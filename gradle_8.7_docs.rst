.. code-block:: bash

   subl -n 'C:\Users\OCEAN\.gradle\caches\transforms-4\69955912123c68eecd096b71c66ee211'
   pushd 'C:\dl\pl\gradle-8.7.0\platforms\documentation\docs\src'

   #du -hd 2 'docs' | sort -h
   #find -type f -path '*.md'
   
   while read -r it; do
      if [[ $it == "" ]]; then
         continue
      fi
      if [[ $it =~ "/Sample:" ]] || [[ $it =~ "/Topic:" ]] || [[ $it =~ "/Section:" ]]; then 
         echo $it
         echo $it | sed -n 's/./=/gp'
         continue
      fi
      if [[ $it =~ "samples/" ]]; then
         echo $it
      else
         echo $it
         echo $it | sed -n 's/./=/gp'
      fi
      if [[ $it =~ ".md" ]]; then
         echo pandoc -t rst -r markdown "$it"
         continue
      fi
      printf '\n.. code-block::\n'
      sed -n 's/.*/   \0/p' "$it" 

   done <<EOF
   docs/kotlin/Module.md
   docs/release/notes-template.md
   docs/release/notes.md
   docs/design/gradle-module-metadata-1.0-specification.md
   docs/design/gradle-module-metadata-latest-specification.md

    /Topic: 游댯 Overview
    docs/userguide/userguide_single.adoc
    docs/userguide/overview/userguide.adoc
    docs/userguide/overview/about_manual.adoc

    /Topic: 游댯 Release
    docs/userguide/releases/installation.adoc
    docs/userguide/releases/compatibility.adoc
    docs/userguide/releases/feature_lifecycle.adoc
    docs/userguide/releases/migrating/migrating_from_ant.adoc
    docs/userguide/releases/migrating/migrating_from_maven.adoc
    docs/userguide/releases/upgrading/upgrading_version_4.adoc
    docs/userguide/releases/upgrading/upgrading_version_5.adoc
    docs/userguide/releases/upgrading/upgrading_version_6.adoc
    docs/userguide/releases/upgrading/upgrading_version_7.adoc
    docs/userguide/releases/upgrading/upgrading_version_8.adoc
    docs/userguide/troubleshooting/validation_problems.adoc
    docs/userguide/troubleshooting/version_catalog_problems.adoc

    /Topic: 游댯 Running Gradle Builds
    docs/userguide/running-builds/introduction/gradle_basics.adoc
    docs/userguide/running-builds/introduction/gradle_wrapper_basics.adoc
    docs/userguide/running-builds/introduction/command_line_interface_basics.adoc
    docs/userguide/running-builds/introduction/settings_file_basics.adoc
    docs/userguide/running-builds/introduction/build_file_basics.adoc
    docs/userguide/running-builds/introduction/dependency_management_basics.adoc
    docs/userguide/running-builds/introduction/task_basics.adoc
    docs/userguide/running-builds/introduction/plugin_basics.adoc
    docs/userguide/running-builds/introduction/gradle_optimizations.adoc
    docs/userguide/running-builds/introduction/build_scans.adoc

    /Section: 游릭 Core Concepts
    docs/userguide/running-builds/getting_started_eng.adoc
    docs/userguide/running-builds/tutorial/part1_gradle_init.adoc
    docs/userguide/running-builds/tutorial/part2_gradle_tasks.adoc
    docs/userguide/running-builds/tutorial/part3_gradle_dep_man.adoc
    docs/userguide/running-builds/tutorial/part4_gradle_plugins.adoc
    docs/userguide/running-builds/tutorial/part5_gradle_inc_builds.adoc
    docs/userguide/running-builds/tutorial/part6_gradle_caching.adoc
    docs/userguide/running-builds/tutorial/part7_gradle_refs.adoc

    /Section: 游릭 Other Topics
    docs/userguide/running-builds/additional/continuous_builds.adoc
    docs/userguide/running-builds/additional/gradle_ides.adoc


    /Topic: 游댯 Authoring Gradle Builds
    docs/userguide/authoring-builds/getting_started_dev.adoc
    docs/userguide/authoring-builds/plugins/designing_gradle_plugins.adoc
    docs/userguide/authoring-builds/structuring/fine_tuning_project_layout.adoc
    docs/userguide/authoring-builds/structuring/structuring_software_products.adoc
    docs/userguide/authoring-builds/structuring/structuring_software_products_details.adoc
    docs/userguide/authoring-builds/tasks/task_configuration_avoidance.adoc

    /Section: 游릭 The Basics

    docs/userguide/authoring-builds/basics/gradle_directories.adoc
    docs/userguide/authoring-builds/basics/intro_multi_project_builds.adoc
    docs/userguide/authoring-builds/basics/build_lifecycle.adoc
    docs/userguide/authoring-builds/basics/writing_settings_files.adoc
    docs/userguide/authoring-builds/basics/writing_build_scripts.adoc
    docs/userguide/authoring-builds/basics/tutorial_using_tasks.adoc
    docs/userguide/authoring-builds/basics/writing_tasks.adoc
    docs/userguide/authoring-builds/basics/plugins.adoc
    docs/userguide/authoring-builds/basics/writing_plugins.adoc

    /Section: 游릭 Structuring Builds

    docs/userguide/authoring-builds/tutorial/partr1_gradle_init.adoc
    docs/userguide/authoring-builds/tutorial/partr2_build_lifecycle.adoc
    docs/userguide/authoring-builds/tutorial/partr3_multi_project_builds.adoc
    docs/userguide/authoring-builds/tutorial/partr4_settings_file.adoc
    docs/userguide/authoring-builds/tutorial/partr5_build_scripts.adoc
    docs/userguide/authoring-builds/tutorial/partr6_writing_tasks.adoc
    docs/userguide/authoring-builds/tutorial/partr7_writing_plugins.adoc

    /Section: 游릭 Structuring Builds

    docs/userguide/authoring-builds/structuring/multi_project_builds.adoc
    docs/userguide/authoring-builds/structuring/declaring_dependencies_between_subprojects.adoc
    docs/userguide/authoring-builds/structuring/sharing_build_logic_between_subprojects.adoc
    docs/userguide/authoring-builds/structuring/composite_builds.adoc
    docs/userguide/authoring-builds/structuring/multi_project_configuration_and_execution.adoc

    /Section: 游릭 Developing Tasks

    docs/userguide/authoring-builds/tasks/more_about_tasks.adoc
    docs/userguide/authoring-builds/tasks/lifecycle_tasks.adoc
    docs/userguide/authoring-builds/tasks/actionable_tasks.adoc
    docs/userguide/authoring-builds/tasks/lazy_configuration.adoc
    docs/userguide/authoring-builds/tasks/worker_api.adoc
    docs/userguide/authoring-builds/tasks/custom_tasks.adoc

    /Section: 游릭 Developing Plugins

    docs/userguide/authoring-builds/plugins/custom_plugins.adoc
    docs/userguide/authoring-builds/plugins/implementing_gradle_plugins.adoc
    docs/userguide/authoring-builds/plugins/implementing_gradle_plugins_precompiled.adoc
    docs/userguide/authoring-builds/plugins/implementing_gradle_plugins_binary.adoc
    docs/userguide/authoring-builds/plugins/testing_gradle_plugins.adoc
    docs/userguide/authoring-builds/plugins/publishing_gradle_plugins.adoc

    /Section: 游릭 Best Practices

    docs/userguide/authoring-builds/best-practices/organizing_gradle_projects.adoc
    docs/userguide/authoring-builds/best-practices/authoring_maintainable_build_scripts.adoc

    /Section: 游릭 Other Topics

    docs/userguide/authoring-builds/other/directory_layout.adoc
    docs/userguide/authoring-builds/other/working_with_files.adoc
    docs/userguide/authoring-builds/other/logging.adoc
    docs/userguide/authoring-builds/other/potential_traps.adoc
    docs/userguide/authoring-builds/other/build_environment.adoc
    docs/userguide/authoring-builds/other/init_scripts.adoc
    docs/userguide/authoring-builds/other/custom_gradle_types.adoc
    docs/userguide/authoring-builds/other/build_services.adoc
    docs/userguide/authoring-builds/other/dataflow_actions.adoc
    docs/userguide/authoring-builds/other/test_kit.adoc
    docs/userguide/authoring-builds/other/ant.adoc

    /Topic: 游댯 Authoring JVM Builds

    docs/userguide/jvm/building_java_projects.adoc
    docs/userguide/jvm/java_testing.adoc
    docs/userguide/jvm/dependency_management_for_java_projects.adoc

    /Section: 游릭 Java Toolchains

    docs/userguide/jvm/toolchains.adoc
    docs/userguide/jvm/toolchain_plugins.adoc

    /Section: 游릭 JVM Plugins
    docs/userguide/jvm/java_library_plugin.adoc
    docs/userguide/jvm/application_plugin.adoc
    docs/userguide/jvm/java_platform_plugin.adoc
    docs/userguide/jvm/groovy_plugin.adoc
    docs/userguide/jvm/scala_plugin.adoc

    /Topic: 游댯 Working With Dependencies

    docs/userguide/dep-man/dependency_management.adoc
    docs/userguide/dep-man/dependency_management_terminology.adoc

    /Section: 游릭 The Basics

    docs/userguide/dep-man/01-core-dependency-management/core_dependency_management.adoc
    docs/userguide/dep-man/01-core-dependency-management/declaring_repositories.adoc
    docs/userguide/dep-man/01-core-dependency-management/declaring_dependencies.adoc
    docs/userguide/dep-man/01-core-dependency-management/library_vs_application.adoc
    docs/userguide/dep-man/01-core-dependency-management/viewing_debugging_dependencies.adoc
    docs/userguide/dep-man/01-core-dependency-management/dependency_resolution.adoc
    docs/userguide/dep-man/01-core-dependency-management/dependency_verification.adoc

    /Section: 游릭 Declaring Versions

    docs/userguide/dep-man/02-declaring-dependency-versions/single_versions.adoc
    docs/userguide/dep-man/02-declaring-dependency-versions/rich_versions.adoc
    docs/userguide/dep-man/02-declaring-dependency-versions/dynamic_versions.adoc
    docs/userguide/dep-man/02-declaring-dependency-versions/dependency_locking.adoc

    /Section: 游릭 Controlling Transitives

    docs/userguide/dep-man/03-controlling-transitive-dependencies/dependency_constraints.adoc
    docs/userguide/dep-man/03-controlling-transitive-dependencies/dependency_downgrade_and_exclude.adoc
    docs/userguide/dep-man/03-controlling-transitive-dependencies/platforms.adoc
    docs/userguide/dep-man/03-controlling-transitive-dependencies/dependency_version_alignment.adoc
    docs/userguide/dep-man/03-controlling-transitive-dependencies/dependency_capability_conflict.adoc
    docs/userguide/dep-man/03-controlling-transitive-dependencies/component_metadata_rules.adoc
    docs/userguide/dep-man/03-controlling-transitive-dependencies/resolution_rules.adoc
    docs/userguide/dep-man/03-controlling-transitive-dependencies/resolution_strategy_tuning.adoc

    /Section: 游릭 Producing And Consuming Variants Of Libraries

    docs/userguide/dep-man/04-modeling-features/component_capabilities.adoc
    docs/userguide/dep-man/04-modeling-features/feature_variants.adoc
    docs/userguide/dep-man/04-modeling-features/variant_model.adoc
    docs/userguide/dep-man/04-modeling-features/variant_attributes.adoc
    docs/userguide/dep-man/04-modeling-features/cross_project_publications.adoc
    docs/userguide/dep-man/04-modeling-features/artifact_transforms.adoc

    /Section: 游릭 Publishing Libraries

    docs/userguide/dep-man/06-publishing/publishing_setup.adoc
    docs/userguide/dep-man/06-publishing/publishing_gradle_module_metadata.adoc
    docs/userguide/dep-man/06-publishing/publishing_signing.adoc
    docs/userguide/dep-man/06-publishing/publishing_customization.adoc

    /Topic: 游댯 Optimizing Build Performance

    docs/userguide/optimizing-performance/performance.adoc
    docs/userguide/optimizing-performance/gradle_daemon.adoc
    docs/userguide/optimizing-performance/file_system_watching.adoc
    docs/userguide/optimizing-performance/incremental_build.adoc
    docs/userguide/optimizing-performance/configuration_cache.adoc
    docs/userguide/optimizing-performance/inspect.adoc
    docs/userguide/optimizing-performance/config_gradle.adoc
    docs/userguide/optimizing-performance/project_properties.adoc
    docs/userguide/optimizing-performance/networking.adoc

    /Section: 游릭 Using The Build Cache

    docs/userguide/optimizing-performance/build-cache/build_cache.adoc
    docs/userguide/optimizing-performance/build-cache/build_cache_use_cases.adoc
    docs/userguide/optimizing-performance/build-cache/build_cache_performance.adoc
    docs/userguide/optimizing-performance/build-cache/build_cache_concepts.adoc
    docs/userguide/optimizing-performance/build-cache/caching_java_projects.adoc
    docs/userguide/optimizing-performance/build-cache/caching_android_projects.adoc
    docs/userguide/optimizing-performance/build-cache/build_cache_debugging.adoc
    docs/userguide/optimizing-performance/build-cache/common_caching_problems.adoc

    /Topic: 游댯 Authoring C++/Swift Builds
    docs/userguide/native/native_software.adoc
    docs/userguide/native/building_cpp_projects.adoc
    docs/userguide/native/cpp_testing.adoc
    docs/userguide/native/building_swift_projects.adoc
    docs/userguide/native/swift_testing.adoc

    /Topic: 游댯 Gradle On CI

    docs/userguide/reference/ci-systems/jenkins.adoc
    docs/userguide/reference/ci-systems/teamcity.adoc
    docs/userguide/reference/ci-systems/github-actions.adoc
    docs/userguide/reference/ci-systems/travis-ci.adoc

    /Topic: 游댯 Reference

    docs/userguide/reference/command_line_interface.adoc
    docs/userguide/reference/gradle_wrapper.adoc
    docs/userguide/reference/third_party_integration.adoc

    /Section: 游릭 Gradle DSLs and API

    https://docs.gradle.org/current/javadoc/index.html
    docs/userguide/api/groovy_build_script_primer.adoc
    docs/userguide/api/kotlin_dsl.adoc
    docs/userguide/releases/migrating/migrating_from_groovy_to_kotlin_dsl.adoc
    `Groovy DSL Reference <https://docs.gradle.org/current/dsl/index.html>`__
    `Kotlin DSL Reference <https://docs.gradle.org/current/kotlin-dsl/index.html>`__
    `Samples <https://docs.gradle.org/current/samples/index.html>`__

    /Topic: 游댯 Gradle Plugin Reference
    docs/userguide/core-plugins/plugin_reference.adoc

    /Section: 游릭 JVM languages and frameworks
    docs/userguide/jvm/java_plugin.adoc
    docs/userguide/core-plugins/antlr_plugin.adoc
    docs/userguide/jvm/jvm_test_suite_plugin.adoc
    docs/userguide/jvm/test_report_aggregation_plugin.adoc

    /Section: 游릭 Native languages
    docs/userguide/native/cpp_application_plugin.adoc
    docs/userguide/native/cpp_library_plugin.adoc
    docs/userguide/native/cpp_unit_test_plugin.adoc
    docs/userguide/native/swift_application_plugin.adoc
    docs/userguide/native/swift_library_plugin.adoc
    docs/userguide/native/xctest_plugin.adoc

    /Section: 游릭 Packaging and distribution
    docs/userguide/core-plugins/war_plugin.adoc
    docs/userguide/core-plugins/ear_plugin.adoc
    docs/userguide/dep-man/06-publishing/publishing_maven.adoc
    docs/userguide/dep-man/06-publishing/publishing_ivy.adoc
    docs/userguide/core-plugins/distribution_plugin.adoc
    docs/userguide/jvm/java_library_distribution_plugin.adoc

    /Section: 游릭 Code analysis
    docs/userguide/core-plugins/checkstyle_plugin.adoc
    docs/userguide/core-plugins/pmd_plugin.adoc
    docs/userguide/core-plugins/jacoco_plugin.adoc
    docs/userguide/jvm/jacoco_report_aggregation_plugin.adoc
    docs/userguide/core-plugins/codenarc_plugin.adoc

    /Section: 游릭 IDE integration
    docs/userguide/core-plugins/eclipse_plugin.adoc
    docs/userguide/core-plugins/idea_plugin.adoc
    docs/userguide/core-plugins/visual_studio_plugin.adoc
    docs/userguide/native/xcode_plugin.adoc

    /Section: 游릭 Utility
    docs/userguide/core-plugins/base_plugin.adoc
    docs/userguide/core-plugins/build_init_plugin.adoc
    docs/userguide/dep-man/06-publishing/signing_plugin.adoc
    docs/userguide/core-plugins/java_gradle_plugin.adoc
    docs/userguide/core-plugins/project_report_plugin.adoc

    /Topic: 游댯 License Information

    docs/userguide/licenses.adoc

    /Topic: 游댯 Others
    docs/userguide/core-plugins/build_dashboard_plugin.adoc
    docs/userguide/jvm/javaProjectGenericLayout.adoc
    docs/userguide/jvm/javaProjectMainLayout.adoc
    docs/userguide/jvm/javaProjectTestLayout.adoc
    docs/userguide/legacy/rule_source.adoc
    docs/userguide/optimizing-performance/isolated_projects.adoc

    /Topic: 游댯 Graphs
    docs/userguide/img/cpp-application-configurations.dot
    docs/userguide/img/cpp-application-task-graph.dot
    docs/userguide/img/cpp-application-variant-task-graph.dot
    docs/userguide/img/cpp-library-configurations.dot
    docs/userguide/img/cpp-library-variant-task-graph.dot
    docs/userguide/img/cpp-shared-library-task-graph.dot
    docs/userguide/img/cpp-sourcesets-compilation.dot
    docs/userguide/img/cpp-static-library-task-graph.dot
    docs/userguide/img/cpp-unit-test-configurations.dot
    docs/userguide/img/cpp-unit-test-task-graph.dot
    docs/userguide/img/cpp-unit-test-variant-task-graph.dot
    docs/userguide/img/java-library-ignore-deprecated-main.dot
    docs/userguide/img/java-library-ignore-deprecated-test.dot
    docs/userguide/img/java-main-configurations.dot
    docs/userguide/img/java-test-configurations.dot
    docs/userguide/img/plugin-markers.puml
    docs/userguide/img/software_architecture.puml
    docs/userguide/img/swift-application-configurations.dot
    docs/userguide/img/swift-application-task-graph.dot
    docs/userguide/img/swift-application-variant-task-graph.dot
    docs/userguide/img/swift-library-configurations.dot
    docs/userguide/img/swift-library-variant-task-graph.dot
    docs/userguide/img/swift-shared-library-task-graph.dot
    docs/userguide/img/swift-sourcesets-compilation.dot
    docs/userguide/img/swift-static-library-task-graph.dot
    docs/userguide/img/visual-studio-task-graph.dot
    docs/userguide/img/xcode-task-graph.dot
    docs/userguide/img/xctest-configurations.dot
    docs/userguide/img/xctest-task-graph.dot
    docs/userguide/img/xctest-variant-task-graph.dot


    /Sample: android-application
    samples/android-application/README.adoc
    samples/android-application/groovy/app/build.gradle
    samples/android-application/groovy/settings.gradle
    samples/android-application/kotlin/app/build.gradle.kts
    samples/android-application/kotlin/settings.gradle.kts
    samples/android-application/tests/buildTask.sample.conf
    samples/android-application/tests/sanityCheck.sample.conf

    /Sample: build-organization/composite-builds/basic
    samples/build-organization/composite-builds/basic/README.adoc
    samples/build-organization/composite-builds/basic/groovy/build.gradle
    samples/build-organization/composite-builds/basic/groovy/my-app/app/build.gradle
    samples/build-organization/composite-builds/basic/groovy/my-app/app/src/main/java/org/sample/myapp/Main.java
    samples/build-organization/composite-builds/basic/groovy/my-app/settings.gradle
    samples/build-organization/composite-builds/basic/groovy/my-utils/number-utils/build.gradle
    samples/build-organization/composite-builds/basic/groovy/my-utils/number-utils/src/main/java/org/sample/numberutils/Numbers.java
    samples/build-organization/composite-builds/basic/groovy/my-utils/settings.gradle
    samples/build-organization/composite-builds/basic/groovy/my-utils/string-utils/build.gradle
    samples/build-organization/composite-builds/basic/groovy/my-utils/string-utils/src/main/java/org/sample/stringutils/Strings.java
    samples/build-organization/composite-builds/basic/groovy/settings.gradle
    samples/build-organization/composite-builds/basic/kotlin/build.gradle.kts
    samples/build-organization/composite-builds/basic/kotlin/my-app/app/build.gradle.kts
    samples/build-organization/composite-builds/basic/kotlin/my-app/app/src/main/java/org/sample/myapp/Main.java
    samples/build-organization/composite-builds/basic/kotlin/my-app/settings.gradle.kts
    samples/build-organization/composite-builds/basic/kotlin/my-utils/number-utils/build.gradle.kts
    samples/build-organization/composite-builds/basic/kotlin/my-utils/number-utils/src/main/java/org/sample/numberutils/Numbers.java
    samples/build-organization/composite-builds/basic/kotlin/my-utils/settings.gradle.kts
    samples/build-organization/composite-builds/basic/kotlin/my-utils/string-utils/build.gradle.kts
    samples/build-organization/composite-builds/basic/kotlin/my-utils/string-utils/src/main/java/org/sample/stringutils/Strings.java
    samples/build-organization/composite-builds/basic/kotlin/settings.gradle.kts
    samples/build-organization/composite-builds/basic/tests/basicCli.out
    samples/build-organization/composite-builds/basic/tests/basicCli.sample.conf
    samples/build-organization/composite-builds/basic/tests/compositeRootProject.out
    samples/build-organization/composite-builds/basic/tests/compositeRootProject.sample.conf
    samples/build-organization/composite-builds/basic/tests/sanityCheck.sample.conf

    /Sample: build-organization/composite-builds/declared-substitution
    samples/build-organization/composite-builds/declared-substitution/README.adoc
    samples/build-organization/composite-builds/declared-substitution/groovy/anonymous-library/build.gradle
    samples/build-organization/composite-builds/declared-substitution/groovy/anonymous-library/settings.gradle
    samples/build-organization/composite-builds/declared-substitution/groovy/anonymous-library/src/main/java/org/sample/numberutils/Numbers.java
    samples/build-organization/composite-builds/declared-substitution/groovy/app/build.gradle
    samples/build-organization/composite-builds/declared-substitution/groovy/app/src/main/java/org/sample/myapp/Main.java
    samples/build-organization/composite-builds/declared-substitution/groovy/settings.gradle
    samples/build-organization/composite-builds/declared-substitution/kotlin/anonymous-library/build.gradle.kts
    samples/build-organization/composite-builds/declared-substitution/kotlin/anonymous-library/settings.gradle.kts
    samples/build-organization/composite-builds/declared-substitution/kotlin/anonymous-library/src/main/java/org/sample/numberutils/Numbers.java
    samples/build-organization/composite-builds/declared-substitution/kotlin/app/build.gradle.kts
    samples/build-organization/composite-builds/declared-substitution/kotlin/app/src/main/java/org/sample/myapp/Main.java
    samples/build-organization/composite-builds/declared-substitution/kotlin/settings.gradle.kts
    samples/build-organization/composite-builds/declared-substitution/tests/sanityCheck.sample.conf
    samples/build-organization/composite-builds/declared-substitution/tests/withDeclaredSubstitution.out
    samples/build-organization/composite-builds/declared-substitution/tests/withDeclaredSubstitution.sample.conf

    /Sample: build-organization/composite-builds/hierarchical-multirepo
    samples/build-organization/composite-builds/hierarchical-multirepo/README.adoc
    samples/build-organization/composite-builds/hierarchical-multirepo/groovy/app/build.gradle
    samples/build-organization/composite-builds/hierarchical-multirepo/groovy/app/src/main/java/org/sample/myapp/Main.java
    samples/build-organization/composite-builds/hierarchical-multirepo/groovy/build.gradle
    samples/build-organization/composite-builds/hierarchical-multirepo/groovy/modules/number-utils/build.gradle
    samples/build-organization/composite-builds/hierarchical-multirepo/groovy/modules/number-utils/settings.gradle
    samples/build-organization/composite-builds/hierarchical-multirepo/groovy/modules/number-utils/src/main/java/org/sample/numberutils/Numbers.java
    samples/build-organization/composite-builds/hierarchical-multirepo/groovy/modules/string-utils/build.gradle
    samples/build-organization/composite-builds/hierarchical-multirepo/groovy/modules/string-utils/settings.gradle
    samples/build-organization/composite-builds/hierarchical-multirepo/groovy/modules/string-utils/src/main/java/org/sample/stringutils/Strings.java
    samples/build-organization/composite-builds/hierarchical-multirepo/groovy/settings.gradle
    samples/build-organization/composite-builds/hierarchical-multirepo/kotlin/app/build.gradle.kts
    samples/build-organization/composite-builds/hierarchical-multirepo/kotlin/app/src/main/java/org/sample/myapp/Main.java
    samples/build-organization/composite-builds/hierarchical-multirepo/kotlin/build.gradle.kts
    samples/build-organization/composite-builds/hierarchical-multirepo/kotlin/modules/number-utils/build.gradle.kts
    samples/build-organization/composite-builds/hierarchical-multirepo/kotlin/modules/number-utils/settings.gradle.kts
    samples/build-organization/composite-builds/hierarchical-multirepo/kotlin/modules/number-utils/src/main/java/org/sample/numberutils/Numbers.java
    samples/build-organization/composite-builds/hierarchical-multirepo/kotlin/modules/string-utils/build.gradle.kts
    samples/build-organization/composite-builds/hierarchical-multirepo/kotlin/modules/string-utils/settings.gradle.kts
    samples/build-organization/composite-builds/hierarchical-multirepo/kotlin/modules/string-utils/src/main/java/org/sample/stringutils/Strings.java
    samples/build-organization/composite-builds/hierarchical-multirepo/kotlin/settings.gradle.kts
    samples/build-organization/composite-builds/hierarchical-multirepo/tests/runComposite.out
    samples/build-organization/composite-builds/hierarchical-multirepo/tests/runComposite.sample.conf
    samples/build-organization/composite-builds/hierarchical-multirepo/tests/sanityCheck.sample.conf

    /Sample: build-organization/composite-builds/plugin-dev
    samples/build-organization/composite-builds/plugin-dev/README.adoc
    samples/build-organization/composite-builds/plugin-dev/groovy/greeting-plugin/build.gradle
    samples/build-organization/composite-builds/plugin-dev/groovy/greeting-plugin/settings.gradle
    samples/build-organization/composite-builds/plugin-dev/groovy/greeting-plugin/src/main/java/org/sample/GreetingExtension.java
    samples/build-organization/composite-builds/plugin-dev/groovy/greeting-plugin/src/main/java/org/sample/GreetingPlugin.java
    samples/build-organization/composite-builds/plugin-dev/groovy/greeting-plugin/src/main/java/org/sample/GreetingTask.java
    samples/build-organization/composite-builds/plugin-dev/groovy/my-greeting-app/build.gradle
    samples/build-organization/composite-builds/plugin-dev/groovy/settings.gradle
    samples/build-organization/composite-builds/plugin-dev/kotlin/greeting-plugin/build.gradle.kts
    samples/build-organization/composite-builds/plugin-dev/kotlin/greeting-plugin/settings.gradle.kts
    samples/build-organization/composite-builds/plugin-dev/kotlin/greeting-plugin/src/main/java/org/sample/GreetingExtension.java
    samples/build-organization/composite-builds/plugin-dev/kotlin/greeting-plugin/src/main/java/org/sample/GreetingPlugin.java
    samples/build-organization/composite-builds/plugin-dev/kotlin/greeting-plugin/src/main/java/org/sample/GreetingTask.java
    samples/build-organization/composite-builds/plugin-dev/kotlin/my-greeting-app/build.gradle.kts
    samples/build-organization/composite-builds/plugin-dev/kotlin/settings.gradle.kts
    samples/build-organization/composite-builds/plugin-dev/tests/compositeBuilds_plugin_dev.out
    samples/build-organization/composite-builds/plugin-dev/tests/compositeBuilds_plugin_dev.sample.conf
    samples/build-organization/composite-builds/plugin-dev/tests/sanityCheck.sample.conf

    /Sample: build-organization/cross-project-output-sharing
    samples/build-organization/cross-project-output-sharing/README.adoc
    samples/build-organization/cross-project-output-sharing/groovy/consumer/build.gradle
    samples/build-organization/cross-project-output-sharing/groovy/producer/build.gradle
    samples/build-organization/cross-project-output-sharing/groovy/settings.gradle
    samples/build-organization/cross-project-output-sharing/kotlin/consumer/build.gradle.kts
    samples/build-organization/cross-project-output-sharing/kotlin/producer/build.gradle.kts
    samples/build-organization/cross-project-output-sharing/kotlin/settings.gradle.kts
    samples/build-organization/cross-project-output-sharing/tests/check.out
    samples/build-organization/cross-project-output-sharing/tests/check.sample.conf

    /Sample: build-organization/gradle-plugin
    samples/build-organization/gradle-plugin/README.adoc
    samples/build-organization/gradle-plugin/groovy/greeting-plugin/build.gradle
    samples/build-organization/gradle-plugin/groovy/settings.gradle
    samples/build-organization/gradle-plugin/kotlin/greeting-plugin/build.gradle.kts
    samples/build-organization/gradle-plugin/kotlin/settings.gradle.kts
    samples/build-organization/gradle-plugin/tests/check.out
    samples/build-organization/gradle-plugin/tests/check.sample.conf

    /Sample: build-organization/multi-project-with-convention-plugins
    samples/build-organization/multi-project-with-convention-plugins/README.adoc
    samples/build-organization/multi-project-with-convention-plugins/groovy/buildSrc/build.gradle
    samples/build-organization/multi-project-with-convention-plugins/groovy/buildSrc/settings.gradle
    samples/build-organization/multi-project-with-convention-plugins/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle
    samples/build-organization/multi-project-with-convention-plugins/groovy/buildSrc/src/main/groovy/myproject.library-conventions.gradle
    samples/build-organization/multi-project-with-convention-plugins/groovy/buildSrc/src/test/groovy/com/example/JavaConventionPluginTest.groovy
    samples/build-organization/multi-project-with-convention-plugins/groovy/buildSrc/src/test/groovy/com/example/LibraryPluginTest.groovy
    samples/build-organization/multi-project-with-convention-plugins/groovy/buildSrc/src/test/groovy/com/example/PluginTest.groovy
    samples/build-organization/multi-project-with-convention-plugins/groovy/internal-module/build.gradle
    samples/build-organization/multi-project-with-convention-plugins/groovy/library-a/build.gradle
    samples/build-organization/multi-project-with-convention-plugins/groovy/library-a/README.md
    samples/build-organization/multi-project-with-convention-plugins/groovy/library-b/build.gradle
    samples/build-organization/multi-project-with-convention-plugins/groovy/library-b/README.md
    samples/build-organization/multi-project-with-convention-plugins/groovy/settings.gradle
    samples/build-organization/multi-project-with-convention-plugins/kotlin/buildSrc/build.gradle.kts
    samples/build-organization/multi-project-with-convention-plugins/kotlin/buildSrc/settings.gradle.kts
    samples/build-organization/multi-project-with-convention-plugins/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts
    samples/build-organization/multi-project-with-convention-plugins/kotlin/buildSrc/src/main/kotlin/myproject.library-conventions.gradle.kts
    samples/build-organization/multi-project-with-convention-plugins/kotlin/buildSrc/src/test/kotlin/com/example/JavaConventionPluginTest.kt
    samples/build-organization/multi-project-with-convention-plugins/kotlin/buildSrc/src/test/kotlin/com/example/LibraryPluginTest.kt
    samples/build-organization/multi-project-with-convention-plugins/kotlin/buildSrc/src/test/kotlin/com/example/PluginTest.kt
    samples/build-organization/multi-project-with-convention-plugins/kotlin/internal-module/build.gradle.kts
    samples/build-organization/multi-project-with-convention-plugins/kotlin/library-a/build.gradle.kts
    samples/build-organization/multi-project-with-convention-plugins/kotlin/library-a/README.md
    samples/build-organization/multi-project-with-convention-plugins/kotlin/library-b/build.gradle.kts
    samples/build-organization/multi-project-with-convention-plugins/kotlin/library-b/README.md
    samples/build-organization/multi-project-with-convention-plugins/kotlin/settings.gradle.kts
    samples/build-organization/multi-project-with-convention-plugins/tests/check.sample.conf

    /Sample: build-organization/publishing-convention-plugins
    samples/build-organization/publishing-convention-plugins/README.adoc
    samples/build-organization/publishing-convention-plugins/groovy/convention-plugins/build.gradle
    samples/build-organization/publishing-convention-plugins/groovy/convention-plugins/settings.gradle
    samples/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/main/groovy/com.myorg.java-conventions.gradle
    samples/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/main/groovy/com.myorg.library-conventions.gradle
    samples/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/main/groovy/com.myorg.service-conventions.gradle
    samples/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/test/groovy/com/myorg/JavaConventionPluginTest.groovy
    samples/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/test/groovy/com/myorg/LibraryPluginTest.groovy
    samples/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/test/groovy/com/myorg/PluginTest.groovy
    samples/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/test/groovy/com/myorg/ServicePluginTest.groovy
    samples/build-organization/publishing-convention-plugins/groovy/settings.gradle
    samples/build-organization/publishing-convention-plugins/kotlin/convention-plugins/build.gradle.kts
    samples/build-organization/publishing-convention-plugins/kotlin/convention-plugins/settings.gradle.kts
    samples/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/main/kotlin/com.myorg.java-conventions.gradle.kts
    samples/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/main/kotlin/com.myorg.library-conventions.gradle.kts
    samples/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/main/kotlin/com.myorg.service-conventions.gradle.kts
    samples/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/test/kotlin/com/myorg/JavaConventionPluginTest.kt
    samples/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/test/kotlin/com/myorg/LibraryPluginTest.kt
    samples/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/test/kotlin/com/myorg/PluginTest.kt
    samples/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/test/kotlin/com/myorg/ServicePluginTest.kt
    samples/build-organization/publishing-convention-plugins/kotlin/settings.gradle.kts
    samples/build-organization/publishing-convention-plugins/tests/publish.sample.conf

    /Sample: build-organization/sharing-convention-plugins-with-build-logic
    samples/build-organization/sharing-convention-plugins-with-build-logic/README.adoc
    samples/build-organization/sharing-convention-plugins-with-build-logic/groovy/application/build.gradle
    samples/build-organization/sharing-convention-plugins-with-build-logic/groovy/build-conventions/build.gradle
    samples/build-organization/sharing-convention-plugins-with-build-logic/groovy/build-conventions/settings.gradle
    samples/build-organization/sharing-convention-plugins-with-build-logic/groovy/build-conventions/src/main/groovy/myproject.java-conventions.gradle
    samples/build-organization/sharing-convention-plugins-with-build-logic/groovy/buildSrc/build.gradle
    samples/build-organization/sharing-convention-plugins-with-build-logic/groovy/buildSrc/src/main/groovy/myproject.greeting.gradle
    samples/build-organization/sharing-convention-plugins-with-build-logic/groovy/buildSrc/src/main/java/com/example/GreetingTask.java
    samples/build-organization/sharing-convention-plugins-with-build-logic/groovy/list/build.gradle
    samples/build-organization/sharing-convention-plugins-with-build-logic/groovy/settings.gradle
    samples/build-organization/sharing-convention-plugins-with-build-logic/groovy/utilities/build.gradle
    samples/build-organization/sharing-convention-plugins-with-build-logic/kotlin/application/build.gradle.kts
    samples/build-organization/sharing-convention-plugins-with-build-logic/kotlin/build-conventions/build.gradle.kts
    samples/build-organization/sharing-convention-plugins-with-build-logic/kotlin/build-conventions/settings.gradle.kts
    samples/build-organization/sharing-convention-plugins-with-build-logic/kotlin/build-conventions/src/main/kotlin/myproject.java-conventions.gradle.kts
    samples/build-organization/sharing-convention-plugins-with-build-logic/kotlin/buildSrc/build.gradle.kts
    samples/build-organization/sharing-convention-plugins-with-build-logic/kotlin/buildSrc/src/main/java/com/example/GreetingTask.java
    samples/build-organization/sharing-convention-plugins-with-build-logic/kotlin/buildSrc/src/main/kotlin/myproject.greeting.gradle.kts
    samples/build-organization/sharing-convention-plugins-with-build-logic/kotlin/list/build.gradle.kts
    samples/build-organization/sharing-convention-plugins-with-build-logic/kotlin/settings.gradle.kts
    samples/build-organization/sharing-convention-plugins-with-build-logic/kotlin/utilities/build.gradle.kts
    samples/build-organization/sharing-convention-plugins-with-build-logic/tests/check.sample.conf
    samples/build-organization/sharing-convention-plugins-with-build-logic/tests/greet.out
    samples/build-organization/sharing-convention-plugins-with-build-logic/tests/run.out
    samples/build-organization/sharing-convention-plugins-with-build-logic/tests/sanityCheck.sample.conf

    /Sample: build-organization/structuring-software-projects
    samples/build-organization/structuring-software-projects/README.adoc
    samples/build-organization/structuring-software-projects/groovy/build.gradle
    samples/build-organization/structuring-software-projects/groovy/settings.gradle
    samples/build-organization/structuring-software-projects/groovy/admin-feature/config/build.gradle
    samples/build-organization/structuring-software-projects/groovy/admin-feature/settings.gradle
    samples/build-organization/structuring-software-projects/groovy/aggregation/settings.gradle
    samples/build-organization/structuring-software-projects/groovy/aggregation/test-coverage/build.gradle
    samples/build-organization/structuring-software-projects/groovy/android-app/app/build.gradle
    samples/build-organization/structuring-software-projects/groovy/android-app/settings.gradle
    samples/build-organization/structuring-software-projects/groovy/build-logic/settings.gradle
    samples/build-organization/structuring-software-projects/groovy/build-logic/android-application/build.gradle
    samples/build-organization/structuring-software-projects/groovy/build-logic/android-application/src/main/groovy/com.example.android-application.gradle
    samples/build-organization/structuring-software-projects/groovy/build-logic/commons/build.gradle
    samples/build-organization/structuring-software-projects/groovy/build-logic/commons/src/main/groovy/com.example.commons.gradle
    samples/build-organization/structuring-software-projects/groovy/build-logic/commons/src/main/groovy/com.example.jacoco.gradle
    samples/build-organization/structuring-software-projects/groovy/build-logic/java-library/build.gradle
    samples/build-organization/structuring-software-projects/groovy/build-logic/java-library/src/main/groovy/com.example.java-library.gradle
    samples/build-organization/structuring-software-projects/groovy/build-logic/kotlin-library/build.gradle
    samples/build-organization/structuring-software-projects/groovy/build-logic/kotlin-library/src/main/groovy/com.example.kotlin-library.gradle
    samples/build-organization/structuring-software-projects/groovy/build-logic/report-aggregation/build.gradle
    samples/build-organization/structuring-software-projects/groovy/build-logic/report-aggregation/src/main/groovy/com.example.report-aggregation.gradle
    samples/build-organization/structuring-software-projects/groovy/build-logic/spring-boot-application/build.gradle
    samples/build-organization/structuring-software-projects/groovy/build-logic/spring-boot-application/src/main/groovy/com.example.spring-boot-application.gradle
    samples/build-organization/structuring-software-projects/groovy/domain-model/release/build.gradle
    samples/build-organization/structuring-software-projects/groovy/domain-model/settings.gradle
    samples/build-organization/structuring-software-projects/groovy/platforms/plugins-platform/build.gradle
    samples/build-organization/structuring-software-projects/groovy/platforms/product-platform/build.gradle
    samples/build-organization/structuring-software-projects/groovy/platforms/settings.gradle
    samples/build-organization/structuring-software-projects/groovy/platforms/test-platform/build.gradle
    samples/build-organization/structuring-software-projects/groovy/server-application/app/build.gradle
    samples/build-organization/structuring-software-projects/groovy/server-application/settings.gradle
    samples/build-organization/structuring-software-projects/groovy/state/application-state/build.gradle
    samples/build-organization/structuring-software-projects/groovy/state/settings.gradle
    samples/build-organization/structuring-software-projects/groovy/user-feature/data/build.gradle
    samples/build-organization/structuring-software-projects/groovy/user-feature/settings.gradle
    samples/build-organization/structuring-software-projects/groovy/user-feature/table/build.gradle
    samples/build-organization/structuring-software-projects/kotlin/build.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/settings.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/admin-feature/config/build.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/admin-feature/settings.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/aggregation/settings.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/aggregation/test-coverage/build.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/android-app/app/build.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/android-app/settings.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/build-logic/android-application/build.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/build-logic/android-application/src/main/kotlin/com.example.android-application.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/build-logic/commons/build.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/build-logic/commons/src/main/kotlin/com.example.commons.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/build-logic/commons/src/main/kotlin/com.example.jacoco.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/build-logic/java-library/build.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/build-logic/java-library/src/main/kotlin/com.example.java-library.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/build-logic/kotlin-library/build.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/build-logic/kotlin-library/src/main/kotlin/com.example.kotlin-library.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/build-logic/report-aggregation/build.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/build-logic/report-aggregation/src/main/kotlin/com.example.report-aggregation.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/build-logic/settings.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/build-logic/spring-boot-application/build.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/build-logic/spring-boot-application/src/main/kotlin/com.example.spring-boot-application.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/domain-model/release/build.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/domain-model/settings.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/platforms/plugins-platform/build.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/platforms/product-platform/build.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/platforms/settings.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/platforms/test-platform/build.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/server-application/app/build.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/server-application/settings.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/state/application-state/build.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/state/settings.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/user-feature/data/build.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/user-feature/settings.gradle.kts
    samples/build-organization/structuring-software-projects/kotlin/user-feature/table/build.gradle.kts
    samples/build-organization/structuring-software-projects/tests/aggregate-reports.sample.conf
    samples/build-organization/structuring-software-projects/tests/build-android-app.sample.conf
    samples/build-organization/structuring-software-projects/tests/build-server-application.sample.conf
    samples/build-organization/structuring-software-projects/tests/sanityCheck.sample.conf
    samples/build-organization/structuring-software-projects/tests/umbrella-build.sample.conf

    /Sample: credentials-handling
    samples/credentials-handling/pass-credentials-to-external-tool-via-stdin/README.adoc
    samples/credentials-handling/pass-credentials-to-external-tool-via-stdin/common/login.sh
    samples/credentials-handling/pass-credentials-to-external-tool-via-stdin/groovy/build.gradle
    samples/credentials-handling/pass-credentials-to-external-tool-via-stdin/groovy/settings.gradle
    samples/credentials-handling/pass-credentials-to-external-tool-via-stdin/kotlin/build.gradle.kts
    samples/credentials-handling/pass-credentials-to-external-tool-via-stdin/kotlin/settings.gradle.kts
    samples/credentials-handling/pass-credentials-to-external-tool-via-stdin/tests/commandLineCredentials.out
    samples/credentials-handling/pass-credentials-to-external-tool-via-stdin/tests/commandLineCredentials.sample.conf

    /Sample: credentials-handling
    samples/credentials-handling/publishing-credentials/README.adoc
    samples/credentials-handling/publishing-credentials/common/maven-repository-stub/src/main/java/com/example/MavenRepositoryStub.java
    samples/credentials-handling/publishing-credentials/groovy/build.gradle
    samples/credentials-handling/publishing-credentials/groovy/maven-repository-stub/build.gradle
    samples/credentials-handling/publishing-credentials/groovy/maven-repository-stub/settings.gradle
    samples/credentials-handling/publishing-credentials/groovy/maven-repository-stub/src/main/groovy/maven-repository-stub.gradle
    samples/credentials-handling/publishing-credentials/groovy/settings.gradle
    samples/credentials-handling/publishing-credentials/kotlin/build.gradle.kts
    samples/credentials-handling/publishing-credentials/kotlin/maven-repository-stub/build.gradle.kts
    samples/credentials-handling/publishing-credentials/kotlin/maven-repository-stub/settings.gradle.kts
    samples/credentials-handling/publishing-credentials/kotlin/maven-repository-stub/src/main/kotlin/maven-repository-stub.gradle.kts
    samples/credentials-handling/publishing-credentials/kotlin/settings.gradle.kts
    samples/credentials-handling/publishing-credentials/tests/publishCommandLineCredentials.sample.conf

    /Sample: groovy/library
    samples/groovy/library-publishing/README.adoc
    samples/groovy/library-publishing/groovy/my-library/build.gradle
    samples/groovy/library-publishing/groovy/settings.gradle
    samples/groovy/library-publishing/kotlin/my-library/build.gradle.kts
    samples/groovy/library-publishing/kotlin/settings.gradle.kts
    samples/groovy/library-publishing/tests/publishTask.out
    samples/groovy/library-publishing/tests/publishTask.sample.conf

    /Sample: ide/problems
    samples/ide/problems-api-usage/README.adoc
    samples/ide/problems-api-usage/groovy/build.gradle
    samples/ide/problems-api-usage/groovy/reporters/model-builder-plugin/build.gradle
    samples/ide/problems-api-usage/groovy/reporters/script-plugin/build.gradle
    samples/ide/problems-api-usage/groovy/reporters/script-plugin/src/main/groovy/reporters.script.plugin.gradle
    samples/ide/problems-api-usage/groovy/reporters/standard-plugin/build.gradle
    samples/ide/problems-api-usage/groovy/sample-ide/build.gradle
    samples/ide/problems-api-usage/groovy/sample-project/build.gradle
    samples/ide/problems-api-usage/groovy/sample-project/settings.gradle
    samples/ide/problems-api-usage/groovy/settings.gradle
    samples/ide/problems-api-usage/kotlin/build.gradle.kts
    samples/ide/problems-api-usage/kotlin/reporters/model-builder-plugin/build.gradle.kts
    samples/ide/problems-api-usage/kotlin/reporters/script-plugin/build.gradle.kts
    samples/ide/problems-api-usage/kotlin/reporters/script-plugin/src/main/kotlin/reporters/script.plugin.gradle.kts
    samples/ide/problems-api-usage/kotlin/reporters/standard-plugin/build.gradle.kts
    samples/ide/problems-api-usage/kotlin/sample-ide/build.gradle.kts
    samples/ide/problems-api-usage/kotlin/sample-project/build.gradle.kts
    samples/ide/problems-api-usage/kotlin/sample-project/settings.gradle.kts
    samples/ide/problems-api-usage/kotlin/settings.gradle.kts

    /Sample: incubating/build-organization
    samples/incubating/build-organization/publishing-convention-plugins/README.adoc
    samples/incubating/build-organization/publishing-convention-plugins/groovy/convention-plugins/build.gradle
    samples/incubating/build-organization/publishing-convention-plugins/groovy/convention-plugins/settings.gradle
    samples/incubating/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/main/groovy/com.myorg.java-conventions.gradle
    samples/incubating/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/main/groovy/com.myorg.library-conventions.gradle
    samples/incubating/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/main/groovy/com.myorg.service-conventions.gradle
    samples/incubating/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/test/groovy/com/myorg/JavaConventionPluginTest.groovy
    samples/incubating/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/test/groovy/com/myorg/LibraryPluginTest.groovy
    samples/incubating/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/test/groovy/com/myorg/PluginTest.groovy
    samples/incubating/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/test/groovy/com/myorg/ServicePluginTest.groovy
    samples/incubating/build-organization/publishing-convention-plugins/groovy/settings.gradle
    samples/incubating/build-organization/publishing-convention-plugins/kotlin/convention-plugins/build.gradle.kts
    samples/incubating/build-organization/publishing-convention-plugins/kotlin/convention-plugins/settings.gradle.kts
    samples/incubating/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/main/kotlin/com.myorg.java-conventions.gradle.kts
    samples/incubating/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/main/kotlin/com.myorg.library-conventions.gradle.kts
    samples/incubating/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/main/kotlin/com.myorg.service-conventions.gradle.kts
    samples/incubating/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/test/kotlin/com/myorg/JavaConventionPluginTest.kt
    samples/incubating/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/test/kotlin/com/myorg/LibraryPluginTest.kt
    samples/incubating/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/test/kotlin/com/myorg/PluginTest.kt
    samples/incubating/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/test/kotlin/com/myorg/ServicePluginTest.kt
    samples/incubating/build-organization/publishing-convention-plugins/kotlin/settings.gradle.kts
    samples/incubating/build-organization/publishing-convention-plugins/tests/publish.sample.conf

    /Sample: incubating/java/jvm-multi-project-with-additional-test-types
    samples/incubating/java/jvm-multi-project-with-additional-test-types/README.adoc
    samples/incubating/java/jvm-multi-project-with-additional-test-types/groovy/application/build.gradle
    samples/incubating/java/jvm-multi-project-with-additional-test-types/groovy/buildSrc/build.gradle
    samples/incubating/java/jvm-multi-project-with-additional-test-types/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle
    samples/incubating/java/jvm-multi-project-with-additional-test-types/groovy/list/build.gradle
    samples/incubating/java/jvm-multi-project-with-additional-test-types/groovy/settings.gradle
    samples/incubating/java/jvm-multi-project-with-additional-test-types/groovy/utilities/build.gradle
    samples/incubating/java/jvm-multi-project-with-additional-test-types/kotlin/application/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-additional-test-types/kotlin/buildSrc/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-additional-test-types/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts
    samples/incubating/java/jvm-multi-project-with-additional-test-types/kotlin/list/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-additional-test-types/kotlin/settings.gradle.kts
    samples/incubating/java/jvm-multi-project-with-additional-test-types/kotlin/utilities/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-additional-test-types/tests/checkTask.out
    samples/incubating/java/jvm-multi-project-with-additional-test-types/tests/checkTask.sample.conf

    /Sample: incubating/java/jvm-multi-project-with-code-coverage-distribution
    samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/README.adoc
    samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/groovy/application/build.gradle
    samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/groovy/buildSrc/build.gradle
    samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle
    samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/groovy/list/build.gradle
    samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/groovy/settings.gradle
    samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/groovy/utilities/build.gradle
    samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/kotlin/application/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/kotlin/buildSrc/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts
    samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/kotlin/list/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/kotlin/settings.gradle.kts
    samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/kotlin/utilities/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/tests/testTask.out
    samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/tests/testTask.sample.conf

    /Sample: incubating/java/jvm-multi-project-with-code-coverage-standalone
    samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/README.adoc
    samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/groovy/application/build.gradle
    samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/groovy/buildSrc/build.gradle
    samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle
    samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/groovy/code-coverage-report/build.gradle
    samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/groovy/list/build.gradle
    samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/groovy/settings.gradle
    samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/groovy/utilities/build.gradle
    samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/kotlin/application/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/kotlin/buildSrc/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts
    samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/kotlin/code-coverage-report/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/kotlin/list/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/kotlin/settings.gradle.kts
    samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/kotlin/utilities/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/tests/testTask.out
    samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/tests/testTask.sample.conf

    /Sample: incubating/java/jvm-multi-project-with-test-aggregation-distribution
    samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/README.adoc
    samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/groovy/application/build.gradle
    samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/groovy/buildSrc/build.gradle
    samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle
    samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/groovy/list/build.gradle
    samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/groovy/settings.gradle
    samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/groovy/utilities/build.gradle
    samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/kotlin/application/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/kotlin/buildSrc/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts
    samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/kotlin/list/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/kotlin/settings.gradle.kts
    samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/kotlin/utilities/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/tests/testTask.out
    samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/tests/testTask.sample.conf
    samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/groovy/application/build.gradle

    /Sample: incubating/java/jvm-multi-project-with-test-aggregation-standalone
    samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/README.adoc
    samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/groovy/buildSrc/build.gradle
    samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle
    samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/groovy/list/build.gradle
    samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/groovy/settings.gradle
    samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/groovy/test-results/build.gradle
    samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/groovy/utilities/build.gradle
    samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/kotlin/application/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/kotlin/buildSrc/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts
    samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/kotlin/list/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/kotlin/settings.gradle.kts
    samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/kotlin/test-results/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/kotlin/utilities/build.gradle.kts
    samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/tests/testTask.out
    samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/tests/testTask.sample.conf

    /Sample: incubating/java/modules-multi-project-with-integration-tests/README
    samples/incubating/java/modules-multi-project-with-integration-tests/README.adoc
    samples/incubating/java/modules-multi-project-with-integration-tests/groovy/application/build.gradle
    samples/incubating/java/modules-multi-project-with-integration-tests/groovy/buildSrc/build.gradle
    samples/incubating/java/modules-multi-project-with-integration-tests/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle
    samples/incubating/java/modules-multi-project-with-integration-tests/groovy/list/build.gradle
    samples/incubating/java/modules-multi-project-with-integration-tests/groovy/settings.gradle
    samples/incubating/java/modules-multi-project-with-integration-tests/groovy/utilities/build.gradle
    samples/incubating/java/modules-multi-project-with-integration-tests/kotlin/application/build.gradle.kts
    samples/incubating/java/modules-multi-project-with-integration-tests/kotlin/buildSrc/build.gradle.kts
    samples/incubating/java/modules-multi-project-with-integration-tests/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts
    samples/incubating/java/modules-multi-project-with-integration-tests/kotlin/list/build.gradle.kts
    samples/incubating/java/modules-multi-project-with-integration-tests/kotlin/settings.gradle.kts
    samples/incubating/java/modules-multi-project-with-integration-tests/kotlin/utilities/build.gradle.kts
    samples/incubating/java/modules-multi-project-with-integration-tests/tests/checkTask.out
    samples/incubating/java/modules-multi-project-with-integration-tests/tests/runTask.out
    samples/incubating/java/modules-multi-project-with-integration-tests/tests/testTask.sample.conf

    /Sample: java/jvm-multi-project-with-additional-test-types
    samples/java/jvm-multi-project-with-additional-test-types/README.adoc
    samples/java/jvm-multi-project-with-additional-test-types/groovy/application/build.gradle
    samples/java/jvm-multi-project-with-additional-test-types/groovy/buildSrc/build.gradle
    samples/java/jvm-multi-project-with-additional-test-types/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle
    samples/java/jvm-multi-project-with-additional-test-types/groovy/list/build.gradle
    samples/java/jvm-multi-project-with-additional-test-types/groovy/settings.gradle
    samples/java/jvm-multi-project-with-additional-test-types/groovy/utilities/build.gradle
    samples/java/jvm-multi-project-with-additional-test-types/kotlin/application/build.gradle.kts
    samples/java/jvm-multi-project-with-additional-test-types/kotlin/buildSrc/build.gradle.kts
    samples/java/jvm-multi-project-with-additional-test-types/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts
    samples/java/jvm-multi-project-with-additional-test-types/kotlin/list/build.gradle.kts
    samples/java/jvm-multi-project-with-additional-test-types/kotlin/settings.gradle.kts
    samples/java/jvm-multi-project-with-additional-test-types/kotlin/utilities/build.gradle.kts
    samples/java/jvm-multi-project-with-additional-test-types/tests/checkTask.out
    samples/java/jvm-multi-project-with-additional-test-types/tests/checkTask.sample.conf

    /Sample: java/jvm-multi-project-with-toolchains
    samples/java/jvm-multi-project-with-toolchains/README.adoc
    samples/java/jvm-multi-project-with-toolchains/groovy/application/build.gradle
    samples/java/jvm-multi-project-with-toolchains/groovy/buildSrc/build.gradle
    samples/java/jvm-multi-project-with-toolchains/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle
    samples/java/jvm-multi-project-with-toolchains/groovy/list/build.gradle
    samples/java/jvm-multi-project-with-toolchains/groovy/settings.gradle
    samples/java/jvm-multi-project-with-toolchains/groovy/utilities/build.gradle
    samples/java/jvm-multi-project-with-toolchains/kotlin/application/build.gradle.kts
    samples/java/jvm-multi-project-with-toolchains/kotlin/buildSrc/build.gradle.kts
    samples/java/jvm-multi-project-with-toolchains/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts
    samples/java/jvm-multi-project-with-toolchains/kotlin/list/build.gradle.kts
    samples/java/jvm-multi-project-with-toolchains/kotlin/settings.gradle.kts
    samples/java/jvm-multi-project-with-toolchains/kotlin/utilities/build.gradle.kts
    samples/java/jvm-multi-project-with-toolchains/tests/checkTask.out
    samples/java/jvm-multi-project-with-toolchains/tests/checkTask.sample.conf

    /Sample: java/library-publishing
    samples/java/library-publishing/README.adoc
    samples/java/library-publishing/groovy/my-library/build.gradle
    samples/java/library-publishing/groovy/settings.gradle
    samples/java/library-publishing/kotlin/my-library/build.gradle.kts
    samples/java/library-publishing/kotlin/settings.gradle.kts
    samples/java/library-publishing/tests/publishTask.out
    samples/java/library-publishing/tests/publishTask.sample.conf

    /Sample: java/modules-multi-project
    samples/java/modules-multi-project/README.adoc
    samples/java/modules-multi-project/groovy/application/build.gradle
    samples/java/modules-multi-project/groovy/buildSrc/build.gradle
    samples/java/modules-multi-project/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle
    samples/java/modules-multi-project/groovy/list/build.gradle
    samples/java/modules-multi-project/groovy/settings.gradle
    samples/java/modules-multi-project/groovy/utilities/build.gradle
    samples/java/modules-multi-project/kotlin/application/build.gradle.kts
    samples/java/modules-multi-project/kotlin/buildSrc/build.gradle.kts
    samples/java/modules-multi-project/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts
    samples/java/modules-multi-project/kotlin/list/build.gradle.kts
    samples/java/modules-multi-project/kotlin/settings.gradle.kts
    samples/java/modules-multi-project/kotlin/utilities/build.gradle.kts
    samples/java/modules-multi-project/tests/checkTask.out
    samples/java/modules-multi-project/tests/runTask.out
    samples/java/modules-multi-project/tests/testTask.sample.conf

    /Sample: java/modules-multi-project-with-integration-tests
    samples/java/modules-multi-project-with-integration-tests/README.adoc
    samples/java/modules-multi-project-with-integration-tests/groovy/application/build.gradle
    samples/java/modules-multi-project-with-integration-tests/groovy/buildSrc/build.gradle
    samples/java/modules-multi-project-with-integration-tests/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle
    samples/java/modules-multi-project-with-integration-tests/groovy/list/build.gradle
    samples/java/modules-multi-project-with-integration-tests/groovy/settings.gradle
    samples/java/modules-multi-project-with-integration-tests/groovy/utilities/build.gradle
    samples/java/modules-multi-project-with-integration-tests/kotlin/application/build.gradle.kts
    samples/java/modules-multi-project-with-integration-tests/kotlin/buildSrc/build.gradle.kts
    samples/java/modules-multi-project-with-integration-tests/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts
    samples/java/modules-multi-project-with-integration-tests/kotlin/list/build.gradle.kts
    samples/java/modules-multi-project-with-integration-tests/kotlin/settings.gradle.kts
    samples/java/modules-multi-project-with-integration-tests/kotlin/utilities/build.gradle.kts
    samples/java/modules-multi-project-with-integration-tests/tests/checkTask.out
    samples/java/modules-multi-project-with-integration-tests/tests/runTask.out
    samples/java/modules-multi-project-with-integration-tests/tests/testTask.sample.conf

    /Sample: java/modules-with-transform
    samples/java/modules-with-transform/README.adoc
    samples/java/modules-with-transform/groovy/application/build.gradle
    samples/java/modules-with-transform/groovy/buildSrc/build.gradle
    samples/java/modules-with-transform/groovy/settings.gradle
    samples/java/modules-with-transform/kotlin/application/build.gradle.kts
    samples/java/modules-with-transform/kotlin/buildSrc/build.gradle.kts
    samples/java/modules-with-transform/kotlin/settings.gradle.kts
    samples/java/modules-with-transform/tests/runTask.out
    samples/java/modules-with-transform/tests/runTask.sample.conf

    /Sample: spring-boot-web-application
    samples/spring-boot-web-application/README.adoc
    samples/spring-boot-web-application/groovy/app/build.gradle
    samples/spring-boot-web-application/groovy/settings.gradle
    samples/spring-boot-web-application/kotlin/app/build.gradle.kts
    samples/spring-boot-web-application/kotlin/settings.gradle.kts
    samples/spring-boot-web-application/tests/sanityCheck.sample.conf
    samples/spring-boot-web-application/tests/testTask.out
    samples/spring-boot-web-application/tests/testTask.sample.conf

    /Sample: templates/build-src-plugin-java-module-transform
    samples/templates/build-src-plugin-java-module-transform/application/src/main/java/module-info.java
    samples/templates/build-src-plugin-java-module-transform/application/src/main/java/org/gradle/sample/app/data/Message.java
    samples/templates/build-src-plugin-java-module-transform/application/src/main/java/org/gradle/sample/app/Main.java
    samples/templates/build-src-plugin-java-module-transform/buildSrc/src/main/java/org/gradle/sample/transform/javamodules/ExtraModuleInfoPlugin.java
    samples/templates/build-src-plugin-java-module-transform/buildSrc/src/main/java/org/gradle/sample/transform/javamodules/ExtraModuleInfoPluginExtension.java
    samples/templates/build-src-plugin-java-module-transform/buildSrc/src/main/java/org/gradle/sample/transform/javamodules/ExtraModuleInfoTransform.java
    samples/templates/build-src-plugin-java-module-transform/buildSrc/src/main/java/org/gradle/sample/transform/javamodules/ModuleInfo.java

    /Sample: templates/gradle-plugin-in-java
    samples/templates/gradle-plugin-in-java/src/functionalTest/java/com/example/plugin/GreetingPluginFunctionalTest.java
    samples/templates/gradle-plugin-in-java/src/main/java/com/example/plugin/GreetingPlugin.java
    samples/templates/gradle-plugin-in-java/src/test/java/com/example/plugin/GreetingPluginTest.java

    /Sample: templates/groovy-list-library/src/main/groovy/org/gradle/sample/list
    samples/templates/groovy-list-library/src/main/groovy/org/gradle/sample/list/LinkedList.groovy
    samples/templates/groovy-utilities-library/src/main/groovy/org/gradle/sample/utilities/JoinUtils.groovy
    samples/templates/groovy-utilities-library/src/main/groovy/org/gradle/sample/utilities/SplitUtils.groovy
    samples/templates/groovy-utilities-library/src/main/groovy/org/gradle/sample/utilities/StringUtils.groovy

    /Sample: templates/java-android-application
    samples/templates/java-android-application/gradle.properties
    samples/templates/java-android-application/proguard-rules.pro
    samples/templates/java-android-application/app/.gitignore
    samples/templates/java-android-application/app/proguard-rules.pro
    samples/templates/java-android-application/app/src/androidTest/java/org/gradle/samples/ExampleInstrumentedTest.java
    samples/templates/java-android-application/app/src/main/AndroidManifest.xml
    samples/templates/java-android-application/app/src/main/java/org/gradle/samples/MainActivity.java
    samples/templates/java-android-application/app/src/main/res/drawable/ic_launcher_background.xml
    samples/templates/java-android-application/app/src/main/res/drawable-v24/ic_launcher_foreground.xml
    samples/templates/java-android-application/app/src/main/res/layout/activity_main.xml
    samples/templates/java-android-application/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
    samples/templates/java-android-application/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml
    samples/templates/java-android-application/app/src/main/res/values/colors.xml
    samples/templates/java-android-application/app/src/main/res/values/strings.xml
    samples/templates/java-android-application/app/src/main/res/values/styles.xml
    samples/templates/java-android-application/app/src/test/java/org/gradle/samples/ExampleUnitTest.java
    samples/templates/java-android-application/src/androidTest/java/org/gradle/samples/ExampleInstrumentedTest.java
    samples/templates/java-android-application/src/main/AndroidManifest.xml
    samples/templates/java-android-application/src/main/java/org/gradle/samples/MainActivity.java
    samples/templates/java-android-application/src/main/res/drawable/ic_launcher_background.xml
    samples/templates/java-android-application/src/main/res/drawable-v24/ic_launcher_foreground.xml
    samples/templates/java-android-application/src/main/res/layout/activity_main.xml
    samples/templates/java-android-application/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
    samples/templates/java-android-application/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml
    samples/templates/java-android-application/src/main/res/values/colors.xml
    samples/templates/java-android-application/src/main/res/values/strings.xml
    samples/templates/java-android-application/src/main/res/values/styles.xml
    samples/templates/java-android-application/src/test/java/org/gradle/samples/ExampleUnitTest.java

    /Sample: templates/java-application
    samples/templates/java-application/src/main/java/org/gradle/sample/app/Main.java
    samples/templates/java-application/src/main/java/org/gradle/sample/app/MessageUtils.java

    /Sample: templates/java-junit5-integration-test-for-application
    samples/templates/java-junit5-integration-test-for-application/src/integrationTest/java/org/gradle/sample/integtest/app/MainIntegrationTest.java
    samples/templates/java-junit5-integration-test-for-utilities-library/src/integrationTest/java/org/gradle/sample/integtest/utilities/StringUtilsIntegrationTest.java
    samples/templates/java-junit5-module-info-for-application/src/integrationTest/java/module-info.java
    samples/templates/java-junit5-module-info-for-utilities-library/src/integrationTest/java/module-info.java
    samples/templates/java-junit5-test-for-application/src/test/java/org/gradle/sample/app/MessageUtilsTest.java
    samples/templates/java-junit5-test-for-list-library/src/test/java/org/gradle/sample/list/LinkedListTest.java
    samples/templates/java-junit5-test-for-utilities-library/src/test/java/org/gradle/sample/utilities/JoinUtilsTest.java
    samples/templates/java-junit5-test-for-utilities-library/src/test/java/org/gradle/sample/utilities/StringUtilsTest.java

    /Sample: templates/java-list-library
    samples/templates/java-list-library/src/main/java/org/gradle/sample/list/LinkedList.java

    /Sample: templates/java-module-info-for-application
    samples/templates/java-module-info-for-application/src/main/java/module-info.java
    samples/templates/java-module-info-for-list-library/src/main/java/module-info.java
    samples/templates/java-module-info-for-utilities-library/src/main/java/module-info.java

    /Sample: templates/java-utilities-library
    samples/templates/java-utilities-library/src/main/java/org/gradle/sample/utilities/JoinUtils.java
    samples/templates/java-utilities-library/src/main/java/org/gradle/sample/utilities/SplitUtils.java
    samples/templates/java-utilities-library/src/main/java/org/gradle/sample/utilities/StringUtils.java

    /Sample: templates/precompiled-script-plugin-utils
    samples/templates/precompiled-script-plugin-utils/src/main/java/com/example/CheckstyleUtil.java
    samples/templates/precompiled-script-plugin-utils/src/main/java/com/example/ReadmeVerificationTask.java
    samples/templates/precompiled-script-plugin-utils/src/main/resources/checkstyle.xml

    /Sample: templates/problems-api-usage
    samples/templates/problems-api-usage/reporters/model-builder-plugin/src/main/java/reporters/DefaultDemoModel.java
    samples/templates/problems-api-usage/reporters/model-builder-plugin/src/main/java/reporters/DemoModel.java
    samples/templates/problems-api-usage/reporters/model-builder-plugin/src/main/java/reporters/ModelBuilder.java
    samples/templates/problems-api-usage/reporters/model-builder-plugin/src/main/java/reporters/ModelBuilderPlugin.java
    samples/templates/problems-api-usage/reporters/standard-plugin/src/main/java/reporters/StandardPlugin.java
    samples/templates/problems-api-usage/sample-ide/src/main/java/org/gradle/sample/SampleIde.java

    /Sample: templates/spring-boot-web-application
    samples/templates/spring-boot-web-application/HELP.md
    samples/templates/spring-boot-web-application/src/main/java/org/gradle/samples/SpringBootDemoApplication.java
    samples/templates/spring-boot-web-application/src/main/resources/application.properties
    samples/templates/spring-boot-web-application/src/test/java/org/gradle/samples/SpringBootDemoApplicationTests.java

    /Sample: templates/structuring-software-projects
    samples/templates/structuring-software-projects/admin-feature/config/src/main/kotlin/com/example/myproduct/admin/config/AdminController.kt
    samples/templates/structuring-software-projects/admin-feature/config/src/main/kotlin/com/example/myproduct/admin/config/VersionRange.kt
    samples/templates/structuring-software-projects/admin-feature/config/src/test/kotlin/com/example/myproduct/admin/config/AdminControllerTest.kt
    samples/templates/structuring-software-projects/android-app/app/src/main/AndroidManifest.xml
    samples/templates/structuring-software-projects/android-app/app/src/main/java/com/example/myproduct/app/MyProductAppActivity.kt
    samples/templates/structuring-software-projects/domain-model/release/src/main/kotlin/com/example/myproduct/model/MyProductRelease.kt
    samples/templates/structuring-software-projects/domain-model/release/src/main/kotlin/com/example/myproduct/model/MyProductReleaseList.kt
    samples/templates/structuring-software-projects/server-application/app/src/main/java/com/example/myproduct/server/MyProductAdminController.java
    samples/templates/structuring-software-projects/server-application/app/src/main/java/com/example/myproduct/server/MyProductApplication.java
    samples/templates/structuring-software-projects/server-application/app/src/main/java/com/example/myproduct/server/MyProductController.java
    samples/templates/structuring-software-projects/server-application/app/src/main/java/com/example/myproduct/server/MyProductJsonController.java
    samples/templates/structuring-software-projects/server-application/app/src/main/resources/templates/admin.html
    samples/templates/structuring-software-projects/state/application-state/src/main/kotlin/com/example/myproduct/admin/state/ConfigurationState.kt
    samples/templates/structuring-software-projects/state/application-state/src/main/kotlin/com/example/myproduct/admin/state/VersionRangeSetting.kt
    samples/templates/structuring-software-projects/user-feature/data/src/main/java/com/example/myproduct/user/data/DataRetriever.java
    samples/templates/structuring-software-projects/user-feature/table/src/main/java/com/example/myproduct/user/table/TableBuilder.java
    samples/templates/structuring-software-projects/user-feature/table/src/test/java/com/example/myproduct/user/table/TableBuilderTest.java

    /Sample: writing-tasks/task-with-arguments
    samples/writing-tasks/task-with-arguments/README.adoc
    samples/writing-tasks/task-with-arguments/groovy/build.gradle
    samples/writing-tasks/task-with-arguments/groovy/settings.gradle
    samples/writing-tasks/task-with-arguments/groovy/project-info/build.gradle
    samples/writing-tasks/task-with-arguments/groovy/project-info/settings.gradle
    samples/writing-tasks/task-with-arguments/common/project-info/src/main/java/com/example/ProjectInfoPlugin.java
    samples/writing-tasks/task-with-arguments/common/project-info/src/main/java/com/example/ProjectInfoTask.java
    samples/writing-tasks/task-with-arguments/kotlin/build.gradle.kts
    samples/writing-tasks/task-with-arguments/kotlin/settings.gradle.kts
    samples/writing-tasks/task-with-arguments/kotlin/project-info/build.gradle.kts
    samples/writing-tasks/task-with-arguments/kotlin/project-info/settings.gradle.kts
    samples/writing-tasks/task-with-arguments/tests/help.out
    samples/writing-tasks/task-with-arguments/tests/json.out
    samples/writing-tasks/task-with-arguments/tests/plain.out
    samples/writing-tasks/task-with-arguments/tests/projectInfoTask.sample.conf

    /Sample: writing-tasks/tasks-with-dependency-resolution-result-inputs
    samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/README.adoc
    samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/common/dependency-reports/src/main/java/com/example/DependencyReportsPlugin.java
    samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/common/dependency-reports/src/main/java/com/example/GraphResolvedComponents.java
    samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/common/dependency-reports/src/main/java/com/example/GraphResolvedComponentsAndFiles.java
    samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/common/dependency-reports/src/main/java/com/example/ListResolvedArtifacts.java
    samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/groovy/build.gradle
    samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/groovy/dependency-reports/build.gradle
    samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/groovy/dependency-reports/settings.gradle
    samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/groovy/list/build.gradle
    samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/groovy/settings.gradle
    samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/groovy/utilities/build.gradle
    samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/kotlin/build.gradle.kts
    samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/kotlin/settings.gradle.kts
    samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/kotlin/dependency-reports/build.gradle.kts
    samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/kotlin/dependency-reports/settings.gradle.kts
    samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/kotlin/list/build.gradle.kts
    samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/kotlin/utilities/build.gradle.kts
    samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/tests/dependencyReports.sample.conf
    samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/tests/graphResolvedComponents.out
    samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/tests/graphResolvedComponentsAndFiles.out
    samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/tests/listResolvedArtifacts.out
EOF
   exit



/Readme
=======

|Revved up by Develocity| |CII Best Practices|

`Gradle <https://gradle.org/>`__ is a build tool with a focus on build
automation and support for multi-language development. If you are
building, testing, publishing, and deploying software on any platform,
Gradle offers a flexible model that can support the entire development
lifecycle from compiling and packaging code to publishing web sites.
Gradle has been designed to support build automation across multiple
languages and platforms including Java, Scala, Android, Kotlin, C/C++,
and Groovy, and is closely integrated with development tools and
continuous integration servers including Eclipse, IntelliJ, and Jenkins.

**For more information, please visit the** `official project homepage <https://gradle.org>`__

Getting Started
---------------

-  `Installing Gradle <https://docs.gradle.org/current/userguide/installation.html>`__
-  `Building Android Apps <https://developer.android.com/training/basics/firstapp/>`__
-  `Building Java Applications <https://docs.gradle.org/current/samples/sample_building_java_applications.html>`__
-  `Building Java Libraries <https://docs.gradle.org/current/samples/sample_building_java_libraries.html>`__
-  `Building Groovy Applications <https://docs.gradle.org/current/samples/sample_building_groovy_applications.html>`__
-  `Building Groovy Libraries <https://docs.gradle.org/current/samples/sample_building_groovy_libraries.html>`__
-  `Building Scala Applications <https://docs.gradle.org/current/samples/sample_building_scala_applications.html>`__
-  `Building Scala Libraries <https://docs.gradle.org/current/samples/sample_building_scala_libraries.html>`__
-  `Building Kotlin JVM Applications <https://docs.gradle.org/current/samples/sample_building_kotlin_applications.html>`__
-  `Building Kotlin JVM Libraries <https://docs.gradle.org/current/samples/sample_building_kotlin_libraries.html>`__
-  `Building C++ Applications <https://docs.gradle.org/current/samples/sample_building_cpp_applications.html>`__
-  `Building C++ Libraries <https://docs.gradle.org/current/samples/sample_building_cpp_libraries.html>`__
-  `Building Swift Applications <https://docs.gradle.org/current/samples/sample_building_swift_applications.html>`__
-  `Building Swift Libraries <https://docs.gradle.org/current/samples/sample_building_swift_libraries.html>`__
-  `Creating Build Scans <https://scans.gradle.com/>`__

Stay in Flow
------------

Enjoy first-class Gradle support in your IDE of choice.

-  `Android Studio <https://developer.android.com/studio/build/index.html>`__
-  `Eclipse <https://www.vogella.com/tutorials/EclipseGradle/article.html>`__
-  `IntelliJ IDEA <https://www.jetbrains.com/help/idea/gradle.html>`__
-  `NetBeans <https://netbeans.apache.org>`__
-  `Visual Studio Code <https://code.visualstudio.com/docs/languages/java>`__

Need Help?
----------

-  Get familiar with the `Gradle User Manual <https://docs.gradle.org/current/userguide/userguide.html>`__
-  `Upcoming trainings <https://gradle.org/training/>`__
-  Ask on the `forum <https://discuss.gradle.org/>`__ or
   `StackOverflow <https://stackoverflow.com/questions/tagged/gradle>`__
-  Have a look at the
   `Samples <https://docs.gradle.org/current/samples/index.html>`__
-  Checkout the `Community Resources <https://gradle.org/resources/>`__
   as well
-  Join our `Slack Channel <https://gradle.com/slack-invite>`__

Contributing
------------

If youre looking to contribute to Gradle or provide a patch/pull
request, you can find more info
`here <https://github.com/gradle/gradle/blob/master/CONTRIBUTING.md>`__.

This project adheres to the `Gradle Code of Conduct <https://gradle.org/conduct/>`__. By participating, you are
expected to uphold this code.

.. |Revved up by Develocity| image:: https://img.shields.io/badge/Revved%20up%20by-Develocity-06A0CE?logo=Gradle&labelColor=02303A
   :target: https://ge.gradle.org/scans
.. |CII Best Practices| image:: https://bestpractices.coreinfrastructure.org/projects/4898/badge
   :target: https://bestpractices.coreinfrastructure.org/projects/4898


/Readme - Documentation
=======================

   The docs project produces the 
   `user manual <http://gradle.org/docs/current/userguide/userguide.html>`__,
   `DSL reference <http://gradle.org/docs/current/dsl/>`__,
   `javadoc <http://gradle.org/docs/current/javadoc/>`__ and 
   `release notes <http://gradle.org/docs/current/release-notes>`__ (as well as some
   other minor bits).

   The following is some help for working with the docs, all file paths are
   relative to this directory unless specified otherwise.

Release Notes
-------------

   The release notes are generated from ``src/docs/release/notes.md``.

Schema
~~~~~~

   Every ``h2`` tag and ``h3`` will be listed in the generated TOC.

   After every ``h3`` all content after the first element (usually a ``p``)
   will be collapsed/expandable, up until the next ``h3``, or ``h2``.

   After every ``h4`` all content will be collapsed/expandable, up until
   the next ``h4``, ``h3`` or ``h2``.

   An ``h3`` may include an incubating marker ``(i)`` at the end of its
   text to indicate that the feature is incubating.

   Here뗩 an example:

   ::

      ## h2 New and Noteworthy

      ### h3 Some feature (i)

      This is some incubating feature.

      #### h4 Some detail

      This detail about the feature is collapsed. The reader can expand it if they are interested.

Generating
~~~~~~~~~~

   Run the ``:docs:releaseNotes`` task to generate the release notes.

User Manual
-----------

   The source for the user manual lives @ ``src/docs/userguide``, and is
   authored in `Asciidoctor <https://asciidoctor.org>`__.

   To generate the user manual for the final preview and see all changes,
   you normally want to run:

   ::

      ./gradlew stageDocs

   That will generate all the docs in the ``build/docs`` directory.

   For development and fast feedback you should use:

   ::

      ./gradlew stageDocs -PquickDocs

   Alternatively, if you want to serve the docs in a built-in webserver,
   you can use:

   ::

      ./gradlew serveDocs -PquickDocs

   The flag ``-PquickDocs`` disables some slow documentation tasks, like
   creating the DSL reference or the single page user manual PDF or HTML.

   If you really want to generate just the user manual, you can run:

   ::

      ./gradlew :docs:userguide

   But note that the generated documentation might not be fully functional
   (e.g.맓inks will not work). This will generate:

   -  A multi-page HTML manual in
      ``build/working/usermanual/render-multi/`` for each chapter. There is
      a 1-1 mapping from ``.adoc`` file to ``.html`` file.
   -  A single-page HTML manual at
      ``build/working/usermanual/render-single-html/userguide_single.html``
   -  A PDF at
      ``build/working/usermanual/render-single-pdf/userguide_single.pdf``

   Note that PNG files in the source are generated from .graphml files in
   the same directory. You can edit these files with tools like
   `yEd <http://www.yworks.com/en/products_yed_about.html>`__ and then
   generate the associated PNG.

Authoring with AsciiDoc
~~~~~~~~~~~~~~~~~~~~~~~

   To write a chapter in Asciidoctor format, simply place it in
   ``src/docs/userguide`` called ``<chapter>.adoc``.

   You will find these references useful when authoring AsciiDoc:

   -  `AsciiDoc Syntax Quick Reference <https://asciidoctor.org/docs/asciidoc-syntax-quick-reference/>`__
   -  `Asciidoctor User Manual <https://asciidoctor.org/docs/user-manual/>`__
   -  `Asciidoctor Gradle Plugin Reference <https://asciidoctor.org/docs/asciidoctor-gradle-plugin/>`__

Adding new chapters
~~~~~~~~~~~~~~~~~~~

   | When adding a new chapter to the manual do the following steps: 1.
     Create a file called ``<chapter>.adoc`` in a suitable subdirectory of
     ``src/docs/userguide`` and write the content there. 2. Add the license
     text to the top of the file and also add an ID for the chapter title.
     This is required to be able to link directly to the chapter from other
     chapters, as opposed to linking to a section inside.
   | The ID should preferably match the name of the ``adoc`` file. For
     instance, linking to ``toolchains.adoc`` is possible with
     ``<<toolchains.adoc#toolchains,Text>>``, and the declaration looks
     like:
     ``asciidoc     [[toolchains]]     = Toolchains for JVM projects`` 3.
     Include the new chapter file in the
     `userguide_single.adoc <#src/docs/userguide/userguide_single.adoc>`__.
     4. Include the relative link to the new chapter in the
     `header.html <#src/main/resources/header.html>`__

Code Snippets
~~~~~~~~~~~~~

   Snippets and output belong under ``src/snippets`` and are typically
   included in the user manual. This is a typical example:

Example multi-language sample file listing
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

   This shows Groovy and Kotlin sample projects under 랍ample-dir which is
   defined as $projectDir/src/snippets.

   ::

      platforms/documentation/docs/src/snippets/
      較덕較 initScripts/customLogger/
       먝 較럭較 customLogger.out
       먝 較럭較 customLogger.sample.conf
       먝 較럭較 groovy
       먝 較   較럭較 build.gradle
       먝 較   較럭較 init.gradle
       먝 較   較덕較 settings.gradle
       먝 較덕較 kotlin
       먝     較럭較 build.gradle.kts
       먝     較럭較 customLogger.init.gradle.kts
       먝     較덕較 settings.gradle.kts

   Note here that there are 2 sample projects under
   ``initScripts/customLogger/``: one for the Groovy DSL and one for Kotlin
   DSL. Also note that there is only 1 ``customLogger.sample.conf`` file
   that tells Exemplar how to execute both groovy and kotlin samples, with
   1 ``customLogger.out`` file proving the output is identical between the
   two.

Example Asciidoctor multi-language sample declaration
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

   .. code:: asciidoc

   .Customizing what Gradle logs
   ====
      include::sample[dir="snippets/initScripts/customLogger/kotlin",files="customLogger.init.gradle.kts[]"]
   include::sample[dir="snippets/initScripts/customLogger/groovy",files="init.gradle[]"]
   ====

   [.multi-language-text.lang-kotlin]
   ----
      $ gradle -I customLogger.init.gradle.kts build
   include::{snippetsPath}/initScripts/customLogger/tests/customLogger.out[]
   ----
   [.multi-language-text.lang-groovy]
   ----
      $ gradle -I init.gradle build
   include::{snippetsPath}/initScripts/customLogger/tests/customLogger.out[]
   ----

   Let뗩 break down this example to explain:

   -  Enclosing ``====`` around the sample includes groups these samples
      and collapses them
   -  ``include::sample``: invokes the ``SampleIncludeProcessor``
      asciidoctor extension, with a ``dir`` relative to ``src/snippets/``,
      and a list of ``files`` separated by ``;`` (only 1 in this example),
      each with optional ``tags=...`` (like Asciidoctor뗩 tags mechanism).
      We write this once for each DSL dialect. This notes to our front-end
      code to group these 2 samples and show them with selector tabs.
   -  ``[.multi-language-text.lang-groovy]``: Most times the gradle command
      is identical between Groovy and Kotlin samples, but in this case we
      need to use ``[.multi-language-text.lang-*]`` that our CSS will
      collapse and switch for the DSL of choice. This is case-sensitive.
      You can use this construct for any 2 sibling blocks!

   It is possible to embed sample sources, commands, and expected output
   directly in the Asciidoc (or a mixture of embedded and ``include``\ d),
   but we don뗪 use this for the user manual yet. See the 
   `Exemplar documentation <https://github.com/gradle/exemplar/#configuring-embedded-samples>`__
   if youre interested in this.

Testing docs
------------

   Currently, ``docs`` is tested by ``docs:docsTest``, which covers three
   kinds of code:

   -  The code generated by 
      `Build Init Plugin <https://docs.gradle.org/current/userguide/build_init_plugin.html>`__,
      i.e.``gradle init`` task.

      -  ``generate-samples.gradle.kts`` registers multiple generator tasks
         that generate the same sample project code as you manually run
         ``gradle init``.
      -  These sample projects will also be published beside the user
         manual.

   -  The code samples under ``platforms/documentation/docs/src/samples``.
      They are published beside the user manual.
   -  `The code snippets <#code-snippets>`__ under
      ``platforms/documentation/docs/src/snippets``, which are typically
      included in the user manual.

   Note: the terminology ``sample`` could refer to different things
   depending on the context:

   -  The code samples under ``platforms/documentation/docs/src/samples``.
      We뗣l call them 띾ode samples.
   -  The test unit used by 
      `exemplar framework <https://github.com/gradle/exemplar/blob/9c4415f6237d7d86329fdbb32d80a2f7dd8ae0a9/samples-discovery/src/main/java/org/gradle/exemplar/model/Sample.java#L21>`__.
      We뗣l call them 란xemplar sample.

   The build script of the ``docs`` subproject
   (``supprojects/docs/build.gradle``) eventually assembles the three kinds
   of docs code above to exemplar samples and then tests them with
   exemplar.

``org.gradle.samples`` plugin
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``platforms/documentation/docs/build.gradle`` applies
   ``generate-samples.gradle.kts``, which further applies an opinionated
   plugin called ``org.gradle.samples``. The source code of this plugin is
   `here <https://github.com/gradle/guides/blob/ba018cec535d90f75876bfcca29381d213a956cc/subprojects/gradle-guides-plugin/src/main/java/org/gradle/docs/samples/internal/LegacySamplesDocumentationPlugin.java#L9>`__.
   This plugin adds a
   `Samples <https://github.com/gradle/guides/blob/fa335417efb5656e202e95759ebf8a4e60843f10/subprojects/gradle-guides-plugin/src/main/java/org/gradle/docs/samples/Samples.java#L8>`__
   extension named ``samples``.

   This ``samples`` extension is configured in both
   ``platforms/documentation/docs/build.gradle`` and
   ``generate-samples.gradle.kts``: all docs code to be tested will be
   assembled into
   `samples.publishedSamples <https://github.com/gradle/guides/blob/fa335417efb5656e202e95759ebf8a4e60843f10/subprojects/gradle-guides-plugin/src/main/java/org/gradle/docs/samples/Samples.java#L41>`__,
   as follows:

   ::

      This graph is generated by [asciiflow.com](https://asciiflow.com/). You can copy-paste it to the website to modify it. 

      較꺽較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較
      較 documentation/docs/build.gradle    較
      較 較꺽較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較 較    較꺽較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較
      較 較 generate-samples.gradle.kts    較럭較쩍較較郊쥑댁 code generated by init tasks    較럭較較較
      較 較                                較 較    較                                 較   較
      較 較덕較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較 較    較덕較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較   較
      較                                    較                                          較
      較  samples {                         較    較꺽較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較   較
      較    ...                             較    較 code snippets in src/snippets   較럭較較較
      較    publishedSamples {  較較較較較較較較較較較較較쩍較석郊쥑댁                                 較   較
      較      ...                           較 較  較덕較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較   較
      較덕較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較 較                                        較
                                             較  較꺽較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較   較
                                             較덕郊쥑댁 code samples in src/samples     較럭較較較
                                                較                                 較   較
                                                較덕較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較   較
                                                                                      較
                                                                                      較
                                              較꺽較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較   較
                                              較 org.gradle.samples plugin         較   較
                                              較 較꺽較較較較較較較較較較較較較較較較較較較較較較較較較較較較較   較   較
      較꺽較較較較較較較較較較較較較   Install samples to    較 較 Samples.publishedSamples    較   較   較
      較  Exemplar   較   local directory and   較 較                             較   較   較
      較             較   test with exemplar    較 較                             較   較   較
      較             較餃較較較較較較較較較較較較較較較較較較較較較較較較較 較                             餃較較較較쩍較較較
      較             較                         較 較                             較   較
      較덕較較較較較較較較較較較較較                         較 較                             較   較
                                              較 較덕較較較較較較較較較較較較較較較較較較較較較較較較較較較較較   較
                                              較                                   較
                                              較덕較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較較

   The elements in ``samples.publishedSamples`` container will later be
   installed into a local directory (by default
   `docs/build/working/samples/install <https://github.com/gradle/guides/blob/900650c6fd6c980ae7335d7aab6dea200a693aa0/subprojects/gradle-guides-plugin/src/main/java/org/gradle/docs/samples/internal/SamplesInternal.java#L46>`__)
   as exemplar samples.

   After the exemplar examples are installed, ``docs:docsTest`` will start
   testing them (see
   `BaseSamplesTest <https://github.com/gradle/gradle/blob/a503d4a36c53e43a8857da3115fa744612c6ad36/subprojects/docs/src/docsTest/java/org/gradle/docs/samples/BaseSamplesTest.java#L66>`__).

Code samples
~~~~~~~~~~~~

   To run the samples tests:

   ::

      ./gradlew :docs:docsTest --tests "org.gradle.docs.samples.*.*"

   To run tests for a single sample, let뗩 say from
   ``samples/java/application``:

   ::

      ./gradlew :docs:docsTest --tests "org.gradle.docs.samples.DependencyManagementSnippetsTest.java-application*"

   Note that the samples are also used in ``samples`` subproject, see
   `@UsesSample <https://github.com/gradle/gradle/blob/9ade1a05427aaf04c976a0e85814b44b3435f9f9/subprojects/internal-integ-testing/src/main/groovy/org/gradle/integtests/fixtures/UsesSample.java#L25>`__
   and
   `Sample <https://github.com/gradle/gradle/blob/903c5f2cee88c9768077d46025eaafdf65862fc8/subprojects/internal-integ-testing/src/main/groovy/org/gradle/integtests/fixtures/Sample.java#L37>`__.

   .. _code-snippets-1:

Code snippets
~~~~~~~~~~~~~

   As an example, you can run Kotlin and Groovy snippets tests from
   `src/snippets/java/toolchain-task/ <#src/snippets/java/toolchain-task>`__
   using:

   ::

      ./gradlew :docs:docsTest --tests "*.snippet-java-toolchain-task_*"

   You can also filter the tests for a specific DSL like this:

   ::

      ./gradlew :docs:docsTest --tests "*.snippet-java-toolchain-task_kotlin_*"

Testing with configuration cache
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   It is possible to run samples and snippets with the configuration cache
   enabled to ensure compatibility. You can do that by setting the Gradle
   property ``enableConfigurationCacheForDocsTests`` in the command line or
   in the ``gradle.properties`` file.

   ::

      ./gradlew :docs:docsTest --tests "*.snippet-java-toolchain-task_*" -PenableConfigurationCacheForDocsTests=true

Groovy DSL Reference
--------------------

   The DSL reference is authored in Docbook syntax, with sources under
   ``src/docs/dsl``. Much of the content is extracted from code doc
   comments.

   To build it, run:

   .. code:: bash

      ./gradlew :docs:dslHtml

   The output is available under ``build/working/dsl``.

Useful docbook tags
~~~~~~~~~~~~~~~~~~~

   See the `docbook reference <http://docbook.org/tdg/en/html/part2.html>`__ for a list of
   all available tags.

Custom Tags
^^^^^^^^^^^

``<apilink>``
'''''''''''''

   This is an inline element which adds a link to the API documentation for
   a particular class or method.

   ::

      You can use the <apilink class='org.gradle.api.Project' /> interface to do stuff.

   The link will point to the DSL reference for the specified class, if
   available. Otherwise, it will point to the javadoc for the class.

   To link to a method:

   ::

      <apilink class='org.gradle.api.Project' method="apply(java.util.Map)" />

Javadocs
--------

   To build these, run:

   ::

      ./gradlew :docs:javadocAll

   The output is available within ``build/javadoc``.

Building all the docs
---------------------

   There is a convenience task to build all of the documentation:

   ::

      ./gradlew :docs:docs


/Module gradle
==============

Kotlin DSL Reference for Gradle
-------------------------------

   Gradle뗩 Kotlin DSL provides an enhanced editing experience in supported
   IDEs, with superior content assist, refactoring, documentation, and
   more. For an introduction see the Kotlin DSL Primer.

   The Kotlin DSL is implemented on top of Gradle뗩 Java API. Many of the
   objects, functions and properties you use in your build scripts come
   from the Gradle API and the APIs of the applied plugins. This reference
   covers both the Kotlin DSL and the Java API, but it doesn뗪 include
   functionality provided by external plugins.

   The main package of the Kotlin DSL is org.gradle.kotlin.dsl. All members
   of this package are implicitly imported and readily available in
   ``.gradle.kts`` scripts in addition to the Java API default imports.

Package org.gradle.kotlin.dsl
-----------------------------

   The ``org.gradle.kotlin.dsl`` package contains the Gradle Kotlin DSL
   public API.

   All members of this package are implicitly imported and readily
   available in ``.gradle.kts`` scripts in addition to the Gradle Java API
   default imports.


/Notes template
===============

   The Gradle team is excited to announce Gradle @version@.

   This release features `1 <>`__, `2 <>`__,  `n <>`__, and more.

   .. raw:: html

      <!-- 
      Include only their name, impactful features should be called out separately below.
       [Some person](https://github.com/some-person)

       THiS LIST SHOULD BE ALPHABETIZED BY [PERSON NAME] - 
       the docs:updateContributorsInReleaseNotes task will enforce this ordering, 
       which is case-insensitive.
      -->

   We would like to thank the following community members for their
   contributions to this release of Gradle:

   Be sure to check out the `public roadmap <https://blog.gradle.org/roadmap-announcement>`__ 
   for insight into what뗩 planned for future releases.

Upgrade instructions
--------------------

   Switch your build to use Gradle @version@ by updating your wrapper:

   ``./gradlew wrapper --gradle-version=@version@``

   See the `Gradle 8.x upgrade guide <#userguide/upgrading_version_8.html#changes_@baseVersion@>`__ to
   learn about deprecations, breaking changes and other considerations when
   upgrading to Gradle @version@.

   For Java, Groovy, Kotlin, and Android compatibility, see the 
   `full compatibility notes <#userguide/compatibility.html>`__.

New features and usability improvements
---------------------------------------

.. raw:: html

   <!-- Do not add breaking changes or deprecations here! Add them to the upgrade guide instead. -->

.. raw:: html

   <!--

   ================== TEMPLATE ==============================

   <a name="FILL-IN-KEY-AREA"></a>
   ### FILL-IN-KEY-AREA improvements

   <<<FILL IN CONTEXT FOR KEY AREA>>>
   Example:
   > The [configuration cache](userguide/configuration_cache.html) improves build performance by caching the result of
   > the configuration phase. Using the configuration cache, Gradle can skip the configuration phase entirely when
   > nothing that affects the build configuration has changed.

   #### FILL-IN-FEATURE
   > HIGHLIGHT the usecase or existing problem the feature solves
   > EXPLAIN how the new release addresses that problem or use case
   > PROVIDE a screenshot or snippet illustrating the new feature, if applicable
   > LINK to the full documentation for more details

   ================== END TEMPLATE ==========================


   ==========================================================
   ADD RELEASE FEATURES BELOW
   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv -->

.. raw:: html

   <!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   ADD RELEASE FEATURES ABOVE
   ==========================================================

   -->

Promoted features
-----------------

   Promoted features are features that were incubating in previous versions
   of Gradle but are now supported and subject to backwards compatibility.
   See the User Manual section on the `Feature
   Lifecycle <#userguide/feature_lifecycle.html>`__ for more information.

   The following are the features that have been promoted in this Gradle
   release.

   .. raw:: html

      <!--
      ### Example promoted
      -->

Fixed issues
------------

   .. raw:: html

      <!--
      This section will be populated automatically
      -->

Known issues
------------

   Known issues are problems that were discovered post release that are
   directly related to changes made in this release.

   .. raw:: html

      <!--
      This section will be populated automatically
      -->

External contributions
----------------------

   We love getting contributions from the Gradle community. For information
   on contributing, please see
   `gradle.org/contribute <https://gradle.org/contribute>`__.

Reporting problems
------------------

   If you find a problem with this release, please file a bug on 
   `GitHub Issues <https://github.com/gradle/gradle/issues>`__ adhering to our
   issue guidelines. If youre not sure youre encountering a bug, please
   use the `forum <https://discuss.gradle.org/c/help-discuss>`__.

   We hope you will build happiness with Gradle, and we look forward to
   your feedback via `Twitter <https://twitter.com/gradle>`__ or on
   `GitHub <https://github.com/gradle>`__.


/Notes
======

   The Gradle team is excited to announce Gradle @version@.

   `Java 22 <#java-22>`__ is now supported for compiling, testing, and
   running JVM-based projects.

   Script compilation for the Groovy DSL can now be `avoided thanks to the build cache <#build-cache>`__.

   Additionally, this release includes improvements to 
   `build authoring <#build-authoring>`__, `error and warning messages <#error-warning>`__, 
   the `configuration cache <#configuration-cache>`__, and the `Kotlin DSL <#kotlin-dsl>`__.

   See the full release notes below for details.

   We would like to thank the following community members for their
   contributions to this release of Gradle: 
   `Aleksandr Postnov <https://github.com/alex-postnov>`__, 
   `Bj칬rn Kautler <https://github.com/Vampire>`__, 
   `Brice Dutheil <https://github.com/bric3>`__, 
   `Denis Buzmakov <https://github.com/bacecek>`__, 
   `Federico La Penna <https://github.com/flapenna>`__, 
   `Gregor Dschung <https://github.com/chkpnt>`__, 
   `Hal Deadman <https://github.com/hdeadman>`__, 
   `H칠lio Fernandes Sebasti칚o <https://github.com/helfese>`__, 
   `Ivan Gavrilovic <https://github.com/gavra0>`__, 
   `Jendrik Johannes <https://github.com/jjohannes>`__, 
   `J칬rgen Andersson <https://github.com/jorander>`__,
   `Marie <https://github.com/NyCodeGHG>`__,
   `pandaninjas <https://github.com/pandaninjas>`__, 
   `Philip Wedemann <https://github.com/hfhbd>`__, 
   `Ryan Schmitt <https://github.com/rschmitt>`__, 
   `Steffen Yount <https://github.com/steffenyount>`__, 
   `Tyler Kinkade <https://github.com/tyknkd>`__, 
   `Zed Spencer-Milnes <https://github.com/GingerGeek>`__

   Be sure to check out the `public roadmap <https://blog.gradle.org/roadmap-announcement>`__ 
   for insight into what뗩 planned for future releases.

Upgrade instructions
--------------------

   Switch your build to use Gradle @version@ by updating your wrapper:

   ``./gradlew wrapper --gradle-version=@version@``

   See the `Gradle 8.x upgrade guide <#userguide/upgrading_version_8.html#changes_@baseVersion@>`__ 
   to learn about deprecations, breaking changes and other considerations when
   upgrading to Gradle @version@.

   For Java, Groovy, Kotlin, and Android compatibility, see the 
   `full compatibility notes <#userguide/compatibility.html>`__.

New features and usability improvements
---------------------------------------

   ### Support for building projects with Java 22

   Gradle now supports `using Java 22 <#userguide/compatibility.html#java>`__ for compiling, 
   testing, and starting other Java programs. Selecting a language version is done using
   `toolchains <#userguide/toolchains.html>`__.

   You cannot run Gradle @version@ itself with Java 22 because Groovy still
   needs to support JDK 22. However, future versions are expected to
   provide this support.

   ### Avoiding Groovy build script compilation thanks to build cache
   support

   The `Gradle build cache <#userguide/build_cache.html>`__ is a mechanism
   designed to save time by reusing local or remote outputs from previous
   builds.

   In this release, `Groovy build script <#userguide/groovy_build_script_primer.html>`__ 
   compilation can benefit from the remote build cache, which, when enabled, reduces
   initial build times for developers by avoiding this step altogether.

   While this feature has been available for Kotlin build script
   compilation since the introduction of the Kotlin DSL in Gradle 5.0, the
   Groovy DSL lacked this feature parity.

   ### Build authoring improvements

   As a build grows in complexity, it can be challenging to determine when
   and where particular values are configured. Gradle provides an efficient
   way to manage this complexity using `lazy configuration <#userguide/lazy_configuration.html>`__.

Better API for updating collection properties
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

   This release improves the API for lazy collection properties, a key
   element of Gradle lazy configuration. Before this release, the
   interaction of classical collection methods, the concept of
   `convention <#userguide/designing_gradle_plugins.html#convention_over_configuration>`__,
   and the rules around empty providers have resulted in surprising
   behaviors for users in some scenarios. Based on the community feedback,
   this release of Gradle introduces alternative APIs for updating
   collections with a clearer contract:

   -  `HasMultipleValues.append*(...) <#javadoc/org/gradle/api/provider/HasMultipleValues.html#append-T->`__
      which are meant as more convenient replacements for
      ``HasMultipleValues.add*(...)``.
   -  `MapProperty.insert*(...) <#javadoc/org/gradle/api/provider/MapProperty.html#insert-K-V->`__
      which are meant as more convenient replacements for
      ``MapProperty.put*(...)``.

   The new APIs provide the following benefits:

Conventions are honored
'''''''''''''''''''''''

   One common complaint was that adding values (using
   ``ListProperty.add(...)``, ``SetProperty.add(...)`` or
   ``MapProperty.put(...)`` on top of values from a convention would result
   in losing the values from the convention.

   For example, in an applied plugin, a list property
   ``ListProperty<String>`` is configured with a convention:

   .. code:: kotlin

      listProp.convention(listOf("one"))

   In the build file, the build author adds elements to that list property:

   .. code:: kotlin

      listProp.add("two")
      // listProp now only contains "two", that뗩 confusing

   However, as explained in the snippet, the behavior is surprising. The
   newly introduced methods (such as ``ListProperty.append(...)``,
   ``SetProperty.append(...)`` and ``MapProperty.insert(...)``) allow the
   user to express that the convention should be preserved:

   .. code:: kotlin

      listProp.append("two")
      // listProp now contains ["one", "two"], as expected

Empty provider values are ignored
'''''''''''''''''''''''''''''''''

   Another common source of confusion is how empty providers are handled in
   collection properties. For instance, adding an empty provider to a
   collection property using ``add(...)`` will cause the entire property to
   become void of any values as well.

   .. code:: kotlin

      listProp.add("one")
      listProp.add(providers.environmentVariable("myEnvVar"))
      // listProp will be empty if `myEnvVar` is not defined

   In order to avoid that behavior, you can instead use the new update APIs
   introduced in this release (such as ``ListProperty.append(...)``,
   ``SetProperty.append(...)`` and ``MapProperty.insert(...)``):

   .. code:: kotlin

      listProp.append("one")
      listProp.append(providers.environmentVariable("myEnvVar"))
      // listProp will still contain "one" if myEnvVar is not defined

   ### Error and warning reporting improvements

   Gradle provides a rich set of error and warning messages to help you
   understand and resolve problems in your build.

Improved plugin application error reporting
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

   When `applying a plugin <#userguide/plugins.html#sec:plugins_block>`__
   that requires a higher version of Gradle 
   (`by specifying the org.gradle.plugin.api-version attribute <#userguide/variant_attributes.html#sub:gradle_plugins_default_attributes>`__),
   the error message when dependency resolution fails will now clearly
   state the issue:

   ::

      FAILURE: Build failed with an exception.

      * What went wrong:
      A problem occurred configuring root project 'example'.
      > Could not resolve all files for configuration ':classpath'.
         > Could not resolve com.example:plugin:1.0.
           Required by:
               project : > com.example.greeting:com.example.greeting.gradle.plugin:1.0
            > Plugin com.example:plugin:1.0 requires at least Gradle 8.0. This build uses Gradle 7.6.

      * Try:
      > Upgrade to at least Gradle 8.0. See the instructions at https://docs.gradle.org/8.7/userguide/upgrading_version_8.html#sub:updating-gradle.
      > Downgrade plugin com.example:plugin:1.0 to an older version compatible with Gradle 7.6.

   The failure뗩 suggested resolutions will include upgrading your version
   of Gradle or downgrading the version of the plugin. This replaces the
   previous low-level incompatibility message containing details about all
   the attributes involved in the plugin request.

Improved copy task error reporting
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

   When including a compressed archive in a `Copy <#javadoc/org/gradle/api/tasks/Copy.html>`__ 
   task results in duplicate files and
   `DuplicatesStrategy.Fail <#javadoc/org/gradle/api/file/DuplicatesStrategy.html#FAIL>`__
   is used, the error message will now clearly state the issue:

   ::

      Cannot copy file <SOURCE_FILE> to <DESTINATION_DIR> because file <OTHER_SOURCE_FILE> has already been copied there. 

Suppressable 딳ependencies-without-versions validation error
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

   When `generating Gradle Module Metadata files <#userguide/publishing_gradle_module_metadata.html>`__, 
   Gradle prevents your project from publishing broken metadata by looking for
   common configuration errors.

   One of those errors is publishing metadata with dependencies that do not
   have versions. This validation error can now be suppressed as there are
   use cases where such metadata is valid:

   .. code:: groovy

      tasks.withType(GenerateModuleMetadata).configureEach {
          suppressedValidationErrors.add('dependencies-without-versions')
      }

Configuration cache improvements
--------------------------------

   The `configuration cache <#userguide/configuration_cache.html>`__
   improves build time by caching the result of the configuration phase and
   reusing it for subsequent builds. This feature can significantly improve
   build performance.

Cleaner stack traces in the configuration cache report
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

   The stack traces shown in the `configuration cache report <#userguide/configuration_cache.html#config_cache:troubleshooting>`__
   for forbidden API calls can be long and contain internal Gradle frames
   that do not always help to troubleshoot the issue. With this release,
   internal stack frames are collapsed by default to highlight the build
   logic that triggered the error:

   `Collapsed stack frames in the configuration cache report <https://docs.gradle.org/current/release-notes.html#configuration-cache-improvements>`__

   The collapsed frames can still be expanded and examined if necessary.

Supporting standard streams as task property values
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

   The standard streams (``System.in``, ``System.out``, and ``System.err``)
   can now be used as ``standardInput``, ``standardOutput``, and
   ``errorOutput`` of `Exec <#javadoc/org/gradle/api/tasks/Exec.html>`__
   and `JavaExec <#javadoc/org/gradle/api/tasks/JavaExec.html>`__ tasks
   without breaking configuration caching.

   User created tasks with properties of types ``java.io.InputStream`` and
   ``java.io.OutputStream`` can also use the standard streams as property
   values. Setting up custom standard streams with ``System.setIn``,
   ``System.setOut``, and ``System.setErr`` isn뗪 supported.

Kotlin DSL improvements
-----------------------

Embedded Kotlin upgrade to 1.9.22
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

   The embedded Kotlin has been updated from 1.9.10 to 
   `Kotlin 1.9.22 <https://github.com/JetBrains/kotlin/releases/tag/v1.9.22>`__.

Kotlin DSL Reference update
^^^^^^^^^^^^^^^^^^^^^^^^^^^

   Javadocs generated from Java code now support a 랍ince section,
   indicating the Gradle version when the functionality was introduced.

   The information comes from the ``@since`` tags in the Javadoc, which
   haven뗪 been displayed until now. An example can be found at
   `JavaToolchainSpec <#kotlin-dsl/gradle/org.gradle.jvm.toolchain/-java-toolchain-spec/index.html>`__.

Other improvements
~~~~~~~~~~~~~~~~~~

Generating concise projects with Gradle init
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

   Using the new ``--no-comments`` option allows `Gradle init <#userguide/build_init_plugin.html>`__ 
   to generate new projects that
   contain code without comments. The resulting build files and source
   files are smaller and less verbose.

   ::

      gradle init --use-defaults --type kotlin-library --no-comments

   You can permanently set this preference by configuring the
   ``org.gradle.buildinit.comments`` property to ``false`` in 
   `Gradle properties <#userguide/build_environment.html#sec:gradle_configuration_properties>`__.

Shared build service registration without parameters
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

   Gradle enables tasks to share state or resources, such as pre-computed
   values or external services, through `build services <#userguide/build_services.html>`__, 
   which are objects holding
   the state for task use. A build service can optionally take parameters,
   which Gradle injects into the service instance when creating it.

   `Shared build services <#userguide/build_services.html>`__ that do not
   require additional configuration can now be registered without having to
   provide an empty configuration action using the updated
   `registerIfAbsent() <#/javadoc/org/gradle/api/services/BuildServiceRegistry.html#registerIfAbsent-java.lang.String-java.lang.Class-org.gradle.api.Action->`__
   method:

   ::

      gradle.sharedServices.registerIfAbsent("counter", CountingService, voidAction)  // Old method
      gradle.sharedServices.registerIfAbsent("counter", CountingService)      // New method

Support for TestNG뗩 threadPoolFactoryClass parameter
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

   `TestNG <https://testng.org/>`__ is a testing framework supported in
   Gradle. In TestNG, the ``threadPoolFactoryClass`` attribute is used to
   specify a custom thread pool factory class, which details how TestNG
   manages threads for parallel test execution.

   The ``threadPoolFactoryClass`` parameter can now be configured on
   `TestNGOptions <#javadoc/org/gradle/api/tasks/testing/testng/TestNGOptions.html>`__
   for TestNG versions that support it (i.e., TestNG 7.0.0 and above):

   ::

      testing {
          suites {
              test {
                  useTestNG("7.5")
                  targets {
                      all {
                          testTask.configure {
                              options.threadPoolFactoryClass = "com.example.MyThreadPoolFactory"
                          }
                      }
                  }
              }
          }     
      }

   An error will occur if this parameter is set for a version of TestNG
   that does not support it.

Consistent sorting of ignored keys in the metadata verification file
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

   To mitigate the security risks and avoid integrating compromised
   dependencies in your project, Gradle supports 
   `dependency verification <#userguide/dependency_verification.html>`__. Dependency
   verification is typically done using checksums or digital signatures.
   Gradle verifies that downloaded artifacts match the expected checksums
   or are signed with trusted keys.

   Before this release, the *ignored keys* list in the 
   `metadata verification file <#userguide/dependency_verification.html#sub:verification-metadata>`__
   was not properly sorted by Gradle so that the order would change
   depending on the execution order, impacting the reproducibility of the
   build and checksums for the file. In this release, the order is
   guaranteed to be preserved regardless of the execution order.

Better support for symlinks with File System Watching
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

   Gradle maintains a `Virtual File System <#userguide/file_system_watching.html#sec:daemon_watch_fs>`__
   (VFS) to calculate what needs to be rebuilt on repeat builds of a
   project. By watching the file system, Gradle keeps the VFS current
   between builds, reducing the required I/O operations.

   This version fixes a problem with detecting content changes indirectly
   referenced via symlinks, improving the build뗩 correctness.

Support for constraints in JVM test suite dependencies block
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

   The `strongly-typed dependencies block introduced in Gradle 7.6 <#../7.6/release-notes.html#strongly-typed-dependencies>`__ did not
   support dependency constraints.

   In this release, dependency constraints can now be added:

   .. code:: kotlin

      testing {
          suites {
              getByName<JvmTestSuite>("test") {
                  dependencies {
                      implementation(constraint("foo:bar:1.0"))
                  }
              }
          }
      }

   Providing separate strings or using named arguments for each part is not
   supported currently.

Fixed issues
------------

   .. raw:: html

      <!--
      This section will be populated automatically
      -->

Known issues
------------

   Known issues are problems that were discovered post release that are
   directly related to changes made in this release.

   .. raw:: html

      <!--
      This section will be populated automatically
      -->

External contributions
----------------------

   We love getting contributions from the Gradle community. For information
   on contributing, please see
   `gradle.org/contribute <https://gradle.org/contribute>`__.

Reporting problems
------------------

   If you find a problem with this release, please file a bug on 
   `GitHub Issues <https://github.com/gradle/gradle/issues>`__ adhering to our
   issue guidelines. If youre not sure youre encountering a bug, please
   use the `forum <https://discuss.gradle.org/c/help-discuss>`__.

   We hope you will build happiness with Gradle, and we look forward to
   your feedback via `Twitter <https://twitter.com/gradle>`__ or on
   `GitHub <https://github.com/gradle>`__.


/Gradle Module Metadata 1.0 specification
=========================================

   Consumption of Gradle Module Metadata is automatic. However publication
   needs to be enabled explicitly for any Gradle version prior to Gradle 6.

   Publishing Gradle Module Metadata can be enabled in Gradle settings file
   (``settings.gradle``):

   ::

      enableFeaturePreview("GRADLE_METADATA")

Goal
----

   This document describes version 1.0 of the Gradle module metadata file.
   A module metadata file describes the contents of a *module*, which is
   the unit of publication for a particular repository format, such as a
   module in a Maven repository. This is often called a 랋ackage in many
   repository formats.

   The module metadata file is a JSON file published alongside the existing
   repository specific metadata files, such as a Maven POM or Ivy
   descriptor. It adds additional metadata that can be used by Gradle
   versions and other tooling that understand the format. This allows the
   rich Gradle model to be mapped to and 랎unnelled through existing
   repository formats, while continuing to support existing Gradle versions
   and tooling that does not understand the format.

   The module metadata file is intended to be machine generated rather than
   written by a human, but is intended to be human readable.

   The module metadata file is also intended to fully describe the binaries
   in the module where it is present so that it can replace the existing
   metadata files. This would allow a Gradle repository format to be added,
   for example.

   In version 1.0, the module metadata file can describe only those modules
   that contain a single *component*, which is some piece of software such
   as a library or application. Support for more sophisticated mappings may
   be added by later versions.

Usage in a Maven repository
---------------------------

   When present in a Maven module, the file must have extension ``module``.
   For example, in version 1.2 of 딼ylib, the file should be called
   ``mylib-1.2.module``.

   Gradle ignores the contents of the Maven POM when the module metadata
   file is present.

Contents
--------

   The file must be encoded using UTF-8.

   The file must contain a JSON object with the following values:

   -  ``formatVersion``: must be present and the first value of the JSON
      object. Its value must be ``"1.0"``
   -  ``component``: optional. Describes the identity of the component
      contained in the module.
   -  ``createdBy``: optional. Describes the producer of this metadata file
      and the contents of the module.
   -  ``variants``: optional. Describes the variants of the component
      packaged in the module, if any.

``component`` value
~~~~~~~~~~~~~~~~~~~

   This value must contain an object with the following values:

   -  ``group``: The group of this component. A string
   -  ``module``: The module name of this component. A string
   -  ``version``: The version of this component. A string
   -  ``url``: optional. When present, indicates where the metadata for the
      component may be found. When missing, indicates that this metadata
      file defines the metadata for the whole component.

``createdBy`` value
~~~~~~~~~~~~~~~~~~~

   This value must contain an object with the following values:

   -  ``gradle``: optional. Describes the Gradle instance that produced the
      contents of the module.

``gradle`` value
~~~~~~~~~~~~~~~~

   This value, nested in ``createdBy``, must contain an object with the
   following values:

   -  ``version``: The version of Gradle. A string
   -  ``buildId``: The buildId for the Gradle instance. A string

``variants`` value
~~~~~~~~~~~~~~~~~~

   This value must contain an array with zero or more elements. Each
   element must be an object with the following values:

   -  ``name``: The name of the variant. A string. The name must be unique
      across all variants of the component.
   -  ``attributes``: optional. When missing the variant is assumed to have
      no attributes.
   -  ``available-at``: optional. Information about where the metadata and
      files of this variant are available.
   -  ``dependencies``: optional. When missing the variant is assumed to
      have no dependencies. Must not be present when ``available-at`` is
      present.
   -  ``files``: optional. When missing the variant is assumed to have no
      files. Must not be present when ``available-at`` is present.
   -  ``capabilities``: optional. When missing the variant is assumed to
      declared no specific capability.

``attributes`` value
~~~~~~~~~~~~~~~~~~~~

   This value, nested in ``variants`` or elements of ``dependencies`` or
   ``dependencyConstraints`` nodes, must contain an object with a value for
   each attribute. The attribute value must be a string or boolean.

``capabilities`` value
~~~~~~~~~~~~~~~~~~~~~~

   This value must contain an array of 0 or more capabilities. Each
   capability is an object consisting of the mandatory following values:

   -  ``group``: The group of the capability. A string.
   -  ``name``: The name of the capability. A string.
   -  ``version``: The name of the capability. A string.

Standard attributes
^^^^^^^^^^^^^^^^^^^

   -  ``org.gradle.usage`` indicates the purpose of the variant. See the
      ``org.gradle.api.attributes.Usage`` class for more details. Value
      must be a string.
   -  ``org.gradle.status`` indicates the kind of release: one of
      ``release`` or ``integration``.
   -  ``org.gradle.category`` indicates the type of component (library,
      platform or documentation). This attribute is mostly used to
      disambiguate Maven POM files derived either as a platform or a
      library. Value must be a string.
   -  ``org.gradle.libraryelements`` indicates the content of a
      ``org.gradle.category=library`` variant, like ``jar``, ``classes`` or
      ``headers-cplusplus``. Value must be a string.
   -  ``org.gradle.docstype`` indicates the documentation type of a
      ``org.gradle.category=documentation`` variant, like ``javadoc``,
      ``sources`` or ``doxygen``. Value must be a string.
   -  ``org.gradle.dependency.bundling`` indicates how dependencies of the
      variant are bundled. Either externally, embedded or shadowed. See the
      ``org.gradle.api.attributes.Bundling`` for more details. Value must
      be a string.

Deprecated attributes value
'''''''''''''''''''''''''''

   The ``org.gradle.usage`` attribute has seen an evolution for its values.
   The values ``java-api-*`` and ``java-runtime-*`` are now deprecated and
   replaced by a new combination.

   The values for the Java ecosystem are now limited to ``java-api`` /
   ``java-runtime`` combined with the relevant value for
   ``org.gradle.libraryelements``.

   Values for the native ecosystem remain unaffected.

   Existing metadata must remain compatible and thus tools supporting the
   Gradle Module Metadata format must support both old and new values,
   while no longer publishing the deprecated ones.

Java Ecosystem specific attributes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

   -  ``org.gradle.jvm.version`` indicated the minimal target JVM version
      of a library. For example is built for java 8, its minimal target is
      ``8``. If it뗩 a multi-release jar for Java 9, 10 and 11, it뗩
      minimal target is ``9``. Value must be an integer corresponding to
      the Java version.

Native ecosystem specific attributes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

   -  ``org.gradle.native.debuggable`` indicates native binaries that are
      debuggable. Value must be a boolean.

``available-at`` value
~~~~~~~~~~~~~~~~~~~~~~

   This value, nested in ``variants``, must contain an object with the
   following values:

   -  ``url``: The location of the metadata file that describes the
      variant. A string. In version 1.0, this must be a path relative to
      the module.
   -  ``group``: The group of the module. A string
   -  ``module``: The name of the module. A string
   -  ``version``: The version of the module. A string

``dependencies`` value
~~~~~~~~~~~~~~~~~~~~~~

   This value, nested in ``variants``, must contain an array with zero or
   more elements. Each element must be an object with the following values:

   -  ``group``: The group of the dependency.
   -  ``module``: The module of the dependency.
   -  ``version``: optional. The version constraint of the dependency.
   -  ``excludes``: optional. Defines the exclusions that apply to this
      dependency.
   -  ``reason``: optional. A explanation why the dependency is used. Can
      typically be used to explain why a specific version is requested.
   -  ``attributes``: optional. If set, attributes will override the
      consumer attributes during dependency resolution for this specific
      dependency.
   -  ``requestedCapabilities``: optional. If set, declares the
      capabilities that the dependency must provide in order to be
      selected. See ``capabilities`` above for the format.

``version`` value
^^^^^^^^^^^^^^^^^

   This value, nested in elements of the ``dependencies`` or
   ``dependencyConstraints`` nodes, defines the version constraint of a
   dependency or dependency constraint. Has the same meaning as ``version``
   in the Gradle DSL. A version constraint consists of: - ``requires``:
   optional. The required version for this dependency. - ``prefers``:
   optional. The preferred version for this dependency. - ``strictly``:
   optional. A strictly enforced version requirement for this dependency. -
   ``rejects``: optional. An array of rejected versions for this
   dependency.

``excludes`` value
^^^^^^^^^^^^^^^^^^

   This value, nested in elements of the ``dependencies`` node, must
   contain an array with zero or more elements. Each element has the same
   meaning as ``exclude`` in the Gradle DSL.

   Each element must be an object with the of the following values:

   -  ``group``: The group to exclude from transitive dependencies, or
      wildcard 뗖* if any group may be excluded.
   -  ``module``: The module to exclude from transitive dependencies, or
      wildcard 뗖* if any module may be excluded.

   An exclude that has a wildcard value for both ``group`` and ``module``
   will exclude *all* transitive dependencies.

``dependencyConstraints`` value
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This value, nested in ``variants``, must contain an array with zero or
   more elements. Each element must be an object with the following values:

   -  ``group``: The group of the dependency constraint.
   -  ``module``: The module of the dependency constraint.
   -  ``version``: optional. The version constraint of the dependency
      constraint.
   -  ``reason``: optional. A explanation why the constraint is used. Can
      typically be used to explain why a specific version is rejected, or
      from where a platform comes from.
   -  ``attributes``: optional. If set, attributes will override the
      consumer attributes during dependency resolution for this specific
      dependency.

``files`` value
~~~~~~~~~~~~~~~

   This value, nested in ``variants``, must contain an array with zero or
   more elements. Each element must be an object with the following values:

   -  ``name``: The name of the file. A string. This will be used to
      calculate the identity of the file in the cache, which means it must
      be unique across variants for different files.
   -  ``url``: The location of the file. A string. In version 1.0, this
      must be a path relative to the module.
   -  ``size``: The size of the file in bytes. A number.
   -  ``sha1``: The SHA1 hash of the file content. A hex string.
   -  ``md5``: The MD5 hash of the file content. A hex string.

Changelog
~~~~~~~~~

   1.0
   ^^^

   -  Initial release

Example
-------

   ::

   {
       "formatVersion": "1.0",
       "component": {
           "group": "my.group",
           "module": "mylib",
           "version": "1.2"
       },
       "createdBy": {
           "gradle": {
               "version": "4.3",
               "buildId": "abc123"
           }
       },
       "variants": [
           {
               "name": "api",
               "attributes": {
                   "org.gradle.usage": "java-api",
                   "org.gradle.category": "library",
                   "org.gradle.libraryelements": "jar"
               },
               "files": [
                   { 
                       "name": "mylib-api.jar", 
                       "url": "mylib-api-1.2.jar",
                       "size": "1453",
                       "sha1": "abc12345",
                       "md5": "abc12345"
                   }
               ],
               "dependencies": [
                   { 
                       "group": "some.group", 
                       "module": "other-lib", 
                       "version": { "requires": "3.4" },
                       "excludes": [
                           { "group": "*", "module": "excluded-lib" }
                       ],
                       "attributes": {
                          "buildType": "debug"
                       }
                   }
               ]
           },
           {
               "name": "runtime",
               "attributes": {
                   "org.gradle.usage": "java-runtime",
                   "org.gradle.category": "library",
                   "org.gradle.libraryelements": "jar"
               },
               "files": [
                   { 
                       "name": "mylib.jar", 
                       "url": "mylib-1.2.jar",
                       "size": "4561",
                       "sha1": "abc12345",
                       "md5": "abc12345"
                   }
               ],
               "dependencies": [
                   { 
                       "group": "some.group", 
                       "module": "other-lib", 
                       "version": { "requires": "[3.0, 4.0)", "prefers": "3.4", "rejects": ["3.4.1"] } 
                   }
               ],
               "dependencyConstraints": [
                   { 
                       "group": "some.group", 
                       "module": "other-lib-2", 
                       "version": { "requires": "1.0" } 
                   }
               ]
           }
       ]
   }

/Gradle Module Metadata 1.1 specification
=========================================

   *Gradle Module Metadata 1.1 is supported in Gradle 6.*

   Gradle publishes Gradle Module Metadata along with traditional metadata.
   Gradle Module Metadata is automatically consumed when available.

Goal
----

   This document describes version 1.1 of the Gradle module metadata file
   format. A module metadata file describes the contents of a *module*,
   which is the unit of publication for a particular repository format,
   such as a module in a Maven repository. This is often called a 랋ackage
   in many repository formats.

   The module metadata file is a JSON file published alongside the existing
   repository specific metadata files, such as a Maven POM or Ivy
   descriptor. It adds additional metadata that can be used by Gradle
   versions and other tooling that understand the format. This allows the
   rich Gradle model to be mapped to and 랎unnelled through existing
   repository formats, while continuing to support existing Gradle versions
   and tooling that does not understand the format.

   The module metadata file is intended to be machine generated rather than
   written by a human, but is intended to be human readable.

   The module metadata file is also intended to fully describe the binaries
   in the module where it is present so that it can replace the existing
   metadata files. This would allow a Gradle repository format to be added,
   for example.

   In version 1.0, the module metadata file can describe only those modules
   that contain a single *component*, which is some piece of software such
   as a library or application. Support for more sophisticated mappings may
   be added by later versions.

Usage in a Maven repository
---------------------------

   When present in a Maven module, the file must have extension ``module``.
   For example, in version 1.2 of 딼ylib, the file should be called
   ``mylib-1.2.module``.

   Gradle ignores the contents of the Maven POM when the module metadata
   file is present.

Contents
--------

   The file must be encoded using UTF-8.

   The file must contain a JSON object with the following values:

   -  ``formatVersion``: must be present and the first value of the JSON
      object. Its value must be ``"1.1"``
   -  ``component``: optional. Describes the identity of the component
      contained in the module.
   -  ``createdBy``: optional. Describes the producer of this metadata file
      and the contents of the module.
   -  ``variants``: optional. Describes the variants of the component
      packaged in the module, if any.

``component`` value
~~~~~~~~~~~~~~~~~~~

   This value must contain an object with the following values:

   -  ``group``: The group of this component. A string
   -  ``module``: The module name of this component. A string
   -  ``version``: The version of this component. A string
   -  ``url``: optional. When present, indicates where the metadata for the
      component may be found. When missing, indicates that this metadata
      file defines the metadata for the whole component.

``createdBy`` value
~~~~~~~~~~~~~~~~~~~

   This value must contain an object with the following values:

   -  ``gradle``: optional. Describes the Gradle instance that produced the
      contents of the module.

``gradle`` value
~~~~~~~~~~~~~~~~

   This value, nested in ``createdBy``, must contain an object with the
   following values:

   -  ``version``: The version of Gradle. A string
   -  ``buildId``: optional. The buildId for the Gradle instance. A string

``variants`` value
~~~~~~~~~~~~~~~~~~

   This value must contain an array with zero or more elements. Each
   element must be an object with the following values:

   -  ``name``: The name of the variant. A string. The name must be unique
      across all variants of the component.
   -  ``attributes``: optional. When missing the variant is assumed to have
      no attributes.
   -  ``available-at``: optional. Information about where the metadata and
      files of this variant are available.
   -  ``dependencies``: optional. When missing the variant is assumed to
      have no dependencies. Must not be present when ``available-at`` is
      present.
   -  ``dependencyConstraints``: optional. When missing the variant is
      assumed to have no dependency constraints. Must not be present when
      ``available-at`` is present.
   -  ``files``: optional. When missing the variant is assumed to have no
      files. Must not be present when ``available-at`` is present.
   -  ``capabilities``: optional. When missing the variant is assumed to
      declared no specific capability.

   The following statements must hold for the variants:

   -  Variant name must be unique per module
   -  Each variant must have at least one attribute
   -  Two variants cannot have the same attributes and capabilities
   -  If there is at least one dependency in any variant, at least one must
      carry version information

``attributes`` value
~~~~~~~~~~~~~~~~~~~~

   This value, nested in ``variants`` or elements of ``dependencies`` or
   ``dependencyConstraints`` nodes, must contain an object with a value for
   each attribute. The attribute value must be a string or boolean.

``capabilities`` value
~~~~~~~~~~~~~~~~~~~~~~

   This value must contain an array of 0 or more capabilities. Each
   capability is an object consisting of the mandatory following values:

   -  ``group``: The group of the capability. A string.
   -  ``name``: The name of the capability. A string.
   -  ``version``: The name of the capability. A string.

Standard attributes
^^^^^^^^^^^^^^^^^^^

   -  ``org.gradle.usage`` indicates the purpose of the variant. See the
      ``org.gradle.api.attributes.Usage`` class for more details. Value
      must be a string.
   -  ``org.gradle.status`` indicates the kind of release: one of
      ``release`` or ``integration``.
   -  ``org.gradle.category`` indicates the type of component (library,
      platform or documentation). This attribute is mostly used to
      disambiguate Maven POM files derived either as a platform or a
      library. Value must be a string.
   -  ``org.gradle.libraryelements`` indicates the content of a
      ``org.gradle.category=library`` variant, like ``jar``, ``classes`` or
      ``headers-cplusplus``. Value must be a string.
   -  ``org.gradle.docstype`` indicates the documentation type of a
      ``org.gradle.category=documentation`` variant, like ``javadoc``,
      ``sources`` or ``doxygen``. Value must be a string.
   -  ``org.gradle.dependency.bundling`` indicates how dependencies of the
      variant are bundled. Either externally, embedded or shadowed. See the
      ``org.gradle.api.attributes.Bundling`` for more details. Value must
      be a string.

Deprecated attributes value
'''''''''''''''''''''''''''

   The ``org.gradle.usage`` attribute has seen an evolution for its values.
   The values ``java-api-*`` and ``java-runtime-*`` are now deprecated and
   replaced by a new combination.

   The values for the Java ecosystem are now limited to ``java-api`` /
   ``java-runtime`` combined with the relevant value for
   ``org.gradle.libraryelements``.

   Values for the native ecosystem remain unaffected.

   Existing metadata must remain compatible and thus tools supporting the
   Gradle Module Metadata format must support both old and new values,
   while no longer publishing the deprecated ones.

Java Ecosystem specific attributes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

   -  ``org.gradle.jvm.version`` indicated the minimal target JVM version
      of a library. For example is built for java 8, its minimal target is
      ``8``. If it뗩 a multi-release jar for Java 9, 10 and 11, it뗩
      minimal target is ``9``. Value must be an integer corresponding to
      the Java version.

Native ecosystem specific attributes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

   -  ``org.gradle.native.debuggable`` indicates native binaries that are
      debuggable. Value must be a boolean.

``available-at`` value
~~~~~~~~~~~~~~~~~~~~~~

   This value, nested in ``variants``, must contain an object with the
   following values:

   -  ``url``: The location of the metadata file that describes the
      variant. A string. In version 1.0 and 1.1, this must be a path
      relative to the module.
   -  ``group``: The group of the module. A string
   -  ``module``: The name of the module. A string
   -  ``version``: The version of the module. A string

   Note that the ``group:module`` cannot be the same as the
   ``group:module`` of the root ``component`` element.

``dependencies`` value
~~~~~~~~~~~~~~~~~~~~~~

   This value, nested in ``variants``, must contain an array with zero or
   more elements. Each element must be an object with the following values:

   -  ``group``: The group of the dependency.
   -  ``module``: The module of the dependency.
   -  ``version``: optional. The version constraint of the dependency.
   -  ``excludes``: optional. Defines the exclusions that apply to this
      dependency.
   -  ``reason``: optional. A explanation why the dependency is used. Can
      typically be used to explain why a specific version is requested.
   -  ``attributes``: optional. If set, attributes will override the
      consumer attributes during dependency resolution for this specific
      dependency.
   -  ``requestedCapabilities``: optional. If set, declares the
      capabilities that the dependency must provide in order to be
      selected. See ``capabilities`` above for the format.
   -  ``endorseStrictVersions``: optional. If set to ``true``, all strict
      versions of the target module will be treated as if they were defined
      on the variant defining this dependency.
   -  ``thirdPartyCompatibility``: optional. Includes additional
      information to be used if the dependency points at a module that did
      **not** publish Gradle module metadata.

``version`` value
^^^^^^^^^^^^^^^^^

   This value, nested in elements of the ``dependencies`` or
   ``dependencyConstraints`` nodes, defines the version constraint of a
   dependency or dependency constraint. Has the same meaning as ``version``
   in the Gradle DSL. A version constraint consists of: - ``requires``:
   optional. The required version for this dependency. - ``prefers``:
   optional. The preferred version for this dependency. - ``strictly``:
   optional. A strictly enforced version requirement for this dependency. -
   ``rejects``: optional. An array of rejected versions for this
   dependency.

``excludes`` value
^^^^^^^^^^^^^^^^^^

   This value, nested in elements of the ``dependencies`` node, must
   contain an array with zero or more elements. Each element has the same
   meaning as ``exclude`` in the Gradle DSL.

   Each element must be an object with the of the following values:

   -  ``group``: The group to exclude from transitive dependencies, or
      wildcard 뗖* if any group may be excluded.
   -  ``module``: The module to exclude from transitive dependencies, or
      wildcard 뗖* if any module may be excluded.

   An exclude that has a wildcard value for both ``group`` and ``module``
   will exclude *all* transitive dependencies.

``dependencyConstraints`` value
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This value, nested in ``variants``, must contain an array with zero or
   more elements. Each element must be an object with the following values:

   -  ``group``: The group of the dependency constraint.
   -  ``module``: The module of the dependency constraint.
   -  ``version``: optional. The version constraint of the dependency
      constraint.
   -  ``reason``: optional. A explanation why the constraint is used. Can
      typically be used to explain why a specific version is rejected, or
      from where a platform comes from.
   -  ``attributes``: optional. If set, attributes will override the
      consumer attributes during dependency resolution for this specific
      dependency.

``files`` value
~~~~~~~~~~~~~~~

   This value, nested in ``variants``, must contain an array with zero or
   more elements. Each element must be an object with the following values:

   -  ``name``: The name of the file. A string. This will be used to
      calculate the identity of the file in the cache, which means it must
      be unique across variants for different files.
   -  ``url``: The location of the file. A string. In version 1.0, this
      must be a path relative to the module.
   -  ``size``: The size of the file in bytes. A number.
   -  ``sha1``: The SHA1 hash of the file content. A hex string.
   -  ``sha256``: The SHA-256 hash of the file content. A hex string.
   -  ``sha512``: The SHA-512 hash of the file content. A hex string.
   -  ``md5``: The MD5 hash of the file content. A hex string.

``thirdPartyCompatibility`` value
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This value, nested in elements of the ``dependencies`` node, includes
   additional information to be used if the dependency points at a module
   that did **not** publish Gradle module metadata.

   -  ``artifactSelector``: Information to select a specific artifact
      (identified by ``name``, ``type``, ``extension``, and ``classifier``)
      of the dependency that is not mentioned in the dependency뗩 metadata.
      These are typically artifacts published with Maven that contain a
      *classifier*.

   Changelog
   ~~~~~~~~~

   1.1
   ^^^

   -  Adds support to *endorse strict versions* defined in another module:
      ``{ "group": "some.group", "module": "other-lib", "version": { "requires": "3.4" }, "endorseStrictVersions": "true"``
   -  Adds ``thirdPartyCompatibility`` features for better compatibility
      with maven and ivy metadata

   .. _section-1:

   1.0
   ^^^

   -  Initial release

Example
-------

::

   {
       "formatVersion": "1.0",
       "component": {
           "group": "my.group",
           "module": "mylib",
           "version": "1.2"
       },
       "createdBy": {
           "gradle": {
               "version": "4.3",
               "buildId": "abc123"
           }
       },
       "variants": [
           {
               "name": "api",
               "attributes": {
                   "org.gradle.usage": "java-api",
                   "org.gradle.category": "library",
                   "org.gradle.libraryelements": "jar"
               },
               "files": [
                   { 
                       "name": "mylib-api.jar", 
                       "url": "mylib-api-1.2.jar",
                       "size": "1453",
                       "sha1": "abc12345",
                       "md5": "abc12345"
                   }
               ],
               "dependencies": [
                   { 
                       "group": "some.group", 
                       "module": "other-lib", 
                       "version": { "requires": "3.4" },
                       "excludes": [
                           { "group": "*", "module": "excluded-lib" }
                       ],
                       "attributes": {
                          "buildType": "debug"
                       }
                   }
               ]
           },
           {
               "name": "runtime",
               "attributes": {
                   "org.gradle.usage": "java-runtime",
                   "org.gradle.category": "library",
                   "org.gradle.libraryelements": "jar"
               },
               "files": [
                   { 
                       "name": "mylib.jar", 
                       "url": "mylib-1.2.jar",
                       "size": "4561",
                       "sha1": "abc12345",
                       "md5": "abc12345"
                   }
               ],
               "dependencies": [
                   { 
                       "group": "some.group", 
                       "module": "other-lib", 
                       "version": { "requires": "[3.0, 4.0)", "prefers": "3.4", "rejects": ["3.4.1"] } 
                   }
               ],
               "dependencyConstraints": [
                   { 
                       "group": "some.group", 
                       "module": "other-lib-2", 
                       "version": { "requires": "1.0" } 
                   }
               ]
           }
       ]
   }
/c/dl/pl/gradle-8.7.0/platforms/documentation/docs/src /c/opendocs

/Topic: 游댯 Overview
=====================


/docs/userguide/userguide_single.adoc
=====================================

.. code-block::

   = Gradle User Manual: Version {gradleVersion}
   :description: Single-page Gradle User Manual for Gradle {gradleVersion}
   :meta-name-robots: noindex
   :meta-name-twitter_card: summary
   :meta-name-twitter_site: @gradle
   :meta-name-twitter_creator: @gradle
   :meta-name-twitter_title: Gradle User Manual: Version {gradleVersion}
   :meta-name-twitter_description: {description}
   :meta-name-twitter_url: {docsUrl}/{gradleVersion}/userguide/{docname}.html
   :meta-name-twitter_image: {website}/images/gradle-256x256.png
   
   toc::[leveloffset=+2]
   
   == **OVERVIEW**
   
   include::userguide.adoc[leveloffset=+2]
   include::about_manual.adoc[leveloffset=+2]
   
   '''
   
   == **RELEASES**
   
   include::installation.adoc[leveloffset=+2]
   include::compatibility.adoc[leveloffset=+2]
   include::feature_lifecycle.adoc[leveloffset=+2]
   
   == **RUNNING GRADLE BUILDS**
   
   == CORE CONCEPTS
   
   include::gradle_basics.adoc[leveloffset=+2]
   include::gradle_wrapper_basics.adoc[leveloffset=+2]
   include::command_line_interface_basics.adoc[leveloffset=+2]
   include::settings_file_basics.adoc[leveloffset=+2]
   include::build_file_basics.adoc[leveloffset=+2]
   include::dependency_management_basics.adoc[leveloffset=+2]
   include::task_basics.adoc[leveloffset=+2]
   include::plugin_basics.adoc[leveloffset=+2]
   include::gradle_optimizations.adoc[leveloffset=+2]
   include::build_scans.adoc[leveloffset=+2]
   
   == OTHER TOPICS
   
   include::continuous_builds.adoc[leveloffset=+2]
   
   == **AUTHORING GRADLE BUILDS**
   
   == THE BASICS
   
   include::gradle_directories.adoc[leveloffset=+2]
   include::intro_multi_project_builds.adoc[leveloffset=+2]
   include::build_lifecycle.adoc[leveloffset=+2]
   include::writing_settings_files.adoc[leveloffset=+2]
   include::writing_build_scripts.adoc[leveloffset=+2]
   include::tutorial_using_tasks.adoc[leveloffset=+2]
   include::writing_tasks.adoc[leveloffset=+2]
   include::plugins.adoc[leveloffset=+2]
   include::writing_plugins.adoc[leveloffset=+2]
   
   == STRUCTURING BUILDS
   
   include::multi_project_builds.adoc[leveloffset=+2]
   include::declaring_dependencies_between_subprojects.adoc[leveloffset=+2]
   include::sharing_build_logic_between_subprojects.adoc[leveloffset=+2]
   include::composite_builds.adoc[leveloffset=+2]
   include::multi_project_configuration_and_execution.adoc[leveloffset=+2]
   
   == DEVELOPING TASKS
   
   include::more_about_tasks.adoc[leveloffset=+2]
   include::lifecycle_tasks.adoc[leveloffset=+2]
   include::actionable_tasks.adoc[leveloffset=+2]
   include::lazy_configuration.adoc[leveloffset=+2]
   include::worker_api.adoc[leveloffset=+2]
   include::custom_tasks.adoc[leveloffset=+2]
   
   == DEVELOPING PLUGINS
   
   include::custom_plugins.adoc[leveloffset=+2]
   include::implementing_gradle_plugins.adoc[leveloffset=+2]
   include::implementing_gradle_plugins_precompiled.adoc[leveloffset=+2]
   include::implementing_gradle_plugins_binary.adoc[leveloffset=+2]
   include::testing_gradle_plugins.adoc[leveloffset=+2]
   include::publishing_gradle_plugins.adoc[leveloffset=+2]
   
   == BEST PRACTICES
   
   include::organizing_gradle_projects.adoc[leveloffset=+2]
   include::authoring_maintainable_build_scripts.adoc[leveloffset=+2]
   
   == OTHER TOPICS
   
   include::directory_layout.adoc[leveloffset=+2]
   include::working_with_files.adoc[leveloffset=+2]
   include::logging.adoc[leveloffset=+2]
   include::potential_traps.adoc[leveloffset=+2]
   include::build_environment.adoc[leveloffset=+2]
   include::init_scripts.adoc[leveloffset=+2]
   include::custom_gradle_types.adoc[leveloffset=+2]
   include::build_services.adoc[leveloffset=+2]
   include::dataflow_actions.adoc[leveloffset=+2]
   include::test_kit.adoc[leveloffset=+2]
   include::ant.adoc[leveloffset=+2]
   
   == **AUTHORING JVM BUILDS**
   
   include::building_java_projects.adoc[leveloffset=+2]
   include::java_testing.adoc[leveloffset=+2]
   include::dependency_management_for_java_projects.adoc[leveloffset=+2]
   
   == JAVA TOOLCHAINS
   
   include::toolchains.adoc[leveloffset=+2]
   include::toolchain_plugins.adoc[leveloffset=+2]
   
   == JVM PLUGINS
   
   include::java_library_plugin.adoc[leveloffset=+2]
   include::application_plugin.adoc[leveloffset=+2]
   include::java_platform_plugin.adoc[leveloffset=+2]
   include::groovy_plugin.adoc[leveloffset=+2]
   include::scala_plugin.adoc[leveloffset=+2]
   
   == **WORKING WITH DEPENDENCIES**
   
   include::dependency_management_terminology.adoc[leveloffset=+2]
   
   == THE BASICS
   
   include::core_dependency_management.adoc[leveloffset=+2]
   include::declaring_repositories.adoc[leveloffset=+2]
   include::declaring_dependencies.adoc[leveloffset=+2]
   include::library_vs_application.adoc[leveloffset=+2]
   include::viewing_debugging_dependencies.adoc[leveloffset=+2]
   include::dependency_resolution.adoc[leveloffset=+2]
   include::dependency_verification.adoc[leveloffset=+2]
   
   == DECLARING VERSIONS
   
   include::single_versions.adoc[leveloffset=+2]
   include::rich_versions.adoc[leveloffset=+2]
   include::dynamic_versions.adoc[leveloffset=+2]
   include::dependency_locking.adoc[leveloffset=+2]
   
   == CONTROLLING TRANSITIVES
   
   include::dependency_constraints.adoc[leveloffset=+2]
   include::dependency_downgrade_and_exclude.adoc[leveloffset=+2]
   include::platforms.adoc[leveloffset=+2]
   include::dependency_version_alignment.adoc[leveloffset=+2]
   include::dependency_capability_conflict.adoc[leveloffset=+2]
   include::component_metadata_rules.adoc[leveloffset=+2]
   include::resolution_rules.adoc[leveloffset=+2]
   include::resolution_strategy_tuning.adoc[leveloffset=+2]
   
   == PRODUCING AND CONSUMING VARIANTS OF LIBRARIES
   
   include::component_capabilities.adoc[leveloffset=+2]
   include::feature_variants.adoc[leveloffset=+2]
   include::variant_model.adoc[leveloffset=+2]
   include::variant_attributes.adoc[leveloffset=+2]
   include::cross_project_publications.adoc[leveloffset=+2]
   include::artifact_transforms.adoc[leveloffset=+2]
   
   == PUBLISHING LIBRARIES
   
   include::publishing_setup.adoc[leveloffset=+2]
   include::publishing_gradle_module_metadata.adoc[leveloffset=+2]
   include::publishing_signing.adoc[leveloffset=+2]
   include::publishing_customization.adoc[leveloffset=+2]
   include::publishing_maven.adoc[leveloffset=+2]
   include::publishing_ivy.adoc[leveloffset=+2]
   
   == **OPTIMIZING BUILD PERFORMANCE**
   
   include::performance.adoc[leveloffset=+2]
   include::gradle_daemon.adoc[leveloffset=+2]
   include::file_system_watching.adoc[leveloffset=+2]
   include::incremental_build.adoc[leveloffset=+2]
   include::configuration_cache.adoc[leveloffset=+2]
   include::inspect.adoc[leveloffset=+2]
   include::config_gradle.adoc[leveloffset=+2]
   include::project_properties.adoc[leveloffset=+2]
   include::networking.adoc[leveloffset=+2]
   
   == USING THE BUILD CACHE
   
   include::build_cache.adoc[leveloffset=+2]
   include::build_cache_use_cases.adoc[leveloffset=+2]
   include::build_cache_performance.adoc[leveloffset=+2]
   include::build_cache_concepts.adoc[leveloffset=+2]
   include::caching_java_projects.adoc[leveloffset=+2]
   include::caching_android_projects.adoc[leveloffset=+2]
   include::build_cache_debugging.adoc[leveloffset=+2]
   include::common_caching_problems.adoc[leveloffset=+2]
   
   == **GRADLE ON CI**
   
   include::jenkins.adoc[leveloffset=+2]
   include::teamcity.adoc[leveloffset=+2]
   include::github-actions.adoc[leveloffset=+2]
   include::travis-ci.adoc[leveloffset=+2]
   
   == **REFERENCE**
   
   include::command_line_interface.adoc[leveloffset=+2]
   include::gradle_wrapper.adoc[leveloffset=+2]
   include::plugin_reference.adoc[leveloffset=2]
   include::third_party_integration.adoc[leveloffset=2]
   
   == GRADLE DSLs and API
   
   include::groovy_build_script_primer.adoc[leveloffset=+2]
   include::kotlin_dsl.adoc[leveloffset=+2]
   
   == **LICENSE INFORMATION**
   
   include::licenses.adoc[leveloffset=+2]

/docs/userguide/overview/userguide.adoc
=======================================

.. code-block::

   = Gradle User Manual
   
   == Gradle Build Tool
   
   image:gradle.png[float=left] Gradle Build Tool is a fast, dependable, and adaptable open-source https://en.wikipedia.org/wiki/Build_automation[build automation] tool with an elegant and extensible declarative build language.
   
   In this User Manual, Gradle Build Tool is abbreviated **Gradle**.
   
   == Why Gradle?
   
   Gradle is a widely used and mature tool with an active community and a strong developer ecosystem.
   
   * Gradle is the most popular build system for the JVM and is the default system for Android and Kotlin Multi-Platform projects.
   It has a rich community plugin ecosystem.
   * Gradle can automate a wide range of software build scenarios using either its built-in functionality, third-party plugins, or custom build logic.
   * Gradle provides a high-level, declarative, and expressive build language that makes it easy to read and write build logic.
   * Gradle is fast, scalable, and can build projects of any size and complexity.
   * Gradle produces dependable results while benefiting from optimizations such as incremental builds, build caching, and parallel execution.
   
   Gradle, Inc. provides a free service called https://scans.gradle.com/[Build Scan춽] that provides extensive information and insights about your builds.
   You can view scans to identify problems or share them for debugging help.
   
   === Supported Languages and Frameworks
   Gradle supports Android, Java, Kotlin Multiplatform, Groovy, Scala, Javascript, and C/C++.
   
   image::userguide-languages.png[]
   
   === Compatible IDEs
   All major IDEs support Gradle, including Android Studio, IntelliJ IDEA, Visual Studio Code, Eclipse, and NetBeans.
   
   image::userguide-ides.png[]
   
   You can also invoke Gradle via its <<command_line_interface.adoc#command_line_interface,command-line interface>> (CLI) in your terminal or through your continuous integration (CI) server.
   
   == Education
   The **<<about_manual.adoc#about_manual,Gradle User Manual>>** is the official documentation for the Gradle Build Tool.
   
   * **Getting Started Tutorial**  <<getting_started_eng.adoc#introduction,Learn Gradle basics>> and the benefits of building your App with Gradle.
   * **Training Courses**  Head over to the link:https://gradle.org/courses/[courses page] to sign up for free Gradle training.
   
   == Support
   * **Forum**  The fastest way to get help is through the link:https://discuss.gradle.org/[Gradle Forum].
   * **Slack**  Community members and core contributors answer questions directly on our link:https://gradle-community.slack.com/[Slack Channel].
   
   == Licenses
   [.legalnotice]
   Gradle Build Tool source code is open and licensed under the link:https://github.com/gradle/gradle/blob/master/LICENSE[Apache License 2.0].
   Gradle user manual and DSL reference manual are licensed under link:https://creativecommons.org/licenses/by-nc-sa/4.0/[Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License].

/docs/userguide/overview/about_manual.adoc
==========================================

.. code-block::

   = The User Manual
   
   Explore our guides and examples to use Gradle.
   
   == Releases
   
   Information on Gradle releases and how to install Gradle is found on the <<installation.adoc#installation,Installation page>>.
   
   == Content
   
   The Gradle User Manual is broken down into the following sections:
   
   <<command_line_interface.adoc#command_line_interface,Running Gradle Builds>> :: Learn Gradle basics and how to use Gradle to build your project.
   <<build_lifecycle.adoc#build_lifecycle,Authoring Gradle Builds>> :: Develop tasks and plugins to customize your build.
   <<building_java_projects.adoc#building_java_projects,Authoring JVM Builds>> :: Use Gradle with your Java project.
   <<dependency_management_terminology.adoc#dependency_management_terminology,Working with Dependencies>> :: Add dependencies to your build.
   <<performance.adoc#performance_gradle,Optimizing Builds>> :: Use caches to optimize your build and understand the Gradle daemon, incremental builds and file system watching.
   <<jenkins.adoc#build_jenkins,Gradle on CI>> :: Gradle integration with popular continuous integration (CI) servers.
   
   == Reference
   
   . Gradle's API link:{javadocPath}#[Javadocs^]
   . Gradle's link:{groovyDslPath}#[Groovy DSL^]
   . Gradle's link:{kotlinDslPath}/index.html[Kotlin DSL^]
   . Gradle's <<plugin_reference#plugin_reference,Core Plugins>>

/Topic: 游댯 Release
====================


/docs/userguide/releases/installation.adoc
==========================================

.. code-block::

   = Installing Gradle
   
   == Gradle Installation
   
   If all you want to do is run an existing Gradle project, then you don't need to install Gradle if the build uses the <<gradle_wrapper#gradle_wrapper_reference,Gradle Wrapper>>.
   This is identifiable by the presence of the `gradlew` or `gradlew.bat` files in the root of the project:
   
   [listing,subs=+macros]
   ----
   .   // <1>
   較럭較 gradle
   較   較덕較 wrapper // <2>
   較럭較 gradlew         // <3>
   較럭較 gradlew.bat     // <3>
   較덕較 긽
   ----
   <1> Project root directory.
   <2> <<gradle_wrapper.adoc#gradle_wrapper_reference,Gradle Wrapper>>.
   <3> Scripts for executing Gradle builds.
   
   If the `gradlew` or `gradlew.bat` files are already present in your project, *you do not need to install Gradle*.
   But you need to make sure your system <<installation#sec:prerequisites,satisfies Gradle's prerequisites>>.
   
   You can follow the steps in the <<upgrading_version_8.adoc#upgrading_version_8,Upgrading Gradle section>> if you want to update the Gradle version for your project.
   Please use the <<gradle_wrapper.adoc#sec:upgrading_wrapper,Gradle Wrapper>> to upgrade Gradle.
   
   Android Studio comes with a working installation of Gradle, so you *don't need to install Gradle separately when only working within that IDE*.
   
   If you do not meet the criteria above and decide to install Gradle on your machine, first check if Gradle is already installed by running `gradle -v` in your terminal.
   If the command does not return anything, then Gradle is not installed, and you can follow the instructions below.
   
   You can install Gradle Build Tool on Linux, macOS, or Windows.
   The installation can be done manually or using a package manager like https://sdkman.io/[SDKMAN!] or https://brew.sh/[Homebrew].
   
   You can find all Gradle releases and their checksums on the link:{website}/releases[releases page].
   
   == Prerequisites
   Gradle runs on all major operating systems. It requires link:{jdkDownloadUrl}[Java Development Kit] (JDK) version {minJdkVersion} or higher to run. You can check the <<compatibility.adoc#compatibility,compatibility matrix>> for more information.
   
   To check, run `java -version`:
   
   ----
   仇 java -version
   openjdk version "11.0.18" 2023-01-17
   OpenJDK Runtime Environment Homebrew (build 11.0.18+0)
   OpenJDK 64-Bit Server VM Homebrew (build 11.0.18+0, mixed mode)
   ----
   
   ----
   仇 java version "1.8.0_151"
   Java(TM) SE Runtime Environment (build 1.8.0_151-b12)
   Java HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode)
   ----
   
   Gradle uses the JDK it finds in your path, the JDK used by your IDE, or the JDK specified by your project.
   In this example, the $PATH points to JDK17:
   
   ----
   仇 echo $PATH
   /opt/homebrew/opt/openjdk@17/bin
   ----
   
   You can also set the `JAVA_HOME` environment variable to point to a specific JDK installation directory.
   This is especially useful when multiple JDKs are installed:
   
   ----
   仇 echo %JAVA_HOME%
   C:\Program Files\Java\jdk1.7.0_80
   ----
   
   ----
   仇 echo $JAVA_HOME
   /Library/Java/JavaVirtualMachines/jdk-16.jdk/Contents/Home
   ----
   
   Gradle supports link:https://kotlinlang.org/[Kotlin] and link:https://groovy-lang.org/[Groovy] as the main build languages.
   Gradle ships with its own Kotlin and Groovy libraries, therefore they do not need to be installed.
   Existing installations are ignored by Gradle.
   
   <<compatibility.adoc#compatibility, See the full compatibility notes for Java, Groovy, Kotlin, and Android.>>
   
   == Linux installation
   
   .Installing with a package manager
   [%collapsible]
   ====
   
   link:http://sdkman.io[SDKMAN!] is a tool for managing parallel versions of multiple Software Development Kits on most Unix-like systems (macOS, Linux, Cygwin, Solaris and FreeBSD).
   Gradle is deployed and maintained by SDKMAN!:
   
   ----
   仇 sdk install gradle
   ----
   
   Other package managers are available, but the version of Gradle distributed by them is not controlled by Gradle, Inc.
   Linux package managers may distribute a modified version of Gradle that is incompatible or incomplete when compared to the official version.
   ====
   
   .Installing manually
   [%collapsible]
   ====
   
   **Step 1 - link:{website}/releases[Download] the latest Gradle distribution**
   
   The distribution ZIP file comes in two flavors:
   
   - Binary-only (bin)
   - Complete (all) with docs and sources
   
   We recommend downloading the bin file; it is a smaller file that is quick to download (and the latest documentation is available online).
   
   **Step 2 - Unpack the distribution**
   
   Unzip the distribution zip file in the directory of your choosing, e.g.:
   
   [subs="attributes"]
   ----
   仇 mkdir /opt/gradle
   仇 unzip -d /opt/gradle gradle-{gradleVersion}-bin.zip
   仇 ls /opt/gradle/gradle-{gradleVersion}
   LICENSE  NOTICE  bin  README  init.d  lib  media
   ----
   
   
   **Step 3 - Configure your system environment**
   
   To install Gradle, the path to the unpacked files needs to be in your Path.
   Configure your `PATH` environment variable to include the `bin` directory of the unzipped distribution, e.g.:
   
   [subs="attributes"]
   ----
   仇 export PATH=$PATH:/opt/gradle/gradle-{gradleVersion}/bin
   ----
   
   Alternatively, you could also add the environment variable `GRADLE_HOME` and point this to the unzipped distribution.
   Instead of adding a specific version of Gradle to your `PATH`, you can add `$GRADLE_HOME/bin` to your `PATH`.
   When upgrading to a different version of Gradle, simply change the `GRADLE_HOME` environment variable.
   
   [subs="attributes"]
   ----
   export GRADLE_HOME=/opt/gradle/gradle-{gradleVersion}
   export PATH=${GRADLE_HOME}/bin:${PATH}
   ----
   ====
   
   == macOS installation
   
   .Installing with a package manager
   [%collapsible]
   ====
   
   link:http://sdkman.io[SDKMAN!] is a tool for managing parallel versions of multiple Software Development Kits on most Unix-like systems (macOS, Linux, Cygwin, Solaris and FreeBSD).
   Gradle is deployed and maintained by SDKMAN!:
   
   ----
   仇 sdk install gradle
   ----
   
   Using link:http://brew.sh[Homebrew]:
   
   ----
   仇 brew install gradle
   ----
   
   Using link:https://www.macports.org[MacPorts]:
   
   ----
   仇 sudo port install gradle
   ----
   
   Other package managers are available, but the version of Gradle distributed by them is not controlled by Gradle, Inc.
   ====
   
   .Installing manually
   [%collapsible]
   ====
   
   **Step 1 - link:{website}/releases[Download] the latest Gradle distribution**
   
   The distribution ZIP file comes in two flavors:
   
   - Binary-only (bin)
   - Complete (all) with docs and sources
   
   We recommend downloading the bin file; it is a smaller file that is quick to download (and the latest documentation is available online).
   
   **Step 2 - Unpack the distribution**
   
   Unzip the distribution zip file in the directory of your choosing, e.g.:
   
   [subs="attributes"]
   ----
   仇 mkdir /usr/local/gradle
   仇 unzip gradle-{gradleVersion}-bin.zip -d /usr/local/gradle
   仇 ls /usr/local/gradle/gradle-{gradleVersion}
   LICENSE	NOTICE	README	bin	init.d	lib
   ----
   
   **Step 3 - Configure your system environment**
   
   To install Gradle, the path to the unpacked files needs to be in your Path.
   Configure your `PATH` environment variable to include the `bin` directory of the unzipped distribution, e.g.:
   
   [subs="attributes"]
   ----
   仇 export PATH=$PATH:/usr/local/gradle/gradle-{gradleVersion}/bin
   ----
   
   Alternatively, you could also add the environment variable `GRADLE_HOME` and point this to the unzipped distribution.
   Instead of adding a specific version of Gradle to your `PATH`, you can add `$GRADLE_HOME/bin` to your `PATH`.
   When upgrading to a different version of Gradle, simply change the `GRADLE_HOME` environment variable.
   
   It's a good idea to edit `.bash_profile` in your home directory to add `GRADLE_HOME` variable:
   
   [subs="attributes"]
   ----
   export GRADLE_HOME=/usr/local/gradle/gradle-{gradleVersion}
   export PATH=$GRADLE_HOME/bin:$PATH
   ----
   ====
   
   == Windows installation
   
   .Installing manually
   [%collapsible]
   ====
   
   **Step 1 - link:{website}/releases[Download] the latest Gradle distribution**
   
   The distribution ZIP file comes in two flavors:
   
   - Binary-only (bin)
   - Complete (all) with docs and sources
   
   We recommend downloading the bin file.
   
   **Step 2 - Unpack the distribution**
   
   Create a new directory `C:\Gradle` with **File Explorer**.
   
   Open a second **File Explorer** window and go to the directory where the Gradle distribution was downloaded. Double-click the ZIP archive to expose the content.
   Drag the content folder `gradle-{gradleVersion}` to your newly created `C:\Gradle` folder.
   
   Alternatively, you can unpack the Gradle distribution ZIP into `C:\Gradle` using the archiver tool of your choice.
   
   **Step 3 - Configure your system environment**
   
   To install Gradle, the path to the unpacked files needs to be in your Path.
   
   In **File Explorer** right-click on the `This PC` (or `Computer`) icon, then click `Properties` -> `Advanced System Settings` -> `Environmental Variables`.
   
   Under `System Variables` select `Path`, then click `Edit`.
   Add an entry for `C:\Gradle\gradle-{gradleVersion}\bin`.
   Click `OK` to save.
   
   Alternatively, you can add the environment variable `GRADLE_HOME` and point this to the unzipped distribution.
   Instead of adding a specific version of Gradle to your `Path`, you can add `__%GRADLE_HOME%__\bin` to your `Path`.
   When upgrading to a different version of Gradle, just change the `GRADLE_HOME` environment variable.
   ====
   
   == Verify the installation
   
   Open a console (or a Windows command prompt) and run `gradle -v` to run gradle and display the version, e.g.:
   
   [subs="attributes"]
   ----
   仇 gradle -v
   
   ------------------------------------------------------------
   Gradle {gradleVersion}
   ------------------------------------------------------------
   
   Build time:   2023-03-03 16:41:37 UTC
   Revision:     7d6581558e226a580d91d399f7dfb9e3095c2b1d
   
   Kotlin:       1.8.10
   Groovy:       3.0.13
   Ant:          Apache Ant(TM) version 1.10.11 compiled on July 10 2021
   JVM:          17.0.6 (Homebrew 17.0.6+0)
   OS:           Mac OS X 13.2.1 aarch64
   
   ----
   
   You can verify the integrity of the Gradle distribution by downloading the SHA-256 file (available from the link:{website}/releases[releases page]) and following these <<gradle_wrapper.adoc#sec:verification,verification instructions>>.

/docs/userguide/releases/compatibility.adoc
===========================================

.. code-block::

   = Compatibility Matrix
   
   The sections below describe Gradle's compatibility with several integrations.
   Versions not listed here may or may not work.
   
   == Java
   A Java version between 8 and 21 is required to execute Gradle.
   Java 22 and later versions are not yet supported.
   
   Java 6 and 7 can be used for <<building_java_projects.adoc#sec:java_cross_compilation,compilation>> but are deprecated for use with testing. Testing with Java 6 and 7 will not be supported in Gradle 9.0.
   
   Any fully supported version of Java can be used for compilation or testing.
   However, the latest Java version may only be supported for compilation or testing, not for running Gradle.
   Support is achieved using <<toolchains#toolchains,toolchains>> and applies to all tasks supporting toolchains.
   
   See the table below for the Java version supported by a specific Gradle release:
   
   .Java Compatibility
   |===
   |Java version | Support for toolchains | Support for running Gradle
   
   | 8 | N/A | 2.0
   | 9 | N/A | 4.3
   | 10| N/A | 4.7
   | 11| N/A | 5.0
   | 12| N/A | 5.4
   | 13| N/A | 6.0
   | 14| N/A | 6.3
   | 15| 6.7 | 6.7
   | 16| 7.0 | 7.0
   | 17| 7.3 | 7.3
   | 18| 7.5 | 7.5
   | 19| 7.6 | 7.6
   | 20| 8.1 | 8.3
   | 21| 8.4 | 8.5
   | 22| 8.7 | N/A
   | 23| N/A | N/A
   |===
   
   == Kotlin
   Gradle is tested with Kotlin 1.6.10 through 2.0.0-Beta3.
   Beta and RC versions may or may not work.
   
   .Embedded Kotlin version
   |===
   | Minimum Gradle version | Embedded Kotlin version | Kotlin Language version
   
   | 5.0 | 1.3.10 | 1.3
   | 5.1 | 1.3.11 | 1.3
   | 5.2 | 1.3.20 | 1.3
   | 5.3 | 1.3.21 | 1.3
   | 5.5 | 1.3.31 | 1.3
   | 5.6 | 1.3.41 | 1.3
   | 6.0 | 1.3.50 | 1.3
   | 6.1 | 1.3.61 | 1.3
   | 6.3 | 1.3.70 | 1.3
   | 6.4 | 1.3.71 | 1.3
   | 6.5 | 1.3.72 | 1.3
   | 6.8 | 1.4.20 | 1.3
   | 7.0 | 1.4.31 | 1.4
   | 7.2 | 1.5.21 | 1.4
   | 7.3 | 1.5.31 | 1.4
   | 7.5 | 1.6.21 | 1.4
   | 7.6 | 1.7.10 | 1.4
   | 8.0 | 1.8.10 | 1.8
   | 8.2 | 1.8.20 | 1.8
   | 8.3 | 1.9.0  | 1.8
   | 8.4 | 1.9.10 | 1.8
   | 8.5 | 1.9.20 | 1.8
   | 8.7 | 1.9.22 | 1.8
   |===
   
   == Groovy
   Gradle is tested with Groovy 1.5.8 through 4.0.0.
   
   Gradle plugins written in Groovy must use Groovy 3.x for compatibility with Gradle and Groovy DSL build scripts.
   
   == Android
   Gradle is tested with Android Gradle Plugin 7.3 through 8.2.
   Alpha and beta versions may or may not work.

/docs/userguide/releases/feature_lifecycle.adoc
===============================================

.. code-block::

   = The Feature Lifecycle
   
   Gradle is under constant development. New versions are delivered on a regular and frequent basis (approximately every six weeks) as described in <<#eol_support,the section on end-of-life support>>.
   
   Continuous improvement combined with frequent delivery allows new features to be available to users early.
   Early users provide invaluable feedback, which is incorporated into the development process.
   
   Getting new functionality into the hands of users regularly is a core value of the Gradle platform.
   
   At the same time, API and feature stability are taken very seriously and considered a core value of the Gradle platform.
   Design choices and automated testing are engineered into the development process and formalized by <<#backwards_compatibility,the section on backward compatibility>>.
   
   The Gradle _feature lifecycle_ has been designed to meet these goals. It also communicates to users of Gradle what the state of a feature is.
   The term _feature_ typically means an API or DSL method or property in this context, but it is not restricted to this definition.
   Command line arguments and modes of execution (e.g. the Build Daemon) are two examples of other features.
   
   == Feature States
   
   Features can be in one of four states:
   
   1. <<#sec:internal,Internal>>
   2. <<#sec:incubating_state,Incubating>>
   3. <<#sec:public,Public>>
   4. <<#sec:deprecated,Deprecated>>
   
   == 1. Internal
   
   _Internal_ features are not designed for public use and are only intended to be used by Gradle itself. They can change in any way at any point in time without any notice.
   Therefore, we recommend avoiding the use of such features.
   _Internal_ features are not documented.
   If it appears in this User Manual, the DSL Reference, or the API Reference, then the feature is not _internal_.
   
   _Internal_ features may evolve into public features.
   
   == 2. Incubating
   
   Features are introduced in the _incubating_ state to allow real-world feedback to be incorporated into the feature before making it public.
   It also gives users willing to test potential future changes early access.
   
   A feature in an _incubating_ state may change in future Gradle versions until it is no longer _incubating_.
   Changes to _incubating_ features for a Gradle release will be highlighted in the release notes for that release.
   The _incubation_ period for new features varies depending on the feature's scope, complexity, and nature.
   
   Features in _incubation_ are indicated.
   In the source code, all methods/properties/classes that are _incubating_ are annotated with link:{javadocPath}#[incubating].
   This results in a special mark for them in the DSL and API references.
   
   If an _incubating_ feature is discussed in this User Manual, it will be explicitly said to be in the _incubating_ state.
   
   === Feature Preview API
   
   The feature preview API allows certain _incubating_ features to be activated by adding `enableFeaturePreview('FEATURE')` in your _settings_ file.
   Individual preview features will be announced in release notes.
   
   When _incubating_ features are either promoted to _public_ or removed, the feature preview flags for them become obsolete, have no effect, and should be removed from the settings file.
   
   == 3. Public
   
   The default state for a non-internal feature is _public_. Anything documented in the User Manual, DSL Reference, or API reference that is not explicitly said to be _incubating_ or _deprecated_ is considered _public_.
   Features are said to be *promoted* from an _incubating_ state to _public_.
   The release notes for each release indicate which previously _incubating_ features are being promoted by the release.
   
   A _public_ feature will *never* be removed or intentionally changed without undergoing _deprecation_.
   All public features are subject to the backward compatibility policy.
   
   == 4. Deprecated
   
   Some features may be replaced or become irrelevant due to the natural evolution of Gradle.
   Such features will eventually be removed from Gradle after being _deprecated_.
   A _deprecated_ feature may become stale until it is finally removed according to the backward compatibility policy.
   
   _Deprecated_ features are indicated to be so.
   In the source code, all methods/properties/classes that are _deprecated_ are annotated with "`@java.lang.Deprecated`" which is reflected in the DSL and API References.
   In most cases, there is a replacement for the deprecated element, which will be described in the documentation.
   Using a _deprecated_ feature will result in a runtime warning in Gradle's output.
   
   The use of _deprecated_ features should be avoided.
   The release notes for each release indicate any features being _deprecated_ by the release.
   
   == Backward compatibility policy
   
   Gradle provides backward compatibility across major versions (e.g., `1.x`, `2.x`, etc.).
   Once a public feature is introduced in a Gradle release, it will remain indefinitely unless deprecated.
   Once deprecated, it may be removed in the next major release.
   Deprecated features may be supported across major releases, but this is not guaranteed.
   
   == Release end-of-life Policy
   
   Every day, a new nightly build of Gradle is created.
   
   This contains all of the changes made through Gradle's extensive continuous integration tests during that day.
   Nightly builds may contain new changes that may or may not be stable.
   
   The Gradle team creates a pre-release distribution called a release candidate (RC) for each minor or major release.
   When no problems are found after a short time (usually a week), the release candidate is promoted to a general availability (GA) release.
   If a regression is found in the release candidate, a new RC distribution is created, and the process repeats.
   Release candidates are supported for as long as the release window is open, but they are not intended to be used for production.
   Bug reports are greatly appreciated during the RC phase.
   
   The Gradle team may create additional patch releases to replace the final release due to critical bug fixes or regressions.
   For instance, Gradle 5.2.1 replaces the Gradle 5.2 release.
   
   Once a release candidate has been made, all feature development moves on to the next release for the latest major version.
   As such, each minor Gradle release causes the previous minor releases in the same major version to become end-of-life (EOL). EOL releases do not receive bug fixes or feature backports.
   
   For major versions, Gradle will backport critical fixes and security fixes to the last minor in the previous major version.
   For example, when Gradle 7 was the latest major version, several releases were made in the 6.x line, including Gradle 6.9 (and subsequent releases).
   
   As such, each major Gradle release causes:
   
   * The previous major version becomes maintenance only. It will only receive critical bug fixes and security fixes.
   * The major version before the previous one to become end-of-life (EOL), and that release line will not receive any new fixes.

/docs/userguide/releases/migrating/migrating_from_ant.adoc
==========================================================

.. code-block::

   = Migrating Builds From Apache Ant
   
   https://ant.apache.org/[Apache Ant] is a build tool with a long history in the Java world that is still widely used, albeit by a decreasing number of teams.
   While flexible, it lacks conventions and many of the powerful features that Gradle provides.
   Migrating to Gradle is worthwhile so that your builds can become slimmer, simpler, and faster, while still retaining the flexibility you enjoy with Ant.
   You will also benefit from robust support for multi-project builds and easy-to-use, flexible dependency management.
   
   The biggest challenge in migrating from Ant to Gradle is that there is no such thing as a standard Ant build.
   That makes it difficult to provide specific instructions.
   Fortunately, Gradle has some great integration features with Ant that can make the process relatively smooth.
   Migrating from https://ant.apache.org/ivy/[Ivy]-based dependency management isn't difficult because Gradle has a similar model based on <<dependency_management_terminology#sub:terminology_configuration,dependency configurations>> that works with Ivy-compatible repositories.
   
   We will start by outlining the things you should consider when migrating a build from Ant to Gradle and offer some general guidelines on how to proceed.
   
   == General guidelines
   
   When you migrate a build from Ant to Gradle, you should keep in mind the nature of what you already have and where you would like to end up.
   Do you want a Gradle build that mirrors the structure of the existing Ant build?
   Or do you want to move to something that is more idiomatic to Gradle?
   What are the main benefits you are looking for?
   
   To better understand, consider the following opposing scenarios:
   
    * An imported build via <<ant#sec:import_ant_build,`ant.importBuild()`>>
   +
   This approach is quick, simple, and works for many Ant-based builds.
   You end up with a build that is effectively identical to the original Ant build, except your Ant targets become Gradle tasks.
   Even the dependencies between targets are retained.
   +
   The downside is that you're still using the Ant build, which you must continue to maintain.
   You also lose the advantages of Gradle's conventions, many of its plugins, its dependency management, and so on.
   You can still enhance the build with <<incremental_build.adoc#incremental_build,incremental build information>>, but it's more effort than would be the case for a normal Gradle build.
   
    * An idiomatic Gradle build
   +
   If you want to future proof your build, this is where you want to end up.
   Making use of Gradle's conventions and plugins will result in a smaller, easier-to-maintain build, with a structure that is familiar to many Java developers.
   You will also find it easier to take advantage of Gradle's power features to improve build performance.
   +
   The main downside is the extra work required to perform the migration, particularly if the existing build is complex and has many inter-project dependencies.
   However, these builds often benefit the most from a switch to idiomatic Gradle.
   In addition, Gradle provides many features that can ease the migration, such as the ability to <<ant#sec:using_ant_tasks,use core and custom Ant tasks>> directly from a Gradle build.
   
   You ideally want to end up somewhere close to the second option in the long term, but you don't have to get there in one fell swoop.
   
   What follows is a series of steps to help you decide the approach you want to take and how to go about it:
   
    1. Keep the old Ant build and new Gradle build side by side.
   +
   You know the Ant build works, so you should keep it until you are confident that the Gradle build produces all the same artifacts and otherwise does what you need.
   This also means that users can try the Gradle build without creating a new copy of the source tree.
   +
   Don't try to change the directory and file structure of the build until after you're ready to make the switch.
    2. Develop a mechanism to verify that the two builds produce the same artifacts.
   +
   This is a vitally important step to ensure that your deployments and tests don't break.
   Even small changes, such as the contents of a manifest file in a JAR, can cause problems.
   If your Gradle build produces the same output as the Ant build, this will give you and others confidence in switching over and make it easier to implement the big changes that will provide the greatest benefits.
    3. Decide whether you have a multi-project build or not.
   +
   Multi-project builds are generally harder to migrate and require more work than single-project ones. We have provided some dedicated advice to help with the process in the <<migant:multi_project_builds,Migrating multi-project builds>> section.
    4. Work out what plugins to use for each project.
   +
   We expect that the vast majority of Ant builds are for <<building_java_projects#building_java_projects,JVM-based projects>>, for which there are a wealth of plugins that provide a lot of the functionality you need.
   Gradle plugins include <<plugin_reference#plugin_reference,core plugins>> that come packaged with Gradle and useful community plugins on the https://plugins.gradle.org/[Plugin Portal].
   +
   Even if the <<java_plugin#java_plugin,Java Plugin>> or one of its derivatives (such as the <<java_library_plugin#java_library_plugin,Java Library Plugin>>) aren't a good match for your build, you should at least consider the <<base_plugin#base_plugin,Base Plugin>> for its lifecycle tasks.
    5. Import the Ant build or create a Gradle build from scratch.
   +
   This step very much depends on the requirements of your build.
   If a selection of Gradle plugins can do the vast majority of the work your Ant build does, then it probably makes sense to create a fresh Gradle build script that doesn't depend on the Ant build.
   You can either implement the missing pieces yourself or <<ant#sec:using_ant_tasks,use existing Ant tasks>>.
   +
   The alternative approach is to <<ant#sec:import_ant_build,import the Ant build>> into the Gradle build script and gradually replace the Ant build functionality.
   This allows you to have a working Gradle build at each stage, but it requires a bit of work to get the Gradle tasks working properly with the Ant ones.
   You can learn more about this in <<migant:imported_builds,Working with an imported build>>.
    6. Configure your build for the existing directory and file structure
   +
   Gradle makes use of conventions to eliminate much of the boilerplate associated with older builds and to make it easier for users to work with new builds once they are familiar with those conventions.
   But that doesn't mean you have to follow them.
   +
   Gradle provides many configuration options that allow for a good degree of customization.
   Those options are typically made available through the plugins that provide the conventions.
   For example, the standard source directory structure for production Java code 댹`src/main/java` 댹말s provided by the Java Plugin, which allows you to <<building_java_projects#sec:custom_java_source_set_paths,configure a different source path>>.
   Many paths can be modified via properties on the link:{groovyDslPath}#[Project] object.
    7. Migrate to standard Gradle conventions if you wish
   +
   Once you're confident that the Gradle build is producing the same artifacts and other resources as the Ant build, you can consider migrating to the standard conventions, such as for source directory paths.
   Doing so will allow you to remove the extra configuration that was required to override those conventions.
   New team members will also find it easier to work with the build after the change.
   +
   It's up to you to decide whether this step is worth the effort and potential disruption, which in turn depends on your specific build and team.
   
   The rest of the chapter covers some common scenarios you will likely deal with during the migration, such as dependency management and working with Ant tasks.
   
   == Working with an imported build
   
   WARNING: Importing an Ant build is not supported with the <<configuration_cache.adoc#config_cache,configuration cache>>.
   You need to complete the conversion to Gradle to get the benefits of caching.
   
   The first step of many migrations will involve <<ant#sec:import_ant_build,importing an Ant build>> using `ant.importBuild()`.
   Then how do you then move towards a standard Gradle build without replacing everything at once?
   
   The important thing to remember is that the Ant targets become real Gradle tasks, meaning you can do things like modify their task dependencies, attach extra task actions, and so on.
   This allows you to substitute native Gradle tasks for the equivalent Ant ones, maintaining any links to other existing tasks.
   
   As an example, imagine that you have a Java library project that you want to migrate from Ant to Gradle.
   The Gradle build script has the line that imports the Ant build and now want to use the standard Gradle mechanism for compiling the Java source files.
   However, you want to keep using the existing `package` task that creates the library's JAR file.
   
   In diagram form, the scenario looks like the following, where each box represents a target/task:
   
   image::ant-task-migration.png[]
   
   The idea is to substitute the standard Gradle `compileJava` task for the Ant `build` task.
   There are several steps involved in this substitution:
   
    1. Applying the <<java_library_plugin#java_library_plugin,Java Library Plugin>>.
   +
   This provides the `compileJava` task shown in the diagram.
    2. Renaming the old `build` task.
   +
   The name `build` conflicts with the standard `build` task provided by the <<base_plugin#base_plugin,Base Plugin>> (via the Java Library Plugin).
    3. Configuring the compilation to use the existing directory structure.
   +
   There's a good chance the Ant build does not conform to the standard Gradle directory structure, so you need to tell Gradle where to find the source files and where to place the compiled classes so `package` can find them.
    4. Updating task dependencies.
   +
   `compileJava` must depend on `prepare`, `package` must depend on `compileJava` rather than `ant_build`, and `assemble` must depend on `package` rather than the standard Gradle `jar` task.
   
   Applying the plugin is as simple as inserting a  `plugins {}` block at the beginning of the Gradle build script, i.e. before `ant.importBuild()`.
   Here's how to apply the Java Library Plugin:
   
   .Applying the Java Library Plugin
   ====
   include::sample[dir="snippets/antMigration/importBuild/kotlin",files="build.gradle.kts[tags=apply-plugin]"]
   include::sample[dir="snippets/antMigration/importBuild/groovy",files="build.gradle[tags=apply-plugin]"]
   ====
   
   To rename the `build` task, use the variant of link:{javadocPath}#[AntBuilder.importBuild()] that accepts a transformer, like this:
   
   .Renaming targets on import
   ====
   include::sample[dir="snippets/antMigration/importBuild/kotlin",files="build.gradle.kts[tags=import-build]"]
   include::sample[dir="snippets/antMigration/importBuild/groovy",files="build.gradle[tags=import-build]"]
   ====
   <1> Renames the `build` target to `ant_build` and leaves all other targets unchanged
   
   Configuring a different path for the sources is described in <<building_java_projects#sec:custom_java_source_set_paths,Building Java & JVM projects>>.
   You can change the output directory for the compiled classes in a similar way.
   
   If, for example, the original Ant build stores these paths in Ant properties; `src.dir` for the Java source files and `classes.dir` for the output.
   Here's how you would configure Gradle to use those paths:
   
   .Configuring the source sets
   ====
   include::sample[dir="snippets/antMigration/importBuild/kotlin",files="build.gradle.kts[tags=source-sets]"]
   include::sample[dir="snippets/antMigration/importBuild/groovy",files="build.gradle[tags=source-sets]"]
   ====
   
   You should eventually switch to the standard directory structure for your type of project so that you will be able to remove this customization.
   
   The last step is straightforward and involves using the link:{groovyDslPath}#[Task.dependsOn] property and link:{groovyDslPath}#[]++)[Task.dependsOn()] method to detach and link tasks.
   The property is appropriate for _replacing_ dependencies, while the method is the preferred way to add to the existing dependencies.
   
   Here is the required task dependency configuration for the example scenario, which should come after the Ant build import:
   
   .Configuring the task dependencies
   ====
   include::sample[dir="snippets/antMigration/importBuild/kotlin",files="build.gradle.kts[tags=task-dependencies]"]
   include::sample[dir="snippets/antMigration/importBuild/groovy",files="build.gradle[tags=task-dependencies]"]
   ====
   <1> Makes compilation depend on the `prepare` task
   <2> Detaches `package` from the `ant_build` task and makes it depend on `compileJava`
   <3> Detaches `assemble` from the standard Gradle `jar` task and makes it depend on `package` instead
   
   These four steps will successfully replace the old Ant compilation with the Gradle implementation.
   Even this small migration will give you the advantage of Gradle's <<java_plugin#sec:incremental_compile,incremental Java compilation>> for faster builds.
   
   TIP: This is one example of a staged migration. It may make more sense to include resource processing  such as properties files 댹마nd packaging with the compilation in this stage.
   
   One important question you will have to ask yourself is how many tasks to migrate in each stage.
   The more you can migrate in one go the better, but risk comes with the number of custom steps within the Ant build that will be affected by the changes.
   
   For example, if the Ant build follows a fairly standard approach for compilation, static resources, packaging and unit tests, then it is probably worth migrating all of those together.
   But if the build performs some extra processing on the compiled classes, or does something unique when processing the static resources, it is probably worth splitting those tasks into separate stages.
   
   == Managing dependencies
   
   Ant builds typically take one of two approaches to dealing with binary <<dependency_management_terminology#sub:terminology_dependency,dependencies>> (such as libraries):
   
    * Storing them with the project in a local "lib" directory
    * Using https://ant.apache.org/ivy/[Apache Ivy] to manage them
   
   They each require a different technique for the migration to Gradle, but you will find the process straightforward in either case.
   Let's look at each case, in detail, in the following sections.
   
   === Serving dependencies from a directory
   
   When you are attempting to migrate a build that stores its dependencies on the filesystem, either locally or on the network, you should consider whether you want to eventually move to managed dependencies using remote repositories.
   That's because you can incorporate filesystem dependencies into a Gradle build in one of two ways:
   
    * Define a <<declaring_repositories.adoc#sub:flat_dir_resolver,flat-directory repository>> and use standard dependency declarations
    * Attach the files directly to the appropriate dependency configurations (<<declaring_dependencies#sub:file_dependencies,file dependencies>>)
   
   It's easier to migrate to managed dependencies served from Maven, or Ivy-compatible repositories, if you take the first approach, but doing so requires all your files to conform to the naming convention "<moduleName>-<version>.<extension>".
   
   NOTE: If you store your dependencies in the standard Maven repository layout 댹`<repoDir>/<group>/<module>/<version>` 댹맚hen you can define a <<declaring_repositories.adoc#sec:declaring_custom_repository,custom Maven repository>> with a `file://` URL.
   
   To demonstrate the two techniques, consider a project that has the following library JARs in its `libs` directory:
   
   [listing]
   libs
   較럭較 our-custom.jar
   較럭較 awesome-framework-2.0.jar
   較덕較 utility-library-1.0.jar
   
   The file `our-custom.jar` has no version number, so it has to be added as a file dependency.
   The other two JARs match the required naming convention and can be declared as normal <<declaring_dependencies#sub:module_dependencies,module dependencies>> that are retrieved from a flat-directory repository.
   
   The following sample build script demonstrates how you can incorporate all of these libraries into a build:
   
   .Declaring dependencies served from the filesystem
   ====
   include::sample[dir="snippets/antMigration/fileDeps/kotlin",files="build.gradle.kts[tags=file-deps]"]
   include::sample[dir="snippets/antMigration/fileDeps/groovy",files="build.gradle[tags=file-deps]"]
   ====
   <1> Specifies the path to the directory containing the JAR files
   <2> Declares a _file dependency_ for the un-versioned JAR
   <3> Declares dependencies using standard dependency coordinates  note that no group is specified, but each identifier has a leading `:`, implying an empty group
   
   The above sample will add `our-custom.jar`, `awesome-framework-2.0.jar` and `utility-library-1.0.jar` to the `implementation` configuration, which is used to compile the project's code.
   
   [NOTE]
   ====
   You can also specify a group in these module dependencies, even though they don't actually have a group.
   That's because the flat-directory repository simply ignores this information.
   Then, if you add a normal Maven or Ivy-compatible repository at a later date, Gradle will download the module dependencies that are declared with a group from that repository rather than the flat-directory one.
   ====
   
   === Migrating Ivy dependencies
   
   Apache Ivy is a standalone dependency management tool that is widely used with Ant. It works similarly to Gradle.
   In fact, they both allow you to:
   
    * Define your own <<dependency_management_terminology#sub:terminology_configuration,configurations>>
    * Extend configurations from one another
    * Attach dependencies to configurations
    * Resolve dependencies from Ivy-compatible repositories
    * Publish artifacts to Ivy-compatible repositories
   
   The most notable difference is that Gradle has standard configurations for specific types of projects.
   For example, the <<java_plugin#tab:configurations,Java Plugin>> defines configurations like `implementation`, `testImplementation` and `runtimeOnly`.
   You are able to <<declaring_dependencies.adoc#sec:defining-custom-configurations,define your own dependency configurations>> if needed.
   
   As such, it's typically straightforward to migrate from Ivy to Gradle:
   
    * Transcribe the dependency declarations from your module descriptors into the link:{groovyDslPath}#[dependencies {}] block of your Gradle build script, ideally using the standard configurations provided by any plugins you apply.
    * Transcribe any configuration declarations from your module descriptors into the link:{groovyDslPath}#[configurations {}] block of the build script for any custom configurations that can't be replaced by Gradle's standard ones.
    * Transcribe the resolvers from your Ivy settings file into the link:{groovyDslPath}#[repositories {}] block of the build script.
   
   See the chapters on <<declaring_dependencies.adoc#sec:what-are-dependency-configurations,Managing Dependency Configurations>>, <<declaring_dependencies.adoc#sec:dependency-types,Declaring Dependencies>> and <<declaring_repositories.adoc#declaring-repositories,Declaring Repositories>> for more information.
   
   Ivy provides several Ant tasks that handle Ivy's process for fetching dependencies.
   The basic steps of that process consist of:
   
    1. _Configure_ 댹마pplies the configuration defined in the Ivy settings file
    2. _Resolve_  locates the declared dependencies and downloads them to the cache if necessary
    3. _Retrieve_  copies the cached dependencies to another directory
   
   Gradle's process is similar, but you don't have to explicitly invoke the first two steps as it performs them automatically.
   The third step doesn't happen at all  unless you create a task to do it  because Gradle typically uses the files in the dependency cache directly in classpaths and as the source for assembling application packages.
   
   Let's look in more detail at how Ivy's steps map to Gradle:
   
   Configuration::
   Most of Gradle's dependency-related configuration is baked into the build script, as you've seen with elements like the `dependencies {}` block.
   Another particularly important configuration element is link:{groovyDslPath}#[resolutionStrategy], which can be accessed from dependency configurations.
   This provides many of the features you might get from Ivy's conflict managers and is a powerful way to control transitive dependencies and caching.
   +
   Some Ivy configuration options have no equivalent in Gradle.
   For example, there are no lock strategies because Gradle guarantees that its dependency cache is concurrency safe.
   There are no "latest strategies" methodology because it's simpler to have a reliable, single strategy for conflict resolution.
   If the "wrong" version is picked, you can override it using forced versions or other resolution options.
   +
   See the chapter on <<dependency_constraints.adoc#dependency-constraints,controlling transitive dependencies>> for more information.
   
   Resolution::
   At the beginning of the build, Gradle will automatically resolve any dependencies that you have declared and download them to its cache.
   Gradle searches the repositories for those dependencies, with the search order defined by <<declaring_repositories.adoc#sec:declaring_multiple_repositories,the order in which the repositories are declared>>.
   +
   It's worth noting that Gradle supports the same dynamic version syntax as Ivy, so you can still use conventions like `1.0.+`.
   You can also use the special `latest.integration` and `latest.release` labels.
   If you decide to use such <<dynamic_versions.adoc#sub:declaring_dependency_with_dynamic_version,dynamic>> and <<dynamic_versions.adoc#sub:declaring_dependency_with_changing_version,changing>> dependencies, you can configure the caching behavior for them via link:{groovyDslPath}#[resolutionStrategy].
   +
   You might also want to consider <<dependency_locking#dependency-locking,dependency locking>> if you're using dynamic and/or changing dependencies.
   It's a way to make the build more reliable and ensures https://reproducible-builds.org/[reproducibility].
   
   Retrieval::
   As mentioned, Gradle does not automatically copy files from the dependency cache.
   Its standard tasks typically use the files directly.
   If you want to copy the dependencies to a local directory, you can use a link:{groovyDslPath}#[Copy] task like this in your build script:
   +
   .Copying dependencies to a local directory
   ====
   include::sample[dir="snippets/antMigration/fileDeps/kotlin",files="build.gradle.kts[tags=retrieve-deps]"]
   include::sample[dir="snippets/antMigration/fileDeps/groovy",files="build.gradle[tags=retrieve-deps]"]
   ====
   +
   A configuration is also a file collection, hence why it can be used in the `from()` configuration.
   You can use a similar technique to attach a configuration to a compilation task or one that produces documentation.
   See the chapter on <<working_with_files#working_with_files,Working with Files>> for more examples and information on Gradle's file API.
   
   == Publishing artifacts
   
   Projects that use Ivy to manage dependencies often also use it for publishing JARs and other artifacts to repositories.
   If you're migrating such a build, then you'll be glad to know that Gradle has built-in support for publishing artifacts to Ivy-compatible repositories.
   
   Before you attempt to migrate this particular aspect of your build, read the <<publishing_setup.adoc#publishing_overview,Publishing>> chapter to learn about Gradle's publishing model.
   The chapter examples are based on Maven repositories but the same model is used for Ivy repositories.
   
   The basic migration process looks like this:
   
    * Apply the <<publishing_ivy#publishing_ivy,Ivy Publish Plugin>> to your build
    * <<publishing_ivy#publishing_ivy:publications,Configure at least one publication>>, representing what will be published (including additional artifacts if desired)
    * <<publishing_ivy#publishing_ivy:repositories,Configure one or more repositories to publish artifacts to>>
   
   Once that's all done, you will be able to generate an Ivy module descriptor for each publication and publish them to one or more repositories.
   
   Let's say you have defined a publication named "myLibrary" and a repository named "myRepo".
   Ivy's Ant tasks would then map to the Gradle tasks like this:
   
    * `<deliver>` -> `generateDescriptorFileForMyLibraryPublication`
    * `<publish>` -> `publishMyLibraryPublicationToMyRepoRepository`
   
   There is also a convenient `publish` task that publishes _all_ publications to _all_ repositories.
   If you want to limit publications to specific repositories, check out the <<publishing_customization.adoc#sec:publishing_maven:conditional_publishing,relevant section of the Publishing chapter>>.
   
   .On dependency versions
   --
   Ivy will, by default, automatically replace dynamic versions of dependencies with the resolved "static" versions when it generates the module descriptor.
   Gradle does _not_ mimic this behavior, declared dependency versions are left unchanged.
   
   You can replicate the default Ivy behavior by using the https://plugins.gradle.org/plugin/nebula.ivy-resolved-dependencies[Nebula Ivy Resolved Plugin].
   Alternatively, you can link:{groovyDslPath}#[customize the descriptor file] so that it contains the versions you want.
   --
   
   == Dealing with custom Ant tasks
   
   One of the advantages of Ant is that it's fairly easy to create a custom task and incorporate it into a build.
   If you have such tasks, then there are two main options for migrating them to a Gradle build:
   
    * <<ant#sec:using_custom_ant_tasks,Using the custom Ant task>> from the Gradle build
    * Rewriting the task as a <<custom_tasks#custom_tasks,custom Gradle task type>>
   
   The first option is typically quick and easy.
   If you want to integrate the task into incremental build, you must use the <<incremental_build#sec:task_input_output_runtime_api,incremental build runtime API>>.
   You also often have to work with Ant paths and filesets, which can be inconvenient.
   
   The second option is preferable long term.
   Gradle task types tend to be simpler than Ant tasks because they don't have to work with an XML-based interface.
   You also gain the benefits of Gradle's rich APIs.
   This approach enables the <<incremental_build#sec:task_input_output_annotations,type-safe incremental build API>> based on typed properties.
   
   == Working with files
   
   Ant has many tasks for working with files, most of which have Gradle equivalents.
   As with other areas of the Ant to Gradle migration, you can <<ant#sec:using_ant_tasks,use those Ant tasks>> from within your Gradle build.
   However, we strongly recommend migrating to native Gradle constructs where possible so that the build benefits from:
   
    * <<incremental_build#incremental_build,Incremental build>>
    * Easier integration with other parts of the build, such as dependency configurations
    * More idiomatic build scripts
   
   It can be convenient to use Ant tasks that have no direct equivalents, such as `<checksum>` and `<chown>`.
   However, in the long term, it may be better to convert these to native Gradle task types that make use of standard Java APIs or third-party libraries.
   
   Here are the most common file-related elements used by Ant builds, along with the Gradle equivalents:
   
    * `<copy>` 댹맗refer the Gradle link:{groovyDslPath}#[Copy] task type
    * `<zip>` (plus Java variants) 댹맗refer the link:{groovyDslPath}#[Zip] task type (plus link:{groovyDslPath}#[Jar], link:{groovyDslPath}#[War], and link:{groovyDslPath}#[Ear])
    * `<unzip>` 댹맗refer using the link:{groovyDslPath}#[Project.zipTree()] method with a `Copy` task
   
   You can see several examples of Gradle's file API and learn more about it in the <<working_with_files#working_with_files,Working with Files>> chapter.
   
   .On paths and filesets
   --
   Ant makes use of the concepts of path-like structures and filesets to enable users to work with collections of files and directories.
   Gradle has a simpler, more powerful model based on link:{javadocPath}#[FileCollection]s and link:{javadocPath}#[FileTree]s that can be treated as objects from within the build.
   Both types allow filtering based on Ant's glob syntax, e.g. `++**/books_*++`.
   You can learn more about these types and other aspects of Gradle's file API in the <<working_with_files#working_with_files,Working with Files>> chapter.
   
   You can construct Ant paths and filesets from within your build via the `ant` object if you need to interact with an Ant task that requires them.
   The chapter on <<ant#ant,Ant integration>> has examples that use both `<path>` and `<fileset>`.
   There is also link:{javadocPath}#[a method on `FileCollection`] that will convert a file collection to a fileset or similar Ant type.
   --
   
   == Migrating Ant properties
   
   Ant makes use of a properties map to store values that can be reused throughout the build.
   The big downsides to this approach are that property values are all strings and the properties themselves behave like global variables.
   
   .Interacting with Ant properties in Gradle
   --
   Sometimes you will want to make use of an Ant task directly from your Gradle build and that task requires one or more Ant properties to be set.
   
   If that's the case, you can easily set those properties via the `ant` object, as described in the <<ant#sec:ant_properties,Using Ant from Gradle>> chapter.
   --
   
   Gradle does use something similar in the form of <<project_properties.adoc#sec:project_properties,project properties>>, which are a reasonable way to parameterize a build.
   These can be set from the command line, in the <<build_environment#sec:gradle_configuration_properties,`gradle.properties` file>>, or via specially named system properties and environment variables.
   
   If you have existing Ant properties files, you can copy their contents into the project's `gradle.properties` file.
   Just be aware that:
   
    * Properties set in `gradle.properties` **do not** override <<writing_build_scripts#sec:extra_properties,extra project properties>> defined in the build script with the same name
    * Imported Ant tasks will not automatically "see" the Gradle project properties 댹맟ou must copy them into the Ant properties map for that to happen
   
   Another important factor to understand is that a Gradle build script works with an object-oriented API and it's often best to use the properties of tasks, source sets, and other objects where possible.
   For example, this build script fragment creates tasks for packaging Javadoc documentation as a JAR and unpacking it, linking tasks via their properties:
   
   .Using task properties in place of project properties
   ====
   include::sample[dir="snippets/antMigration/fileDeps/kotlin",files="build.gradle.kts[tags=properties]"]
   include::sample[dir="snippets/antMigration/fileDeps/groovy",files="build.gradle[tags=properties]"]
   ====
   <1> Packages all ``javadoc``'s output files 댹만quivalent to `from javadoc.destinationDir`
   <2> Uses the location of the Javadoc JAR held by the `javadocJar` task
   <3> Uses an project property called `tmpDistDir` to define the location of the 'dist' directory
   
   As you can see from the example with `tmpDistDir`, there is often a need to define paths through properties, which is why Gradle also provides <<writing_build_scripts#sec:extra_properties,extra properties>> that can be attached to the project, tasks, and some other types of objects.
   
   == Migrating multi-project builds
   
   Multi-project builds are a particular challenge to migrate because there is no standard approach in Ant for structuring them or handling inter-project dependencies.
   
   Fortunately, Gradle's multi-project support can handle fairly diverse project structures and it provides much more robust and helpful support than Ant for constructing and maintaining multi-project builds.
   The `ant.importBuild()` method also handles `<ant>` and `<antcall>` tasks transparently, which allows for a phased migration.
   
   The following steps highlight a suggested method for migrating a multi-project build:
   
    1. Start by learning <<multi_project_builds#multi_project_builds,how Gradle configures multi-project builds>>.
    2. Create a Gradle build script in each project of the build, setting their contents to this line:
   +
   [source.multi-language-sample,groovy]
   ----
   ant.importBuild 'build.xml'
   ----
   +
   [source.multi-language-sample,kotlin]
   ----
   ant.importBuild("build.xml")
   ----
   +
   Replace `build.xml` with the path to the actual Ant build file that corresponds to the project.
   If there is no corresponding Ant build file, leave the Gradle build script empty.
   Even if your build is not be suitable for this migration approach, continue with these steps to see if there is still a way to do a phased migration.
    3. Create a settings file that link:{groovyDslPath}#[]++)[includes all the projects] that now have a Gradle build script.
    4. Implement inter-project dependencies.
   +
   Some projects in your multi-project build will depend on artifacts produced by one or more other projects in that build.
   Such projects need to ensure that the projects they depend on have produced their artifacts and that the paths to those artifacts are known.
   +
   Ensuring the production of the required artifacts typically means calling into other projects' builds via the `<ant>` task.
   This unfortunately bypasses the Gradle build, negating any changes you make to the Gradle build scripts.
   You will need to replace targets that use `<ant>` tasks with Gradle <<more_about_tasks#sec:adding_dependencies_to_tasks,task dependencies>>.
   +
   For example, your web project depends on a "util" library that's part of the same build. The Ant build file for "web" might have a target like this:
   +
   ====
   include::sample[dir="snippets/antMigration/multiProject/groovy",files="web/build.xml[tags=build-required]"]
   ====
   <1> `root.dir` would have to be defined by the build
   +
   This can be replaced by an inter-project task dependency in the corresponding Gradle build script, as demonstrated in the following example that assumes the "web" project's "compile" task is requires "util" to be built beforehand:
   +
   ====
   include::sample[dir="snippets/antMigration/multiProject/kotlin",files="web/build.gradle.kts[]"]
   include::sample[dir="snippets/antMigration/multiProject/groovy",files="web/build.gradle[]"]
   ====
   +
   This is not as robust or powerful as Gradle's <<declaring_dependencies_between_subprojects#sec:project_jar_dependencies,project dependencies>>, but it solves the immediate problem without big changes to the build.
   Just be careful to remove or override any dependencies on tasks that delegate to other subprojects, like the `buildRequiredProjects` task.
    5. Identify the projects that have no dependencies on other projects and migrate them to idiomatic Gradle builds scripts.
   +
   Follow the advice in the rest of this guide to migrate individual project builds.
   As mentioned, you should use Gradle standard plugins where possible.
   This may mean that you need to add an extra copy task to each build that copies the generated artifacts to the location expected by the rest of the Ant builds.
    6. Migrate projects when they depend solely on projects with fully migrated Gradle builds.
   +
   At this point, you should be able to switch to using proper project dependencies attached to the appropriate dependency configurations.
    7. Clean up projects once no part of the Ant build depends on them.
   +
   We mentioned in step 5 that you might need to add copy tasks to satisfy the requirements of dependent Ant builds.
   Once those builds have been migrated, such build logic will no longer be needed and should be removed.
   
   At the end of the process you should have a Gradle build that you are confident works as it should, with much less build logic than before.
   
   == Further reading
   
   This chapter has covered the major topics that are specific to migrating Ant builds to Gradle.
   All that remain are a few other areas that may be useful following a migration:
   
    * Learn how to configure Gradle's <<build_environment#build_environment,build environment>>, including the JVM settings used to run it
    * Learn how to <<organizing_gradle_projects#organizing_gradle_projects,structure your builds effectively>>
    * <<logging#logging,Configure Gradle's logging>> and use it from your builds
   
   As a final note, this guide has only touched on a few of Gradle's features and we encourage you to learn about the rest from the other chapters of the User Manual.

/docs/userguide/releases/migrating/migrating_from_groovy_to_kotlin_dsl.adoc
===========================================================================

.. code-block::

   = Migrating build logic from Groovy to Kotlin
   :figure-caption!:
   :example-caption!:
   :plugin-portal: https://plugins.gradle.org/
   :kotlin-reference: https://kotlinlang.org/docs/reference/
   :kotlin-tutorials: https://kotlinlang.org/tutorials/
   :gradle-issues: https://github.com/gradle/gradle/issues/
   
   This section will walk you through converting your Groovy-based Gradle build scripts to Kotlin.
   
   Gradle's newer Kotlin DSL provides a pleasant editing experience in supported IDEs: content-assist, refactoring, documentation, and more.
   
   image::intellij-idea-android-studio.png[IntelliJ IDEA and Android Studio]
   
   [TIP]
   ====
   Please also read the <<kotlin_dsl.adoc#kotlin_dsl,Gradle Kotlin DSL Primer>> to learn the specificities, limitations and usage of the Gradle Kotlin DSL.
   
   The rest of the user manual contain build script excerpts that demonstrate both the Groovy DSL and the Kotlin DSL.
   This is the best place where to find how to do this and what with each DSL ; and it covers all Gradle features from <<plugins.adoc#using_plugins,using plugins>> to <<dependency_constraints.adoc#dependency-constraints,customizing the dependency resolution behavior>>.
   ====
   
   == Before you start migrating
   
   **Please read:** It's helpful to understand the following important information _before you migrate_:
   
   * Using the latest versions of Gradle, applied plugins, and your IDE should be your first move.
   * Kotlin DSL is fully supported in Intellij IDEA and Android Studio. Other IDEs, such as Eclipse or NetBeans, do not yet provide helpful tools for editing Gradle Kotlin DSL files, however, importing and working with Kotlin DSL-based builds work as usual.
   * In IntelliJ IDEA, you must link:https://www.jetbrains.com/help/idea/gradle.html#gradle_import[import your project from the Gradle model] to get content-assist and refactoring tools for Kotlin DSL scripts.
   * There are some situations where the Kotlin DSL is slower. First use, on clean checkouts or ephemeral CI agents for example, link:{gradle-issues}15886[are known to be slower].
   The same applies to the scenario in which something in the _buildSrc_ directory changes, which invalidates build-script caching.
   Builds with slow configuration time might affect the IDE responsiveness, please check out the <<performance.adoc#performance_gradle,documentation on Gradle performance>>.
   * You must run Gradle with Java 8 or higher. Java 7 is not supported.
   * The embedded Kotlin compiler is known to work on Linux, macOS, Windows, Cygwin, FreeBSD and Solaris on x86-64 architectures.
   * Knowledge of Kotlin syntax and basic language features is very helpful. The link:{kotlin-reference}[Kotlin reference documentation] and link:https://kotlinlang.org/docs/tutorials/koans.html[Kotlin Koans] should be useful to you.
   * Use of the `plugins {}` block to declare Gradle plugins significantly improves the editing experience, and is highly recommended. Consider adopting it in your Groovy build scripts before converting them to Kotlin.
   * The Kotlin DSL will not support `model {}` elements. This is part of the link:https://blog.gradle.org/state-and-future-of-the-gradle-software-model[discontinued Gradle Software Model].
   * Enabling the incubating configuration on demand feature is not recommended as it can lead to very hard-to-diagnose problems.
   
   Read more in the <<kotlin_dsl.adoc#kotlin_dsl,Gradle Kotlin DSL Primer>>.
   
   If you run to trouble or a suspected bug, please take advantage of the `gradle/gradle` link:{gradle-issues}[issue tracker].
   
   _You don't have to migrate all at once!_ Both Groovy and Kotlin-based build scripts can `apply` other scripts of either language. You can find inspiration for any Gradle features not covered in the link:https://github.com/gradle/kotlin-dsl/tree/master/samples[Kotlin DSL samples].
   
   
   == Prepare your Groovy scripts
   
   Some simple Kotlin and Groovy language differences can make converting scripts tedious:
   
   * Groovy strings can be quoted with single quotes `'string'` or double quotes `"string"` whereas Kotlin requires double quotes `"string"`.
   * Groovy allows to omit parentheses when invoking functions whereas Kotlin always requires the parentheses.
   * The Gradle Groovy DSL allows to omit the `=` assignment operator when assigning properties whereas Kotlin always requires the assignment operator.
   
   As a first migration step, it is recommended to prepare your Groovy build scripts by
   
   * unifying quotes using double quotes,
   * disambiguating function invocations and property assignments (using respectively parentheses and assignment operator).
   
   The former can easily be done by searching for `'` and replacing by `"`.
   For example,
   
   [.multi-language-sample]
   ====
   .build.gradle
   =====
   [source,groovy]
   ----
   group 'com.acme'
   dependencies {
       implementation 'com.acme:example:1.0'
   }
   ----
   =====
   ====
   
   becomes:
   
   [.multi-language-sample]
   ====
   .build.gradle
   =====
   [source,groovy]
   ----
   group "com.acme"
   dependencies {
       implementation "com.acme:example:1.0"
   }
   ----
   =====
   ====
   
   The next step is a bit more involved as it may not be trivial to distinguish function invocations and property assignments in a Groovy script.
   A good strategy is to make all ambiguous statements property assignments first and then fix the build by turning the failing ones to function invocations.
   
   For example,
   
   [.multi-language-sample]
   ====
   .build.gradle
   =====
   [source,groovy]
   ----
   group "com.acme"
   dependencies {
       implementation "com.acme:example:1.0"
   }
   ----
   =====
   ====
   
   becomes:
   
   [.multi-language-sample]
   ====
   .build.gradle
   =====
   [source,groovy]
   ----
   group = "com.acme"                          // <1>
   dependencies {
       implementation("com.acme:example:1.0")  // <2>
   }
   ----
   =====
   ====
   <1> Property assignment
   <2> Function invocation
   
   While staying valid Groovy, it is now unambiguous and close to the Kotlin syntax, making it easier to then rename the script to turn it into a Gradle Kotlin DSL script.
   
   It is important to note that while Groovy extra properties can be modified using an object's `ext` property, in Kotlin they are modified using the `extra` property. It is important to look at each object and update the build scripts accordingly.
   
   You can find an example in the <<writing_build_scripts#sec:extra_properties,userguide>>.
   
   == Script file naming
   
   NOTE: Groovy DSL script files use the `.gradle` file name extension.
   Kotlin DSL script files use the `.gradle.kts` file name extension.
   
   To use the Kotlin DSL, simply name your files `build.gradle.kts` instead of `build.gradle`.
   
   The <<organizing_gradle_projects.adoc#sec:settings_file,settings file>>, `settings.gradle`, can also be renamed `settings.gradle.kts`.
   
   In a multi-project build, you can have some modules using the Groovy DSL (with `build.gradle`) and others using the Kotlin DSL (with `build.gradle.kts`).
   
   On top of that, apply the following conventions for better IDE support:
   
   * Name scripts that are applied to `Settings` according to the pattern `*.settings.gradle.kts`,
   * Name <<init_scripts.adoc#init_scripts,init scripts>> according to the pattern `*.init.gradle.kts`.
   
   
   == Applying plugins
   
   Just like with the Groovy DSL, there are two ways to apply Gradle plugins:
   
   - <<plugins.adoc#sec:plugins_block,declaratively, using the `plugins {}` block>>,
   - <<plugins.adoc#sec:old_plugin_application,imperatively, using the legacy `apply(..)` functions>>.
   
   Here's an example using the declarative `plugins {}` block:
   
   ====
   include::sample[dir="snippets/kotlinDsl/applying-plugins-declarative/kotlin",files="build.gradle.kts[tags=script]"]
   include::sample[dir="snippets/kotlinDsl/applying-plugins-declarative/groovy",files="build.gradle[tags=script]"]
   ====
   
   The Kotlin DSL provides property extensions for all <<plugin_reference#plugin_reference,Gradle core plugins>>,
   as shown above with the `java`, `jacoco` or `maven-publish` declaration.
   
   Third party plugins can be applied the same way as with the Groovy DSL. Except for the double quotes and parentheses.
   You can also apply core plugins with that style. But the statically-typed accessors are recommended since they are
   type-safe and will be autocompleted by your IDE.
   
   You can also use the imperative `apply` syntax, but then non-core plugins must be included on the classpath of the build script:
   
   ====
   include::sample[dir="snippets/kotlinDsl/applying-plugins-imperative/kotlin",files="build.gradle.kts[tags=script]"]
   include::sample[dir="snippets/kotlinDsl/applying-plugins-imperative/groovy",files="build.gradle[tags=script]"]
   ====
   
   [NOTE]
   ====
   **We strongly recommend that you use the `plugins {}` block in preference to the `apply()` function.**
   
   The declarative nature of the `plugins {}` block enables the Kotlin DSL to provide type-safe accessors to the extensions, configurations and other features contributed by the applied plugins, which makes it easy for IDEs to discover the details of the plugins' models and makes them easy to configure. +
   See the <<plugins.adoc#sec:plugins_block,`plugins {}` block documentation>> in the Gradle user manual for more information.
   ====
   
   == Configuring plugins
   
   Many plugins come with extensions to configure them. If those plugins are applied using the declarative `plugins {}` block, then Kotlin extension functions are made available to configure their extension, the same way as in Groovy.
   The following sample shows how this works for the Jacoco Plugin.
   
   ====
   include::sample[dir="snippets/kotlinDsl/configuring-plugins-declaratively-applied/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/kotlinDsl/configuring-plugins-declaratively-applied/groovy",files="build.gradle[]"]
   ====
   
   By contrast, if you use the imperative `apply()` function to apply a plugin, then you will have to use the `configure<T>()` function to configure that plugin.
   The following sample shows how this works for the Checkstyle Plugin by explicitly declaring the plugin's extension class 댹`CheckstyleExtension`  in the `configure<T>()` function:
   
   ====
   include::sample[dir="snippets/kotlinDsl/configuring-plugins-imperatively-applied/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/kotlinDsl/configuring-plugins-imperatively-applied/groovy",files="build.gradle[]"]
   ====
   
   Again, we strongly recommend that you apply plugins declaratively via the `plugins {}` block.
   
   .Knowing what plugin-provided extensions are available
   --
   Because your IDE knows about the configuration elements that a plugin provides, it will include those elements when you ask your IDE for suggestions.
   This will happen both at the top level of your build scripts  most plugin extensions are added to the `Project` object 댹마nd within an extension's configuration block.
   
   You can also run the `:kotlinDslAccessorsReport` task to learn about the extensions contributed by all applied plugins.
   It prints the Kotlin code you can use to access those extensions and provides the name and type of the accessor methods.
   --
   
   If the plugin you want to configure relies on `groovy.lang.Closure` in its method signatures or uses other dynamic Groovy semantics, more work will be required to configure that plugin from a Kotlin DSL build script.
   See the <<kotlin_dsl.adoc#sec:interoperability,interoperability section of the Gradle Kotlin DSL documentation>> for more information on how to call Groovy code from Kotlin code or to keep that plugin's configuration in a Groovy script.
   
   Plugins also contribute tasks that you may want to configure directly.
   This topic is covered in the <<configuring-tasks>> section below.
   
   .Keeping build scripts declarative
   --
   To get the most benefits of the Gradle Kotlin DSL you should strive to keep your build scripts declarative.
   The main thing to remember here is that in order to get type-safe accessors, plugins must be applied before the body of build scripts.
   
   It is strongly recommended to read about <<kotlin_dsl.adoc#sec:configuring_plugins,configuring plugins>> with the Gradle Kotlin DSL in the Gradle user manual.
   
   If your build is a multi-project build, like mostly all *Android* builds for example, please also read the subsequent section about <<kotlin_dsl.adoc#sec:multi_project_builds,multi-project builds>>.
   
   Finally, there are strategies to <<kotlin_dsl.adoc#sec:plugins_resolution_strategy,use the `plugins {}` block with plugins that aren't published with the correct metadata>>, such as the *Android* Gradle Plugin.
   --
   
   == Configuration avoidance
   
   Gradle 4.9 introduced a new API for creating and configuring tasks in build scripts and plugins. The intent is for this new API to eventually replace the existing API.
   
   [quote]
   ____
   One of the major differences between the existing and new Gradle Tasks API is whether or not Gradle spends the time to create `Task` instances and run configuration code. The new API allows Gradle to delay or completely avoid configuring tasks that will never be executed in a build. For example, when compiling code, Gradle does not need to configure tasks that run tests.
   ____
   
   See the link:https://blog.gradle.org/preview-avoiding-task-configuration-time[_Evolving the Gradle API to reduce configuration time_] blog post and the <<task_configuration_avoidance.adoc#task_configuration_avoidance,Task Configuration Avoidance>> chapter in the user manual for more information.
   
   The Gradle Kotlin DSL embraces configuration avoidance by making the type-safe model accessors leverage the new APIs and providing DSL constructs to make them easier to use.
   Rest assured, the whole Gradle API remains available.
   
   
   == Configuring tasks
   
   The syntax for configuring tasks is where the Groovy and Kotlin DSLs start to differ significantly.
   
   .In Kotlin, Tasks are namespaced into the `tasks` container
   ====
   include::sample[dir="snippets/kotlinDsl/configuring-tasks-basics/kotlin",files="build.gradle.kts[tags=namespace]"]
   include::sample[dir="snippets/kotlinDsl/configuring-tasks-basics/groovy",files="build.gradle[tags=namespace]"]
   ====
   
   Note that in Kotlin the `tasks.jar {}` notation leverage the configuration avoidance API and defer the configuration of the `jar` task.
   
   If the type-safe task accessor `tasks.jar` isn't available, see the <<#configuring-plugins,configuring plugins>> section above, you can fallback to using the `tasks` container API. The Kotlin flavor of the following sample is strictly equivalent to the one using the type-safe accessor above:
   
   .Using the `tasks` container API
   ====
   include::sample[dir="snippets/kotlinDsl/configuring-tasks-basics/kotlin",files="build.gradle.kts[tags=using-api]"]
   include::sample[dir="snippets/kotlinDsl/configuring-tasks-basics/groovy",files="build.gradle[tags=using-api]"]
   ====
   
   Note that since Kotlin is a statically typed language, it is necessary to specify the type of the task explicitly. Otherwise, the script will not compile because the inferred type will be `Task`, not `Jar`, and the `archiveName` property is specific to the `Jar` task type.
   
   If configuration avoidance is getting in your way migrating and you want to eagerly configure a task just like Groovy you can do so by using the eager configuration API on the `tasks` container:
   
   .Using the `tasks` container API for eager configuration
   ====
   include::sample[dir="snippets/kotlinDsl/configuring-tasks-basics/kotlin",files="build.gradle.kts[tags=using-eager-api]"]
   include::sample[dir="snippets/kotlinDsl/configuring-tasks-basics/groovy",files="build.gradle[tags=using-eager-api]"]
   ====
   
   Working with containers in the Gradle Kotlin DSL is <<kotlin_dsl.adoc#kotdsl:containers,documented in detail here>>.
   
   .Knowing the type of a task
   --
   If you don't know what type a task has, then you can find that information out via the built-in `help` task.
   Simply pass it the name of the task you're interested in using the `--task` option, like so:
   
   [source,text]
   ----
   仇 ./gradlew help --task jar
   ...
   Type
        Jar (org.gradle.api.tasks.bundling.Jar)
   ----
   --
   
   Let's bring all this together by running through a quick worked example that configures the `bootJar` and `bootRun` tasks of a Spring Boot project:
   
   .Configuring Spring Boot using type-safe accessors
   ====
   include::sample[dir="snippets/kotlinDsl/configuring-tasks-spring-boot/kotlin",files="build.gradle.kts[tags=accessors]"]
   include::sample[dir="snippets/kotlinDsl/configuring-tasks-spring-boot/groovy",files="build.gradle[tags=accessors]"]
   ====
   
   This is pretty self explanatory.
   The main difference is that the task configuration automatically becomes lazy when using the Kotlin DSL accessors.
   
   Now, for the sake of the example, let's look at the same configuration applied using the API instead of the type-safe accessors that may not be available depending on the build logic structure, see the corresponding <<kotlin_dsl#sec:configuring_plugins,documentation>> in the Gradle user manual for more information.
   
   We first determine the types of the `bootJar` and `bootRun` tasks via the `help` task:
   
   [source,text]
   ----
   仇 ./gradlew help --task bootJar
   ...
   Type
        BootJar (org.springframework.boot.gradle.tasks.bundling.BootJar)
   ----
   
   [source,text]
   ----
   仇 ./gradlew help --task bootRun
   ...
   Type
        BootRun (org.springframework.boot.gradle.tasks.run.BootRun)
   ----
   
   Now that we know the types of the two tasks, we can import the relevant types 댹`BootJar` and `BootRun` 댹마nd configure the tasks as required.
   Note that the IDE can assist us with the required imports, so we only need the simple names, i.e. without the full packages.
   Here's the resulting build script, complete with imports:
   
   .Configuring Spring Boot using the API
   ====
   include::sample[dir="snippets/kotlinDsl/configuring-tasks-spring-boot/kotlin",files="build.gradle.kts[tags=lazy]"]
   include::sample[dir="snippets/kotlinDsl/configuring-tasks-spring-boot/groovy",files="build.gradle[tags=lazy]"]
   ====
   
   
   == Creating tasks
   
   Creating tasks can be done using the script top-level function named `task(...)`:
   
   .Using the top-level `tasks(...)` function
   ====
   include::sample[dir="snippets/kotlinDsl/creating-tasks-project/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/kotlinDsl/creating-tasks-project/groovy",files="build.gradle[]"]
   ====
   
   Note that the above eagerly configures the created task with both Groovy and Kotlin DSLs.
   
   Registering or creating tasks can also be done on the `tasks` container, respectively using the `register(...)` and `create(...)` functions as shown here:
   
   .Using the configuration avoidance API & DSL
   ====
   include::sample[dir="snippets/kotlinDsl/creating-tasks-lazy/kotlin",files="build.gradle.kts[tags=container-api]"]
   include::sample[dir="snippets/kotlinDsl/creating-tasks-lazy/groovy",files="build.gradle[tags=container-api]"]
   ====
   
   .Using the eager API & DSL
   ====
   include::sample[dir="snippets/kotlinDsl/creating-tasks-eager/kotlin",files="build.gradle.kts[tags=container-api]"]
   include::sample[dir="snippets/kotlinDsl/creating-tasks-eager/groovy",files="build.gradle[tags=container-api]"]
   ====
   
   The samples above create untyped, ad-hoc tasks, but you will more commonly want to create tasks of a specific type.
   This can also be done using the same `register()` and `create()` methods.
   Here's an example that creates a new task of type `Zip`:
   
   .Using the configuration avoidance API & DSL
   ====
   include::sample[dir="snippets/kotlinDsl/creating-tasks-lazy/kotlin",files="build.gradle.kts[tags=typed-container-api]"]
   include::sample[dir="snippets/kotlinDsl/creating-tasks-lazy/groovy",files="build.gradle[tags=typed-container-api]"]
   ====
   
   .Using the eager API & DSL
   ====
   include::sample[dir="snippets/kotlinDsl/creating-tasks-eager/kotlin",files="build.gradle.kts[tags=typed-container-api]"]
   include::sample[dir="snippets/kotlinDsl/creating-tasks-eager/groovy",files="build.gradle[tags=typed-container-api]"]
   ====
   
   
   == Configurations and dependencies
   
   Declaring dependencies in existing configurations is similar to the way it's done in Groovy build scripts, as you can see in this example:
   
   ====
   include::sample[dir="snippets/kotlinDsl/configurations-and-dependencies-declarative/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/kotlinDsl/configurations-and-dependencies-declarative/groovy",files="build.gradle[]"]
   ====
   
   Each configuration contributed by an applied plugin is also available as a member of the `configurations` container, so you can reference it just like any other configuration.
   
   .Knowing what configurations are available
   --
   The easiest way to find out what configurations are available is by asking your IDE for suggestions within the `configurations` container.
   
   You can also use the `:kotlinDslAccessorsReport` task, which prints the Kotlin code for accessing the configurations contributed by applied plugins and provides the names for all of those accessors.
   --
   
   Note that if you do not use the `plugins {}` block to apply your plugins, then you won't be able to configure the dependency configurations provided by those plugins in the usual way. Instead, you will have to use string literals for the configuration names, which means you won't get IDE support:
   
   ====
   include::sample[dir="snippets/kotlinDsl/configurations-and-dependencies-imperative/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/kotlinDsl/configurations-and-dependencies-imperative/groovy",files="build.gradle[]"]
   ====
   
   This is just one more reason to use the `plugins {}` block whenever you can!
   
   === Custom configurations and dependencies
   
   Sometimes you need to create your own configurations and attach dependencies to them.
   The following example declares two new configurations:
   
    * `db`, to which we add a PostgreSQL dependency
    * `integTestImplementation`, which is configured to extend the `testImplementation` configuration and to which we add a different dependency
   
   ====
   include::sample[dir="snippets/kotlinDsl/configurations-and-dependencies-custom/kotlin",files="build.gradle.kts[tags=delegated-properties]"]
   include::sample[dir="snippets/kotlinDsl/configurations-and-dependencies-custom/groovy",files="build.gradle[tags=custom]"]
   ====
   
   Note that we can only use the `db(...)` and `integTestImplementation(...)` notation within the `dependencies {}` block in the above example because both configurations are declared as delegated properties beforehand via the `creating()` method.
   If the configurations were defined elsewhere, you could only reference them either by first creating delegating properties via `configurations`  댹마s opposed to `configurations.creating()` 댹맖r by using string literals within the `dependencies {}` block.
   The following example demonstrates both approaches:
   
   ====
   include::sample[dir="snippets/kotlinDsl/configurations-and-dependencies-custom/kotlin",files="build.gradle.kts[tags=string-reference]"]
   ====
   
   
   == Migration strategies
   
   // TODO step by step to migrate a build script
   // https://gradle.slack.com/archives/C14BJHC2K/p1534945935000100
   // split into "migrating builds" vs. "migrating scripts"?
   
   As we've seen above, both scripts using the Kotlin DSL and those using the Groovy DSL can participate in the same build.
   In addition, Gradle plugins from the _buildSrc_ directory, an included build or an external location can be implemented using any JVM language.
   This makes it possible to migrate a build progressively, piece by piece, without blocking your team.
   
   Two approaches to migrations stand out:
   
    * Migrating the existing syntax of your build to Kotlin, bit by bit, while retaining the structure  what we call a _mechanical migration_
    * Restructuring your build logic towards Gradle best practices and switching to Kotlin DSL as part of that effort
   
   Both approaches are viable.
   A mechanical migration will be enough for simple builds.
   A complex and highly dynamic build may require some restructuring anyway, so in such cases reimplementing build logic to follow Gradle best practice makes sense.
   
   Since applying Gradle best practices will make your builds easier to use and faster, we recommend that you migrate all projects in that way eventually, but it makes sense to focus on the projects that have to be restructured first and those that would benefit most from the improvements.
   
   Also consider that the more parts of your build logic rely on the dynamic aspects of Groovy, the harder they will be to use from the Kotlin DSL.
   You'll find recipes on how to cross the dynamic boundaries from static Kotlin in the <<kotlin_dsl.adoc#sec:interoperability,interoperability section of the Gradle Kotlin DSL documentation>>, regardless of where the dynamic Groovy build logic resides.
   
   There are two key best practices that make it easier to work within the static context of the Kotlin DSL:
   
    * Using the `plugins {}` block
    * Putting local build logic in the build's _buildSrc_ directory
   
   The <<plugins.adoc#sec:plugins_block,`plugins {}` block>> is about keeping your build scripts declarative in order to get the best out of the Kotlin DSL.
   
   Utilizing the <<sharing_build_logic_between_subprojects.adoc#sec:using_buildsrc,_buildSrc_ project>> is about organizing your build logic into shared local plugins and conventions that are easily testable and provide good IDE support.
   
   === Kotlin DSL build structure samples
   
   Depending on your build structure you might be interested in the following user manual chapters:
   
   * The <<writing_build_scripts#writing_build_scripts,Writing Build Scripts>> chapter demonstrates the use of `apply(from = "")` to modularize build scripts.
   * The <<multi_project_builds#multi_project_builds,Multi-project Builds>> chapter demonstrates various multi-project build structures.
   * The <<custom_plugins#custom_plugins,Developing Custom Gradle Plugins>> and <<kotlin_dsl#kotlin_dsl,Gradle Kotlin DSL Primer>> chapters demonstrate how to develop custom Gradle plugins.
   * The <<composite_builds#composite_builds,Composing builds>> chapter demonstrates how to use Composite Builds.
   
   
   == Interoperability
   
   When mixing languages in your build logic, you may have to cross language boundaries.
   An extreme example would be a build that uses tasks and plugins that are implemented in Java, Groovy and Kotlin, while also using both Kotlin DSL and Groovy DSL build scripts.
   
   Quoting the Kotlin reference documentation:
   
   > Kotlin is designed with Java Interoperability in mind. Existing Java code can be called from Kotlin in a natural way, and Kotlin code can be used from Java rather smoothly as well.
   
   Both link:{kotlin-reference}java-interop.html[calling Java from Kotlin] and link:{kotlin-reference}java-to-kotlin-interop.html[calling Kotlin from Java] are very well covered in the Kotlin reference documentation.
   
   The same mostly applies to interoperability with Groovy code.
   In addition, the Kotlin DSL provides several ways to opt into Groovy semantics.
   
   .On the Gradle Kotlin DSL and interoperability
   --
   Please find detailed documentation in the <<kotlin_dsl.adoc#sec:interoperability,interoperability section of the Gradle Kotlin DSL Primer>>.
   --
   
   

/docs/userguide/releases/migrating/migrating_from_maven.adoc
============================================================

.. code-block::

   = Migrating Builds From Apache Maven
   
   https://maven.apache.org[Apache Maven] is a build tool for Java and other JVM-based projects. It is typical to migrate an existing Maven build to Gradle.
   
   This guide will help with such a migration by explaining the differences and similarities between the two tools and providing steps that you can follow to ease the process.
   
   Converting a build can be scary, but you don't have to do it alone.
   You can search our https://docs.gradle.org/[documentation], post on our https://discuss.gradle.org/[community forums], or reach out on our https://gradle.org/slack-invite[Slack channel] if you get stuck.
   
   == Making a case for migration
   
   The primary differences between Gradle and Maven are flexibility, performance, user experience, and dependency management.
   
   A visual overview of these aspects is available in the link:https://gradle.org/maven-vs-gradle[Maven vs Gradle feature comparison].
   
   Since Gradle 3.0, Gradle has invested heavily in making Gradle builds much faster, with features such as link:https://blog.gradle.org/introducing-gradle-build-cache[build caching], link:https://blog.gradle.org/incremental-compiler-avoidance[compile avoidance], and an improved incremental Java compiler.
   Gradle is now 2-10x faster than Maven for the vast majority of projects, even without using a build cache.
   In-depth performance comparison and business cases for switching from Maven to Gradle can be found link:https://gradle.org/gradle-vs-maven-performance/[here].
   
   == General guidelines
   
   Gradle and Maven have fundamentally different views on how to build a project.
   Gradle provides a flexible and extensible build model that delegates the actual work to the execution of a graph of tasks.
   Maven uses a model of fixed, linear phases to which you can attach goals (the things that do the work).
   This may make migrating between the two seem intimidating, but migrations can be surprisingly easy because Gradle follows many of the same conventions as Maven -- such as the <<java_plugin#sec:java_project_layout,standard project structure>> -- and its dependency management works in a similar way.
   
   Here we lay out a series of steps for you to follow that will help facilitate the migration of any Maven build to Gradle:
   
   TIP: Keep the old Maven build and new Gradle build side by side.
   You know the Maven build works, so you should keep it until you are confident that the Gradle build produces all the same artifacts.
   This also means that users can try the Gradle build without creating a new copy of the source tree.
   
    . link:https://scans.gradle.com[Create a build scan for the Maven build].
   +
   A build scan will make it easier to visualize what's happening in your existing Maven build.
   For Maven builds, you will be able to see the project structure, what plugins are being used, a timeline of the build steps, and more.
   Keep this handy so you can compare it to the Gradle build scans while converting the project.
   +
   . Develop a mechanism to verify that the two builds produce the same artifacts.
   +
   This is a vitally important step to ensure that your deployments and tests don't break.
   Even small changes, such as the contents of a manifest file in a JAR, can cause problems.
   If your Gradle build produces the same output as the Maven build, this will give you confidence in switching over and make it easier to implement the changes that will provide the greatest benefits.
   +
   This doesn't mean that you need to verify every artifact at every stage, although doing so can help you quickly identify the source of a problem.
   You should focus on the critical output such as final reports and the artifacts that are published or deployed.
   +
   You will need to factor in some inherent differences in the build output that Gradle produces compared to Maven.
   Generated POMs will contain only the information needed for consumption and they will use `<compile>` and `<runtime>` scopes correctly for that scenario.
   You might also see differences in the order of files in archives and of files on classpaths.
   Most differences will be minor, but it's worth identifying them and verifying that they are acceptable.
   +
    . <<migmvn:automatic_conversion,Run an automatic conversion>>.
   +
   This will create all the Gradle build files you need, even for <<migmvn:multimodule_builds,multi-module builds>>.
   For simpler Maven projects, the Gradle build will be ready to run!
   +
    . link:https://scans.gradle.com[Create a build scan for the Gradle build].
   +
   A build scan will make it easier to visualize what's happening in the build.
   For Gradle builds, you'll be able to see the project structure, the dependencies (regular and inter-project ones), what plugins are being used and the console output of the build.
   +
   Your build may fail at this point, but that's ok; the scan will still run.
   Compare the build scan for the Gradle build to the one for the Maven build and continue down this list to troubleshoot the failures.
   +
   We recommend that you regularly generate build scans during the migration to help you identify and troubleshoot problems.
   If you want, you can also use a Gradle build scan to identify opportunities to <<performance.adoc#performance_gradle,improve the performance of the build>>.
   +
    . <<migmvn:migrating_deps,Verify your dependencies and fix any problems>>.
   +
    . <<migmvn:integration_tests,Configure integration and functional tests>>.
   +
   Many tests can simply be migrated by configuring an extra source set.
   If you are using a third-party library, such as http://docs.fitnesse.org/FrontPage[FitNesse], look to see whether  there is a suitable community plugin available on the https://plugins.gradle.org/[Gradle Plugin Portal].
   +
    . Replace Maven plugins with Gradle equivalents.
   +
   In the case of <<migmvn:common_plugins,popular plugins>>, Gradle often has an equivalent plugin that you can use.
   You might also find that you can <<migmvn:unnecessary_plugins,replace a plugin with built-in Gradle functionality>>.
   As a last resort, you may need to reimplement a Maven plugin <<migmvn:custom_plugins,via your own custom plugins and task types>>.
   +
   The rest of this chapter looks in more detail at specific aspects of migrating a build from Maven to Gradle.
   
   == Understanding the build lifecycle
   
   Maven builds are based around the concept of https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html[_build lifecycles_] that consist of a set of fixed phases.
   This can be a challenge for users migrating to Gradle because the build lifecycle is <<build_lifecycle#build_lifecycle,a new concept>>.
   Although it's important to understand how Gradle builds fit into the structure of *initialization*, *configuration*, and *execution* phases, Gradle provides a helper feature that can mimic Maven's phases: <<lifecycle_tasks.adoc#sec:lifecycle_tasks,_lifecycle tasks_>>.
   
   This feature allow you to define your own "lifecycles" by creating no-action tasks that simply depend on the tasks you're interested in.
   And to make the transition to Gradle easier for Maven users, the <<base_plugin#sec:base_tasks,Base Plugin>> -- applied by all the JVM language plugins like the <<java_library_plugin#java_library_plugin,Java Library Plugin>> -- provides a set of lifecycle tasks that correspond to the main Maven phases.
   
   Here is a list of some of the main Maven phases and the Gradle tasks that they map to:
   
   `clean`::
   Use the `clean` task provided by the Base Plugin.
   
   `compile`::
   Use the `classes` task provided by the <<java_plugin.adoc#sec:java_tasks,Java Plugin>> and other JVM language plugins.
   This compiles all classes for all source files of all languages and also performs <<migmvn:filtering_resources,resource filtering>> via the `processResources` task.
   
   `test`::
   Use the `test` task provided by the Java Plugin.
   It runs the unit tests, and more specifically, the tests that make up the <<java_plugin.adoc#source_sets,`test` source set>>.
   
   `package`::
   Use the `assemble` task provided by the Base Plugin.
   This builds whatever is the appropriate package for the project; for example, a JAR for Java libraries or a WAR for traditional Java webapps.
   
   `verify`::
   Use the `check` task provided by the Base Plugin.
   This runs all verification tasks that are attached to it, which typically includes the unit tests, any static analysis tasks -- such as <<checkstyle_plugin#checkstyle_plugin,Checkstyle>> -- and others.
   If you want to include integration tests, you will have to <<migmvn:integration_tests,configure these manually>>.
   
   `install`::
   Use the `publishToMavenLocal` task provided by the <<publishing_maven#publishing_maven:tasks,Maven Publish Plugin>>.
   +
   Note that Gradle builds don't require you to "install" artifacts as you have access to more appropriate features like <<declaring_dependencies.adoc#sub:project_dependencies,inter-project dependencies>> and <<composite_builds#composite_builds,composite builds>>.
   You should only use `publishToMavenLocal` for interoperating with Maven builds.
   +
   Gradle also allows you to resolve dependencies against the local Maven cache, as described in the <<migmvn:declaring_repos,Declaring repositories>> section.
   
   `deploy`::
   Use the `publish` task provided by the <<publishing_maven#publishing_maven:tasks,Maven Publish Plugin>> -- making sure you switch from the older Maven Plugin (ID: `maven`) if your build is using that one.
   This will publish your package to all configured publication repositories.
   There are also tasks that allow you to publish to a single repository even when multiple ones are defined.
   +
   Note that the Maven Publish Plugin does not publish *source and Javadoc JARs* _by default_, but this can easily be activated as explained in <<building_java_projects.adoc#sec:java_packaging,the guide for building java projects>>.
   
   == Performing an automatic conversion
   
   Gradle's <<build_init_plugin#build_init_plugin,`init` task>> is typically used to create a new skeleton project, but you can also use it to convert an existing Maven build to Gradle automatically.
   Once Gradle is <<installation#installation,installed on your system>>, all you have to do is run the command
   
   [listing.terminal]
   ----
   > gradle init
   ----
   
   from the root project directory.
   This consists of parsing the existing POMs and generating the corresponding Gradle build scripts.
   Gradle will also create a settings script if you're migrating a <<multi_project_builds#multi_project_builds,multi-project build>>.
   
   You'll find that the new Gradle build includes the following:
   
    * All the custom repositories that are specified in the POM
    * Your external and inter-project dependencies
    * The appropriate plugins to build the project (limited to one or more of the <<publishing_maven.adoc#publishing_maven,Maven Publish>>, <<java_plugin.adoc#java_plugin,Java>> and <<war_plugin.adoc#war_plugin,War>> Plugins)
   
   See the <<build_init_plugin#sec:pom_maven_conversion,Build Init Plugin chapter>> for a complete list of the automatic conversion features.
   
   One thing to keep in mind is that assemblies are not automatically converted.
   This additional conversion will required some manual work.
   Options include:
   
    * Using the <<distribution_plugin#distribution_plugin,Distribution Plugin>>
    * Using the <<java_library_distribution_plugin#java_library_distribution_plugin,Java Library Distribution Plugin>>
    * Using the <<application_plugin#application_plugin,Application Plugin>>
    * <<working_with_files#sec:creating_archives_example,Creating custom archive tasks>>
    * Using a suitable community plugin from the https://plugins.gradle.org/[Gradle Plugin Portal]
   
   If your Maven build does not have many plugins or custom steps, you can simply run
   
   [listing.terminal]
   ----
   > gradle build
   ----
   
   once the migration has completed.
   This will run the tests and produce the required artifacts automatically.
   
   == Migrating dependencies
   
   Gradle's dependency management system is more flexible than Maven's, but it still supports the same concepts of repositories, declared dependencies, scopes (<<declaring_dependencies.adoc#sec:what-are-dependency-configurations,dependency configurations>> in Gradle), and transitive dependencies.
   In fact, Gradle works with Maven-compatible repositories which makes it easy to migrate your dependencies.
   
   NOTE: One notable difference between the two tools is in how they manage version conflicts. Maven uses a "closest" match algorithm, whereas Gradle picks the newest.
   Don't worry though, you have a lot of control over which versions are selected, as documented in <<dependency_constraints.adoc#dependency-constraints,Managing Transitive Dependencies>>.
   
   Over the following sections, we will show you how to migrate the most common elements of a Maven build's dependency management information.
   
   === Declaring dependencies
   
   Gradle uses the same dependency identifier components as Maven: group ID, artifact ID and version.
   It also supports classifiers.
   All you need to do is substitute the identifier information for a dependency into Gradle's syntax, which is described in the <<declaring_dependencies#declaring-dependencies,Declaring Dependencies>> chapter.
   
   For example, consider this Maven-style dependency on Log4J:
   
   [source,xml]
   ----
   <dependencies>
       <dependency>
           <groupId>log4j</groupId>
           <artifactId>log4j</artifactId>
           <version>1.2.12</version>
       </dependency>
   </dependencies>
   ----
   
   This dependency would look like the following in a Gradle build script:
   
   .Declaring a simple compile-time dependency
   ====
   include::sample[dir="snippets/mavenMigration/basic/kotlin",files="build.gradle.kts[tags=compile-dependencies]"]
   include::sample[dir="snippets/mavenMigration/basic/groovy",files="build.gradle[tags=compile-dependencies]"]
   ====
   <1> Attaches version 1.2.12 of Log4J to the `implementation` configuration (scope)
   
   The string identifier takes the Maven values of `groupId`, `artifactId` and `version`, although Gradle refers to them as `group`, `module` and `version`.
   
   The above example raises an obvious question: what is that `implementation` configuration?
   It's one of the standard dependency configurations provided by the <<java_plugin#tab:configurations,Java Plugin>> and is often used as a substitute for Maven's default `compile` scope.
   
   Several of the differences between Maven's scopes and Gradle's standard configurations come down to Gradle distinguishing between the dependencies required to build a module and the dependencies required to build a module that depends on it.
   Maven makes no such distinction, so published POMs typically include dependencies that consumers of a library don't actually need.
   
   Here are the main Maven dependency scopes and how you should deal with their migration:
   
   `compile`::
   Gradle has two configurations that can be used in place of the `compile` scope: `implementation` and `api`.
   The former is available to any project that applies the Java Plugin, while `api` is only available to projects that specifically apply the <<java_library_plugin#java_library_plugin,Java Library Plugin>>.
   
   +
   In most cases you should simply use the `implementation` configuration, particularly if you're building an application or webapp.
   But if you're building a library, you can learn about which dependencies should be declared using `api` in the section on <<building_java_projects#sec:building_java_libraries,Building Java libraries>>.
   Even more information on the differences between `api` and `implementation` is provided in the Java Library Plugin chapter linked above.
   
   `runtime`::
   Use the `runtimeOnly` configuration.
   
   `test`::
   Gradle distinguishes between those dependencies that are required to _compile_ a project's tests and those that are only needed to _run_ them.
   +
   Dependencies required for test compilation should be declared against the `testImplementation` configuration.
   Those that are only required for running the tests should use `testRuntimeOnly`.
   
   `provided`::
   Use the `compileOnly` configuration.
   +
   Note that the <<war_plugin#sec:war_dependency_management,War Plugin>> adds `providedCompile` and `providedRuntime` dependency configurations.
   These behave slightly differently from `compileOnly` and simply ensure that those dependencies aren't packaged in the WAR file.
   However, the dependencies are included on runtime and test runtime classpaths, so use these configurations if that's the behavior you need.
   
   `import`::
   The `import` scope is mostly used within `<dependencyManagement>` blocks and applies solely to POM-only publications.
   Read the section on <<migmvn:using_boms,Using bills of materials>> to learn more about how to replicate this behavior.
   +
   You can also specify a regular dependency on a POM-only publication.
   In this case, the dependencies declared in that POM are treated as normal transitive dependencies of the build.
   +
   For example, imagine you want to use the `groovy-all` POM for your tests.
   It's a POM-only publication that has its own dependencies listed inside a `<dependencies>` block.
   The appropriate configuration in the Gradle build looks like this:
   +
   .Consuming a POM-only dependency
   ====
   include::sample[dir="snippets/mavenMigration/basic/kotlin",files="build.gradle.kts[tags=pom-dependencies]"]
   include::sample[dir="snippets/mavenMigration/basic/groovy",files="build.gradle[tags=pom-dependencies]"]
   ====
   +
   The result of this will be that all `compile` and `runtime` scope dependencies in the `groovy-all` POM get added to the test runtime classpath, while only the `compile` scope dependencies get added to the test compilation classpath.
   Dependencies with other scopes will be ignored.
   
   === Declaring repositories
   
   Gradle allows you to retrieve declared dependencies from any Maven-compatible or Ivy-compatible repository.
   Unlike Maven, it has no default repository and so you have to declare at least one.
   In order to have the same behavior as your Maven build, just configure <<declaring_repositories.adoc#sub:maven_central,Maven Central>> in your Gradle build, like this:
   
   .Configuring the build to use Maven Central
   ====
   include::sample[dir="snippets/mavenMigration/basic/kotlin",files="build.gradle.kts[tags=repositories]"]
   include::sample[dir="snippets/mavenMigration/basic/groovy",files="build.gradle[tags=repositories]"]
   ====
   
   You can also use the `repositories {}` block to configure custom repositories, as described in the <<declaring_repositories.adoc#sec:maven_repo,Repository Types>> chapter.
   
   Lastly, Gradle allows you to resolve dependencies against the <<declaring_repositories.adoc#sub:maven_local,local Maven cache/repository>>.
   This helps Gradle builds interoperate with Maven builds, but it shouldn't be a technique that you use if you don't need that interoperability.
   If you want to share published artifacts via the filesystem, consider configuring a <<declaring_repositories.adoc#sec:maven_repo,custom Maven repository>> with a `file://` URL.
   
   You might also be interested in learning about Gradle's own <<dependency_resolution.adoc#sec:dependency_cache,dependency cache>>, which behaves more reliably than Maven's and can be used safely by multiple concurrent Gradle processes.
   
   === Controlling dependency versions
   
   The existence of transitive dependencies means that you can very easily end up with multiple versions of the same dependency in your dependency graph.
   By default, Gradle will pick the newest version of a dependency in the graph, but that's not always the right solution.
   That's why it provides several mechanisms for controlling which version of a given dependency is resolved.
   
   On a per-project basis, you can use:
   
    * <<dependency_constraints.adoc#sec:adding-constraints-transitive-deps,Dependency constraints>>
    * <<migmvn:using_boms,Bills of materials>> (Maven BOMs)
    * <<dependency_downgrade_and_exclude.adoc#sec:enforcing_dependency_version,Overriding transitive versions>>
   
   There are even more, specialized options listed in the <<dependency_constraints.adoc#dependency-constraints,controlling transitive dependencies>> chapter.
   
   If you want to ensure consistency of versions across all projects in a multi-project build, similar to how the `<dependencyManagement>` block in Maven works, you can use the <<java_platform_plugin#java_platform_plugin,Java Platform Plugin>>.
   This allows you declare a set of dependency constraints that can be applied to multiple projects.
   You can even publish the platform as a Maven BOM or using Gradle's metadata format.
   See the plugin page for more information on how to do that, and in particular the section on <<java_platform_plugin#sec:java_platform_consumption,Consuming platforms>> to see how you can apply a platform to other projects in the same build.
   
   
   === Excluding transitive dependencies
   
   Maven builds use exclusions to keep unwanted dependencies -- or unwanted _versions_ of dependencies -- out of the dependency graph.
   You can do the same thing with Gradle, but that's not necessarily the _right_ thing to do.
   Gradle provides other options that may be more appropriate for a given situation, so you really need to understand _why_ an exclusion is in place to migrate it properly.
   
   If you want to exclude a dependency for reasons unrelated to versions, then check out the section on <<dependency_downgrade_and_exclude.adoc#sec:excluding-transitive-deps,excluding transitive dependencies>>.
   It shows you how to attach an exclusion either to an entire configuration (often the most appropriate solution) or to a dependency.
   You can even easily apply an exclusion to all configurations.
   
   If you're more interested in controlling which version of a dependency is actually resolved, see the previous section.
   
   === Handling optional dependencies
   
   You are likely to encounter two situations regarding optional dependencies:
   
    * Some of your transitive dependencies are declared as optional
    * You want to declare some of your direct dependencies as optional in your project's published POM
   
   For the first scenario, Gradle behaves the same way as Maven and simply ignores any transitive dependencies that are declared as optional.
   They are not resolved and have no impact on the versions selected if the same dependencies appear elsewhere in the dependency graph as non-optional.
   
   As for publishing dependencies as optional, Gradle provides a richer model called <<feature_variants#feature_variants, feature variants>>, which will let you declare the "optional features" your library provides.
   
   == Using bills of materials (BOMs)
   
   Maven allows you to share dependency constraints by defining dependencies inside a `<dependencyManagement>` section of a POM file that has a packaging type of `pom`.
   This special type of POM (a BOM) can then be imported into other POMs so that you have consistent library versions across your projects.
   
   Gradle can use such BOMs for the same purpose, using a special dependency syntax based on link:{groovyDslPath}#[platform()] and link:{groovyDslPath}#[enforcedPlatform()] methods.
   You simply declare the dependency in the normal way, but wrap the dependency identifier in the appropriate method, as shown in this example that "imports" the Spring Boot Dependencies BOM:
   
   .Importing a BOM in a Gradle build
   ====
   include::sample[dir="snippets/mavenMigration/importBom/kotlin",files="build.gradle.kts[tags=bom]"]
   include::sample[dir="snippets/mavenMigration/importBom/groovy",files="build.gradle[tags=bom]"]
   ====
   <1> Applies the Spring Boot Dependencies BOM
   <2> Adds a dependency whose version is defined by that BOM
   
   You can learn more about this feature and the difference between `platform()` and `enforcedPlatform()` in the section on <<platforms.adoc#sub:bom_import,importing version recommendations from a Maven BOM>>.
   
   NOTE: You can use this feature to apply the `<dependencyManagement>` information from any dependency's POM to the Gradle build, even those that don't have a packaging type of `pom`. Both `platform()` and `enforcedPlatform()` will ignore any dependencies declared in the `<dependencies>` block.
   
   == Migrating multi-module builds (project aggregation)
   
   Maven's multi-module builds map nicely to Gradle's <<multi_project_builds#multi_project_builds,multi-project builds>>.
   Try the corresponding link:#[sample] to see how a basic multi-project Gradle build is set up.
   
   To migrate a multi-module Maven build, simply follow these steps:
   
    1. Create a settings script that matches the `<modules>` block of the root POM.
   +
   For example, this `<modules>` block:
   +
   [source,xml]
   ----
   <modules>
       <module>simple-weather</module>
       <module>simple-webapp</module>
   </modules>
   ----
   +
   can be migrated by adding the following line to the settings script:
   +
   .Declaring which projects are part of the build
   ====
   include::sample[dir="snippets/mavenMigration/multiModule/kotlin",files="settings.gradle.kts"]
   include::sample[dir="snippets/mavenMigration/multiModule/groovy",files="settings.gradle"]
   ====
   <1> Sets the name of the overall project
   <2> Configures two subprojects as part of this build
   +
   .Output of **`gradle projects`**
   ----
   > gradle projects
   include::{snippetsPath}/mavenMigration/multiModule/tests/projects.out[]
   ----
    2. Replace cross-module dependencies with <<declaring_dependencies.adoc#sub:project_dependencies,project dependencies>>.
    3. Replicate project inheritance with <<sharing_build_logic_between_subprojects#sec:convention_plugins,convention plugins>>.
   +
   This basically involves creating a root project build script that injects shared configuration into the appropriate subprojects.
   
   === Sharing versions across projects
   
   If you want to replicate the Maven pattern of having dependency versions declared in the `dependencyManagement` section of the root POM file, the best approach is to leverage the `java-platform` plugin.
   You will need to add a dedicated project for this and consume it in the regular projects of your build.
   See <<java_platform_plugin.adoc#java_platform_plugin,the documentation>> for more details on this pattern.
   
   == Migrating Maven profiles and properties
   
   Maven allows you parameterize builds using properties of various sorts.
   Some are read-only properties of the project model, others are user-defined in the POM.
   It even allows you to treat system properties as project properties.
   
   Gradle has a similar system of project properties, although it differentiates between those and system properties.
   You can, for example, define properties in:
   
   * the build script
   * a `gradle.properties` file in the root project directory
   * a `gradle.properties` file in the `$HOME/.gradle` directory
   
   Those aren't the only options, so if you are interested in finding out more about how and where you can define properties, check out the <<build_environment#build_environment,Build Environment>> chapter.
   
   One important piece of behavior you need to be aware of is what happens when the same property is defined in both the build script and one of the external properties files: the build script value takes precedence.
   Always.
   Fortunately, you can mimic the concept of profiles to provide overridable default values.
   
   Which brings us to Maven profiles.
   These are a way to enable and disable different configurations based on environment, target platform, or any other similar factor.
   Logically, they are nothing more than limited `if` statements.
   And since Gradle has much more powerful ways to declare conditions, it does not need맚o have formal support for profiles (except in the POMs of dependencies).
   You can easily get the same behavior by combining conditions with secondary build scripts, as you'll see.
   
   Let's say you have different deployment settings depending on the environment: local development (the default), a test environment, and production.
   To add profile-like behavior, you first create build scripts for each environment in the project root: `profile-default.gradle`, `profile-test.gradle`, and `profile-prod.gradle`.
   You can then conditionally apply one of those profile scripts based on a <<project_properties.adoc#sec:project_properties,project property>> of your own choice.
   
   The following example demonstrates the basic technique using a project property called `buildProfile` and profile scripts that simply initialize an <<writing_build_scripts#sec:extra_properties,extra project property>> called `message`:
   
   .Mimicking the behavior of Maven profiles in Gradle
   ====
   include::sample[dir="snippets/mavenMigration/profiles/kotlin",files="build.gradle.kts;profile-default.gradle.kts;profile-test.gradle.kts;profile-prod.gradle.kts"]
   include::sample[dir="snippets/mavenMigration/profiles/groovy",files="build.gradle;profile-default.gradle;profile-test.gradle;profile-prod.gradle"]
   ====
   <1> Checks for the existence of (Groovy) or binds (Kotlin) the `buildProfile` project property
   <2> Applies the appropriate profile script, using the value of `buildProfile` in the script filename
   <3> Prints out the value of the `message` extra project property
   <4> Initializes the `message` extra project property, whose value can then be used in the main build script
   
   With this setup in place, you can activate one of the profiles by passing a value for the project property you're using -- `buildProfile` in this case:
   
   .Output of **`gradle greeting`**
   ----
   > gradle greeting
   include::{snippetsPath}/mavenMigration/profiles/tests/greeting-default.out[]
   ----
   .Output of **`gradle -PbuildProfile=test greeting`**
   ----
   > gradle -PbuildProfile=test greeting
   include::{snippetsPath}/mavenMigration/profiles/tests/greeting-test.out[]
   ----
   
   You're not limited to checking project properties.
   You could also check environment variables, the JDK version, the OS the build is running on, or anything else you can imagine.
   
   One thing to bear in mind is that high level condition statements make builds harder to understand and maintain, similar to the way they complicate object-oriented code.
   The same applies to profiles.
   Gradle offers you many better ways to avoid the extensive use of profiles that Maven often requires, for example by configuring multiple tasks that are variants of one another.
   See the `publish__PubName__PublicationTo__RepoName__Repository` tasks created by the <<publishing_maven#publishing_maven:tasks,Maven Publish Plugin>>.
   
   For a lengthier discussion on working with Maven profiles in Gradle, look no further than https://blog.gradle.org/maven-pom-profiles[this blog post].
   
   
   == Filtering resources
   
   Maven has a phase called `process-resources` that has the goal `resources:resources` bound to it by default.
   This gives the build author an opportunity to perform variable substitution on various files, such as web resources, packaged properties files, etc.
   
   The Java plugin for Gradle provides a `processResources` task to do the same thing.
   This is a link:{groovyDslPath}#[ProcessResources] task that copies files from the configured resources directory -- `src/main/resources` by default -- to an output directory.
   And as with any `ProcessResources` or `Copy` task, you can configure it to perform <<working_with_files#filtering_files,file filtering>>, <<working_with_files#sec:renaming_files,renaming>>, and <<working_with_files#sec:filtering_files,content filtering>>.
   
   As an example, here's a configuration that treats the source files as https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_simpletemplateengine[Groovy `SimpleTemplateEngine`] templates, providing `version` and `buildNumber` properties to those templates:
   
   .Filtering the content of resources via the `processResources` task
   ====
   include::sample[dir="snippets/mavenMigration/basic/kotlin",files="build.gradle.kts[tags=process-resources]"]
   include::sample[dir="snippets/mavenMigration/basic/groovy",files="build.gradle[tags=process-resources]"]
   ====
   
   See the API docs for link:{javadocPath}#[CopySpec] to see all the options available to you.
   
   
   == Configuring integration tests
   
   Many Maven builds incorporate integration tests of some sort, which Maven supports through an extra set of phases: `pre-integration-test`, `integration-test`, `post-integration-test`, and `verify`.
   It also uses the Failsafe plugin in place of Surefire so that failed integration tests don't automatically fail the build (because you may need to clean up resources, such as a running application server).
   
   This behavior is easy to replicate in Gradle with source sets, as explained in our chapter on <<java_testing#sec:configuring_java_integration_tests,Testing in Java & JVM projects>>.
   You can then configure a clean-up task, such as one that shuts down a test server for example, to always run after the integration tests regardless of whether they succeed or fail using link:{groovyDslPath}#[]++)[Task.finalizedBy()].
   
   If you really don't want your integration tests to fail the build, then you can use the link:{groovyDslPath}#[Test.ignoreFailures] setting described in the <<java_testing#sec:test_execution,Test execution>> section of the Java testing chapter.
   
   Source sets also give you a lot of flexibility on where you place the source files for your integration tests.
   You can easily keep them in the same directory as the unit tests or, more preferably, in a separate source directory like `src/integTest/java`.
   To support other types of tests, simple add more source sets and link:{groovyDslPath}#[Test] tasks.
   
   == Migrating common plugins
   
   Maven and Gradle share a common approach of extending the build through plugins.
   Although the plugin systems are very different beneath the surface, they share many feature-based plugins, such as:
   
   * Shade/Shadow
   * Jetty
   * Checkstyle
   * JaCoCo
   * AntRun (see further down)
   
   Why does this matter? Because many plugins rely on standard Java conventions, migration is just a matter of replicating the configuration of the Maven plugin in Gradle.
   As an example, here's a simple Maven Checkstyle plugin configuration:
   
   [source,xml]
   ----
   ...
   <plugin>
     <groupId>org.apache.maven.plugins</groupId>
     <artifactId>maven-checkstyle-plugin</artifactId>
     <version>2.17</version>
     <executions>
       <execution>
         <id>validate</id>
         <phase>validate</phase>
         <configuration>
           <configLocation>checkstyle.xml</configLocation>
           <encoding>UTF-8</encoding>
           <consoleOutput>true</consoleOutput>
           <failsOnError>true</failsOnError>
           <linkXRef>false</linkXRef>
         </configuration>
         <goals>
           <goal>check</goal>
         </goals>
       </execution>
     </executions>
   </plugin>
   ...
   ----
   
   Everything outside of the configuration block can safely be ignored when migrating to Gradle.
   In this case, the corresponding Gradle configuration is as follows:
   
   .Configuring the Gradle Checkstyle Plugin
   ====
   include::sample[dir="snippets/mavenMigration/basic/kotlin",files="build.gradle.kts[tags=checkstyle]"]
   include::sample[dir="snippets/mavenMigration/basic/groovy",files="build.gradle[tags=checkstyle]"]
   ====
   
   The Checkstyle tasks are automatically added as dependencies of the `check` task, which also includes `test`.
   If you want to ensure that Checkstyle runs before the tests, then just specify an ordering with the
   link:{groovyDslPath}#[]++)[mustRunAfter(...)] method:
   
   .Controlling when the `checkstyle` task runs
   ====
   include::sample[dir="snippets/mavenMigration/basic/kotlin",files="build.gradle.kts[tags=depends-on]"]
   include::sample[dir="snippets/mavenMigration/basic/groovy",files="build.gradle[tags=depends-on]"]
   ====
   
   As you can see, the Gradle configuration is often much shorter than the Maven equivalent.
   You also have a much more flexible execution model since you are no longer constrained by Maven's fixed phases.
   
   While migrating a project from Maven, don't forget about source sets.
   These often provide a more elegant solution for handling integration tests or generated sources than Maven can provide, so you should factor them into your migration plans.
   
   
   === Ant goals
   
   Many Maven builds rely on the AntRun plugin to customize the build without the overhead of implementing a custom Maven plugin.
   Gradle has no equivalent plugin because Ant is a first-class citizen in Gradle builds, via the `ant` object.
   For example, you can use Ant's Echo task like this:
   
   .Invoking Ant tasks
   ====
   include::sample[dir="snippets/mavenMigration/ant/kotlin",files="build.gradle.kts"]
   include::sample[dir="snippets/mavenMigration/ant/groovy",files="build.gradle"]
   ====
   
   Even Ant properties and filesets are supported natively.
   To learn more, see <<ant#ant,Using Ant from Gradle>>.
   
   [TIP]
   ====
   It may be simpler and cleaner to just <<custom_tasks#custom_tasks,create custom task types>> to replace the work that Ant is doing for you.
   You can then more readily benefit from <<incremental_build.adoc#incremental_build,incremental build>> and other useful Gradle features.
   ====
   
   == Understanding which plugins you don't need
   
   It's worth remembering that Gradle builds are typically easier to extend and customize than Maven ones.
   In this context, that means you may not need a Gradle plugin to replace a Maven one.
   For example, the Maven Enforcer plugin allows you to control dependency versions and environmental factors, but these things can easily be configured in a normal Gradle build script.
   
   
   == Dealing with uncommon and custom plugins
   
   You may come across Maven plugins that have no counterpart in Gradle, particularly if you or someone in your organisation has written a custom plugin.
   Such cases rely on you understanding how Gradle (and potentially Maven) works, because you will usually have to write your own plugin.
   
   For the purposes of migration, there are two key types of Maven plugins:
   
   * Those that use the Maven project object.
   * Those that don't.
   
   Why is this important? Because if you use one of the latter, you can trivially reimplement it as a <<custom_tasks#custom_tasks,custom Gradle task type>>.
   Simply define task inputs and outputs that correspond to the mojo parameters and convert the execution logic into a task action.
   
   If a plugin depends on the Maven project, then you will have to rewrite it.
   Don't start by considering how the Maven plugin works, but look at what problem it is trying to solve.
   Then try to work out how to solve that problem in Gradle.
   You will probably find that the two build models are different enough that "transcribing" Maven plugin code into a Gradle plugin just won't be effective.
   On the plus side, the plugin is likely to be much easier to write than the original Maven one because Gradle has a much richer build model and API.
   
   If you do need to implement custom logic, either via build scripts or plugins, check out the https://gradle.org/guides/?q=Plugin%20Development[Guides related to plugin development].
   Also be sure to familiarize yourself with Gradle's link:{groovyDslPath}#[Groovy DSL Reference], which provides comprehensive documentation on the API that you'll be working with.
   It details the standard configuration blocks (and the objects that back them), the core types in the system (`Project`, `Task`, etc.), and the standard set of task types.
   The main entry point is the link:{groovyDslPath}#[Project] interface as that's the top-level object that backs the build scripts.
   
   == Further reading
   
   This chapter has covered the major topics that are specific to migrating Maven builds to Gradle. All that remain are a few other areas that may be useful during or after a migration:
   
    * Learn how to configure Gradle's <<build_environment#build_environment,build environment>>, including the JVM settings used to run it
    * Learn how to <<organizing_gradle_projects#organizing_gradle_projects,structure your builds effectively>>
    * <<logging#logging,Configure Gradle's logging>> and use it from your builds
   
   As a final note, this guide has only touched on a few of Gradle's features and we encourage you to learn about the rest from the other chapters of the user manual and from our link:#[step-by-step samples].

/docs/userguide/releases/upgrading/upgrading_version_4.adoc
===========================================================

.. code-block::

   = Upgrading your build from Gradle 4.x to 5.0
   
   This chapter provides the information you need to migrate your older Gradle 4.x builds to Gradle 5.0.
   In most cases, you will need to apply the changes from all versions that come after the one you're upgrading from.
   For example, if you're upgrading from Gradle 4.3 to 5.0, you will also need to apply the changes since 4.4, 4.5, etc up to 5.0.
   
   TIP: If you are using Gradle for Android, you need to move to version 3.3 or higher of both the Android Gradle Plugin and Android Studio.
   
   == For all users
   
    . If you are not already on the latest 4.10.x release, read the sections <<#changes_4.10,below>> for help upgrading your project to the latest 4.10.x release.
   We recommend upgrading to the latest 4.10.x release to get the most useful warnings and deprecations information before moving to 5.0.
   Avoid upgrading Gradle and migrating to Kotlin DSL at the same time in order to ease troubleshooting in case of potential issues.
    . Try running `gradle help --scan` and view the https://gradle.com/enterprise/releases/2018.4/#identify-usages-of-deprecated-gradle-functionality[deprecations view] of the generated build scan.
   If there are no warnings, the Deprecations tab will not appear.
   +
   image::deprecations.png[Deprecations View of a Gradle Build Scan]
   +
   This is so that you can see any deprecation warnings that apply to your build.
   Gradle 5.x will generate (potentially less obvious) errors if you try to upgrade directly to it.
   +
   Alternatively, you can run `gradle help --warning-mode=all` to see the deprecations in the console, though it may not report as much detailed information.
   . Update your plugins.
   +
   Some plugins will break with this new version of Gradle, for example because they use internal APIs that have been removed or changed.
   The previous step will help you identify potential problems by issuing deprecation warnings when a plugin does try to use a deprecated part of the API.
   +
   In particular, you will need to use at least a 2.x version of the https://plugins.gradle.org/plugin/com.github.johnrengelman.shadow[*Shadow Plugin*].
   . Run `gradle wrapper --gradle-version 5.0` to update the project to 5.0
   . Move to Java 8 or higher if you haven't already. Whereas Gradle 4.x requires Java 7, Gradle 5 requires Java 8 to run.
   . Read the <<#changes_5.0, Upgrading from 4.10>> section and make any necessary changes.
   . Try to run the project and debug any errors using the <<troubleshooting.adoc#troubleshooting, Troubleshooting Guide>>.
   
   In addition, Gradle has added several significant new and improved features that you should consider using in your builds:
   
    * <<#rel4.8:switch_to_publishing_plugins,Maven Publish and Ivy Publish Plugins>> that now support digital signatures with the <<signing_plugin#signing_plugin,Signing Plugin>>.
    * Use native <<#rel5.0:bom_import,BOM import>> in your builds.
    * The <<worker_api.adoc#worker_api,Worker API>> for enabling units of work to run in parallel.
    * A new API for <<#rel4.9:lazy_task_creation,creating and configuring tasks lazily>> that can significantly improve your build's configuration time.
   
   Other notable changes to be aware of that may break your build include:
   
    * <<#rel5.0:pom_compile_runtime_separation,Separation of compile and runtime dependencies when consuming POMs>>
    * A change that means you should <<#rel4.8:configure_internal_tasks,configure existing `wrapper` and `init` tasks>> rather than defining your own.
    * The <<#rel4.8:pom_wildcard_exclusions,honoring of implicit wildcards in Maven POM exclusions>>, which may result in dependencies being excluded that weren't before.
    * A <<#rel4.6:annotation_processor_configuration,change to the way you add Java annotation processors to a project>>.
    * The <<#rel5.0:default_memory_settings,default memory settings>> for the command-line client, the Gradle daemon, and all workers including compilers and test executors, have been greatly reduced.
    * The <<#rel5.0:default_tool_versions,default versions of several code quality plugins>> have been updated.
    * Several <<#rel5.0:library_upgrades, library versions used by Gradle>> have been upgraded.
   
   == Upgrading from 4.10 and earlier
   
   If you are not already on version 4.10, skip down to the section that applies to your current Gradle version and work your way up until you reach here. Then, apply these changes when moving from Gradle 4.10 to 5.0.
   
   === Other changes
   
    * The `enableFeaturePreview('IMPROVED_POM_SUPPORT')` and `enableFeaturePreview('STABLE_PUBLISHING')` flags are no longer necessary. These features are now enabled by default.
    * Gradle now bundles <<#rel5.0:jaxb_and_java9, JAXB>> for Java 9 and above. You can remove the `--add-modules java.xml.bind` option from `org.gradle.jvmargs`, if set.
   
   === Potential breaking changes
   
   The changes in this section have the potential to break your build, but the vast majority have been deprecated for quite some time and few builds will be affected by a large number of them.
   We strongly recommend upgrading to Gradle 4.10 first to get a report on what deprecations affect your build.
   
   The following breaking changes are not from deprecations, but the result of changes in behavior:
   
    * <<#rel5.0:pom_compile_runtime_separation,Separation of compile and runtime dependencies when consuming POMs>>
    * The evaluation of the `publishing {}` block is no longer deferred until needed but behaves like any other block.
      Please use `afterEvaluate {}` if you need to defer evaluation.
    * The link:{groovyDslPath}#[`Javadoc`] and link:{groovyDslPath}#[`Groovydoc`] tasks now delete the destination dir for the documentation before executing. This has been added to remove stale output files from the last task execution.
    * The <<java_library_distribution_plugin.adoc#java_library_distribution_plugin, Java Library Distribution Plugin>> is now based on the <<java_library_plugin.adoc#java_library_plugin, Java Library Plugin>> instead of the <<java_plugin.adoc#java_plugin, Java Plugin>>.
   +
   While it applies the Java Plugin, it behaves slightly different (e.g. it adds the `api` configuration).
   Thus, make sure to check whether your build behaves as expected after upgrading.
    * The `html` property on `CheckstyleReport` and `FindBugsReport` now returns a link:{groovyDslPath}#[`CustomizableHtmlReport`] instance that is easier to configure from statically typed languages like Java and Kotlin.
    * The <<#rel5.0:configuration_avoidance, Configuration Avoidance API>> has been updated to prevent the creation and configuration of tasks that are never used.
    * The <<#rel5.0:default_memory_settings,default memory settings>> for the command-line client, the Gradle daemon, and all workers including compilers and test executors, have been greatly reduced.
    * The <<#rel5.0:default_tool_versions,default versions of several code quality plugins>> have been updated.
    * Several <<#rel5.0:library_upgrades, library versions used by Gradle>> have been upgraded.
   
   The following breaking changes will appear as deprecation warnings with Gradle 4.10:
   
   General::
    * `<<` for task definitions no longer works. In other words, you can not use the syntax `task myTask << { ... }`.
   +
   Use the link:{groovyDslPath}#[Task.doLast()] method instead, like this:
   +
   ----
   task myTask {
       doLast {
           ...
       }
   }
   ----
    * You can no longer use any of the following characters in domain object names, such as project and task names: <space> `/ \ : < > " ? * |` . You should also not use `.` as a leading or trailing character.
   Running Gradle & build environment::
    * As mentioned before, Gradle can no longer be run on Java 7. However, you can still use <<building_java_projects.adoc#sec:java_cross_compilation,forked compilation and testing>> to build and test software for Java 6 and above.
    * The `-Dtest.single` command-line option has been removed 댹맛se <<java_testing.adoc#test_filtering,test filtering>> instead.
    * The `-Dtest.debug` command-line option has been removed  use the <<java_testing#sec:debugging_java_tests,`--debug-jvm` option>> instead.
    * The `-u`/`--no-search-upward` command-line option has been removed 댹맔ake sure all your builds have a _settings.gradle_ file.
    * The `--recompile-scripts` command-line option has been removed.
    * You can no longer have a Gradle build nested in a subdirectory of another Gradle build unless the nested build has a _settings.gradle_ file.
    * The `DirectoryBuildCache.setTargetSizeInMB(long)` method has been removed 댹맛se link:{groovyDslPath}#[DirectoryBuildCache.removeUnusedEntriesAfterDays] instead.
    * The `org.gradle.readLoggingConfigFile` system property no longer does anything 댹맛pdate affected tests to work with your `java.util.logging` settings.
   Working with files::
    * You can no longer cast `FileCollection` objects to other types using the `as` keyword or the `asType()` method.
    * You can no longer pass `null` as the configuration action of link:{javadocPath}#[CopySpec.from(Object, Action)].
    * For better compatibility with the Kotlin DSL, link:{javadocPath}#[CopySpec.duplicatesStrategy] is no longer nullable. The property setter no longer accepts `null` as a way
   to reset the property back to its default value. Use `DuplicatesStrategy.INHERIT` instead.
    * The `FileCollection.stopExecutionIfEmpty()` method has been removed  use the link:{javadocPath}#[@SkipWhenEmpty] annotation on `FileCollection` task properties instead.
    * The `FileCollection.add()` method has been removed 댹맛se link:{groovyDslPath}#[++])[Project.files()] and link:{groovyDslPath}#[Project.fileTree()] to create configurable file collections/file trees and add to them via link:{javadocPath}#[ConfigurableFileCollection.from()].
    * `SimpleFileCollection` has been removed  use link:{groovyDslPath}#[]++)[Project.files(Object...)] instead.
    * Don't have your own classes extend `AbstractFileCollection`  use the link:{groovyDslPath}#[++])[Project.files()] method instead. This problem may exhibit as a missing `getBuildDependencies()` method.
   Java builds::
    * The `CompileOptions.bootClasspath` property has been removed 댹맛se link:{groovyDslPath}#[CompileOptions.bootstrapClasspath] instead.
    * You can no longer use `-source-path` as a generic compiler argument 댹맛se link:{groovyDslPath}#[CompileOptions.sourcepath] instead.
    * You can no longer use `-processorpath` as a generic compiler argument 댹맛se link:{groovyDslPath}#[CompileOptions.annotationProcessorPath] instead.
    * Gradle will no longer automatically apply annotation processors that are on the compile classpath  use link:{groovyDslPath}#[CompileOptions.annotationProcessorPath] instead.
    * The `testClassesDir` property has been removed from the link:{groovyDslPath}#[Test] task 댹맛se link:{groovyDslPath}#[testClassesDirs] instead.
    * The `classesDir` property has been removed from both the _JDepend_ task and link:{groovyDslPath}#[SourceSetOutput]. Use the _JDepend.classesDirs_ and link:{groovyDslPath}#[SourceSetOutput.classesDirs] properties instead.
    * The `JavaLibrary(PublishArtifact, DependencySet)` constructor has been removed 댹맚his was used by the https://plugins.gradle.org/plugin/com.github.johnrengelman.shadow[Shadow Plugin], so make sure you upgrade to at least version 2.x of that plugin.
    * The `JavaBasePlugin.configureForSourceSet()` method has been removed.
    * You can no longer create your own instances of link:{javadocPath}#[JavaPluginConvention], link:{javadocPath}#[ApplicationPluginConvention], link:{javadocPath}#[WarPluginConvention], link:{javadocPath}#[EarPluginConvention], link:{javadocPath}#[BasePluginConvention], and link:{javadocPath}#[ProjectReportsPluginConvention].
    * The `Maven` Plugin used to publish the highly outdated Maven 2 metadata format. This has been changed and it will now publish Maven 3 metadata, just like the `Maven Publish` Plugin.
   +
   With the removal of Maven 2 support, the methods that configure unique snapshot behavior have also been removed. Maven 3 only supports unique snapshots, so we decided to remove them.
   Tasks & properties::
    * The following legacy classes and methods related to <<lazy_configuration#lazy_properties,lazy properties>> have been removed 댹맛se link:{javadocPath}#[ObjectFactory.property()] to create `Property` instances:
    ** `PropertyState`
    ** `DirectoryVar`
    ** `RegularFileVar`
    ** `ProjectLayout.newDirectoryVar()`
    ** `ProjectLayout.newFileVar()`
    ** `Project.property(Class)`
    ** `Script.property(Class)`
    ** `ProviderFactory.property(Class)`
    * Tasks configured and registered with the <<task_configuration_avoidance#sec:task_configuration_avoidance_migration_guidelines,task configuration avoidance>> APIs have more restrictions on the other methods that can be called from a configuration action.
    * The internal `@Option` and `@OptionValues` annotations  package `org.gradle.api.internal.tasks.options`  have been removed. Use the public link:{javadocPath}#[@Option] and link:{javadocPath}#[@OptionValues] annotations instead.
    * The `Task.deleteAllActions()` method has been removed with no replacement.
    * The `Task.dependsOnTaskDidWork()` method has been removed  use <<incremental_build.adoc#incremental_build,declared inputs and outputs>> instead.
    * The following properties and methods of `TaskInternal` have been removed 댹맛se task dependencies, task rules, reusable utility methods, or the <<worker_api.adoc#worker_api,Worker API>> in place of executing a task directly.
    ** `execute()`
    ** `executer`
    ** `getValidators()`
    ** `addValidator()`
    * The link:{javadocPath}#[TaskInputs.file(Object)] method can no longer be called with an argument that resolves to anything other than a single regular file.
    * The link:{javadocPath}#[TaskInputs.dir(Object)] method can no longer be called with an argument that resolves to anything other than a single directory.
    * You can no longer register invalid inputs and outputs via link:{javadocPath}#[TaskInputs] and link:{javadocPath}#[TaskOutputs].
    * The `TaskDestroyables.file()` and `TaskDestroyables.files()` methods have been removed 댹맛se link:{javadocPath}#[TaskDestroyables.register()] instead.
    * `SimpleWorkResult` has been removed 댹맛se link:{javadocPath}#[WorkResult.didWork].
    * Overriding built-in tasks <<#deprecations_4.8,deprecated in 4.8>> now produces an error.
   +
   Attempting to replace a built-in task will produce an error similar to the following:
   +
   ----
   > Cannot add task 'wrapper' as a task with that name already exists.
   ----
   Scala & Play::
    * Play 2.2 is no longer supported  please upgrade the version of Play you are using.
    * The `ScalaDocOptions.styleSheet` property has been removed  the Scaladoc Ant task in Scala 2.11.8 and later no longer supports this property.
   Kotlin DSL::
    * Artifact configuration accessors now have the type `NamedDomainObjectProvider<Configuration>` instead of `Configuration`
    * `PluginAware.apply<T>(to)` was renamed `PluginAware.applyTo<T>(target)`.
   
   +
   Both changes could cause script compilation errors. See the https://github.com/gradle/kotlin-dsl-samples/releases/tag/v1.0.2#breaking-changes[Gradle Kotlin DSL release notes] for more information and how to fix builds broken by the changes described above.
   
   Miscellaneous::
    * The `ConfigurableReport.setDestination(Object)` method has been removed 댹맛se link:{javadocPath}#[ConfigurableReport.setDestination(File)] instead.
    * The `Signature.setFile(File)` method has been removed 댹Gradle does not support changing the output file for the generated signature.
    * The read-only `Signature.toSignArtifact` property has been removed 댹말t should never have been part of the public API.
    * The `@DeferredConfigurable` annotation has been removed.
    * The method `isDeferredConfigurable()` was removed from `ExtensionSchema`.
    * `IdeaPlugin.performPostEvaluationActions()` and `EclipsePlugin.performPostEvaluationActions()` have been removed.
    * `The `BroadcastingCollectionEventRegister.getAddAction()` method has been removed with no replacement.
    * The internal `org.gradle.util` package is no longer imported by default.
   +
   Ideally you shouldn't use classes from this package, but, as a quick fix, you can add explicit imports to your build scripts for those classes.
    * The `gradlePluginPortal()` repository <<#rel5.0:gradle_plugin_portal_metadata,no longer looks for JARs without a POM by default>>.
    * The Tooling API can no longer connect to builds using a Gradle version below Gradle 2.6. The same applies to builds run through TestKit.
    * Gradle 5.0 requires a minimum Tooling API client version of 3.0. Older client libraries can no longer run builds with Gradle 5.0.
    * The IdeaModule Tooling API model element contains methods to retrieve resources and test resources so those elements were removed from the result of `IdeaModule.getSourceDirs()` and `IdeaModule.getTestSourceDirs()`.
    * In previous Gradle versions, the `source` field in `SourceTask` was accessible from subclasses. This is not the case anymore as the `source` field is now declared as `private`.
    * In the Worker API, <<#rel5.0:worker_api, the working directory of a worker can no longer be set>>.
    * A change in behavior related to <<#rel5.0:dependency_constraints,dependency and version constraints>> may impact a small number of users.
    * There have been several changes to <<#rel5.0:changes_to_default_task,property factory methods on DefaultTask>> that may impact the creation of custom tasks.
   
   == Upgrading from 4.9 and earlier
   
   If you are not already on version 4.9, skip down to the section that applies to your current Gradle version and work your way up until you reach here. Then, apply these changes when upgrading to Gradle 4.10.
   
   === Deprecated classes, methods and properties
   
   Follow the API links to learn how to deal with these deprecations (if no extra information is provided here):
   
    * `TaskContainer.add()` and `TaskContainer.addAll()` 댹맛se link:{javadocPath}#[TaskContainer.create()] or link:{javadocPath}#[TaskContainer.register()] instead
   
   === Potential breaking changes
   
    * There have been several potentially breaking changes in Kotlin DSL 댹맙ee the _Breaking changes_ section of https://github.com/gradle/kotlin-dsl/releases/tag/v1.0-RC3[that project's release notes].
    * You can no longer use any of the link:{groovyDslPath}#[Project.beforeEvaluate()] or link:{groovyDslPath}#[Project.afterEvaluate()] methods with lazy task configuration, for example inside a link:{javadocPath}#[TaskContainer.register()] block.
    * <<#rel4.10:aws_s3_permissions,Publishing to AWS S3 requires new permissions>>.
    * Both link:{javadocPath}#[PluginUnderTestMetadata] and link:{javadocPath}#[GeneratePluginDescriptors]  classes used by the <<java_gradle_plugin#java_gradle_plugin,Java Gradle Plugin Development Plugin>> 댹맏ave been updated to use the Provider API.
   +
   Use the link:{javadocPath}#[Property.set()] method to modify their values rather than using standard property assignment syntax, unless you are doing so in a Groovy build script.
   Standard property assignment still works in that one case.
   
   == Upgrading from 4.8 and earlier
   
    * <<#rel4.9:lazy_task_creation,Consider trying the lazy API for task creation and configuration>>
   
   === Potential breaking changes
   
    * You can no longer use GPath syntax with link:{javadocPath}#[tasks.withType()].
   +
   Use https://docs.groovy-lang.org/latest/html/documentation/#_spread_operator[Groovy's spread operator] instead.
   For example, you would replace `tasks.withType(JavaCompile).name` with `tasks.withType(JavaCompile)*.name`.
   
   == Upgrading from 4.7 and earlier
   
    * <<#rel4.8:switch_to_publishing_plugins,Switch to the Maven Publish and Ivy Publish plugins>>
    * <<#rel4.8:deferred_configuration,Use deferred configuration with the publishing plugins>>
    * <<#rel4.8:configure_internal_tasks,Configure existing `wrapper` and `init` tasks>> rather than defining your own
    * Consider migrating to the built-in <<dependency_locking#dependency-locking,dependency locking mechanism>> if you are currently using a plugin or custom solution for this
   
   
   === Potential breaking changes
   
    * Build will now fail if a specified init script is not found.
    * `TaskContainer.remove()` now actually removes the given task 댹맙ome plugins may have accidentally relied on the old behavior.
    * <<#rel4.8:pom_wildcard_exclusions,Gradle now honors implicit wildcards in Maven POM exclusions>>.
    * The Kotlin DSL now respects JSR-305 package annotations.
   +
   This will lead to some types annotated according to JSR-305 being treated as nullable where they were treated as non-nullable before.
   This may lead to compilation errors in the build script. See https://github.com/gradle/kotlin-dsl/releases/tag/v0.17.4[the relevant Kotlin DSL release notes] for details.
    * Error messages will be directed to standard error rather than standard output now, unless a console is attached to both standard output and standard error. This may affect tools that scrape a build's plain console output. Ignore this change if you're upgrading from an earlier version of Gradle.
   
   === Deprecations
   Prior to this release, builds were allowed to replace built-in tasks. link:https://docs.gradle.org/4.8/release-notes.html#overwriting-gradle\'s-built-in-tasks[This feature has been deprecated].
   
   The full list of built-in tasks that should not be replaced is:
   `wrapper`, `init`, `help`, `tasks`, `projects`, `buildEnvironment`, `components`, `dependencies`, `dependencyInsight`, `dependentComponents`, `model`, `properties`.
   
   == Upgrading from 4.6 and earlier
   
   === Potential breaking changes
   
    * Gradle will now, by convention, look for Checkstyle configuration files in the root project's _config/checkstyle_ directory.
   +
   Checkstyle configuration files in subprojects  the old by-convention location 댹망ill be ignored unless you explicitly configure their path via link:{groovyDslPath}#[checkstyle.configDir] or link:{groovyDslPath}#[checkstyle.config].
    * The structure of Gradle's <<#rel4.7:plain_console_output,plain console output>> has changed, which may break tools that scrape that output.
    * The APIs of many native tasks related to compilation, linking and installation <<rel:4.6:native_task_api_changes,have changed in breaking ways>>.
    * [Kotlin DSL] Delegated properties used to access Gradle's build properties  defined in _gradle.properties_ for example  must now be explicitly typed.
    * [Kotlin DSL] Declaring a `plugins {}` block inside a nested scope now throws an exception.
    * [Kotlin DSL] Only one `pluginManagement {}` block is allowed now.
    * The cache control DSL provided by the `org.gradle.api.artifacts.cache.*` interfaces are no longer available.
    * `getEnabledDirectoryReportDestinations()`, `getEnabledFileReportDestinations()` and `getEnabledReportNames()` have all been removed from `org.gradle.api.reporting.ReportContainer`.
    * link:{javadocPath}#[StartParameter.projectProperties] and link:{javadocPath}#[StartParameter.systemPropertiesArgs] now return immutable maps.
   
   == Upgrading from 4.5 and earlier
   
   === Deprecations
   
    * You should not put annotation processors on the compile classpath or declare them with the `-processorpath` compiler argument.
   +
   They should be added to the `annotationProcessor` configuration instead.
   If you don't want any processing, but your compile classpath contains a processor unintentionally (e.g. as part of a library you depend on), use the `-proc:none` compiler argument to ignore it.
    * Use link:{javadocPath}#[CommandLineArgumentProvider] in place of link:https://docs.gradle.org/4.10.3/javadoc/org/gradle/api/tasks/compile/CompilerArgumentProvider.html[CompilerArgumentProvider].
   
   === Potential breaking changes
   
    * The Java plugins now add a `__sourceSet__AnnotationProcessor` configuration for each source set, which might break if any of them match existing configurations you have. We recommend you remove your conflicting configuration declarations.
    * The `StartParameter.taskOutputCacheEnabled` property has been replaced by link:{javadocPath}#[StartParameter.setBuildCacheEnabled(boolean)].
    * The Visual Studio integration now only <<#rel4.6:visual_studio_single_solution,configures a single solution for all components in a build>>.
    * Gradle has replaced HttpClient 4.4.1 with version 4.5.5.
    * Gradle now bundles the `kotlin-stdlib-jdk8` artifact instead of `kotlin-stdlib-jre8`. This may affect your build. Please see the http://kotlinlang.org/docs/reference/whatsnew12.html#kotlin-standard-library-artifacts-and-split-packages[Kotlin documentation] for more details.
   
   == Upgrading from 4.4 and earlier
   
    * Make sure you have a _settings.gradle_ file: it avoids a performance penalty and allows you to set the root project's name.
    * Gradle now ignores the build cache configuration of included builds (<<composite_builds.adoc#composite_builds,composite builds>>) and instead uses the root build's configuration for all the builds.
   
   === Potential breaking changes
   
    * Two overloaded `ValidateTaskProperties.setOutputFile()` methods were removed. They are replaced with auto-generated setters when the task is accessed from a build script, but that won't be the case from plugins and other code outside of the build script.
    * The Maven Publish Plugin now produces more complete maven-metadata.xml files, including maintaining a list of `<snapshotVersion>` elements. Some older versions of Maven may not be able to consume this metadata.
    * <<#rel4.5:http_build_cache_no_follow_redirects,`HttpBuildCache` no longer follows redirects>>.
    * The `Depend` task type has been removed.
    * link:{groovyDslPath}#[Project.file(Object)] no longer normalizes case for file paths on case-insensitive file systems. It now ignores case in such circumstances and does not touch the file system.
    * link:{javadocPath}#[ListProperty] no longer extends link:{javadocPath}#[Property].
   
   == Upgrading from 4.3 and earlier
   
   === Potential breaking changes
   
    * link:{groovyDslPath}#[AbstractTestTask] is now extended by non-JVM test tasks as well as link:{groovyDslPath}#[Test]. Plugins should beware configuring all tasks of type `AbstractTestTask` because of this.
    * The default output location for link:{groovyDslPath}#[EclipseClasspath.defaultOutputDir] has changed from __``$projectDir``/bin__ to __``$projectDir``/bin/default__.
    * The deprecated `InstallExecutable.setDestinationDir(Provider)` was removed 댹맛se link:{groovyDslPath}#[InstallExecutable.installDirectory] instead.
    * The deprecated `InstallExecutable.setExecutable(Provider)` was removed  use link:{groovyDslPath}#[InstallExecutable.executableFile] instead.
    * Gradle will no longer prefer a version of Visual Studio found on the path over other locations. It is now a last resort.
   +
   You can bypass the toolchain discovery by specifying the installation directory of the version of Visual Studio you want via link:{groovyDslPath}#[VisualCpp.setInstallDir(Object)].
    * `pluginManagement.repositories` is now of type link:{groovyDslPath}#[RepositoryHandler] rather than `PluginRepositoriesSpec`, which has been removed.
    * 5xx HTTP errors during dependency resolution will now trigger exceptions in the build.
    * The embedded Apache Ant has been upgraded from 1.9.6 to 1.9.9.
    * <<#rel4.4:security_library_upgrades,Several third-party libraries used by Gradle have been upgraded>> to fix security issues.
   
   == Upgrading from 4.2 and earlier
   
    * The `plugins {}` block can now be <<plugins.adoc#sec:subprojects_plugins_dsl,used in subprojects>> and for <<plugins.adoc#sec:buildsrc_plugins_dsl,plugins in the _buildSrc_ directory>>.
   
   === Other deprecations
   
    * You should no longer run Gradle versions older than 2.6 via the Tooling API.
    * You should no longer run any version of Gradle via an older version of the Tooling API than 3.0.
    * You should no longer chain link:{javadocPath}#[TaskInputs.property(String,Object)] and link:{javadocPath}#[TaskInputs.properties(Map)] methods.
   
   === Potential breaking changes
   
    * link:{javadocPath}#[DefaultTask.newOutputDirectory()] now returns a `DirectoryProperty` instead of a `DirectoryVar`.
    * link:{javadocPath}#[DefaultTask.newOutputFile()] now returns a `RegularFileProperty` instead of a `RegularFileVar`.
    * link:{javadocPath}#[DefaultTask.newInputFile()] now returns a `RegularFileProperty` instead of a `RegularFileVar`.
    * link:{javadocPath}#[ProjectLayout.buildDirectory] now returns a `DirectoryProperty` instead of a `DirectoryVar`.
    * link:{groovyDslPath}#[AbstractNativeCompileTask.compilerArgs] is now of type `ListProperty<String>` instead of `List<String>`.
    * link:{groovyDslPath}#[AbstractNativeCompileTask.objectFileDir] is now of type `DirectoryProperty` instead of `File`.
    * link:{groovyDslPath}#[AbstractLinkTask.linkerArgs] is now of type `ListProperty<String>` instead of `List<String>`.
    * `TaskDestroyables.getFiles()` is no longer part of the public API.
    * Overlapping version ranges for a dependency now result in Gradle picking a version that satisfies all declared ranges.
   +
   For example, if a dependency on `some-module` is found with a version range of `[3,6]` and also transitively with a range of `[4,8]`, Gradle now selects version 6 instead of 8. The prior behavior was to select 8.
    * The order of elements in `Iterable` properties marked with either `@OutputFiles` or `@OutputDirectories` now matters. If the order changes, the property is no longer considered up to date.
   +
   Prefer using separate properties with `@OutputFile`/`@OutputDirectory` annotations or use `Map` properties with `@OutputFiles`/`@OutputDirectories` instead.
    * Gradle will no longer ignore dependency resolution errors from a repository when there is another repository it can check. Dependency resolution will fail instead. This results in more deterministic behavior with respect to resolution results.
   
   == Upgrading from 4.1 and earlier
   
   === Potential breaking changes
   
    * The `withPathSensitivity()` methods on link:{javadocPath}#[TaskFilePropertyBuilder] and link:{javadocPath}#[TaskOutputFilePropertyBuilder] have been removed.
    * The bundled `bndlib` has been upgraded from 3.2.0 to 3.4.0.
    * The FindBugs Plugin no longer renders progress information from its analysis. If you rely on that output in any way, you can enable it with _FindBugs.showProgress_.
   
   == Upgrading from 4.0
   
    * Consider using the new <<worker_api.adoc#worker_api,Worker API>> to enable units of work within your build to run in parallel.
   
   === Deprecated classes, methods and properties
   
   Follow the API links to learn how to deal with these deprecations (if no extra information is provided here):
   
    * link:https://docs.gradle.org/4.10.3/javadoc/org/gradle/api/Nullable.html[Nullable]
   
   === Potential breaking changes
   
    * Non-Java projects that have a <<declaring_dependencies.adoc#sub:project_dependencies,project dependency>> on a Java project now consume the `runtimeElements` configuration by default instead of the `default` configuration.
   +
   To override this behavior, you can explicitly declare the configuration to use in the project dependency.
   For example: `project(path: ':myJavaProject', configuration: 'default')`.
    * Default Zinc compiler upgraded from 0.3.13 to 0.3.15.
    * [Kotlin DSL] Base package renamed from `org.gradle.script.lang.kotlin` to `org.gradle.kotlin.dsl`.
   
   
   == Changes in detail
   
   === [5.0] Default memory settings changed
   
   The command line client now starts with 64MB of heap instead of 1GB.
   This may affect builds running directly inside the client VM using `--no-daemon` mode.
   We discourage the use of `--no-daemon`, but if you must use it, you can increase the available memory using the `GRADLE_OPTS` environment variable.
   
   The Gradle daemon now starts with 512MB of heap instead of 1GB.
   Large projects may have to increase this setting using the <<config_gradle.adoc#sec:configuring_jvm_memory,`org.gradle.jvmargs`>> property.
   
   All workers, including compilers and test executors, now start with 512MB of heap. The previous default was 1/4th of physical memory.
   Large projects may have to increase this setting on the relevant tasks, e.g. <<config_gradle.adoc#sec:configuring_jvm_memory,`JavaCompile`>> or link:{groovyDslPath}#[`Test`].
   
   === [5.0] New default versions for code quality plugins
   
   The default tool versions of the following code quality plugins have been updated:
   
    * The http://checkstyle.sourceforge.net[Checkstyle Plugin] now uses http://checkstyle.sourceforge.net/releasenotes.html#Release_8.12[8.12] instead of 6.19 by default.
    * The https://codenarc.org/[CodeNarc Plugin] now uses https://github.com/CodeNarc/CodeNarc/blob/master/CHANGELOG.md#version-121-aug-2018[1.2.1] instead of 1.1 by default.
    * The https://www.jacoco.org/jacoco/[JaCoCo Plugin] now uses https://www.jacoco.org/jacoco/trunk/doc/changes.html[0.8.2] instead of 0.8.1 by default.
    * The https://pmd.github.io/[PMD Plugin] now uses https://pmd.github.io/pmd-6.8.0/pmd_release_notes.html#30-september-2018---680[6.8.0] instead of 5.6.1 by default.
   +
   In addition, the default ruleset was changed from the now deprecated `java-basic` to `category/java/errorprone.xml`.
   +
   We recommend configuring a ruleset explicitly, though.
   
   === [5.0] Library upgrades
   Several libraries that are used by Gradle have been upgraded:
   
    * Groovy was upgraded from 2.4.15 to https://groovy-lang.org/releasenotes/groovy-2.5.html[2.5.4].
    * Ant has been upgraded from 1.9.11 to https://archive.apache.org/dist/ant/RELEASE-NOTES-1.9.13.html[1.9.13].
    * The AWS SDK used to access S3-backed Maven/Ivy repositories has been upgraded from 1.11.267 to https://github.com/aws/aws-sdk-java/blob/master/CHANGELOG.md#111407-2018-09-11[1.11.407].
    * The BND library used by the OSGi Plugin has been upgraded from 3.4.0 to https://github.com/bndtools/bnd/wiki/Changes-in-4.0.0[4.0.0].
    * The Google Cloud Storage JSON API Client Library used to access Google Cloud Storage backed Maven/Ivy repositories has been upgraded from v1-rev116-1.23.0 to v1-rev136-1.25.0.
    * Ivy has been upgraded from 2.2.0 to http://ant.apache.org/ivy/history/2.3.0/release-notes.html[2.3.0].
    * The JUnit Platform libraries used by the `Test` task have been upgraded from 1.0.3 to 1.3.1.
    * The Maven Wagon libraries used to access Maven repositories have been upgraded from 2.4 to 3.0.0.
    * SLF4J has been upgraded from 1.7.16 to https://www.slf4j.org/news.html[1.7.25].
   
   === [5.0] Improved support for dependency and version constraints
   
   Through the Gradle 4.x release stream, new `@Incubating` features were added to the dependency resolution engine.
   These include sophisticated version constraints (`prefer`, `strictly`, `reject`), dependency constraints, and `platform` dependencies.
   
   If you have been using the `IMPROVED_POM_SUPPORT` feature preview, playing with constraints or prefer, reject and other specific version indications, then make sure to take a good look at your dependency resolution results.
   
   === [5.0] BOM import
   
   Gradle now provides support for importing bill of materials (BOM) files, which are effectively POM files that use `<dependencyManagement>` sections to control the versions of direct and transitive dependencies. All you need to do is declare the POM as a `platform` dependency.
   
   The following example picks the versions of the `gson` and `dom4j` dependencies from the declared Spring Boot BOM:
   
   ----
   dependencies {
       // import a BOM
       implementation platform('org.springframework.boot:spring-boot-dependencies:1.5.8.RELEASE')
   
       // define dependencies without versions
       implementation 'com.google.code.gson:gson'
       implementation 'dom4j:dom4j'
   }
   ----
   
   === [5.0] Separation of compile and runtime dependencies when consuming POMs
   
   Since Gradle 1.0, runtime-scoped dependencies have been included in the Java compilation classpath, which has some drawbacks:
   
    * The compilation classpath is much larger than it needs to be, slowing down compilation.
    * The compilation classpath includes runtime-scoped files that do not impact compilation, resulting in unnecessary re-compilation when those files change.
   
   With this new behavior, the Java and Java Library plugins both honor the <<java_library_plugin.adoc#sec:java_library_separation,separation of compile and runtime scopes>>. This means that the compilation classpath only includes compile-scoped dependencies, while the runtime classpath adds the runtime-scoped dependencies as well.
   This is particularly useful if you develop and publish Java libraries with Gradle where the separation between `api` and `implementation` dependencies is reflected in the published scopes.
   
   === [5.0] Changes to property factory methods on `DefaultTask`
   
   ==== Property factory methods on `DefaultTask` are now final
   The property factory methods such as `newInputFile()` are intended to be called from the constructor of a type that extends `DefaultTask`.
   These methods are now final to avoid subclasses overriding these methods and using state that is not initialized.
   
   ==== Inputs and outputs are not automatically registered
   The Property instances that are returned by these methods are no longer automatically registered as inputs or outputs of the task.
   The Property instances need to be declared as inputs or outputs in the usual ways, such as attaching annotations such as `@OutputFile` or using the runtime API to register the property.
   
   For example, you could previously use the following syntax and have both outputFile instances registered as declared outputs:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   class MyTask extends DefaultTask {
       // note: no annotation here
       final RegularFileProperty outputFile = newOutputFile()
   }
   
   task myOtherTask {
       def outputFile = newOutputFile()
       doLast { ... }
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   open class MyTask : DefaultTask() {
       // note: no annotation here
       val outputFile: RegularFileProperty = newOutputFile()
   }
   
   task("myOtherTask") {
       val outputFile = newOutputFile()
       doLast { ... }
   }
   ----
   =====
   ====
   
   Now you have to explicitly register `outputFile`, like this:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle
   [source, groovy]
   ----
   class MyTask extends DefaultTask {
       @OutputFile // property needs an annotation
       final RegularFileProperty outputFile = project.objects.fileProperty()
   }
   
   task myOtherTask {
       def outputFile = project.objects.fileProperty()
       outputs.file(outputFile) // or to be registered using the runtime API
       doLast { ... }
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   open class MyTask : DefaultTask() {
       @OutputFile // property needs an annotation
       val outputFile: RegularFileProperty = project.objects.fileProperty()
   }
   
   task("myOtherTask") {
       val outputFile = project.objects.fileProperty()
       outputs.file(outputFile) // or to be registered using the runtime API
       doLast { ... }
   }
   ----
   =====
   ====
   
   === [5.0] Gradle now bundles JAXB for Java 9 and above
   
   In order to use S3 backed artifact repositories, you previously had to add `--add-modules java.xml.bind` to `org.gradle.jvmargs` when running on Java 9 and above.
   
   Since Java 11 no longer contains the `java.xml.bind` module, Gradle now bundles JAXB 2.3.1 (`com.sun.xml.bind:jaxb-impl`) and uses it on Java 9 and above.
   
   Please remove the `--add-modules java.xml.bind` option from `org.gradle.jvmargs`, if set.
   
   === [5.0] The `gradlePluginPortal()` repository no longer looks for JARs without a POM by default
   
   With this new behavior, if a plugin or a transitive dependency of a plugin found in the `gradlePluginPortal()` repository has no Maven POM it will fail to resolve.
   
   Artifacts published to a Maven repository without a POM should be fixed.
   If you encounter such artifacts, please ask the plugin or library author to publish a new version with proper metadata.
   
   If you are stuck with a bad plugin, you can work around by re-enabling JARs as metadata source for the `gradlePluginPortal()` repository:
   
   ====
   [.multi-language-sample]
   =====
   .settings.gradle
   [source,groovy]
   ----
   pluginManagement {
       repositories {
           gradlePluginPortal().tap {
               metadataSources {
                   mavenPom()
                   artifact()
               }
           }
       }
   }
   ----
   =====
   
   [.multi-language-sample]
   =====
   .settings.gradle.kts
   [source,kotlin]
   ----
   pluginManagement {
       repositories {
           gradlePluginPortal().apply {
               (this as MavenArtifactRepository).metadataSources {
                   mavenPom()
                   artifact()
               }
           }
       }
   }
   ----
   =====
   ====
   
   === Java Library Distribution Plugin utilizes Java Library Plugin
   
   The <<java_library_distribution_plugin.adoc#java_library_distribution_plugin,Java Library Distribution Plugin>> is now based on the
   <<java_library_plugin.adoc#java_library_plugin, Java Library Plugin>> instead of the <<java_plugin.adoc#java_plugin, Java Plugin>>.
   
   Additionally, the default distribution created by the plugin will contain all artifacts of the `runtimeClasspath` configuration instead of the deprecated `runtime` configuration.
   
   === Configuration Avoidance API disallows common configuration errors
   
   The <<task_configuration_avoidance.adoc#task_configuration_avoidance, configuration avoidance API>> introduced in Gradle 4.9 allows you to avoid creating and configuring tasks that are never used.
   
   With the existing API, this example adds two tasks (`foo` and `bar`):
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle
   [source, groovy]
   ----
   tasks.create("foo") {
       tasks.create("bar")
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   tasks.create("foo") {
       tasks.create("bar")
   }
   ----
   =====
   ====
   
   When converting this to use the new API, something surprising happens: `bar` doesn't exist.
   The new API only executes configuration actions when necessary,
   so the `register()` for task `bar` only executes when `foo` is configured.
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle
   [source, groovy]
   ----
   tasks.register("foo") {
       tasks.register("bar") // WRONG
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   tasks.register("foo") {
       tasks.register("bar") // WRONG
   }
   ----
   =====
   ====
   
   To avoid this, Gradle now detects this and prevents modification to the underlying container (through `create()` or `register()`) when using the new API.
   
   === [5.0] Worker API: working directory of a worker can no longer be set
   
   Since JDK 11 no longer supports changing the working directory of a running process, setting the working directory of a worker via its fork options is now prohibited.
   
   All workers now use the same working directory to enable reuse.
   
   Please pass files and directories as arguments instead.
   
   === [4.10] Publishing to AWS S3 requires new permissions
   
   The S3 repository transport protocol allows Gradle to publish artifacts to AWS S3 buckets.
   Starting with this release, every artifact uploaded to an S3 bucket will be equipped with the `bucket-owner-full-control` canned ACL.
   Make sure that the AWS account used to publish artifacts has the `s3:PutObjectAcl` and `s3:PutObjectVersionAcl` permissions, otherwise the upload will fail.
   
   [source,json]
   ----
   {
       "Version":"2012-10-17",
       "Statement":[
           // ...
           {
               "Effect":"Allow",
               "Action":[
                   "s3:PutObject", // necessary for uploading objects
                   "s3:PutObjectAcl", // required starting with this release
                   "s3:PutObjectVersionAcl" // if S3 bucket versioning is enabled
               ],
               "Resource":"arn:aws:s3:::myCompanyBucket/*"
           }
       ]
   }
   ----
   
   See <<declaring_repositories.adoc#sub:s3_cross_account,AWS S3 Cross Account Access>> for more information.
   
   === [4.9] Consider trying the lazy API for task creation and configuration
   
   Gradle 4.9 introduced a new way to create and configure tasks that works lazily.
   When you use this approach for tasks that are expensive to configure, or when you have many, many tasks, your build configuration time can drop significantly when those tasks don't run.
   
   You can learn more about lazily creating tasks in the <<task_configuration_avoidance#task_configuration_avoidance,Task Configuration Avoidance>> chapter. You can also read about the background to this new feature in https://blog.gradle.org/preview-avoiding-task-configuration-time[this blog post].
   
   === [4.8] Switch to the Maven Publish and Ivy Publish Plugins
   
   Now that the publishing plugins are stable, we recommend that you migrate from the legacy publishing mechanism for standard Java projects, i.e. those based on the <<java_plugin#java_plugin,Java Plugin>>.
   That includes projects that use any one of: <<java_library_plugin#java_library_plugin,Java Library Plugin>>, <<application_plugin#application_plugin,Application Plugin>> or <<war_plugin#war_plugin,War Plugin>>.
   
   To use the new approach, simply replace any `upload<Conf>` configuration with a `publishing {}` block. See the <<publishing_setup.adoc#publishing_overview,publishing overview chapter>> for more information.
   
   === [4.8] Use deferred configuration for publishing plugins
   
   Prior to Gradle 4.8, the `publishing {}` block was implicitly treated as if all the logic inside it was executed after the project was evaluated.
   This was confusing, because it was the only block that behaved that way.
   As part of the stabilization effort in Gradle 4.8, we are deprecating this behavior and asking all users to migrate their build.
   
   The new, stable behavior can be switched on by adding the following to your settings file:
   
   ====
   [.multi-language-sample]
   =====
   .settings.gradle
   [source, groovy]
   ----
   enableFeaturePreview('STABLE_PUBLISHING')
   ----
   =====
   [.multi-language-sample]
   =====
   .settings.gradle.kts
   [source,kotlin]
   ----
   enableFeaturePreview("STABLE_PUBLISHING")
   ----
   =====
   ====
   
   We recommend doing a test run with a local repository to see whether all artifacts still have the expected coordinates.
   In most cases everything should work as before and you are done.
   However, your publishing block may rely on the implicit deferred configuration, particularly if it relies on values that may change during the configuration phase of the build.
   
   For example, under the new behavior, the following logic assumes that `jar.archiveBaseName` doesn't change after `artifactId` is set:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle
   [source, groovy]
   ----
   subprojects {
       publishing {
           publications {
               mavenJava {
                   from components.java
                   artifactId = jar.archiveBaseName
               }
           }
       }
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   subprojects {
       publishing {
           publications {
               named<MavenPublication>("mavenJava") {
                   from(components["java"])
                   artifactId = tasks.jar.get().archiveBaseName.get()
               }
           }
       }
   }
   ----
   =====
   ====
   
   If that assumption is incorrect or might possibly be incorrect in the future, the `artifactId` must be set within an `afterEvaluate {}` block, like so:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle
   [source, groovy]
   ----
   subprojects {
       publishing {
           publications {
               mavenJava {
                   from components.java
                   afterEvaluate {
                       artifactId = jar.archiveBaseName
                   }
               }
           }
       }
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   subprojects {
       publishing {
           publications {
               named<MavenPublication>("mavenJava") {
                   from(components["java"])
                   afterEvaluate {
                       artifactId = tasks.jar.get().archiveBbaseName.get()
                   }
               }
           }
       }
   }
   ----
   =====
   ====
   
   === [4.8] Configure existing `wrapper` and `init` tasks
   
   You should no longer define your own `wrapper` and `init` tasks. Configure the existing tasks instead, for example by converting this:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle
   [source, groovy]
   ----
   task wrapper(type: Wrapper) {
       ...
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   task<Wrapper>("wrapper") {
       ...
   }
   ----
   =====
   ====
   
   to this:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle
   [source, groovy]
   ----
   wrapper {
       ...
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   tasks.wrapper {
       ...
   }
   ----
   =====
   ====
   
   === [4.8] Gradle now honors implicit wildcards in Maven POM exclusions
   
   If an exclusion in a Maven POM was missing either a `groupId` or `artifactId`, Gradle used to ignore the exclusion.
   Now the missing elements are treated as implicit wildcards 댹만.g. `<groupId>*</groupId>`  which means that some of your dependencies may now be excluded where they weren't before.
   
   You will need to explicitly declare any missing dependencies that you need.
   
   === [4.7] Changes to the structure of Gradle's plain console output
   
   The plain console mode now formats output consistently with the rich console, which means that the output format has changed.
   For example:
   
    * The output produced by a given task is now grouped together, even when other tasks execute in parallel with it.
    * Task execution headers are printed with a "> Task" prefix.
    * All output produced during build execution is written to the standard output file handle. This includes messages written to System.err unless you are redirecting standard error to a file or any other non-console destination.
   
   This may break tools that scrape details from the plain console output.
   
   === [4.6] Changes to the APIs of native tasks related to compilation, linking and installation
   
   Many tasks related to compiling, linking and installing native libraries and applications have been converted to the Provider API so that they support <<lazy_configuration.adoc#lazy_configuration,lazy configuration>>.
   This conversion has introduced some breaking changes to the APIs of the tasks so that they match the conventions of the Provider API.
   
   The following tasks have been changed:
   
   link:{groovyDslPath}#[AbstractLinkTask] and its subclasses::
    * `getDestinationDir()` was replaced by `getDestinationDirectory()`.
    * `getBinaryFile()`, `getOutputFile()` was replaced by `getLinkedFile()`.
    * `setOutputFile(File)` was removed. Use `Property.set()` instead.
    * `setOutputFile(Provider)` was removed. Use `Property.set()` instead.
    * `getTargetPlatform()` was changed to return a `Property`.
    * `setTargetPlatform(NativePlatform)` was removed. Use `Property.set()` instead.
    * `getToolChain()` was changed to return a `Property`.
    * `setToolChain(NativeToolChain)` was removed. Use `Property.set()` instead.
   
   link:{groovyDslPath}#[CreateStaticLibrary]::
    * `getOutputFile()` was changed to return a `Property`.
    * `setOutputFile(File)` was removed. Use `Property.set()` instead.
    * `setOutputFile(Provider)` was removed. Use `Property.set()` instead.
    * `getTargetPlatform()` was changed to return a `Property`.
    * `setTargetPlatform(NativePlatform)` was removed. Use `Property.set()` instead.
    * `getToolChain()` was changed to return a `Property`.
    * `setToolChain(NativeToolChain)` was removed. Use `Property.set()` instead.
    * `getStaticLibArgs()` was changed to return a `ListProperty`.
    * `setStaticLibArgs(List)` was removed. Use `ListProperty.set()` instead.
   
   link:{groovyDslPath}#[InstallExecutable]::
    * `getSourceFile()` was replaced by `getExecutableFile()`.
    * `getPlatform()` was replaced by `getTargetPlatform()`.
    * `setTargetPlatform(NativePlatform)` was removed. Use `Property.set()` instead.
    * `getToolChain()` was changed to return a `Property`.
    * `setToolChain(NativeToolChain)` was removed. Use `Property.set()` instead.
   
   The following have also seen similar changes:
   
    * link:{groovyDslPath}#[Assemble]
    * link:{groovyDslPath}#[WindowsResourceCompile]
    * link:{javadocPath}#[StripSymbols]
    * link:{javadocPath}#[ExtractSymbols]
    * link:{javadocPath}#[SwiftCompile]
    * link:{javadocPath}#[LinkMachOBundle]
   
   === [4.6] Visual Studio integration only supports a single solution file for all components of a build
   
   link:{groovyDslPath}#[VisualStudioExtension] no longer has a `solutions` property.
   Instead, you configure a single solution via link:{groovyDslPath}#[VisualStudioRootExtension] in the root project, like so:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle
   [source, groovy]
   ----
   model {
       visualStudio {
           solution {
               solutionFile.location = "vs/${name}.sln"
           }
       }
   }
   ----
   =====
   ====
   
   In addition, there are no longer individual tasks to generate the solution files for each component, but rather a single `visualStudio` task that generates a solution file that encompasses all components in the build.
   
   === [4.5] `HttpBuildCache` no longer follows redirects
   
   When connecting to an HTTP build cache backend via `HttpBuildCache`, Gradle does not follow redirects any more, treating them as errors instead.
   Getting a redirect from the build cache backend is mostly a configuration error  using an "http" URL instead of "https" for example  and has negative effects on performance.
   
   === [4.4] Third-party dependency upgrades
   
   This version includes several upgrades of third-party dependencies:
   
    * jackson: 2.6.6 -> 2.8.9
    * plexus-utils: 2.0.6 -> 2.1
    * xercesImpl: 2.9.1 -> 2.11.0
    * bsh: 2.0b4 -> 2.0b6
    * bouncycastle: 1.57 -> 1.58
   
   This fix the following security issues:
   
    * http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-7525[CVE-2017-7525] (critical)
    * SONATYPE-2017-0359 (critical)
    * SONATYPE-2017-0355 (critical)
    * SONATYPE-2017-0398 (critical)
    * https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-4002[CVE-2013-4002] (critical)
    * https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-2510[CVE-2016-2510] (severe)
    * SONATYPE-2016-0397 (severe)
    * https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2625[CVE-2009-2625] (severe)
    * SONATYPE-2017-0348 (severe)
   
   Gradle does not expose public APIs for these 3rd-party dependencies, but those who customize Gradle will want to be aware.

/docs/userguide/releases/upgrading/upgrading_version_5.adoc
===========================================================

.. code-block::

   = Upgrading your build from Gradle 5.x to 6.0
   
   This chapter provides the information you need to migrate your Gradle 5.x builds to Gradle 6.0.
   For migrating from Gradle 4.x, complete the <<upgrading_version_4.adoc#upgrading_version_4, 4.x to 5.0 guide>> first.
   
   We recommend the following steps for all users:
   
   . Try running `gradle help --scan` and view the https://gradle.com/enterprise/releases/2018.4/#identify-usages-of-deprecated-gradle-functionality[deprecations view] of the generated build scan.
   +
   image::deprecations.png[Deprecations View of a Gradle Build Scan]
   +
   This is so that you can see any deprecation warnings that apply to your build.
   +
   Alternatively, you can run `gradle help --warning-mode=all` to see the deprecations in the console, though it may not report as much detailed information.
   . Update your plugins.
   +
   Some plugins will break with this new version of Gradle, for example because they use internal APIs that have been removed or changed.
   The previous step will help you identify potential problems by issuing deprecation warnings when a plugin does try to use a deprecated part of the API.
   +
   . Run `gradle wrapper --gradle-version 6.0` to update the project to 6.0.
   . Try to run the project and debug any errors using the <<troubleshooting.adoc#troubleshooting, Troubleshooting Guide>>.
   
   == Upgrading from 5.6 and earlier
   
   === Deprecations
   
   ==== Dependencies should no longer be declared using the `compile` and `runtime` configurations
   
   The usage of the `compile` and `runtime` configurations in the Java ecosystem plugins has been discouraged since https://docs.gradle.org/3.4/release-notes.html#the-java-library-plugin[Gradle 3.4].
   
   These configurations are used for compiling and running code from the `main` source set.
   Other sources sets create similar configurations (e.g. `testCompile` and `testRuntime` for the `test` source set), should not be used either.
   The `implementation`, `api`, `compileOnly` and `runtimeOnly` configurations should be used to declare dependencies and the `compileClasspath` and `runtimeClasspath` configurations to resolve dependencies.
   See <<java_library_plugin.adoc#sec:java_library_configurations_graph, the relationship of these configurations>>.
   
   ==== Legacy publication system is deprecated and replaced with the `*-publish` plugins
   
   The `uploadArchives` task and the `maven` plugin are deprecated.
   
   Users should migrate to the <<publishing_setup.adoc#publishing_components,publishing system>> of Gradle by using either the <<publishing_maven.adoc#publishing_maven,`maven-publish`>> or <<publishing_ivy.adoc#publishing_ivy,`ivy-publish`>> plugins.
   These plugins have been stable since Gradle 4.8.
   
   The publishing system is also the only way to ensure the publication of <<publishing_gradle_module_metadata.adoc#sec:understanding-gradle-module-md,Gradle Module Metadata>>.
   
   ==== Problems with tasks emit deprecation warnings
   
   When Gradle detects problems with task definitions (such as incorrectly defined inputs or outputs) it will show the following message on the console:
   
   ```
   Deprecated Gradle features were used in this build, making it incompatible with Gradle 7.0.
   Use '--warning-mode all' to show the individual deprecation warnings.
   See https://docs.gradle.org/6.0/userguide/command_line_interface.html#sec:command_line_warnings
   ```
   
   The deprecation warnings show up in https://scans.gradle.com/s/txrptciitl2ha/deprecations[build scans] for every build, regardless of the command-line switches used.
   
   When the build is executed with `--warning-mode all`, the individual warnings will be shown:
   
   ```
   > Task :myTask
   Property 'inputDirectory' is declared without normalization specified. Properties of cacheable work must declare their normalization via @PathSensitive, @Classpath or @CompileClasspath. Defaulting to PathSensitivity.ABSOLUTE. This behavior is scheduled to be removed in Gradle 7.0.
   Property 'outputFile' is not annotated with an input or output annotation. This behavior is scheduled to be removed in Gradle 7.0.
   ```
   
   If you own the code of the tasks in question, you can fix them by <<incremental_build.adoc#sec:task_input_validation, following the suggestions>>.
   You can also use `--stacktrace` to see where in the code each warning originates from.
   
   Otherwise, you'll need to report the problems to the maintainer of the relevant task or plugin.
   
   ==== Old API for incremental tasks, `IncrementalTaskInputs`, has been deprecated
   
   In Gradle 5.4 we introduced a new API for implementing <<custom_tasks.adoc#incremental_tasks,incremental tasks>>: link:{groovyDslPath}#[InputChanges]. The old API based on `IncrementalTaskInputs` has been deprecated.
   
   ==== Forced dependencies
   
   Forcing dependency versions using `force = true` on a first-level dependency has been deprecated.
   
   Force has both a semantic and ordering issue which can be avoided by using a <<rich_versions.adoc#rich-version-constraints, strict version constraint>>.
   
   ==== Search upwards related APIs in `StartParameter` have been deprecated
   
   In Gradle 5.0, we removed the `--no-search-upward` CLI parameter.
   
   The related APIs in `StartParameter` (like `isSearchUpwards()`) are now deprecated.
   
   ==== APIs `BuildListener.buildStarted` and `Gradle.buildStarted` have been deprecated
   
   These methods currently do not work as expected since the callbacks will never be called after the build has started.
   
   The methods are being deprecated to avoid confusion.
   
   ==== Implicit duplicate strategy for `Copy` or archive tasks has been deprecated
   
   Archive tasks `Tar` and `Zip` by default allow multiple entries for the same path to exist in the created archive.
   This can cause https://github.com/gradle/gradle/issues/9990["grossly invalid zip files" that can trigger zip bomb detection].
   
   To prevent this from happening accidentally, encountering duplicates while creating an archive now produces a deprecation message and will fail the build starting with Gradle 7.0.
   
   `Copy` tasks also happily copy multiple sources with the same relative path to the destination directory.
   This behavior has also been deprecated.
   
   If you want to allow duplicates, you can specify that explicitly:
   ```
   task archive(type: Zip) {
       duplicatesStrategy = DuplicatesStrategy.INCLUDE // allow duplicates
       ...
   }
   ```
   
   ==== Executing Gradle without a settings file has been deprecated
   
   A Gradle build is defined by a `settings.gradle[.kts]` file in the current or parent directory.
   Without a settings file, a Gradle build is undefined and will emit a deprecation warning.
   
   In Gradle 7.0, Gradle will only allow you to invoke the `init` task or diagnostic command line flags, such as `--version`, with undefined builds.
   
   ==== Calling `Project.afterEvaluate` on an evaluated project has been deprecated
   
   Once a project is evaluated, Gradle ignores all configuration passed to `Project#afterEvaluate` and emits a deprecation warning.
   This scenario will become an error in Gradle 7.0.
   
   ==== Deprecated plugins
   
   The following bundled plugins were never announced and will be removed in the next major release of Gradle:
   
   - `org.gradle.coffeescript-base`
   - `org.gradle.envjs`
   - `org.gradle.javascript-base`
   - `org.gradle.jshint`
   - `org.gradle.rhino`
   
   Some of these plugins may have replacements on the https://plugins.gradle.org/[Plugin Portal].
   
   === Potential breaking changes
   
   ==== Android Gradle Plugin 3.3 and earlier is no longer supported
   
   Gradle 6.0 supports Android Gradle Plugin versions 3.4 and later.
   
   ==== Build scan plugin 2.x is no longer supported
   
   For Gradle 6, usage of the build scan plugin must be replaced with the Develocity plugin.
   This also requires changing how the plugin is applied.
   Please see https://gradle.com/help/gradle-6-build-scan-plugin for more information.
   
   ==== Updates to bundled Gradle dependencies
   
   - Groovy has been updated to http://groovy-lang.org/changelogs/changelog-2.5.8.html[Groovy 2.5.8].
   - Kotlin has been updated to https://blog.jetbrains.com/kotlin/2019/08/kotlin-1-3-50-released/[Kotlin 1.3.50].
   - Ant has been updated to https://archive.apache.org/dist/ant/RELEASE-NOTES-1.10.7.html[Ant 1.10.7].
   
   ==== Updates to default integration versions
   
   - Checkstyle has been updated to https://checkstyle.org/releasenotes.html#Release_8.24[Checkstyle 8.24].
   - CodeNarc has been updated to https://github.com/CodeNarc/CodeNarc/blob/master/CHANGELOG.md#version-14---may-2019[CodeNarc 1.4].
   - PMD has been updated to https://pmd.github.io/latest/pmd_release_notes.html#28-july-2019---6170[PMD 6.17.0].
   - JaCoCo has been updated to http://www.jacoco.org/jacoco/trunk/doc/changes.html[0.8.5]. Contributed by link:https://github.com/Godin[Evgeny Mandrikov]
   
   ==== Changes to build and task names in composite builds
   
   Previously, Gradle used the name of the root project as the build name for an included build.
   Now, the name of the build's root directory is used and the root project name is not considered if different.
   A different name for the build can be specified if the build is being included via a settings file.
   
   ```kotlin
   includeBuild("some-other-build") {
       name = "another-name"
   }
   ```
   
   The previous behavior was problematic as it caused different names to be used at different times during the build.
   
   ==== buildSrc is now reserved as a project and subproject build name
   
   Previously, Gradle did not prevent using the name 락uildSrc for a subproject of a multi-project build or as the name of an included build.
   Now, this is not allowed.
   The name 락uildSrc is now reserved for the conventional buildSrc project that builds extra build logic.
   
   Typical use of buildSrc is unaffected by this change.
   You will only be affected if your settings file specifies `include("buildSrc")` or `includeBuild("buildSrc")`.
   
   ==== Scala Zinc compiler
   
   The Zinc compiler has been upgraded to version 1.3.0. Gradle no longer supports building for Scala 2.9.
   
   The minimum Zinc compiler supported by Gradle is 1.2.0 and the maximum tested version is 1.3.0.
   
   To make it easier to select the version of the Zinc compiler, you can now configure a `zincVersion` property:
   ```
   scala {
       zincVersion = "1.2.1"
   }
   ```
   
   Please remove any explicit dependencies you've added to the `zinc` configuration and use this property instead.
   If you try to use the `com.typesafe.zinc:zinc` dependency, Gradle will switch to the new Zinc implementation.
   
   ==== Changes to Build Cache
   
   ==== Local build cache is always a directory cache
   
   In the past, it was possible to use any build cache implementation as the `local` cache.
   This is no longer allowed as the local cache must always be a `DirectoryBuildCache`.
   
   Calls to `BuildCacheConfiguration.local(Class)` with anything other than `DirectoryBuildCache` as the type will fail the build.
   Calling these methods with the `DirectoryBuildCache` type will produce a deprecation warning.
   
   Use `getLocal()` and `local(Action)` instead.
   
   ==== Failing to pack or unpack cached results will now fail the build
   
   In the past, when Gradle encountered a problem while packing the results of a cached task, Gradle would ignore the problem and continue running the build.
   
   When encountering a corrupt cached artifact, Gradle would remove whatever was already unpacked and re-execute the task to make sure the build had a chance to succeed.
   
   While this behavior was intended to make a build successful, this had the adverse effect of hiding problems and led to reduced cache performance.
   
   In Gradle 6.0, both pack and unpack errors will cause the build to fail, so that these problems will be surfaced more easily.
   
   ==== buildSrc projects automatically use build cache configuration
   
   Previously, in order to use the build cache for the buildSrc build you needed to duplicate your build cache config in the buildSrc build.
   Now, it automatically uses the build cache configuration defined by the top level settings script.
   
   ==== Changes to Dependency Management
   
   ==== Gradle Module Metadata is always published
   
   Officially introduced in Gradle 5.3, https://blog.gradle.org/gradle-metadata-1.0[Gradle Module Metadata] was created to solve many of the problems that have plagued dependency management for years, in particular, but not exclusively, in the Java ecosystem.
   
   With Gradle 6.0, Gradle Module Metadata is enabled by default.
   
   This means, if you are publishing libraries with Gradle and using the <<publishing_maven.adoc#publishing_maven,maven-publish>> or <<publishing_ivy.adoc#publishing_ivy,ivy-publish>> plugin, the Gradle Module Metadata file is always published *in addition* to traditional metadata.
   
   The traditional metadata file will contain a marker so that Gradle knows that there is additional metadata to consume.
   
   ==== Gradle Module Metadata has stricter validation
   
   The following rules are verified when publishing Gradle Module Metadata:
   
   * Variant names must be unique,
   * Each variant must have at least <<variant_attributes.adoc#variant_attributes,one attribute>>,
   * Two variants cannot have the <<variant_model.adoc#understanding-variant-selection,exact same attributes and capabilities>>,
   * If there are dependencies, at least one, across all variants, must carry <<rich_versions.adoc#rich-version-constraints,version information>>.
   
   These are documented in the link:https://github.com/gradle/gradle/blob/master/platforms/documentation/docs/src/docs/design/gradle-module-metadata-latest-specification.md[specification] as well.
   
   ==== Maven or Ivy repositories are no longer queried for artifacts without metadata by default
   
   If Gradle fails to locate the metadata file (`.pom` or `ivy.xml`) of a module in a repository defined in the `repositories { }` section, it now assumes that the module does not exist in that repository.
   
   For dynamic versions, the `maven-metadata.xml` for the corresponding module needs to be present in a Maven repository.
   
   Previously, Gradle would also look for a default artifact (`.jar`).
   This behavior often caused a large number of unnecessary requests when using multiple repositories that slowed builds down.
   
   You can opt into the old behavior for selected repositories by adding the `artifact()` <<declaring_repositories.adoc#sec:supported_metadata_sources,metadata source>>.
   
   ==== Changing the pom `packaging` property no longer changes the artifact extension
   
   Previously, if the pom packaging was not _jar_, _ejb_, _bundle_ or _maven-plugin_, the extension of the main artifact published to a Maven repository was changed during publishing to match the pom packaging.
   
   This behavior led to broken Gradle Module Metadata and was difficult to understand due to handling of different packaging types.
   
   Build authors can change the artifact name when the artifact is created to obtain the same result as before  e.g. by setting `jar.archiveExtension.set(pomPackaging)` explicitly.
   
   ==== An `ivy.xml` published for Java libraries contains more information
   
   A number of fixes were made to produce more correct `ivy.xml` metadata in the `ivy-publish` plugin.
   
   As a consequence, the internal structure of the `ivy.xml` file has changed. The `runtime` configuration now contains more information, which corresponds to the _runtimeElements_ variant of a Java library.
   The `default` configuration should yield the same result as before.
   
   In general, users are advised to migrate from `ivy.xml` to the new Gradle Module Metadata format.
   
   ==== Changes to Plugins and Build scripts
   
   ==== Classes from `buildSrc` are no longer visible to settings scripts
   
   Previously, the buildSrc project was built before applying the project's settings script and its classes were visible within the script.
   Now, buildSrc is built after the settings script and its classes are not visible to it.
   The buildSrc classes remain visible to project build scripts and script plugins.
   
   Custom logic can be used from a settings script by <<tutorial_using_tasks.adoc#sec:build_script_external_dependencies, declaring external dependencies>>.
   
   ==== The `pluginManagement` block in settings scripts is now isolated
   
   Previously, any `pluginManagement {}` blocks inside a settings script were executed during the normal execution of the script.
   
   Now, they are executed earlier in a similar manner to `buildscript {}` or `plugins {}`.
   This means that code inside such a block cannot reference anything declared elsewhere in the script.
   
   This change has been made so that `pluginManagement` configuration can also be applied when resolving plugins for the settings script itself.
   
   ==== Plugins and classes loaded in settings scripts are visible to project scripts and `buildSrc`
   
   Previously, any classes added to the a settings script by using `buildscript {}` were not visible outside of the script.
   Now, they are visible to all of the project build scripts.
   
   They are also visible to the `buildSrc` build script and its settings script.
   
   This change has been made so that plugins applied to the settings script can contribute logic to the entire build.
   
   ==== Plugin validation changes
   
   - The `validateTaskProperties` task is now deprecated, use `validatePlugins` instead.
     The new name better reflects the fact that it also validates artifact transform parameters and other non-property definitions.
   - The `ValidateTaskProperties` type is replaced by `ValidatePlugins`.
   - The `setClasses()` method is now removed. Use `getClasses().setFrom()` instead.
   - The `setClasspath()` method is also removed. use `getClasspath().setFrom()` instead.
   - The link:{javadocPath}#[failOnWarning] option is now enabled by default.
   - The following task validation errors now fail the build at runtime and are promoted to errors for link:{javadocPath}#[ValidatePlugins]:
     * A task property is annotated with a property annotation not allowed for tasks, like `@InputArtifact`.
   
   ==== Changes to Kotlin DSL
   
   ==== Using the `embedded-kotlin` plugin now requires a repository
   
   Just like when using the `kotlin-dsl` plugin, it is now required to declare a repository where Kotlin dependencies can be found if you apply the `embedded-kotlin` plugin.
   
   ```kotlin
   plugins {
       `embedded-kotlin`
   }
   
   repositories {
       mavenCentral()
   }
   ```
   
   ==== Kotlin DSL IDE support now requires Kotlin IntelliJ Plugin >= 1.3.50
   
   With Kotlin IntelliJ plugin versions prior to 1.3.50, Kotlin DSL scripts will be wrongly highlighted when the _Gradle JVM_ is set to a version different from the one in _Project SDK_.
   Simply upgrade your IDE plugin to a version >= 1.3.50 to restore the correct Kotlin DSL script highlighting behavior.
   
   ==== Kotlin DSL script base types no longer extend `Project`, `Settings` or `Gradle`
   
   In previous versions, Kotlin DSL scripts were compiled to classes that implemented one of the three core Gradle configuration interfaces in order to implicitly expose their APIs to scripts. `org.gradle.api.Project` for project scripts, `org.gradle.api.initialization.Settings` for settings scripts and `org.gradle.api.invocation.Gradle` for init scripts.
   
   Having the script instance implement the core Gradle interface of the model object it was supposed to configure was convenient because it made the model object API immediately available to the body of the script but it was also a lie that could cause all sorts of trouble whenever the script itself was used in place of the model object, a project script **was not** a proper `Project` instance just because it implemented the core `Project` interface and the same was true for settings and init scripts.
   
   In 6.0 all Kotlin DSL scripts are compiled to classes that implement the newly introduced `org.gradle.kotlin.dsl.KotlinScript` interface and the corresponding model objects are now available as _implicit receivers_ in the body of the scripts. In other words, a project script behaves as if the body of the script is enclosed within a `with(project) { ... }` block, a settings script as if the body of the script is enclosed within a `with(settings) { ... }` block and an init script as if the body of the script is enclosed within a `with(gradle) { ... }` block. This implies the corresponding model object is also available as a property in the body of the script, the `project` property for project scripts, the `settings` property for settings scripts and the `gradle` property for init scripts.
   
   As part of the change, the `SettingsScriptApi` interface is no longer implemented by settings scripts and the `InitScriptApi` interface is no longer implemented by init scripts. They should be replaced with the corresponding model object interfaces, `Settings` and `Gradle`.
   
   ==== Miscellaneous
   
   ==== Javadoc and Groovydoc don't include timestamps by default
   
   Timestamps in the generated documentation have very limited practical use, however they make it impossible to have repeatable documentation builds.
   Therefore, the `Javadoc` and `Groovydoc` tasks are now configured to not include timestamps by default any more.
   
   ==== User provided 'config_loc' properties are ignored by Checkstyle
   
   Gradle always uses `configDirectory` as the value for 'config_loc' when running Checkstyle.
   
   ==== New Tooling API progress event
   
   In Gradle 6.0, we introduced a new progress event (link:{javadocPath}#[org.gradle.tooling.events.test.TestOutputEvent]) to expose the output of test execution.
   This new event breaks the convention of having a `StartEvent`-`FinishEvent` pair to express progress.
   `TaskOutputEvent` is a simple `ProgressEvent`.
   
   ==== Changes to the task container behavior
   
   The following deprecated methods on the task container now result in errors:
   
   - `TaskContainer.add()`
   - `TaskContainer.addAll()`
   - `TaskContainer.remove()`
   - `TaskContainer.removeAll()`
   - `TaskContainer.retainAll()`
   - `TaskContainer.clear()`
   - `TaskContainer.iterator().remove()`
   
   Additionally, the following deprecated functionality now results in an error:
   
   - Replacing a task that has already been realized.
   - Replacing a registered (unrealized) task with an incompatible type. A compatible type is the same type or a sub-type of the registered type.
   - Replacing a task that has never been registered.
   
   ==== Replaced and Removed APIs
   
   ==== Methods on `DefaultTask` and `ProjectLayout` replaced with `ObjectFactory`
   
   Use `ObjectFactory.fileProperty()` instead of the following methods that are now removed:
   
   - `DefaultTask.newInputFile()`
   - `DefaultTask.newOutputFile()`
   - `ProjectLayout.fileProperty()`
   
   Use `ObjectFactory.directoryProperty()` instead of the following methods that are now removed:
   
   - `DefaultTask.newInputDirectory()`
   - `DefaultTask.newOutputDirectory()`
   - `ProjectLayout.directoryProperty()`
   
   ==== Annotation `@Nullable` has been removed
   
   The `org.gradle.api.Nullable` annotation type has been removed. Use `javax.annotation.Nullable` from JSR-305 instead.
   
   ==== The FindBugs plugin has been removed
   
   The deprecated FindBugs plugin has been removed.
   As an alternative, you can use the link:https://plugins.gradle.org/plugin/com.github.spotbugs[SpotBugs plugin] from the link:https://plugins.gradle.org/search?term=spotbugs[Gradle Plugin Portal].
   
   ==== The JDepend plugin has been removed
   
   The deprecated JDepend plugin has been removed.
   There are a number of community-provided plugins for code and architecture analysis available on the link:https://plugins.gradle.org[Gradle Plugin Portal].
   
   ==== The OSGI plugin has been removed
   
   The deprecated OSGI plugin has been removed.
   There are a number of community-provided OSGI plugins available on the link:https://plugins.gradle.org/search?term=osgi[Gradle Plugin Portal].
   
   ==== The announce and build-announcements plugins have been removed
   
   The deprecated announce and build-announcements plugins have been removed.
   There are a number of community-provided plugins for sending out notifications available on the link:https://plugins.gradle.org[Gradle Plugin Portal].
   
   ==== The Compare Gradle Builds plugin has been removed
   
   The deprecated Compare Gradle Builds plugin has been removed.
   Please use https://scans.gradle.com/[build scans] for build analysis and comparison.
   
   ==== The Play plugins have been removed
   
   The deprecated Play plugin has been removed.
   An external replacement, the link:https://gradle.github.io/playframework[Play Framework plugin], is available from the plugin portal.
   
   ==== Method `AbstractCompile.compile()` method has been removed
   
   The abstract method `compile()` is no longer declared by `AbstractCompile`.
   
   Tasks extending `AbstractCompile` can implement their own `@TaskAction` method with the name of their choosing.
   
   They are also free to add a method annotated with `@TaskAction` using an `InputChanges` parameter without having to implement a parameter-less one as well.
   
   ==== Other Deprecated Behaviors and APIs
   
   * The `org.gradle.util.internal.GUtil.savePropertiesNoDateComment` has been removed. There is no public replacement for this internal method.
   * The deprecated class `org.gradle.api.tasks.compile.CompilerArgumentProvider` has been removed.
     Use link:{javadocPath}#[org.gradle.process.CommandLineArgumentProvider] instead.
   * The deprecated class `org.gradle.api.ConventionProperty` has been removed.
     Use link:{javadocPath}#[Providers] instead of convention properties.
   * The deprecated class `org.gradle.reporting.DurationFormatter` has been removed.
   * The bridge method `org.gradle.api.tasks.TaskInputs.property(String name, @Nullable Object value)` returning `TaskInputs` has been removed.
     A plugin using the method must be compiled with Gradle 4.3 to work on Gradle 6.0.
   * The following setters have been removed from `JacocoReportBase`:
   ** link:{groovyDslPath}#[executionData] - use `getExecutionData().setFrom()` instead.
   ** link:{groovyDslPath}#[sourceDirectories] - use `getSourceDirectories().setFrom()` instead.
   ** link:{groovyDslPath}#[classDirectories] - use `getClassDirectories().setFrom()` instead.
   ** link:{groovyDslPath}#[additionalClassDirs] - use `getAdditionalClassDirs().setFrom()` instead.
   ** link:{groovyDslPath}#[additionalSourceDirs] - use `getAdditionalSourceDirs().setFrom()` instead.
   * The `append` property on `JacocoTaskExtension` has been removed.
     `append` is now always configured to be true for the Jacoco agent.
   * The `configureDefaultOutputPathForJacocoMerge` method on `JacocoPlugin` has been removed.
     The method was never meant to be public.
   * File paths in link:{javadocPath}#[deployment descriptor file name] for the ear plugin are not allowed any more.
     Use a simple name, like `application.xml`, instead.
   * The `org.gradle.testfixtures.ProjectBuilder` constructor has been removed. Please use `ProjectBuilder.builder()` instead.
   * When <<groovy_plugin.adoc#sec:incremental_groovy_compilation,incremental Groovy compilation>> is enabled, a wrong configuration of the source roots or enabling Java annotation for Groovy now fails the build.
     Disable incremental Groovy compilation when you want to compile in those cases.
   * `ComponentSelectionRule` no longer can inject the metadata or ivy descriptor.
     Use the methods on the <<dynamic_versions.adoc#sec:component_selection_rules,`ComponentSelection` parameter>> instead.
   * Declaring an <<custom_tasks.adoc#incremental_tasks,incremental task>> without declaring outputs is now an error.
     Declare file outputs or use link:{javadocPath}#[TaskOutputs.upToDateWhen()] instead.
   * The `getEffectiveAnnotationProcessorPath()` method is removed from the `JavaCompile` and `ScalaCompile` tasks.
   * Changing the value of a task property with type `Property<T>` after the task has started execution now results in an error.
   * The `isLegacyLayout()` method is removed from `SourceSetOutput`.
   * The map returned by `TaskInputs.getProperties()` is now unmodifiable.
     Trying to modify it will result in an `UnsupportedOperationException` being thrown.
   * There are slight changes in the incubating <<dependency_capability_conflict.adoc#sub:selecting-between-candidates,capabilities resolution>> API, which has been introduced in 5.6, to also allow variant selection based on variant name
   
   == Upgrading from 5.5 and earlier
   
   === Deprecations
   
   ==== Changing the contents of `ConfigurableFileCollection` task properties after task starts execution
   
   When a task property has type `ConfigurableFileCollection`, then the file collection referenced by the property will ignore changes made to the contents of the collection once the task starts execution.
   This has two benefits.
   Firstly, this prevents accidental changes to the property value during task execution which can cause Gradle up-to-date checks and build cache lookup using different values to those used by the task action.
   Secondly, this improves performance as Gradle can calculate the value once and cache the result.
   
   This will become an error in Gradle 6.0.
   
   ==== Creating `SignOperation` instances
   
   Creating `SignOperation` instances directly is now deprecated. Instead, the methods of `SigningExtension` should be used to create these instances.
   
   This will become an error in Gradle 6.0.
   
   ==== Declaring an incremental task without outputs
   
   Declaring an <<custom_tasks.adoc#incremental_tasks,incremental task>> without declaring outputs is now deprecated.
   Declare file outputs or use link:{javadocPath}#[TaskOutputs.upToDateWhen()] instead.
   
   This will become an error in Gradle 6.0.
   
   ==== Method `WorkerExecutor.submit()` is deprecated
   
   The `WorkerExecutor.submit()` method is now deprecated.
   The new `noIsolation()`, `classLoaderIsolation()` and `processIsolation()` methods should now be used to submit work.
   See <<worker_api.adoc#tasks_parallel_worker,the section on the Worker API>> for more information on using these methods.
   
   `WorkerExecutor.submit()` will be removed in Gradle 8.0.
   
   === Potential breaking changes
   
   ==== Task dependencies are honored for task `@Input` properties whose value is a `Property`
   
   Previously, task dependencies would be ignored for task `@Input` properties of type `Property<T>`.
   These are now honored, so that it is possible to attach a task output property to a task `@Input` property.
   
   This may introduce unexpected cycles in the task dependency graph, where the value of an output property is mapped to produce a value for an input property.
   
   ==== Declaring task dependencies using a file `Provider` that does not represent a task output
   
   Previously, it was possible to pass `Task.dependsOn()` a `Provider<File>`, `Provider<RegularFile>` or `Provider<Directory>` instance that did not represent a task output.
   These providers would be silently ignored.
   
   This is now an error because Gradle does not know how to build files that are not task outputs.
   
   *Note* that it is still possible to pass `Task.dependsOn()` a `Provider` that returns a file and that represents a task output, for example `myTask.dependsOn(jar.archiveFile)` or `myTask.dependsOn(taskProvider.flatMap { it.outputDirectory })`, when the `Provider` is an annotated `@OutputFile` or `@OutputDirectory` property of a task.
   
   ==== Setting `Property` value to `null` uses the property convention
   
   Previously, calling `Property.set(null)` would always reset the value of the property to 'not defined'.
   Now, the convention that is associated with the property using the `convention()` method will be used to determine the value of the property.
   
   ==== Enhanced validation of names for `publishing.publications` and `publishing.repositories`
   
   The repository and publication names are used to construct task names for publishing. It was possible to supply a name that would result in an invalid task name.
   Names for publications and repositories are now restricted to `[A-Za-z0-9_\\-.]+`.
   
   ==== Restricted Worker API classloader and process classpath
   
   Gradle now prevents internal dependencies (like Guava) from leaking into the classpath used by Worker API actions.
   This fixes link:https://github.com/gradle/gradle/issues/3698[an issue] where a worker needs to use a dependency that is also used by Gradle internally.
   
   In previous releases, it was possible to rely on these leaked classes. Plugins relying on this behavior will now fail.
   To fix the plugin, the worker should explicitly include all required dependencies in its classpath.
   
   ==== Default PMD version upgraded to 6.15.0
   
   <<pmd_plugin#pmd_plugin, The PMD plugin>> has been upgraded to use link:https://pmd.github.io/pmd-6.15.0/pmd_release_notes.html[PMD version 6.15.0] instead of 6.8.0 by default.
   
   Contributed by link:https://github.com/wreulicke[wreulicke]
   
   ==== Configuration copies have unique names
   
   Previously, all copies of a configuration always had the name `<OriginConfigurationName>Copy`.
   Now when creating multiple copies, each will have a unique name by adding an index starting from the second copy. (e.g. `CompileOnlyCopy2`)
   
   ==== Changed classpath filtering for Eclipse
   
   Gradle 5.6 no longer supplies custom classpath attributes in the Eclipse model.
   Instead, it provides the attributes for link:https://www.eclipse.org/eclipse/news/4.8/jdt.php#jdt-test-sources[Eclipse test sources].
   This change requires Buildship version 3.1.1 or later.
   
   ==== Embedded Kotlin upgraded to 1.3.41
   
   Gradle Kotlin DSL scripts and Gradle Plugins authored using the `kotlin-dsl` plugin are now compiled using Kotlin 1.3.41.
   
   Please see the Kotlin link:https://blog.jetbrains.com/kotlin/2019/06/kotlin-1-3-40-released/[blog post] and link:https://github.com/JetBrains/kotlin/blob/1.3.40/ChangeLog.md[changelog] for more information about the included changes.
   
   The minimum supported Kotlin Gradle Plugin version is now 1.2.31. Previously it was 1.2.21.
   
   ==== Automatic capability conflict resolution
   
   Previous versions of Gradle would automatically select, in case of capability conflicts, the module which has the highest capability version.
   Starting from 5.6, this is an opt-in behavior that can be activated using:
   
   ```
   configurations.all {
      resolutionStrategy.capabilitiesResolution.all { selectHighestVersion() }
   }
   ```
   
   See <<dependency_capability_conflict.adoc#sub:capabilities, the capabilities section of the documentation>> for more options.
   
   ==== File removal operations don't follow symlinked directories
   
   When Gradle has to remove the output files of a task for various reasons, it will not follow symlinked directories.
   The symlink itself will be deleted, but the contents of the linked directory will stay intact.
   
   === Disabled debug argument parsing in JavaExec
   
   Gradle 5.6 introduced a new DSL element (`JavaForkOptions.debugOptions(Action<JavaDebugOptions>)`) to configure debug properties for forked Java processes.
   Due to this change, Gradle no longer parses debug-related JVM arguments. Consequently, `JavaForkOptions.getDebu()` no longer returns `true` if the `-Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005` or the `-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005` argument is specified to the process.
   
   === Scala 2.9 and Zinc compiler
   
   Gradle no longer supports building applications using Scala 2.9.
   
   == Upgrading from 5.4 and earlier
   
   === Deprecations
   
   ==== Play
   
   The built-in <<play_plugin.adoc#play_plugin, Play plugin>> has been deprecated and will be replaced by a new link:https://gradle.github.io/playframework[Play Framework plugin] available from the plugin portal.
   
   ==== Build Comparison
   
   The _build comparison_ plugin has been deprecated and will be removed in the next major version of Gradle.
   
   link:https://gradle.com/build-scans[Build scans] show much deeper insights into your build and you can use link:https://gradle.com/develocity[Develocity] to directly compare two build's build-scans.
   
   === Potential breaking changes
   
   ==== User supplied Eclipse project names may be ignored on conflict
   
   Project names configured via link:{javadocPath}#[`EclipseProject.setName(...)`] were honored by Gradle and Buildship in all cases, even when the names caused conflicts and import/synchronization errors.
   
   Gradle can now deduplicate these names if they conflict with other project names in an Eclipse workspace.
   This may lead to different Eclipse project names for projects with user-specified names.
   
   The upcoming 3.1.1 version of Buildship is required to take advantage of this behavior.
   
   Contributed by link:https://github.com/fraenkelc[Christian Fr칛nkel]
   
   ==== Default JaCoCo version upgraded to 0.8.4
   
   <<jacoco_plugin#jacoco_plugin, The JaCoCo plugin>> has been upgraded to use link:http://www.jacoco.org/jacoco/trunk/doc/changes.html[JaCoCo version 0.8.4] instead of 0.8.3 by default.
   
   Contributed by link:https://github.com/Godin[Evgeny Mandrikov]
   
   ==== Embedded Ant version upgraded to 1.9.14
   
   The version of Ant distributed with Gradle has been upgraded to link:https://archive.apache.org/dist/ant/RELEASE-NOTES-1.9.14.html[1.9.14] from 1.9.13.
   
   ==== Type `DependencyHandler` now statically exposes `ExtensionAware`
   
   This affects Kotlin DSL build scripts that make use of `ExtensionAware` extension members such as the `extra` properties accessor inside the `dependencies {}` block.
   The receiver for those members will no longer be the enclosing `Project` instance but the `dependencies` object itself, the innermost `ExtensionAware` conforming receiver.
   In order to address `Project` extra properties inside `dependencies {}` the receiver must be explicitly qualified i.e. `project.extra` instead of just `extra`.
   Affected extensions also include `the<T>()` and `configure<T>(T.() -> Unit)`.
   
   ==== Improved processing of dependency excludes
   
   Previous versions of Gradle could, in some complex dependency graphs, have a wrong result or a randomized dependency order when lots of excludes were present.
   To mitigate this, the algorithm that computes exclusions has been rewritten.
   In some rare cases this may cause some differences in resolution, due to the correctness changes.
   
   ==== Improved classpath separation for worker processes
   
   The system classpath for worker daemons started by the <<worker_api.adoc#worker_api, Worker API>> when using `PROCESS` isolation has been reduced to a minimum set of Gradle infrastructure.
   User code is still segregated into a separate classloader to isolate it from the Gradle runtime.
   This should be a transparent change for tasks using the worker API, but previous versions of Gradle mixed user code and Gradle internals in the worker process.
   Worker actions that rely on things like the `java.class.path` system property may be affected, since `java.class.path` now represents only the classpath of the Gradle internals.
   
   == Upgrading from 5.3 and earlier
   
   === Deprecations
   
   ==== Using custom local build cache implementations
   
   Using a custom build cache implementation for the local build cache is now deprecated.
   The only allowed type will be `DirectoryBuildCache` going forward.
   There is no change in the support for using custom build cache implementations as the remote build cache.
   
   === Potential breaking changes
   
   ==== Use HTTPS when configuring Google Hosted Libraries via `googleApis()`
   
   The Google Hosted Libraries URL accessible via `JavaScriptRepositoriesExtension#GOOGLE_APIS_REPO_URL` was changed to use the HTTPS protocol.
   The change also affect the Ivy repository configured via `googleApis()`.
   
   == Upgrading from 5.2 and earlier
   
   === Potential breaking changes
   
   ==== Bug fixes in platform resolution
   
   There was a bug from Gradle 5.0 to 5.2.1 (included) where enforced platforms would potentially include dependencies instead of constraints.
   This would happen whenever a POM file defined both dependencies and "constraints" (via `<dependencyManagement>`) and that you used `enforcedPlatform`.
   Gradle 5.3 fixes this bug, meaning that you might have differences in the resolution result if you relied on this broken behavior.
   Similarly, Gradle 5.3 will no longer try to download jars for `platform` and `enforcedPlatform` dependencies (as they should only bring in constraints).
   
   ==== Automatic target JVM version
   
   If you apply any of the Java plugins, Gradle will now do its best to select dependencies which match the target compatibility of the module being compiled.
   What it means, in practice, is that if you have module A built for Java 8, and module B built for Java 8, then there's no change.
   However if B is built for Java 9+, then it's not binary compatible anymore, and Gradle would complain with an error message like the following:
   
   ```
   Unable to find a matching variant of project :producer:
     - Variant 'apiElements' capability test:producer:unspecified:
         - Provides org.gradle.dependency.bundling 'external'
         - Required org.gradle.jvm.version '8' and found incompatible value '9'.
         - Required org.gradle.usage 'java-api' and found value 'java-api-jars'.
     - Variant 'runtimeElements' capability test:producer:unspecified:
         - Provides org.gradle.dependency.bundling 'external'
         - Required org.gradle.jvm.version '8' and found incompatible value '9'.
         - Required org.gradle.usage 'java-api' and found value 'java-runtime-jars'.
   ```
   
   In general, this is a sign that your project is misconfigured and that your dependencies are not compatible.
   However, there are cases where you still may want to do this, for example when only a _subset_ of classes of your module actually need the Java 9 dependencies, and are not intended to be used on earlier releases.
   Java in general doesn't encourage you to do this (you should split your module instead), but if you face this problem, you can workaround by disabling this new behavior on the consumer side:
   
   ```
   java {
      disableAutoTargetJvm()
   }
   ```
   
   ==== Bug fix in Maven / Ivy interoperability with dependency substitution
   
   If you have a Maven dependency pointing to an Ivy dependency where the `default` configuration dependencies do not match the `compile` + `runtime` + `master` ones
   _and_ that Ivy dependency was substituted (using a `resolutionStrategy.force`, `resolutionStrategy.eachDependency` or `resolutionStrategy.dependencySubstitution`)
   then this fix will impact you.
   The legacy behaviour of Gradle, prior to 5.0, was still in place instead of being replaced by the changes introduced by improved pom support.
   
   ==== Delete operations correctly handle symbolic links on Windows
   
   Gradle no longer ignores the `followSymlink` option on Windows for the `clean` task, all `Delete` tasks, and `project.delete {}` operations in the presence of junction points and symbolic links.
   
   ==== Fix in publication of additional artifacts
   
   In previous Gradle versions, additional artifacts registered at the project level were not published by `maven-publish` or `ivy-publish` unless they were also added as artifacts in the publication configuration.
   
   With Gradle 5.3, these artifacts are now properly accounted for and published.
   
   This means that artifacts that are registered both on the project _and_ the publication, Ivy or Maven, will cause publication to fail since it will create duplicate entries.
   The fix is to remove these artifacts from the publication configuration.
   
   == Upgrading from 5.1 and earlier
   
   === Potential breaking changes
   
   none
   
   == Upgrading from 5.0 and earlier
   
   === Deprecations
   
   Follow the API links to learn how to deal with these deprecations (if no extra information is provided here):
   
    * Setters for `classes` and `classpath` on `org.gradle.plugin.devel.tasks.ValidateTaskProperties` (removed)
   
    * There should not be setters for lazy properties like link:{javadocPath}#[`ConfigurableFileCollection`].  Use `setFrom` instead. For example,
   ----
       validateTaskProperties.getClasses().setFrom(fileCollection)
       validateTaskProperties.getClasspath().setFrom(fileCollection)
   ----
   
   === Potential breaking changes
   
   The following changes were not previously deprecated:
   
   ==== Signing API changes
   Input and output files of `Sign` tasks are now tracked via `Signature.getToSign()` and `Signature.getFile()`, respectively.
   
   ==== Collection properties default to empty collection
   
   In Gradle 5.0, the collection property instances created using `ObjectFactory` would have no value defined, requiring plugin authors to explicitly set an initial value. This proved to be awkward and error prone so `ObjectFactory` now returns instances with an empty collection as their initial value.
   
   ==== Worker API: working directory of a worker can no longer be set
   
   Since JDK 11 no longer supports changing the working directory of a running process, setting the working directory of a worker via its fork options is now prohibited.
   All workers now use the same working directory to enable reuse.
   Please pass files and directories as arguments instead. See examples in the <<worker_api.adoc#worker_api, Worker API documentation>>.
   
   ==== Changes to native linking tasks
   
   To expand our idiomatic <<lazy_configuration.adoc#lazy_configuration, Provider API>> practices, the install name property from `org.gradle.nativeplatform.tasks.LinkSharedLibrary` is affected by this change.
   
   - `getInstallName()` was changed to return a `Property`.
   - `setInstallName(String)` was removed. Use `Property.set()` instead.
   
   ==== Passing arguments to Windows Resource Compiler
   
   To expand our idiomatic <<lazy_configuration.adoc#lazy_configuration, Provider API>> practices, the `WindowsResourceCompile` task has been converted to use the Provider API.
   
   Passing additional compiler arguments now follow the same pattern as the `CppCompile` and other tasks.
   
   ==== Copied configuration no longer shares a list of `beforeResolve` actions with original
   
   The list of `beforeResolve` actions are no longer shared between a copied configuration and the original.
   Instead, a copied configuration receives a copy of the `beforeResolve` actions at the time the copy is made.
   Any `beforeResolve` actions added after copying (to either configuration) will not be shared between the original and the copy.
   This may break plugins that relied on the previous behaviour.
   
   ==== Changes to incubating POM customization types
   
   - The type of `MavenPomDeveloper.properties` has changed from `Property<Map<String, String>>` to `MapProperty<String, String>`.
   - The type of `MavenPomContributor.properties` has changed from `Property<Map<String, String>>` to `MapProperty<String, String>`.
   
   ==== Changes to specifying operating system for native projects
   
   The incubating `operatingSystems` property on native components has been replaced with the link:{javadocPath}#[targetMachines] property.
   
   ==== Changes for archive tasks (`Zip`, `Jar`, `War`, `Ear`, `Tar`)
   
   ===== Change in behavior for tasks extending `AbstractArchiveTask`
   
   The `AbstractArchiveTask` has several new properties using the <<lazy_configuration.adoc#lazy_configuration_reference,Provider API>>.
   Plugins that extend these types and override methods from the base class may no longer behave the same way.
   Internally, `AbstractArchiveTask` prefers the new properties and methods like `getArchiveName()` are fa칞ades over the new properties.
   
   If your plugin/build only uses these types (and does not extend them), nothing has changed.

/docs/userguide/releases/upgrading/upgrading_version_6.adoc
===========================================================

.. code-block::

   = Upgrading your build from Gradle 6.x to 7.0
   
   This chapter provides the information you need to migrate your Gradle 6.x builds to Gradle 7.0.
   For migrating from Gradle 5.x or earlier, complete the <<upgrading_version_5.adoc#upgrading_version_5, older migration guide>> first.
   
   We recommend the following steps for all users:
   
   . Try running `gradle help --scan` and view the https://gradle.com/enterprise/releases/2018.4/#identify-usages-of-deprecated-gradle-functionality[deprecations view] of the generated build scan.
   +
   image::deprecations.png[Deprecations View of a Gradle Build Scan]
   +
   This is so that you can see any deprecation warnings that apply to your build.
   +
   Alternatively, you can run `gradle help --warning-mode=all` to see the deprecations in the console, though it may not report as much detailed information.
   . Update your plugins.
   +
   Some plugins will break with this new version of Gradle, for example because they use internal APIs that have been removed or changed.
   The previous step will help you identify potential problems by issuing deprecation warnings when a plugin does try to use a deprecated part of the API.
   +
   . Run `gradle wrapper --gradle-version 7.0` to update the project to 7.0.
   . Try to run the project and debug any errors using the <<troubleshooting.adoc#troubleshooting, Troubleshooting Guide>>.
   
   == Upgrading from 6.9 and earlier
   
   === Changes in the IDE integration
   
   ==== Changes in the IDEA model
   
   The `getGeneratedSourceDirectories()` and `getGeneratedTestDirectories()` methods are removed from the `IdeaContentRoot` interface.
   Clients should replace these invocations with `getSourceDirectories()` and `getTestDirectories()` and use the `isGenerated()` method on the returned instances.
   
   === Dependency locking now defaults to a single file per project
   
   The format of the dependency lockfile has been changed and as a consequence there is only one file per project instead of one file per configuration per project.
   This change only affects _writing_ lock files.
   Gradle remains capable of _loading_ lock state saved in the older format.
   
   Head over to <<dependency_locking.adoc#migrate_single_lockfile,the documentation>> to learn how to migrate to the new format.
   The migration can be performed per configuration and does not have to be done in a single step.
   Gradle will automatically clean up previous lock files when migrating them over to the new file format.
   
   === Gradle Module Metadata is now reproducible by default
   
   The `buildId` field will not be populated by default to ensure that the produced metadata file remains unchanged when no build inputs are changed.
   Users can still opt in to have this unique identifier part of the produced metadata if they want to, see <<publishing_gradle_module_metadata.adoc#sub:gmm-reproducible,the documentation>>.
   
   === The `jcenter()` convenience method is now deprecated
   
   JFrog link:https://jfrog.com/blog/into-the-sunset-bintray-jcenter-gocenter-and-chartcenter[announced] the sunset of the JCenter repository in February 2021. https://blog.gradle.org/jcenter-shutdown[Many Gradle builds] rely on JCenter for project dependencies.
   
   No new packages or versions are published to JCenter, but JFrog says they will keep JCenter running in a read-only state indefinitely.
   We recommend that you consider <<declaring_repositories.adoc#declaring-repositories,using>> `mavenCentral()`, `google()` or a private `maven` repository instead.
   
   Gradle emits a deprecation warning when `jcenter()` is used as a repository and this method is scheduled to be removed in Gradle 8.0.
   
   === Potential breaking changes
   
   ==== Updates to bundled Gradle dependencies
   
   - Kotlin has been updated to https://kotlinlang.org/docs/reference/whatsnew1430.html[Kotlin 1.4.31].
   - Groovy has been updated to https://groovy-lang.org/releasenotes/groovy-3.0.html[Groovy 3.0.7].
   
   ==== Changes to Groovy and Groovy DSL
   
   Due to the update to the next major version of Groovy, you may experience minor issues when upgrading to Gradle 7.0.
   
   The new version of Groovy has a stricter parser that fails to compile code that may have been accepted in previous Groovy versions.
   If you encounter syntax errors, check the https://groovy.apache.org/#reporting-issues[Groovy issue tracker] and https://blogs.apache.org/groovy/entry/groovy-3-highlights[Groovy 3 release highlights].
   
   https://issues.apache.org/jira/browse/GROOVY-9936[Some very specific regressions] have already been fixed in the next minor version of Groovy.
   
   ===== Groovy modularization
   
   Gradle no longer embeds a copy of `groovy-all` that bundles all Groovy modules into a single jar--only the most important modules are distributed in the Gradle distribution.
   
   The `localGroovy()` dependency will include these Groovy modules:
   
   - `groovy`
   - `groovy-ant`
   - `groovy-astbuilder`
   - `groovy-console`
   - `groovy-datetime`
   - `groovy-dateutil`
   - `groovy-groovydoc`
   - `groovy-json`
   - `groovy-nio`
   - `groovy-sql`
   - `groovy-templates`
   - `groovy-test`
   - `groovy-xml`
   
   But the following Groovy modules are *not* included:
   
   - `groovy-cli-picocli`
   - `groovy-docgenerator`
   - `groovy-groovysh`
   - `groovy-jmx`
   - `groovy-jsr223`
   - `groovy-macro`
   - `groovy-servlet`
   - `groovy-swing`
   - `groovy-test-junit5`
   - `groovy-testng`
   
   You can pull these dependencies into your build like any other external dependency.
   
   ===== Building Gradle plugins with Groovy 3
   
   Plugins built with Gradle 7.0 will now have Groovy 3 on their classpath when using `gradleApi()` or `localGroovy()`.
   
   NOTE: If you use https://spockframework.org/[Spock] to test your plugins, you will need to use Spock 2.x. There are no compatible versions of Spock 1.x and Groovy 3.
   
   ```
   dependencies {
       // Ensure you use the Groovy 3.x variant
       testImplementation('org.spockframework:spock-core:2.0-groovy-3.0') {
           exclude group: 'org.codehaus.groovy'
       }
   }
   
   // Spock 2 is based on JUnit Platform which needs to be enabled explicitly.
   tasks.withType(Test).configureEach {
       useJUnitPlatform()
   }
   ```
   
   ===== Performance
   
   Depending on the number of subprojects and Groovy DSL build scripts, you may notice a performance regression when compiling build scripts for the first time or when changes are made to the build script's classpath.
   This is due to the slower performance of the Groovy 3 parser, but the Groovy team is aware of the issue and trying to mitigate the regression.
   
   In general, we are also looking at how we can improve the performance of build script compilation for both Groovy DSL and Kotlin DSL.
   
   ===== Encountering 'Could not find method X for arguments Y on DefaultDependencyHandler'
   
   While the following error initially looks like a compile error, it is actually due to the fact that specific `Configuration`s have been removed.
   Please refer to <<sec:configuration_removal>> for more details.
   
   ```
   Could not find method testCompile() for arguments [DefaultExternalModuleDependency{group='org.junit', name='junit-bom', version='5.7.0', configuration='default'}] on object of type org.gradle.api.internal.artifacts.dsl.dependencies.DefaultDependencyHandler.
   ```
   
   ==== Updates to default tool integration versions
   
   - PMD has been updated to https://github.com/pmd/pmd/releases/tag/pmd_releases%2F6.31.0[PMD 6.31.0].
   - Groovy and GroovyDoc have been updated to https://groovy-lang.org/releasenotes/groovy-3.0.html[Groovy 3.0.7].
   
   ==== Removal of `compile` and `runtime` configurations
   
   Since its inception, Gradle provided the `compile` and `runtime` configurations to declare dependencies.
   These however did not support a fine grained scoping of dependencies. Hence, better replacements were introduced in Gradle 3.4:
   
   - The `implementation` configuration should be used to declare dependencies which are _implementation details_ of a library: they are not visible to consumers of the library during compilation time.
   - The `api` configuration, available only if you apply the `java-library` plugin, should be used to declare dependencies which are part of the API of a library, that need to be exposed to consumers at compilation time.
   
   In Gradle 7, both the `compile` and `runtime` configurations are removed.
   Therefore, you have to migrate to the `implementation` and `api` configurations above.
   If you are still using the `java` plugin for a Java library, you will need to apply the `java-library` plugin instead.
   
   
   .Common configuration upgrades
   |===
   |Removed Configuration | New Configuration
   
   |`compile`
   |`api` or `implementation`
   
   |`runtime`
   |`runtimeOnly`
   
   |`testRuntime`
   |`testRuntimeOnly`
   
   |`testCompile`
   |`testImplementation`
   
   
   |`<sourceSet>Runtime`
   |`<sourceSet>RuntimeOnly`
   
   |`<sourceSet>Compile`
   |`<sourceSet>Implementation`
   |===
   
   You can find more details about the benefits of the new configurations and which one to use in place of `compile` and `runtime` by reading the <<java_library_plugin.adoc#java_library_plugin,Java Library plugin>> documentation.
   
   --
   When using the Groovy DSL, you need to watch out for a particular upgrade problem when dealing with the removed configurations.
   
   If you were creating custom configurations that extend one of the removed configurations, Gradle may silently create configurations that do not exist.
   
   This looks something like:
   ```
   configurations {
     // This silently creates a configuration called "runtime"
     myConf extendsFrom runtime
   }
   ```
   
   The result of dependency resolution for your custom configuration may not be the same as Gradle 6.x or before.
   You may notice missing dependencies or artifacts.
   --
   
   ==== Location of temporary project files for `ProjectBuilder`
   
   The `ProjectBuilder` API is used for inspecting Gradle builds in unit tests. This API used to create temporary project files under the system temporary directory as defined by `java.io.tmpdir`.
   
   The API now creates temporary project files under the `Test` task's temporary directory. This path is usually under the project build directory.
   This may cause test failures when the test expects particular file paths.
   
   If the test uses `ProjectBuilder.withProjectDir(...)`, it is unaffected.
   
   ==== Location of temporary files for TestKit tests
   
   Tests that use the <<test_kit#test_kit, TestKit>> API used to create temporary files under the system temporary directory as defined by `java.io.tmpdir`.
   These files were used to store copies of Gradle distributions or another test-only Gradle User Home.
   
   TestKit tests will now create temporary files under the `Test` task's temporary directory.
   This path is usually under the project build directory.
   This may cause test failures when the test expects particular file paths.
   
   If the test uses `GradleRunner.withTestKitDir(...)`, it is unaffected.
   
   ==== File system watching with TestKit on Windows
   
   The file system watching implementation on Windows adds a lock to the root project directory in order to watch for changes.
   This may cause errors when you try to delete the root project directory after running a build with TestKit.
   For example, tests that use TestKit together with JUnit's `@TempDir` extension, or the `TemporaryFolder` rule can run into this problem.
   To avoid problems with these file locks, `<<test_kit#test_kit,TestKit>>` disables file system watching for builds executed on Windows via `GradleRunner`.
   If you'd like to override the default behavior, you can enable file system watching by passing `--watch-fs` to `GradleRunner.withArguments()`.
   
   ==== Removal of the legacy `maven` plugin
   
   The `maven` plugin has been removed.
   You should use the `maven-publish` plugin instead.
   
   Please refer to the <<publishing_maven.adoc#publishing_maven, documentation of the Maven Publish plugin>> for more details.
   
   ==== Removal of the `uploadArchives` task
   
   The `uploadArchives` task was used in combination with the legacy Ivy or Maven publishing mechanisms.
   It has been removed in Gradle 7.
   You should migrate to the `maven-publish` or `ivy-publish` plugin instead.
   
   Please refer to the <<publishing_maven.adoc#publishing_maven, documentation of the Maven Publish plugin>> for publishing on Maven repositories.
   Please refer to the <<publishing_ivy.adoc#publishing_ivy, documentation of the Ivy Publish plugin>> for publishing on Ivy repositories.
   
   ==== Changes in dependency version sorting
   
   In the context of dependency version sorting, a `-SNAPSHOT` version is now considered to be right before a final release but after any `-RC` version.
   More special version suffixes are also taken into account.
   This brings the Gradle algorithm closer to the Maven one for well-known version suffixes.
   
   Have a look at <<single_versions.adoc#single-version-declarations,the documentation>> for all the rules Gradle applies.
   
   ==== Removal of Play Framework plugins
   
   The deprecated Play plugins have been removed.
   An external replacement, the link:https://gradle.github.io/playframework[Play Framework plugin], is available from the plugin portal.
   
   === Removal of deprecated JVM plugins
   
   These unmaintained alternative JVM plugins have been removed:
   `java-lang`, `scala-lang`, `junit-test-suite`, `jvm-component`, `jvm-resources`.
   
   Please use the stable <<java_library_plugin.adoc#java_library_plugin,Java Library>> and <<scala_plugin.adoc#scala_plugin,Scala>> plugins instead.
   
   ==== Removal of experimental JavaScript plugins
   
   The following plugins for experimental JavaScript integration are now removed from the distribution:
   `coffeescript-base`, `envjs`, `javascript-base`, `jshint`, `rhino`.
   
   If you used these plugins despite their experimental nature, you may find suitable replacements in the https://plugins.gradle.org/[Plugin Portal].
   
   ==== Configuring the layout of an Ivy repository
   
   The `layout` method taking a configuration block has been removed and is replaced by link:{groovyDslPath}#[patternLayout].
   
   ==== Executing a Gradle build without a settings file is now an error
   
   A Gradle build is defined by its `settings.gradle(.kts)` file found in the current or parent directory.
   Without a settings file, a Gradle build is undefined and Gradle produces an error when attempting to execute tasks.
   
   To fix this error, <<organizing_gradle_projects.adoc#sec:settings_file,create a `settings.gradle(.kts)` file>> for the build.
   
   Exceptions to this are invoking Gradle with the `init` task or using diagnostic command line flags, such as `--version`.
   
   ==== Calling Project.afterEvaluate() after project evaluation is now an error
   
   Gradle 6.x warns users about the wrong behavior and ignores the target action in this scenario.
   Starting from 7.0 the same case will produce an error. Plugins and build scripts should be adjusted to call `afterEvaluate` only at configuration time.
   If you have such a build failure and the related `afterEvaluate` statement is declared in your build sources then you can simply delete it.
   If `afterEvaluate` is declared in a plugin then report the issue to the plugin maintainers.
   
   === Modifying file collections after values finalized is now an error
   
   Calling any mutator methods (i.e. `clear()`, `add()`, `remove()`, etc.) on `ConfigurableFileCollection` after the stored value calculated throws an exception.
   Users and plugin authors should adjust their code such that all configuration on `ConfigurableFileCollection` happens during configuration time, before the values are read.
   
   ==== Removal of `ProjectLayout#configurableFiles`
   
   Please use `ObjectFactory#fileCollection()` instead.
   
   ==== Removal of `BasePluginConvention.libsDir` and `BasePluginConvention.distsDir`
   
   Please use the `libsDirectory` and `distsDirectory` properties instead.
   
   ==== Removal of `UnableToDeleteFileException`
   
   Existing usages should be replaced with `RuntimeException`.
   
   ==== Properties removed in Checkstyle and PMD plugins
   
   * The `configDir` getters and setters have been removed from the Checkstle task and extension.
   Use the `configDirectory` property instead.
   * The `rulePriority` getter and setter have been removed from the Pmd task and extension.
   Use the `rulesMinimumPriority` property instead.
   
   ==== Removal of `baseName` property in `distribution` plugin
   
   The `getBaseName()` and `setBaseName()` methods were removed from the `Distribution` class. Clients should replace the usages with the `distributionBaseName` property.
   
   ==== Using `AbstractTask`
   
   Registering a task with the `AbstractTask` type or with a type extending `AbstractTask` was deprecated in Gradle 6.5 and is now an error in Gradle 7.0.
   You can use link:{javadocPath}#[DefaultTask] instead.
   
   ==== Removal of `BuildListener.buildStarted(Gradle)`
   
   `BuildListener.buildStarted(Gradle)` was deprecated in Gradle 6.0 and is now removed in Gradle 7.0.
   Please use link:{javadocPath}#[BuildListener.beforeSettings(Settings)] instead.
   
   ==== Removal of unused `StartParameter` APIs
   
   The following APIs, which were not usable via command line options anymore since Gradle 5.0, are now removed:
   `StartParameter.useEmptySettings()`, `StartParameter.isUseEmptySettings()`, `StartParameter.setSearchUpwards(boolean)` and `StartParameter.isSearchUpwards()`.
   
   ==== Removal of searching for settings files in 'master' directories
   
   Gradle no longer supports discovering the settings file in a directory named `master` in a sibling directory.
   If your build still uses this deprecated feature, consider refactoring the build to have the root directory match the physical root of the project hierarchy.
   You can find more information about <<multi_project_builds.adoc#multi_project_builds,how to structure a Gradle build>> or a <<structuring_software_products.adoc#structure_large_projects,composition of builds>> in the user manual.
   Alternatively, you can still run tasks in builds like this by invoking the build from the `master` directory only using a
   <<intro_multi_project_builds.adoc#sec:executing_tasks_by_fully_qualified_name,fully qualified path to the task>>.
   
   ==== `modularity.inferModulePath` defaults to 'true'
   
   <<java_library_plugin.adoc#sec:java_library_modular,Compiling>>,
   <<java_testing.adoc#sec:java_testing_modular,testing>> and
   <<application_plugin.adoc#sec:application_modular,executing>>
   now works automatically for any source set that defines a module by containing a `module-info.java` file.
   Usually, this is the behavior you need.
   If this is causing issues in cases you manually configure the module path, or use a 3rd party plugin for it, you can still opt out of this by setting `modularity.inferModulePath` to `false` on the java extension or individual tasks.
   
   ==== Removal of `ValidateTaskProperties`
   
   The `ValidateTaskProperties` task has been removed and replaced by the link:{javadocPath}#[ValidatePlugins] task.
   
   ==== Removal of `ImmutableFileCollection`
   
   The `ImmutableFileCollection` type has been removed.
   Use the link:{javadocPath}#[factory method] instead.
   A handle to the project layout can be obtained via link:{javadocPath}#[Project.layout].
   
   ==== Removal of `ComponentSelectionReason.getDescription`
   
   The method `ComponentSelectionReason.getDescription` has been removed.
   It is replaced by `ComponentSelectionReason.getDescriptions` which returns a list of `ComponentSelectionDescriptor`, each having a `getDescription`.
   
   ==== Removal of domain object collection constructors
   
   The following deprecated constructors were removed:
   
   - DefaultNamedDomainObjectList(Class, Instantiator, Namer)
   - DefaultNamedDomainObjectSet(Class, Instantiator)
   - DefaultPolymorphicDomainObjectContainer(Class, Instantiator)
   - FactoryNamedDomainObjectContainer(Class, Instantiator, NamedDomainObjectFactory)
   
   ==== Removal of arbitrary local cache configuration
   
   The local build cache configuration now needs to be done via link:{javadocPath}#[BuildCacheConfiguration.local()].
   
   ==== Removal of DefaultVersionSelectorScheme constructor
   
   This internal API was used in plugins, amongst other the https://github.com/nebula-plugins[Nebula plugins], and was deprecated in the Gradle 5.x timeline and is now removed.
   Latest plugins version should no longer reference it.
   
   ==== Setting the `config_loc` config property on the `checkstyle` plugin is now an error
   
   The `checkstyle` plugin now fails for the following configuration
   ```
   checkstyle {
       configProperties['config_loc'] = file("path/to/checkstyle-config-dir")
   }
   ```
   Builds should declare the checkstyle configuration with the `checkstyle` block:
   ```
   checkstyle {
       configDirectory = file("path/to/checkstyle-config-dir")
   }
   ```
   
   ==== Querying the mapped value of a provider before the producer has completed is now an error
   
   Gradle 6.x warns users about the wrong behavior and then returns a possibly incorrect provider value.
   Starting with 7.0 the same case will produce an error.
   Plugins and build scripts should be adjusted to query the mapped value of a provider, for example a task output property, after the task has completed.
   
   ==== Task validation problems are now errors
   
   Gradle 6.0 started warning about problems with task definitions (such as incorrectly defined inputs or outputs).
   For Gradle 7.0, those warnings are now errors and will fail the build.
   
   ==== Change in behavior when there's a strict version conflict with a local project
   
   Previous Gradle releases had an inconsistent behavior in regard to conflict resolution in a particular configuration:
   - your project declares a strict dependency on a published module (for example, `com.mycompany:some-module:1.2!!`, where `1.2!!` is the short hand notation for a strict dependency on 1.2)
   - your build actually provides `com.mycompany:some-module` in a higher version
   
   Previous Gradle releases would succeed, selecting the project dependency despite the strict constraint.
   Starting from Gradle 7, this will trigger a dependency resolution failure.
   
   See https://github.com/gradle/gradle/issues/16706[this issue] for more context.
   
   === Deprecations
   
   ==== Missing dependencies between tasks
   
   Having a task which produces an output in a location and another task consuming that location by referring to it as an input without the consumer task depending on the producer task has been deprecated.
   A fix for this problem is to <<incremental_build.adoc#sec:link_output_dir_to_input_files,add a dependency from the consumer to the producer>>.
   
   ==== Duplicates strategy
   
   Gradle 7 now fails when a copy operation (or any operation which uses a `org.gradle.api.file.CopySpec`) encounters a duplicate entry, and that the duplicates strategy isn't set.
   Please look at link:{javadocPath}#[the CopySpec docs] for details.
   
   == Upgrading from 6.8 and earlier
   
   No upgrade notes from 6.8 to 6.9, as 6.9 only contains bug fixes.
   
   == Upgrading from 6.7 and earlier
   
   === Potential breaking changes
   
   ==== Toolchain API is now marked as @NonNull
   
   The API supporting the Java Toolchain feature in `org.gradle.jvm.toolchain` is now marked as `@NonNull`.
   
   This may impact Kotlin consumers where the return types of APIs are no longer nullable.
   
   ==== Updates to default tool integration versions
   
   - JaCoCo has been updated to http://www.jacoco.org/jacoco/trunk/doc/changes.html[0.8.6].
   - Checkstyle has been updated to https://checkstyle.sourceforge.io/releasenotes.html#Release_8.37[Checkstyle 8.37].
   - CodeNarc has been updated to https://github.com/CodeNarc/CodeNarc/blob/v2.0.0/CHANGELOG.md[CodeNarc 2.0.0].
   
   ==== Updates to bundled Gradle dependencies
   
   - Kotlin has been updated to https://blog.jetbrains.com/kotlin/2020/08/kotlin-1-4-released-with-a-focus-on-quality-and-performance/[Kotlin 1.4.20].
     Note that Gradle scripts are still using the Kotlin 1.3 language.
   - Apache Ant has been updated to 1.10.9 to fix https://github.com/gradle/gradle/security/advisories/GHSA-j45w-qrgf-25vm[CVE-2020-11979]
   
   ==== Projects imported into Eclipse now include custom source set classpaths
   
   Previously, projects imported by Eclipse only included dependencies for the main and test source sets.
   The compile and runtime classpaths of custom source sets were ignored.
   
   Since Gradle 6.8, projects imported into Eclipse include the compile and runtime classpath for every source set defined by the build.
   
   ==== SourceTask is no longer sensitive to empty directories
   
   Previously, empty directories would be taken into account during up-to-date checks and build cache key calculations for the sources declared in `SourceTask`.
   This meant that a source tree that contained an empty directory and an otherwise identical source tree that did not contain the empty directory would be considered different sources, even if the task would produce the same outputs.
   In Gradle 6.8, `SourceTask` now ignores empty directories during doing up-to-date checks and build cache key calculations.
   In the vast majority of cases, this is the desired behavior, but it is possible that a task may extend `SourceTask` but also produce different outputs when empty directories are present in the sources.
   For tasks where this is a concern, you can expose a separate property without the `@IgnoreEmptyDirectories` annotation in order to capture those changes:
   
   ```
   @InputFiles
   @SkipWhenEmpty
   @PathSensitive(PathSensitivity.ABSOLUTE)
   public FileTree getSourcesWithEmptyDirectories() {
       return super.getSource()
   }
   ```
   
   ==== Changes to publications
   
   Publishing a component which has a dependency on an enforced platform now triggers a validation error, preventing accidental publishing of bad metadata:
   enforced platforms use cases should be limited to applications, not things which can be consumed from another library or an application.
   
   If, for some reason, you still want to publish components with dependencies on enforced platforms, you can disable the validation following the <<publishing_setup.adoc#sec:suppressing_validation_errors, documentation>>.
   
   ==== Changing default excludes during the execution phase
   
   Gradle's file trees apply some default exclude patterns for convenience  the same defaults as Ant in fact.
   See the <<working_with_files.adoc#sec:file_trees,user manual>> for more information.
   Sometimes, Ant's default excludes prove problematic, for example when you want to include the `.gitignore` in an archive file.
   
   Changing Gradle's default excludes during the execution phase can lead to correctness problems with up-to-date checks.
   As a consequence, you are only allowed to change Gradle's default excludes in the settings script, see the <<working_with_files.adoc#sec:change_default_excludes,user manual>> for an example.
   
   === Deprecations
   
   ==== Referencing tasks from included builds
   
   Direct references to tasks from included builds in `mustRunAfter`, `shouldRunAfter` and `finalizedBy` task methods have been deprecated.
   Task ordering using `mustRunAfter` and `shouldRunAfter` as well as finalizers specified by `finalizedBy` should be used for task ordering within a build.
   If you happen to have cross-build task ordering defined using above mentioned methods, consider restructuring such builds and decoupling them from one another.
   
   ==== Searching for settings files in 'master' directories
   
   Gradle will emit a deprecation warning when your build relies on finding the settings file in a directory named `master` in a sibling directory.
   
   If your build uses this feature, consider refactoring the build to have the root directory match the physical root of the project hierarchy.
   
   Alternatively, you can still run tasks in builds like this by invoking the build from the `master` directory only using a
   <<intro_multi_project_builds.adoc#sec:executing_tasks_by_fully_qualified_name,fully qualified path to the task>>.
   
   ==== Using method `NamedDomainObjectContainer<T>.invoke(kotlin.Function1)`
   
   Gradle Kotlin DSL extensions have been changed to favor Gradle's `Action<T>` type over Kotlin function types.
   
   While the change should be transparent to Kotlin clients, Java clients calling Kotlin DSL extensions need to be updated to use the `Action<T>` APIs.
   
   == Upgrading from 6.6 and earlier
   
   === Potential breaking changes
   
   ==== buildSrc can now see included builds from the root
   
   Previously, `buildSrc` was built in such a way that included builds were ignored from the root build.
   
   Since Gradle 6.7, `buildSrc` can see any included build from the root build.
   This may cause dependencies to be substituted from an included build in `buildSrc`.
   This may also change the order in which some builds are executed if an included build is needed by `buildSrc`.
   
   ==== Updates to default tool integration versions
   
   - PMD has been updated to https://github.com/pmd/pmd/releases/tag/pmd_releases%2F6.26.0[PMD 6.26.0].
   - Checkstyle has been updated to https://checkstyle.sourceforge.io/releasenotes.html#Release_8.35[Checkstyle 8.35].
   - CodeNarc has been updated to https://github.com/CodeNarc/CodeNarc/blob/v1.6.1/CHANGELOG.md[CodeNarc 1.6.1].
   
   === Deprecations
   
   ==== Changing default excludes during the execution phase
   
   Gradle's file trees apply some default exclude patterns for convenience  the same defaults as Ant in fact.
   See the <<working_with_files.adoc#sec:file_trees,user manual>> for more information.
   Sometimes, Ant's default excludes prove problematic, for example when you want to include the `.gitignore` in an archive file.
   
   Changing Gradle's default excludes during the execution phase can lead to correctness problems with up-to-date checks, and is deprecated.
   You are only allowed to change Gradle's default excludes in the settings script, see the <<working_with_files.adoc#sec:change_default_excludes,user manual>> for an example.
   
   ==== Using a Configuration directly as a dependency
   
   Gradle allowed instances of `Configuration` to be used directly as dependencies:
   
   ```
   dependencies {
       implementation(configurations.myConfiguration)
   }
   ```
   
   This behavior is now deprecated as it is confusing: one could expect the "dependent configuration" to be resolved first and add the result of resolution as dependencies to the including configuration, which is not the case.
   The deprecated version can be replaced with the actual behavior, which is configuration inheritance:
   
   ```
   configurations.implementation.extendsFrom(configurations.myConfiguration)
   ```
   
   
   == Upgrading from 6.5 and earlier
   
   === Potential breaking changes
   
   ==== Updates to bundled Gradle dependencies
   
   - Ant has been updated to https://downloads.apache.org/ant/RELEASE-NOTES-1.10.8.html[1.10.8].
   - Groovy has been updated to https://groovy-lang.org/changelogs/changelog-2.5.12.html[Groovy 2.5.12].
   
   ==== Dependency substitutions and variant aware dependency resolution
   
   While adding support for expressing <<resolution_rules#sec:variant_aware_substitutions, variant support>> in dependency substitutions, a bug fix introduced a behaviour change that some builds may rely upon.
   Previously a substituted dependency would still use the <<variant_attributes#variant_attributes, attributes>> of the original selector instead of the ones from the replacement selector.
   
   With that change, existing substitutions around dependencies with richer selectors, such as for platform dependencies, will no longer work as they did.
   It becomes mandatory to define the variant aware part in the target selector.
   
   You can be affected by this change if you:
   
   * have dependencies on platforms, like `implementation platform("org:platform:1.0")`
   * _or_ if you specify attributes on dependencies,
   * _and_ you use <<resolution_rules#resolution_rules, resolution rules>> on these dependencies.
   
   See the <<resolution_rules#sec:variant_aware_substitutions, documentation>> for resolving issues if you are impacted.
   
   === Deprecations
   
   No deprecations were made in Gradle 6.6.
   
   == Upgrading from 6.4 and earlier
   
   === Potential breaking changes
   
   ==== Updates to bundled Gradle dependencies
   
   - Kotlin has been updated to https://github.com/JetBrains/kotlin/releases/tag/v1.3.72[Kotlin 1.3.72].
   - Groovy has been updated to https://groovy-lang.org/changelogs/changelog-2.5.11.html[Groovy 2.5.11].
   
   ==== Updates to default tool integration versions
   
   - PMD has been updated to https://github.com/pmd/pmd/releases/tag/pmd_releases%2F6.23.0[PMD 6.23.0].
   
   === Deprecations
   
   ==== Internal class AbstractTask is deprecated
   
   `AbstractTask` is an internal class which is visible on the public API, as a superclass of public type `DefaultTask`.
   `AbstractTask` will be removed in Gradle 7.0, and the following are deprecated in Gradle 6.5:
   
   - Registering a task whose type is `AbstractTask` or `TaskInternal`. You can remove the task type from the task registration and Gradle will use `DefaultTask` instead.
   - Registering a task whose type is a subclass of `AbstractTask` but not a subclass of `DefaultTask`. You can change the task type to extend `DefaultTask` instead.
   - Using the class `AbstractTask` from plugin code or build scripts. You can change the code to use `DefaultTask` instead.
   
   == Upgrading from 6.3 and earlier
   
   === Potential breaking changes
   
   ==== PMD plugin expects PMD 6.0.0 or higher by default
   
   Gradle 6.4 enabled incremental analysis by default.
   Incremental analysis is only available in PMD 6.0.0 or higher.
   If you want to use an older PMD version, you need to disable incremental analysis:
   
   ```
   pmd {
       incrementalAnalysis = false
   }
   ```
   
   ==== Changes in dependency locking
   
   With Gradle 6.4, the incubating API for <<dependency_locking#fine_tuning_dependency_locking_behaviour_with_lock_mode, dependency locking `LockMode`>> has changed.
   The value is now set via a `Property<LockMode>` instead of a direct setter.
   This means that the notation to set the value has to be updated for the Kotlin DSL:
   
   ```
   dependencyLocking {
       lockMode.set(LockMode.STRICT)
   }
   ```
   
   Users of the Groovy DSL should not be impacted as the notation `lockMode = LockMode.STRICT` remains valid.
   
   ==== Java versions in published metadata
   
   If a Java library is published with Gradle Module Metadata, the information which Java version it supports is encoded in the `org.gradle.jvm.version` attribute.
   By default, this attribute was set to what you configured in `java.targetCompatibility`.
   If that was not configured, it was set to the current Java version running Gradle.
   Changing the version of a particular compile task, e.g. `javaCompile.targetCompatibility` had no effect on that attribute, leading to wrong information if the attribute was not adjusted manually.
   This is now fixed and the attribute defaults to the setting of the compile task that is associated with the sources from which the published jar is built.
   
   ==== Ivy repositories with custom layouts
   
   Gradle versions from 6.0 to 6.3.x included could generate bad Gradle Module Metadata when publishing on an Ivy repository which had a custom repository layout.
   Starting from 6.4, Gradle will no longer publish Gradle Module Metadata if it detects that you are using a custom repository layout.
   
   ==== New properties may shadow variables in build scripts
   
   This release introduces some new properties -- `mainClass`, `mainModule`, `modularity` -- in different places.
   Since these are very generic names, there is a chance that you use one of them in your build scripts as variable name.
   A new property might then shadow one of your variables in an undesired way, leading to a build failure where the property is accessed instead of the local variable with the same name.
   You can fix it by renaming the corresponding variable in the build script.
   
   Affected is configuration code inside the `application {}` and `java {}` configuration blocks, inside a java execution setup with `project.javaexec {}`, and inside various task configurations
   (`JavaExec`, `CreateStartScripts`, `JavaCompile`, `Test`, `Javadoc`).
   
   ==== Updates to bundled Gradle dependencies
   
   - Kotlin has been updated to https://github.com/JetBrains/kotlin/releases/tag/v1.3.71[Kotlin 1.3.71].
   
   === Deprecations
   
   There were no deprecations between Gradle 6.3 and 6.4.
   
   == Upgrading from 6.2 and earlier
   
   === Potential breaking changes
   
   ==== Fewer dependencies available in IDEA
   
   Gradle no longer includes the annotation processor classpath as provided dependencies in IDEA.
   The dependencies IDEA sees at compile time are the same as what Gradle sees after resolving the compile classpath (configuration named `compileClasspath`).
   This prevents the leakage of annotation processor dependencies into the project's code.
   
   Before Gradle introduced <<java_plugin.adoc#sec:incremental_annotation_processing,incremental annotation processing support>>, IDEA required all annotation processors to be on the compilation classpath to be able to run annotation processing when compiling in IDEA.
   This is no longer necessary because Gradle has a separate <<java_plugin.adoc#tab:configurations,annotation processor classpath>>.
   The dependencies for annotation processors are not added to an IDEA module's classpath when a Gradle project with annotation processors is imported.
   
   ==== Updates to bundled Gradle dependencies
   
   - Kotlin has been updated to https://blog.jetbrains.com/kotlin/2020/03/kotlin-1-3-70-released/[Kotlin 1.3.70].
   - Groovy has been updated to http://groovy-lang.org/changelogs/changelog-2.5.10.html[Groovy 2.5.10].
   
   ==== Updates to default tool integration versions
   
   - PMD has been updated to https://pmd.github.io/pmd-6.21.0/pmd_release_notes.html#24-january-2020---6210[PMD 6.21.0].
   - CodeNarc has been updated to https://github.com/CodeNarc/CodeNarc/blob/v1.5/CHANGELOG.md#version-15----nov-2019[CodeNarc 1.5].
   
   ==== Rich console support removed for some 32-bit operating systems
   
   Gradle 6.3 does not support the <<command_line_interface.adoc#sec:rich_console, rich console>> for 32-bit Unix systems and for old FreeBSD versions (older than FreeBSD 10). Microsoft Windows 32-bit is unaffected.
   
   Gradle will continue building projects on 32-bit systems but will no longer show the rich console.
   
   === Deprecations
   
   ==== Using default and archives configurations
   
   Almost every Gradle project has the _default_ and _archives_ configurations which are added by the _base_ plugin.
   These configurations are no longer used in modern Gradle builds that use <<variant_model.adoc#understanding-variant-selection,variant aware dependency management>> and the <<publishing_setup.adoc#publishing_components,new publishing plugins>>.
   
   While the configurations will stay in Gradle for backwards compatibility for now, using them to declare dependencies or to resolve dependencies is now deprecated.
   
   Resolving these configurations was never an intended use case and only possible because in earlier Gradle versions _every_ configuration was resolvable.
   For declaring dependencies, please use the configurations provided by the plugins you use, for example by the <<java_library_plugin.adoc#sec:java_library_configurations_graph,Java Library plugin>>.
   
   == Upgrading from 6.1 and earlier
   
   === Potential breaking changes
   
   ==== Compile and runtime classpath now request library variants by default
   
   A classpath in a JVM project now explicitly requests the `org.gradle.category=library` attribute.
   This leads to clearer error messages if a certain library cannot be used.
   For example, when the library does not support the required Java version.
   The practical effect is that now all <<java_platform_plugin.adoc#sec:java_platform_consumption,platform dependencies>> have to be declared as such.
   Before, platform dependencies also worked, accidentally, when the `platform()` keyword was omitted for local platforms or platforms published with Gradle Module Metadata.
   
   ==== Properties from project root `gradle.properties` leaking into `buildSrc` and included builds
   
   There was a regression in Gradle 6.2 and Gradle 6.2.1 that caused Gradle properties set in the project root `gradle.properties` file to leak into the `buildSrc` build and any builds included by the root.
   
   This could cause your build to start failing if the `buildSrc` build or an included build suddenly found an unexpected or incompatible value for a property coming from the project root `gradle.properties` file.
   
   The regression has been fixed in Gradle 6.2.2.
   
   === Deprecations
   
   There were no deprecations between Gradle 6.1 and 6.2.
   
   == Upgrading from 6.0 and earlier
   
   === Deprecations
   
   ==== Querying a mapped output property of a task before the task has completed
   
   Querying the value of a mapped output property before the task has completed can cause strange build failures because it indicates stale or non-existent outputs may be used by mistake.
   This behavior is deprecated and will emit a deprecation warning. This will become an error in Gradle 7.0.
   
   The following example demonstrates this problem where the Producer's output file is parsed before the Producer executes:
   ```
   class Consumer extends DefaultTask {
       @Input
       final Property<Integer> threadPoolSize = ...
   }
   
   class Producer extends DefaultTask {
       @OutputFile
       final RegularFileProperty outputFile = ...
   }
   
   // threadPoolSize is read from the producer's outputFile
   consumer.threadPoolSize = producer.outputFile.map { it.text.toInteger() }
   
   // Emits deprecation warning
   println("thread pool size = " + consumer.threadPoolSize.get())
   ```
   
   Querying the value of `consumer.threadPoolSize` will produce a deprecation warning if done prior to `producer` completing, as the output file has not yet been generated.
   
   ==== Discontinued methods
   The following methods have been discontinued and should no longer be used. They will be removed in Gradle 7.0.
   
   - `BasePluginConvention.setProject(ProjectInternal)`
   - `BasePluginConvention.getProject()`
   - `StartParameter.useEmptySettings()`
   - `StartParameter.isUseEmptySettings()`
   
   ==== Alternative JVM plugins (a.k.a "Software Model")
   
   A set of alternative plugins for Java and Scala development were introduced in Gradle 2.x as an experiment based on the "software model".
   These plugins are now deprecated and will eventually be removed.
   If you are still using one of these old plugins (`java-lang`, `scala-lang`, `jvm-component`, `jvm-resources`, `junit-test-suite`) please consult the documentation on <<building_java_projects.adoc#building_java_projects,Building Java & JVM projects>> to determine which of the stable JVM plugins are appropriate for your project.
   
   === Potential breaking changes
   
   ==== `ProjectLayout` is no longer available to worker actions as a service
   
   In Gradle 6.0, the `ProjectLayout` service was made available to worker actions via service injection.
   This service allowed for mutable state to leak into a worker action and introduced a way for dependencies to go undeclared in the worker action.
   
   `ProjectLayout` has been removed from the available services.  Worker actions that were using `ProjectLayout` should switch to injecting the `projectDirectory` or `buildDirectory` as a parameter instead.
   
   ==== Updates to bundled Gradle dependencies
   
   - Kotlin has been updated to https://blog.jetbrains.com/kotlin/2019/11/kotlin-1-3-60-released/[Kotlin 1.3.61].
   
   ==== Updates to default tool integration versions
   
   - Checkstyle has been updated to https://checkstyle.org/releasenotes.html#Release_8.27[Checkstyle 8.27].
   - PMD has been updated to https://pmd.github.io/pmd-6.20.0/pmd_release_notes.html#29-november-2019---6200[PMD 6.20.0].
   
   ==== Publishing Spring Boot applications
   
   Starting from Gradle 6.2, Gradle performs a sanity check before uploading, to make sure you don't upload stale files (files produced by another build).
   This introduces a problem with Spring Boot applications which are uploaded using the `components.java` component:
   
   ```
   Artifact my-application-0.0.1-SNAPSHOT.jar wasn't produced by this build.
   ```
   
   This is caused by the fact that the main `jar` task is disabled by the Spring Boot application, and the component expects it to be present.
   Because the `bootJar` task uses the _same file_ as the main `jar` task by default, previous releases of Gradle would either:
   
   - publish a stale `bootJar` artifact
   - or fail if the `bootJar` task hasn't been called previously
   
   A workaround is to tell Gradle what to upload.
   If you want to upload the `bootJar`, then you need to configure the outgoing configurations to do this:
   
   ```
   configurations {
      [apiElements, runtimeElements].each {
          it.outgoing.artifacts.removeIf { it.buildDependencies.getDependencies(null).contains(jar) }
          it.outgoing.artifact(bootJar)
      }
   }
   ```
   
   Alternatively, you might want to re-enable the `jar` task, and add the `bootJar` with a different classifier.
   
   ```
   jar {
      enabled = true
   }
   
   bootJar {
      classifier = 'application'
   }
   ```

/docs/userguide/releases/upgrading/upgrading_version_7.adoc
===========================================================

.. code-block::

   = Upgrading your build from Gradle 7.x to 8.0
   
   This chapter provides the information you need to migrate your Gradle 7.x builds to Gradle 8.0.
   For migrating from Gradle 6.x or earlier, complete the  <<upgrading_version_6.adoc#upgrading_version_6, older migration guide>> first.
   
   We recommend the following steps for all users:
   
   . Try running `gradle help --scan` and view the https://gradle.com/enterprise/releases/2018.4/#identify-usages-of-deprecated-gradle-functionality[deprecations view] of the generated build scan.
   +
   image::deprecations.png[Deprecations View of a Gradle Build Scan]
   +
   This is so that you can see any deprecation warnings that apply to your build.
   +
   Alternatively, you can run `gradle help --warning-mode=all` to see the deprecations in the console, though it may not report as much detailed information.
   . Update your plugins.
   +
   Some plugins will break with this new version of Gradle, for example because they use internal APIs that have been removed or changed.
   The previous step will help you identify potential problems by issuing deprecation warnings when a plugin does try to use a deprecated part of the API.
   +
   . Run `gradle wrapper --gradle-version {gradleVersion}` to update the project to {gradleVersion}.
   . Try to run the project and debug any errors using the <<troubleshooting.adoc#troubleshooting, Troubleshooting Guide>>.
   
   == Upgrading from 7.6 and earlier
   
   === Warnings that are now errors
   
   ==== Referencing tasks in an included build with `finalizedBy`, `mustRunAfter` or `shouldRunAfter`
   
   Referencing tasks contained in an included build with any of the following methods now results in an execution time error:
   
   - `finalizedBy`
   - `mustRunAfter`
   - `shouldRunAfter`
   
   ==== Creating TAR trees from resources without backing files
   
   Creating a TAR tree from a resource with no backing file is no longer supported.
   Instead, convert the resource to a file and use `project.tarTree()` on the file.
   For more information, see <<tar_tree_no_backing_file>>.
   
   ==== Using invalid Java toolchain specifications
   
   Usage of invalid Java toolchain specifications is no longer supported.
   Related build errors can be avoided by making sure that language version is set on all toolchain specifications.
   See <<toolchains#sec:configuring_toolchain_specifications,user manual>> for more information.
   
   ==== Using automatic toolchain downloading without having a repository configured
   
   Automatic toolchain downloading without explicitly providing repositories to use is no longer supported.
   See <<toolchains#sub:download_repositories,user manual>> for more information.
   
   ==== Changing test framework after setting test framework options is now an error
   
   When configuring the built-in test task for Java, Groovy, and Scala projects, Gradle no longer allows you to
   change the test framework used by the `Test` task after configuring options.
   This was deprecated since it silently discarded configuration in some cases.
   
   The following code example now produces an error:
   ```
   test {
      options {
      }
   
      useJUnitPlatform()
   }
   ```
   Instead, you can:
   
   - set the test framework before configuring options
   - migrate to the <<jvm_test_suite_plugin#jvm_test_suite_plugin,JVM Test Suite Plugin>>
   ```
   test {
      // select test framework before configuring options
      useJUnitPlatform()
      options {
      }
   }
   ```
   
   Additionally, setting the test framework multiple times to the _same_ framework now accumulates any options that might be set on the framework.
   Previously, each time the framework was set, it would cause the framework options to be overwritten.
   
   The following code now results in both the "foo" and "bar" tags to be included for the `test` task:
   ```
   test {
      useJUnitPlatform {
           includeTags("foo")
      }
   }
   tasks.withType(Test).configureEach {
      // previously, this would overwrite the included tags to only include "bar"
      useJUnitPlatform {
           includeTags("bar")
      }
   }
   ```
   
   === Removed APIs
   
   ==== Legacy ArtifactTransform API
   
   The legacy `ArtifactTransform` API has been removed.
   For more information, see <<old_artifact_transforms_api>>.
   
   ==== Legacy IncrementalTaskInputs API
   
   The legacy `IncrementalTaskInputs` API has been removed.
   For more information, see <<incremental_task_inputs_deprecation>>.
   This change also affects Kotlin Gradle Plugin and Android Gradle Plugin.
   With Gradle 8.0 you should use Kotlin Gradle Plugin 1.6.10 or later and Android Gradle Plugin 7.3.0 with `android.experimental.legacyTransform.forceNonIncremental=true` property or later.
   
   ==== Legacy AntlrSourceVirtualDirectory API
   
   The legacy `AntlrSourceVirtualDirectory` API has been removed.
   This change affects the `antlr` plugin.
   In Gradle 8.0 and above, use the `AntlrSourceDirectorySet` source set extension instead.
   
   ==== JvmPluginsHelper
   
   A deprecated `configureDocumentationVariantWithArtifact` method of the `JvmPluginsHelper` class which did not require a `FileResolver` has been removed.
   This was an internal API, but may have been accessed by plugins.
   Supply a `FileResolver` to the overloaded version of this method instead.
   
   ==== Groovydoc API Cleanup
   
   The deprecated `isIncludePrivate` property of the `Groovydoc` task type has been removed.
   Use the `access` property along with the `GroovydocAccess#PRIVATE` constant instead.
   
   ==== JavaApplication API Cleanup
   
   The deprecated `mainClassName` property of the `JavaApplication` interface has been removed.
   Use the `mainClass` property instead.
   
   ==== DefaultDomainObjectSet API Cleanup
   
   The deprecated `DefaultDomainObjectSet(Class)` constructor has been removed.
   This was an internal API, but may have been used by plugins.
   
   ==== JacocoPluginExtension API Cleanup
   
   The deprecated `reportsDir` property of the `JacocoPluginExtension` has been removed.
   Use the `reportsDirectory` property instead.
   
   ==== DependencyInsightReportTask API Cleanup
   
   The deprecated `legacyShowSinglePathToDependnecy` property of the `DependencyInsightReportTask` task type has been removed.
   Use the `showSinglePathToDependency` property instead.
   
   ==== Report and TestReport API Cleanup
   
   The deprecated `destination`, and `enabled` properties of the `Report` type have been removed.
   Use the `outputLocation` and `required` properties instead.
   
   The deprecated `testResultDirs` property of the `TestReport` task type has been removed.
   Use the `testResults` property instead.
   
   ==== JacocoMerge Task Removed
   
   The deprecated `JacocoMerge` task type has been removed.
   The same functionality is also available on the `JacocoReport` task.
   
   ==== JavaExec API Cleanup
   
   The deprecated `main` property of the `JavaExec` task type has been removed.
   Use the `mainClass` property instead.
   
   ==== AbstractExecTask API Cleanup
   
   The deprecated `execResult` getter property of the `AbstractExecTask` task type has been removed.
   Use the `executionResult` getter property instead.
   
   ==== AbstractTestTask API Cleanup
   
   The deprecated `binResultsDir` property of the `AbstractTestTask` task type has been removed.
   Use the `binaryResultsDirectory` property instead.
   
   ==== SourceDirectorySet API Cleanup
   
   The deprecated `outputDir` property of the `SourceDirectorySet` type has been removed.
   Use the `destinationDirectory` property instead.
   
   ==== VersionCatalog API Cleanup
   
   The deprecated `findDependency(String)` method and `dependencyAliases` property of the `VersionCatalog` type have been removed.
   Use the `findLibrary(String)` method and `libraryAliases` property instead.
   
   The deprecated `alias(String)` method of the `VersionCatalogBuilder` type has been removed.
   Use the `library(String, String, String)` or `plugin(String, String)` methods instead.
   
   ==== WorkerExecutor API Cleanup
   
   The deprecated `submit(Class, Action)` method of the `WorkerExecutor` interface has been removed.
   Instead, obtain a `WorkQueue` via the `noIsolation()`, `classLoaderIsolation()`, and `processIsolation()`, methods and use the `submit(Class, Action)` method on the `WorkQueue` instead.
   
   ==== DependencySubstitution API Cleanup
   
   The deprecated `with(ComponentSelector)` method of the `DependencySubstitution` type's inner `Substitution` type's has been removed.
   Use the `using(ComponentSelector)` method instead.
   
   ==== AbstractArchiveTask API Cleanup
   
   The deprecated `appendix`, `archiveName`, `archivePath`, `baseName`, `classifier`, `destinationDir`, `extension` and `version` properties of the `AbstractArchiveTask` task type have been removed.
   Use the `archiveAppendix`, `archiveFileName` , `archiveFile`, `archiveBaseName`, `archiveClassifier`, `destinationDirectory`, `archiveExtension` and `archiveVersion` properties instead.
   
   ==== IdeaModule API Cleanup
   
   The deprecated `testSourceDirs` and `testResourceDirs` properties of the `IdeaModule` type have been removed.
   This affects the `org.gradle.plugins.ide.idea.model.IdeaModule` type, not the `org.gradle.tooling.model.idea.IdeaModule` type.
   Use the `testSources` and `testResources` properties instead.
   
   ==== AbstractCompile API Deprecations
   
   The previously deprecated `destinationDir` property of the `AbstractCompile` remains deprecated, and will now emit a deprecation warning upon use.
   It is now scheduled for removal in Gradle 9.0.
   Use the `destinationDirectory` property instead.
   
   ==== ResolvedComponentResult API Cleanup
   
   The deprecated `getVariant` method of the `ResolvedComponentResult` interface has been removed.
   Use the `getVariants` method instead.
   
   ==== Code quality plugins API Cleanup
   
   The deprecated `antBuilder` property of the `Checkstyle`, `CodeNarc` and `Pmd` task types has been removed.
   Use the `Project` type's `ant` property instead.
   
   ==== Usage API Cleanup
   
   The deprecated public fields `JAVA_API_CLASSES`, `JAVA_API_JARS`, `JAVA_RUNTIME_CLASSES`, `JAVA_RUNTIME_JARS` and `JAVA_RUNTIME_RESOURCES` of the `Usage` type have been removed.
   The values are available in the **internal** `JavaEcosystemSupport` class for compatibility with previously published modules, but should **not** be used for any new publishing.
   
   ==== ExternalDependency API Cleanup
   
   The deprecated `setForce(boolean)` method of the `ExternalDependency` interface has been removed.
   Use the `version(Action)` method to configure strict versions instead.
   
   ==== Build-scan method removed from Kotlin DSL
   
   The deprecated `build-scan` plugin application method has been removed from the Kotlin DSL.
   Use the `gradle-enterprise` method instead.
   
   ==== Configuration extension methods removed from Kotlin DSL
   
   The Kotlin DSL added specialized extension methods for `NamedDomainObjectProvider<Configuration>` that are available when looking up a configuration by name.
   These extensions allowed builds to access some properties of a `Configuration` when using an instance of `NamedDomainObjectProvider<Configuration>` directly:
   ```
   configurations.compileClasspath.files // equivalent to configurations.compileClasspath.get().files
   configurations.compileClasspath.singleFile // equivalent to configurations.compileClasspath.get().singleFile
   ```
   
   All of these extensions have been removed from the API, but the methods are still available for plugins compiled against older versions of Gradle.
   
   * NamedDomainObjectProvider<Configuration>.addToAntBuilder
   * NamedDomainObjectProvider<Configuration>.all
   * NamedDomainObjectProvider<Configuration>.allArtifacts
   * NamedDomainObjectProvider<Configuration>.allDependencies
   * NamedDomainObjectProvider<Configuration>.allDependencyConstraints
   * NamedDomainObjectProvider<Configuration>.artifacts
   * NamedDomainObjectProvider<Configuration>.asFileTree
   * NamedDomainObjectProvider<Configuration>.asPath
   * NamedDomainObjectProvider<Configuration>.attributes
   * NamedDomainObjectProvider<Configuration>.buildDependencies
   * NamedDomainObjectProvider<Configuration>.contains
   * NamedDomainObjectProvider<Configuration>.copy
   * NamedDomainObjectProvider<Configuration>.copyRecursive
   * NamedDomainObjectProvider<Configuration>.defaultDependencies
   * NamedDomainObjectProvider<Configuration>.dependencies
   * NamedDomainObjectProvider<Configuration>.dependencyConstraints
   * NamedDomainObjectProvider<Configuration>.description
   * NamedDomainObjectProvider<Configuration>.exclude
   * NamedDomainObjectProvider<Configuration>.excludeRules
   * NamedDomainObjectProvider<Configuration>.extendsFrom
   * NamedDomainObjectProvider<Configuration>.fileCollection
   * NamedDomainObjectProvider<Configuration>.files
   * NamedDomainObjectProvider<Configuration>.filter
   * NamedDomainObjectProvider<Configuration>.getTaskDependencyFromProjectDependency
   * NamedDomainObjectProvider<Configuration>.hierarchy
   * NamedDomainObjectProvider<Configuration>.incoming
   * NamedDomainObjectProvider<Configuration>.isCanBeConsumed
   * NamedDomainObjectProvider<Configuration>.isCanBeResolved
   * NamedDomainObjectProvider<Configuration>.isEmpty
   * NamedDomainObjectProvider<Configuration>.isTransitive
   * NamedDomainObjectProvider<Configuration>.isVisible
   * NamedDomainObjectProvider<Configuration>.minus
   * NamedDomainObjectProvider<Configuration>.outgoing
   * NamedDomainObjectProvider<Configuration>.plus
   * NamedDomainObjectProvider<Configuration>.resolutionStrategy
   * NamedDomainObjectProvider<Configuration>.resolve
   * NamedDomainObjectProvider<Configuration>.resolvedConfiguration
   * NamedDomainObjectProvider<Configuration>.setDescription
   * NamedDomainObjectProvider<Configuration>.setExtendsFrom
   * NamedDomainObjectProvider<Configuration>.setTransitive
   * NamedDomainObjectProvider<Configuration>.singleFile
   * NamedDomainObjectProvider<Configuration>.state
   * NamedDomainObjectProvider<Configuration>.withDependencies
   
   You should prefer to directly reference the methods from `Configuration`.
   
   === Potential breaking changes
   
   ==== `JavaForkOptions` `getJvmArgs()` and `getAllJvmArgs()` return immutable lists
   
   The lists of JVM arguments retrieved from the `JavaForkOptions` interface are now immutable.
   
   Previously, modifications of the returned list were silently ignored.
   
   ==== Nullable annotations better reflect actual nullability of API
   
   In some APIs, nullability was not correctly annotated and APIs that did allow null or returned null were marked as non-null.
   In Java or Groovy, this mismatch did not cause problems at compile time.
   In Kotlin, this mismatch made valid code difficult to write because the language would not allow you to pass null.
   
   One particular example was returning `null` from a `Provider#map` or `Provider#flatMap`. In both APIs, Gradle allows you to return null, but in the Kotlin DSL this was considered illegal.
   
   This correction may cause compilation errors in code that expected non-null.
   
   ==== Plugins, tasks and extension classes are abstract
   
   Most public classes for plugins, tasks and extensions have been made abstract.
   This was done to make it easier to remove boilerplate from Gradle's implementation.
   
   Plugins that are affected by this change should make their classes abstract as well.
   Gradle uses runtime class decoration to implement abstract methods as long as the object is instantiated via `ObjectFactory` or some other automatic mechanism (like <<custom_gradle_types.adoc#managed_properties,managed properties>>).
   Those methods should never be directly implemented.
   
   ==== Wrapper task configuration
   If `gradle-wrapper.properties` contains the `distributionSha256Sum` property, you must specify a sum.
   You can specify a sum in the wrapped task configuration or with the `--gradle-distribution-sha256-sum` task option.
   
   ==== Changes in the AbstractCodeQualityPlugin class
   
   The deprecated `AbstractCodeQualityPlugin.getJavaPluginConvention()` method was removed in Gradle 8.0.
   You should use `JavaPluginExtension` instead.
   
   ==== Remove implicit `--add-opens` for Gradle workers
   Before Gradle 8.0, Gradle workers on JDK9+ automatically opened JDK modules `java.base/java.util` and `java.base/java.lang` by passing `--add-opens` CLI arguments.
   This enabled code executed in a Gradle worker to perform deep reflection on JDK internals without warning or failing.
   Workers no longer use these implicit arguments.
   
   This affects all internal Gradle workers, which are used for a variety of tasks:
   
   - code-quality plugins (Checkstyle, CodeNarc, Pmd)
   - ScalaDoc
   - AntlrTask
   - JVM compiler daemons
   - tasks executed using process isolation via the link:#[Worker API]
   
   New warnings and errors may appear in any tools, extensions, or plugins that perform deep reflection into JDK internals with the worker API.
   
   These errors can be resolved by updating the violating code or dependency.
   Updates may include:
   
   - code-quality tools
   - annotation processors
   - any Gradle plugins which use the worker API
   
   For some examples of possible error or warning outputs which may arise due to this change, see <<remove_test_add_opens>>.
   
   ==== SourceSet classesDirs no longer depends upon the entire SourceSet as a task dependency
   
   Prior to Gradle 8.0, the task dependencies for `link:{groovyDslPath}#[SourceSetOutput.classesDirs]`
   included tasks that did not produce class files.
   This meant that a task which depends on `classesDirs` would also depend on `classes`, `processResources`, and any other task dependency added to `link:{groovyDslPath}#[SourceSetOutput]`.
   This behavior was potentially an error because the `classesDirs` property did not contain the output for `processResources`.
   Since 8.0, this implicit dependency is removed.
   Now, depending on `classesDirs` only executes the tasks which directly produce files in the classes directories.
   
   Consider the following buildscript:
   ```groovy
   plugins {
       id 'java-library'
   }
   // Task lists all files in the given classFiles FileCollection
   tasks.register("listClassFiles", ListClassFiles) {
       classFiles.from(java.sourceSets.main.output.classesDirs)
   }
   ```
   
   Previously, the `listClassFiles` task depended on `compileJava`, `processResources`, and `classes`.
   Now, only `compileJava` is a task dependency of `listClassFiles`.
   
   If a task in your build relied on the previous behavior, you can instead use the entire
   `SourceSetOutput` as an input, which contains all classes and resources.
   
   If that is not feasible, you can restore the previous behavior by adding more task dependencies to `classesDirs`:
   ```groovy
   java {
       sourceSets {
           main {
               output.classesDirs.builtBy(output)
           }
       }
   }
   ```
   
   ==== Minimal supported Kotlin Gradle Plugin version changed
   Gradle 7.x supports Kotlin Gradle Plugin 1.3.72 and above.
   Kotlin Gradle Plugin versions above 1.6.21 are not tested with Gradle 7.x.
   Gradle 8.x supports Kotlin Gradle Plugin 1.6.10 and above.
   You can use a lower Kotlin language version by modifying the language version and api version setting in the Kotlin compilation tasks.
   
   ==== Minimal supported Android Gradle Plugin version changed
   Gradle 7.x supports Android Gradle Plugin (AGP) 4.1 and above.
   AGP versions above 7.3 are not tested with Gradle 7.x.
   Gradle 8.x supports AGP 8 and above.
   Gradle 8.x supports AGP 7.3 and above if you configure the following property:
   ```
   android.experimental.legacyTransform.forceNonIncremental=true
   ```
   
   ==== Change to `AntBuilder` parent class
   
   Previously, `org.gradle.api.AntBuilder` extended the deprecated `groovy.util.AntBuilder` class.
   It now extends `groovy.ant.AntBuilder`.
   
   ==== `PluginDeclaration` is not serializable
   
   `org.gradle.plugin.devel.PluginDeclaration` is not serializable anymore.
   If you need to serialize it, you can convert it into your own, serializable class.
   
   ==== Gradle does not use equals for serialized values in up-to-date checks
   
   Gradle now does not try to use equals when comparing serialized values in up-to-date checks.
   For more information see <<equals_up_to_date_deprecation>>.
   
   ==== Task and transform validation warnings introduced in Gradle 7.x are now errors
   
   Gradle introduced additional task and artifact transform validation warnings in the Gradle 7.x series.
   Those warnings are now errors in Gradle 8.0 and will fail the build.
   
   Warnings that became errors:
   
   - An input file collection that can't be resolved.
   - An input or output file or directory that cannot be read.
   See <<#declare_unreadable_input_output,Declaring input or output directories which contain unreadable content>>.
   - Using a `java.io.File` as the `@InputArtifact` of an artifact transform.
   - Using an input with an unknown implementation.
   See <<validation_problems.adoc#implementation_unknown,Cannot use an input with an unknown implementation>>.
   - Missing dependencies between tasks.
   See <<validation_problems.adoc#implicit_dependency,Implicit dependencies between tasks>>.
   - Converting files to a classpath where paths contain file separator.
   
   ==== Gradle does not ignore empty directories for file-trees with `@SkipWhenEmpty`
   
   Previously Gradle used to detect if an input file collection annotated with `@SkipWhenEmpty` consisted only of file trees and then ignored directories automatically.
   To ignore directories in Gradle 8.0 and later, the input property needs to be explicitly annotated with `@IgnoreEmptyDirectories`.
   For more information see <<empty_directories_file_tree>>.
   
   ==== Format of `JavaVersion` has changed for Java 9 and Java 10
   
   The string format of the `JavaVersion` has changed to match the official Java versioning.
   Starting from Java 9, the language version must not contain the `1.` prefix.
   This affects the format of the `sourceCompatiblity` and `targetCompatibility` properties on the `JavaCompile` task and `JavaExtension`.
   The old format is still supported when resolving the `JavaVersion` from a string.
   
   [cols="1,1"]
   |===
   | Gradle 7.6 | Gradle 8.0
   | `1.8` | `1.8`
   | `1.9` | `9`
   | `1.10`| `10`
   | `11`  | `11`
   |===
   
   ==== Precompiled script plugins use strict Kotlin DSL accessor generation by default
   
   In precompiled script plugins, type safe Kotlin DSL accessor generation now fails the build if a plugin fails to apply.
   
   Starting in Gradle 7.6, builds could enable this behavior with the `org.gradle.kotlin.dsl.precompiled.accessors.strict` system property.
   This behavior is now default.
   The property has been deprecated and its usage should be removed.
   You can find more information about this property <<upgrading_version_7.adoc#strict-kotlin-dsl-precompiled-scripts-accessors, below>>.
   
   ==== Init scripts are applied to `buildSrc` builds
   
   Init scripts specified using `--init-script` are now applied to `buildSrc` builds. In previous releases these were applied to included builds but not `buildSrc builds.
   
   This behavior is now consistent for `buildSrc` and included builds.
   
   ==== Gradle no longer runs the `build` task for `buildSrc` builds
   
   When Gradle builds the output of `buildSrc` it runs only the tasks that produce that output, which is typically the `jar` task.
   In previous releases Gradle would run the `build` task.
   
   This means that the tests of `buildSrc` and its subprojects are not built and executed automatically and must now be explicitly requested.
   
   This behavior is now consistent for `buildSrc` and included builds.
   
   You can run the tests for `buildSrc` in the same way as projects in included builds, for example by running `gradle buildSrc:build`.
   
   ==== `buildFinished { }` hook for `buildSrc` runs after all tasks have executed
   
   The `buildFinished {}` hook for `buildSrc` now runs after all tasks have completed. In previous releases this hook would run immediately after
   the tasks for `buildSrc` completed and before any requested tasks started.
   
   This behavior is now consistent for `buildSrc` and included builds.
   
   ==== Changes to paths of included builds
   
   In order to handle conflicts between nested included build names better, Gradle now uses the directory hierarchy of included builds to assign the build path.
   If you are running tasks from the command line in nested included builds, then you may need to adjust your invocation.
   
   For example, if you have the following hierarchy:
   
   ====
   [.multi-language-sample]
   =====
   [source,kotlin]
   ----
   .
   較럭較 settings.gradle.kts
   較덕較 nested
       較럭較 settings.gradle.kts
       較덕較 nestedNested
           較덕較 settings.gradle.kts
   ----
   .settings.gradle.kts
   [source,kotlin]
   ----
   includeBuild("nested")
   ----
   .nested/settings.gradle.kts
   [source,kotlin]
   ----
   includeBuild("nestedNested")
   ----
   =====
   [.multi-language-sample]
   =====
   [source,groovy]
   ----
   .
   較럭較 settings.gradle
   較덕較 nested
       較럭較 settings.gradle
       較덕較 nestedNested
           較덕較 settings.gradle
   ----
   .settings.gradle
   [source,groovy]
   ----
   includeBuild("nested")
   ----
   .nested/settings.gradle
   [source,groovy]
   ----
   includeBuild("nestedNested")
   ----
   =====
   ====
   
   Before Gradle 8.0, you ran `gradle :nestedNested:compileJava`.
   In Gradle 8.0 the invocation changes to `gradle :nested:nestedNested:compileJava`.
   
   ==== Adding `jst.ejb` with the `eclipse wtp` plugin now removes the `jst.utility` facet
   
   The `eclipse wtp` plugin adds the `jst.utility` facet to java projects.
   Now, adding the `jst.ejb` facet implicitly removes the `jst.utility` facet:
   
   ```
   eclipse {
       wtp {
           facet {
               facet name: 'jst.ejb', version: '3.2'
           }
       }
   }
   ```
   
   ==== Simplifying PMD custom rules configuration
   
   Previously, you had to explicitly configure PMD to ignore default rules with `ruleSets = []`.
   In the Gradle 8.0, setting `ruleSetConfig` or `ruleSetFiles` to a non-empty value implicitly ignores default rules.
   
   ==== Report `getOutputLocation` return type changed from Provider to Property
   
   The `outputLocation` property of the link:{groovyDslPath}#[Report] now returns a value of type `Property<? extends FileSystemLocation>`.
   Previously, `outputLocation` returned a value of type `Provider<? extends FileSystemLocation>`.
   
   This change makes the Report API more internally consistent, and allows for more idiomatic configuration of reporting tasks.
   
   The former, now `@Deprecated` usage:
   
   ```groovy
   tasks.named('test') {
       reports.junitXml.setDestination(layout.buildDirectory.file('reports/my-report-old').get().asFile) // DEPRECATED
   }
   
   ```
   
   can be replaced with:
   
   ```groovy
   tasks.named('test') {
       reports.junitXml.outputLocation = layout.buildDirectory.dir('reports/my-report')
   }
   ```
   
   
   Many built-in and custom reports, such as those used by JUnit, implement this interface.
   Plugins compiled against an earlier version of Gradle containing the previous method signature may need to be recompiled to be used with newer versions of Gradle containing the new signature.
   
   ==== Removed external plugin validation plugin
   
   The incubating plugin `ExternalPluginValidationPlugin` has been removed.
   Use the link:#[`java-gradle-plugin`]'s `validatePlugins` task to validate plugins under development.
   
   ==== Reproducible archives can change compared to past versions
   
   Gradle changes the compression library used for creating archives from an Ant based one to https://commons.apache.org/proper/commons-compress/[Apache Commons Compress묗.
   As a consequence archives created from the same content, are unlikely to end up identical byte-by-byte to their older versions, created with the old library.
   
   ==== Upgrade to Kotlin 1.8.10
   
   The embedded Kotlin has been updated to link:https://github.com/JetBrains/kotlin/releases/tag/v1.8.10[Kotlin 1.8.10].
   Also see link:https://github.com/JetBrains/kotlin/releases/tag/v1.8.0[Kotlin 1.8.0] release notes.
   For more information, see the release notes for Kotlin
   
   * https://github.com/JetBrains/kotlin/releases/tag/v1.7.20[1.7.20]
   * https://github.com/JetBrains/kotlin/releases/tag/v1.7.21[1.7.21]
   * https://github.com/JetBrains/kotlin/releases/tag/v1.8.0[1.8.0]
   
   ==== Updated the Kotlin DSL to Kotlin API Level 1.8
   
   Previously, the Kotlin DSL used Kotlin API level 1.4.
   Starting with Gradle 8.0, the Kotlin DSL uses Kotlin API level 1.8.
   This change brings all the improvements made to the Kotlin language and standard library since Kotlin 1.4.0.
   
   For information about breaking and nonbreaking changes in this upgrade, see the following links to the Kotlin documentation:
   
   * Kotlin 1.5 link:https://kotlinlang.org/docs/whatsnew15.html#language-features[language] / link:https://kotlinlang.org/docs/whatsnew15.html#standard-library[standard library]
   * Kotlin 1.6 link:https://kotlinlang.org/docs/whatsnew16.html#language[language] / link:https://kotlinlang.org/docs/whatsnew16.html#standard-library[standard library]
   * Kotlin 1.7 link:https://kotlinlang.org/docs/whatsnew17.html#language[language] / link:https://kotlinlang.org/docs/whatsnew17.html#standard-library[standard library]
   * Kotlin 1.8 link:https://kotlinlang.org/docs/whatsnew18.html#language[language] / link:https://kotlinlang.org/docs/whatsnew18.html#standard-library[standard library]
   
   Note that the Kotlin Gradle Plugin 1.8.0 started using Java toolchains.
   It is recommended you configure a toolchain instead of defining Java `sourceCompatibility`/`targetCompatibility` in Kotlin projects.
   
   Also note that the Kotlin Gradle Plugin 1.8.0 introduced `compilerOptions` with lazy configuration properties as a replacement for `kotlinOptions` which did not support lazy configuration.
   It is recommended you configure Kotlin compilation using `compilerOptions` instead of `kotlinOptions`.
   
   ==== `kotlinDslPluginOptions.jvmTarget` is deprecated
   
   Previously, you could use `kotlinDslPluginOptions.jvmTarget` to configure which JVM target should be used for compiling code when using the `kotlin-dsl` plugin.
   
   Starting with Gradle 8.0, `kotlinDslPluginOptions.jvmTarget` is deprecated.
   You should <<kotlin_dsl#sec:kotlin-dsl_plugin,configure a Java Toolchain>> instead.
   
   If you already have a Java Toolchain configured and `kotlinDslPluginOptions.jvmTarget` unset then Gradle 8.0 will now use the Java Toolchain as the JVM target instead of the previous default target (1.8).
   
   ==== Java Base Plugin now sets Jar, War, and Ear destination directory defaults
   
   Previously, the `base` plugin configured the
   link:{groovyDslPath}#[destinationDirectory] of
   link:{groovyDslPath}#[Jar], link:{groovyDslPath}#[War], and
   link:{groovyDslPath}#[Ear] tasks to the directory specified by
   link:{groovyDslPath}#[BasePluginExtension#getLibsDirectory].
   In Gradle 8.0, `java-base` handles this configuration.
   No changes are required for projects that already apply the
   `java-base` plugin directly or indirectly through the `java`, `application`, `java-library`, or other JVM ecosystem plugins.
   
   ==== Upload Task should not be used
   
   The `Upload` task remains deprecated and is now scheduled for removal in Gradle 9.0.
   Although this type remains, it is no longer functional and will throw an exception upon running.
   It is preserved solely to avoid breaking plugins.
   Use the tasks in the `maven-publish` or `ivy-publish` plugins instead.
   
   ==== Configurations no longer allowed as Dependencies
   
   Adding a Configuration as a dependency in the `dependencies` DSL block, or programmatically using the `DependencyHandler` classes' `doAdd(Configuration, Object, Closure)` method, is no longer allowed and will fail with an exception.
   To replicate many aspects of this behavior, extend configurations using the `extendsFrom(Configuration)` method on `Configuration` instead.
   
   ==== Deprecated for consumption configurations are now non-consumable
   
   The following configurations were never meant to be consumed:
   
    - The `antlr` configuration created by the `AntlrPlugin`
    - The `zinc` configuration created by the `ScalaBasePlugin`
    - The `providedCompile` and `providedRuntime` configurations created by the `WarPlugin`
   
   These configurations were deprecated for consumption and are now no longer consumable.
   Attempting to consume them will result in an error.
   
   ==== Identical consumable configurations are now an error
   
   If a project has multiple consumable configurations that share the same attributes and capabilities declaration, the build will fail when publishing or resolving as a dependency that project.
   This was <<#unique_attribute_sets,previously deprecated>>.
   
   The <<variant_model.adoc#outgoing_variants_report,`outgoingVariants` report>> will warn about this for impacted configurations.
   
   ==== Toolchain-based tasks for JVM projects
   
   Starting with Gradle 8.0, all core Java tasks that have toolchain support are now using toolchains unconditionally.
   If `JavaBasePlugin` is applied, the convention value for tool properties on the task is defined by the toolchain configured on the `java` extension.
   In case no toolchains are explicitly configured, the toolchain corresponding to the JVM running Gradle is used.
   
   Similarly, tasks from the Groovy and Scala plugins also rely on toolchains to determine on which JVM they are executed.
   
   ==== Scala compilation target
   
   With the toolchain changes described above, Scala compilation tasks are now always provided with a `target` or `release` parameter.
   The exact parameter and value depend on toolchain usage, or not, and Scala version.
   
   See the <<scala_plugin#sec:scala_target,Scala plugin documentation>> for details.
   
   ==== `pluginBundle` dropped in Plugin Publish plugin
   
   Gradle 8 no longer supports the `pluginBundle` extension.
   Its functionality has been merged into the `gradlePlugin` block.
   These changes require recent versions of the Plugin Publish plugin (link:https://plugins.gradle.org/plugin/com.gradle.plugin-publish/1.1.0[1.0.+]).
   Documentation on configuring plugin publication can be found both link:https://plugins.gradle.org/docs/publish-plugin[on the Portal] and <<publishing_gradle_plugins#configure_the_plugin_publishing_plugin,in the user manual>>.
   
   == Upgrading from 7.5 and earlier
   
   === Updates to Attribute Disambiguation Rules related methods
   
   The `link:{javadocPath}#[AttributeSchema.setAttributeDisambiguationPrecedence(List)]` and `link:{javadocPath}#[AttributeSchema.getAttributeDisambiguationPrecedence()]` methods now accept and return `List` instead of `Collection` to better indicate that the order of the elements in those collection is significant.
   
   === Strict Kotlin DSL precompiled script plugins accessors generation
   
   Type safe Kotlin DSL accessors generation for precompiled script plugins does not fail the build by default if a plugin requested in such precompiled scripts fails to be applied.
   Because the cause could be environmental and for backwards compatibility reasons, this behaviour hasn't changed yet.
   
   Back in Gradle 7.1 the `:generatePrecompiledScriptPluginAccessors` task responsible for the accessors generation has been marked as non-cacheable by default.
   The `org.gradle.kotlin.dsl.precompiled.accessors.strict` system property was introduced in order to offer an opt-in to a stricter mode of operation that fails the build when a plugin application fails, and enable the build cache for that task.
   
   Starting with Gradle 7.6, non-strict accessors generation for Kotlin DSL precompiled script plugins has been deprecated.
   This will change in Gradle 8.0.
   Strict accessor generation will become the default.
   To opt in to the strict behavior, set the 'org.gradle.kotlin.dsl.precompiled.accessors.strict' system property to `true`.
   
   This can be achieved persistently in the `gradle.properties` file in your build root directory:
   
   ```properties
   systemProp.org.gradle.kotlin.dsl.precompiled.accessors.strict=true
   ```
   
   === Potential breaking changes
   
   ==== Upgrade to Kotlin 1.7.10
   
   The embedded Kotlin has been updated to https://github.com/JetBrains/kotlin/releases/tag/v1.7.10[Kotlin 1.7.10].
   
   Gradle doesn't ship with the `kotlin-gradle-plugin` but the upgrade to 1.7.10 can bring the new version.
   For example when you use the `kotlin-dsl` plugin.
   
   The `kotlin-gradle-plugin` version 1.7.10 changes the type hierarchy of the `KotlinCompile` task type.
   It doesn't extend from `AbstractCompile` anymore.
   If you used to select Kotlin compilation tasks by `AbstractCompile` you need to change that to `KotlinCompile`.
   
   For example, this
   ```kotlin
   tasks.named<AbstractCompile>("compileKotlin")
   ```
   
   needs to be changed to
   ```kotlin
   tasks.named<KotlinCompile>("compileKotlin")
   ```
   
   In the same vein, if you used to filter tasks by `AbstractCompile` you won't obtain the Kotlin compilation tasks anymore:
   
   ```kotlin
   tasks.withType<AbstractCompile>().configureEach {
       // ...
   }
   ```
   
   needs to be changed to
   ```kotlin
   tasks.withType<AbstractCompile>().configureEach {
       // ...
   }
   tasks.withType<KotlinCompile>().configureEach {
       // ...
   }
   ```
   
   ==== Upgrade to Groovy 3.0.13
   
   Groovy has been updated to https://groovy-lang.org/changelogs/changelog-3.0.13.html[Groovy 3.0.13].
   
   Since the previous version was 3.0.10, the https://groovy-lang.org/changelogs/changelog-3.0.11.html[3.0.11] and https://groovy-lang.org/changelogs/changelog-3.0.12.html[3.0.12] changes are also included.
   
   ==== Upgrade to CodeNarc 3.1.0
   
   The default version of CodeNarc has been updated to https://github.com/CodeNarc/CodeNarc/blob/master/CHANGELOG.md#version-310----jun-2022[3.1.0].
   
   ==== Upgrade to PMD 6.48.0
   
   PMD has been updated to https://pmd.github.io/pmd-6.48.0/pmd_release_notes.html[PMD 6.48.0].
   
   ==== Configuring a non-existing executable now fails
   
   When configuring an executable explicitly for link:{groovyDslPath}#[`JavaCompile`] or link:{groovyDslPath}#[`Test`] tasks, Gradle will now emit an error if this executable does not exist.
   In the past, the task would be executed with the default toolchain or JVM running the build.
   
   ==== Changes to dependency declarations in Test Suites
   
   As part of the ongoing effort to evolve Test Suites, dependency declarations in the Test Suites `dependencies` block are <<jvm_test_suite_plugin.adoc#sec:differences_with_top_level_dependencies, now strongly typed>>.
   This will help make this incubating API more discoverable and easier to use in an IDE.
   
   In some cases, this requires syntax changes.
   For example, build scripts that previously added Test Suite dependencies with the following syntax:
   
   ```kotlin
   testing {
     suites {
       register<JvmTestSuite>("integrationTest") {
         dependencies {
           implementation(project)
         }
       }
     }
   }
   ```
   
   will now fail to compile, with a message like:
   
   ```
   None of the following functions can be called with the arguments supplied:
   public operator fun DependencyAdder.invoke(dependencyNotation: CharSequence): Unit defined in org.gradle.kotlin.dsl
   public operator fun DependencyAdder.invoke(dependency: Dependency): Unit defined in org.gradle.kotlin.dsl
   public operator fun DependencyAdder.invoke(files: FileCollection): Unit defined in org.gradle.kotlin.dsl
   public operator fun DependencyAdder.invoke(dependency: Provider<out Dependency>): Unit defined in org.gradle.kotlin.dsl
   public operator fun DependencyAdder.invoke(externalModule: ProviderConvertible<out MinimalExternalModuleDependency>): Unit defined in org.gradle.kotlin.dsl
   ```
   
   To fix this, replace the reference to `project` with a call to `project()`:
   
   ```kotlin
   testing {
     suites {
       register<JvmTestSuite>("integrationTest") {
         dependencies {
           implementation(project())
         }
       }
     }
   }
   ```
   
   Other syntax effected by this change includes:
   
   - You cannot use `Provider<String>` as a dependency declaration.
   - You cannot use a `Map` as a dependency declaration for Kotlin or Java.
   - You cannot use a bundle as a dependency declaration directly (`implementation(libs.bundles.testing)`).
   Use `implementation.bundle(libs.bundles.testing)` instead.
   
   For more information, see the updated <<jvm_test_suite_plugin.adoc#sec:declare_an_additional_test_suite, declare an additional test suite>> example in the JVM Test Suite Plugin section of the user guide and the link:{groovyDslPath}#[`DependencyAdder`] page in the DSL reference.
   
   === Deprecations
   
   ==== Usage of invalid Java toolchain specifications is now deprecated
   
   Along with the Java language version, the <<toolchains#toolchains, Java toolchain>> DSL allows configuring other criteria such as specific vendors or VM implementations.
   Starting with Gradle 7.6, toolchain specifications that configure other properties without specifying the language version are considered _invalid_.
   Invalid specifications are deprecated and will become build errors in Gradle 8.0.
   
   See more details about toolchain configuration in the <<toolchains#sec:configuring_toolchain_specifications,user manual>>.
   
   ==== Deprecated members of the `org.gradle.util` package now report their deprecation
   
   These members will be removed in Gradle 9.0.
   
   * `ClosureBackedAction`
   * `CollectionUtils`
   * `ConfigureUtil`
   * `DistributionLocator`
   * `GFileUtils`
   * `GradleVersion.getBuildTime()`
   * `GradleVersion.getNextMajor()`
   * `GradleVersion.getRevision()`
   * `GradleVersion.isValid()`
   * `GUtil`
   * `NameMatcher`
   * `NameValidator`
   * `RelativePathUtil`
   * `TextUtil`
   * `SingleMessageLogger`
   * `VersionNumber`
   * `WrapUtil`
   
   ==== Internal DependencyFactory was renamed
   The internal `org.gradle.api.internal.artifacts.dsl.dependencies.DependencyFactory` type was renamed to `org.gradle.api.internal.artifacts.dsl.dependencies.DependencyFactoryInternal`.
   As an internal type, it should not be used, but for compatibility reasons the inner `ClassPathNotation` type is still available.
   This name for the type is deprecated and will be removed in Gradle 8.0.
   The public API for this is on `DependencyHandler`, with methods such as `localGroovy()` providing the same functionality.
   
   ==== Replacement collections in `org.gradle.plugins.ide.idea.model.IdeaModule`
   
   The `testResourcesDirs` and `testSourcesDirs` fields and their getters and setters have been deprecated.
   Replace usages with the now stable `getTestSources()` and `getTestResources()` methods and their respective setters.
   These new methods return and are backed by `ConfigurableFileCollection` instances for improved flexibility of use.
   Gradle now warns upon usage of these deprecated methods.
   They will be removed in a future version of Gradle.
   
   ==== Replacement methods in `org.gradle.api.tasks.testing.TestReport`
   
   The `getDestinationDir()`, `setDestinationDir(File)`, and `getTestResultDirs()` and `setTestResultDirs(Iterable)` methods have been deprecated.
   Replace usages with the now stable `getDestinationDirectory()` and `getTestResults()` methods and their associated setters.
   These deprecated elements will be removed in a future version of Gradle.
   
   ==== Deprecated implicit references to outer scope methods in some configuration blocks
   
   Prior to Gradle 7.6, Groovy scripts permitted access to root project configure methods
   within named container configure methods that throw `MissingMethodException`s.
   Consider the following snippets for examples of this behavior:
   
   Gradle permits access to the top-level `repositories` block from within the `configurations` block
   when the provided closure is otherwise an invalid configure closure for a Configuration.
   In this case, the `repositories` closure executes as if it were called at the script-level, and
   creates an unconfigured `repositories` Configuration:
   
   ```groovy
   configurations {
       repositories {
           mavenCentral()
       }
       someConf {
           canBeConsumed = false
           canBeResolved = false
       }
   }
   ```
   
   The behavior also applies to closures which do not immediately execute.
   In this case, `afterResolve` only executes when the `resolve` task runs.
   The `distributions` closure is a valid top-level script closure.
   But it is an invalid configure closure for a Configuration.
   This example creates the `conf` Configuration immediately.
   During `resolve` task execution, the `distributions` block executed as if it were declared at the script-level:
   
   ```groovy
   configurations {
       conf.incoming.afterResolve {
           distributions {
               myDist {
                   contents {}
               }
           }
       }
   }
   
   task resolve {
       dependsOn configurations.conf
       doFirst {
           configurations.conf.files() // Trigger `afterResolve`
       }
   }
   ```
   
   As of Gradle 7.6, this behavior is deprecated.
   Starting with Gradle 8.0, this behavior will be removed.
   Instead, Gradle will throw the underlying `MissingMethodException`.
   To mitigate this change, consider the following solutions:
   
   ```groovy
   configurations {
       conf.incoming.afterResolve {
           // Fully qualify the reference.
           project.distributions {
               myDist {
                   contents {}
               }
           }
       }
   }
   ```
   
   ```groovy
   configurations {
       conf
   }
   
   // Extract the script-level closure to the script root scope.
   configurations.conf.incoming.afterResolve {
       distributions {
           myDist {
               contents {}
           }
       }
   }
   ```
   
   == Upgrading from 7.4 and earlier
   
   === IncrementalTaskInputs type is deprecated
   
   The `IncrementalTaskInputs` type was used to implement _incremental tasks,_ that is to say tasks that can be optimized to run on a subset of changed inputs instead of the whole input.
   This type had a number of drawbacks.
   In particular using this type it was not possible to determine what input a change was associated with.
   
   You should now use the `InputChanges` type instead.
   Please refer to the <<custom_tasks.adoc#sec:implementing_an_incremental_task, userguide section about implementing incremental tasks for more details>>.
   
   === Potential breaking changes
   
   ==== Version catalog only accepts a single TOML import file
   
   Only a single file will be accepted when using a `from` import method.
   This means that notations, which resolve to multiple files (e.g. the link:{groovyDslPath}#[]++)[Project.files(java.lang.Object...)] method, when more then one file is passed) will result in a build failure.
   
   ==== Updates to default tool integration versions
   
   - Checkstyle has been updated to https://checkstyle.sourceforge.io/releasenotes.html#Release_8.45.1[Checkstyle 8.45.1].
   - JaCoCo has been updated to https://www.jacoco.org/jacoco/trunk/doc/changes.html[0.8.8].
   
   ==== Classpath file generated by the `eclipse` plugin has changed
   
   Project dependencies defined in test configurations get the `test=true` classpath attribute.
   All source sets and dependencies defined by the JVM Test Suite plugin are also marked as test code by default.
   You can now customize test source sets and dependencies via the `eclipse` plugin DSL:
   
   ```
   eclipse {
       classpath {
           testSourceSets = [sourcesSets.test, sourceSets.myTestSourceSet]
           testConfigurations = [configuration.myTestConfiguration]
       }
   }
   ```
   
   Alternatively, you can adjust or remove classpath attributes in the `eclipse.classpath.file.whenMerged { }` block.
   
   ==== Signing plugin defaults to `gpg` instead of `gpg2` when using the GPG command
   
   The signature plugin's default executable link:#[when using the GPG command] changed from `gpg2` to `gpg`.
   The change was motivated as GPG 2.x became stable, and distributions started to migrate by not linking the `gpg2` executable.
   
   In order to set the old default, the executable can be manually defined in `gradle.properties`:
   
   [source,properties]
   ----
   signing.gnupg.executable=gpg2
   ----
   ==== `mustRunAfter` constraints no longer violated by `finalizedBy` dependencies
   
   In previous Gradle versions, `mustRunAfter` constraints between regular tasks and finalizer task dependencies would not be honored.
   
   For a concrete example, consider the following task graph definition:
   
   [source,kotlin]
   ----
   tasks {
       register("dockerTest") {
           dependsOn("dockerUp")     // dependsOn createContainer mustRunAfter removeContainer
           finalizedBy("dockerStop") // dependsOn removeContainer
       }
   
       register("dockerUp") {
           dependsOn("createContainer")
       }
   
       register("dockerStop") {
           dependsOn("removeContainer")
       }
   
       register("createContainer") {
           mustRunAfter("removeContainer")
       }
   
       register("removeContainer") {
       }
   }
   ----
   
   The relevant constraints are:
   
   - `dockerStop` is a finalizer of `dockerTest` so it  must be run after `dockerTest`;
   - `removeContainer` is a dependency of `dockerStop` so it must be run before `dockerStop`;
   - `createContainer` must run after `removeContainer`;
   
   Prior to Gradle 7.5, `gradle dockerTest` would yield the following order of execution, in violation of the `mustRunAfter` constraint between `:createContainer` and `:removeContainer`:
   
   ```
   > Task :createContainer UP-TO-DATE
   > Task :dockerUp UP-TO-DATE
   > Task :dockerTest UP-TO-DATE
   > Task :removeContainer UP-TO-DATE
   > Task :dockerStop UP-TO-DATE
   ```
   
   Starting with Gradle 7.5, `mustRunAfter` constraints are fully honored yielding the following order of execution:
   
   ```
   > Task :removeContainer UP-TO-DATE
   > Task :createContainer UP-TO-DATE
   > Task :dockerUp UP-TO-DATE
   > Task :dockerTest UP-TO-DATE
   > Task :dockerStop UP-TO-DATE
   ```
   
   ==== Updates to bundled Gradle dependencies
   
   - Groovy has been updated to https://groovy-lang.org/releasenotes/groovy-3.0.html[Groovy 3.0.11].
   
   ==== Scala Zinc version updated to 1.6.1
   
   Zinc is the Scala incremental compiler that allows Gradle to always compile the minimal set of files needed by the current file changes.
   It takes into account which methods are being used and which have changed, which means it's much more granular than just interfile dependencies.
   
   Zinc version has been updated to the newest available one in order to benefit from all the recent bugfixes.
   Due to that, if you use `zincVersion` setting it's advised to remove it and only use the default version, because Gradle will only be able to compile Scala code with Zinc versions set to 1.6.x or higher.
   
   ==== Removes implicit `--add-opens` for test workers
   
   Prior to Gradle 7.5, JDK modules `java.base/java.util` and `java.base/java.lang` were automatically opened in test workers on JDK9+ by passing `--add-opens` CLI arguments.
   This meant any tests were able to perform deep reflection on JDK internals without warning or failing.
   This caused tests to be unreliable by allowing code to pass when it would otherwise fail in a production environment.
   
   These implicit arguments have been removed and are no longer added by default.
   If your code or any of your dependencies are performing deep reflection into JDK internals during test execution, you may see the following behavior changes:
   
   Before Java 16, new build warnings are shown.
   These new warnings are printed to stderr and will not fail the build:
   ```
   WARNING: An illegal reflective access operation has occurred
   WARNING: Illegal reflective access by com.google.inject.internal.cglib.core.ReflectUtils$2 (file:/.../testng-5.12.1.jar) to <method>
   WARNING: Please consider reporting this to the maintainers of com.google.inject.internal.cglib.core.ReflectUtils$2
   WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
   WARNING: All illegal access operations will be denied in a future release
   ```
   
   With Java 16 or higher, exceptions are thrown that fail the build:
   ```
   // Thrown by TestNG
   java.lang.reflect.InaccessibleObjectException: Unable to make <method> accessible: module java.base does not "opens java.lang" to unnamed module @1e92bd61
   	at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:354)
   	at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:297)
   	at java.base/java.lang.reflect.Method.checkCanSetAccessible(Method.java:199)
   	at java.base/java.lang.reflect.Method.setAccessible(Method.java:193)
       ...
   
   // Thrown by ProjectBuilder
   org.gradle.api.GradleException: Could not inject synthetic classes.
   	at org.gradle.initialization.DefaultLegacyTypesSupport.injectEmptyInterfacesIntoClassLoader(DefaultLegacyTypesSupport.java:91)
   	at org.gradle.testfixtures.internal.ProjectBuilderImpl.getGlobalServices(ProjectBuilderImpl.java:182)
   	at org.gradle.testfixtures.internal.ProjectBuilderImpl.createProject(ProjectBuilderImpl.java:111)
   	at org.gradle.testfixtures.ProjectBuilder.build(ProjectBuilder.java:120)
   	...
   Caused by: java.lang.RuntimeException: java.lang.IllegalAccessException: module java.base does not open java.lang to unnamed module @1e92bd61
   ```
   
   In most cases, these errors can be resolved by updating the code or dependency performing the illegal access.
   If the code-under-test or the newest version of the dependency in question performs illegal access by design, the old behavior can be restored by opening the `java.base/java.lang` and `java.base/java.util` modules manually with `--add-opens`:
   
   ```
   tasks.withType(Test).configureEach {
       jvmArgs(["--add-opens=java.base/java.lang=ALL-UNNAMED",
                "--add-opens=java.base/java.util=ALL-UNNAMED"]
   }
   ```
   
   If you are developing Gradle plugins, `ProjectBuilder` relies on reflection in the `java.base/java.lang` module.
   Gradle will automatically add the appropriate `--add-opens` flag to tests when the `java-gradle-plugin` plugin is applied.
   
   If you are using TestNG, versions prior to `5.14.6` perform illegal reflection.
   Updating to at least `5.14.6` should fix the incompatibility.
   
   ==== Checkstyle tasks use toolchains and execute in parallel by default
   
   The <<checkstyle_plugin.adoc#checkstyle_plugin,Checkstyle plugin>> now uses the Gradle worker API to run Checkstyle as an external worker process.
   Multiple Checkstyle tasks may now run in parallel within a project.
   
   Some projects will need to increase the amount of memory available to Checkstyle to avoid out of memory errors.
   You can <<checkstyle_plugin.adoc#sec:checkstyle_customize_memory,increase the maximum memory for the Checkstyle process>> by setting the `maxHeapSize` for the Checkstyle task.
   By default, the process will start with a maximum heap size of 512MB.
   
   We also recommend to update Checkstyle to version 9.3 or later.
   
   ==== Missing files specified with relative paths when running Checkstyle
   
   Gradle 7.5 consistently sets the current working directory for the Checkstyle task to `$<<directory_layout.adoc#dir:gradle_user_home,GRADLE_USER_HOME>>/workers`.
   This may cause problems with custom Checkstyle tasks or Checkstyle configuration files that assume a different directory for relative paths.
   
   Previously, Gradle selected the current working directory based on the directory where you ran Gradle.
   If you ran Gradle in:
   
   - the root directory of a project: Gradle uses the root directory as the current working directory.
   - a nested directory of a project: Gradle uses the root directory of the subproject as the current working directory.
   
   In version 7.5 and above, Gradle consistently sets the current working directory for the Checkstyle task to `$<<directory_layout.adoc#dir:gradle_user_home,GRADLE_USER_HOME>>/workers`.
   
   === Deprecations
   
   ==== Converting files to a classpath where paths contain file separator
   
   Java has the concept of a path separator which is used to separate individual paths in a list of paths, for example in a classpath string.
   The individual paths must not contain the path separator.
   Consequently, using
   `@link:{javadocPath}#[FileCollection.getAsPath()]` for files with paths that contain a path separator has been deprecated, and it will be an error in Gradle 8.0 and later.
   Using a file collection with paths which contain a path separator may lead to incorrect builds, since Gradle doesn't find the files as inputs, or even to build failures when the path containing the path separator is illegal on the operating system.
   
   ==== `dependencyInsight` `--singlepath` option is deprecated
   For consistency, this was changed to `--single-path`.
   The API method has remained the same, this only affects the CLI.
   
   ==== Groovydoc `includePrivate` property is deprecated
   There is a new `link:{groovyDslPath}#[access]` property that allows finer control over what is included in the Groovydoc.
   
   ==== Provider-based API must be used to run external processes at the configuration time
   
   Using `Project.exec`, `Project.javaexec`, and standard Java and Groovy APIs to run external processes at the configuration time is now deprecated when the configuration cache is enabled.
   It will be an error in Gradle 8.0 and later.
   Gradle 7.5 introduces configuration cache-compatible ways to execute and obtain output of an external process with the link:{groovyDslPath}#[provider-based APIs] or a custom implementation of the link:{javadocPath}#[`ValueSource`] interface.
   The <<configuration_cache#config_cache:requirements:external_processes,configuration cache chapter>> has more details to help with the migration to the new APIs.
   
   == Upgrading from 7.3 and earlier
   
   === Potential breaking changes
   
   ==== Updates to default tool integration versions
   
   - PMD has been updated to https://github.com/pmd/pmd/releases/tag/pmd_releases%2F6.39.0[PMD 6.39.0].
   
   === Deprecations
   
   ==== AdoptOpenJDK toolchain download
   
   Following the move from AdoptOpenJDK to Adoptium, under the Eclipse foundation, it is no longer possible to download an AdoptOpenJDK build from their end point.
   Instead, an Eclipse Temurin or IBM Semeru build is returned.
   
   Gradle 7.4+ will now emit a deprecation warning when the AdoptOpenJDK vendor is specified in the <<toolchains.adoc#sec:vendors,toolchain specification>> and it is used by auto provisioning.
   If you must use AdoptOpenJDK, you should turn off auto-download.
   If an Eclipse Temurin or IBM Semeru build works for you, specify `JvmVendorSpec.ADOPTIUM` or `JvmVendorSpec.IBM` as the vendor or leave the vendor unspecified.
   
   ==== File trees and empty directory handling
   
   When using `@link:{javadocPath}#[SkipWhenEmpty]` on an input file collection, Gradle skips the task when it determines that the input is empty.
   If the input file collection consists only of file trees, Gradle ignores directories for the emptiness check.
   Though when checking for changes to the input file collection, Gradle only ignores directories when the `@link:{javadocPath}#[IgnoreEmptyDirectories]` annotation is present.
   
   Gradle will now ignore directories for both the `@SkipWhenEmpty` check and for determining changes consistently.
   Until Gradle 8.0, Gradle will detect if an input file collection annotated with `@SkipWhenEmpty` consists only of file trees and then ignore directories automatically.
   Moreover, Gradle will issue a deprecation warning to advise the user that the behavior will change in Gradle 8.0, and that the input property should be annotated with `@IgnoreEmptyDirectories`.
   To ignore directories in Gradle 8.0 and later, the input property needs to be annotated with `@IgnoreEmptyDirectories`.
   
   Finally, using `@link:{javadocPath}#[InputDirectory]` implies `@IgnoreEmptyDirectories`, so no changes are necessary when using this annotation.
   The same is true for `link:{javadocPath}#[inputs.dir()]` when registering an input directory via the runtime API.
   
   ==== Using LazyPublishArtifact without a FileResolver is deprecated
   
   When using a LazyPublishArtifact without a FileResolver, a different file resolution strategy is used, which duplicates some logic in the FileResolver.
   
   To improve consistency, LazyPublishArtifact should be used with a FileResolver, and will require it in the future.
   
   This also affects other internal APIs that use LazyPublishArtifact, which now also have deprecation warnings where needed.
   
   ==== TAR trees from resources without backing files
   
   It is possible to create TAR trees from arbitrary resources.
   If the resource is not created via `project.resources`, then it may not have a backing file.
   Creating a TAR tree from a resource with no backing file has been deprecated.
   Instead, convert the resource to a file and use `project.tarTree()` on the file.
   To convert the resource to a file you can use a custom task or use dependency management to download the file via a URL.
   This way, Gradle is able to apply optimizations like up-to-date checks instead of re-running the logic to create the resource every time.
   
   ==== Unique attribute sets
   
   The set of link:{javadocPath}#[Attribute]s associated with a _consumable_ configuration within a project, must be unique across all other configurations within that project which share the same set of link:{javadocPath}#[Capability]s.
   
   This will be checked at the end of configuring variant configurations, as they are locked against further mutation.
   
   If the set of attributes is shared across configurations, consider adding an additional attribute to one of the variants for the sole purpose of disambiguation.
   
   ==== `Provider#forUseAtConfigurationTime()` has been deprecated
   
   link:{javadocPath}#[Provider#forUseAtConfigurationTime] is now deprecated and scheduled for removal in Gradle 9.0.
   Clients should simply remove the call.
   
   The call was mandatory on providers of external values such as link:{groovyDslPath}#[system properties], link:{groovyDslPath}#[environment variables],
   link:{groovyDslPath}#[Gradle properties] and link:{groovyDslPath}#[file contents] meant to be used at configuration time together with the configuration cache feature.
   
   Starting with version 7.4 Gradle will implicitly treat an external value used at configuration time as a configuration cache input.
   
   Clients are also free to use standard Java APIs such as `System#getenv` to read environment variables, `System#getProperty` to read system properties as well as Gradle APIs such as link:{groovyDslPath}#[`Project#property(String)`] and link:{javadocPath}#[`Project#findProperty(String)`] to read Gradle properties at configuration time.
   The `Provider` based APIs are still the recommended way to connect external values to task inputs for maximum configuration cache reuse.
   
   ==== `ConfigurableReport#setDestination(org.gradle.api.provider.Provider<java.io.File>)` has been deprecated
   
   link:{javadocPath}#[`ConfigurableReport#setDestination(org.gradle.api.provider.Provider<java.io.File>)`] is now deprecated and scheduled for removal in Gradle 8.0.
   
   Use link:{javadocPath}#[`Report#getOutputLocation().set(...)`] instead.
   
   ==== Task execution listeners and events
   
   The Gradle configuration cache does not support listeners and events that have direct access to `Task` and `Project` instances, which allows Gradle to execute tasks in parallel and to store the minimal amount of data in the configuration cache.
   In order to move towards an API that is consistent whether the configuration cache is enabled or not, the following APIs are deprecated and will be removed or be made an error in Gradle 8.0:
   
   - Interface link:{javadocPath}#[TaskExecutionListener]
   - Interface link:{javadocPath}#[TaskActionListener]
   - Method link:{javadocPath}#[TaskExecutionGraph.addTaskExecutionListener()]
   - Method link:{javadocPath}#[TaskExecutionGraph.removeTaskExecutionListener()]
   - Method link:{javadocPath}#[TaskExecutionGraph.beforeTask()]
   - Method link:{javadocPath}#[TaskExecutionGraph.afterTask()]
   - Registering TaskExecutionListener, TaskActionListener, TestListener, TestOutputListener via link:{javadocPath}#[Gradle.addListener()]
   
   See the <<configuration_cache#config_cache:requirements:build_listeners,configuration cache chapter>> for details on how to migrate these usages to APIs that are supported by the configuration cache.
   
   ==== Build finished events
   
   Build finished listeners are not supported by the Gradle configuration cache.
   And so, the following API are deprecated and will be removed in Gradle 8.0:
   
   - Method link:{javadocPath}#[Gradle.buildFinished()]
   - Method link:{javadocPath}#[BuildListener.buildFinished()]
   
   See the <<configuration_cache#config_cache:requirements:build_listeners,configuration cache chapter>> for details on how to migrate these usages to APIs that are supported by the configuration cache.
   
   ==== Calling `Task.getProject()` from a task action
   
   Calling link:{javadocPath}#[Task.getProject()] from a task action at execution time is now deprecated and will be made an error in Gradle 8.0.
   This method can be used during configuration time, but it is recommended to avoid doing this.
   
   See the <<configuration_cache#config_cache:requirements:use_project_during_execution,configuration cache chapter>> for details on how to migrate these usages to APIs that are supported by the configuration cache.
   
   ==== Calling `Task.getTaskDependencies()` from a task action
   
   Calling link:{javadocPath}#[Task.getTaskDependencies()] from a task action at execution time is now deprecated and will be made an error in Gradle 8.0.
   This method can be used during configuration time, but it is recommended to avoid doing this.
   
   See the <<configuration_cache#config_cache:requirements:use_project_during_execution,configuration cache chapter>> for details on how to migrate these usages to APIs that are supported by the configuration cache.
   
   ==== Using a build service from a task without the corresponding `Task.usesService` declaration
   
   Gradle needs the information so it can properly honor the build service lifecycle and its usage constraints.
   
   This will become an error in a future Gradle version.
   
   Check the <<build_services.adoc#using_a_build_service_from_a_task, Shared Build Services documentation>> for more information.
   
   ==== VersionCatalog and VersionCatalogBuilder deprecations
   
   Some methods in link:{javadocPath}#[VersionCatalog] and link:{javadocPath}#[VersionCatalogBuilder] are now deprecated and scheduled for removal in Gradle 8.0.
   Specific replacements can be found in the JavaDoc of the affected methods.
   
   These methods were changed to improve the consistency between the `libs.versions.toml` file and the API classes.
   
   == Upgrading from 7.2 and earlier
   
   === Potential breaking changes
   
   ==== Updates to bundled Gradle dependencies
   
   - Kotlin has been updated to https://github.com/JetBrains/kotlin/releases/tag/v1.5.31[Kotlin 1.5.31].
   - Groovy has been updated to https://groovy-lang.org/changelogs/changelog-3.0.9.html[Groovy 3.0.9].
   - Ant has been updated to https://archive.apache.org/dist/ant/RELEASE-NOTES-1.10.11.html[Ant 1.10.11] to fix https://github.com/advisories/GHSA-q5r4-cfpx-h6fh[CVE-2021-36373] and https://github.com/advisories/GHSA-5v34-g2px-j4fw[CVE-2021-36374].
   - Commons compress has been updated to https://commons.apache.org/proper/commons-compress/[Commons-compress 1.21] to fix https://github.com/advisories/GHSA-7hfm-57qf-j43q[CVE-2021-35515], https://github.com/advisories/GHSA-crv7-7245-f45f[CVE-2021-35516], https://github.com/advisories/GHSA-xqfj-vm6h-2x34[CVE-2021-35517] and https://github.com/advisories/GHSA-mc84-pj99-q6hh[CVE-2021-36090].
   
   ==== Application order of plugins in the `plugins` block
   
   The order in which plugins in the `plugins` block were actually applied was inconsistent and depended on how a plugin was added to the class path.
   
   Now the plugins are always applied in the same order they are declared in the `plugins` block which in rare cases might change behavior of existing builds.
   
   ==== Effects of exclusion on substituted dependencies in dependency resolution
   
   Prior to this version, a dependency substitution target could not be excluded from a dependency graph.
   This was caused by checking for exclusions prior to performing the substitution.
   Now Gradle will also check for exclusion on the substitution result.
   
   ==== Version catalog
   
   Generated accessors no longer give access to the type unsafe API.
   You have to use the <<platforms.adoc#sub:type-unsafe-access-to-catalog,version catalog extension>> instead.
   
   ==== Toolchain support in Scala
   
   When using <<scala_plugin.adoc#sec:scala_tasks,toolchains in Scala>>, the `-target` option of the Scala compiler will now be set automatically.
   This means that using a version of Java that cannot be targeted by a version of Scala will result in an error.
   Providing this flag in the compiler options will disable this behaviour and allow to use a higher Java version to compile for a lower bytecode target.
   
   ==== Declaring input or output directories which contain unreadable content
   
   For up-to-date checks Gradle relies on tracking the state of the inputs and the outputs of a task.
   Gradle used to ignore unreadable files in the input or outputs to support certain use-cases, although it cannot track their state.
   Declaring input or output directories on tasks which contain unreadable content has been deprecated and these use-cases are now supported by declaring the task to be untracked.
   Use the @link:{javadocPath}#[UntrackedTask] annotation or the link:{groovyDslPath}#[Task.doNotTrackState()] method to declare a task as untracked.
   
   When you are using a `link:{groovyDslPath}#[Copy]` task for copying single files into a directory which contains unreadable files, use the method link:{groovyDslPath}#[Task.doNotTrackState()].
   
   == Upgrading from 7.1 and earlier
   
   === Potential breaking changes
   
   ==== Security changes to application start scripts and Gradle wrapper scripts
   
   Due to https://github.com/gradle/gradle/security/advisories/GHSA-6j2p-252f-7mw8[CVE-2021-32751], `gradle`, `gradlew` and start scripts generated by Gradle's <<application_plugin.adoc#application_plugin,application plugin>> have been updated to avoid situations where these
   scripts could be used for arbitrary code execution when an attacker is able to change environment variables.
   
   You can use the latest version of Gradle to generate a `gradlew` script and use it to execute an older version of Gradle.
   
   This should be transparent for most users; however, there may be changes for Gradle builds that rely on the environment variables `JAVA_OPTS` or `GRADLE_OPTS` to pass parameters with complicated quote escaping.
   Contact us if you suspect something has broken your build and you cannot find a solution.
   
   ==== Updates to bundled Gradle dependencies
   
   - Groovy has been updated to https://groovy-lang.org/releasenotes/groovy-3.0.html[Groovy 3.0.8].
   - Kotlin has been updated to https://github.com/JetBrains/kotlin/releases/tag/v1.5.21[Kotlin 1.5.21].
   
   ==== Updates to default tool integration versions
   
   - PMD has been updated to https://github.com/pmd/pmd/releases/tag/pmd_releases%2F6.36.0[PMD 6.36.0].
   
   === Deprecations
   
   ==== Using Java lambdas as task actions
   
   When using a Java lambda to implement a task action, Gradle cannot track the implementation and the task will never be up-to-date or served from the build cache.
   Since it is easy to add such a task action, using task actions implemented by Java lambdas is now deprecated.
   See <<validation_problems.adoc#implementation_unknown,Validation problems>> for more details how to fix the issue.
   
   ==== Relying on equals for up-to-date checks is deprecated
   
   When a task input is annotated with `@Input` and is not a type Gradle understand directly (like `String`), then Gradle uses the serialized form of the input for up-to-date checks and the build cache key.
   Historically, Gradle also loads the serialized value from the last execution and then uses `equals()` to compare it to the current value for up-to-date checks.
   Doing so is error prone, doesn't work with the build cache and has a performance impact, therefore it has been deprecated.
   Instead of using `@Input` on a type Gradle doesn't understand directly, use `@Nested` and annotate the properties of the type accordingly.
   
   == Upgrading from 7.0 and earlier
   
   === Potential breaking changes
   
   ==== Updates to default tool integration versions
   
   - JaCoCo has been updated to http://www.jacoco.org/jacoco/trunk/doc/changes.html[0.8.7].
   
   ==== The `org.gradle.util` package is now a public API
   
   Officially, the `org.gradle.util` package is not part of the public API.
   But, because this package name doesn't contain the word `internal`, many Gradle plugins already consider as one.
   Gradle 7.1 addresses the situation and marks the package as public.
   The classes that were unintentionally exposed are either deprecated or removed, depending on their external usage.
   
   ===== The following classes are now officially recognized as public API:
   - `GradleVersion`
   - `Path`
   - `Configurable`
   
   ===== The following classes have known usages in external plugins and are now deprecated and set for removal in Gradle 8.0:
   
   - `VersionNumber`
   - `TextUtil`
   - `WrapUtil`
   - `RelativePathUtil`
   - `DistributionLocator`
   - `SingleMessageLogger`
   - `ConfigureUtil`
   
   `ConfigureUtil` is being removed without a replacement.
   Plugins can avoid the need for using `ConfigureUtil` by following link:{javadocPath}#[our example].
   
   ===== The following classes have only internal usages and were moved from `org.gradle.util` to the `org.gradle.util.internal` package:
   
   - `Resources`
   - `RedirectStdOutAndErr`
   - `Swapper`
   - `StdInSwapper`
   - `IncubationLogger`
   - `RedirectStdIn`
   - `MultithreadedTestRule`
   - `DisconnectableInputStream`
   - `BulkReadInputStream`
   - `MockExecutor`
   - `FailsWithMessage`
   - `FailsWithMessageExtension`
   - `TreeVisitor`
   - `AntUtil`
   - `JarUtil`
   
   ===== The last set of classes have no external or internal usages and therefore were deleted:
   
   - `DiffUtil`
   - `NoopChangeListener`
   - `EnumWithClassBody`
   - `AlwaysTrue`
   - `ReflectionEqualsMatcher`
   - `DynamicDelegate`
   - `IncubationLogger`
   - `NoOpChangeListener`
   - `DeferredUtil`
   - `ChangeListener`
   
   ==== The return type of source set extensions have changed
   
   The following source sets are contributed via an extension with a custom type:
   
   - `groovy`: link:{groovyDslPath}#[GroovySourceDirectorySet]
   - `antlr`: link:{groovyDslPath}#[AntlrSourceDirectorySet]
   - `scala`: link:{groovyDslPath}#[ScalaSourceDirectorySet]
   
   The 'idiomatic' DSL declaration is backward compatible:
   
   ```groovy
   sourceSets {
       main {
           groovy {
               // ...
           }
       }
   }
   ```
   
   However, the return type of the groovy block has changed to the extension type.
   This means that the following snippet no longer works in Gradle 7.1:
   
   ```groovy
    sourceSets {
        main {
            GroovySourceSet sourceSet = groovy {
                // ...
            }
        }
    }
   ```
   
   ==== Start scripts require bash shell
   
   The command used to start Gradle, the Gradle wrapper as well as the scripts generated by the `application` plugin now require `bash` shell.
   
   === Deprecations
   
   ==== Using convention mapping with properties with type Provider is deprecated
   Convention mapping is an internal feature that is been replaced by the <<lazy_configuration#lazy_configuration,Provider API>>.
   When mixing convention mapping with the Provider API, unexpected behavior can occur.
   Gradle emits a deprecation warning when a property in a task, extension or other domain object uses convention mapping with the Provider API.
   
   To fix this, the plugin that configures the convention mapping for the task, extension or domain object needs to be changed to use the Provider API only.
   
   
   ==== Setting custom build layout
   
   Command line options:
   
   * `-c`, `--settings-file` for specifying a custom settings file location
   * `-b`, `--build-file` for specifying a custom build file location
   
   have been deprecated.
   
   Setting custom build file using
   link:{groovyDslPath}#[buildFile]
   property in link:{groovyDslPath}#[GradleBuild] task has been deprecated.
   
   Please use the link:{groovyDslPath}#[dir]
   property instead to specify the root of the nested build.
   Alternatively, consider using one of the recommended alternatives for
   link:{groovyDslPath}#[GradleBuild] task as suggested in
   <<authoring_maintainable_build_scripts#sec:avoiding_use_of_gradlebuild, Avoid using the GradleBuild task type>> section.
   
   Setting custom build layout using
   link:{javadocPath}#[StartParameter] methods
   link:{javadocPath}#[setBuildFile(File)]
   and
   link:{javadocPath}#[setSettingsFile(File)]
   as well as the counterpart getters
   link:{javadocPath}#[getBuildFile()]
   and
   link:{javadocPath}#[getSettingsFile()]
   have been deprecated.
   
   Please use standard locations for settings and build files:
   
   * settings file in the root of the build
   * build file in the root of each subproject
   
   For the use case where custom settings or build files are used to model different behavior (similar to Maven profiles), consider using <<build_environment#sec:gradle_system_properties, system properties>> with conditional logic.
   For example, given a piece of code in either settings or build file:
   ```
   if (System.getProperty("profile") == "custom") {
       println("custom profile")
   } else {
       println("default profile")
   }
   ```
   You can pass the `profile` system property to Gradle using `gradle -Dprofile=custom` to execute the code in the `custom` profile branch.
   
   ==== Substitution.with replaced with Substitution.using
   
   <<resolution_rules#sec:dependency_substitution_rules, Dependency substitutions>> using `with` method have been deprecated and are replaced with `using` method that also allows chaining.
   For example, a dependency substitution rule `substitute(project(':a')).with(project(':b'))` should be replaced with
   `substitute(project(':a')).using(project(':b'))`.
   With chaining you can, for example, add a reason for a substitution like this: `substitute(project(':a')).using(project(':b')).because("a reason")`.
   
   ==== Properties deprecated in JavaExec task
   
   * The link:{groovyDslPath}#[main] getters and setters
   in link:{groovyDslPath}#[JavaExec] task have been deprecated.
   Use the link:{groovyDslPath}#[mainClass] property instead.
   
   ==== Deprecated properties in `compile` task
   
   * The link:{groovyDslPath}#[JavaCompile.destinationDir]
   property has been deprecated.
   Use the link:{groovyDslPath}#[JavaCompile.destinationDirectory]
   property instead.
   * The link:{groovyDslPath}#[GroovyCompile.destinationDir]
   property has been deprecated.
   Use the link:{groovyDslPath}#[GroovyCompile.destinationDirectory]
   property instead.
   * The link:{groovyDslPath}#[ScalaCompile.destinationDir]
   property has been deprecated.
   Use the link:{groovyDslPath}#[ScalaCompile.destinationDirectory]
   property instead.
   
   ==== Non-hierarchical project layouts
   
   Gradle 7.1 deprecated project layouts where subprojects were located outside of the project root.
   However, based on link:https://github.com/gradle/gradle/issues/18644[community feedback] we decided to roll back in Gradle 7.4 and removed the deprecation.
   As a consequence, the link:{groovyDslPath}#[Settings.includeFlat()] method is deprecated in Gradle 7.1, 7.2, and 7.3 only.
   
   ==== Deprecated `Upload` task
   
   Gradle used to have two ways of publishing artifacts.
   Now, the situation has been cleared and all build should use the `maven-publish` plugin.
   The last remaining artifact of the old way of publishing is the `Upload` task that has been deprecated and scheduled for removal in Gradle 8.0.
   Existing clients should migrate to the <<publishing_maven.adoc#publishing_maven,`maven-publish` plugin>>.
   
   ==== Deprecated conventions
   The concept of conventions is outdated and superseded by extensions.
   To reflect this in the Gradle API, the following elements are now deprecated:
   
   - link:{javadocPath}#[org.gradle.api.Project.getConvention()]
   - `org.gradle.api.internal.HasConvention` (deprecated)
   
   The internal usages of conventions have been also cleaned up (see the deprecated items below).
   
   Plugin authors migrate to extensions if they replicate the changes we've done internally.
   Here are some examples:
   
   - Migrate plugin configuration: link:https://github.com/gradle/gradle/pull/16900/files#diff-ac53d4f39698b83e30b93855fe6a725ffd96d5ed9df156d4f9dfd32bdc7946e7[gradle/gradle#16900].
   - Migrate custom source sets: link:https://github.com/gradle/gradle/pull/17149/files#diff-e159587e2f9aec398fa795b1d8b344f1593cb631e15e04893d31cdc9465f9781[gradle/gradle#17149].
   
   ==== Deprecated consumption of internal plugin configurations
   
   Some core Gradle plugins declare configurations that are used by the plugin itself and are not meant to be
   published or consumed by another subproject directly.
   Gradle did not explicitly prohibit this.
   Gradle 7.1 deprecates consumption of those configurations and this will become an error in Gradle 8.0.
   
   The following plugin configurations have been deprecated for consumption:
   
   [cols="1,1"]
   |===
   | plugin | configurations deprecated for consumption
   
   | `codenarc`
   | `codenarc`
   
   | `pmd`
   | `pmd`
   
   | `checkstyle`
   | `checkstyle`
   
   | `antlr`
   | `antlr`
   
   | `jacoco`
   | `jacocoAnt`, `jacocoAgent`
   
   | `scala`
   | `zinc`
   
   | `war`
   | `providedCompile`, `providedRuntime`
   |===
   
   If your use case needs to consume any of the above mentioned configurations in another project, please create a separate consumable
   configuration that extends from the internal ones.
   For example:
   ```
   plugins {
       id("codenarc")
   }
   configurations {
       codenarc {
           // because currently this is consumable until Gradle 8.0 and can clash with the configuration below depending on the attributes set
           canBeConsumed = false
       }
       codenarcConsumable {
           extendsFrom(codenarc)
           canBeConsumed = true
           canBeResolved = false
           // the attributes below make this configuration consumable by a `java-library` project using `implementation` configuration
           attributes {
               attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
               attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.LIBRARY))
               attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, objects.named(LibraryElements, LibraryElements.JAR))
               attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
               attribute(TargetJvmEnvironment.TARGET_JVM_ENVIRONMENT_ATTRIBUTE, objects.named(TargetJvmEnvironment, TargetJvmEnvironment.STANDARD_JVM));
           }
       }
   }
   ```
   
   ==== Deprecated custom source set interfaces
   The following source set interfaces are now deprecated and scheduled for removal in Gradle 8.0:
   
   - link:{javadocPath}#[GroovySourceSet]
   - `org.gradle.api.plugins.antlr.AntlrSourceVirtualDirectory` (removed)
   - link:{javadocPath}#[ScalaSourceSet]
   
   Clients should configure the sources with their plugin-specific configuration:
   
   - `groovy`: link:{javadocPath}#[GroovySourceDirectorySet]
   - `antlr`: link:{javadocPath}#[AntlrSourceDirectorySet]
   - `scala`: link:{javadocPath}#[ScalaSourceDirectorySet]
   
   For example, here's how you configure the groovy sources from a plugin:
   
   ```java
   GroovySourceDirectorySet groovySources = sourceSet.getExtensions().getByType(GroovySourceDirectorySet.class);
   groovySources.setSrcDirs(Arrays.asList("sources/groovy"));
   ```
   
   ==== Registering artifact transforms extending `ArtifactTransform`
   
   When Gradle first introduced artifact transforms, it used the base class `ArtifactTransform` for implementing them.
   Gradle 5.3 introduced the interface `TransformAction` for implementing artifact transforms, replacing the previous class `ArtifactTransform` and addressing various shortcomings.
   Using the registration method link:{groovyDslPath}#[DependencyHandler.registerTransform(Action)] for `ArtifactTransform` has been deprecated.
   Migrate your artifact transform to use `TransformAction` and use link:{groovyDslPath}#[DependencyHandler.registerTransform(Class, Action)] instead.
   See the <<artifact_transforms#sec:abm_artifact_transforms,user manual>> for more information on implementing `TransformAction`.

/docs/userguide/releases/upgrading/upgrading_version_8.adoc
===========================================================

.. code-block::

   = Upgrading your build from Gradle 8.x to the latest
   
   This chapter provides the information you need to migrate your Gradle 8.x builds to the latest Gradle release.
   For migrating from Gradle 4.x, 5.x, 6.x, or 7.x, see the <<upgrading_version_7.adoc#upgrading_version_7, older migration guide>> first.
   
   We recommend the following steps for all users:
   
   . Try running `gradle help --scan` and view the https://gradle.com/enterprise/releases/2018.4/#identify-usages-of-deprecated-gradle-functionality[deprecations view] of the generated build scan.
   +
   image::deprecations.png[Deprecations View of a Gradle Build Scan]
   +
   This is so you can see any deprecation warnings that apply to your build.
   +
   Alternatively, you can run `gradle help --warning-mode=all` to see the deprecations in the console, though it may not report as much detailed information.
   . Update your plugins.
   +
   Some plugins will break with this new version of Gradle, for example because they use internal APIs that have been removed or changed.
   The previous step will help you identify potential problems by issuing deprecation warnings when a plugin does try to use a deprecated part of the API.
   +
   . Run `gradle wrapper --gradle-version {gradleVersion}` to update the project to {gradleVersion}.
   . Try to run the project and debug any errors using the <<troubleshooting.adoc#troubleshooting, Troubleshooting Guide>>.
   
   == Upgrading from 8.6 and earlier
   
   === Potential breaking changes
   
   ==== Upgrade to Kotlin 1.9.22
   
   The embedded Kotlin has been updated to link:https://github.com/JetBrains/kotlin/releases/tag/v1.9.22[Kotlin 1.9.22].
   
   ==== Upgrade to Apache SSHD 2.10.0
   
   Apache SSHD has been updated from 2.0.0 to https://mina.apache.org/sshd-project/download_2.10.0.html[2.10.0].
   
   ==== Replacement and upgrade of JSch
   
   http://www.jcraft.com/jsch/[JSch] has been replaced by https://github.com/mwiede/jsch[`com.github.mwiede:jsch`] and updated from 0.1.55 to https://github.com/mwiede/jsch/releases/tag/jsch-0.2.16[0.2.16]
   
   ==== Upgrade to Eclipse JGit 5.13.3
   
   Eclipse JGit has been updated from 5.7.0 to https://projects.eclipse.org/projects/technology.jgit/releases/5.13.3[5.13.3].
   
   This includes reworking the way that Gradle configures JGit for SSH operations by moving from JSch to Apache SSHD.
   
   ==== Upgrade to Apache Commons Compress 1.25.0
   
   Apache Commons Compress has been updated from 1.21 to https://commons.apache.org/proper/commons-compress/changes-report.html#a1.25.0[1.25.0].
   This change may affect the checksums of the produced jars, zips, and other archive types because the metadata of the produced artifacts may differ.
   
   ==== Upgrade to ASM 9.6
   
   ASM was upgraded from 9.5 to https://asm.ow2.io/versions.html[9.6] for better support of multi-release jars.
   
   ==== Upgrade of the version catalog parser
   
   The version catalog parser has been upgraded and is now compliant with https://toml.io/en/v1.0.0[version 1.0.0 of the TOML spec].
   
   This should not impact catalogs that use the <<platforms.adoc#sub::toml-dependencies-format,recommended syntax>> or were generated by Gradle for publication.
   
   === Deprecations
   
   ==== Deprecated registration of plugin conventions
   
   Using plugin conventions has been emitting warnings since Gradle 8.2.
   Now, registering plugin conventions will also trigger deprecation warnings.
   For more information, see the <<deprecated_access_to_conventions, section about plugin convention deprecation>>.
   
   ==== Referencing tasks and domain objects by `"name"()` in Kotlin DSL
   
   In Kotlin DSL, it is possible to reference a task or other domain object by its name using the `"name"()` notation.
   
   There are several ways to look up an element in a container by name:
   ```
   tasks {
       "wrapper"() // 1 - returns TaskProvider<Task>
       "wrapper"(Wrapper::class) // 2 - returns TaskProvider<Wrapper>
       "wrapper"(Wrapper::class) { // 3 - configures a task named wrapper of type Wrapper
       }
       "wrapper" { // 4 - configures a task named wrapper of type Task
       }
   }
   ```
   
   The first notation is deprecated and will be removed in Gradle 9.0.
   Instead of using `"name"()` to reference a task or domain object, use `named("name")` or one of the other supported notations.
   
   The above example would be written:
   ```
   tasks {
       named("wrapper") // returns TaskProvider<Task>
   }
   ```
   
   Groovy DSL build scripts and the Gradle API are not impacted by this.
   
   ==== Deprecated invalid URL decoding behavior
   Prior to Gradle 8.3, Gradle would decode a `CharSequence` given to `link:{groovyDslPath}#[Project.uri(Object)]` using an algorithm that accepted invalid URLs and improperly decoded others.
   Gradle now uses the `URI` class to parse and decode URLs, but with a fallback to the legacy behavior in the event of an error.
   
   Starting in Gradle 9.0, the fallback will be removed, and an error will be thrown instead.
   
   To fix a deprecation warning, invalid URLs that require the legacy behavior should be re-encoded to be valid URLs, such as in the following examples:
   
   .Legacy URL Conversions
   |===
   | Original Input | New Input | Reasoning
   
   | `file:relative/path` | `relative/path` | The `file` scheme does not support relative paths.
   | `file:relative/path%21` | `relative/path!` | Without a scheme, the path is taken as-is, without decoding.
   | `https://example.com/my folder/` | `https://example.com/my%20folder/` | Spaces are not valid in URLs.
   | `https://example.com/my%%badly%encoded%path` | `https://example.com/my%25%25badly%25encoded%25path` | `%` must be encoded as `%25` in URLs, and no `%`-escapes should be invalid.
   |===
   
   ==== Deprecated `SelfResolvingDependency`
   
   The `SelfResolvingDependency` interface has been deprecated for removal in Gradle 9.0.
   This type dates back to the first versions of Gradle, where some dependencies could be resolved independently.
   Now, all dependencies should be resolved as part of a dependency graph using a `Configuration`.
   
   Currently, `ProjectDependency` and `FileCollectionDependency` implement this interface.
   In Gradle 9.0, these types will no longer implement `SelfResolvingDependency`.
   Instead, they will both directly implement `Dependency`.
   
   As such, the following methods of `ProjectDependency` and `FileCollectionDependency` will no longer be avaDilable:
   
   - `resolve`
   - `resolve(boolean)`
   - `getBuildDependencies`
   
   Consider the following scripts that showcase the deprecated interface and its replacement:
   
   =====
   [.multi-language-sample]
   ======
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("java-library")
   }
   
   dependencies {
       implementation(files("bar.txt"))
       implementation(project(":foo"))
   }
   
   tasks.register("resolveDeprecated") {
       // Wire build dependencies (calls getBuildDependencies)
       dependsOn(configurations["implementation"].dependencies.toSet())
   
       // Resolve dependencies
       doLast {
           configurations["implementation"].dependencies.withType<FileCollectionDependency>() {
               assert(resolve().map { it.name } == listOf("bar.txt"))
               assert(resolve(true).map { it.name } == listOf("bar.txt"))
           }
           configurations["implementation"].dependencies.withType<ProjectDependency>() {
               // These methods do not even work properly.
               assert(resolve().map { it.name } == listOf<String>())
               assert(resolve(true).map { it.name } == listOf<String>())
           }
       }
   }
   
   tasks.register("resolveReplacement") {
       val conf = configurations["runtimeClasspath"]
   
       // Wire build dependencies
       dependsOn(conf)
   
       // Resolve dependencies
       val files = conf.files
       doLast {
           assert(files.map { it.name } == listOf("bar.txt", "foo.jar"))
       }
   }
   ----
   ======
   =====
   
   ==== Deprecated members of the `org.gradle.util` package now report their deprecation
   
   These members will be removed in Gradle 9.0.
   
   * `Collection.stringize(Collection)`
   
   == Upgrading from 8.5 and earlier
   
   === Potential breaking changes
   
   ==== Upgrade to JaCoCo 0.8.11
   
   JaCoCo has been updated to https://www.jacoco.org/jacoco/trunk/doc/changes.html[0.8.11].
   
   ==== `DependencyAdder` renamed to `DependencyCollector`
   
   The incubating `DependencyAdder` interface has been renamed to link:{javadocPath}#[`DependencyCollector`].
   A `getDependencies` method has been added to the interface that returns all declared dependencies.
   
   === Deprecations
   
   ==== Deprecated calling `registerFeature` using the `main` source set
   
   Calling `link:{javadocPath}#[registerFeature]` on the `link:{javadocPath}#[java]` extension using the `main` source set is deprecated and will change behavior in Gradle 9.0.
   
   Currently, features created while calling `link:{javadocPath}#[usingSourceSet]` with the `main` source set are initialized differently than features created while calling `usingSourceSet` with any other source set.
   Previously, when using the `main` source set, new `implementation`, `compileOnly`, `runtimeOnly`, `api`, and `compileOnlyApi` configurations were created, and the compile and runtime classpaths of the `main` source set were configured to extend these configurations.
   
   Starting in Gradle 9.0, the `main` source set will be treated like any other source set.
   With the `java-library` plugin applied (or any other plugin that applies the `java` plugin), calling `usingSourceSet` with the `main` source set will throw an exception.
   This is because the `java` plugin already configures a main feature.
   Only if the `java` plugin is not applied will the `main` source set be permitted when calling `usingSourceSet`.
   
   Code that currently registers features with the main source set, like so:
   =====
   [.multi-language-sample]
   ======
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("java-library")
   }
   
   java {
       registerFeature("feature") {
           usingSourceSet(sourceSets["main"])
       }
   }
   ----
   ======
   [.multi-language-sample]
   ======
   .build.gradle
   [source,groovy]
   ----
   plugins {
       id("java-library")
   }
   
   java {
       registerFeature("feature") {
           usingSourceSet(sourceSets.main)
       }
   }
   ----
   ======
   =====
   
   Should instead create a separate source set for the feature, and register the feature with that source set:
   =====
   [.multi-language-sample]
   ======
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("java-library")
   }
   
   sourceSets {
       create("feature")
   }
   
   java {
       registerFeature("feature") {
           usingSourceSet(sourceSets["feature"])
       }
   }
   ----
   ======
   [.multi-language-sample]
   ======
   .build.gradle
   [source,groovy]
   ----
   plugins {
       id("java-library")
   }
   
   sourceSets {
       feature
   }
   
   java {
       registerFeature("feature") {
           usingSourceSet(sourceSets.feature)
       }
   }
   ----
   ======
   =====
   
   ==== Deprecated publishing artifact dependencies with explicit name to Maven repositories
   
   Publishing dependencies with an explicit artifact with a name different from the dependency's `artifactId` to Maven repositories has been deprecated.
   This behavior is still permitted when publishing to Ivy repositories.
   It will result in an error in Gradle 9.0.
   
   Currently, when publishing to Maven repositories, Gradle will interpret the dependency below as if it were declared with coordinates `org:notfoo:1.0`.
   
   =====
   [.multi-language-sample]
   ======
   .build.gradle.kts
   [source,kotlin]
   ----
   dependencies {
       implementation("org:foo:1.0") {
           artifact {
               name = "notfoo"
           }
       }
   }
   ----
   ======
   [.multi-language-sample]
   ======
   .build.gradle
   [source,groovy]
   ----
   dependencies {
       implementation("org:foo:1.0") {
           artifact {
               name = "notfoo"
           }
       }
   }
   ----
   ======
   =====
   
   Instead, this dependency should be declared as:
   
   =====
   [.multi-language-sample]
   ======
   .build.gradle.kts
   [source,kotlin]
   ----
   dependencies {
       implementation("org:notfoo:1.0")
   }
   ----
   ======
   [.multi-language-sample]
   ======
   .build.gradle
   [source,groovy]
   ----
   dependencies {
       implementation("org:notfoo:1.0")
   }
   ----
   ======
   =====
   
   ==== Deprecated `ArtifactIdentifier`
   The `ArtifactIdentifier` class has been deprecated for removal in Gradle 9.0.
   
   ==== Deprecate mutating `DependencyCollector` dependencies after observation
   
   Starting in Gradle 9.0, mutating dependencies sourced from a link:{javadocPath}#[DependencyCollector] after those dependencies have been observed will result in an error.
   The `DependencyCollector` interface is used to declare dependencies within the test suites DSL.
   
   Consider the following example where a test suite's dependency is mutated after it is observed:
   
   =====
   [.multi-language-sample]
   ======
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("java-library")
   }
   
   testing.suites {
       named<JvmTestSuite>("test") {
           dependencies {
               // Dependency is declared on a `DependencyCollector`
               implementation("com:foo")
           }
       }
   }
   
   configurations.testImplementation {
       // Calling `all` here realizes/observes all lazy sources, including the `DependencyCollector`
       // from the test suite block. Operations like resolving a configuration similarly realize lazy sources.
       dependencies.all {
           if (this is ExternalDependency && group == "com" && name == "foo" && version == null) {
               // Dependency is mutated after observation
               version {
                   require("2.0")
               }
           }
       }
   }
   ----
   ======
   =====
   
   In the above example, the build logic uses iteration and mutation to try to set a default version for a particular dependency if the version is not already set.
   Build logic like the above example creates challenges in resolving declared dependencies, as reporting tools will display this dependency as if the user declared the version as "2.0", even though they never did.
   Instead, the build logic can avoid iteration and mutation by declaring a `preferred` version constraint on the dependency's coordinates.
   This allows the dependency management engine to use the version declared on the constraint if no other version is declared.
   
   Consider the following example that replaces the above iteration with an indiscriminate <<rich_versions.adoc#sec:preferred-version,preferred>> version constraint:
   
   =====
   [.multi-language-sample]
   ======
   .build.gradle.kts
   [source,kotlin]
   ----
   dependencies {
       constraints {
           testImplementation("com:foo") {
               version {
                   prefer("2.0")
               }
           }
       }
   }
   ----
   ======
   =====
   
   == Upgrading from 8.4 and earlier
   
   === Potential breaking changes
   
   ==== Upgrade to Kotlin 1.9.20
   
   The embedded Kotlin has been updated to link:https://github.com/JetBrains/kotlin/releases/tag/v1.9.20[Kotlin 1.9.20].
   
   ==== Changes to Groovy task conventions
   
   The `groovy-base` plugin is now responsible for configuring source and target compatibility version conventions on all `GroovyCompile` tasks.
   
   If you are using this task *without applying `grooy-base`*, you will have to manually set compatibility versions on these tasks.
   In general, the `groovy-base` plugin should be applied whenever working with Groovy language tasks.
   
   ==== Provider.filter
   
   The type of the argument passed to `Provider.filter` is changed from `Predicate` to `Spec` for a more consistent API.
   This change should not affect anyone using `Provider.filter` with a lambda expression.
   However, this might affect plugin authors if they don't use SAM conversions to create a lambda.
   
   === Deprecations
   
   ==== Deprecated members of the `org.gradle.util` package now report their deprecation
   
   These members will be removed in Gradle 9.0:
   
   * `VersionNumber.parse(String)`
   * `VersionNumber.compareTo(VersionNumber)`
   
   ==== Deprecated depending on resolved configuration
   
   When resolving a `Configuration`, it is sometimes possible to select that same configuration as a variant.
   Configurations should be used for one purpose (resolution, consumption or dependency declarations), so this can only occur when a configuration is marked as both consumable and resolvable.
   
   This can lead to confusing circular dependency graphs, as the configuration being resolved is used for two different purposes.
   
   To avoid this problem, plugins should mark all resolvable configurations as `canBeConsumed=false` or use the `resolvable(String)` configuration factory method when creating configurations meant for resolution.
   
   In Gradle 9.0, consuming configurations in this manner will no longer be allowed and will result in an error.
   
   ==== Including projects without an existing directory
   
   Gradle will warn if a project is added to the build where the associated `projectDir` does not exist or is not writable.
   Starting with version 9.0, Gradle will not run builds if a project directory is missing or read-only.
   If you intend to dynamically synthesize projects make sure to create directories for them as well:
   
   =====
   [.multi-language-sample]
   ======
   .settings.gradle.kts
   [source,kotlin]
   ----
   include("project-without-directory")
   project(":project-without-directory").projectDir.mkdirs()
   ----
   ======
   [.multi-language-sample]
   ======
   .settings.gradle
   [source,groovy]
   ----
   include 'project-without-directory'
   project(":project-without-directory").projectDir.mkdirs()
   ----
   ======
   =====
   
   
   == Upgrading from 8.3 and earlier
   
   === Potential breaking changes
   
   ==== Upgrade to Kotlin 1.9.10
   
   The embedded Kotlin has been updated to link:https://github.com/JetBrains/kotlin/releases/tag/v1.9.10[Kotlin 1.9.10].
   
   ==== XML parsing now requires recent parsers
   
   Gradle 8.4 now configures XML parsers with security features enabled.
   If your build logic has dependencies on old XML parsers that don't support secure parsing, your build may now fail.
   If you encounter a failure, check and update or remove any dependency on legacy XML parsers.
   
   If you are unable to upgrade XML parsers coming from your build logic dependencies, you can force the use of the XML parsers built into the JVM.
   For example, in OpenJDK this can be done by adding the following to `gradle.properties`:
   ```
   systemProp.javax.xml.parsers.SAXParserFactory=com.sun.org.apache.xerces.internal.jaxp.SAXParserFactoryImpl
   systemProp.javax.xml.transform.TransformerFactory=com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl
   systemProp.javax.xml.parsers.DocumentBuilderFactory=com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl
   ```
   See the link:https://github.com/gradle/gradle/security/advisories/GHSA-mrff-q8qj-xvg8[CVE-2023-42445] advisory for more details and ways to enable secure XML processing on previous Gradle versions.
   
   ==== EAR plugin with customized JEE 1.3 descriptor
   
   Gradle 8.4 forbids external XML entities when parsing XML documents.
   If you use the EAR plugin and configure the `application.xml` descriptor via the EAR plugin's DSL and customize the descriptor using `withXml {}` and use `asElement{}` in the customization block, then the build will now fail for security reasons.
   
   =====
   [.multi-language-sample]
   ======
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("ear")
   }
   ear {
       deploymentDescriptor {
           version = "1.3"
           withXml {
               asElement()
           }
       }
   }
   ----
   ======
   [.multi-language-sample]
   ======
   .build.gradle
   [source,groovy]
   ----
   plugins {
       id("ear")
   }
   ear {
       deploymentDescriptor {
           version = "1.3"
           withXml {
               asElement()
           }
       }
   }
   ----
   ======
   =====
   
   If you happen to use `asNode()` instead of `asElement()` then nothing changes given `asNode()` simply ignores external DTDs.
   
   You can work around this by running your build with the `javax.xml.accessExternalDTD` system property set to `http`.
   
   On the command line, add this to your Gradle invocation:
   
   [source,properties]
   ----
   -Djavax.xml.accessExternalDTD=http
   ----
   
   To make this workaround persistent, add the following line to your `gradle.properties`:
   
   [source,properties]
   ----
   systemProp.javax.xml.accessExternalDTD=http
   ----
   
   Note that this will enable HTTP access to external DTDs for the whole build JVM.
   See the link:https://docs.oracle.com/en/java/javase/13/security/java-api-xml-processing-jaxp-security-guide.html#GUID-8CD65EF5-D113-4D5C-A564-B875C8625FAC[JAXP documentation] for more details.
   
   === Deprecations
   
   ==== Deprecated `GenerateMavenPom` methods
   
   The following methods on `link:{javadocPath}#[GenerateMavenPom]` are deprecated and will be removed in Gradle 9.0.
   They were never intended to be public API.
   
   - `getVersionRangeMapper`
   - `withCompileScopeAttributes`
   - `withRuntimeScopeAttributes`
   
   == Upgrading from 8.2 and earlier
   
   === Potential breaking changes
   
   ==== Deprecated `Project.buildDir` can cause script compilation failure
   
   With the deprecation of `Project.buildDir`, buildscripts that are compiled with warnings as errors could fail if the deprecated field is used.
   
   See <<#project_builddir, the deprecation entry>> for details.
   
   ==== `TestLauncher` API no longer ignores build failures
   
   The `TestLauncher` interface is part of the Tooling API, specialized for running tests.
   It is a logical extension of the `BuildLauncher` that can only launch tasks.
   A discrepancy has been reported in their behavior: if the same failing test is executed, `BuildLauncher` will report a build failure but `TestLauncher` won't.
   Originally, this was a design decision in order to continue the execution and run the tests in all test tasks and not stop at the first failure.
   At the same time, this behavior can be confusing for users as they can experience a failing test in a successful build.
   To make the two APIs more uniform, we made `TestLauncher` also fail the build, which is a potential breaking change.
   To continue the test execution even if a test task failed, Tooling API clients should explicitly pass `--continue` to the build.
   
   ==== Fixed variant selection behavior with `ArtifactView` and `ArtifactCollection`
   
   The dependency resolution APIs for selecting different artifacts or files (`Configuration.getIncoming().artifactView { }` and `Configuration.getIncoming().getArtifacts()`) captured immutable copies of the underlying `Configuration`'s attributes to use for variant selection.
   If the `Configuration`'s attributes were changed after these methods were called, the artifacts selected by these methods could be unexpected.
   
   Consider the case where the set of attributes on a `Configuration` is changed after an `ArtifactView` is created.
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   tasks {
       myTask {
           inputFiles.from(configurations.classpath.incoming.artifactView {
               attributes {
                   // Add attributes to select a different type of artifact
               }
           }.files)
       }
   }
   
   configurations {
       classpath {
           attributes {
               // Add more attributes to the configuration
           }
       }
   }
   
   ----
   =====
   ====
   
   The `inputFiles` property of `myTask` uses an artifact view to select a different type of artifact from the configuration `classpath`.
   Since the artifact view was created before the attributes were added to the configuration, Gradle was not able to select the correct artifact.
   
   Some builds may have worked around this by also putting the additional attributes into the artifact view. This is no longer necessary.
   
   ==== Upgrade to Kotlin 1.9.0
   
   The embedded Kotlin has been updated from 1.8.20 to link:https://github.com/JetBrains/kotlin/releases/tag/v1.9.0[Kotlin 1.9.0].
   The Kotlin language and API levels for the Kotlin DSL are still set to 1.8 for backwards compatibility.
   See the release notes for link:https://github.com/JetBrains/kotlin/releases/tag/v1.8.22[Kotlin 1.8.22] and link:https://github.com/JetBrains/kotlin/releases/tag/v1.8.21[Kotlin 1.8.21].
   
   Kotlin 1.9 dropped support for Kotlin language and API level 1.3.
   If you build Gradle plugins written in Kotlin with this version of Gradle and need to support Gradle <7.0 you need to stick to using the Kotlin Gradle Plugin <1.9.0 and configure the Kotlin language and API levels to 1.3.
   See the <<compatibility.adoc#compatibility, Compatibility Matrix>> for details about other versions.
   
   ==== Eager evaluation of `Configuration` attributes
   
   Gradle 8.3 updates the `org.gradle.libraryelements` and `org.gradle.jvm.version` attributes of JVM Configurations to be present at the time of creation, as opposed to previously, where they were only present after the Configuration had been resolved or consumed.
   In particular, the value for `org.gradle.jvm.version` relies on the project's configured toolchain, meaning that querying the value for this attribute will finalize the value of the project's Java toolchain.
   
   Plugins or build logic that eagerly queries the attributes of JVM configurations may now cause the project's Java toolchain to be finalized earlier than before.
   Attempting to modify the toolchain after it has been finalized will result in error messages similar to the following:
   ```
   The value for property 'implementation' is final and cannot be changed any further.
   The value for property 'languageVersion' is final and cannot be changed any further.
   The value for property 'vendor' is final and cannot be changed any further.
   ```
   
   This situation may arise when plugins or build logic eagerly queries an existing JVM Configuration's attributes to create a new Configuration with the same attributes.
   Previously, this logic would have omitted the two above noted attributes entirely, while now the same logic will copy the attributes and finalize the project's Java toolchain.
   To avoid early toolchain finalization, attribute-copying logic should be updated to query the source Configuration's attributes lazily:
   
   =====
   [.multi-language-sample]
   ======
   .build.gradle.kts
   [source,kotlin]
   ----
   fun <T> copyAttribute(attribute: Attribute<T>, from: AttributeContainer, to: AttributeContainer) =
       to.attributeProvider<T>(attribute, provider { from.getAttribute(attribute)!! })
   
   val source = configurations["runtimeClasspath"].attributes
   configurations {
       create("customRuntimeClasspath") {
           source.keySet().forEach { key ->
               copyAttribute(key, source, attributes)
           }
       }
   }
   ----
   ======
   [.multi-language-sample]
   ======
   .build.gradle
   [source,groovy]
   ----
   def source = configurations.runtimeClasspath.attributes
   configurations {
       customRuntimeClasspath {
           source.keySet().each { key ->
               attributes.attributeProvider(key, provider { source.getAttribute(key) })
           }
       }
   }
   ----
   ======
   =====
   
   
   === Deprecations
   
   ==== Deprecated `Project.buildDir` is to be replaced by `Project.layout.buildDirectory`
   
   The `Project.buildDir` property is deprecated.
   It uses eager APIs and has ordering issues if the value is read in build logic and then later modified.
   It could result in outputs ending up in different locations.
   
   It is replaced by a `link:{javadocPath}#[DirectoryProperty]` found at `Project.layout.buildDirectory`.
   See the `link:{groovyDslPath}#[ProjectLayout]` interface for details.
   
   Note that, at this stage, Gradle will not print deprecation warnings if you still use `Project.buildDir`.
   We know this is a big change and want to give time for authors of major plugins to move away from its usage first.
   
   The switch from a `File` to a `DirectoryProperty` requires adaptations in build logic.
   The main impact is that you cannot use the property inside a `String` to expand it.
   Instead, you should leverage the `dir` and `file` methods to compute the location you want.
   
   Here is an example for creating a file, where the following:
   
   =====
   [.multi-language-sample]
   ======
   .build.gradle.kts
   [source,kotlin]
   ----
   // Returns a java.io.File
   file("$buildDir/myOutput.txt")
   ----
   ======
   [.multi-language-sample]
   ======
   .build.gradle
   [source,groovy]
   ----
   // Returns a java.io.File
   file("$buildDir/myOutput.txt")
   ----
   ======
   =====
   
   should be replaced by:
   
   =====
   [.multi-language-sample]
   ======
   .build.gradle.kts
   [source,kotlin]
   ----
   // Compatible with a number of Gradle lazy APIs that accept also java.io.File
   val output: Provider<RegularFile> = layout.buildDirectory.file("myOutput.txt")
   
   // If you really need the java.io.File for a non lazy API
   output.get().asFile
   
   // Or a path for a lazy String based API
   output.map { it.asFile.path }
   ----
   ======
   [.multi-language-sample]
   ======
   .build.gradle
   [source,groovy]
   ----
   // Compatible with a number of Gradle lazy APIs that accept also java.io.File
   Provider<RegularFile> output = layout.buildDirectory.file("myOutput.txt")
   
   // If you really need the java.io.File for a non lazy API
   output.get().asFile
   
   // Or a path for a lazy String based API
   output.map { it.asFile.path }
   ----
   ======
   =====
   
   Here is another example for creating a directory, where the following:
   
   =====
   [.multi-language-sample]
   ======
   .build.gradle.kts
   [source,kotlin]
   ----
   // Returns a java.io.File
   file("$buildDir/outputLocation")
   ----
   ======
   [.multi-language-sample]
   ======
   .build.gradle
   [source,groovy]
   ----
   // Returns a java.io.File
   file("$buildDir/outputLocation")
   ----
   ======
   =====
   
   should be replaced by:
   
   =====
   [.multi-language-sample]
   ======
   .build.gradle.kts
   [source,kotlin]
   ----
   // Compatible with a number of Gradle APIs that accept a java.io.File
   val output: Provider<Directory> = layout.buildDirectory.dir("outputLocation")
   
   // If you really need the java.io.File for a non lazy API
   output.get().asFile
   
   // Or a path for a lazy String based API
   output.map { it.asFile.path }
   ----
   ======
   [.multi-language-sample]
   ======
   .build.gradle
   [source,groovy]
   ----
   // Compatible with a number of Gradle APIs that accept a java.io.File
   Provider<Directory> output = layout.buildDirectory.dir("outputLocation")
   
   // If you really need the java.io.File for a non lazy API
   output.get().asFile
   
   // Or a path for a lazy String based API
   output.map { it.asFile.path }
   ----
   ======
   =====
   
   ==== Deprecated `ClientModule` dependencies
   
   `link:{javadocPath}#[ClientModule]` dependencies are deprecated and will be removed in Gradle 9.0.
   
   Client module dependencies were originally intended to allow builds to override incorrect or missing component metadata of external dependencies by defining the metadata locally.
   This functionality has since been replaced by <<component_metadata_rules.adoc#sec:component_metadata_rules,Component Metadata Rules>>.
   
   Consider the following client module dependency example:
   
   =====
   [.multi-language-sample]
   ======
   .build.gradle.kts
   [source,kotlin]
   ----
   dependencies {
       implementation(module("org:foo:1.0") {
           dependency("org:bar:1.0")
           module("org:baz:1.0") {
               dependency("com:example:1.0")
           }
       })
   }
   ----
   ======
   [.multi-language-sample]
   ======
   .build.gradle
   [source,groovy]
   ----
   dependencies {
       implementation module("org:foo:1.0") {
           dependency "org:bar:1.0"
           module("org:baz:1.0") {
               dependency "com:example:1.0"
           }
       }
   }
   ----
   ======
   =====
   
   This can be replaced with the following component metadata rule:
   
   =====
   [.multi-language-sample]
   ======
   .build-logic/src/main/kotlin/my-plugin.gradle.kts
   [source,kotlin]
   ----
   @CacheableRule
   abstract class AddDependenciesRule @Inject constructor(val dependencies: List<String>) : ComponentMetadataRule {
       override fun execute(context: ComponentMetadataContext) {
           listOf("compile", "runtime").forEach { base ->
               context.details.withVariant(base) {
                   withDependencies {
                       dependencies.forEach {
                           add(it)
                       }
                   }
               }
           }
       }
   }
   ----
   .build.gradle.kts
   [source,kotlin]
   ----
   dependencies {
       components {
           withModule<AddDependenciesRule>("org:foo") {
               params(listOf(
                   "org:bar:1.0",
                   "org:baz:1.0"
               ))
           }
           withModule<AddDependenciesRule>("org:baz") {
               params(listOf("com:example:1.0"))
           }
       }
   
       implementation("org:foo:1.0")
   }
   ----
   ======
   [.multi-language-sample]
   ======
   .build-logic/src/main/groovy/my-plugin.gradle
   [source,groovy]
   ----
   @CacheableRule
   abstract class AddDependenciesRule implements ComponentMetadataRule {
   
       List<String> dependencies
   
       @Inject
       AddDependenciesRule(List<String> dependencies) {
           this.dependencies = dependencies
       }
   
       @Override
       void execute(ComponentMetadataContext context) {
           ["compile", "runtime"].each { base ->
               context.details.withVariant(base) {
                   withDependencies {
                       dependencies.each {
                           add(it)
                       }
                   }
               }
           }
       }
   }
   ----
   .build.gradle
   [source,groovy]
   ----
   dependencies {
       components {
           withModule("org:foo", AddDependenciesRule) {
               params([
                   "org:bar:1.0",
                   "org:baz:1.0"
               ])
           }
           withModule("org:baz", AddDependenciesRule) {
               params(["com:example:1.0"])
           }
       }
   
       implementation "org:foo:1.0"
   }
   ----
   ======
   =====
   
   ==== Earliest supported Develocity plugin version is 3.13.1
   
   Starting in Gradle 9.0, the earliest supported Develocity plugin version is 3.13.1.
   The plugin versions from 3.0 up to 3.13 will be ignored when applied.
   
   Upgrade to version 3.13.1 or later of the Develocity plugin.
   You can find the link:https://plugins.gradle.org/plugin/com.gradle.enterprise[latest available version on the Gradle Plugin Portal].
   More information on the compatibility can be found link:https://docs.gradle.com/enterprise/compatibility/#build_scans[here].
   
   == Upgrading from 8.1 and earlier
   
   === Potential breaking changes
   
   ==== Upgrade to Kotlin 1.8.20
   
   The embedded Kotlin has been updated to link:https://github.com/JetBrains/kotlin/releases/tag/v1.8.20[Kotlin 1.8.20].
   For more information, see https://kotlinlang.org/docs/whatsnew1820.html[What's new in Kotlin 1.8.20].
   
   Note that there is a known issue with Kotlin compilation avoidance that can cause `OutOfMemory` exceptions in `compileKotlin` tasks if the compilation classpath contains very large JAR files.
   This applies to builds applying the Kotlin plugin v1.8.20 or the `kotlin-dsl` plugin.
   
   You can work around it by disabling Kotlin compilation avoidance in your `gradle.properties` file:
   
   [source,properties]
   ----
   kotlin.incremental.useClasspathSnapshot=false
   ----
   
   See link:https://youtrack.jetbrains.com/issue/KT-57757/[KT-57757] for more information.
   
   ==== Upgrade to Groovy 3.0.17
   
   Groovy has been updated to https://groovy-lang.org/changelogs/changelog-3.0.17.html[Groovy 3.0.17].
   
   Since the previous version was 3.0.15, the https://groovy-lang.org/changelogs/changelog-3.0.16.html[3.0.16] changes are also included.
   
   ==== Upgrade to Ant 1.10.13
   
   Ant has been updated to https://github.com/apache/ant/blob/rel/1.10.13/WHATSNEW[Ant 1.10.13].
   
   Since the previous version was 1.10.11, the https://github.com/apache/ant/blob/rel/1.10.12/WHATSNEW[1.10.12] changes are also included.
   
   ==== Upgrade to CodeNarc 3.2.0
   
   The default version of CodeNarc has been updated to https://github.com/CodeNarc/CodeNarc/blob/v3.2.0/CHANGELOG.md#version-320----jan-2023[CodeNarc 3.2.0].
   
   ==== Upgrade to PMD 6.55.0
   
   PMD has been updated to https://docs.pmd-code.org/pmd-doc-6.55.0/pmd_release_notes.html[PMD 6.55.0].
   
   Since the previous version was 6.48.0, all changes since then are included.
   
   ==== Upgrade to JaCoCo 0.8.9
   
   JaCoCo has been updated to https://www.jacoco.org/jacoco/trunk/doc/changes.html[0.8.9].
   
   ==== Plugin compatibility changes
   
   A plugin compiled with Gradle >= 8.2 that makes use of the Kotlin DSL functions link:{kotlinDslPath}/gradle/org.gradle.kotlin.dsl/the.html[`Project.the<T>()`], link:{kotlinDslPath}/gradle/org.gradle.kotlin.dsl/the.html[`Project.the(KClass)`] or link:{kotlinDslPath}/gradle/org.gradle.kotlin.dsl/configure.html[`Project.configure<T> {}`] cannot run on Gradle <= 6.1.
   
   ==== Deferred or avoided configuration of some tasks
   
   When performing dependency resolution, Gradle creates an internal representation of the available link:{javadocPath}#[Configuration]s.
   This requires inspecting all configurations and artifacts.
   Processing artifacts created by tasks causes those tasks to be realized and configured.
   
   This internal representation is now created more lazily, which can change the order in which tasks are configured.
   Some tasks may never be configured.
   
   This change may cause code paths that relied on a particular order to no longer function, such as conditionally adding attributes to a configuration based on the presence of certain attributes.
   
   This impacted the link:https://github.com/bndtools/bnd/issues/5695[bnd plugin and JUnit5 build].
   
   We recommend not modifying domain objects (configurations, source sets, tasks, etc) from configuration blocks for other domain objects that may not be configured.
   
   For example, avoid doing something like this:
   
   ```kotlin
       configurations {
           val myConfig = create("myConfig")
       }
   
       tasks.register("myTask") {
               // This is not safe, as the execution of this block may not occur, or may not occur in the order expected
             configurations["myConfig"].attributes {
                 attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage::class.java, Usage.JAVA_RUNTIME))
             }
       }
   ```
   
   === Deprecations
   
   ==== `link:{javadocPath}#[CompileOptions]` method deprecations
   
   The following methods on `CompileOptions` are deprecated:
   
   - `getAnnotationProcessorGeneratedSourcesDirectory()`
   - `setAnnotationProcessorGeneratedSourcesDirectory(File)`
   - `setAnnotationProcessorGeneratedSourcesDirectory(Provider<File>)`
   
   Current usages of these methods should migrate to `link:{javadocPath}#[DirectoryProperty getGeneratedSourceOutputDirectory()]`
   
   ==== Using configurations incorrectly
   
   Gradle will now warn at runtime when methods of link:{javadocPath}#[Configuration] are called inconsistently with the configuration's intended usage.
   
   This change is part of a larger ongoing effort to make the intended behavior of configurations more consistent and predictable, and to unlock further speed and memory improvements.
   
   Currently, the following methods should only be called with these listed allowed usages:
   
   - `resolve()` - RESOLVABLE configurations only
   - `files(Closure)`, `files(Spec)`, `files(Dependency)`, `fileCollection(Spec)`, `fileCollection(Closure)`, `fileCollection(Dependency)` - RESOLVABLE configurations only
   - `getResolvedConfigurations()` - RESOLVABLE configurations only
   - `defaultDependencies(Action)` - DECLARABLE configurations only
   - `shouldResolveConsistentlyWith(Configuration)` - RESOLVABLE configurations only
   - `disableConsistentResolution()` - RESOLVABLE configurations only
   - `getDependencyConstraints()` - DECLARABLE configurations only
   - `copy()`, `copy(Spec)`, `copy(Closure)`, `copyRecursive()`, `copyRecursive(Spec)`, `copyRecursive(Closure)` - RESOLVABLE configurations only
   
   Intended usage is noted in the `Configuration` interface's Javadoc.
   This list is likely to grow in future releases.
   
   Starting in Gradle 9.0, using a configuration inconsistently with its intended usage will be prohibited.
   
   Also note that although it is not currently restricted, the `getDependencies()` method is really only intended for use with DECLARABLE configurations.
   The `getAllDependencies()` method, which retrieves all declared dependencies on a configuration and any superconfigurations, will not be restricted to any particular usage.
   
   ==== Deprecated access to plugin conventions
   
   The concept of conventions is outdated and superseded by <<implementing_gradle_plugins_binary.adoc#modeling_dsl_like_apis, extensions>> to provide custom DSLs.
   
   To reflect this in the Gradle API, the following elements are deprecated:
   
   - link:{javadocPath}#[org.gradle.api.Project.getConvention()]
   - link:{javadocPath}#[org.gradle.api.plugins.Convention]
   - `org.gradle.api.internal.HasConvention`
   
   Gradle Core plugins still register their conventions in addition to their extensions for backwards compatibility.
   
   It is deprecated to access any of these conventions and their properties.
   Doing so will now emit a deprecation warning.
   This will become an error in Gradle 9.0.
   You should prefer accessing the extensions and their properties instead.
   
   For specific examples see the next sections.
   
   Prominent community plugins already migrated to using extensions to provide custom DSLs.
   Some of them still registers conventions for backwards compatibility.
   Registering conventions does not emit a deprecation warning yet to provide a migration window.
   Future Gradle versions will do.
   
   Also note that Plugins compiled with Gradle <= 8.1 that make use of the Kotlin DSL functions link:{kotlinDslPath}/gradle/org.gradle.kotlin.dsl/the.html[`Project.the<T>()`], link:{kotlinDslPath}/gradle/org.gradle.kotlin.dsl/the.html[`Project.the(KClass)`] or link:{kotlinDslPath}/gradle/org.gradle.kotlin.dsl/configure.html[`Project.configure<T> {}`] will emit a deprecation warning when run on Gradle >= 8.2.
   To fix this these plugins should be recompiled with Gradle >= 8.2 or changed to access extensions directly using `extensions.getByType<T>()` instead.
   
   ==== Deprecated `base` plugin conventions
   
   The convention properties contributed by the `base` plugin have been deprecated and scheduled for removal in Gradle 9.0.
   For the wider context see the <<deprecated_access_to_conventions, section about plugin convention deprecation>>.
   
   The conventions are replaced by the `base { }` configuration block backed by link:{groovyDslPath}#[BasePluginExtension].
   The old convention object defines the `distsDirName`, `libsDirName` and `archivesBaseName` properties with simple getter and setter methods.
   Those methods are available in the extension only to maintain backwards compatibility.
   Build scripts should solely use the properties of type `Property`:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       base
   }
   
   base {
       archivesName.set("gradle")
       distsDirectory.set(layout.buildDirectory.dir("custom-dist"))
       libsDirectory.set(layout.buildDirectory.dir("custom-libs"))
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   plugins {
       id 'base'
   }
   
   base {
       archivesName = "gradle"
       distsDirectory = layout.buildDirectory.dir('custom-dist')
       libsDirectory = layout.buildDirectory.dir('custom-libs')
   }
   ----
   =====
   ====
   
   ==== Deprecated `application` plugin conventions
   
   The convention properties contributed by the `application` plugin have been deprecated and scheduled for removal in Gradle 9.0.
   For the wider context see the <<deprecated_access_to_conventions, section about plugin convention deprecation>>.
   
   The following code will now emit deprecation warnings:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       application
   }
   
   applicationDefaultJvmArgs = listOf("-Dgreeting.language=en") // Accessing a convention
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   plugins {
       id 'application'
   }
   
   applicationDefaultJvmArgs = ['-Dgreeting.language=en'] // Accessing a convention
   ----
   =====
   ====
   
   This should be changed to use the `application { }` configuration block, backed by link:{groovyDslPath}#[JavaApplication], instead:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       application
   }
   
   application {
       applicationDefaultJvmArgs = listOf("-Dgreeting.language=en")
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   plugins {
       id 'application'
   }
   
   application {
       applicationDefaultJvmArgs = ['-Dgreeting.language=en']
   }
   ----
   =====
   ====
   
   ==== Deprecated `java` plugin conventions
   
   The convention properties contributed by the `java` plugin have been deprecated and scheduled for removal in Gradle 9.0.
   For the wider context see the <<deprecated_access_to_conventions, section about plugin convention deprecation>>.
   
   The following code will now emit deprecation warnings:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("java")
   }
   
   configure<JavaPluginConvention> { // Accessing a convention
       sourceCompatibility = JavaVersion.VERSION_18
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   plugins {
       id 'java'
   }
   
   sourceCompatibility = 18 // Accessing a convention
   ----
   =====
   ====
   
   This should be changed to use the `java { }` configuration block, backed by link:{groovyDslPath}#[JavaPluginExtension], instead:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("java")
   }
   
   java {
       sourceCompatibility = JavaVersion.VERSION_18
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   plugins {
       id 'java'
   }
   
   java {
       sourceCompatibility = JavaVersion.VERSION_18
   }
   ----
   =====
   ====
   
   ==== Deprecated `war` plugin conventions
   
   The convention properties contributed by the `war` plugin have been deprecated and scheduled for removal in Gradle 9.0.
   For the wider context see the <<deprecated_access_to_conventions, section about plugin convention deprecation>>.
   
   The following code will now emit deprecation warnings:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("war")
   }
   
   configure<WarPluginConvention> { // Accessing a convention
       webAppDirName = "src/main/webapp"
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   plugins {
       id 'war'
   }
   
   webAppDirName = 'src/main/webapp' // Accessing a convention
   ----
   =====
   ====
   
   Clients should configure the `war` task  directly.
   Also, link:{javadocPath}#[tasks.withType(War.class).configureEach(...)] can be used to configure each task of type `War`.
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("war")
   }
   
   tasks.war {
       webAppDirectory.set(file("src/main/webapp"))
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   plugins {
       id 'war'
   }
   
   war {
       webAppDirectory = file('src/main/webapp')
   }
   ----
   =====
   ====
   
   ==== Deprecated `ear` plugin conventions
   
   The convention properties contributed by the `ear` plugin have been deprecated and scheduled for removal in Gradle 9.0.
   For the wider context see the <<deprecated_access_to_conventions, section about plugin convention deprecation>>.
   
   The following code will now emit deprecation warnings:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("ear")
   }
   
   configure<EarPluginConvention> { // Accessing a convention
       appDirName = "src/main/app"
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   plugins {
       id 'ear'
   }
   
   appDirName = 'src/main/app' // Accessing a convention
   ----
   =====
   ====
   
   Clients should configure the `ear` task directly.
   Also, link:{javadocPath}#[tasks.withType(Ear.class).configureEach(...)] can be used to configure each task of type `Ear`.
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("ear")
   }
   
   tasks.ear {
       appDirectory.set(file("src/main/app"))
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   plugins {
       id 'ear'
   }
   
   ear {
       appDirectory = file('src/main/app')  // use application metadata found in this folder
   }
   ----
   =====
   ====
   
   ==== Deprecated `project-report` plugin conventions
   
   The convention properties contributed by the `project-reports` plugin have been deprecated and scheduled for removal in Gradle 9.0.
   For the wider context see the <<deprecated_access_to_conventions, section about plugin convention deprecation>>.
   
   The following code will now emit deprecation warnings:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       `project-report`
   }
   
   configure<ProjectReportsPluginConvention> {
       projectReportDirName = "custom" // Accessing a convention
   }
   ----
   =====
   
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   plugins {
       id 'project-report'
   }
   
   projectReportDirName = "custom" // Accessing a convention
   ----
   =====
   ====
   
   Configure your report task instead:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       `project-report`
   }
   
   tasks.withType<HtmlDependencyReportTask>() {
       projectReportDirectory.set(project.layout.buildDirectory.dir("reports/custom"))
   }
   ----
   =====
   
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   plugins {
       id 'project-report'
   }
   
   tasks.withType(HtmlDependencyReportTask) {
       projectReportDirectory = project.layout.buildDirectory.dir("reports/custom")
   }
   ----
   =====
   ====
   
   ==== Redundant configuration usage activation
   
   Calling `setCanBeConsumed(boolean)` or `setCanBeResolved(boolean)` on a configuration that already allows that usage is deprecated.
   
   This deprecation is intended to help users identify unnecessary configuration usage modifications.
   
   ==== `link:{javadocPath}#[Configuration]` method deprecations
   
   The following method on `Configuration` is deprecated for removal:
   
   - `getAll()`
   
   Obtain the set of all configurations from the project's `configurations` container instead.
   
   ==== Relying on automatic test framework implementation dependencies
   
   In some cases, Gradle will load JVM test framework dependencies from the Gradle distribution in order to
   execute tests.
   This existing behavior can lead to test framework dependency version conflicts on the test
   classpath.
   To avoid these conflicts, this behavior is deprecated and will be removed in Gradle 9.0. Tests
   using TestNG are unaffected.
   
   In order to prepare for this change in behavior, either declare the required dependencies explicitly,
   or migrate to link:#[Test Suites], where these dependencies are managed automatically.
   
   ===== Test Suites
   
   Builds that use test suites will not be affected by this change.
   Test suites manage the test
   framework dependencies automatically and do not require dependencies to be explicitly declared.
   See link:#[the user manual] for further information on migrating to test suites.
   
   ===== Manually declaring dependencies
   
   In the absence of test suites, dependencies must be manually declared on the test runtime classpath:
   
     * If using JUnit 5, an explicit `runtimeOnly` dependency on `junit-platform-launcher` is required
     in addition to the existing `implementation` dependency on the test engine.
     * If using JUnit 4, only the existing `implementation` dependency on `junit` 4 is required.
     * If using JUnit 3, a test `runtimeOnly` dependency on `junit` 4 is required in addition to a
     `compileOnly` dependency on `junit` 3.
   
   =====
   [.multi-language-sample]
   ======
   .build.gradle.kts
   [source,kotlin]
   ----
   dependencies {
       // If using JUnit Jupiter
       testImplementation("org.junit.jupiter:junit-jupiter:5.9.2")
       testRuntimeOnly("org.junit.platform:junit-platform-launcher")
   
       // If using JUnit Vintage
       testCompileOnly("junit:junit:4.13.2")
       testRuntimeOnly("org.junit.vintage:junit-vintage-engine:5.9.2")
       testRuntimeOnly("org.junit.platform:junit-platform-launcher")
   
       // If using JUnit 4
       testImplementation("junit:junit:4.13.2")
   
       // If using JUnit 3
       testCompileOnly("junit:junit:3.8.2")
       testRuntimeOnly("junit:junit:4.13.2")
   }
   ----
   ======
   [.multi-language-sample]
   ======
   .build.gradle
   [source,groovy]
   ----
   dependencies {
       // If using JUnit Jupiter
       testImplementation 'org.junit.jupiter:junit-jupiter:5.9.2'
       testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
   
       // If using JUnit Vintage
       testCompileOnly 'junit:junit:4.13.2'
       testRuntimeOnly 'org.junit.vintage:junit-vintage-engine:5.9.2'
       testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
   
       // If using JUnit 4
       testImplementation 'junit:junit:4.13.2'
   
       // If using JUnit 3
       testCompileOnly 'junit:junit:3.8.2'
       testRuntimeOnly 'junit:junit:4.13.2'
   }
   ----
   ======
   =====
   
   ==== `link:{javadocPath}#[BuildIdentifier]` and `link:{javadocPath}#[ProjectComponentSelector]` method deprecations
   
   The following methods on `BuildIdentifier` are deprecated:
   
   - `getName()`
   - `isCurrentBuild()`
   
   You could use these methods to distinguish between different project components with the same name but from different builds.
   However, for certain composite build setups, these methods do not provide enough information to guarantee uniqueness.
   
   Current usages of these methods should migrate to `link:{javadocPath}#[BuildIdentifier.getBuildPath()]`.
   
   Similarly, the method `ProjectComponentSelector.getBuildName()` is deprecated.
   Use `link:{javadocPath}#[ProjectComponentSelector.getBuildPath()]` instead.
   
   == Upgrading from 8.0 and earlier
   
   === CACHEDIR.TAG files are created in global cache directories
   Gradle now emits a `CACHEDIR.TAG` file in some global cache directories, as specified in <<directory_layout#dir:gradle_user_home:cache_marking>>.
   
   This may cause these directories to no longer be searched or backed up by some tools. To disable it, use the following code in an <<init_scripts#sec:using_an_init_script,init script>> in the Gradle User Home:
   
   ====
   [.multi-language-sample]
   =====
   .init.gradle.kts
   [source,kotlin]
   ----
   beforeSettings {
       caches {
           // Disable cache marking for all caches
           markingStrategy.set(MarkingStrategy.NONE)
       }
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .init.gradle
   [source,groovy]
   ----
   beforeSettings { settings ->
       settings.caches {
           // Disable cache marking for all caches
           markingStrategy = MarkingStrategy.NONE
       }
   }
   ----
   =====
   ====
   
   === Configuration cache options renamed
   
   In this release, the configuration cache feature was promoted from incubating to stable, and as such, all properties
   originally mentioned in the feature documentation (which had an `unsafe` part in their names, e.g. `org.gradle.unsafe.configuration-cache`) were renamed, in some cases, by just removing the `unsafe` bit.
   
   [cols="1,1", options="header"]
   |===
   
   | Incubating property
   | Finalized property
   
   |`org.gradle.unsafe.configuration-cache`
   |`org.gradle.configuration-cache`
   
   |`org.gradle.unsafe.configuration-cache-problems`
   |`org.gradle.configuration-cache.problems`*
   
   |`org.gradle.unsafe.configuration-cache.max-problems`
   |`org.gradle.configuration-cache.max-problems`
   |===
   
   Note that the original `org.gradle.unsafe.configuration-cache...` properties continue to be honored in this release,
   and no warnings will be produced if they are used, but they will be deprecated and removed in a future release.
   
   === Potential breaking changes
   
   ==== Kotlin DSL scripts emit compilation warnings
   
   Compilation warnings from Kotlin DSL scripts are printed to the console output.
   For example, the use of deprecated APIs in Kotlin DSL will emit warnings each time the script is compiled.
   
   This is a potentially breaking change if you are consuming the console output of Gradle builds.
   
   ==== Configuring Kotlin compiler options with the `kotlin-dsl` plugin applied
   
   If you are configuring custom Kotlin compiler options on a project with the <<kotlin_dsl.adoc#sec:kotlin-dsl_plugin, kotlin-dsl>> plugin applied you might encounter a breaking change.
   
   In previous Gradle versions, the `kotlin-dsl` plugin was adding required compiler arguments on link:{javadocPath}#[afterEvaluate {}].
   Now that the Kotlin Gradle Plugin provides <<lazy_configuration.adoc#lazy_configuration, lazy configuration>> properties, our `kotlin-dsl` plugin switched to adding required compiler arguments to the lazy properties directly.
   As a consequence, if you were setting `freeCompilerArgs` the `kotlin-dsl` plugin is now failing the build because its required compiler arguments are overridden by your configuration.
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       `kotlin-dsl`
   }
   
   tasks.withType(KotlinCompile::class).configureEach {
       kotlinOptions { // Deprecated non-lazy configuration options
           freeCompilerArgs = listOf("-Xcontext-receivers")
       }
   }
   ----
   =====
   ====
   
   With the configuration above you would get the following build failure:
   
   [source,text]
   ----
   * What went wrong
   Execution failed for task ':compileKotlin'.
   > Kotlin compiler arguments of task ':compileKotlin' do not work for the `kotlin-dsl` plugin. The 'freeCompilerArgs' property has been reassigned. It must instead be appended to. Please use 'freeCompilerArgs.addAll(\"your\", \"args\")' to fix this.
   ----
   
   You must change this to adding your custom compiler arguments to the lazy configuration properties of the Kotlin Gradle Plugin in order for them to be appended to the ones required by the `kotlin-dsl` plugin:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       `kotlin-dsl`
   }
   
   tasks.withType(KotlinCompile::class).configureEach {
       compilerOptions { // New lazy configuration options
           freeCompilerArgs.addAll("-Xcontext-receivers")
       }
   }
   ----
   =====
   ====
   
   If you were already adding to `freeCompilerArgs` instead of setting its value, then you should not experience a build failure.
   
   ==== New API introduced may clash with existing Gradle DSL code
   
   When a new property or method is added to an existing type in the Gradle DSL, it may clash with names already in use in user code.
   
   When a name clash occurs, one solution is to rename the element in user code.
   
   This is a non-exhaustive list of API additions in 8.1 that may cause name collisions with existing user code.
   
   * link:{javadocPath}#[`JavaExec.getJvmArguments()`]
   * link:{javadocPath}#[`JavaExecSpec.getJvmArguments()`]
   
   ==== Using unsupported API to start external processes at configuration time is no longer allowed with the configuration cache enabled
   
   Since Gradle 7.5, using `Project.exec`, `Project.javaexec`, and standard Java and Groovy APIs to run external processes at configuration time has been considered an error only if the <<configuration_cache.adoc#config_cache:stable,feature preview `STABLE_CONFIGURATION_CACHE`>> was enabled.
   With the configuration cache promotion to a stable feature in Gradle 8.1, this error is detected regardless of the feature preview status.
   The <<configuration_cache#config_cache:requirements:external_processes,configuration cache chapter>> has more details to help with the migration to the new provider-based APIs to execute external processes at configuration time.
   
   Builds that do not use the configuration cache, or only start external processes at execution time are not affected by this change.
   
   === Deprecations
   
   ==== Mutating core plugin configuration usage
   
   The allowed usage of a configuration should be immutable after creation.
   Mutating the allowed usage on a configuration created by a Gradle core plugin is deprecated.
   This includes calling any of the following `Configuration` methods:
   
   - `setCanBeConsumed(boolean)`
   - `setCanBeResolved(boolean)`
   
   These methods now emit deprecation warnings on these configurations, except for certain special cases which make allowances for the existing behavior of popular plugins.
   This rule does not yet apply to detached configurations or configurations created
   in buildscripts and third-party plugins.
   Calling `setCanBeConsumed(false)` on `apiElements` or `runtimeElements`
   is not yet deprecated in order to avoid warnings that would be otherwise emitted when
   using select popular third-party plugins.
   
   This change is part of a larger ongoing effort to make the intended behavior of configurations more consistent and predictable, and to unlock further speed and memory improvements in this area of Gradle.
   
   The ability to change the allowed usage of a configuration after creation will be removed in Gradle 9.0.
   
   ==== Reserved configuration names
   
   Configuration names "detachedConfiguration" and "detachedConfigurationX" (where X is any integer) are reserved for internal use when creating detached configurations.
   
   The ability to create non-detached configurations with these names will be removed in Gradle 9.0.
   
   ==== Calling select methods on the `JavaPluginExtension` without the `java` component present
   
   Starting in Gradle 8.1, calling any of the following methods on `JavaPluginExtension` without
   the presence of the default `java` component is deprecated:
   
   - `withJavadocJar()`
   - `withSourcesJar()`
   - `consistentResolution(Action)`
   
   This `java` component is added by the `JavaPlugin`, which is applied by any of the Gradle JVM plugins including:
   
   - `java-library`
   - `application`
   - `groovy`
   - `scala`
   
   Starting in Gradle 9.0, calling any of the above listed methods without the presence of the default `java` component
   will become an error.
   
   ==== `WarPlugin#configureConfiguration(ConfigurationContainer)`
   
   Starting in Gradle 8.1, calling `WarPlugin#configureConfiguration(ConfigurationContainer)` is deprecated. This method was
   intended for internal use and was never intended to be used as part of the public interface.
   
   Starting in Gradle 9.0, this method will be removed without replacement.
   
   ==== Relying on conventions for custom Test tasks
   
   By default, when applying the link:#[`java`] plugin, the `testClassesDirs`and `classpath` of all `Test` tasks have the same convention.
   Unless otherwise changed, the default behavior is to execute the tests from the default `test` link:#[`TestSuite`] by configuring the task with the `classpath` and `testClassesDirs` from the `test` suite.
   This behavior will be removed in Gradle 9.0.
   
   While this existing default behavior is correct for the use case of executing the default unit test suite under a different environment, it does not support the use case of executing an entirely separate set of tests.
   
   If you wish to continue including these tests, use the following code to avoid the deprecation warning in 8.1 and prepare for the behavior change in 9.0.
   Alternatively, consider migrating to test suites.
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   val test by testing.suites.existing(JvmTestSuite::class)
   tasks.named<Test>("myTestTask") {
       testClassesDirs = files(test.map { it.sources.output.classesDirs })
       classpath = files(test.map { it.sources.runtimeClasspath })
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   tasks.myTestTask {
       testClassesDirs = testing.suites.test.sources.output.classesDirs
       classpath = testing.suites.test.sources.runtimeClasspath
   }
   ----
   =====
   ====
   
   
   ==== Modifying Gradle Module Metadata after a publication has been populated
   
   Altering the link:#[GMM] (e.g., changing a component configuration variants) *after* a Maven or Ivy publication has been populated from their components is now deprecated.
   This feature will be removed in Gradle 9.0.
   
   Eager population of the publication can happen if the following methods are called:
   
   * Maven
   ** link:{javadocPath}#[MavenPublication.getArtifacts()]
   * Ivy
   ** link:{javadocPath}#[IvyPublication.getArtifacts()]
   ** link:{javadocPath}#[IvyPublication.getConfigurations()]
   ** link:{javadocPath}#[IvyPublication.configurations(Action)]
   
   Previously, the following code did not generate warnings, but it created inconsistencies between published artifacts:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   publishing {
       publications {
           create<MavenPublication>("maven") {
               from(components["java"])
           }
           create<IvyPublication>("ivy") {
               from(components["java"])
           }
       }
   }
   
   // These calls eagerly populate the Maven and Ivy publications
   
   (publishing.publications["maven"] as MavenPublication).artifacts
   (publishing.publications["ivy"] as IvyPublication).artifacts
   
   val javaComponent = components["java"] as AdhocComponentWithVariants
   javaComponent.withVariantsFromConfiguration(configurations["apiElements"]) { skip() }
   javaComponent.withVariantsFromConfiguration(configurations["runtimeElements"]) { skip() }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   publishing {
       publications {
           maven(MavenPublication) {
               from components.java
           }
           ivy(IvyPublication) {
               from components.java
           }
       }
   }
   
   // These calls eagerly populate the Maven and Ivy publications
   
   publishing.publications.maven.artifacts
   publishing.publications.ivy.artifacts
   
   components.java.withVariantsFromConfiguration(configurations.apiElements) { skip() }
   components.java.withVariantsFromConfiguration(configurations.runtimeElements) { skip() }
   ----
   =====
   ====
   
   In this example, the Maven and Ivy publications will contain the main JAR artifacts for the project, whereas the GMM link:https://github.com/gradle/gradle/blob/master/platforms/documentation/docs/src/docs/design/gradle-module-metadata-latest-specification.md[module file] will omit them.
   
   ==== Running tests on JVM versions 6 and 7
   
   Running JVM tests on JVM versions older than 8 is deprecated.
   Testing on these versions will become an error in Gradle 9.0
   
   ==== Applying Kotlin DSL precompiled scripts published with Gradle < 6.0
   
   Applying Kotlin DSL precompiled scripts published with Gradle < 6.0 is deprecated.
   Please use a version of the plugin published with Gradle >= 6.0.
   
   ==== Applying the `kotlin-dsl` together with Kotlin Gradle Plugin < 1.8.0
   
   Applying the `kotlin-dsl` together with Kotlin Gradle Plugin < 1.8.0 is deprecated.
   Please let Gradle control the version of `kotlin-dsl` by removing any explicit `kotlin-dsl` version constraints from your build logic.
   This will let the `kotlin-dsl` plugin decide which version of the Kotlin Gradle Plugin to use.
   If you explicitly declare which version of the Kotlin Gradle Plugin to use for your build logic, update it to >= 1.8.0.
   
   ==== Accessing `libraries` or `bundles` from dependency version catalogs in the `plugins {}` block of a Kotlin script
   
   Accessing `libraries` or `bundles` from dependency version catalogs in the `plugins {}` block of a Kotlin script is deprecated.
   Please only use `versions` or `plugins` from dependency version catalogs in the `plugins {}` block.
   
   ==== Using `ValidatePlugins` task without a Java Toolchain
   
   Using a task of type link:{javadocPath}#[ValidatePlugins] without applying the link:#[Java Toolchains] plugin is deprecated, and will become an error in Gradle 9.0.
   
   To avoid this warning, please apply the plugin to your project:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("jvm-toolchains")
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   plugins {
       id 'jvm-toolchains'
   }
   ----
   =====
   ====
   
   The Java Toolchains plugin is applied automatically by the <<java_library_plugin#java_library_plugin,Java library plugin>> or other JVM plugins.
   So you can apply any of them to your project and it will fix the warning.
   
   ==== Deprecated members of the `org.gradle.util` package now report their deprecation
   
   These members will be removed in Gradle 9.0.
   
   * `WrapUtil.toDomainObjectSet(...)`
   * `GUtil.toCamelCase(...)`
   * `GUtil.toLowerCase(...)`
   * `ConfigureUtil`
   
   ==== Deprecated JVM vendor IBM Semeru
   
   The enum constant `JvmVendorSpec.IBM_SEMERU` is now deprecated and will be removed in Gradle 9.0.
   
   Please replace it by its equivalent `JvmVendorSpec.IBM` to avoid warnings and potential errors in the next major version release.
   
   ==== Setting custom build layout on `StartParameter` and `GradleBuild`
   
   Following the <<upgrading_version_7.adoc#configuring_custom_build_layout_7,related previous deprecation>> of the behaviour in Gradle 7.1, it is now also deprecated to use related link:{javadocPath}#[StartParameter] and link:{javadocPath}#[GradleBuild] properties.
   These properties will be removed in Gradle 9.0.
   
   Setting custom build file using link:{groovyDslPath}#[buildFile] property in link:{groovyDslPath}#[GradleBuild] task has been deprecated.
   
   Please use the link:{groovyDslPath}#[dir] property instead to specify the root of the nested build.
   Alternatively, consider using one of the recommended alternatives for link:{groovyDslPath}#[GradleBuild] task as suggested in <<authoring_maintainable_build_scripts#sec:avoiding_use_of_gradlebuild, Avoid using the GradleBuild task type>> section.
   
   Setting custom build layout using link:{javadocPath}#[StartParameter] methods link:{javadocPath}#[setBuildFile(File)] and link:{javadocPath}#[setSettingsFile(File)] as well as the counterpart getters link:{javadocPath}#[getBuildFile()] and link:{javadocPath}#[getSettingsFile()] have been deprecated.
   
   Please use standard locations for settings and build files:
   
   * settings file in the root of the build
   * build file in the root of each subproject
   
   ==== Deprecated org.gradle.cache.cleanup property
   
   The `org.gradle.cache.cleanup` property in `gradle.properties` under Gradle User Home has been deprecated.
   Please use the <<directory_layout#dir:gradle_user_home:configure_cache_cleanup,cache cleanup DSL>> instead to disable or modify the cleanup configuration.
   
   Since the `org.gradle.cache.cleanup` property may still be needed for older versions of Gradle, this property may still be present and no deprecation warnings will be printed as long as it is also configured via the DSL.
   The DSL value will always take preference over the `org.gradle.cache.cleanup` property.
   If the desired configuration is to disable cleanup for older versions of Gradle (using `org.gradle.cache.cleanup`), but to enable cleanup with the default values for Gradle versions at or above Gradle 8, then cleanup should be configured to use link:{javadocPath}#[Cleanup.DEFAULT]:
   
   ====
   [.multi-language-sample]
   =====
   .cache-settings.gradle
   [source,groovy]
   ----
   if (GradleVersion.current() >= GradleVersion.version('8.0')) {
       apply from: "gradle8/cache-settings.gradle"
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .cache-settings.gradle.kts
   [source,kotlin]
   ----
   if (GradleVersion.current() >= GradleVersion.version("8.0")) {
       apply(from = "gradle8/cache-settings.gradle")
   }
   ----
   =====
   ====
   ====
   [.multi-language-sample]
   =====
   .gradle8/cache-settings.gradle
   [source,groovy]
   ----
   beforeSettings { settings ->
       settings.caches {
           cleanup = Cleanup.DEFAULT
       }
   }
   ----
   =====
   =====
   .gradle8/cache-settings.gradle.kts
   [source,kotlin]
   ----
   beforeSettings {
       caches {
           cleanup.set(Cleanup.DEFAULT)
       }
   }
   ----
   =====
   ====
   
   [no_relative_paths_for_java_executables]
   ==== Deprecated using relative paths to specify Java executables
   Using relative file paths to point to Java executables is now deprecated and will become an error in Gradle 9.
   This is done to reduce confusion about what such relative paths should resolve against.
   
   ==== Calling `Task.getConvention()`, `Task.getExtensions()` from a task action
   
   Calling link:{javadocPath}#[Task.getConvention()], link:{javadocPath}#[Task.getExtensions()] from a task action at execution time is now deprecated and will be made an error in Gradle 9.0.
   
   See the <<configuration_cache#config_cache:requirements:disallowed_types,configuration cache chapter>> for details on how to migrate these usages to APIs that are supported by the configuration cache.
   
   ==== Deprecated running test task successfully when no test executed
   Running the `Test` task successfully when no test was executed is now deprecated and will become an error in Gradle 9.
   Note that it is not an error when no test sources are present, in this case the `test` task is simply skipped. It is only an error when test sources are present, but no test was selected for execution.
   This is changed to avoid accidental successful test runs due to erroneous configuration.
   
   === Changes in the IDE integration
   
   ==== Workaround for false positive errors shown in Kotlin DSL `plugins {}` block using version catalog is not needed anymore
   
   Version catalog accessors for plugin aliases in the `plugins {}` block aren't shown as errors in IntelliJ IDEA and Android Studio Kotlin script editor anymore.
   
   If you were using the `@Suppress("DSL_SCOPE_VIOLATION")` annotation as a workaround, you can now remove it.
   
   If you were using the link:https://plugins.jetbrains.com/plugin/18949-gradle-libs-error-suppressor[Gradle Libs Error Suppressor] IntelliJ IDEA plugin, you can now uninstall it.
   
   After upgrading Gradle to 8.1 you will need to clear the IDE caches and restart.
   
   Also see <<upgrading_version_8.adoc#kotlin_dsl_deprecated_catalogs_plugins_block, the deprecated usages of version catalogs in the Kotlin DSL `plugins {}` block>> above.

/docs/userguide/troubleshooting/validation_problems.adoc
========================================================

.. code-block::

   = Dealing with validation problems
   
   This page summarizes the different task (or in general work) validation problems that Gradle reports and provides guidance for fixing them.
   
   == Invalid use of cacheable annotation
   
   This error indicates that you have annotated a type with `@CacheableTransform` on something that is not an artifact transform, or `@CacheableTask` on something which is not a `Task`.
   
   The solution is to remove the annotation.
   
   For tasks, the annotation to use is `@CacheableTask`.
   For artifact transforms, the annotation to use is `@CacheableTransform`
   
   == Missing normalization annotation
   
   This error occurs whenever a task or artifact transform is cacheable and that a file or file collection input property isn't declaring how it should be normalized.
   Normalization tells Gradle if, for example, the absolute path of input files matter or if only the contents is relevant.
   If you don't declare the normalization strategy, outputs of the task cannot be reused between machines or between different locations on the same machine.
   In short, without normalization, caching is highly ineffective.
   
   To fix this problem, you need to declare a normalization strategy, by applying one of the following annotations:
   
   - link:{javadocPath}#[`PathSensitive`]
   - link:{javadocPath}#[`Classpath`]
   - link:{javadocPath}#[`CompileClasspath`]
   
   == Required value isn't set
   
   This error indicates that a property expected a value but none was provided.
   By default, Gradle properties are _required_, that is to say that if an input or output property isn't configured, either via a conventional value or explicitly by a build script, then Gradle will fail because it doesn't know what value to use when the task is executed.
   
   To fix the problem, you must either:
   
   - provide a value for this property explicitly (for example by configuring the task in your build script)
   - or make the property optional by annotating it with link:{javadocPath}#[`@Optional`]
   
   == Invalid use of absolute path sensitivity for an artifact transform
   
   This error indicates that you have annotated an input of a cacheable artifact transform as sensitive to the absolute path.
   However, artifact transforms are executed in isolation using their own workspace which, for example, is resilient to `clean` builds.
   Even if the artifact transform result can't be shared via the build cache, using an absolute path sensitivity doesn't make sense.
   
   To fix this problem, you must change the normalization strategy using one of those:
   
   - link:{javadocPath}#[`PathSensitive`] (but not absolute)
   - link:{javadocPath}#[`Classpath`]
   - link:{javadocPath}#[`CompileClasspath`]
   
   == Invalid use of an output property on an artifact transforms
   
   This error indicates that you have annotated a property of an artifact transform with an output annotation, which is not the correct way to register outputs for artifact transforms.
   
   To fix this problem, you must remove the property and use the `TransformOutputs` parameter instead.
   
   See link:{javadocPath}#[TransformAction#transform(TransformOutputs)] for details.
   
   == Invalid use of annotations on fields
   
   This error indicates that you have a field annotated, but that there's no getter for this field.
   Gradle will recognize annotations on fields _only_ if there's a corresponding getter.
   If this getter is absent, the annotations have no effect whatsoever.
   
   To fix this, you need to create a getter for this field.
   We also recommend to annotate the getter instead of the field.
   
   If you are using Groovy, it's likely that you unintentionally added the `private` modifier to a property declaration:
   
   ```groovy
   @InputFile
   RegularFileProperty inputFile // this is a public property
   
   @InputFile
   private RegularFileProperty inputFile // this is a field, remove the `private` modifier
   ```
   
   == Invalid annotation on method
   
   This error indicates that a annotation has been placed on an unexpected method.
   In general, annotations like `@InputFiles` or `@OutputDirectory` need to be placed on a "property" method.
   A property is defined by having a getter.
   
   This causes Gradle to ignore the annotations, so they are typically not used in up-to-date checking or caching.
   
   To fix this problem, you must remove the annotation, create a getter for the property you want to use and annotate the getter instead.
   
   == Mutable type with setter
   
   This error indicates that a property of "mutable" type is also providing a setter.
   Mutable types in Gradle include link:{javadocPath}#[Property] or link:{javadocPath}#[ConfigurableFileCollection].
   
   For example, you wrote:
   
   ```groovy
   class MyTask extends DefaultTask {
       private Property<Integer> x
   
       @Input
       Property<Integer> getX() { this.x }
   
       void setX(Property<Integer> x) { this.x = x }
   }
   ```
   
   However, mutable types like `Property` are designed to track dependencies and origin of values they are supplied with.
   As a consequence, it is an error to make them overwritable, because Gradle will then be unable to tell where a property value comes from.
   
   To fix this problem, you should either make your property final and remove the setter:
   
   ```groovy
   class MyTask extends DefaultTask {
       @Input
       final Property<Integer> getX() = ...
   ```
   
   You can also rely on Gradle's built-in capacity to inject final properties:
   
   ```groovy
   abstract class MyTask {
       abstract Property<Integer> getX()
   }
   ```
   
   Then the value of the properties need to be configured via the mutation methods:
   
   ```groovy
   myTask {
       x.set(123)
   }
   ```
   
   == Redundant getters
   
   This error indicates that a `boolean` property has both a `get` and an `is` getter method.
   This is a problem because both getters can be annotated differently and Gradle cannot know which ones to use.
   
   The solution to this problem is to get rid of one of the getters or to mark one of the getters with link:{javadocPath}#[@Internal]
   
   == Annotations on private getters
   
   This error indicates that you have annotated a _private_ getter with an input or output annotation.
   Gradle doesn't consider private getters as inputs for up-to-date checking, which means that your annotations effectively are ignored.
   It is important to fix because you might think that you have declared an input when it's not the case.
   
   To fix this, either make the getter public, or annotate an existing getter instead, or create a new annotated getter.
   
   == Annotations on ignored properties
   
   This error indicates that you have a property which is annotated with an annotation which tells Gradle to ignore it (for example link:{javadocPath}#[`@ReplacedBy`]) but is also annotated with an input annotation (for example link:{javadocPath}#[`@InputFile`]).
   
   This is an error because Gradle cannot determine if the property should actually be used for up-to-date checking, that is to say if it's actually an input or not.
   
   To fix this, you must either:
   
   - remove the input annotations from the property, or
   - remove the ignoring annotation from the property.
   
   == Conflicting annotations
   
   This error indicates that a property is annotated with conflicting annotations, that is to say annotations which have different, irreconciliable semantics.
   
   For example, a property cannot be annotated both with `@InputFile` and `@OutputFile` at the same time.
   
   To fix this problem, you need to understand the semantics of the different annotations and choose only one.
   
   == Annotation is invalid in a particular context
   
   This error indicates that a property was annotated with an annotation which is invalid in a particular context.
   For example, it's in general possible to annotate a `DirectoryProperty` with `@OutputDirectory`, but this is invalid in the context of an artifact transform, because artifact transforms provide their own workspace.
   
   To fix this problem, you must remove the property.
   
   == Properties without annotations
   
   This error indicates that a property isn't annotated with an input or output annotation.
   Therefore, Gradle doesn't know if this property represents an input, an output, or simply should be ignored.
   As a consequence, up-to-date checking and caching won't work.
   
   To fix this problem, you need to annotate the property with the appropriate annotation, for example `@InputDirectory` for a property representing an input directory, or `@OutputDirectory` for a property representing an output directory.
   
   Alternatively, if the property is internal, that is to say that it shouldn't participate in up-to-date checking (it's not an input or an output), then you need to annotate it with link:{javadocPath}#[@Internal].
   
   == Annotation is incompatible with the property type
   
   This error indicates that for a specific kind of property, a modifier annotation doesn't make sense.
   This is the case, for example, if the `@SkipWhenEmpty` is used on an output property.
   Because there are no semantics associated with this combination, Gradle cannot deduce your intent.
   
   To fix this, you most likely need to remove the conflicting modifier annotation or check that the actual property type is what you intended.
   
   == Incorrect use of the `@Input` annotation
   
   This error indicates that a property is annotated with `@Input`, but that it should be annotated with `@InputFile` or `@InputDirectory` instead.
   
   If you use the `@Input` annotation on a file-based property, Gradle wouldn't consider the file contents, or the directory contents, as inputs, as you might expect.
   
   To fix this problem, you need to tell Gradle if the file property represents an input file, in which case you should annotate it with `@InputFile`, or a directory, in which case it should be annotated with `@InputDirectory`.
   If what you really wanted to say is that the actual file path is an input, then you should return a `String` instead which corresponds to the absolute path of the file.
   
   
   == Property annotated with `@ServiceReference` is not a BuildService
   
   This error indicates that a property annotated with `@ServiceReference` has a type that does not implement the `link:{javadocPath}#[BuildService]` interface.
   
   Properties annotated with `link:{javadocPath}#[@ServiceReference]` are meant to hold references to <<build_services#build_services,shared build services>>.
   
   == Implicit dependencies between tasks
   
   This error indicates that you have a task which depends on another, but that no explicit or implicit dependency is declared between those two tasks.
   As a consequence, the results of the build are dependent on the order of execution of tasks, often referred to "accidental dependencies between tasks".
   Often, this is because you refer directly to the output file of another task instead of using the task directly as an input.
   
   For example, imagine that you have a task which takes a `ConfigurableFileCollection` as an input and that you have declared a dependency on the `jar` task using this:
   
   ```
   someTask {
       inputFile.from(jar.archivePath)
   }
   ```
   
   The `jar.archivePath` property is of type `File`, which doesn't carry any task dependency.
   It means that if you call `someTask` _after_ `jar` has been called, the task will succeed, but if the jar is removed, for example, the task would fail.
   
   To fix this, you can declare a `Property` as an input instead:
   
   ```
   someTask {
       inputFile.from(jar.archiveFile)
   }
   ```
   
   The `jar.archiveFile` property is of type `Provider<RegularFile>` which properly carries task dependencies: Gradle will be able to know that the file is generated by the `jar` task.
   
   It's actually even easier to add an implicit dependency to the task itself:
   
   ```
   someTask {
       inputFile.from(jar)
   }
   ```
   
   In some cases, for producer tasks which don't use the <<lazy_configuration#lazy_configuration,configuration avoidance APIs>>, you can instead declare an _explicit dependency_ on the task:
   
   ```
   someTask {
       dependsOn(producer)
       inputFile.from(producer.someFile)
   }
   ```
   
   In some cases, adding a dependency on the producing task is not desired, for example when the consumer generates reports for possible multiple tasks.
   In this case you can introduce an <<more_about_tasks.adoc#sec:ordering_tasks,ordering>> between the two tasks by using link:{groovyDslPath}#[]++)[Task.mustRunAfter()].
   
   == Input file doesn't exist
   
   This error occurs whenever a file (or a directory) is declared as an input of a task, but at the moment the task is executed, the file (or directory) doesn't exist.
   
   Usually, this hints at a missing task dependency: the file should exist _before_ the task is executed, which means that a dependent task wasn't executed.
   
   The symptoms are similar to <<implicit_dependency>> except that in this case the task which creates the file hasn't been executed.
   
   Please refer to the <<implicit_dependency>> section for possible solutions.
   If the file isn't produced by another task, you may want to make sure that it exists before the task is called.
   If what you want to declare is that it doesn't matter that the file exists or not when the task is executed, you can use `@InputFiles` that won't fail for non-existing inputs:
   
   ====
   include::sample[dir="snippets/tasks/customTaskWithMissingFileProperty/kotlin",files="build.gradle.kts[tags=task]"]
   include::sample[dir="snippets/tasks/customTaskWithMissingFileProperty/groovy",files="build.gradle[tags=task]"]
   ====
   
   == Unexpected input file or directory
   
   This error indicates that a property expected a regular file as an input but that it was provided with a directory (or the other way around).
   
   For example, if property is annotated with `@InputFile`:
   
   ```groovy
   @InputFile
   File getInputFile()
   ```
   
   Then Gradle expects the input file to be a _regular file_. If the input is a directory, then validation fails.
   
   To fix this problem, you have two options:
   
   - either you made a mistake an provided a directory instead of a file in which case you just need to fix the input
   - or the task should actually have used a directory as an input, in which case you need to change the type of the property to `@InputDirectory`
   
   == Cannot write to an output file or directory
   
   This error indicates that :
   
   - an output directory cannot be written because the directory property which has been configured actually refers to a regular file (or something else than an actual directory).
   - or that an output file cannot be written because the file property which has been configured actually refers to a directory.
   - or the parent of the output location exists and is a file.
   
   For example, you've set an output directory to `/some/path/file.txt` instead of `/some/path`.
   It's also possible that you have configured an output directory like `/some/path` but that an ancestor `/some` is a regular file.
   
   To fix this problem, make sure that the configured output is a directory (for properties which expect a directory) or a file (for tasks which expect a file).
   
   == Cannot write to reserved location
   
   This error indicates that you are trying to write a file to a location which is managed by Gradle only.
   Typically, this happens whenever you're trying to write a file directly into an artifact transforms output directory.
   If you did this intentionally, this is a mistake because those directories should never be written directly: all artifact transform writes should be performed within the artifact transform code itself.
   
   If you didn't intend to write in this directory, you should simply setup your task to write in a different location.
   
   == Unsupported notation in file inputs
   
   This error indicates that a file, directory, collection of files, or a nested collection of files property, refers to an element that Gradle cannot convert to a file.
   
   To fix this, look at the error message which indicates the list of supported file notations and make sure to pick one of them.
   
   == Invalid use of @Optional annotation on primitive types
   
   This error indicates that a property of primitive type is also annotated with `@Optional`.
   This is similar to `null` not being assignable to primitive types in Java.
   
   To fix this problem, you have two options:
   
   - remove the `@Optional` annotation
   - or use the boxed type (e.g Integer instead of int) if you intend to make the property nullable
   
   
   == Cannot use an input with an unknown implementation
   
   This error indicates that a task uses a class as an input and Gradle cannot track the implementation of the class.
   Gradle considers the implementation of the following classes as inputs to a task:
   
   - the task class,
   - the classes of the actions of the task,
   - and the classes of nested inputs of the task, i.e. inputs annotated with `@Nested`.
   
   There are two reasons why Gradle cannot track the implementation of a class:
   
   - a non-serializable Java lambda was used to implement the class,
   - or the class has been loaded by a classloader unknown to Gradle.
   
   Using a Java lambda means that the bytecode uses invoke-dynamic instead of creating an actual sub-class.
   The class for the invoke-dynamic instruction is generated at JVM runtime and Gradle cannot uniquely identify this class across different JVMs if the target functional interface is not serializable.
   For task actions it is not a problem, because Gradle handles them in a special way.
   On the other hand, for classes of nested inputs implemented by a non-serializable lambda Gradle does not support tracking.
   As a workaround you can convert the lambda to an anonymous inner class or make the target functional interface serializable.
   
   For the case where Gradle cannot track the implementation because it was loaded by a classloader unknown to Gradle, you can use Gradle's built-in ways to load the class.
   
   == Missing reason for not caching
   
   This warning indicates that the task or artifact transform action has not been marked as cacheable, though there also is no reason why it is not cacheable.
   Task or artifact transform authors should always provide a reason why something is not cacheable by using the link:{javadocPath}#[`@DisableCachingByDefault`] annotation.
   
   To fix the problem either annotate the work type with `@CacheableTask`/`@CacheableTransform` or `@DisableCachingByDefault(because = "...")`.
   
   == Unsupported value type
   
   This message indicates that a task declares an input property with values of an unsupported type.
   
   To address this, look at the message which indicates the list of possible solutions.
   
   Please find below the list of unsupported value types:
   
   `ResolvedArtifactResult`:: <<incremental_build#sec:task_input_using_dependency_resolution_results, Using dependency resolution results as task inputs>>
   `java.net.URL`:: This type is not supported on properties annotated with @Input because up-to-date checks might to be inconsistent for this type, leading to incorrect build results.
   This is caused by a known issue in Java where the serialization of `java.net.URL` is incorrect.
   See the https://bugs.openjdk.org/browse/JDK-8075619[OpenJDK bug report] for more details.
   To address this, we suggest to use `java.net.URI` instead.
   
   == Unsupported key type of nested map
   
   This error indicates that a nested map declares a key of an unsupported type.
   Gradle uses the key to generate a name for the (sub)property.
   Only allowing keys of type `Enum`, `Integer`, and `String` guarantees that these names are unique and well-formed, and is preferable to relying on `toString()` for producing such names.
   
   To fix this problem, change the type of the key to `Enum`, `Integer`, or `String`.
   
   == Unsupported nested type
   
   This error indicates that an unsupported type is annotated as nested.
   Nested types are expected to either declare some annotated properties (which themselves are checked for annotations) or some conditional behaviour where capturing the type itself as input is important.
   Types of the Java SE API, types of the Kotlin stdlib, and Groovy's GString are not supported, because they meet neither of those requirements.
   
   To fix this problem, declare a nested type, e.g. `Provider<T>`, `Iterable<T>`, or `<MapProperty<K, V>>`, where `T` and `V` have some annotated properties or some behaviour that requires capturing the type as input.

/docs/userguide/troubleshooting/version_catalog_problems.adoc
=============================================================

.. code-block::

   = Troubleshooting version catalog problems
   
   This page summarizes the different problems that Gradle reports when using version catalogs and provides guidance for fixing them.
   
   == Accessor name clash
   
   This error indicates that your version catalog contains (at least) two aliases which are mapped to the same accessor.
   Given an alias like `some.alias`, Gradle implements a mapping strategy to a _getter_ for type-checked accessors.
   In this case, it means that two aliases are in conflict because they result in the same getter being created.
   
   To fix this problem, you must choose different aliases.
   
   == Too many entries in a single catalog
   
   This error indicates that a version catalog contains too many entries.
   Because of JVM file format restrictions, when Gradle generates dependency accessors, it has to put an upper limit to the number of aliases that a catalog may contain.
   This limit is currently of 32000 entries.
   
   To fix this problem, if you need more entries, it's probably best to split the catalog into multiple, distinct catalogs.
   
   == Use of a reserved alias name
   
   This error indicates that you chose an alias which is a reserved name.
   Typically this happens if you choose an alias which starts with `versions`, `bundles`, or `plugins` or contains `extensions`, `convention`, `class`, as it may clash with generated accessors.
   
   To fix this problem, you must choose a different alias.
   
   == Undefined version reference
   
   This error indicates that your catalog declares a library which references a non-existing version.
   When you use version references in a catalog, the version reference must point to an existing version alias.
   
   To fix this, you must either:
   
   - fix the version reference to use one of the versions declared in the catalog
   - or declare a new version corresponding to the reference you want to use in the catalog
   
   It's worth noting that catalogs are isolated, so you cannot use a version reference from one catalog in another catalog.
   
   == Undefined alias reference
   
   This error indicates that your catalog declares a bundle (a group of libraries) which references a non-existing library.
   
   Bundles should only consist of libraries declared in the same catalog.
   
   To fix this, you must either:
   
   - make sure that the alias for the library you want to include is defined in the same catalog
   - or remove the library from the bundle
   
   == Invalid dependency notation
   
   This error indicates that the dependency notation associated with an alias is incorrect.
   Version catalog supports the simplified `group:artifact:version` notation.
   
   If you are using the `Settings` DSL to create a catalog, you can use the `to` method in different flavors:
   
   ```groovy
   library("some-alias", "com.mycompany:some-lib:1.1").withoutVersion()
   // or
   library("some-alias", "com.mycompany", "some-lib").version("1.1")
   ```
   
   If you are using TOML files to create a catalog, you can use one of the following notations:
   
   ```toml
   [libraries]
   some-alias = { group="com.mycompany",
       name="some-lib",
       version="1.1"
   }
   # or
   some-alias = {
        module="com.mycompany:some-lib",
        version="1.1"
   }
   ```
   
   == Unsupported catalog file format
   
   This error indicates that you tried to import a catalog file, but the format isn't recognized.
   Typically, this happens if you tried to import a catalog using `from(files("some-catalog.txt"))`.
   
   Currently Gradle only supports TOML version catalogs.
   
   To fix this problem, either import a TOML file, or use the `Settings` API to declare your catalog.
   
   == Catalog file doesn't exist
   
   This error indicates that you tried to import a catalog file, but the file doesn't exist.
   
   Make sure that it's not a typo, and if not, that the catalog file exists _before_ importing it.
   
   == Invalid alias or bundle notation
   
   This error indicates that you have used an alias (or bundle) name which isn't supported by Gradle.
   Gradle puts some restrictions on alias names: they must match the following regular expression: `[a-z]([a-zA-Z0-9_.\-])+`
   
   A typical alias name would be `some-alias`.
   
   == Invalid module notation
   
   This error indicates that your module notation in a TOML version catalog is incorrect.
   When you use the `module` notation in a TOML, it must consist of 2 elements, the `group` and the `name` of the module, separated by a colon (`:`).
   
   For example:
   
   ```toml
   [libraries]
   groovy = { module="org.codehaus.groovy:groovy", version="3.0.5" }
   ```
   
   == Invalid TOML definition
   
   This error indicates that you have a syntax or grammar error in your TOML version catalog file.
   
   This can happen if you use wrong keys, for example:
   
   ```toml
   some-alias = { unknownKey = "foo" }
   ```
   
   or that you forgot about some elements:
   
   ```toml
   # missing the "group"
   some-alias = { name="my-lib", version="1.0" }
   ```
   
   == Unsupported TOML file format version
   
   This error indicates that you are trying to read a version catalog file which has a higher version than what the current version of Gradle supports.
   
   This would usually mean that the version catalog file you're trying to use has been produced with a higher release of Gradle than the one you're using.
   
   A potential solution to this is to upgrade your Gradle version.
   
   == Invalid plugin notation
   
   This error indicates that the dependency notation associated with a plugin alias is incorrect.
   The TOML version catalog supports the simplified `plugin.id:version` notation when declaring a plugin alias.
   
   Therefore this usually means that you have a notation which consists of a string, but which doesn't separate the plugin id from the plugin version using a semicolon.
   
   == Alias not finished
   
   This error indicates that an alias builder was created, but never registered with the catalog. This is usually because
   you didn't call `.version()` or `.withoutVersion()` on the builder.
   
   The solution is to call whichever version method is appropriate.
   
   == Too many import invocations
   
   This error indicates that an import statement (e.g. link:{javadocPath}#[from(Object notation)]) was called more than once.
   
   A version catalog can only be imported from a single source.
   To prevent the import of multiple sources, some methods will throw an exception when called more than once.
   
   A simple example could be the following, which triggers the error when building a version catalog:
   ```kotlin
   create("testLibs") {
       from(files("gradle/a.versions.toml"))
       from(files("gradle/b.versions.toml"))
   }
   ```
   
   When this happens, make sure that there is only a single import invocation per version catalog.
   
   == No import files
   
   When an import statement receives a notation, which doesn't resolve to a file, an exception will be thrown.
   
   A simple example could be the following, which triggers the error when building a version catalog:
   ```kotlin
   create("testLibs") {
       from(files())
   }
   ```
   
   The solution is to make sure that from is not called with empty files.
   
   == Too many import files
   
   When an imported file doesn't resolve to a file, an exception will be thrown.
   
   A simple example could be the following, which triggers the error when building a version catalog:
   ```kotlin
   create("testLibs") {
       from(files("gradle/a.versions.toml", "gradle/b.versions.toml"))
   }
   ```
   
   The solution is to make sure that from is not called with a notation, which resolves into multiple files.

/Topic: 游댯 Running Gradle Builds
==================================


/docs/userguide/running-builds/introduction/gradle_basics.adoc
==============================================================

.. code-block::

   = Gradle Basics
   
   Gradle *automates building, testing, and deployment of software* from information in *build scripts*.
   
   image::gradle-basic-1.png[]
   
   == Gradle core concepts
   
   === Projects
   
   A Gradle *project* is a piece of software that can be built, such as an application or a library.
   
   *Single project* builds include a single project called the *root project*.
   
   *Multi-project* builds include *one root project* and *any number of subprojects*.
   
   === Build Scripts
   
   *Build scripts* detail to Gradle what steps to take to build the project.
   
   Each project can include one or more build scripts.
   
   === Dependency Management
   
   *Dependency management* is an automated technique for declaring and resolving external resources required by a project.
   
   Each project typically includes a number of external dependencies that Gradle will resolve during the build.
   
   === Tasks
   
   *Tasks are a basic unit of work* such as compiling code or running your test.
   
   Each project contains one or more tasks defined inside a build script or a plugin.
   
   === Plugins
   
   Plugins are used to *extend Gradle's capability* and optionally contribute *tasks* to a project.
   
   == Gradle project structure
   
   Many developers will interact with Gradle for the first time through an existing project.
   
   The presence of the `gradlew` and `gradlew.bat` files in the root directory of a project is a clear indicator that Gradle is used.
   
   A Gradle project will look similar to the following:
   
   [source,text]
   ----
   project
   較럭較 gradle                              // <1>
   較   較럭較 libs.versions.toml              // <2>
   較   較덕較 wrapper
   較       較럭較 gradle-wrapper.jar
   較       較덕較 gradle-wrapper.properties
   較럭較 gradlew                             // <3>
   較럭較 gradlew.bat                         // <3>
   較럭較 settings.gradle(.kts)               // <4>
   較럭較 subproject-a
   較   較럭較 build.gradle(.kts)              // <5>
   較   較덕較 src                             // <6>
   較덕較 subproject-b
       較럭較 build.gradle(.kts)              // <5>
       較덕較 src                             // <6>
   ----
   <1> Gradle directory to store wrapper files and more
   <2> Gradle version catalog for dependency management
   <3> Gradle wrapper scripts
   <4> Gradle settings file to define a root project name and subprojects
   <5> Gradle build scripts of the two subprojects - `subproject-a` and `subproject-b`
   <6> Source code and/or additional files for the projects
   
   == Invoking Gradle
   
   === IDE
   
   Gradle is <<gradle_ides.adoc#gradle_ides,built-in to many IDEs>> including Android Studio, IntelliJ IDEA, Visual Studio Code, Eclipse, and NetBeans.
   
   Gradle can be automatically invoked when you build, clean, or run your app in the IDE.
   
   It is recommended that you consult the manual for the IDE of your choice to learn more about how Gradle can be used and configured.
   
   === Command line
   
   Gradle can be invoked in the command line once <<installation.adoc#installation, installed>>.
   For example:
   
   [source,text]
   ----
   $ gradle build
   ----
   
   NOTE: Most projects do not use the installed version of Gradle.
   
   === Gradle Wrapper
   
   The Wrapper is a script that invokes a declared version of Gradle and is *the recommended way to execute a Gradle build*.
   It is found in the project root directory as a `gradlew` or `gradlew.bat` file:
   
   [source,text]
   ----
   $ gradlew build     // Linux or OSX
   $ gradlew.bat build  // Windows
   ----
   
   [.text-right]
   **Next Step:** <<gradle_wrapper_basics.adoc#gradle_wrapper_basics,Learn about the Gradle Wrapper>> >>

/docs/userguide/running-builds/introduction/gradle_wrapper_basics.adoc
======================================================================

.. code-block::

   = Gradle Wrapper Basics
   
   The **recommended way to execute any Gradle build** is with the Gradle Wrapper.
   
   image::gradle-basic-2.png[]
   
   The _Wrapper_ script invokes a declared version of Gradle, downloading it beforehand if necessary.
   
   image::wrapper-workflow.png[]
   
   The Wrapper is available as a `gradlew` or `gradlew.bat` file.
   
   The Wrapper provides the following benefits:
   
   - Standardizes a project on a given Gradle version.
   - Provisions the same Gradle version for different users.
   - Provisions the Gradle version for different execution environments (IDEs, CI servers...).
   
   == Using the Gradle Wrapper
   
   It is always recommended to execute a build with the Wrapper to ensure a reliable, controlled, and standardized execution of the build.
   
   Depending on the operating system, you run `gradlew` or `gradlew.bat` instead of the `gradle` command.
   
   Typical Gradle invocation:
   
   ----
   $ gradle build
   ----
   
   To run the Wrapper on a Linux or OSX machine:
   
   ----
   $ ./gradlew build
   ----
   
   To run the Wrapper on Windows PowerShell:
   
   ----
   $ .\gradlew.bat build
   ----
   
   The command is run in the same directory that the Wrapper is located in.
   If you want to run the command in a different directory, you must provide the relative path to the Wrapper:
   
   ----
   $ ../gradlew build
   ----
   
   The following console output demonstrates the use of the Wrapper on a Windows machine, in the command prompt (cmd), for a Java-based project:
   
   ----
   $ gradlew.bat build
   
   include::{snippetsPath}/wrapper/simple/tests/wrapperBatchFileExecution.out[]
   ----
   
   Consult the <<gradle_wrapper.adoc#gradle_wrapper_reference,Gradle Wrapper reference>> to learn more.
   
   [.text-right]
   **Next Step:** <<command_line_interface_basics.adoc#command_line_interface_basics,Learn about the Gradle CLI>> >>

/docs/userguide/running-builds/introduction/command_line_interface_basics.adoc
==============================================================================

.. code-block::

   = Command-Line Interface Basics
   
   The command-line interface is the primary **method of interacting with Gradle** outside the IDE.
   
   image::gradle-basic-2.png[]
   
   Use of the <<gradle_wrapper.adoc#gradle_wrapper_reference, Gradle Wrapper>> is highly encouraged.
   
   Substitute `./gradlew` (in macOS / Linux) or `gradlew.bat` (in Windows) for `gradle` in the following examples.
   
   Executing Gradle on the command line conforms to the following structure:
   
   ----
   gradle [taskName...] [--option-name...]
   ----
   
   Options are allowed _before_ and _after_ task names.
   
   ----
   gradle [--option-name...] [taskName...]
   ----
   
   If multiple tasks are specified, you should separate them with a space.
   
   ----
   gradle [taskName1 taskName2...] [--option-name...]
   ----
   
   Options that accept values can be specified with or without `=` between the option and argument. The use of `=` is recommended.
   
   ----
   gradle [...] --console=plain
   ----
   
   Options that enable behavior have long-form options with inverses specified with `--no-`. The following are opposites.
   
   ----
   gradle [...] --build-cache
   gradle [...] --no-build-cache
   ----
   
   Many long-form options have short-option equivalents. The following are equivalent:
   
   ----
   gradle --help
   gradle -h
   ----
   
   == Command-line usage
   
   The following sections describe the use of the Gradle command-line interface.
   Some plugins also add their own command line options.
   
   === Executing tasks
   To execute a task called `taskName` on the root project, type:
   
   ----
   $ gradle :taskName
   ----
   
   This will run the single `taskName` and all of its <<tutorial_using_tasks.adoc#sec:task_dependencies,dependencies>>.
   
   === Specify options for tasks
   To pass an option to a task, prefix the option name with `--` after the task name:
   
   ----
   $ gradle taskName --exampleOption=exampleValue
   ----
   
   Consult the <<command_line_interface.adoc#command_line_interface,Gradle Command Line Interface reference>> to learn more.
   
   [.text-right]
   **Next Step:** <<settings_file_basics.adoc#settings_file_basics,Learn about the Settings file>> >>

/docs/userguide/running-builds/introduction/settings_file_basics.adoc
=====================================================================

.. code-block::

   = Settings File Basics
   
   The settings file is the *entry point* of every Gradle project.
   
   image::gradle-basic-3.png[]
   
   The primary purpose of the _settings file_ is to add subprojects to your build.
   
   Gradle supports single and multi-project builds.
   
   - For single-project builds, the settings file is optional.
   - For multi-project builds, the settings file is mandatory and declares all subprojects.
   
   == Settings script
   
   The settings file is a script.
   It is either a `settings.gradle` file written in Groovy or a `settings.gradle.kts` file in Kotlin.
   
   The link:{groovyDslPath}#[Groovy DSL^] and the link:{kotlinDslPath}/index.html[Kotlin DSL^] are the only accepted languages for Gradle scripts.
   
   The settings file is typically found in the root directory of the project.
   
   Let's take a look at an example and break it down:
   
   ====
   [.multi-language-sample]
   =====
   .settings.gradle.kts
   [source,kotlin]
   ----
   rootProject.name = "root-project"   // <1>
   
   include("sub-project-a")            // <2>
   include("sub-project-b")
   include("sub-project-c")
   ----
   <1> Define the project name.
   <2> Add subprojects.
   =====
   
   [.multi-language-sample]
   =====
   .settings.gradle
   [source,groovy]
   ----
   rootProject.name = 'root-project'   // <1>
   
   include('sub-project-a')            // <2>
   include('sub-project-b')
   include('sub-project-c')
   ----
   <1> Define the project name.
   <2> Add subprojects.
   =====
   ====
   
   === 1. Define the project name
   
   The settings file defines your project name:
   
   [source,kotlin]
   ----
   rootProject.name = "root-project"
   ----
   
   There is only one root project per build.
   
   === 2. Add subprojects
   
   The settings file defines the structure of the project by including subprojects, if there are any:
   
   [source,kotlin]
   ----
   include("app")
   include("business-logic")
   include("data-model")
   ----
   
   Consult the <<writing_settings_files.adoc#writing_settings_files,Writing Settings File>> page to learn more.
   
   [.text-right]
   **Next Step:** <<build_file_basics.adoc#build_file_basics,Learn about the Build scripts>> >>

/docs/userguide/running-builds/introduction/build_file_basics.adoc
==================================================================

.. code-block::

   = Build File Basics
   
   Generally, a build script details *build configuration, tasks, and plugins*.
   
   image::gradle-basic-4.png[]
   
   Every Gradle build comprises at least one _build script_.
   
   In the build file, two types of dependencies can be added:
   
   1. The libraries and/or plugins on which Gradle and the build script depend.
   2. The libraries on which the project sources (i.e., source code) depend.
   
   == Build scripts
   
   The build script is either a `build.gradle` file written in Groovy or a `build.gradle.kts` file in Kotlin.
   
   The link:{groovyDslPath}#[Groovy DSL^] and the link:{kotlinDslPath}/index.html[Kotlin DSL^] are the only accepted languages for Gradle scripts.
   
   Let's take a look at an example and break it down:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("application")               // <1>
   }
   
   application {
       mainClass = "com.example.Main"  // <2>
   }
   ----
   <1> Add plugins.
   <2> Use convention properties.
   =====
   
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   plugins {
       id 'application'                // <1>
   }
   
   application {
       mainClass = 'com.example.Main'  // <2>
   }
   ----
   <1> Add plugins.
   <2> Use convention properties.
   =====
   ====
   
   === 1. Add plugins
   Plugins extend Gradle's functionality and can contribute tasks to a project.
   
   Adding a plugin to a build is called _applying_ a plugin and makes additional functionality available.
   
   [source,kotlin]
   ----
   plugins {
       id("application")
   }
   ----
   
   The `application` plugin facilitates creating an executable JVM application.
   
   Applying the <<application_plugin.adoc#application_plugin,Application plugin>> also implicitly applies the <<java_plugin.adoc#java_plugin,Java plugin>>.
   The `java` plugin adds Java compilation along with testing and bundling capabilities to a project.
   
   === 2. Use convention properties
   A plugin adds tasks to a project.
   It also adds properties and methods to a project.
   
   The `application` plugin defines tasks that package and distribute an application, such as the `run` task.
   
   The Application plugin provides a way to declare the main class of a Java application, which is required to execute the code.
   
   [source,kotlin]
   ----
   application {
       mainClass = "com.example.Main"
   }
   ----
   
   In this example, the main class (i.e., the point where the program's execution begins) is `com.example.Main`.
   
   Consult the <<writing_build_scripts.adoc#writing_build_scripts,Writing Build Scripts>> page to learn more.
   
   [.text-right]
   **Next Step:** <<dependency_management_basics.adoc#dependency_management_basics,Learn about Dependency Management>> >>

/docs/userguide/running-builds/introduction/dependency_management_basics.adoc
=============================================================================

.. code-block::

   = Dependency Management Basics
   
   Gradle has built-in support for *dependency management*.
   
   image::gradle-basic-7.png[]
   
   Dependency management is an automated technique for declaring and resolving external resources required by a project.
   
   Gradle build scripts define the process to build projects that may require external dependencies.
   Dependencies refer to JARs, plugins, libraries, or source code that support building your project.
   
   == Version Catalog
   
   Version catalogs provide a way to centralize your dependency declarations in a `libs.versions.toml` file.
   
   The catalog makes sharing dependencies and version configurations between subprojects simple.
   It also allows teams to enforce versions of libraries and plugins in large projects.
   
   The version catalog typically contains four sections:
   
   1. [versions] to declare the version numbers that plugins and libraries will reference.
   2. [libraries] to define the libraries used in the build files.
   3. [bundles] to define a set of dependencies.
   4. [plugins] to define plugins.
   
   [source,gradle/libs.versions.toml]
   ----
   [versions]
   androidGradlePlugin = "7.4.1"
   mockito = "2.16.0"
   
   [libraries]
   googleMaterial = { group = "com.google.android.material", name = "material", version = "1.1.0-alpha05" }
   mockitoCore = { module = "org.mockito:mockito-core", version.ref = "mockito" }
   
   [plugins]
   androidApplication = { id = "com.android.application", version.ref = "androidGradlePlugin" }
   ----
   
   The file is located in the `gradle` directory so that it can be used by Gradle and IDEs automatically.
   The version catalog should be checked into source control: `gradle/libs.versions.toml`.
   
   == Declaring Your Dependencies
   
   To add a dependency to your project, specify a dependency in the dependencies block of your `build.gradle(.kts)` file.
   
   The following `build.gradle.kts` file adds a plugin and two dependencies to the project using the version catalog above:
   
   [source,kotlin]
   ----
   plugins {
      alias(libs.plugins.androidApplication)  // <1>
   }
   
   dependencies {
       // Dependency on a remote binary to compile and run the code
       implementation(libs.googleMaterial)    // <2>
   
       // Dependency on a remote binary to compile and run the test code
       testImplementation(libs.mockitoCore)   // <3>
   }
   ----
   <1> Applies the Android Gradle plugin to this project, which adds several features that are specific to building Android apps.
   <2> Adds the Material dependency to the project. Material Design provides components for creating a user interface in an Android App. This library will be used to compile and run the Kotlin source code in this project.
   <3> Adds the Mockito dependency to the project. Mockito is a mocking framework for testing Java code. This library will be used to compile and run the _test_ source code in this project.
   
   Dependencies in Gradle are grouped by *configurations*.
   
   - The `material` library is added to the `implementation` configuration, which is used for compiling and running _production_ code.
   - The `mockito-core` library is added to the `testImplementation` configuration, which is used for compiling and running _test_ code.
   
   NOTE: There are many more configurations available.
   
   == Viewing Project Dependencies
   
   You can view your dependency tree in the terminal using the `./gradlew :app:dependencies` command:
   
   [source,text]
   ----
   $ ./gradlew :app:dependencies
   
   > Task :app:dependencies
   
   ------------------------------------------------------------
   Project ':app'
   ------------------------------------------------------------
   
   implementation - Implementation only dependencies for source set 'main'. (n)
   \--- com.google.android.material:material:1.1.0-alpha05 (n)
   
   testImplementation - Implementation only dependencies for source set 'test'. (n)
   \--- org.mockito:mockito-core:2.16.0 (n)
   
   ...
   ----
   
   Consult the <<dependency_management_terminology.adoc#dependency_management_terminology,Dependency Management chapter>> to learn more.
   
   [.text-right]
   **Next Step:** <<task_basics.adoc#task_basics,Learn about Tasks>> >>

/docs/userguide/running-builds/introduction/task_basics.adoc
============================================================

.. code-block::

   = Task Basics
   
   A task represents some *independent unit of work* that a build performs, such as compiling classes, creating a JAR, generating Javadoc, or publishing archives to a repository.
   
   image::gradle-basic-5.png[]
   
   You run a Gradle `build` task using the `gradle` command or by invoking the Gradle Wrapper (`./gradlew` or `gradlew.bat`) in your project directory:
   
   [source,text]
   ----
   $ ./gradlew build
   ----
   
   == Available tasks
   All available tasks in your project come from Gradle plugins and build scripts.
   
   You can list all the available tasks in the project by running the following command in the terminal:
   
   [source,text]
   ----
   $ ./gradlew tasks
   ----
   
   [source,text]
   ----
   Application tasks
   -----------------
   run - Runs this project as a JVM application
   
   Build tasks
   -----------
   assemble - Assembles the outputs of this project.
   build - Assembles and tests this project.
   
   ...
   
   Documentation tasks
   -------------------
   javadoc - Generates Javadoc API documentation for the main source code.
   
   ...
   
   Other tasks
   -----------
   compileJava - Compiles main Java source.
   
   ...
   ----
   
   == Running tasks
   The `run` task is executed with `./gradlew run`:
   
   [source,text]
   ----
   $ ./gradlew run
   
   > Task :app:compileJava
   > Task :app:processResources NO-SOURCE
   > Task :app:classes
   
   > Task :app:run
   Hello World!
   
   BUILD SUCCESSFUL in 904ms
   2 actionable tasks: 2 executed
   ----
   
   In this example Java project, the output of the `run` task is a `Hello World` statement printed on the console.
   
   == Task dependency
   
   Many times, a task requires another task to run first.
   
   For example, for Gradle to execute the `build` task, the Java code must first be compiled.
   Thus, the `build` task _depends_ on the `compileJava` task.
   
   This means that the `compileJava` task will run _before_ the `build` task:
   
   [source,text]
   ----
   $ ./gradlew build
   
   > Task :app:compileJava
   > Task :app:processResources NO-SOURCE
   > Task :app:classes
   > Task :app:jar
   > Task :app:startScripts
   > Task :app:distTar
   > Task :app:distZip
   > Task :app:assemble
   > Task :app:compileTestJava
   > Task :app:processTestResources NO-SOURCE
   > Task :app:testClasses
   > Task :app:test
   > Task :app:check
   > Task :app:build
   
   BUILD SUCCESSFUL in 764ms
   7 actionable tasks: 7 executed
   ----
   
   Build scripts can optionally define task dependencies.
   Gradle then automatically determines the task execution order.
   
   Consult the <<more_about_tasks.adoc#more_about_tasks,Task development chapter>> to learn more.
   
   [.text-right]
   **Next Step:** <<plugin_basics.adoc#plugin_basics,Learn about Plugins>> >>

/docs/userguide/running-builds/introduction/plugin_basics.adoc
==============================================================

.. code-block::

   = Plugin Basics
   
   Gradle is built on a plugin system.
   Gradle itself is primarily composed of infrastructure, such as a sophisticated dependency resolution engine.
   The rest of its functionality comes from plugins.
   
   A plugin is a piece of software that *provides additional functionality to the Gradle build system*.
   
   image::gradle-basic-6.png[]
   
   Plugins can be applied to a Gradle build script to *add new tasks, configurations, or other build-related capabilities*:
   
   The Java Library Plugin - `java-library` :: Used to define and build Java libraries. It compiles Java source code with the `compileJava` task, generates Javadoc with the `javadoc` task, and packages the compiled classes into a JAR file with the `jar` task.
   The Google Services Gradle Plugin - `com.google.gms:google-services` :: Enables Google APIs and Firebase services in your Android application with a configuration block called `googleServices{}` and a task called `generateReleaseAssets`.
   The Gradle Bintray Plugin - `com.jfrog.bintray` :: Allows you to publish artifacts to Bintray by configuring the plugin using the `bintray{}` block.
   
   == Plugin distribution
   
   Plugins are distributed in three ways:
   
   1. **Core plugins** - Gradle develops and maintains a set of <<plugin_reference#plugin_reference,Core Plugins>>.
   2. **Community plugins** - Gradle's community shares plugins via the https://plugins.gradle.org[Gradle Plugin Portal].
   3. **Local plugins** - Gradle enables users to create custom plugins using link:{javadocPath}#[APIs].
   
   == Applying plugins
   
   *Applying* a plugin to a project allows the plugin to extend the project's capabilities.
   
   You apply plugins in the build script using a *plugin id* (a globally unique identifier / name) and a version:
   
   [source,text]
   ----
   plugins {
       id 춺plugin id췉 version 춺plugin version췉
   }
   ----
   
   == 1. Core plugins
   
   Gradle Core plugins are a set of plugins that are included in the Gradle distribution itself.
   These plugins provide essential functionality for building and managing projects.
   
   Some examples of core plugins include:
   
   - *java*: Provides support for building Java projects.
   - *groovy*: Adds support for compiling and testing Groovy source files.
   - *ear*: Adds support for building EAR files for enterprise applications.
   
   Core plugins are unique in that they provide short names, such as `java` for the core link:{javadocPath}#[JavaPlugin], when applied in build scripts.
   They also do not require versions.
   To apply the `java` plugin to a project:
   
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("java")
   }
   ----
   
   There are many <<plugin_reference#plugin_reference,Gradle Core Plugins>> users can take advantage of.
   
   == 2. Community plugins
   
   Community plugins are plugins developed by the Gradle community, rather than being part of the core Gradle distribution.
   These plugins provide additional functionality that may be specific to certain use cases or technologies.
   
   The link:https://plugins.gradle.org/plugin/org.springframework.boot[Spring Boot Gradle plugin] packages executable JAR or WAR archives, and runs link:https://spring.io/[Spring Boot] Java applications.
   
   To apply the `org.springframework.boot` plugin to a project:
   
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("org.springframework.boot") version "3.1.5"
   }
   ----
   
   Community plugins can be published at the link:http://plugins.gradle.org/[Gradle Plugin Portal], where other Gradle users can easily discover and use them.
   
   == 3. Local plugins
   
   Custom or local plugins are developed and used within a specific project or organization.
   These plugins are not shared publicly and are tailored to the specific needs of the project or organization.
   
   Local plugins can encapsulate common build logic, provide integrations with internal systems or tools, or abstract complex functionality into reusable components.
   
   Gradle provides users with the ability to develop custom plugins using APIs.
   To create your own plugin, you'll typically follow these steps:
   
   1. *Define the plugin class:* create a new class that implements the `Plugin<Project>` interface.
   +
   [source,kotlin]
   ----
   // Define a 'HelloPlugin' plugin
   class HelloPlugin : Plugin<Project> {
       override fun apply(project: Project) {
           // Define the 'hello' task
           val helloTask = project.tasks.register("hello") {
               doLast {
                   println("Hello, Gradle!")
               }
           }
       }
   }
   ----
   
   2. *Build and optionally publish your plugin:* generate a JAR file containing your plugin code and optionally publish this JAR to a repository (local or remote) to be used in other projects.
   +
   [source,kotlin]
   ----
   // Publish the plugin
   plugins {
       `maven-publish`
   }
   
   publishing {
       publications {
           create<MavenPublication>("mavenJava") {
               from(components["java"])
           }
       }
       repositories {
           mavenLocal()
       }
   }
   ----
   3. *Apply your plugin:* when you want to use the plugin, include the plugin ID and version in the `plugins{}` block of the build file.
   +
   [source,kotlin]
   ----
   // Apply the plugin
   plugins {
       id("com.example.hello") version "1.0"
   }
   ----
   
   Consult the <<custom_plugins.adoc#custom_plugins,Plugin development chapter>> to learn more.
   
   [.text-right]
   **Next Step:** <<gradle_optimizations.adoc#gradle_optimizations,Learn about Incremental Builds and Build Caching>> >>

/docs/userguide/running-builds/introduction/gradle_optimizations.adoc
=====================================================================

.. code-block::

   = Gradle Incremental Builds and Build Caching
   
   Gradle uses two main features to reduce build time: *incremental builds* and *build caching*.
   
   image::gradle-basic-8.png[]
   
   == Incremental builds
   
   An *incremental build* is a build that avoids running tasks whose inputs have not changed since the previous build.
   Re-executing such tasks is unnecessary if they would only re-produce the same output.
   
   For incremental builds to work, tasks must define their inputs and outputs.
   Gradle will determine whether the input or outputs have changed at build time.
   If they have changed, Gradle will execute the task.
   Otherwise, it will skip execution.
   
   Incremental builds are always enabled, and the best way to see them in action is to turn on _verbose mode_.
   With verbose mode, each task state is labeled during a build:
   
   [source,text]
   ----
   $ ./gradlew compileJava --console=verbose
   
   > Task :buildSrc:generateExternalPluginSpecBuilders UP-TO-DATE
   > Task :buildSrc:extractPrecompiledScriptPluginPlugins UP-TO-DATE
   > Task :buildSrc:compilePluginsBlocks UP-TO-DATE
   > Task :buildSrc:generatePrecompiledScriptPluginAccessors UP-TO-DATE
   > Task :buildSrc:generateScriptPluginAdapters UP-TO-DATE
   > Task :buildSrc:compileKotlin UP-TO-DATE
   > Task :buildSrc:compileJava NO-SOURCE
   > Task :buildSrc:compileGroovy NO-SOURCE
   > Task :buildSrc:pluginDescriptors UP-TO-DATE
   > Task :buildSrc:processResources UP-TO-DATE
   > Task :buildSrc:classes UP-TO-DATE
   > Task :buildSrc:jar UP-TO-DATE
   > Task :list:compileJava UP-TO-DATE
   > Task :utilities:compileJava UP-TO-DATE
   > Task :app:compileJava UP-TO-DATE
   
   BUILD SUCCESSFUL in 374ms
   12 actionable tasks: 12 up-to-date
   ----
   
   When you run a task that has been previously executed and hasn't changed, then `UP-TO-DATE` is printed next to the task.
   
   TIP: To permanently enable verbose mode, add `org.gradle.console=verbose` to your `gradle.properties` file.
   
   == Build caching
   
   Incremental Builds are a great optimization that helps avoid work already done.
   If a developer continuously changes a single file, there is likely no need to rebuild all the other files in the project.
   
   However, what happens when the same developer switches to a new branch created last week?
   The files are rebuilt, even though the developer is building something that has been built before.
   
   This is where a *build cache* is helpful.
   
   The build cache stores previous build results and restores them when needed.
   It prevents the redundant work and cost of executing time-consuming and expensive processes.
   
   When the build cache has been used to repopulate the local directory, the tasks are marked as `FROM-CACHE`:
   
   [source,text]
   ----
   $ ./gradlew compileJava --build-cache
   
   > Task :buildSrc:generateExternalPluginSpecBuilders UP-TO-DATE
   > Task :buildSrc:extractPrecompiledScriptPluginPlugins UP-TO-DATE
   > Task :buildSrc:compilePluginsBlocks UP-TO-DATE
   > Task :buildSrc:generatePrecompiledScriptPluginAccessors UP-TO-DATE
   > Task :buildSrc:generateScriptPluginAdapters UP-TO-DATE
   > Task :buildSrc:compileKotlin UP-TO-DATE
   > Task :buildSrc:compileJava NO-SOURCE
   > Task :buildSrc:compileGroovy NO-SOURCE
   > Task :buildSrc:pluginDescriptors UP-TO-DATE
   > Task :buildSrc:processResources UP-TO-DATE
   > Task :buildSrc:classes UP-TO-DATE
   > Task :buildSrc:jar UP-TO-DATE
   > Task :list:compileJava FROM-CACHE
   > Task :utilities:compileJava FROM-CACHE
   > Task :app:compileJava FROM-CACHE
   
   BUILD SUCCESSFUL in 364ms
   12 actionable tasks: 3 from cache, 9 up-to-date
   ----
   
   Once the local directory has been repopulated, the next execution will mark tasks as `UP-TO-DATE` and not `FROM-CACHE`.
   
   The build cache allows you to share and reuse unchanged build and test outputs across teams.
   This speeds up local and CI builds since cycles are not wasted re-building binaries unaffected by new code changes.
   
   Consult the <<build_cache#build_cache,Build cache chapter>> to learn more.
   
   [.text-right]
   **Next Step:** <<build_scans.adoc#build_scans,Learn about Build Scans>> >>

/docs/userguide/running-builds/introduction/build_scans.adoc
============================================================

.. code-block::

   = Build Scans
   
   A build scan is a *representation of metadata captured* as you run your build.
   
   image::gradle-basic-1.png[]
   
   == Build Scans
   Gradle captures your build metadata and sends it to the link:https://scans.gradle.com/[Build Scan Service].
   The service then transforms the metadata into information you can analyze and share with others.
   
   image::build-scan-1.png[]
   
   The information that scans collect can be an invaluable resource when troubleshooting, collaborating on, or optimizing the performance of your builds.
   
   For example, with a build scan, it뗩 no longer necessary to copy and paste error messages or include all the details about your environment each time you want to ask a question on Stack Overflow, Slack, or the Gradle Forum.
   Instead, copy the link to your latest build scan.
   
   image::build-scan-2.png[]
   
   == Enable Build Scans
   
   To enable build scans on a gradle command, add `--scan` to the command line option:
   
   [source,text]
   ----
    ./gradlew build --scan
   ----
   
   You may be prompted to agree to the terms to use Build Scans.
   
   Vist the link:https://scans.gradle.com/[Build Scans page] to learn more.
   
   [.text-right]
   **Next Step:** <<part1_gradle_init.adoc#part1_gradle_init,Start the Tutorial>> >>

/Section: 游릭 Core Concepts
=======================


/docs/userguide/running-builds/getting_started_eng.adoc
=======================================================

.. code-block::

   = Getting Started
   
   Everyone has to start somewhere, and if you're new to Gradle, this is where to begin.
   
   To get started using Gradle:
   
   1. Read the <<gradle_intro,core concepts chapters>>.
   2. Follow the <<getting_started,tutorial>> for a hands-on approach.
   
   == 1. Gradle Core Concepts
   
   The core concepts section goes through the Gradle basics so that you can quickly understand how to invoke tasks, turn on features, apply plugins, add dependencies to your project, and more.
   
   [sidebar]
   _Training level_: **Beginner** +
   _Reading time_: **25 minutes**
   
   The core concepts cover:
   
   <<gradle_basics.adoc#gradle,Part 1.>> Gradle Overview +
   <<gradle_wrapper_basics.adoc#gradle_wrapper_basics,Part 2.>> Gradle's Wrapper +
   <<command_line_interface_basics.adoc#command_line_interface_basics,Part 3.>> Gradle's Command Line Interface +
   <<settings_file_basics.adoc#settings_file_basics,Part 4.>> Settings File +
   <<build_file_basics.adoc#build_file_basics,Part 5.>> Build Files +
   <<dependency_management_basics.adoc#dependency_management_basics,Part 6.>> Dependency Management +
   <<task_basics.adoc#task_basics,Part 7.>> Tasks +
   <<plugin_basics.adoc#plugin_basics,Part 8.>> Plugins +
   <<build_scans.adoc#build_scans,Part 9.>> Build Scans +
   <<gradle_optimizations.adoc#gradle_optimizations,Part 10.>> Gradle Optimizations +
   
   == 2. Gradle Tutorial
   
   The tutorial will take you from Gradle initialization all the way through to utilizing Gradle's task caching for your basic Java App.
   No previous experience is necessary but a basic knowledge of Java and Kotlin is nice to have.
   
   If you need to install Gradle before the tutorial, you can do so in the <<installation.adoc#installation,installation section>>.
   
   [sidebar]
   _Training level_: **Beginner** +
   _Training time_: **55 minutes**
   
   The tutorial covers:
   
   <<part1_gradle_init#part1_begin,Part 1.>> Initializing the Project +
   <<part2_gradle_tasks#part2_begin,Part 2.>> Running Tasks +
   <<part3_gradle_dep_man#part3_begin,Part 3.>> Understanding Dependencies +
   <<part4_gradle_plugins#part4_begin,Part 4.>> Applying Plugins +
   <<part5_gradle_inc_builds#part5_begin,Part 5.>> Exploring Incremental Builds +
   <<part6_gradle_caching#part6_begin,Part 6.>> Enabling the Cache +
   <<part7_gradle_refs#part7_begin,Part 7.>> Using Reference Materials +

/docs/userguide/running-builds/tutorial/part1_gradle_init.adoc
==============================================================

.. code-block::

   = Part 1: Initializing the Project
   
   Learn the basics of Gradle by creating a Java app using Gradle init.
   
   ****
   **In this section you will:**
   
   - Initialize a new Gradle project
   - Build the project
   - Review Gradle's project structure
   - Open the project in IntelliJ IDEA
   - Explore Gradle files and build scripts
   - Understand the Gradle wrapper
   ****
   
   == Step 0. Before you Begin
   
   1. Make sure you have <<installation.adoc#installation,Gradle installed>>.
   
   2. Install link:https://www.jetbrains.com/idea/download/[IntelliJ IDEA].
   The Community Edition is a free version of IntelliJ IDEA.
   
   == Step 1. Initializing the Project
   To test the Gradle installation, run Gradle from the command-line:
   [source,text]
   ----
   $ gradle
   
   Welcome to Gradle 8.6.
   
   Directory '/' does not contain a Gradle build.
   
   To create a new build in this directory, run gradle init
   ----
   
   If Gradle is not installed, please refer to the <<installation.adoc#installation, installation section>>.
   
   Create a new directory called `tutorial` and `cd` into it:
   [source,text]
   ----
   $ mkdir tutorial
   ----
   [source,text]
   ----
   $ cd tutorial
   ----
   
   Run `gradle init` with parameters to generate a Java application:
   [source,text]
   ----
   $ gradle init --use-defaults --type java-application
   ----
   
   NOTE: In this tutorial, Kotlin DSL is used to build a simple Java project (as it is the default DSL starting in Gradle 8.2). All examples are macOS based.
   
   When you are done, the directory should look as follows:
   
   ----
   較럭較 .gradle             // <1>
   較   較덕較 긽
   較럭較 gradle              // <2>
   較   較덕較 wrapper
   較럭較 gradlew             // <3>
   較럭較 gradlew.bat         // <4>
   較럭較 settings.gradle.kts // <5>
   較럭較 app                 // <6>
   較   較럭較 build.gradle.kts
   較   較덕較 src
   較덕較 긽                   // <7>
   
   ----
   <1> Project-specific cache directory generated by Gradle.
   <2> Contains the JAR file and configuration of the <<gradle_wrapper.adoc#gradle_wrapper_reference,Gradle Wrapper>>.
   <3> macOS and Linux script for executing builds using the <<gradle_wrapper.adoc#gradle_wrapper_reference,Gradle Wrapper>>.
   <4> Windows script for executing builds using the <<gradle_wrapper.adoc#gradle_wrapper_reference,Gradle Wrapper>>.
   <5> The project's <<organizing_gradle_projects.adoc#sec:settings_file, settings file>> where the list of subprojects is defined.
   <6> The source code and build configuration for the Java app.
   <7> Some additional Git files may be present such as `.gitignore`.
   
   == Step 2. Understanding the Gradle Wrapper
   The Gradle Wrapper is the preferred way of starting a Gradle build.
   The Wrapper downloads (if needed) and then invokes a specific version of Gradle declared in the build.
   
   In your newly created project, take a look at the files used by the Gradle Wrapper first.
   It consists of a shell script for macOS and Linux +++<i class="conum" data-value="3"></i>+++ and a batch script for Windows +++<i class="conum" data-value="4"></i>+++.
   
   These scripts allow you to run a Gradle build without requiring that Gradle be installed on your system.
   It also helps ensure that the same version of Gradle is used for builds by different developers and between local and CI machines.
   
   From now on, you will never invoke Gradle directly; instead, you will use the Gradle _wrapper_.
   
   == Step 3. Invoking the Gradle Wrapper
   Use the wrapper by entering the following command:
   [source,text]
   ----
   $ ./gradlew build
   ----
   
   In Windows, the command is:
   [source,text]
   ----
   $ .\gradlew.bat build
   ----
   
   The first time you run the wrapper, it downloads and caches the Gradle binaries if they are not already installed on your machine.
   
   The Gradle Wrapper is designed to be committed to source control so that anyone can build the project without having to first install and configure a specific version of Gradle.
   
   In this case, we invoked Gradle through the wrapper to build our project, so we can see that the `app` directory now includes a new `build` folder:
   [source,text]
   ----
   $ cd app
   ----
   [source,text]
   ----
   $ ls -al
   ----
   ----
   drwxr-xr-x  10 gradle-user  staff  320 May 24 18:07 build
   -rw-r--r--   1 gradle-user  staff  862 May 24 17:45 build.gradle.kts
   drwxr-xr-x   4 gradle-user  staff  128 May 24 17:45 src
   ----
   
   All the files generated by the build process go into the `build` directory unless otherwise specified.
   
   == Step 4. Understanding Gradle's Project Structure
   
   Let's take a look at a standard Gradle project structure and compare it to our tutorial project:
   
   image::tutorial/project-structure.png[]
   
   A *build* contains:
   
   1. A top level `settings.gradle.kts` file.
   2. A *root project*.
   3. One or more *subprojects*, each with its own `build.gradle.kts` file.
   
   Some builds may contain a `build.gradle.kts` file in the root project but this is NOT recommended.
   
   The `libs.version.toml` file is a version catalog used for dependency management which you will learn about in a subsequent section of the tutorial.
   
   In this tutorial:
   
   1. The *root project* is called *tutorial* and is defined with `rootProject.name = "tutorial"` in the `settings.gradle` file.
   2. The *subproject* is called *app* and is defined with `include("app")` in the `settings.gradle` file.
   
   The root project can be in the top-level directory or have its own directory.
   
   A build:
   
   - Represents a bundle of related software that you can build, test, and/or release together.
   - Can optionally include other builds (i.e. additional software such as libraries, plugins, build-time tools, etc).
   
   A project:
   
   - Represents a single piece of your architecture - a library, an app, a Gradle plugin, etc.
   - Can optionally contain other projects.
   
   == Step 5. Viewing Gradle files in an IDE
   Open the project in IntelliJ IDEA by double-clicking on the `settings.gradle.kts` file in the `tutorial` directory:
   
   image::tutorial/intellij-idea-ide.png[]
   
   Open the `settings.gradle.kts` and `build.gradle.kts` files in the IDE:
   
   image::tutorial/intellij-idea-open.png[]
   
   == Step 6. Understanding the Settings file
   A project is composed of one or more subprojects (sometimes called modules).
   
   Gradle reads the `settings.gradle.kts` file to figure out which subprojects comprise a project build.
   
   Take a look at the file in your project:
   [source,kotlin]
   ----
   plugins {
       // Apply the foojay-resolver plugin to allow automatic download of JDKs
       id("org.gradle.toolchains.foojay-resolver-convention") version "0.8.0"
   }
   
   rootProject.name = "tutorial"
   include("app")
   ----
   
   The `tutorial` root project includes the `app` subproject.
   The presence of the `include` call turns the `app` directory into a subproject.
   
   == Step 7. Understanding the Build script
   Each subproject contains its own `build.gradle.kts` file.
   
   The `build.gradle.kts` file is the core component of the build process and defines the tasks necessary to build the project.
   
   The `build.gradle.kts` file is read and executed by Gradle.
   
   Take a closer look at the build file in your `app` subproject (under the `app` directory):
   [source,kotlin]
   ----
   plugins {
       // Apply the application plugin to add support for building a CLI application in Java.
       application
   }
   
   repositories {
       // Use Maven Central for resolving dependencies.
       mavenCentral()
   }
   
   dependencies {
       // Use JUnit Jupiter for testing.
       testImplementation("org.junit.jupiter:junit-jupiter:5.9.1")
   
       // This dependency is used by the application.
       implementation("com.google.guava:guava:32.1.2-jre")
   }
   
   // Apply a specific Java toolchain to ease working on different environments.
   java {
       toolchain {
           languageVersion = JavaLanguageVersion.of(11)
       }
   }
   
   application {
       // Define the main class for the application.
       mainClass = "org.example.App"
   }
   
   tasks.named<Test>("test") {
       // Use JUnit Platform for unit tests.
       useJUnitPlatform()
   }
   ----
   
   This build script lets Gradle know which dependencies and plugins the `app` subproject is using and where to find them.
   We will look at this in more detail in the following sections.
   
   [.text-right]
   **Next Step:** <<part2_gradle_tasks#part2_begin,Running Tasks>> >>

/docs/userguide/running-builds/tutorial/part2_gradle_tasks.adoc
===============================================================

.. code-block::

   = Part 2: Running Gradle Tasks
   
   Learn the basics of Gradle tasks by running one and looking at its output.
   
   ****
   **In this section you will:**
   
   - See available tasks
   - Run a task and inspect the results
   - Understand tasks
   - Explore task dependencies
   ****
   
   == Step 0. Before you Begin
   
   1. You initialized your Java app in <<part1_gradle_init.adoc#part1_begin,part 1>>.
   
   == Step 1. Viewing available Tasks
   A _task_ is a basic unit of work that can be done by Gradle as part of the build.
   
   In the `tutorial` directory, enter the command below to list all the available tasks in the project:
   [source,text]
   ----
   $ ./gradlew tasks
   ----
   
   The list includes tasks contributed by the `application` plugin and the plugin it applies:
   
   [source,text]
   ----
   Application tasks
   -----------------
   run - Runs this project as a JVM application
   
   Build tasks
   -----------
   assemble - Assembles the outputs of this project.
   build - Assembles and tests this project.
   
   ...
   
   Documentation tasks
   -------------------
   javadoc - Generates Javadoc API documentation for the main source code.
   
   ...
   
   Other tasks
   -----------
   compileJava - Compiles main Java source.
   
   ...
   ----
   A task might be responsible for compilation, copying, and moving files around, creating JAR files, generating Javadoc, publishing artifacts to repositories, or many other discrete units of work.
   
   You can also list the tasks only available in the `app` subproject by running `./gradlew :app:tasks`.
   
   TIP: You can obtain more information in the task listing using the `--all` option: `./gradlew tasks --all`.
   
   In <<part1_gradle_init.adoc#part1_begin,part 1>> of the tutorial, we ran the `build` task using the `./gradlew build` command.
   
   == Step 2. Understanding Tasks
   We've listed the tasks available when the project is initialized, but what if we want to create our own tasks?
   
   Gradle provides many _built-in_ tasks that developers can use to enhance build scripts.
   
   This example task copies `*.war` files from the `source` directory to the `target` directory using the `Copy` built-in task.
   
   [source,kotlin]
   ----
   tasks.register<Copy>("copyTask") {
       from("source")
       into("target")
       include("*.war")
   }
   ----
   
   This task, if added to `build.gradle.kts` file in the `app` subproject directory, would be executed using the command `./gradlew :app:copyTask`.
   
   Popular built-in tasks include:
   
   - **Copy** - `Copy` is useful to copy files around.
   - **Delete** -  `Delete` is useful to delete files and directories.
   - **Exec** - `Exec` is useful to execute arbitrary O/S commands.
   - **Zip** - `Zip` is useful to bundle files.
   
   Many more are included in the link:{kotlinDslPath}/gradle/org.gradle.api.tasks/-delete/index.html[DSL documentation].
   
   == Step 3. Understanding Dependencies Between Tasks
   Many times, a task requires another task to run first.
   If task B uses the output of task A, then task A must complete before task B begins.
   
   - A task may declare its dependencies explicitly.
   - A task may depend on other tasks implicitly.
   
   Here is an example of explicit task dependency:
   [source,kotlin]
   ----
   tasks.register("hello") {
       doLast {
           println('Hello!')
       }
   }
   
   tasks.register("greet") {
       doLast {
           println('How are you?')
       }
       dependsOn("hello")
   }
   ----
   
   In this case, `hello` prints before `greet`. The output is `Hello! How are you?`.
   
   Task execution order is automatically determined by Gradle, taking into account explicit and implicit task dependencies.
   If there is no dependency between tasks, Gradle enables users to request a specific execution order.
   
   == Step 4. Viewing Tasks in the IDE
   Project tasks are also available in IntelliJ.
   The project should be open following <<part1_gradle_init.adoc#part1_begin,part 1>> of the tutorial.
   
   On the right-hand side of your window, open the `Gradle` pane:
   
   image::tutorial/intellij-idea-tasks.png[]
   
   == Step 5. Running Tasks in the IDE
   You can run a Gradle task via IntelliJ by double-clicking that task in the pane.
   
   Double-click **tutorial > app > build > build**.
   
   image::tutorial/intellij-idea-build.png[]
   
   Once the build finishes, make sure it is successful in the IntelliJ console:
   [source,text]
   ----
   BUILD SUCCESSFUL in 966ms
   7 actionable tasks: 7 executed
   3:18:24 AM: Execution finished 'build'.
   ----
   
   == Step 6. Running Tasks in the Terminal
   Run the following command in your terminal:
   [source,text]
   ----
   $ ./gradlew build
   ----
   ----
   > Task :app:compileJava
   > Task :app:processResources
   > Task :app:classes
   > Task :app:jar
   > Task :app:startScripts
   > Task :app:distTar
   > Task :app:distZip
   > Task :app:assemble
   > Task :app:compileTestJava
   > Task :app:processTestResources
   > Task :app:testClasses
   > Task :app:test
   > Task :app:check
   > Task :app:build
   ----
   The `build` task uses the source code and its dependencies to build the app.
   As seen in the output, the `build` task compiles, assembles, tests, and checks the code.
   
   The tasks are printed in order of execution.
   The `jar` tasks is a dependency of the `build` task.
   
   The `jar` task creates an executable JAR file of the app.
   Let's run it by itself:
   [source,text]
   ----
   $ ./gradlew jar
   ----
   ----
   > Task :app:compileJava
   > Task :app:processResources
   > Task :app:classes
   > Task :app:jar
   ----
   As expected, the `compileJava` task is a dependency of the `jar` task and executed first.
   Once the task finishes, an `app.jar` file is created in your `tutorial/app/build/libs/` folder.
   
   Invoke the `run` task and check the output:
   [source,text]
   ----
   $ ./gradlew run
   ----
   ----
   > Task :app:compileJava
   > Task :app:processResources
   > Task :app:classes
   
   > Task :app:run
   Hello World!
   
   BUILD SUCCESSFUL in 325ms
   ----
   
   The `run` task executes the code in `tutorial/app/src/main/java/com.gradle.tutorial/App.java`.
   The Java code in `App.java` simply prints "Hello World" to the screen:
   [source,java]
   ----
   public class App {
       public String getGreeting() {
           return "Hello World!";
       }
       public static void main(String[] args) {
           System.out.println(new App().getGreeting());
       }
   }
   ----
   
   [.text-right]
   **Next Step:** <<part3_gradle_dep_man#part3_begin,Dependency Management>> >>

/docs/userguide/running-builds/tutorial/part3_gradle_dep_man.adoc
=================================================================

.. code-block::

   = Part 3: Dependency Management
   
   Learn the basics of project dependencies and Gradle's dependency management.
   
   ****
   **In this section you will:**
   
   - Understand project dependencies
   - Inspect project dependencies
   - Use a Build Scan to analyze dependencies
   - Update project dependencies
   - Understand transitive dependencies
   - Adding a version catalog
   ****
   
   == Step 0. Before you Begin
   
   1. You initialized your Java app in <<part1_gradle_init.adoc#part1_begin,part 1>>.
   2. You ran several tasks in <<part2_gradle_tasks#part2_begin,part 2>>.
   
   == Step 1. Understanding Project Dependencies
   Gradle provides excellent support for dependency management and automation.
   
   Let's take another look at our build script (the `build.gradle.kts` file), specifically the following section:
   [source,kotlin]
   ----
   repositories {
       // Use Maven Central for resolving dependencies.
       mavenCentral()
   }
   
   dependencies {
       // Use JUnit Jupiter for testing.
       testImplementation("org.junit.jupiter:junit-jupiter:5.9.1")
   
       // This dependency is used by the application.
       implementation("com.google.guava:guava:32.1.2-jre")
   }
   ----
   
   Some key concepts in Gradle dependency management include:
   
   *Repositories* - The source of dependencies -> `mavenCentral()`
   
   https://mvnrepository.com/repos/central[Maven Central] is a collection of jar files, plugins, and libraries provided by the Maven community and backed by https://central.sonatype.org/[Sonatype^].
   It is the de-facto public artifact store for Java and is used by many build systems.
   
   *Dependencies* - Dependencies declared via configuration types -> https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api[`junit`] and https://mvnrepository.com/artifact/com.google.guava/guava[`guava`] +
   
   Gradle needs specific information to find a dependency.
   Let's look at `com.google.guava:guava:32.1.2-jre` and `org.junit.jupiter:junit-jupiter-api:5.9.1`; they are broken down as follows:
   
   [cols="10h,30,40,20"]
   |===
   | |Description | com.google.guava:guava:32.1.2-jre | org.junit.jupiter:junit-jupiter-api:5.9.1
   
   |Group
   |identifier of an organization
   |`com.google.guava`
   |`org.junit.jupiter`
   
   |Name
   |dependency identifier
   |`guava`
   |`junit-jupiter-api`
   
   |Version
   |version # to import
   |`32.1.2-jre`
   |`5.9.1`
   |===
   
   == Step 2. Understanding Transitive Dependencies
   A _transitive dependency_ is a dependency of a dependency.
   
   For our `guava` dependency to work, it requires a library called `failureaccess`.
   Therefore `failureaccess` is a transitive dependency of the project.
   
   == Step 3. Viewing Project Dependencies
   You can view your dependency tree in the terminal using the `./gradlew :app:dependencies` command:
   [source,kotlin]
   ----
   $ ./gradlew :app:dependencies
   
   > Task :app:dependencies
   
   ------------------------------------------------------------
   Project ':app'
   ------------------------------------------------------------
   
   ...
   
   compileClasspath - Compile classpath for source set 'main'.
   \--- com.google.guava:guava:32.1.2-jre
        +--- com.google.guava:failureaccess:1.0.1
        +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
        +--- com.google.code.findbugs:jsr305:3.0.2
        +--- org.checkerframework:checker-qual:3.12.0
        +--- com.google.errorprone:error_prone_annotations:2.11.0
        \--- com.google.j2objc:j2objc-annotations:1.3
   
   ...
   ----
   
   The output clearly depicts that `com.google.guava:guava:32.1.2-jre` has a dependency on `com.google.guava:failureaccess:1.0.1`.
   
   == Step 4. Viewing Dependencies in a Build Scan춽
   To view dependencies using a https://scans.gradle.com/[Build Scan], run the build task with an optional `--scan` flag.
   
   In the `tutorial` directory, enter the command below and follow the prompt to accept the terms:
   [source,text]
   ----
   $ ./gradlew build --scan
   
   BUILD SUCCESSFUL in 423ms
   7 actionable tasks: 7 up-to-date
   
   Publishing a build scan to scans.gradle.com requires accepting the Gradle Terms of Service defined at https://gradle.com/terms-of-service. Do you accept these terms? [yes, no] yes
   
   Gradle Terms of Service accepted.
   
   Publishing build scan...
   https://gradle.com/s/link
   ----
   
   A https://scans.gradle.com/[Build Scan] is a shareable and centralized record of a build and is available as a free service from Gradle.
   
   Click the link provided in the prompt: `https://gradle.com/s/link`.
   
   WARNING: You will have to accept the terms of service to use Build Scans.
   
   You will need to activate the Build Scan by using your email:
   
   image::tutorial/build-scan-prompt.png[]
   
   You will receive the final link to the scan in your inbox which should look as follows:
   
   image::tutorial/build-scan-results.png[]
   
   Open the **Dependencies** tab in the menu and expand `compileClasspath`, `runtimeClasspath`, `testCompileClasspath`, and `testRuntimeClasspath`:
   
   image::tutorial/build-scan-dependencies.png[]
   
   As expected, we can see the declared dependencies `junit` and `guava` are used by Gradle to compile, run, and test the app.
   
   Expand `com.google.guava:guava:32.1.2-jre` and `org.junit.jupiter:junit-jupiter:5.9.1` in the window:
   
   image::tutorial/build-scan-trans-dependencies.png[]
   
   There are several transitive dependencies under `junit` and `guava`.
   For example, the `com.google.code.findbugs:jsr305:3.0.2` transitive dependency comes from the `com.google.guava:guava:32.1.2-jre` dependency.
   
   == Step 5. Updating Project Dependencies
   Adding and changing dependencies is done in the build file.
   
   Let's change the `guava` version and look at how this affects the dependency tree.
   
   Change the `guava` dependency to the `gradle.build.kts` file to:
   [source,kotlin]
   ----
   implementation("com.google.guava:guava:30.0-jre")
   ----
   
   If you change the file using IntelliJ, don't forget to click the `sync` Gradle button:
   
   image::tutorial/intellij-idea-dep-man.png[]
   
   Run `./gradlew build --scan` and view the Build Scan results:
   
   image::tutorial/build-scan-change.png[]
   
   Run `./gradlew :app:dependencies` in the terminal to check the changes in the dependency tree:
   [source,text]
   ----
   compileClasspath - Compile classpath for source set 'main'.
   \--- com.google.guava:guava:30.0-jre
        +--- com.google.guava:failureaccess:1.0.1
        +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
        +--- com.google.code.findbugs:jsr305:3.0.2
        +--- org.checkerframework:checker-qual:3.5.0
        +--- com.google.errorprone:error_prone_annotations:2.3.4
        \--- com.google.j2objc:j2objc-annotations:1.3
   
   ...
   ----
   
   It is clear the `guava` dependency has been updated to version `30.0` and the transitive dependencies have changed as well.
   
   == Step 6. Adding a Version Catalog
   A version catalog is used to declare all direct dependencies of a project in a central location.
   
   It is created in `gradle/libs.versions.toml` and referenced in subproject build files.
   
   First, create the `libs.versions.toml` file in the `gradle` directory.
   
   Then, add the following lines to this new file:
   ----
   [versions]
   junitVer = "5.9.1"
   guavaVer = "32.1.2-jre"
   
   [libraries]
   junit = { module = "org.junit.jupiter:junit-jupiter", version.ref = "junitVer" }
   guava = { module = "com.google.guava:guava", version.ref = "guavaVer" }
   ----
   
   In your `app/build.gradle.kts` file, update the dependency block accordingly:
   ----
   dependencies {
       testImplementation(libs.junit)
       implementation(libs.guava)
   }
   ----
   
   Run `./gradlew build` to make sure the changes take effect.
   
   Finally, make sure everything is working using the `run` task, either in your terminal or IDE:
   ----
   ./gradlew run
   
   > Task :app:compileJava UP-TO-DATE
   > Task :app:processResources NO-SOURCE
   > Task :app:classes UP-TO-DATE
   
   > Task :app:run
   Hello World!
   ----
   
   A version catalog provides a number of advantages over declaring the dependencies directly in build scripts:
   
   - Gradle generates type-safe accessors from the catalog so that you can easily add dependencies with autocompletion in the IDE.
   - It is a central place to declare a version of a dependency so that any changes apply to every subproject.
   
   [.text-right]
   **Next Step:** <<part4_gradle_plugins#part4_begin,Applying Plugins>> >>

/docs/userguide/running-builds/tutorial/part4_gradle_plugins.adoc
=================================================================

.. code-block::

   = Part 4: Applying Gradle Plugins
   
   Learn about how plugins extend Gradle's capabilities and use a popular plugin.
   
   ****
   **In this section you will:**
   
   - Apply a plugin
   - Configure the plugin
   - Use the plugin
   - Explore other plugins
   ****
   
   == Step 0. Before you Begin
   
   1. You initialized your Java app in <<part1_gradle_init.adoc#part1_begin,part 1>>.
   2. You ran several tasks in <<part2_gradle_tasks#part2_begin,part 2>>.
   3. You learned about dependency management in <<part3_gradle_dep_man#part3_begin,part 3>>.
   
   == Step 1. Understanding Plugins
   Plugins are the primary method to organize build logic and reuse build logic within a project.
   
   Plugins are also used to distribute custom tasks as packaged code.
   
   Applying a plugin to a project executes code that can create tasks, configure properties, and otherwise extend the project's capabilities. Generally, plugins use the Gradle API to provide additional functionality and extend Gradle's core features.
   
   Plugins can:
   
   - Add tasks to the project (e.g. compile, test).
   - Extend the basic Gradle model (e.g. add new DSL elements that can be configured).
   - Configure the project, according to conventions (e.g. add new tasks or configure sensible defaults).
   - Apply specific configuration (e.g. add organizational repositories or enforce standards).
   - Add new properties and methods to existing types via extensions.
   
   == Step 2. Applying a Plugin
   Our project currently applies a single plugin, the <<application_plugin#application_plugin,Application Plugin>> which is bundled with Gradle:
   [source,groovy]
   ----
   plugins {
       // Apply the application plugin to add support for building a CLI application in Java.
       application
   }
   ----
   
   Let's apply a plugin to our project that is maintained and distributed by Gradle called the <<publishing_maven#publishing_maven,Maven Publish Plugin>>.
   The Maven Publish Plugin provides the ability to publish build artifacts to an https://maven.apache.org/[Apache Maven repository].
   It can also publish to Maven local which is a repository located on your machine.
   
   The default location for Maven local repository may vary but is typically:
   
   - **Mac**: /Users/\[username]/.m2
   - **Linux**: /home/\[username]/.m2
   - **Windows**: C:\Users\[username]\.m2
   
   A publication destined for a Maven repository normally includes:
   
   - One or more artifacts
   - The Gradle Module Metadata
   - The Maven POM file
   
   Apply the plugin by adding `maven-publish` to the plugins block in `build.gradle.kts`:
   [source,groovy]
   ----
   plugins {
       // Apply the application plugin to add support for building a CLI application in Java.
       application
       `maven-publish`
   }
   ----
   
   Don't forget to sync Gradle if you are using IntelliJ IDEA.
   
   Let's make sure the plugin has been applied by looking at the new tasks that are available.
   
   Run `./gradlew :app:tasks` in your command line:
   [source,text]
   ----
   $ ./gradlew :app:tasks
   
   > Task :app:tasks
   
   ------------------------------------------------------------
   Tasks runnable from project ':app'
   ------------------------------------------------------------
   
   ...
   
   Publishing tasks
   ----------------
   publish - Publishes all publications produced by this project.
   publishToMavenLocal - Publishes all Maven publications produced by this project to the local Maven cache.
   ----
   
   A new set of publishing tasks are now available called `publish`, and `publishToMavenLocal`.
   
   Similarly, the new tasks from the Maven Publish plugin are now available in IntelliJ in the Gradle right-hand pane.
   
   image::tutorial/intellij-idea-plugin.png[]
   
   == Step 3. Configuring the Plugin
   Add the publishing information to your `build.gradle.kts` file:
   [source]
   ----
   publishing {
       publications {
           create<MavenPublication>("maven") {
               groupId = "com.gradle.tutorial"
               artifactId = "tutorial"
               version = "1.0"
   
               from(components["java"])
           }
       }
   }
   ----
   
   Run `./gradlew :app:tasks` in your command line again, you will see additional tasks now that we have given the plugin additional information about our app:
   [source,text]
   ----
   $ ./gradlew :app:tasks
   
   > Task :app:tasks
   
   ------------------------------------------------------------
   Tasks runnable from project ':app'
   ------------------------------------------------------------
   
   ...
   
   Publishing tasks
   ----------------
   generateMetadataFileForMavenPublication - Generates the Gradle metadata file for publication 'maven'.
   generatePomFileForMavenPublication - Generates the Maven POM file for publication 'maven'.
   publish - Publishes all publications produced by this project.
   publishMavenPublicationToMavenLocal - Publishes Maven publication 'maven' to the local Maven repository.
   publishToMavenLocal - Publishes all Maven publications produced by this project to the local Maven cache.
   ----
   
   image::tutorial/intellij-idea-pub.png[]
   
   == Step 4. Using the Plugin
   To use the plugin, run the `publishToMavenLocal` task by running `./gradlew :app:publishToMavenLocal`.
   [source,text]
   ----
   $ ./gradlew :app:publishToMavenLocal
   
   > Task :app:compileJava FROM-CACHE
   > Task :app:processResources NO-SOURCE
   > Task :app:classes UP-TO-DATE
   > Task :app:jar
   > Task :app:generateMetadataFileForMavenPublication
   > Task :app:generatePomFileForMavenPublication
   > Task :app:publishMavenPublicationToMavenLocal
   > Task :app:publishToMavenLocal
   BUILD SUCCESSFUL in 331ms
   ----
   
   The `publishToMavenLocal` task builds the POM file and the artifacts to be published. It then _installs_ them into the local Maven repository.
   
   You can view the POM and GMM file in the `build` directory:
   
   image::tutorial/intellij-idea-dist.png[]
   
   You can also view the files in your Maven Local directory: `/Users/\[username]/m2/repository/com/gradle/tutorial/tutorial/1.0`.
   
   [source,xml]
   ----
   <?xml version="1.0" encoding="UTF-8"?>
   <project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
     <modelVersion>4.0.0</modelVersion>
     <groupId>com.gradle.tutorial</groupId>
     <artifactId>tutorial</artifactId>
     <version>1.0</version>
     <packaging>pom</packaging>
   </project>
   ----
   
   == Step 5. Exploring Plugins
   Plugins are used to extend build capability and customize Gradle.
   
   Using plugins is the **primary mechanism for organizing build logic**.
   
   Plugin authors can either keep their plugins private or distribute them to the public. As such, plugins are distributed three ways:
   
   1. **Core plugins** - Gradle develops and maintains a set of <<plugin_reference#plugin_reference,Core Plugins>>.
   2. **Community plugins** - Gradle's community shares plugins via the https://plugins.gradle.org[Gradle Plugin Portal].
   3. **Custom plugins** - Gradle enables user to create custom plugins using link:{groovyDslPath}#[APIs].
   
   link:#[**Convention plugins**] are plugins used to share build logic between subprojects (modules).
   Users can wrap common logic in a convention plugin.
   For example, a code coverage plugin used as a convention plugin can survey code coverage for the _entire project_ and _not_ just a specific subproject.
   
   TIP: Gradle highly recommends the use of Convention plugins.
   
   [.text-right]
   **Next Step:** <<part5_gradle_inc_builds.adoc#part5_begin,Exploring Incremental Builds>> >>

/docs/userguide/running-builds/tutorial/part5_gradle_inc_builds.adoc
====================================================================

.. code-block::

   = Part 5: Exploring Incremental Builds
   
   Learn the basics of Gradle's incremental builds.
   
   ****
   **In this section you will:**
   
   - Understand incremental builds
   ****
   
   == Step 0. Before you Begin
   
   1. You initialized your Java app in <<part1_gradle_init.adoc#part1_begin,part 1>>.
   2. You ran several tasks in <<part2_gradle_tasks#part2_begin,part 2>>.
   3. You learned about dependency management in <<part3_gradle_dep_man#part3_begin,part 3>>.
   4. You applied a plugin to your app in <<part4_gradle_plugins#part4_begin,part 4>>.
   
   == Step 1. Understanding Incremental Builds
   It's important to know that Gradle optimizes your build in a variety of ways.
   One such optimization is called _incremental builds_.
   
   An _incremental build_ is a build that avoids running tasks whose inputs did not change since the previous build, making the execution of such tasks unnecessary.
   
   For incremental builds to work, tasks must define their inputs and outputs. At build time, Gradle will determine whether the input or outputs have changed. If they have changed, Gradle will execute the task. Otherwise, it will skip execution.
   
   == Step 2. Updating Gradle Properties
   To better see incremental builds in action, we are going to switch the console output to verbose.
   
   In the top-level folder of your app (`tutorial`), create a `gradle.properties` file.
   
   [source,properties]
   ----
   $ touch gradle.properties
   ----
   
   Add `org.gradle.console=verbose` so the contents of the file look like this:
   [source,properties]
   ----
   org.gradle.console=verbose
   ----
   
   == Step 3. Analyzing Incremental Builds
   Run the clean task and then the build task using the `./gradlew :app:clean :app:build` command:
   [source,text]
   ----
   $ ./gradlew :app:clean :app:build
   
   > Task :app:clean
   > Task :app:compileJava
   > Task :app:processResources NO-SOURCE
   > Task :app:classes
   > Task :app:jar
   > Task :app:startScripts
   > Task :app:distTar
   > Task :app:distZip
   > Task :app:assemble
   > Task :app:compileTestJava
   > Task :app:processTestResources NO-SOURCE
   > Task :app:testClasses
   > Task :app:test
   > Task :app:check
   > Task :app:build
   
   BUILD SUCCESSFUL in 1s
   8 actionable tasks: 8 executed
   ----
   
   No surprise here, Gradle invoked all the tasks needed to build the app.
   This was done successfully.
   
   Run the build again to view the _incremental build_ optimization in action:
   [source,text]
   ----
   $ ./gradlew :app:build
   
   > Task :app:compileJava UP-TO-DATE
   > Task :app:processResources NO-SOURCE
   > Task :app:classes UP-TO-DATE
   > Task :app:jar UP-TO-DATE
   > Task :app:startScripts UP-TO-DATE
   > Task :app:distTar UP-TO-DATE
   > Task :app:distZip UP-TO-DATE
   > Task :app:assemble UP-TO-DATE
   > Task :app:compileTestJava UP-TO-DATE
   > Task :app:processTestResources NO-SOURCE
   > Task :app:testClasses UP-TO-DATE
   > Task :app:test UP-TO-DATE
   > Task :app:check UP-TO-DATE
   > Task :app:build UP-TO-DATE
   
   BUILD SUCCESSFUL in 409ms
   7 actionable tasks: 7 up-to-date
   ----
   
   Most tasks now have the `UP-TO-DATE` label.
   This is how Gradle lets us know that inputs and outputs have not changed and therefore some tasks did not re-run.
   
   == Step 4. Understanding Outcome Labels
   There are four labels that developers can use to view task outcomes when verbose mode is turned on:
   
   |===
   |Outcome Label |Description
   
   |UP-TO-DATE
   |Task that has been already executed and hasn't changed (incremental build feature)
   
   |SKIPPED
   |Task was explicitly prevented from running
   
   |FROM-CACHE
   |Task output has been copied to local directory from previous builds in the build cache (caching feature)
   
   |NO-SOURCE
   |Task was not executed because its required inputs were not available
   |===
   
   If there is no label, the task was newly executed by Gradle (locally).
   
   We will look at the `FROM-CACHE` label in the next section.
   
   [.text-right]
   **Next Step:** <<part6_gradle_caching#part6_begin,Enabling the Build Cache>> >>

/docs/userguide/running-builds/tutorial/part6_gradle_caching.adoc
=================================================================

.. code-block::

   = Part 6: Enabling the Gradle Build Cache
   
   Learn the basics of Gradle's caching system.
   
   ****
   **In this section you will:**
   
   - Turn on the local Build Cache
   - Understand caching
   - Explore remote build caching
   ****
   
   == Step 0. Before you Begin
   
   1. You initialized your Java app in <<part1_gradle_init.adoc#part1_begin,part 1>>.
   2. You ran several tasks in <<part2_gradle_tasks#part2_begin,part 2>>.
   3. You learned about dependency management in <<part3_gradle_dep_man#part3_begin,part 3>>.
   4. You applied a plugin to your app in <<part4_gradle_plugins#part4_begin,part 4>>.
   5. You learned about incremental builds in <<part5_gradle_inc_builds#part5_begin,part 5>>.
   
   == Step 1. Understanding Caching
   Incremental Builds are a great optimization that helps avoid work that is already done.
   If a developer is continuously making changes in a single file, there is likely no need to rebuild all the other files in the project.
   
   However, what happens when the same developer decides to switch to a new branch created last week?
   The files are rebuilt, even though the developer is building something that has been built before.
   
   This is where a Build Cache is helpful. The cache stores previous build results, and greatly reduces the need to rebuild things when they have already been built locally.
   
   Let's start by turning on the local Build Cache for your app.
   
   == Step 2. Enabling the Local Build Cache
   Run the clean task and then the build task using the `./gradlew :app:clean :app:build` command:
   [source,text]
   ----
   $ ./gradlew :app:clean :app:build
   > Task :app:clean
   > Task :app:compileJava
   > Task :app:processResources NO-SOURCE
   > Task :app:classes
   > Task :app:jar
   > Task :app:startScripts
   > Task :app:distTar
   > Task :app:distZip
   > Task :app:assemble
   > Task :app:compileTestJava
   > Task :app:processTestResources NO-SOURCE
   > Task :app:testClasses
   > Task :app:test
   > Task :app:check
   > Task :app:build
   
   BUILD SUCCESSFUL in 1s
   8 actionable tasks: 8 executed
   ----
   
   Add `org.gradle.caching=true` to the `gradle.properties` file:
   [source,properties]
   ----
   org.gradle.console=verbose
   org.gradle.caching=true
   ----
   
   == Step 3. Using the Local Build Cache
   Run the build task to populate the local Build Cache:
   [source,text]
   ----
   $ ./gradlew :app:build
   
   > Task :app:compileJava UP-TO-DATE
   > Task :app:processResources NO-SOURCE
   > Task :app:classes UP-TO-DATE
   > Task :app:jar UP-TO-DATE
   > Task :app:startScripts UP-TO-DATE
   > Task :app:distTar UP-TO-DATE
   > Task :app:distZip UP-TO-DATE
   > Task :app:assemble UP-TO-DATE
   > Task :app:compileTestJava UP-TO-DATE
   > Task :app:processTestResources NO-SOURCE
   > Task :app:testClasses UP-TO-DATE
   > Task :app:test UP-TO-DATE
   > Task :app:check UP-TO-DATE
   > Task :app:build UP-TO-DATE
   
   BUILD SUCCESSFUL in 409ms
   7 actionable tasks: 7 up-to-date
   ----
   
   No surprise here, thanks to incremental builds, Gradle noticed nothing changed.
   However, in the background, the local build cache has been populated.
   
   Let's run the clean and build again:
   [source,text]
   ----
   $ ./gradlew :app:clean :app:build
   
   > Task :app:clean
   > Task :app:compileJava FROM-CACHE
   > Task :app:processResources NO-SOURCE
   > Task :app:classes UP-TO-DATE
   > Task :app:jar
   > Task :app:startScripts
   > Task :app:distTar
   > Task :app:distZip
   > Task :app:assemble
   > Task :app:compileTestJava FROM-CACHE
   > Task :app:processTestResources NO-SOURCE
   > Task :app:testClasses UP-TO-DATE
   > Task :app:test FROM-CACHE
   > Task :app:check UP-TO-DATE
   > Task :app:build
   
   BUILD SUCCESSFUL in 525ms
   8 actionable tasks: 5 executed, 3 from cache
   ----
   
   Gradle lets us know the outcome of each task in the console output:
   
   - `FROM-CACHE` - tasks have been fetched from the local build cache.
   - `UP-TO-DATE` - tasks that used incremental build and were not re-run.
   
   To summarize:
   
   1. First, we used the `build` task to populate our local cache with task inputs and outputs -- we can imagine this was done a week ago.
   2. Then, we used the `clean` task to mimic switching branches -- overriding previous outputs.
   3. Finally, we used the `build` task -- unlike incremental builds, the previous outputs were stored in the local cache and could be reused.
   
   Gradle is efficient, especially with the local build cache turned on.
   Gradle will look at the cache directory on your machine to check for output files that may already exist. If they do, instead of running that task, it will copy its (output) results into your project `build` directory.
   
   The _outcome label_ `FROM-CACHE` lets the user know that Gradle has fetched the task results from the local build cache.
   
   The local Gradle Build Cache is located at:
   
   - **On Windows**: %USERPROFILE%\.gradle\caches
   - **On OS X / UNIX**: ~/.gradle/caches/
   
   Gradle will periodically clean up the local build cache directory by removing entries that have not been used recently to conserve disk space.
   
   == Step 4. Understanding Remote Caching
   In addition to the local build cache present on a developer's machine, Gradle can make use of remote build caches which can be used by multiple developers.
   
   The idea of a remote cache is to share commonly built task outputs across remote builds to improve build times.
   
   When both remote and local caches are enabled, then the build output is first checked in the local cache.
   If the output isn't present in the local cache, it'll be downloaded from the remote cache and also stored in the local cache.
   
   To try out the remote Build Cache, Gradle provides a free link:https://hub.docker.com/r/gradle/build-cache-node[Docker image] for a single remote Build Cache node.
   For production grade deployments, link:https://gradle.com/gradle-enterprise-solutions/build-cache/[Develocity] is recommended.
   
   [.text-right]
   **Next Step:** <<part7_gradle_refs.adoc#part7_begin,Using Reference Materials>> >>

/docs/userguide/running-builds/tutorial/part7_gradle_refs.adoc
==============================================================

.. code-block::

   = Part 7: Using Gradle's Reference Materials
   
   Learn about the references you will need as you work with Gradle.
   
   ****
   **In this section you will:**
   
   - Learn about References
   - Finish the Tutorial
   ****
   
   == Before you begin
   
   1. You initialized your Java app in <<part1_gradle_init.adoc#part1_begin,part 1>>.
   2. You ran several tasks in <<part2_gradle_tasks#part2_begin,part 2>>.
   3. You learned about dependency management in <<part3_gradle_dep_man#part3_begin,part 3>>.
   4. You applied a plugin to your app in <<part4_gradle_plugins#part4_begin,part 4>>.
   5. You learned about incremental builds in <<part5_gradle_inc_builds#part5_begin,part 5>>.
   6. You turned on the local cache in <<part6_gradle_caching#part6_begin,part 6>>.
   
   == Step 1. Gradle References
   To work with Gradle, the following references are useful:
   
   - Gradle API http://gradle.org/docs/current/javadoc/[Javadocs]
   - Gradle's https://docs.gradle.org/current/dsl/index.html[Groovy DSL] or Gradle's https://docs.gradle.org/current/kotlin-dsl/index.html[Kotlin DSL]
   
   To find plugins:
   
   - Gradle <<plugin_reference#plugin_reference,Core Plugins>>
   - Gradle link:https://plugins.gradle.org/[Plugin Portal]
   
   To view all Gradle releases:
   
   - https://gradle.org/releases/[Gradle Releases]
   - http://gradle.org/docs/current/release-notes[Release Notes]
   
   For Gradle support:
   
   - link:https://discuss.gradle.org/[Gradle Forum]
   - link:https://gradle-community.slack.com/[Gradle Slack Channel]
   - link:https://gradle.org/courses/[Free Gradle Training]
   
   == Step 2. Next steps
   We recommend going through each section of the User Manual.
   
   [.text-right]
   **Next Step:** <<command_line_interface#command_line_interface,Running Gradle Builds>> >>

/Section: 游릭 Other Topics
======================


/docs/userguide/running-builds/additional/continuous_builds.adoc
================================================================

.. code-block::

   = Continuous Builds
   
   Continuous Build allows you to automatically re-execute the requested tasks when file inputs change.
   You can execute the build in this mode using the `-t` or `--continuous` command-line option.
   
   For example, you can continuously run the `test` task and all dependent tasks by running:
   
   ----
   $ gradle test --continuous
   ----
   
   Gradle will behave as if you ran `gradle test` after a change to sources or tests that contribute to the requested tasks.
   This means unrelated changes (such as changes to build scripts) will not trigger a rebuild.
   To incorporate build logic changes, the continuous build must be restarted manually.
   
   Continuous build uses <<file_system_watching.adoc#sec:daemon_watch_fs,file system watching>> to detect changes to the inputs.
   If file system watching does not work on your system, then continuous build won't work either.
   In particular, continuous build does not work when using `--no-daemon`.
   
   When Gradle detects a change to the inputs, it will not trigger the build immediately.
   Instead, it will wait until no additional changes are detected for a certain period of time - the quiet period.
   You can configure the quiet period in milliseconds by the Gradle property `<<build_environment.adoc#sec:gradle_configuration_properties,org.gradle.continuous.quietperiod>>`.
   
   == Terminating Continuous Build
   If Gradle is attached to an interactive input source, such as a terminal, the continuous build can be exited by pressing `CTRL-D` (On Microsoft Windows, it is required to also press `ENTER` or `RETURN` after `CTRL-D`).
   
   If Gradle is not attached to an interactive input source (e.g. is running as part of a script), the build process must be terminated (e.g. using the `kill` command or similar).
   
   If the build is being executed via the Tooling API, the build can be cancelled using the Tooling API's cancellation mechanism.
   
   == Limitations
   Under some circumstances, continuous build may not detect changes to inputs.
   
   === Creating input directories
   Sometimes, creating an input directory that was previously missing does not trigger a build, due to the way file system watching works.
   For example, creating the `src/main/java` directory may not trigger a build.
   Similarly, if the input is a <<working_with_files.adoc#filtering_files,filtered file tree>> and no files are matching the filter, the creation of matching files may not trigger a build.
   
   === Inputs of untracked tasks
   Changes to the inputs of <<incremental_build.adoc#sec:disable-state-tracking,untracked tasks>> or tasks that have no outputs may not trigger a build.
   
   === Changes to files outside of project directories
   Gradle only watches for changes to files inside the project directory.
   Changes to files outside the project directory will go undetected and not trigger a build.
   
   === Build cycles
   Gradle starts watching for changes just before a task executes.
   If a task modifies its own inputs while executing, Gradle will detect the change and trigger a new build.
   If every time the task executes, the inputs are modified again, the build will be triggered again.
   This isn't unique to continuous build.
   A task that modifies its own inputs will never be considered up-to-date when run "normally" without continuous build.
   
   If your build enters a build cycle like this, you can track down the task by looking at the list of files reported changed by Gradle.
   After identifying the file(s) that are changed during each build, you should look for a task that has that file as an input.
   In some cases, it may be obvious (e.g., a Java file is compiled with `compileJava`).
   In other cases, you can use `--info` logging to find the task that is out-of-date due to the identified files.

/docs/userguide/running-builds/additional/gradle_ides.adoc
==========================================================

.. code-block::

   = Gradle in IDEs
   
   Many IDEs support Gradle including Android Studio, IntelliJ IDEA, Visual Studio Code, Eclipse, and NetBeans.
   
   == IntelliJ IDEA
   
   IntelliJ IDEA supports a fully-functional integration with Gradle that helps you automate your building process.
   
   image::intellij_idea.png[]
   
   You can easily create a new Gradle project, open and sync an existing one, work with several linked projects simultaneously, and manage them.
   
   You can find documentation link:https://www.jetbrains.com/help/idea/gradle.html[here].
   
   == Android Studio
   
   Android Studio is the official IDE for Android app development, based on IntelliJ IDEA.
   
   Android Studio uses Gradle to automate and manage the build process while letting you define flexible, custom build configurations.
   
   image::android_studio.png[]
   
   You can find documentation link:https://developer.android.com/build[here].
   
   == Visual Studio Code
   
   VS Code supports Gradle Java projects (not including Android) via the link:https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-gradle[Gradle for Java extension].
   
   image::visual_studio_code.png[]
   
   The extension provides a visual interface for your Gradle build.
   You can use this interface to view Gradle Tasks and Project dependencies, or run Gradle Tasks as VS Code Tasks. The extension also offers a better Gradle build file authoring experience including syntax highlighting, error reporting, and auto-completion.
   
   You can find documentation link:https://code.visualstudio.com/docs/java/java-build[here].
   
   == Eclipse
   
   The Eclipse IDE caters to the Java developer, and features Java tooling, a Git client, XML Editor, and Gradle integration.
   
   image::eclipse.png[]
   
   link:https://marketplace.eclipse.org/content/buildship-gradle-integration[Buildship] is a set of Eclipse Plug-ins that provide a deep integration of Gradle into the Eclipse IDE.
   
   You can find documentation link:https://projects.eclipse.org/projects/tools.buildship[here].
   
   == NetBeans
   
   The Apache Software Foundation maintains NetBeans, an open-source IDE for Java, PHP, Javascript and other languages.
   
   image::netbeans.png[]
   
   You can find documentation link:https://cwiki.apache.org/confluence/display/BEAM/Gradle+Tips[here].

/Topic: 游댯 Authoring Gradle Builds
====================================


/docs/userguide/authoring-builds/getting_started_dev.adoc
=========================================================

.. code-block::

   = Getting Started
   
   Build engineers that are ready to configure custom build logic and write their own plugins should start here.
   
   To get started engineering Gradle builds:
   
   1. Read the <<gradle_author_intro,build basics chapters>>.
   2. Follow the <<author_tutorial,tutorial>> for a hands-on approach.
   
   == 1. Authoring Gradle Builds Basics
   
   The basics section goes through some Gradle authoring basics so that you can quickly understand how to configure builds, create tasks, and write plugins.
   
   [sidebar]
   _Training level_: **Intermediate** +
   _Reading time_: **35 minutes**
   
   The introduction covers:
   
   <<gradle_directories.adoc#gradle_directories,Part 1.>> Gradle Directories +
   <<intro_multi_project_builds.adoc#intro_multi_project_builds,Part 2.>> Multi-Project Builds +
   <<build_lifecycle.adoc#build_lifecycle,Part 3.>> Gradle Build Lifecycle +
   <<writing_settings_files.adoc#writing_settings_files,Part 4.>> Writing Settings Files +
   <<writing_build_scripts.adoc#writing_build_scripts,Part 5.>> Writing Build Scripts +
   <<tutorial_using_tasks.adoc#tutorial_using_tasks,Part 6.>> Using Tasks +
   <<writing_tasks.adoc#writing_tasks,Part 7.>> Writing Tasks +
   <<plugins.adoc#using_plugins,Part 8.>> Using Plugins +
   <<writing_plugins.adoc#writing_plugins,Part 9.>> Writing Plugins +
   
   == 2. Authoring Gradle Builds Tutorial
   
   The tutorial will take you from Gradle initialization all the way through authoring a simple script plugin.
   No previous experience is necessary but a basic knowledge of Java and Kotlin is nice to have.
   
   If you need to install Gradle before the tutorial, you can see how to do so in the <<installation.adoc#installation,installation section>>.
   
   [sidebar]
   _Training level_: **Intermediate** +
   _Training time_: **65 minutes**
   
   The tutorial covers:
   
   <<partr1_gradle_init#part1_begin,Part 1.>> Initializing the Project +
   <<partr2_build_lifecycle#part2_begin,Part 2.>> Understanding the Build Lifecycle +
   <<partr3_multi_project_builds#part3_begin,Part 3.>> Multi-Project Builds +
   <<partr4_settings_file#part4_begin,Part 6.>> Writing the Settings File +
   <<partr5_build_scripts#part5_begin,Part 5.>> Writing Build Script +
   <<partr6_writing_tasks#part6_begin,Part 6.>> Writing Tasks +
   <<partr7_writing_plugins#part7_begin,Part 7.>> Writing Plugins +

/docs/userguide/authoring-builds/plugins/designing_gradle_plugins.adoc
======================================================================

.. code-block::

   = Designing Plugins
   
   This page has been removed.

/docs/userguide/authoring-builds/structuring/fine_tuning_project_layout.adoc
============================================================================

.. code-block::

   = Fine-Tuning the Project Layout
   
   This page has been moved to <<multi_project_builds.adoc#multi_project_builds,Multi-Project Builds>>.

/docs/userguide/authoring-builds/structuring/structuring_software_products.adoc
===============================================================================

.. code-block::

   = Structuring Large Projects
   
   This page has been removed. See <<multi_project_builds.adoc#multi_project_builds,Multi-Project Builds>>.

/docs/userguide/authoring-builds/structuring/structuring_software_products_details.adoc
=======================================================================================

.. code-block::

   = Multi-project Build Considerations and Optimizations
   
   This page has been removed. See <<multi_project_builds.adoc#multi_project_builds,Multi-Project Builds>>.

/docs/userguide/authoring-builds/tasks/task_configuration_avoidance.adoc
========================================================================

.. code-block::

   = Avoiding Unnecessary Task Configuration
   
   As of Gradle 5.1, we recommend that the configuration avoidance APIs be used whenever tasks are created.
   
   image::writing-tasks-4.png[]
   
   == Task configuration avoidance API
   The configuration avoidance API avoids configuring tasks if they will not be used for a build, which can significantly impact total configuration time.
   
   For example, when running a `compile` task (with the `java` plugin applied), other unrelated tasks (such as `clean`, `test`, `javadocs`), will not be executed.
   
   To avoid creating and configuring a task not needed for a build, we can *register* that task instead.
   
   When a task is registered, it is known to the build.
   It can be configured, and references to it can be passed around, but the task object itself has not been created, and its actions have not been executed.
   The registered task will remain in this state until something in the build needs the instantiated task object.
   If the task object is never needed, the task will remain registered, and the cost of creating and configuring the task will be avoided.
   
   In Gradle, you register a task using link:{javadocPath}#[TaskContainer.register(java.lang.String)].
   Instead of returning a task instance, the `register(...)` method returns a link:{javadocPath}#[TaskProvider], which is a reference to the task that can be used in many places where a normal task object might be used (i.e., when creating task dependencies).
   
   == Guidelines
   
   === Defer task creation
   
   Effective task configuration avoidance requires build authors to change instances of link:{javadocPath}#[TaskContainer.create(java.lang.String)] to link:{javadocPath}#[TaskContainer.register(java.lang.String)].
   
   Older versions of Gradle only support the `create(...)` API.
   The `create(...)` API eagerly creates and configures tasks when called and should be avoided.
   
   NOTE: Using `register(...)` alone may not be enough to avoid all task configuration completely.
   You may need to change other code that configures tasks by name or by type, see below.
   
   === Defer task configuration
   
   Eager APIs like link:{javadocPath}#[DomainObjectCollection.all(org.gradle.api.Action)] and link:{javadocPath}#[DomainObjectCollection.withType(java.lang.Class, org.gradle.api.Action)] will immediately create and configure any registered task.
   To defer task configuration, you must migrate to a configuration avoidance API equivalent.
   See the <<#sec:old_vs_new_configuration_api_overview,table below>> to identify the best alternative.
   
   === Reference a registered task
   
   Instead of referencing a task object, you can work with a registered task via a link:{javadocPath}#[TaskProvider] object.
   A link:{javadocPath}#[TaskProvider] can be obtained in several ways including the link:{javadocPath}#[TaskContainer.register(java.lang.String)] and the link:{javadocPath}#[TaskCollection.named(java.lang.String)] method.
   
   Calling link:{javadocPath}#[Provider.get()] or looking up a task by name with link:{javadocPath}#[TaskCollection.getByName(java.lang.String)] will cause the task to be created and configured.
   
   Methods like link:{groovyDslPath}#[]++)[Task.dependsOn(java.lang.Object...)] and link:{javadocPath}#[ConfigurableFileCollection.builtBy(java.lang.Object++...++)] work with link:{javadocPath}#[TaskProvider] the same way as link:{groovyDslPath}#[Task] so you do not need to unwrap a `Provider` for explicit dependencies to continue to work.
   
   You must use the configuration avoidance equivalent to configure a task by name.
   See the <<#sec:old_vs_new_configuration_api_overview,table below>> to identify the best alternative.
   
   === Reference a task instance
   
   In the event you need to get access to a Task instance, you can use link:{javadocPath}#[TaskCollection.named(java.lang.String)] and link:{javadocPath}#[Provider.get()].
   This will cause the task to be created and configured, but everything should work as it had with the eager APIs.
   
   === Task ordering with configuration avoidance
   
   Calling ordering methods will not cause task creation by itself.
   All these methods do is declare relationships.
   
   NOTE: The existence of these relationships might indirectly cause task creation in later stages of the build process.
   
   When task relationships need to be established (i.e., `dependsOn`, `finalizedBy`, `mustRunAfter`, `shouldRunAfter`), a distinction can be made between soft and strong relationships.
   Their effects on task creation during the configuration phase differ:
   
   - link:{groovyDslPath}#[]++)[Task.mustRunAfter(...)] and link:{groovyDslPath}#[]++)[Task.shouldRunAfter(...)] represent soft relationships, which can only change the order of existing tasks, but can't trigger their creation.
   
   - link:{groovyDslPath}#[]++)[Task.dependsOn(...)] and link:{groovyDslPath}#[]++)[Task.finalizedBy(...)] represent strong relationships, which _force_ the execution of referenced tasks, even if they hadn't been created otherwise.
   
   - If a task is _not_ executed, regardless if it was created with link:{groovyDslPath}#[Task.register(...)] or link:{groovyDslPath}#[Task.create(...)], the defined relationships will not trigger task creation at configuration time.
   
   - If a task _is_ executed, all strongly associated tasks must be created and configured at configuration time, as they might have other `dependsOn` or `finalizedBy` relationships.
   This will happen transitively until the task graph contains all strong relationships.
   
   == Migration guide
   
   The following sections will go through some <<#sec:task_configuration_avoidance_general, general guidelines>> to adhere to when migrating your build logic.
   We've also provided some recommended <<#sec:task_configuration_avoidance_migration_steps, steps>> to follow along with <<#sec:task_configuration_avoidance_troubleshooting, troubleshooting>> and <<#sec:task_configuration_avoidance_pitfalls, common pitfalls>>.
   
   === Migration guidelines
   1. [[task_configuration_avoidance_guideline_use_help_task]] **Use `help` task as a benchmark during the migration.** +
   The `help` task is the perfect candidate to benchmark your migration process.
   In a build that uses only the configuration avoidance API, a link:https://scans.gradle.com/s/o7qmlmmrsfxz4/performance/configuration?openScriptsAndPlugins=WzFd[build scan] shows no tasks created during configuration, and only the tasks executed are created.
   
   2. [[task_configuration_avoidance_guideline_only_mutate_task_object]] **Only mutate the current task inside a configuration action.** +
   Because the task configuration action can now run immediately, later, or never, mutating anything other than the current task can cause indeterminate behavior in your build.
   Consider the following code:
   +
   ====
   [.multi-language-sample]
   =====
   [source,kotlin]
   ----
   val check by tasks.registering
   tasks.register("verificationTask") {
       // Configure verificationTask
   
       // Run verificationTask when someone runs check
       check.get().dependsOn(this)
   }
   ----
   =====
   [.multi-language-sample]
   =====
   [source,groovy]
   ----
   def check = tasks.register("check")
   tasks.register("verificationTask") { verificationTask ->
       // Configure verificationTask
   
       // Run verificationTask when someone runs check
       check.get().dependsOn verificationTask
   }
   ----
   =====
   ====
   Executing the `gradle check` task should execute `verificationTask`, but with this example, it won't.
   This is because the dependency between `verificationTask` and `check` only happens when `verificationTask` is realized.
   To avoid issues like this, you must only modify the task associated with the configuration action.
   Other tasks should be modified in their own configuration action:
   +
   ====
   [.multi-language-sample]
   =====
   [source,kotlin]
   ----
   val check by tasks.registering
   val verificationTask by tasks.registering {
       // Configure verificationTask
   }
   check {
       dependsOn(verificationTask)
   }
   ----
   =====
   [.multi-language-sample]
   =====
   [source,groovy]
   ----
   def check = tasks.register("check")
   def verificationTask = tasks.register("verificationTask") {
       // Configure verificationTask
   }
   check.configure {
       dependsOn verificationTask
   }
   ----
   =====
   ====
   In the future, Gradle will consider this sort of antipattern an error and produce an exception.
   
   3. [[task_configuration_avoidance_guideline_prefer_small_incremental_change]] **Prefer small incremental changes.** +
   Smaller changes are easier to sanity check.
   If you ever break your build logic, analyzing the changelog since the last successful verification will be easier.
   
   4. [[task_configuration_avoidance_guideline_validate_build_logic]] **Ensure a good plan is established for validating the build logic.** +
   Usually, a simple `build` task invocation should do the trick to validate your build logic.
   However, some builds may need additional verification  understand the behavior of your build and make sure you have a good verification plan.
   
   5. [[task_configuration_avoidance_guideline_prefer_automatic_testing]] **Prefer automatic testing to manual testing.** +
   Writing integration test for your build logic using TestKit is good practice.
   
   6. [[task_configuration_avoidance_guideline_avoid_task_by_name]] **Avoid referencing a task by name.** +
   Usually, referencing a task by name is a fragile pattern and should be avoided.
   Although the task name is available on the `TaskProvider`, an effort should be made to use references from a strongly typed model instead.
   
   7. **Use the new task API as much as possible.** +
   Eagerly realizing some tasks may cause a cascade of other tasks to be realized.
   Using `TaskProvider` helps create an indirection that protects against transitive realization.
   
   8. **Some APIs may be disallowed if you try to access them from the new API's configuration blocks.**  +
   For example, link:{groovyDslPath}#[`Project.afterEvaluate()`] cannot be called when configuring a task registered with the new API.
   Since `afterEvaluate` is used to delay configuring a `Project`, mixing delayed configuration with the new API can cause errors that are hard to diagnose because tasks registered with the new API are not always configured, but an `afterEvaluate` block may always be expected to execute.
   
   === Migration steps
   The first part of the migration process is to go through the code and manually migrate eager task creation and configuration to use configuration avoidance APIs.
   
   1. **Migrate task configuration that affects all tasks (`tasks.all {}`) or subsets by type (`tasks.withType(...) {}`).** +
   This will cause your build to eagerly create fewer tasks that are registered by plugins.
   
   2. **Migrate tasks configured by name.** +
   This will cause your build to eagerly create fewer tasks that are registered by plugins.
   For example, logic that uses `TaskContainer#getByName(String, Closure)` should be converted to `TaskContainer#named(String, Action)`.
   This also includes <<#task_configuration_avoidance_pitfalls_hidden_eager_task_realization, task configuration via DSL blocks>>.
   
   3. **Migrate tasks creation to `register(...)`.** +
   At this point, you should change any task creation (using `create(...)` or similar) to use register instead.
   
   After making these changes, you should see an improvement in the number of tasks eagerly created at configuration time.
   
   === Migration troubleshooting
   * **What tasks are being realized?** Use a link:https://scans.gradle.com/[Build Scan] to troubleshoot by following these steps:
   
   a. Execute the Gradle command using the `--scan` flag.
   
   b. Navigate to the configuration performance tab:
   +
   image::taskConfigurationAvoidance-navigate-to-performance.png[]
   
   c. All the information required will be presented:
   +
   image::taskConfigurationAvoidance-performance-annotated.png[]
   +
   1. Total tasks present when each task is created or not.
   - `Created immediately` represents tasks created using the eager task APIs.
   - `Created during configuration` represents tasks created using the configuration avoidance APIs, but were realized explicitly (via `TaskProvider#get()`) or implicitly using the eager task query APIs.
   - Both `Created immediately` and `Created during configuration` numbers are considered "bad" numbers that should be minimized as much as possible.
   - `Created during task execution` represents the tasks created _after_ the task graph has been created.
   Any tasks created at this point won't be executed as part of the graph.
   Ideally, this number should be zero.
   - `Created during task graph calculation` represents the tasks created when building the execution task graph.
   Ideally, this number would be equal to the number of tasks executed.
   - `Not created` represents the tasks avoided in this build session.
   Ideally, this number is as large as possible.
   +
   2. The next section helps answer the question of where a task was realized.
   For each script, plugin, or lifecycle callback, the last column represents the tasks created immediately or during configuration.
   Ideally, this column should be empty.
   +
   3. Focusing on a script, plugin, or lifecycle callback will show a breakdown of the tasks that were created.
   
   === Migration pitfalls
   * [[task_configuration_avoidance_pitfalls_hidden_eager_task_realization]] **Beware of the hidden eager task realization.**
   There are many ways that a task can be configured eagerly. +
   For example, configuring a task using the task name and a DSL block will cause the task to be created (when using the Groovy DSL) immediately:
   +
   [source,groovy]
   ----
   // Given a task lazily created with
   tasks.register("someTask")
   
   // Some time later, the task is configured using a DSL block
   someTask {
       // This causes the task to be created and this configuration to be executed immediately
   }
   ----
   +
   Instead use the `named()` method to acquire a reference to the task and configure it:
   +
   [source,groovy]
   ----
   tasks.named("someTask") {
       // ...
       // Beware of the pitfalls here
   }
   ----
   +
   Similarly, Gradle has syntactic sugar that allows tasks to be referenced by name without an explicit query method. This can also cause the task to be immediately created:
   +
   [source,groovy]
   ----
   tasks.register("someTask")
   
   // Sometime later, an eager task is configured like
   task anEagerTask {
       // The following will cause "someTask" to be looked up and immediately created
       dependsOn someTask
   }
   ----
   +
   There are several ways this premature creation can be avoided:
   
   - **Use a `TaskProvider` variable.**
   Useful when the task is referenced multiple times in the same build script.
   +
   ====
   [.multi-language-sample]
   =====
   [source,kotlin]
   ----
   val someTask by tasks.registering
   
   task("anEagerTask") {
       dependsOn(someTask)
   }
   ----
   =====
   [.multi-language-sample]
   =====
   [source,groovy]
   ----
   def someTask = tasks.register("someTask")
   
   task anEagerTask {
       dependsOn someTask
   }
   ----
   =====
   ====
   
   - **Migrate the consumer task to the new API.**
   +
   [source,groovy]
   ----
   tasks.register("someTask")
   
   tasks.register("anEagerTask") {
       dependsOn someTask
   }
   ----
   
   - **Lookup the task lazily.**
   Useful when the tasks are not created by the same plugin.
   +
   ====
   [.multi-language-sample]
   =====
   [source,kotlin]
   ----
   tasks.register("someTask")
   
   task("anEagerTask") {
       dependsOn(tasks.named("someTask"))
   }
   ----
   =====
   [.multi-language-sample]
   =====
   [source,groovy]
   ----
   tasks.register("someTask")
   
   task anEagerTask {
       dependsOn tasks.named("someTask")
   }
   ----
   =====
   ====
   
   
   == Recommended APIs
   
   [cols="a,a", options="header"]
   |===
   | API
   | Note
   
   | link:{javadocPath}#[TaskContainer.register()]
   | Returns a `TaskProvider` instead of a `Task`.
   
   | link:{javadocPath}#[TaskCollection.named()]
   | Returns a `TaskProvider` instead of a `Task`.
   
   | link:{javadocPath}#[TaskCollection.withType()]
   | OK to use.
   
   | link:{javadocPath}#[DomainObjectCollection.configureEach()]
   | Returns `void`, so it cannot be chained.
   
   |===
   
   == APIs to avoid
   
   [cols="a,a", options="header"]
   |===
   | API
   | Note
   
   | `task myTask(type: MyTask) {}`
   | Do not use the shorthand notation.
   
   | link:{javadocPath}#[TaskContainer.create()]
   | Use `register()` instead.
   
   | link:{javadocPath}#[TaskContainer.getByPath()]
   | Do not use.
   
   | link:{javadocPath}#[NamedDomainObjectCollection.findByName()]
   | Do not use. `named()` is the closest equivalent, but will fail if the task does not exist.
   
   | link:{javadocPath}#[TaskContainer.findByPath()]
   | Do not use.
   
   | link:{javadocPath}#[TaskCollection.getByName()]
   | Use `named()` instead.
   
   | link:{javadocPath}#[DomainObjectCollection.all(org.gradle.api.Action)]
   | Use `configureEach()` instead.
   
   | link:{javadocPath}#[TaskCollection.whenTaskAdded(org.gradle.api.Action)]
   | Use `configureEach()` instead.
   
   | link:{javadocPath}#[DomainObjectCollection.whenObjectAdded(org.gradle.api.Action)]
   | Use `configureEach()` instead.
   
   | link:{javadocPath}#[NamedDomainObjectSet.findAll()]
   | Avoid calling this method. `matching()` and `configureEach()` are more appropriate in most cases.
   
   | link:{javadocPath}#[TaskCollection.matching()]
   | If you are matching based on the name, use `named()` instead which will be lazy.
   `matching()` requires all tasks to be created, so try to limit the impact by restricting the type of task, like `withType().matching()`.
   
   | link:{javadocPath}#[TaskCollection.getAt()]
   | Use `named()` instead.
   
   | `iterator()` or implicit iteration over the `Task` collection
   | Avoid doing this as it requires creating and configuring all tasks.
   
   | `remove()`
   | Avoid calling this. The behavior may change in the future.
   
   | link:{javadocPath}#[TaskContainer.replace()]
   | Avoid calling this. The behavior may change in the future.
   
   |===

/Section: 游릭 The Basics
=========================


/docs/userguide/authoring-builds/basics/gradle_directories.adoc
===============================================================

.. code-block::

   = Gradle Directories
   
   Gradle uses two main directories to perform and manage its work: the <<#gradle_user_home>> and the <<#project_root>>.
   
   image::author-gradle-2.png[]
   
   == Gradle User Home directory
   
   By default, the Gradle User Home (`~/.gradle` or `C:\Users\<USERNAME>\.gradle`) stores global configuration properties, initialization scripts, caches, and log files.
   
   It can be set with the environment variable `GRADLE_USER_HOME`.
   
   TIP: Not to be confused with the `GRADLE_HOME`, the optional installation directory for Gradle.
   
   It is roughly structured as follows:
   
   [listing]
   ----
   較럭較 caches                  // <1>
   較   較럭較 4.8                     // <2>
   較   較럭較 4.9                     // <2>
   較   較럭較 긽
   較   較럭較 jars-3                  // <3>
   較   較덕較 modules-2               // <3>
   較럭較 daemon // <4>
   較   較럭較 긽
   較   較럭較 4.8
   較   較덕較 4.9
   較럭較 init.d                  // <5>
   較   較덕較 my-setup.gradle
   較럭較 jdks                    // <6>
   較   較럭較 긽
   較   較덕較 jdk-14.0.2+12
   較럭較 wrapper
   較   較덕較 dists                   // <7>
   較       較럭較 긽
   較       較럭較 gradle-4.8-bin
   較       較럭較 gradle-4.9-all
   較       較덕較 gradle-4.9-bin
   較덕較 gradle.properties       // <8>
   ----
   <1> Global cache directory (for everything that is not project-specific).
   <2> Version-specific caches (e.g., to support incremental builds).
   <3> Shared caches (e.g., for artifacts of dependencies).
   <4> Registry and logs of the <<gradle_daemon.adoc#gradle_daemon, Gradle Daemon>>.
   <5> Global <<init_scripts.adoc#init_scripts, initialization scripts>>.
   <6> JDKs downloaded by the <<toolchains.adoc#sec:provisioning, toolchain support>>.
   <7> Distributions downloaded by the <<gradle_wrapper.adoc#gradle_wrapper_reference,Gradle Wrapper>>.
   <8> Global <<build_environment.adoc#sec:gradle_configuration_properties,Gradle configuration properties>>.
   
   Consult the <<directory_layout.adoc#dir:gradle_user_home,Gradle Directories reference>> to learn more.
   
   == Project Root directory
   
   The project root directory contains all source files from your project.
   
   It also contains files and directories Gradle generates, such as `.gradle` and `build`.
   
   While `.gradle` is usually checked into source control, the `build` directory contains the output of your builds as well as transient files Gradle uses to support features like incremental builds.
   
   The anatomy of a typical project root directory looks as follows:
   
   [listing,subs=+macros]
   ----
   較럭較 .gradle                 // <1>
   較   較럭較 4.8                     // <2>
   較   較럭較 4.9                     // <2>
   較   較덕較 긽
   較럭較 build                   // <3>
   較럭較 gradle
   較   較덕較 wrapper                 // <4>
   較럭較 gradle.properties       // <5>
   較럭較 gradlew                 // <6>
   較럭較 gradlew.bat             // <6>
   較럭較 settings.gradle.kts     // <7>
   較럭較 subproject-one          // <8>
   |   較덕較 build.gradle.kts        // <9>
   較럭較 subproject-two          // <8>
   |   較덕較 build.gradle.kts        // <9>
   較덕較 긽
   ----
   <1> Project-specific cache directory generated by Gradle.
   <2> Version-specific caches (e.g., to support incremental builds).
   <3> The build directory of this project into which Gradle generates all build artifacts.
   <4> Contains the JAR file and configuration of the <<gradle_wrapper.adoc#gradle_wrapper_reference,Gradle Wrapper>>.
   <5> Project-specific <<build_environment.adoc#sec:gradle_configuration_properties,Gradle configuration properties>>.
   <6> Scripts for executing builds using the <<gradle_wrapper.adoc#gradle_wrapper_reference,Gradle Wrapper>>.
   <7> The project's <<organizing_gradle_projects.adoc#sec:settings_file, settings file>> where the list of subprojects is defined.
   <8> Usually, a project is organized into one or multiple subprojects.
   <9> Each subproject has its own Gradle build script.
   
   Consult the <<directory_layout.adoc#dir:project_root,Gradle Directories reference>> to learn more.
   
   [.text-right]
   **Next Step:** <<intro_multi_project_builds.adoc#intro_multi_project_builds,Learn how to structure Multi-Project Builds>> >>

/docs/userguide/authoring-builds/basics/intro_multi_project_builds.adoc
=======================================================================

.. code-block::

   = Multi-Project Build Basics
   
   Gradle supports multi-project builds.
   
   image::gradle-basic-9.png[]
   
   While some small projects and monolithic applications may contain a single build file and source tree, it is often more common for a project to have been split into smaller, interdependent modules.
   The word "interdependent" is vital, as you typically want to link the many modules together through a single build.
   
   Gradle supports this scenario through _multi-project_ builds.
   This is sometimes referred to as a multi-module project.
   Gradle refers to modules as subprojects.
   
   A multi-project build consists of one root project and one or more subprojects.
   
   == Multi-Project structure
   
   The following represents the structure of a multi-project build that contains two subprojects:
   
   image::multi-project-structure.png[]
   
   The directory structure should look as follows:
   
   ----
   較럭較 .gradle
   較   較덕較 긽
   較럭較 gradle
   較   較럭較 libs.version.toml
   較   較덕較 wrapper
   較럭較 gradlew
   較럭較 gradlew.bat
   較럭較 settings.gradle.kts  // <1>
   較럭較 sub-project-1
   較   較덕較 build.gradle.kts // <2>
   較럭較 sub-project-2
   較   較덕較 build.gradle.kts // <2>
   較덕較 sub-project-3
       較덕較 build.gradle.kts // <2>
   ----
   <1> The `settings.gradle.kts` file should include all subprojects.
   <2> Each subproject should have its own `build.gradle.kts` file.
   
   == Multi-Project standards
   
   The Gradle community has two standards for multi-project build structures:
   
   1. **<<sharing_build_logic_between_subprojects.adoc#sec:using_buildsrc,Multi-Project Builds using buildSrc>>** - where `buildSrc` is a subproject-like directory at the Gradle project root containing all the build logic.
   2. **<<composite_builds.adoc#composite_builds,Composite Builds>>** - a build that includes other builds where `build-logic` is a build directory at the Gradle project root containing reusable build logic.
   
   image::multi-project-standards.png[]
   
   === 1. Multi-Project Builds using `buildSrc`
   
   Multi-project builds allow you to organize projects with many modules, wire dependencies between those modules, and easily share common build logic amongst them.
   
   For example, a build that has many modules called `mobile-app`, `web-app`, `api`, `lib`, and `documentation` could be structured as follows:
   
   [source,text]
   ----
   .
   較럭較 gradle
   較럭較 gradlew
   較럭較 settings.gradle.kts
   較럭較 buildSrc
   較   較럭較 build.gradle.kts
   較   較덕較 src/main/kotlin/shared-build-conventions.gradle.kts
   較럭較 mobile-app
   較   較덕較 build.gradle.kts
   較럭較 web-app
   較   較덕較 build.gradle.kts
   較럭較 api
   較   較덕較 build.gradle.kts
   較럭較 lib
   較   較덕較 build.gradle.kts
   較덕較 documentation
       較덕較 build.gradle.kts
   ----
   
   The modules will have dependencies between them such as `web-app` and `mobile-app` depending on `lib`.
   This means that in order for Gradle to build `web-app` or `mobile-app`, it must build `lib` first.
   
   In this example, the root settings file will look as follows:
   
   .settings.gradle.kts
   [source,kotlin]
   ----
   include("mobile-app", "web-app", "api", "lib", "documentation")
   ----
   
   NOTE: The order in which the subprojects (modules) are included does not matter.
   
   The `buildSrc` directory is automatically recognized by Gradle.
   It is a good place to define and maintain shared configuration or imperative build logic, such as custom tasks or plugins.
   
   `buildSrc` is automatically included in your build as a special subproject if a `build.gradle(.kts)` file is found under `buildSrc`.
   
   If the `java` plugin is applied to the `buildSrc` project, the compiled code from `buildSrc/src/main/java` is put in the classpath of the root build script, making it available to any subproject (`web-app`, `mobile-app`, `lib`, etc...) in the build.
   
   Consult how to declare <<sharing_build_logic_between_subprojects.adoc#sec:using_buildsrc, dependencies between subprojects>> to learn more.
   
   === 2. Composite Builds
   
   Composite Builds, also referred to as _included builds_, are best for sharing logic between builds (_not subprojects_) or isolating access to shared build logic (i.e., convention plugins).
   
   Let's take the previous example.
   The logic in `buildSrc` has been turned into a project that contains plugins and can be published and worked on independently of the root project build.
   
   The plugin is moved to its own build called `build-logic` with a build script and settings file:
   
   [source]
   ----
   .
   較럭較 gradle
   較럭較 gradlew
   較럭較 settings.gradle.kts
   較럭較 build-logic
   較   較럭較 settings.gradle.kts
   較   較덕較 conventions
   較       較럭較 build.gradle.kts
   較       較덕較 src/main/kotlin/shared-build-conventions.gradle.kts
   較럭較 mobile-app
   較   較덕較 build.gradle.kts
   較럭較 web-app
   較   較덕較 build.gradle.kts
   較럭較 api
   較   較덕較 build.gradle.kts
   較럭較 lib
   較   較덕較 build.gradle.kts
   較덕較 documentation
       較덕較 build.gradle.kts
   ----
   
   NOTE: The fact that `build-logic` is located in a subdirectory of the root project is irrelevant. The folder could be located outside the root project if desired.
   
   The root settings file includes the entire `build-logic` *build*:
   
   .settings.gradle.kts
   [source]
   ----
   pluginManagement {
       includeBuild("build-logic")
   }
   include("mobile-app", "web-app", "api", "lib", "documentation")
   ----
   
   Consult how to <<composite_builds#defining_composite_builds,create composite builds>> with `includeBuild` to learn more.
   
   == Multi-Project path
   
   A project path has the following pattern: it starts with an optional colon, which denotes the root project.
   
   The root project, `:`, is the only project in a path not specified by its name.
   
   The rest of a project path is a colon-separated sequence of project names, where the next project is a subproject of the previous project:
   
   [source]
   ----
   :sub-project-1
   ----
   
   You can see the project paths when running `gradle projects`:
   
   [source]
   ----
   ------------------------------------------------------------
   Root project 'project'
   ------------------------------------------------------------
   
   Root project 'project'
   +--- Project ':sub-project-1'
   \--- Project ':sub-project-2'
   ----
   
   Project paths usually reflect the filesystem layout, but there are exceptions.
   Most notably for <<composite_builds#defining_composite_builds,composite builds>>.
   
   == Identifying project structure
   
   You can use the `gradle projects` command to identify the project structure.
   
   As an example, let's use a multi-project build with the following structure:
   ----
   > gradle -q projects
   ----
   ----
   include::{snippetsPath}/java/multiproject/tests/listProjects.out[]
   ----
   
   Multi-project builds are collections of tasks you can run.
   The difference is that you may want to control _which_ project's tasks get executed.
   
   The following sections will cover your two options for executing tasks in a multi-project build.
   
   === Executing tasks by name
   
   The command `gradle test` will execute the `test` task in any subprojects relative to the current working directory that has that task.
   
   If you run the command from the root project directory, you will run `test` in _api_, _shared_, _services:shared_ and _services:webservice_.
   
   If you run the command from the _services_ project directory, you will only execute the task in _services:shared_ and _services:webservice_.
   
   The basic rule behind Gradle's behavior is to *execute all tasks down the hierarchy with _this_ name*.
   And *complain if there is _no_ such task found* in any of the subprojects traversed.
   
   NOTE: Some task selectors, like `help` or `dependencies`, will only run the task on the project they are invoked on and not on all the subprojects to reduce the amount of information printed on the screen.
   
   === Executing tasks by fully qualified name
   
   You can use a task's fully qualified name to execute a specific task in a particular subproject.
   For example: `gradle :services:webservice:build` will run the `build` task of the _webservice_ subproject.
   
   The fully qualified name of a task is its <<sec:project_path,project path>> plus the task name.
   
   This approach works for any task, so if you want to know what tasks are in a particular subproject, use the `tasks` task, e.g. `gradle :services:webservice:tasks`.
   
   == Multi-Project building and testing
   
   The `build` task is typically used to compile, test, and check a single project.
   
   In multi-project builds, you may often want to do all of these tasks across various projects.
   The `buildNeeded` and `buildDependents` tasks can help with this.
   
   In <<declaring_dependencies_between_subprojects#javadependencies_2,this example>>, the `:services:person-service` project depends on both the `:api` and `:shared` projects.
   The `:api` project also depends on the `:shared` project.
   
   Assuming you are working on a single project, the `:api` project, you have been making changes but have not built the entire project since performing a `clean`.
   You want to build any necessary supporting JARs but only perform code quality and unit tests on the parts of the project you have changed.
   
   The `build` task does this:
   
   ====
   [.multi-language-sample]
   =====
   ----
   $ gradle :api:build
   
   include::{snippetsPath}/multiproject/dependencies-java/tests/multitestingBuild.out[]
   ----
   =====
   ====
   
   If you have just gotten the latest version of the source from your version control system, which included changes in other projects that `:api` depends on, you might want to build all the projects you depend on AND test them too.
   
   The `buildNeeded` task builds AND tests all the projects from the project dependencies of the `testRuntime` configuration:
   
   ====
   [.multi-language-sample]
   =====
   ----
   $ gradle :api:buildNeeded
   
   include::{snippetsPath}/multiproject/dependencies-java/tests/multitestingBuildNeeded.out[]
   ----
   =====
   ====
   
   You may want to refactor some part of the `:api` project used in other projects.
   If you make these changes, testing only the `:api` project is insufficient.
   You must test all projects that depend on the `:api` project.
   
   The `buildDependents` task tests ALL the projects that have a project dependency (in the testRuntime configuration) on the specified project:
   
   ====
   [.multi-language-sample]
   =====
   ----
   $ gradle :api:buildDependents
   
   include::{snippetsPath}/multiproject/dependencies-java/tests/multitestingBuildDependents.out[]
   ----
   =====
   ====
   
   Finally, you can build and test everything in all projects.
   Any task you run in the root project folder will cause that same-named task to be run on all the children.
   
   You can run `gradle build` to build and test ALL projects.
   
   Consult the <<multi_project_builds.adoc#multi_project_builds,Structuring Builds chapter>> to learn more.
   
   [.text-right]
   **Next Step:** <<build_lifecycle.adoc#build_lifecycle,Learn about the Gradle Build Lifecycle>> >>

/docs/userguide/authoring-builds/basics/build_lifecycle.adoc
============================================================

.. code-block::

   = Build Lifecycle
   
   As a build author, you define tasks and dependencies between tasks.
   Gradle guarantees that these tasks will execute in order of their dependencies.
   
   Your build scripts and plugins configure this dependency graph.
   
   For example, if your project tasks include `build`, `assemble`, `createDocs`, your build script(s) can ensure that they are executed in the order `build` -> `assemble` -> `createDoc`.
   
   == Task Graphs
   
   Gradle builds the task graph *before* executing any task.
   
   Across all projects in the build, tasks form a http://en.wikipedia.org/wiki/Directed_acyclic_graph[Directed Acyclic Graph^] (DAG).
   
   This diagram shows two example task graphs, one abstract and the other concrete, with dependencies between tasks represented as arrows:
   
   image::task-dag-examples.png[]
   
   Both plugins and build scripts contribute to the task graph via the <<tutorial_using_tasks.adoc#sec:task_dependencies,task dependency mechanism>> and <<incremental_build.adoc#sec:task_inputs_outputs,annotated inputs/outputs>>.
   
   == Build Phases
   
   A Gradle build has three distinct phases.
   
   image::author-gradle-1.png[]
   
   Gradle runs these phases in order:
   
   Phase 1. Initialization::
   - Detects the `settings.gradle(.kts)` file.
   - Creates a link:{groovyDslPath}#[`Settings`] instance.
   - Evaluates the settings file to determine which projects (and included builds) make up the build.
   - Creates a link:{groovyDslPath}#[`Project`] instance for every project.
   Phase 2. Configuration::
   - Evaluates the build scripts, `build.gradle(.kts)`, of every project participating in the build.
   - Creates a task graph for requested tasks.
   Phase 3. Execution::
   - Schedules and executes the selected tasks.
   - Dependencies between tasks determine execution order.
   - Execution of tasks can occur in parallel.
   
   image::build-lifecycle-example.png[]
   
   === Example
   
   The following example shows which parts of settings and build files correspond to various build phases:
   
   ====
   include::sample[dir="snippets/buildlifecycle/basic/kotlin",files="settings.gradle.kts[];build.gradle.kts[]"]
   include::sample[dir="snippets/buildlifecycle/basic/groovy",files="settings.gradle[];build.gradle[]"]
   ====
   
   The following command executes the `test` and `testBoth` tasks specified above.
   Because Gradle only configures requested tasks and their dependencies, the `configured` task never configures:
   
   [source.multi-language-sample,kotlin]
   ----
   > gradle test testBoth
   include::{snippetsPath}/buildlifecycle/basic/tests/buildlifecycle.out[]
   ----
   [source.multi-language-sample,groovy]
   ----
   > gradle test testBoth
   include::{snippetsPath}/buildlifecycle/basic/tests/buildlifecycle.out[]
   ----
   
   == Phase 1. Initialization
   
   In the *initialization phase*, Gradle detects the set of projects (root and subprojects) and included builds participating in the build.
   
   Gradle first evaluates the settings file, `settings.gradle(.kts)`, and instantiates a `Settings` object.
   Then, Gradle instantiates `Project` instances for each project.
   
   == Phase 2. Configuration
   
   In the *configuration phase*, Gradle adds tasks and other properties to the projects found by the initialization phase.
   
   == Phase 3. Execution
   
   In the *execution phase*, Gradle runs tasks.
   
   Gradle uses the task execution graphs generated by the configuration phase to determine which tasks to execute.
   
   
   [.text-right]
   **Next Step:** <<writing_settings_files.adoc#writing_settings_files,Learn how to write Settings files>> >>

/docs/userguide/authoring-builds/basics/writing_settings_files.adoc
===================================================================

.. code-block::

   = Writing Settings Files
   
   The settings file is the entry point of every Gradle build.
   
   image::author-gradle-7.png[]
   
   Early in the Gradle Build lifecycle, the <<build_lifecycle.adoc#sec:initialization,initialization phase>> finds the settings file in your <<directory_layout#dir:project_root,project root directory>>.
   
   When the settings file `settings.gradle(.kts)` is found, Gradle instantiates a link:{groovyDslPath}#[`Settings`] object.
   
   One of the purposes of the `Settings` object is to allow you to declare all the projects to be included in the build.
   
   == Settings Scripts
   
   The settings script is either a `settings.gradle` file in Groovy or a `settings.gradle.kts` file in Kotlin.
   
   Before Gradle assembles the projects for a build, it creates a `Settings` instance and executes the settings file against it.
   
   image::author-gradle-3.png[Settings,500,63,align="left"]
   
   As the settings script executes, it configures this `Settings`.
   Therefore, the _settings file_ defines the `Settings` object.
   
   IMPORTANT: There is a one-to-one correspondence between a `Settings` instance and a `settings.gradle(.kts)` file.
   
   == The `Settings` Object
   
   The `Settings` object is part of the link:{javadocPath}#[Gradle API].
   
   - In the Groovy DSL, the `Settings` object documentation is found link:{groovyDslPath}#[here].
   - In the Kotlin DSL, the `Settings` object documentation is found link:{kotlinDslPath}/gradle/org.gradle.api.initialization/-settings/index.html[here].
   
   Many top-level properties and blocks in a settings script are part of the Settings API.
   
   For example, we can set the root project name in the settings script using the `Settings.rootProject` property:
   
   [source,kotlin]
   ----
   settings.rootProject.name = "root"
   ----
   
   Which is usually shortened to:
   
   [source,kotlin]
   ----
   rootProject.name = "root"
   ----
   
   === Standard `Settings` properties
   
   The `Settings` object exposes a standard set of properties in your settings script.
   
   The following table lists a few commonly used properties:
   
   [%autowidth.stretch]
   |===
   | Name | Description
   
   | `buildCache`
   | The build cache configuration.
   
   | `plugins`
   | The container of plugins that have been applied to the settings.
   
   | `rootDir`
   | The root directory of the build. The root directory is the project directory of the root project.
   
   | `rootProject`
   | The root project of the build.
   
   | `settings`
   | Returns this settings object.
   |===
   
   The following table lists a few commonly used methods:
   
   [%autowidth.stretch]
   |===
   | Name | Description
   
   | `include()`
   | Adds the given projects to the build.
   
   | `includeBuild()`
   | Includes a build at the specified path to the composite build.
   |===
   
   == Settings Script structure
   
   A Settings script is a series of method calls to the Gradle API that often use `{ ... }`, a special shortcut in both the Groovy and Kotlin languages.
   A `{ }` block is called a _lambda_ in Kotlin or a _closure_ in Groovy.
   
   Simply put, the `plugins{ }` block is a method invocation in which a Kotlin _lambda_ object or Groovy _closure_ object is passed as the argument.
   It is the short form for:
   
   [source,kotlin]
   ----
   plugins(function() {
       id("plugin")
   })
   ----
   
   Blocks are mapped to Gradle API methods.
   
   The code inside the function is executed against a `this` object called a _receiver_ in Kotlin lambda and a _delegate_ in Groovy closure.
   Gradle determines the correct `this` object and invokes the correct corresponding method.
   The `this` of the method invocation `id("plugin")` object is of type link:{javadocPath}#[`PluginDependenciesSpec`].
   
   The settings file is composed of Gradle API calls built on top of the DSLs.
   Gradle executes the script line by line, top to bottom.
   
   Let's take a look at an example and break it down:
   
   ====
   [.multi-language-sample]
   =====
   .settings.gradle.kts
   [source,kotlin]
   ----
   pluginManagement {                                          // <1>
       repositories {
           gradlePluginPortal()
           google()
       }
   }
   
   plugins {                                                   // <2>
       id("org.gradle.toolchains.fake") version "0.6.0"
   }
   
   rootProject.name = "root-project"                           // <3>
   
   dependencyResolutionManagement {                            // <4>
       repositories {
           mavenCentral()
       }
   }
   
   include("sub-project-a")                                    // <5>
   include("sub-project-b")
   include("sub-project-c")
   ----
   <1> Define the location of plugins
   <2> Apply plugins.
   <3> Define the root project name.
   <4> Define build-wide repositories.
   <5> Add subprojects to the build.
   =====
   
   [.multi-language-sample]
   =====
   .settings.gradle
   [source,groovy]
   ----
   pluginManagement {                                          // <1>
       repositories {
           gradlePluginPortal()
           google()
       }
   }
   
   plugins {                                                   // <2>
       id 'org.gradle.toolchains.fake' version '0.6.0'
   }
   
   rootProject.name = 'root-project'                           // <3>
   
   dependencyResolutionManagement {                            // <4>
       repositories {
           mavenCentral()
       }
   }
   
   include('sub-project-a')                                    // <5>
   include('sub-project-b')
   include('sub-project-c')
   ----
   <1> Define the location of plugins.
   <2> Apply plugins.
   <3> Define the root project name.
   <4> Define build-wide repositories.
   <5> Add subprojects to the build.
   =====
   ====
   
   === 1. Define the location of plugins
   
   The settings file can optionally define the plugins your project uses with link:{javadocPath}#[`pluginManagement`], including binary repositories such as the Gradle Plugin Portal or other Gradle builds using `includeBuild`:
   
   [source]
   ----
   pluginManagement {
       repositories {
           gradlePluginPortal()
           google()
       }
   }
   ----
   
   You can also include plugins and plugin dependency resolution strategies in this block.
   
   === 2. Apply plugins
   
   The settings file can optionally declare the link:{javadocPath}#[plugins] that may be applied later, which can add shared configuration among several builds / subprojects:
   
   Plugins applied to the settings only affect the `Settings` object.
   
   [source]
   ----
   plugins {
       id("org.gradle.toolchains.fake") version "0.6.0"
   }
   ----
   
   This is typically used to ensure that all subprojects use the same plugin version.
   
   === 3. Define the root project name
   
   The settings file defines your project name using the link:{javadocPath}#[`rootProject.name` property]:
   
   [source]
   ----
   rootProject.name = "root-project"
   ----
   
   There is only one root project per build.
   
   === 4. Define build-wide repositories
   
   The settings file can optionally link:{javadocPath}#[define] the locations of components your project relies on (as well as how to resolve them) using `repositories` such as binary repositories like Maven Central and/or other Gradle builds using `includeBuild`:
   
   [source]
   ----
   dependencyResolutionManagement {
       repositories {
           mavenCentral()
       }
   }
   ----
   
   You can also include version catalogs in this section.
   
   === 5. Add subprojects to the build
   
   The settings file defines the structure of the project by adding all the subprojects using the link:{javadocPath}#[`include`] statement:
   
   [source]
   ----
   include("app")
   include("business-logic")
   include("data-model")
   ----
   
   == Settings File Scripting
   
   There are many more properties and methods on the `Settings` object that you can use to configure your build.
   
   It's important to remember that while many Gradle scripts are typically written in short Groovy or Kotlin syntax, every item in the settings script is essentially invoking a method on the `Settings` object in the Gradle API:
   
   [source]
   ----
   include("app")
   ----
   
   Is actually:
   
   [source]
   ----
   settings.include("app")
   ----
   
   Additionally, the full power of the Groovy and Kotlin languages is available to you.
   
   For example, instead of using `include` many times to add subprojects, you can iterate over the list of directories in the project root folder and include them automatically:
   
   [source]
   ----
   rootDir.listFiles().filter { it.isDirectory && (new File(it, "build.gradle.kts").exists()) }.forEach {
       include(it.name)
   }
   ----
   
   TIP: This type of logic should be developed in a plugin.
   
   [.text-right]
   **Next Step:** <<writing_build_scripts.adoc#writing_build_scripts,Learn how to write Build scripts>> >>

/docs/userguide/authoring-builds/basics/writing_build_scripts.adoc
==================================================================

.. code-block::

   = Writing Build Scripts
   
   The initialization phase in the Gradle Build lifecycle finds the root project and subprojects included in your <<directory_layout#dir:project_root,project root directory>> using the settings file.
   
   image::author-gradle-6.png[]
   
   Then, for each project included in the settings file, Gradle creates a link:{javadocPath}#[`Project`] instance.
   
   Gradle then looks for a corresponding build script file, which is used in the configuration phase.
   
   == Build Scripts
   
   Every Gradle build comprises one or more *projects*; a _root_ project and _subprojects_.
   
   A project typically corresponds to a software component that needs to be built, like a library or an application.
   It might represent a library JAR, a web application, or a distribution ZIP assembled from the JARs produced by other projects.
   
   On the other hand, it might represent a thing to be done, such as deploying your application to staging or production environments.
   
   Gradle scripts are written in either Groovy DSL or Kotlin DSL (domain-specific language).
   
   A *build script* configures a *project* and is associated with an object of type link:{javadocPath}#[`Project`].
   
   image::author-gradle-4.png[Build,500,63,align="left"]
   
   As the build script executes, it configures `Project`.
   
   The build script is either a `\*.gradle` file in Groovy or a `*.gradle.kts` file in Kotlin.
   
   IMPORTANT: _Build scripts_ configure `Project` objects and their children.
   
   == The `Project` object
   
   The `Project` object is part of the link:{javadocPath}#[Gradle API].
   
   - In the Groovy DSL, the `Project` object documentation is found link:{groovyDslPath}#[here].
   - In the Kotlin DSL, the `Project` object documentation is found link:{kotlinDslPath}/gradle/org.gradle.api/-project/index.html[here].
   
   Many top-level properties and blocks in a build script are part of the Project API.
   
   For example, the following build script uses the link:{groovyDslPath}#[Project.name] property to print the name of the project:
   
   ====
   include::sample[dir="snippets/tutorial/projectApi/kotlin",files="build.gradle.kts[tags=project-name]"]
   include::sample[dir="snippets/tutorial/projectApi/groovy",files="build.gradle[tags=project-name]"]
   ----
   $ gradle -q check
   include::{snippetsPath}/tutorial/projectApi/tests/projectApi.out[]
   ----
   ====
   
   Both `println` statements print out the same property.
   
   The first uses the top-level reference to the `name` property of the `Project` object.
   The second statement uses the `project` property available to any build script, which returns the associated `Project` object.
   
   === Standard project properties
   
   The `Project` object exposes a standard set of properties in your build script.
   
   The following table lists a few commonly used properties:
   
   [%header%autowidth,compact]
   |===
   | Name | Type | Description
   
   | `name`
   | `String`
   | The name of the project directory.
   
   | `path`
   | `String`
   | The fully qualified name of the project.
   
   | `description`
   | `String`
   | A description for the project.
   
   | `dependencies`
   | `DependencyHandler`
   | Returns the dependency handler of the project.
   
   | `repositories`
   | `RepositoryHandler`
   | Returns the repository handler of the project.
   
   | `layout`
   | `ProjectLayout`
   | Provides access to several important locations for a project.
   
   | `group`
   | `Object`
   | The group of this project.
   
   | `version`
   | `Object`
   | The version of this project.
   |===
   
   The following table lists a few commonly used methods:
   
   [%autowidth.stretch]
   |===
   | Name | Description
   
   | `uri()`
   | Resolves a file path to a URI, relative to the project directory of this project.
   
   | `task()`
   | Creates a Task with the given name and adds it to this project.
   |===
   
   == Build Script structure
   
   The Build script is composed of `{ ... }`, a special object in both Groovy and Kotlin.
   This object is called a _lambda_ in Kotlin or a _closure_ in Groovy.
   
   Simply put, the `plugins{ }` block is a method invocation in which a Kotlin _lambda_ object or Groovy _closure_ object is passed as the argument.
   It is the short form for:
   
   [source]
   ----
   plugins(function() {
       id("plugin")
   })
   ----
   
   Blocks are mapped to Gradle API methods.
   
   The code inside the function is executed against a `this` object called a _receiver_ in Kotlin lambda and a _delegate_ in Groovy closure.
   Gradle determines the correct `this` object and invokes the correct corresponding method.
   The `this` of the method invocation `id("plugin")` object is of type link:{javadocPath}#[`PluginDependenciesSpec`].
   
   The build script is essentially composed of Gradle API calls built on top of the DSLs.
   Gradle executes the script line by line, top to bottom.
   
   Let's take a look at an example and break it down:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {                                                               // <1>
       id("org.jetbrains.kotlin.jvm") version "1.9.0"
       id("application")
   }
   
   repositories {                                                          // <2>
       mavenCentral()
   }
   
   dependencies {                                                          // <3>
       testImplementation("org.jetbrains.kotlin:kotlin-test-junit5")
       testImplementation("org.junit.jupiter:junit-jupiter-engine:5.9.3")
       testRuntimeOnly("org.junit.platform:junit-platform-launcher")
       implementation("com.google.guava:guava:32.1.1-jre")
   }
   
   application {                                                           // <4>
       mainClass = "com.example.Main"
   }
   
   tasks.named<Test>("test") {                                             // <5>
       useJUnitPlatform()
   }
   ----
   <1> Apply plugins to the build.
   <2> Define the locations where dependencies can be found.
   <3> Add dependencies.
   <4> Set properties.
   <5> Register and configure tasks.
   =====
   
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   plugins {                                                               // <1>
       id 'org.jetbrains.kotlin.jvm' version '1.9.0'
       id 'application'
   }
   
   repositories {                                                          // <2>
       mavenCentral()
   }
   
   dependencies {                                                          // <3>
       testImplementation 'org.jetbrains.kotlin:kotlin-test-junit5'
       testImplementation 'org.junit.jupiter:junit-jupiter-engine:5.9.3'
       testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
       implementation 'com.google.guava:guava:32.1.1-jre'
   }
   
   application {                                                           // <4>
       mainClass = 'com.example.Main'
   }
   
   tasks.named('test') {                                                   // <5>
       useJUnitPlatform()
   }
   ----
   <1> Apply plugins to the build.
   <2> Define the locations where dependencies can be found.
   <3> Add dependencies.
   <4> Set properties.
   <5> Register and configure tasks.
   =====
   ====
   
   === 1. Apply plugins to the build
   Plugins are used to extend Gradle. They are also used to modularize and reuse project configurations.
   
   Plugins can be applied using the `PluginDependenciesSpec` plugins script block.
   
   The plugins block is preferred:
   
   [source]
   ----
   plugins {
       id("org.jetbrains.kotlin.jvm") version "1.9.0"
       id("application")
   }
   ----
   
   In the example, the `application` plugin, which is included with Gradle, has been applied, describing our project as a Java application.
   
   The Kotlin gradle plugin, version 1.9.0, has also been applied.
   This plugin is not included with Gradle and, therefore, has to be described using a `plugin id` and a `plugin version` so that Gradle can find and apply it.
   
   === 2. Define the locations where dependencies can be found
   
   A project generally has a number of dependencies it needs to do its work.
   Dependencies include plugins, libraries, or components that Gradle must download for the build to succeed.
   
   The build script lets Gradle know where to look for the binaries of the dependencies.
   More than one location can be provided:
   
   [source]
   ----
   repositories {
       mavenCentral()
       google()
   }
   ----
   
   In the example, the `guava` library and the JetBrains Kotlin plugin (`org.jetbrains.kotlin.jvm`) will be downloaded from the link:https://repo.maven.apache.org/maven2/[Maven Central Repository].
   
   === 3. Add dependencies
   
   A project generally has a number of dependencies it needs to do its work.
   These dependencies are often libraries of precompiled classes that are imported in the project's source code.
   
   Dependencies are managed via <<dependency_management_terminology.adoc#sub:terminology_configuration,configurations>> and are retrieved from repositories.
   
   Use the `DependencyHandler` returned by `Project.getDependencies()` method to manage the dependencies.
   Use the `RepositoryHandler` returned by `Project.getRepositories()` method to manage the repositories.
   
   [source]
   ----
   dependencies {
       implementation("com.google.guava:guava:32.1.1-jre")
   }
   ----
   
   In the example, the application code uses Google's `guava` libraries.
   Guava provides utility methods for collections, caching, primitives support, concurrency, common annotations, string processing, I/O, and validations.
   
   === 4. Set properties
   
   A plugin can add properties and methods to a project using extensions.
   
   The link:{groovyDslPath}#[`Project`] object has an associated link:{javadocPath}#[`ExtensionContainer`] object that contains all the settings and properties for the plugins that have been applied to the project.
   
   In the example, the `application` plugin added an `application` property, which is used to detail the main class of our Java application:
   
   [source]
   ----
   application {
       mainClass = "com.example.Main"
   }
   ----
   
   === 5. Register and configure tasks
   
   Tasks perform some basic piece of work, such as compiling classes, or running unit tests, or zipping up a WAR file.
   
   While tasks are typically defined in plugins, you may need to register or configure tasks in build scripts.
   
   *Registering* a task adds the task to your project.
   
   You can register tasks in a project using the link:{javadocPath}#[`TaskContainer.register(java.lang.String)`] method:
   
   [source]
   ----
   tasks.register<Zip>("zip-reports") {
       from 'Reports/'
       include '*'
       archiveName 'Reports.zip'
       destinationDir(file('/dir'))
   }
   ----
   
   You may have seen usage of the link:{javadocPath}#[`TaskContainer.create(java.lang.String)`] method *which should be avoided*:
   
   [source]
   ----
   tasks.create<Zip>("zip-reports") {
       from 'Reports/'
       include '*'
       archiveName 'Reports.zip'
       destinationDir(file('/dir'))
   }
   ----
   
   TIP: `register()`, which enables <<task_configuration_avoidance.adoc#task_configuration_avoidance,task configuration avoidance>>, is preferred over `create()`.
   
   You can locate a task to configure it using the `TaskCollection.named(java.lang.String)` method:
   
   [source]
   ----
   tasks.named<Test>("test") {
       useJUnitPlatform()
   }
   ----
   
   The example below configures the link:{groovyDslPath}#[`Javadoc`] task to automatically generate HTML documentation from Java code:
   
   [source]
   ----
   tasks.named("javadoc").configure {
       exclude 'app/Internal*.java'
       exclude 'app/internal/*'
       exclude 'app/internal/*'
   }
   ----
   
   == Build Scripting
   
   A build script is made up of zero or more statements and script blocks:
   
   [source]
   ----
   println(project.layout.projectDirectory);
   ----
   
   Statements can include method calls, property assignments, and local variable definitions:
   
   [source]
   ----
   version = '1.0.0.GA'
   ----
   
   A script block is a method call which takes a closure/lambda as a parameter:
   
   [source]
   ----
   configurations {
   }
   ----
   
   The closure/lambda configures some delegate object as it executes:
   
   [source]
   ----
   repositories {
       google()
   }
   ----
   
   A build script is also a Groovy or a Kotlin script:
   
   ====
   include::sample[dir="snippets/tutorial/upper/kotlin", files="build.gradle.kts[]"]
   include::sample[dir="snippets/tutorial/upper/groovy", files="build.gradle[]"]
   ----
   $ gradle -q upper
   include::{snippetsPath}/tutorial/upper/tests/upper.out[]
   ----
   ====
   
   It can contain elements allowed in a Groovy or Kotlin script, such as method definitions and class definitions:
   
   ====
   include::sample[dir="snippets/tutorial/count/kotlin", files="build.gradle.kts[]"]
   include::sample[dir="snippets/tutorial/count/groovy", files="build.gradle[]"]
   
   ----
   $ gradle -q count
   include::{snippetsPath}/tutorial/count/tests/count.out[]
   ----
   ====
   
   === Flexible task registration
   
   Using the capabilities of the Groovy or Kotlin language, you can register multiple tasks in a loop:
   
   ====
   include::sample[dir="snippets/tutorial/dynamic/kotlin", files="build.gradle.kts[]"]
   include::sample[dir="snippets/tutorial/dynamic/groovy", files="build.gradle[]"]
   
   ----
   $ gradle -q task1
   include::{snippetsPath}/tutorial/dynamic/tests/dynamic.out[]
   ----
   ====
   
   === Declare Variables
   
   Build scripts can declare two variables: *local variables* and *extra properties*.
   
   ==== Local Variables
   
   [.multi-language-text.lang-kotlin]
   Declare local variables with the `val` keyword. Local variables are only visible in the scope where they have been declared. They are a feature of the underlying Kotlin language.
   
   [.multi-language-text.lang-groovy]
   Declare local variables with the `def` keyword. Local variables are only visible in the scope where they have been declared. They are a feature of the underlying Groovy language.
   
   ====
   include::sample[dir="snippets/tutorial/localVariables/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/tutorial/localVariables/groovy",files="build.gradle[]"]
   ====
   
   ==== Extra Properties
   
   Gradle's enhanced objects, including projects, tasks, and source sets, can hold user-defined properties.
   
   [.multi-language-text.lang-kotlin]
   Add, read, and set extra properties via the owning object's `extra` property. Alternatively, you can access extra properties via Kotlin delegated properties using `by extra`.
   
   [.multi-language-text.lang-groovy]
   Add, read, and set extra properties via the owning object's `ext` property. Alternatively, you can use an `ext` block to add multiple properties simultaneously.
   
   ====
   include::sample[dir="snippets/tutorial/extraProperties/kotlin",files="build.gradle.kts[tags=extraProperties]"]
   include::sample[dir="snippets/tutorial/extraProperties/groovy",files="build.gradle[tags=extraProperties]"]
   
   ----
   $ gradle -q printProperties
   include::{snippetsPath}/tutorial/extraProperties/tests/extraProperties.out[]
   ----
   ====
   
   [.multi-language-text.lang-kotlin]
   This example adds two extra properties to the `project` object via `by extra`. Additionally, this example adds a property named `purpose` to each source set by setting `extra["purpose"]` to `null`. Once added, you can read and set these properties via `extra`.
   
   [.multi-language-text.lang-groovy]
   This example adds two extra properties to the `project` object via an `ext` block. Additionally, this example adds a property named `purpose` to each source set by setting `ext.purpose` to `null`. Once added, you can read and set all these properties just like predefined ones.
   
   Gradle requires special syntax for adding a property so that it can fail fast. For example, this allows Gradle to recognize
   when a script attempts to set a property that does not exist. You can access extra properties anywhere where you can
   access their owning object. This gives extra properties a wider scope than local variables.
   Subprojects can access extra properties on their parent projects.
   
   For more information about extra properties, see
   link:{groovyDslPath}#[ExtraPropertiesExtension] in the API documentation.
   
   === Configure Arbitrary Objects
   
   The example `greet()` task shows an example of arbitrary object configuration:
   
   ====
   include::sample[dir="snippets/tutorial/configureObject/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/tutorial/configureObject/groovy",files="build.gradle[]"]
   
   ----
   $ gradle -q greet
   include::{snippetsPath}/tutorial/configureObject/tests/configureObject.out[]
   ----
   ====
   
   ==== Closure Delegates
   
   Each closure has a `delegate` object. Groovy uses this delegate to look up variable and method references to nonlocal variables and closure parameters.
   Gradle uses this for _configuration closures_,
   where the `delegate` object refers to the object being configured.
   
   ====
   include::sample[dir="snippets/tutorial/groovy/groovy",files="build.gradle[tags=closureDelegates]"]
   ====
   
   == Default imports
   
   To make build scripts more concise, Gradle automatically adds a set of import statements to scripts.
   
   As a result, instead of writing `throw new org.gradle.api.tasks.StopExecutionException()`, you can write `throw new StopExecutionException()` instead.
   
   Gradle implicitly adds the following imports to each script:
   
   .Gradle default imports
   [source,groovy]
   ----
   include::default-imports.txt[]
   ----
   
   
   [.text-right]
   **Next Step:** <<tutorial_using_tasks.adoc#tutorial_using_tasks,Learn how to use Tasks>> >>

/docs/userguide/authoring-builds/basics/tutorial_using_tasks.adoc
=================================================================

.. code-block::

   = Using Tasks
   
   The work that Gradle can do on a project is defined by one or more _tasks_.
   
   image::author-gradle-5.png[]
   
   A task represents some independent unit of work that a build performs.
   This might be compiling some classes, creating a JAR, generating Javadoc, or publishing some archives to a repository.
   
   When a user runs `./gradlew build` in the command line, Gradle will execute the `build` task along with any other tasks it depends on.
   
   == List available tasks
   
   Gradle provides several default tasks for a project, which are listed by running `./gradlew tasks`:
   
   [source,text]
   ----
   > Task :tasks
   
   ------------------------------------------------------------
   Tasks runnable from root project 'myTutorial'
   ------------------------------------------------------------
   
   Build Setup tasks
   -----------------
   init - Initializes a new Gradle build.
   wrapper - Generates Gradle wrapper files.
   
   Help tasks
   ----------
   buildEnvironment - Displays all buildscript dependencies declared in root project 'myTutorial'.
   ...
   ----
   
   Tasks either come from *build scripts* or *plugins*.
   
   Once we apply a plugin to our project, such as the `application` plugin, additional tasks become available:
   
   .build.gradle.kts
   [source,kotlin]
   plugins {
       id("application")
   }
   
   [source]
   ----
   $ ./gradlew tasks
   
   > Task :tasks
   
   ------------------------------------------------------------
   Tasks runnable from project ':app'
   ------------------------------------------------------------
   
   Application tasks
   -----------------
   run - Runs this project as a JVM application
   
   Build tasks
   -----------
   assemble - Assembles the outputs of this project.
   build - Assembles and tests this project.
   
   Documentation tasks
   -------------------
   javadoc - Generates Javadoc API documentation for the main source code.
   
   Other tasks
   -----------
   compileJava - Compiles main Java source.
   
   ...
   ----
   
   Many of these tasks, such as `assemble`, `build`, and `run`, should be familiar to a developer.
   
   == Task classification
   
   There are two classes of tasks that can be executed:
   
   1. *Actionable tasks* have some action(s) attached to do work in your build: `compileJava`.
   2. *Lifecycle tasks* are tasks with no actions attached: `assemble`, `build`.
   
   Typically, a *lifecycle* tasks depends on many *actionable* tasks, and is used to execute many tasks at once.
   
   == Task registration and action
   
   Let's take a look at a simple "Hello World" task in a build script:
   
   ====
   include::sample[dir="snippets/tutorial/hello/kotlin", files="build.gradle.kts[]"]
   include::sample[dir="snippets/tutorial/hello/groovy", files="build.gradle[]"]
   ====
   
   In the example, the build script *registers* a single task called `hello` using the link:{javadocPath}#[TaskContainer] API, and adds an *action* to it.
   
   If the tasks in the project are listed, the `hello` task is available to Gradle:
   
   [source]
   ----
   $ ./gradlew app:tasks --all
   
   > Task :app:tasks
   
   ------------------------------------------------------------
   Tasks runnable from project ':app'
   ------------------------------------------------------------
   
   Other tasks
   -----------
   compileJava - Compiles main Java source.
   compileTestJava - Compiles test Java source.
   hello
   processResources - Processes main resources.
   processTestResources - Processes test resources.
   startScripts - Creates OS-specific scripts to run the project as a JVM application.
   ----
   
   You can execute the task in the build script with `./gradlew hello`:
   
   ====
   ----
   $ ./gradlew hello
   include::{snippetsPath}/tutorial/hello/tests/hello.out[]
   ----
   ====
   
   When Gradle executes the `hello` task, it executes the *action* provided.
   In this case, the action is simply a block containing some code: `println("Hello world!")`.
   
   == Task group and description
   
   The `hello` task from the previous section can be detailed with a *description* and assigned to a *group* with the following update:
   
   .build.gradle.kts
   [source,kotlin]
   ----
   tasks.register("hello") {
       group = "Custom"
       description = "A lovely greeting task."
       doLast {
           println("Hello world!")
       }
   }
   ----
   
   Once the task is assigned to a group, it will be listed by `./gradlew tasks`:
   
   [source]
   ----
   $ ./gradlew tasks
   
   > Task :tasks
   
   Custom tasks
   ------------------
   hello - A lovely greeting task.
   ----
   
   To view information about a task, use the `help --task <task-name>` command:
   
   [source]
   ----
   $./gradlew help --task hello
   
   > Task :help
   Detailed task information for hello
   
   Path
   :app:hello
   
   Type
   Task (org.gradle.api.Task)
   
   Options
   --rerun     Causes the task to be re-run even if up-to-date.
   
   Description
   A lovely greeting task.
   
   Group
   Custom
   ----
   
   As we can see, the `hello` task belongs to the `custom` group.
   
   == Task dependencies
   
   You can declare tasks that depend on other tasks:
   
   ====
   include::sample[dir="snippets/tutorial/intro/kotlin", files="build.gradle.kts[]"]
   include::sample[dir="snippets/tutorial/intro/groovy", files="build.gradle[]"]
   
   ----
   $ gradle -q intro
   include::{snippetsPath}/tutorial/intro/tests/intro.out[]
   ----
   ====
   
   The dependency of `taskX` to `taskY` may be declared before `taskY` is defined:
   
   ====
   include::sample[dir="snippets/tutorial/lazyDependsOn/kotlin", files="build.gradle.kts[]"]
   include::sample[dir="snippets/tutorial/lazyDependsOn/groovy", files="build.gradle[]"]
   
   ----
   $ gradle -q taskX
   include::{snippetsPath}/tutorial/lazyDependsOn/tests/lazyDependsOn.out[]
   ----
   ====
   
   The `hello` task from the previous example is updated to include a dependency:
   
   .build.gradle.kts
   [source,kotlin]
   ----
   tasks.register("hello") {
       group = "Custom"
       description = "A lovely greeting task."
       doLast {
           println("Hello world!")
       }
       dependsOn(tasks.assemble)
   }
   ----
   
   The `hello` task now depends on the `assemble` task, which means that Gradle must execute the `assemble` task *before* it can execute the `hello` task:
   
   [source]
   ----
   $ ./gradlew :app:hello
   
   > Task :app:compileJava UP-TO-DATE
   > Task :app:processResources NO-SOURCE
   > Task :app:classes UP-TO-DATE
   > Task :app:jar UP-TO-DATE
   > Task :app:startScripts UP-TO-DATE
   > Task :app:distTar UP-TO-DATE
   > Task :app:distZip UP-TO-DATE
   > Task :app:assemble UP-TO-DATE
   
   > Task :app:hello
   Hello world!
   ----
   
   == Task configuration
   
   Once registered, tasks can be accessed via the link:{javadocPath}#[TaskProvider] API for further configuration.
   
   For instance, you can use this to add dependencies to a task at runtime dynamically:
   
   ====
   include::sample[dir="snippets/tutorial/dynamicDepends/kotlin", files="build.gradle.kts[]"]
   include::sample[dir="snippets/tutorial/dynamicDepends/groovy", files="build.gradle[]"]
   
   ----
   $ gradle -q task0
   include::{snippetsPath}/tutorial/dynamicDepends/tests/dynamicDepends.out[]
   ----
   ====
   
   Or you can add behavior to an existing task:
   
   ====
   include::sample[dir="snippets/tutorial/helloEnhanced/kotlin", files="build.gradle.kts[]"]
   include::sample[dir="snippets/tutorial/helloEnhanced/groovy", files="build.gradle[]"]
   
   ----
   $ gradle -q hello
   include::{snippetsPath}/tutorial/helloEnhanced/tests/helloEnhanced.out[]
   ----
   ====
   
   TIP: The calls `doFirst` and `doLast` can be executed multiple times.
   They add an action to the beginning or the end of the task's actions list.
   When the task executes, the actions in the action list are executed in order.
   
   Here is an example of the `named` method being used to configure a task added by a plugin:
   
   [source,groovy]
   ----
   tasks.named("dokkaHtml") {
       outputDirectory.set(buildDir.resolve("dokka"))
   }
   ----
   
   == Task types
   Gradle tasks are a subclass of link:{javadocPath}#[`Task`].
   
   In the build script, the `HelloTask` class is created by extending link:{javadocPath}#[`DefaultTask`]:
   
   .build.gradle.kts
   [source, kotlin]
   ----
   // Extend the DefaultTask class to create a HelloTask class
   abstract class HelloTask : DefaultTask() {
       @TaskAction
       fun hello() {
           println("hello from HelloTask")
       }
   }
   
   // Register the hello Task with type HelloTask
   tasks.register<HelloTask>("hello") {
       group = "Custom tasks"
       description = "A lovely greeting task."
   }
   ----
   
   The `hello` task is registered with the *type* `HelloTask`.
   
   Executing our new `hello` task:
   
   [source]
   ----
   $ ./gradlew hello
   
   > Task :app:hello
   hello from HelloTask
   ----
   
   Now the `hello` task is of type `HelloTask` instead of type `Task`.
   
   The Gradle `help` task reveals the change:
   
   [source]
   ----
   $ ./gradlew help --task hello
   
   > Task :help
   Detailed task information for hello
   
   Path
   :app:hello
   
   Type
   HelloTask (Build_gradle$HelloTask)
   
   Options
   --rerun     Causes the task to be re-run even if up-to-date.
   
   Description
   A lovely greeting task.
   
   Group
   Custom tasks
   ----
   
   == Built-in task types
   Gradle provides many built-in task types with common and popular functionality, such as copying or deleting files.
   
   This example task copies `*.war` files from the `source` directory to the `target` directory using the `Copy` built-in task:
   
   [source]
   ----
   tasks.register("copyTask",Copy) {
       from("source")
       into("target")
       include("*.war")
   }
   ----
   
   There are many task types developers can take advantage of, including `GroovyDoc`, `Zip`, `Jar`, `JacocoReport`, `Sign`, or `Delete`, which are available in the link:{groovyDslPath}#[DSL].
   
   
   [.text-right]
   **Next Step:** <<writing_tasks.adoc#writing_tasks,Learn how to write Tasks>> >>

/docs/userguide/authoring-builds/basics/writing_tasks.adoc
==========================================================

.. code-block::

   = Writing Tasks
   
   Gradle tasks are created by extending link:{javadocPath}#[`DefaultTask`].
   
   However, the generic `DefaultTask` provides no action for Gradle.
   If users want to extend the capabilities of Gradle and their build script, they must either use a *built-in task* or create a *custom task*:
   
   1. *Built-in task* - Gradle provides built-in utility tasks such as `Copy`, `Jar`, `Zip`, `Delete`, etc...
   2. *Custom task* - Gradle allows users to subclass `DefaultTask` to create their own task types.
   
   == Create a task
   
   The simplest and quickest way to create a *custom* task is in a build script:
   
   To create a task, inherit from the `DefaultTask` class and implement a link:{javadocPath}#[`@TaskAction`] handler:
   
   .build.gradle.kts
   [source,kotlin]
   ----
   abstract class CreateFileTask : DefaultTask() {
       @TaskAction
       fun action() {
           val file = File("myfile.txt")
           file.createNewFile()
           file.writeText("HELLO FROM MY TASK")
       }
   }
   ----
   
   The `CreateFileTask` implements a simple set of *actions*.
   First, a file called "myfile.txt" is created in the main project.
   Then, some text is written to the file.
   
   == Register a task
   
   A task is *registered* in the build script using the link:{javadocPath}#[`TaskContainer.register()`] method, which allows it to be then used in the build logic.
   
   .build.gradle.kts
   [source,kotlin]
   ----
   abstract class CreateFileTask : DefaultTask() {
       @TaskAction
       fun action() {
           val file = File("myfile.txt")
           file.createNewFile()
           file.writeText("HELLO FROM MY TASK")
       }
   }
   
   tasks.register<CreateFileTask>("createFileTask")
   ----
   
   == Task group and description
   
   Setting the *group* and *description* properties on your tasks can help users understand how to use your task:
   
   .build.gradle.kts
   [source,kotlin]
   ----
   abstract class CreateFileTask : DefaultTask() {
       @TaskAction
       fun action() {
           val file = File("myfile.txt")
           file.createNewFile()
           file.writeText("HELLO FROM MY TASK")
       }
   }
   
   tasks.register<CreateFileTask>("createFileTask", ) {
       group = "custom"
       description = "Create myfile.txt in the current directory"
   }
   ----
   
   Once a task is added to a group, it is visible when listing tasks.
   
   == Task input and outputs
   
   For the task to do useful work, it typically needs some *inputs*.
   A task typically produces *outputs*.
   
   .build.gradle.kts
   [source,kotlin]
   ----
   abstract class CreateFileTask : DefaultTask() {
       @Input
       val fileText = "HELLO FROM MY TASK"
   
       @Input
       val fileName = "myfile.txt"
   
       @OutputFile
       val myFile: File = File(fileName)
   
       @TaskAction
       fun action() {
           myFile.createNewFile()
           myFile.writeText(fileText)
       }
   }
   
   tasks.register<CreateFileTask>("createFileTask") {
       group = "custom"
       description = "Create myfile.txt in the current directory"
   }
   ----
   
   == Configure a task
   
   A task is optionally *configured* in a build script using the link:{javadocPath}#[`TaskCollection.named()`] method.
   
   The `CreateFileTask` class is updated so that the text in the file is configurable:
   
   .build.gradle.kts
   [source,kotlin]
   ----
   abstract class CreateFileTask : DefaultTask() {
       @get:Input
       abstract val fileText: Property<String>
   
       @Input
       val fileName = "myfile.txt"
   
       @OutputFile
       val myFile: File = File(fileName)
   
       @TaskAction
       fun action() {
           myFile.createNewFile()
           myFile.writeText(fileText.get())
       }
   }
   
   tasks.register<CreateFileTask>("createFileTask") {
       group = "custom"
       description = "Create myfile.txt in the current directory"
       fileText.convention("HELLO FROM THE CREATE FILE TASK METHOD") // Set convention
   }
   
   tasks.named<CreateFileTask>("createFileTask") {
       fileText.set("HELLO FROM THE NAMED METHOD") // Override with custom message
   }
   ----
   
   // Add a small excerpt about properties
   
   In the `named()` method, we find the `createFileTask` task and set the text that will be written to the file.
   
   When the task is executed:
   
   [source]
   ----
   $ ./gradlew createFileTask
   
   > Configure project :app
   
   > Task :app:createFileTask
   
   BUILD SUCCESSFUL in 5s
   2 actionable tasks: 1 executed, 1 up-to-date
   ----
   
   A text file called `myfile.txt` is created in the project root folder:
   
   .myfile.txt
   [source,txt]
   ----
   HELLO FROM THE NAMED METHOD
   ----
   
   Consult the <<more_about_tasks.adoc#more_about_tasks,Developing Gradle Tasks chapter>> to learn more.
   
   [.text-right]
   **Next Step:** <<plugins.adoc#using_plugins,Learn how to use Plugins>> >>

/docs/userguide/authoring-builds/basics/plugins.adoc
====================================================

.. code-block::

   = Using Plugins
   
   Much of Gradle's functionality is delivered via plugins, including core plugins distributed with Gradle, third-party plugins, and script plugins defined within builds.
   
   Plugins introduce new tasks (e.g., `JavaCompile`), domain objects (e.g., `SourceSet`), conventions (e.g., locating Java source at `src/main/java`), and extend core or other plugin objects.
   
   Plugins in Gradle are essential for automating common build tasks, integrating with external tools or services, and tailoring the build process to meet specific project needs.
   They also serve as the primary mechanism for organizing build logic.
   
   == Benefits of plugins
   
   Writing many tasks and duplicating configuration blocks in build scripts can get messy.
   Plugins offer several advantages over adding logic directly to the build script:
   
   - *Promotes Reusability*: Reduces the need to duplicate similar logic across projects.
   - *Enhances Modularity*: Allows for a more modular and organized build script.
   - *Encapsulates Logic*: Keeps imperative logic separate, enabling more declarative build scripts.
   
   == Plugin distribution
   
   You can leverage plugins from Gradle and the Gradle community or create your own.
   
   Plugins are available in three ways:
   
   1. **Core plugins** - Gradle develops and maintains a set of <<plugin_reference#plugin_reference,Core Plugins>>.
   2. **Community plugins** - Gradle plugins shared in a remote repository such as Maven or the https://plugins.gradle.org[Gradle Plugin Portal].
   3. **Local plugins** - Gradle enables users to create *custom* plugins using link:{javadocPath}#[APIs].
   
   == Types of plugins
   
   Plugins can be implemented as *binary plugins*, *precompiled script plugins*, or *script plugins*:
   
   Binary Plugins :: Binary plugins are compiled plugins typically written in Java or Kotlin DSL that are packaged as JAR files.
   They are applied to a project using the `plugins {}` block.
   They offer better performance and maintainability compared to script plugins or precompiled script plugins.
   
   Precompiled Script Plugins :: Precompiled script plugins are Groovy DSL or Kotlin DSL scripts compiled and distributed as Java class files packaged in a library.
   They are applied to a project using the `plugins {}` block.
   They provide a way to reuse complex logic across projects and allow for better organization of build logic.
   
   Script Plugins :: Script plugins are Groovy DSL or Kotlin DSL scripts that are applied directly to a Gradle build script using the `apply from:` syntax.
   They are applied inline within a build script to add functionality or customize the build process.
   They are simple to use.
   
   A plugin often starts as a script plugin (because they are easy to write).
   Then, as the code becomes more valuable, it's migrated to a binary plugin that can be easily tested and shared between multiple projects or organizations.
   
   == Using plugins
   
   To use the build logic encapsulated in a plugin, Gradle needs to perform two steps.
   First, it needs to *resolve* the plugin, and then it needs to *apply* the plugin to the target, usually a link:{groovyDslPath}#[`Project`].
   
   1. *Resolving* a plugin means finding the correct version of the JAR that contains a given plugin and adding it to the script classpath.
   Once a plugin is resolved, its API can be used in a build script.
   Script plugins are self-resolving in that they are resolved from the specific file path or URL provided when applying them.
   Core binary plugins provided as part of the Gradle distribution are automatically resolved.
   
   2. *Applying* a plugin means executing the plugin's link:{javadocPath}#[Plugin.apply(T)] on a project.
   
   The <<#sec:plugins_block,plugins DSL>> is recommended to resolve and apply plugins in one step.
   
   == Resolving plugins
   
   Gradle provides the *core plugins* (e.g., `JavaPlugin`, `GroovyPlugin`, `MavenPublishPlugin`, etc.) as part of its distribution, which means they are automatically resolved.
   
   Core plugins are applied in a build script using the plugin name:
   
   [source,text]
   ----
   plugins {
       id 춺plugin name췉
   }
   ----
   
   For example:
   
   .build.gradle
   [source,text]
   ----
   plugins {
       id("java")
   }
   ----
   
   Non-core plugins must be resolved before they can be applied.
   Non-core plugins are identified by a unique ID and a version in the build file:
   
   [source,text]
   ----
   plugins {
       id 춺plugin id췉 version 춺plugin version췉
   }
   ----
   
   And the location of the plugin must be specified in the settings file:
   
   .settings.gradle
   [source,groovy]
   ----
   pluginManagement {
       repositories {
           gradlePluginPortal()
       }
       maven {
           url 'https://maven.example.com/plugins'
       }
   }
   
   ----
   
   There are additional considerations for resolving and applying plugins:
   
   [%autowidth.stretch]
   |===
   |# |To |Use |For example:
   
   |<<#sec:plugins_block,1>>
   |Apply a *core*, *community* or *local* plugin to a specific project.
   |<<#sec:plugins_block,The `plugins` block in the build file>>
   a|
   [source,kotlin]
   ----
   plugins {
     id("org.barfuin.gradle.taskinfo") version "2.1.0"
   }
   ----
   
   |<<#sec:buildsrc_plugins_dsl,2>>
   |Apply common *core*, *community* or *local* plugin to multiple subprojects.
   |<<#sec:buildsrc_plugins_dsl,A build script in the `buildSrc` directory>>
   a|
   [source,kotlin]
   ----
   plugins {
       id("org.barfuin.gradle.taskinfo") version "2.1.0"
   }
   repositories {
       jcenter()
   }
   dependencies {
       implementation(Libs.Kotlin.coroutines)
   }
   ----
   
   |<<#sec:applying_plugins_buildscript,3>>
   |Apply a *core*, *community* or *local* plugin needed _for the build script itself_.
   |<<#sec:applying_plugins_buildscript,The `buildscript` block in the build file>>
   a|
   [source,kotlin]
   ----
   buildscript {
     repositories {
       maven {
         url = uri("https://plugins.gradle.org/m2/")
       }
     }
     dependencies {
       classpath("org.barfuin.gradle.taskinfo:gradle-taskinfo:2.1.0")
     }
   }
   // Apply the plugin defined in the buildscript block
   plugins {
     id("org.barfuin.gradle.taskinfo") version "2.1.0"
   }
   ----
   
   |<<sec:script_plugins,4>>
   |Apply a *local* script plugins.
   |<<sec:script_plugins,The legacy `apply()` method in the build file>>
   a|
   [source,kotlin]
   ----
   apply(plugin = "org.barfuin.gradle.taskinfo")
   apply<MyPlugin>()
   ----
   |===
   
   == 1. Applying plugins using the `plugins{}` block
   
   The plugin DSL provides a concise and convenient way to declare plugin dependencies.
   
   The plugins block configures an instance of link:{javadocPath}#[`PluginDependenciesSpec`]:
   
   [source, build.gradle.kts]
   ----
   plugins {
       application                                     // by name
       java                                            // by name
       id("java")                                      // by id - recommended
       id("org.jetbrains.kotlin.jvm") version "1.9.0"  // by id - recommended
   }
   ----
   
   Core Gradle plugins are unique in that they provide short names, such as `java` for the core link:{javadocPath}#[JavaPlugin].
   
   To apply a core plugin, the short *name* can be used:
   
   ====
   include::sample[dir="snippets/plugins/dsl/kotlin", files="build.gradle.kts[tags=use-plugin]"]
   include::sample[dir="snippets/plugins/dsl/groovy", files="build.gradle[tags=use-plugin]"]
   ====
   
   All other binary plugins must use the fully qualified form of the plugin id (e.g., `com.github.foo.bar`).
   
   To apply a community plugin from http://plugins.gradle.org[Gradle plugin portal], the fully qualified *plugin id*, a globally unique identifier, must be used:
   
   ====
   include::sample[dir="snippets/plugins/dsl/kotlin", files="build.gradle.kts[tags=use-community-plugin]"]
   include::sample[dir="snippets/plugins/dsl/groovy", files="build.gradle[tags=use-community-plugin]"]
   ====
   
   See link:{javadocPath}#[`PluginDependenciesSpec`] for more information on using the Plugin DSL.
   
   === Limitations of the plugins DSL
   
   The plugins DSL provides a convenient syntax for users and the ability for Gradle to determine which plugins are used quickly.
   This allows Gradle to:
   
   * Optimize the loading and reuse of plugin classes.
   * Provide editors with detailed information about the potential properties and values in the build script.
   
   However, the DSL requires that plugins be defined statically.
   
   There are some key differences between the `plugins {}` block mechanism and the "traditional" `apply()` method mechanism.
   There are also some constraints and possible limitations.
   
   ==== Constrained Syntax
   
   The `plugins {}` block does not support arbitrary code.
   
   It is constrained to be idempotent (produce the same result every time) and side effect-free (safe for Gradle to execute at any time).
   
   The form is:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id(춺plugin id췉)                             // <1>
       id(춺plugin id췉) version 춺plugin version췉    // <2>
   }
   ----
   <1> for core Gradle plugins or plugins already available to the build script
   <2> for binary Gradle plugins that need to be resolved
   =====
   
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   plugins {
       id 춺plugin id췉                            // <1>
       id 춺plugin id췉 version 춺plugin version췉   // <2>
   }
   ----
   <1> for core Gradle plugins or plugins already available to the build script
   <2> for binary Gradle plugins that need to be resolved
   =====
   ====
   
   [.multi-language-text.lang-kotlin]
   Where `춺plugin id췉` and `춺plugin version췉` are a string.
   
   [.multi-language-text.lang-groovy]
   Where `춺plugin id췉` and `춺plugin version췉` must be constant, literal strings.
   
   The `plugins{}` block must also be a top-level statement in the build script.
   It cannot be nested inside another construct (e.g., an if-statement or for-loop).
   
   ==== Only in build scripts and settings file
   
   The `plugins{}` block can only be used in a project's build script `build.gradle(.kts)` and the `settings.gradle(.kts)` file.
   It must appear before any other block.
   It cannot be used in script plugins or init scripts.
   
   ==== Applying plugins to all subprojects
   
   Suppose you have a <<multi_project_builds.adoc#multi_project_builds,multi-project build>>, you probably want to apply plugins to some or all of the subprojects in your build but not to the `root` project.
   
   While the default behavior of the `plugins{}` block is to immediately `resolve` _and_ `apply` the plugins, you can use the `apply false` syntax to tell Gradle not to apply the plugin to the current project. Then, use the `plugins{}` block without the version in subprojects' build scripts:
   
   ====
   include::sample[dir="snippets/plugins/multiproject/kotlin", files="settings.gradle.kts[tags=include-subprojects];build.gradle.kts[tags=plugins-on-subprojects];hello-a/build.gradle.kts[];hello-b/build.gradle.kts[];goodbye-c/build.gradle.kts[]"]
   include::sample[dir="snippets/plugins/multiproject/groovy", files="settings.gradle[tags=include-subprojects];build.gradle[tags=plugins-on-subprojects];hello-a/build.gradle[];hello-b/build.gradle[];goodbye-c/build.gradle[]"]
   ====
   
   You can also encapsulate the versions of external plugins by composing the build logic using your own <<sharing_build_logic_between_subprojects#sec:convention_plugins,convention plugins>>.
   
   == 2. Applying plugins from the `buildSrc` directory
   
   `buildSrc` is an optional directory at the Gradle project root that contains build logic (i.e., plugins) used in building the main project.
   You can apply plugins that reside in a project's `buildSrc` directory as long as they have a defined ID.
   
   The following example shows how to tie the plugin implementation class `my.MyPlugin`, defined in `buildSrc`, to the id "my-plugin":
   
   ====
   include::sample[dir="snippets/plugins/dslWithBuildSrc/kotlin", files="buildSrc/build.gradle.kts[tags=main-block]"]
   include::sample[dir="snippets/plugins/dslWithBuildSrc/groovy", files="buildSrc/build.gradle[tags=main-block]"]
   ====
   
   The plugin can then be applied by ID:
   
   ====
   include::sample[dir="snippets/plugins/dslWithBuildSrc/kotlin", files="build.gradle.kts[tags=use-plugin]"]
   include::sample[dir="snippets/plugins/dslWithBuildSrc/groovy", files="build.gradle[tags=use-plugin]"]
   ====
   
   == 3. Applying plugins using the `buildscript{}` block
   
   The `buildscript` block is used for:
   
   1. global `dependencies` and `repositories` required for building the project (applied in the subprojects).
   2. declaring which plugins are available for use *in the build script* (in the `build.gradle(.kts)` file itself).
   
   So when you want to use a library in the build script itself, you must add this library on the script classpath using `buildScript`:
   
   [source,build.gradle]
   ----
   import org.apache.commons.codec.binary.Base64
   
   buildscript {
       repositories {  // this is where the plugins are located
           mavenCentral()
           google()
       }
       dependencies { // these are the plugins that can be used in subprojects or in the build file itself
           classpath group: 'commons-codec', name: 'commons-codec', version: '1.2' // used in the task below
           classpath 'com.android.tools.build:gradle:4.1.0' // used in subproject
       }
   }
   
   tasks.register('encode') {
       doLast {
           def byte[] encodedString = new Base64().encode('hello world\n'.getBytes())
           println new String(encodedString)
       }
   }
   ----
   
   And you can apply the globally declared dependencies in the subproject that needs it:
   
   [source,subproject/build.gradle]
   ----
   plugins {
       id 'com.android.application'
   }
   ----
   
   Binary plugins published as external jar files can be added to a project by adding the plugin to the build script classpath and then applying the plugin.
   
   External jars can be added to the build script classpath using the `buildscript{}` block as described in <<writing_build_scripts#sec:build_script_external_dependencies,External dependencies for the build script>>:
   
   ====
   include::sample[dir="snippets/plugins/buildscript/kotlin", files="build.gradle.kts[tags=buildscript_block]"]
   include::sample[dir="snippets/plugins/buildscript/groovy", files="build.gradle[tags=buildscript_block]"]
   ====
   
   == 4. Applying script plugins using the legacy `apply()` method
   
   A script plugin is an ad-hoc plugin, typically written and applied in the same build script.
   It is applied using the <<sec:old_plugin_application,legacy application method>>:
   
   [source, build.gradle.kts]
   ----
   class MyPlugin : Plugin<Project> {
       override fun apply(project: Project) {
           println("Plugin ${this.javaClass.simpleName} applied on ${project.name}")
       }
   }
   
   apply<MyPlugin>()
   ----
   
   Let's take a rudimentary example of a plugin written in a file called `other.gradle` located in the same directory as the `build.gradle` file:
   
   [source, other.gradle]
   ----
   public class Other implements Plugin<Project> {
       @Override
       void apply(Project project) {
           // Does something
       }
   }
   ----
   
   First, import the external file using:
   
   [source, build.gradle]
   ----
   apply from: 'other.gradle'
   ----
   
   Then you can apply it:
   
   [source, build.gradle]
   ----
   apply plugin: Other
   ----
   
   Script plugins are automatically resolved and can be applied from a script on the local filesystem or remotely:
   
   ====
   include::sample[dir="snippets/organizingGradleProjects/configureProjectUsingScript/kotlin", files="build.gradle.kts[]"]
   include::sample[dir="snippets/organizingGradleProjects/configureProjectUsingScript/groovy", files="build.gradle[]"]
   ====
   
   Filesystem locations are relative to the project directory, while remote script locations are specified with an HTTP URL.
   Multiple script plugins (of either form) can be applied to a given target.
   
   == Plugin Management
   
   The `pluginManagement{}` block is used to configure repositories for plugin resolution and to define version constraints for plugins that are applied in the build scripts.
   
   The `pluginManagement{}` block can be used in a `settings.gradle(.kts)` file, where it must be the first block in the file:
   
   ====
   include::sample[dir="snippets/plugins/pluginManagement/kotlin", files="settings.gradle.kts[]"]
   include::sample[dir="snippets/plugins/pluginManagement/groovy", files="settings.gradle[]"]
   ====
   
   The block can also be used in <<init_scripts.adoc#init_scripts,Initialization Script>>:
   
   ====
   include::sample[dir="snippets/plugins/pluginManagement/kotlin", files="init.gradle.kts[]"]
   include::sample[dir="snippets/plugins/pluginManagement/groovy", files="init.gradle[]"]
   ====
   
   === Custom Plugin Repositories
   
   By default, the `plugins{}` DSL resolves plugins from the public https://plugins.gradle.org[Gradle Plugin Portal].
   
   Many build authors would also like to resolve plugins from private Maven or Ivy repositories because they contain proprietary implementation details or to have more control over what plugins are available to their builds.
   
   To specify custom plugin repositories, use the `repositories{}` block inside `pluginManagement{}`:
   
   ====
   include::sample[dir="snippets/plugins/consuming/kotlin", files="settings.gradle.kts[tags=custom-plugin-repositories]"]
   include::sample[dir="snippets/plugins/consuming/groovy", files="settings.gradle[tags=custom-plugin-repositories]"]
   ====
   
   This tells Gradle to first look in the Maven repository at `../maven-repo` when resolving plugins and then to check the Gradle Plugin Portal if the plugins are not found in the Maven repository.
   If you don't want the Gradle Plugin Portal to be searched, omit the `gradlePluginPortal()` line.
   Finally, the Ivy repository at `../ivy-repo` will be checked.
   
   === Plugin Version Management
   
   A `plugins{}` block inside `pluginManagement{}` allows all plugin versions for the build to be defined in a single location.
   Plugins can then be applied by id to any build script via the `plugins{}` block.
   
   One benefit of setting plugin versions this way is that the `pluginManagement.plugins{}` does not have the same <<#sec:constrained_syntax,constrained syntax>> as the build script `plugins{}` block.
   This allows plugin versions to be taken from `gradle.properties`, or loaded via another mechanism.
   
   Managing plugin versions via `pluginManagement`:
   
   ====
   include::sample[dir="snippets/plugins/pluginVersions/kotlin", files="settings.gradle.kts[tags=configure-plugin-version];build.gradle.kts;gradle.properties"]
   include::sample[dir="snippets/plugins/pluginVersions/groovy", files="settings.gradle[tags=configure-plugin-version];build.gradle;gradle.properties"]
   ====
   
   The plugin version is loaded from `gradle.properties` and configured in the settings script, allowing the plugin to be added to any project without specifying the version.
   
   === Plugin Resolution Rules
   
   Plugin resolution rules allow you to modify plugin requests made in `plugins{}` blocks, e.g., changing the requested version or explicitly specifying the implementation artifact coordinates.
   
   To add resolution rules, use the `resolutionStrategy{}` inside the `pluginManagement{}` block:
   
   ====
   include::sample[dir="snippets/plugins/resolutionRules/kotlin", files="settings.gradle.kts[tags=plugin-resolution-strategy]"]
   include::sample[dir="snippets/plugins/resolutionRules/groovy", files="settings.gradle[tags=plugin-resolution-strategy]"]
   ====
   
   This tells Gradle to use the specified plugin implementation artifact instead of its built-in default mapping from plugin ID to Maven/Ivy coordinates.
   
   Custom Maven and Ivy plugin repositories must contain <<#sec:plugin_markers,plugin marker artifacts>> and the artifacts that implement the plugin.
   Read <<java_gradle_plugin.adoc#java_gradle_plugin,Gradle Plugin Development Plugin>> for more information on publishing plugins to custom repositories.
   
   See link:{javadocPath}#[PluginManagementSpec] for complete documentation for using the `pluginManagement{}` block.
   
   === Plugin Marker Artifacts
   
   Since the `plugins{}` DSL block only allows for declaring plugins by their globally unique plugin `id` and `version` properties, Gradle needs a way to look up the coordinates of the plugin implementation artifact.
   
   To do so, Gradle will look for a Plugin Marker Artifact with the coordinates `plugin.id:plugin.id.gradle.plugin:plugin.version`.
   This marker needs to have a dependency on the actual plugin implementation.
   Publishing these markers is automated by the <<java_gradle_plugin.adoc#java_gradle_plugin,java-gradle-plugin>>.
   
   For example, the following complete sample from the `sample-plugins` project shows how to publish a `com.example.hello` plugin and a `com.example.goodbye` plugin to both an Ivy and Maven repository using the combination of the <<java_gradle_plugin.adoc#java_gradle_plugin,java-gradle-plugin>>, the <<publishing_maven.adoc#publishing_maven,maven-publish>> plugin, and the <<publishing_ivy.adoc#publishing_ivy,ivy-publish>> plugin.
   
   ====
   include::sample[dir="snippets/plugins/publishing/kotlin", files="build.gradle.kts[tags=complete-plugin-publishing]"]
   include::sample[dir="snippets/plugins/publishing/groovy", files="build.gradle[tags=complete-plugin-publishing]"]
   ====
   
   Running `gradle publish` in the sample directory creates the following Maven repository layout (the Ivy layout is similar):
   
   image::plugin-markers.png[]
   
   == Legacy Plugin Application
   
   With the introduction of the <<#sec:plugins_block,plugins DSL>>, users should have little reason to use the legacy method of applying plugins.
   It is documented here in case a build author cannot use the plugin DSL due to restrictions in how it currently works.
   
   
   ====
   include::sample[dir="snippets/java/quickstart/kotlin", files="build.gradle.kts[tags=use-plugin-legacy]"]
   include::sample[dir="snippets/java/quickstart/groovy", files="build.gradle[tags=use-plugin-legacy]"]
   ====
   
   Plugins can be applied using a _plugin id_.
   In the above case, we are using the short name "java" to apply the link:{javadocPath}#[JavaPlugin].
   
   Rather than using a plugin id, plugins can also be applied by simply specifying the class of the plugin:
   
   ====
   include::sample[dir="snippets/tutorial/pluginIntro/kotlin", files="build.gradle.kts[tags=apply-by-type]"]
   include::sample[dir="snippets/tutorial/pluginIntro/groovy", files="build.gradle[tags=apply-by-type]"]
   ====
   
   The `JavaPlugin` symbol in the above sample refers to the link:{javadocPath}#[JavaPlugin].
   This class does not strictly need to be imported as the `org.gradle.api.plugins` package is automatically imported in all build scripts (see <<writing_build_scripts.adoc#script-default-imports,Default imports>>).
   
   [.multi-language-text.lang-kotlin]
   Furthermore, one needs to append the `::class` suffix to identify a class literal in Kotlin instead of `.class` in Java.
   
   [.multi-language-text.lang-groovy]
   Furthermore, it is unnecessary to append `.class` to identify a class literal in Groovy as it is in Java.
   
   
   == Using a Version Catalog
   
   When a project uses a version catalog, plugins can be referenced via aliases when applied.
   
   
   Let's take a look at a simple Version Catalog:
   
   .gradle/libs.versions.toml
   [source,toml]
   ----
   [versions]
   intellij-plugin = "1.6"
   
   [plugins]
   jetbrains-intellij = { id = "org.jetbrains.intellij", version.ref = "intellij-plugin" }
   ----
   
   Then a plugin can be applied to any build script using the `alias` method:
   
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       alias(libs.plugins.jetbrains.intellij)
   }
   ----
   
   TIP: `jetbrains-intellij` is available as the Gradle generated safe accessor: `jetbrains.intellij`.
   
   [.text-right]
   **Next Step:** <<writing_plugins.adoc#writing_plugins,Learn how to write Plugins>> >>

/docs/userguide/authoring-builds/basics/writing_plugins.adoc
============================================================

.. code-block::

   = Writing Plugins
   
   If Gradle or the Gradle community does not offer the specific capabilities your project needs, creating your own plugin could be a solution.
   
   Additionally, if you find yourself duplicating build logic across subprojects and need a better way to organize it, custom plugins can help.
   
   == Custom plugin
   
   A plugin is any class that implements the link:{javadocPath}#[`Plugin`] interface.
   The example below is the most straightforward plugin, a "hello world" *plugin*:
   
   .build.gradle.kts
   [source,kotlin]
   ----
   import org.gradle.api.Plugin
   import org.gradle.api.Project
   
   abstract class SamplePlugin : Plugin<Project> {
       override fun apply(project: Project) {
           project.tasks.create("SampleTask") {
               println("Hello world!")
           }
       }
   }
   ----
   
   == Script plugin
   
   Many plugins start as a script plugin coded in a build script.
   This offers an easy way to rapidly prototype and experiment when building a plugin.
   Let's take a look at an example:
   
   .build.gradle.kts
   [source,kotlin]
   ----
   // Define a task
   abstract class CreateFileTask : DefaultTask() {                                     // <1>
       @get:Input
       abstract val fileText: Property<String>                                         // <2>
   
       @Input
       val fileName = "myfile.txt"
   
       @OutputFile
       val myFile: File = File(fileName)
   
       @TaskAction
       fun action() {
           myFile.createNewFile()
           myFile.writeText(fileText.get())
       }
   }
   
   // Define a plugin
   abstract class MyPlugin : Plugin<Project> {                                         // <3>
       override fun apply(project: Project) {
           tasks {
               register("createFileTask", CreateFileTask::class) {
                   group = "from my plugin"
                   description = "Create myfile.txt in the current directory"
                   fileText.set("HELLO FROM MY PLUGIN")
               }
           }
       }
   }
   
   // Apply the local plugin
   apply<MyPlugin>()                                                                   // <4>
   ----
   <1> Subclass `DefaultTask()`.
   <2> Use lazy configuration in the task.
   <3> Extend the `org.gradle.api.Plugin` interface.
   <4> Apply the script plugin.
   
   === 1. Subclass `DefaultTask()`
   First, build a task by subclassing `DefaultTask()`.
   
   [source,kotlin]
   ----
   abstract class CreateFileTask : DefaultTask() { }
   ----
   
   This simple task adds a file to our application뗩 root directory.
   
   === 2. Use Lazy Configuration
   Gradle has a concept called _lazy configuration_, which allows task inputs and outputs to be referenced before they are actually set.
   This is done via the link:{javadocPath}#[`Property`] class type.
   
   [source,kotlin]
   ----
   abstract val fileText: Property<String>
   ----
   
   One advantage of this mechanism is that you can link the output file of one task to the input file of another, all before the filename has even been decided.
   The `Property` class also knows which task it뗩 linked to, enabling Gradle to add the required task dependency automatically.
   
   === 3. Extend the `org.gradle.api.Plugin` interface
   Next, create a new class that extends the `org.gradle.api.Plugin` interface.
   
   [source]
   ----
   abstract class MyPlugin : Plugin<Project> {
       override fun apply() {}
   }
   ----
   
   You can add tasks and other logic in the `apply()` method.
   
   === 4. Apply the script plugin
   Finally, apply the local plugin in the build script.
   
   [source]
   ----
   apply<MyPlugin>()
   ----
   
   When `MyPlugin` is applied in the build script, Gradle calls the `fun apply() {}` method defined in the custom `MyPlugin` class.
   
   This makes the plugin available to the application.
   
   NOTE: Script plugins are NOT recommended. Script plugins offer an easy way to rapidly prototype build logic, before migrating it to a more permanent solution such as *convention plugins* or *binary plugins*.
   
   == Convention Plugins
   
   Convention plugins are a way to encapsulate and reuse common build logic in Gradle.
   They allow you to define a set of conventions for a project, and then apply those conventions to other projects or modules.
   
   The example above has been re-written as a convention plugin stored in `buildSrc`:
   
   .buildSrc/src/main/kotlin/MyConventionPlugin.kt
   [source,kotlin]
   ----
   import org.gradle.api.DefaultTask
   import org.gradle.api.Plugin
   import org.gradle.api.Project
   import org.gradle.api.provider.Property
   import org.gradle.api.tasks.Input
   import org.gradle.api.tasks.OutputFile
   import org.gradle.api.tasks.TaskAction
   import java.io.File
   
   abstract class CreateFileTask : DefaultTask() {
       @get:Input
       abstract val fileText: Property<String>
   
       @Input
       val fileName = project.rootDir.toString() + "/myfile.txt"
   
       @OutputFile
       val myFile: File = File(fileName)
   
       @TaskAction
       fun action() {
           myFile.createNewFile()
           myFile.writeText(fileText.get())
       }
   }
   
   class MyConventionPlugin : Plugin<Project> {
       override fun apply(project: Project) {
           project.tasks.register("createFileTask", CreateFileTask::class.java) {
               group = "from my plugin"
               description = "Create myfile.txt in the current directory"
               fileText.set("HELLO FROM MY PLUGIN")
           }
       }
   }
   ----
   
   The plugin can be given an `id` using a `gradlePlugin{}` block so that it can be referenced in the root:
   
   .buildSrc/build.gradle.kts
   [source,kotlin]
   ----
   gradlePlugin {
       plugins {
           create("my-convention-plugin") {
               id = "com.gradle.plugin.my-convention-plugin"
               implementationClass = "com.gradle.plugin.MyConventionPlugin"
           }
       }
   }
   ----
   
   The `gradlePlugin{}` block defines the plugins being built by the project.
   With the newly created `id`, the plugin can be applied in other build scripts accordingly:
   
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       application
       id("com.gradle.plugin.my-convention-plugin") // Apply the new plugin
   }
   ----
   
   == Binary Plugins
   
   A binary plugin is a plugin that is implemented in a compiled language and is packaged as a JAR file.
   It is resolved as a dependency rather than compiled from source.
   
   For most use cases, convention plugins must be updated infrequently.
   Having each developer execute the plugin build as part of their development process is wasteful, and we can instead distribute them as binary dependencies.
   
   There are two ways to update the convention plugin in the example above into a binary plugin.
   
   1. Use <<composite_builds.adoc#composite_builds,composite builds>>:
   +
   .settings.gradle.kts
   [source,kotlin]
   ----
   includeBuild("my-plugin")
   ----
   
   2. <<publishing_gradle_plugins.adoc#sec:publishing_your_plugin,Publish the plugin>> to a repository:
   +
   .build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("com.gradle.plugin.myconventionplugin") version "1.0.0"
   }
   ----
   
   Consult the <<custom_plugins.adoc#custom_plugins,Developing Plugins chapter>> to learn more.

/Section: 游릭 Structuring Builds
=================================


/docs/userguide/authoring-builds/tutorial/partr1_gradle_init.adoc
=================================================================

.. code-block::

   = Part 1: Initializing the Project
   
   Learn the basics of authoring Gradle by first creating a Java app using Gradle init.
   
   ****
   **In this section, you will:**
   
   - Initialize a Java project
   - Review the directory layout
   - Run a Java application
   - Produce a Build Scan
   - Bundle the application in an archive
   ****
   
   == Step 0. Before you Begin
   
   1. Make sure you have <<installation.adoc#installation,Gradle installed>>.
   
   2. Install link:https://www.jetbrains.com/idea/download/[IntelliJ IDEA].
   The Community Edition is a free version of IntelliJ IDEA.
   
   == Step 1. Initializing the Project
   
   Create a new directory called `authoring-tutorial` and `cd` into it:
   
   [source,text]
   ----
   $ mkdir authoring-tutorial
   ----
   [source,text]
   ----
   $ cd authoring-tutorial
   ----
   
   Run `gradle init` with parameters to generate a Java application:
   [source,text]
   ----
   $ gradle init --use-defaults --type java-application
   ----
   
   NOTE: In this tutorial, Kotlin DSL is used to build a simple Java project (as it is the default DSL starting in Gradle 8.2). All examples are macOS based.
   
   == Step 2. Understanding the Directory layout
   
   The *project root directory* contains all source files from your project.
   
   When you are done with Gradle `init`, the directory should look as follows:
   
   ----
   .
   較럭較 gradle                              // <1>
   較   較덕較 wrapper
   較럭較 gradlew                             // <2>
   較럭較 gradlew.bat                         // <2>
   較럭較 settings.gradle.kts                 // <3>
   較덕較 app
       較럭較 build.gradle.kts                // <4>
       較덕較 src
           較럭較 main
           較   較덕較 java                    // <5>
           較       較덕較 demo
           較           較덕較 App.java
           較덕較 test
               較덕較 java                    // <6>
                   較덕較 demo
                       較덕較 AppTest.java
   ----
   <1> Generated folder for wrapper files
   <2> Gradle wrapper start scripts
   <3> Settings file to define build name and subprojects
   <4> Build script for `app` subproject
   <5> Default Java source folder for `app` subproject
   <6> Default Java test source folder for `app` subproject
   
   The `authoring-tutorial` folder is the *root project directory*.
   Inside the root project directory are one or more subprojects, build scripts, and the Gradle wrapper.
   
   While the Gradle Wrapper is local to the root project, the Gradle executable is found in the `GRADLE_USER_HOME`.
   
   The `GRADLE_USER_HOME`, which defaults to `USER_HOME/.gradle`, is also where Gradle stores its global configuration properties, initialization scripts, caches, log files and more.
   
   == Step 3. Review the Gradle Files
   
   The `settings.gradle.kts` file has two interesting lines:
   
   .settings.gradle.kts
   [source, kotlin]
   ----
   rootProject.name = "authoring-tutorial"
   include("app")
   ----
   
   - `rootProject.name` assigns a name to the build, overriding the default behavior of naming the build after its directory name.
   - `include("app")` defines that the build consists of one subproject called `app` that contains its own source code and build logic.
   
   More subprojects can be added by additional `include()` statements.
   
   Our build contains one subproject called `app` representing the Java application we are building.
   It is configured in the `app/build.gradle(.kts)` file:
   
   .build.gradle.kts
   [source, kotlin]
   ----
   plugins {
       id("application")                                               // <1>
   }
   
   repositories {
       mavenCentral()                                                  // <2>
   }
   
   dependencies {
       testImplementation("org.junit.jupiter:junit-jupiter:5.9.3")     // <3>
       testRuntimeOnly("org.junit.platform:junit-platform-launcher")
       implementation("com.google.guava:guava:32.1.1-jre")             // <4>
   }
   
   java {
       toolchain {
           languageVersion = JavaLanguageVersion.of(11)                // <5>
       }
   }
   
   application {
       mainClass = "org.example.App"                                   // <6>
   }
   
   tasks.named<Test>("test") {
       useJUnitPlatform()                                              // <7>
   }
   ----
   <1> Apply the application plugin to add support for building a CLI application in Java.
   <2> Use Maven Central for resolving dependencies.
   <3> Use JUnit Jupiter for testing.
   <4> This dependency is used by the application.
   <5> Define the toolchain version.
   <6> Define the main class for the application.
   <7> Use JUnit Platform for unit tests.
   
   The build script in the `app` subproject directory declares the dependencies the `app` code will need to be assembled and tested.
   
   == Step 4. Review the Code
   
   The file `app/src/main/java/authoring/tutorial/App.java` contains the main class of the project:
   
   .App.java
   [source, java]
   ----
   package authoring.tutorial;
   
   public class App {
       public String getGreeting() {
           return "Hello World!";
       }
   
       public static void main(String[] args) {
           System.out.println(new App().getGreeting());
       }
   }
   ----
   
   The code prints out a simple "Hello World" greeting to the screen.
   
   A test class is available at `app/src/test/java/authoring/tutorial/AppTest.java`:
   
   .AppTest.java
   [source, java]
   ----
   package authoring.tutorial;
   
   import org.junit.jupiter.api.Test;
   import static org.junit.jupiter.api.Assertions.*;
   
   class AppTest {
       @Test void appHasAGreeting() {
           App classUnderTest = new App();
           assertNotNull(classUnderTest.getGreeting(), "app should have a greeting");
       }
   }
   ----
   
   The generated test class has a single _JUnit Jupiter_ test.
   The test instantiates the `App` class, invokes a method on it, and checks that it returns the expected value.
   
   == Step 5. Run the App
   
   The Application plugin, which was automatically added by `gradle init`, facilitates creating an executable JVM application:
   
   [source, kotlin]
   ----
   plugins {
       id("application")
   }
   ----
   
   Applying the Application plugin implicitly applies the Java plugin and adds tasks like `assemble`, `build`, and `run` to our project.
   
   Thanks to the `application` plugin, you can run the application directly from the command line.
   The `run` task tells Gradle to execute the `main` method in the class assigned to the `mainClass` property.
   
   [source,text]
   ----
   $ ./gradlew run
   
   > Task :app:run
   Hello World!
   
   BUILD SUCCESSFUL in 998ms
   2 actionable tasks: 2 executed
   ----
   
   == Step 6. Bundle the App
   
   The `application` plugin packages the application, with all its dependencies, for you.
   The archive will also contain a script to start the application with a single command.
   
   Run `./gradlew build`:
   
   [source,text]
   ----
   $ ./gradlew build
   
   > Task :app:compileJava
   > Task :app:processResources NO-SOURCE
   > Task :app:classes
   > Task :app:jar
   > Task :app:startScripts
   > Task :app:distTar
   > Task :app:distZip
   > Task :app:assemble
   > Task :app:compileTestJava
   > Task :app:processTestResources NO-SOURCE
   > Task :app:testClasses
   > Task :app:test
   > Task :app:check
   > Task :app:build
   
   BUILD SUCCESSFUL in 5s
   ----
   
   If you run a full build as shown above, Gradle will have produced the archive in two formats: `app/build/distributions/app.tar` and `app/build/distributions/app.zip`.
   
   == Step 6. Publish a Build Scan
   
   The best way to learn more about what your build is doing behind the scenes is to publish a link:https://scans.gradle.com[Build Scan].
   To do so, run the `build` task again with the `--scan` flag.
   
   [source]
   ----
   $ ./gradlew build --scan
   > Task :app:compileJava UP-TO-DATE
   > Task :app:processResources NO-SOURCE
   > Task :app:classes UP-TO-DATE
   > Task :app:jar UP-TO-DATE
   > Task :app:startScripts UP-TO-DATE
   > Task :app:distTar UP-TO-DATE
   > Task :app:distZip UP-TO-DATE
   > Task :app:assemble UP-TO-DATE
   > Task :app:compileTestJava UP-TO-DATE
   > Task :app:processTestResources NO-SOURCE
   > Task :app:testClasses UP-TO-DATE
   > Task :app:test UP-TO-DATE
   > Task :app:check UP-TO-DATE
   > Task :app:build UP-TO-DATE
   
   BUILD SUCCESSFUL in 1s
   7 actionable tasks: 7 up-to-date
   Resolving local hostname is slow, see https://gradle.com/help/gradle-slow-host-name
   
   Publishing a build scan to scans.gradle.com requires accepting the Gradle Terms of Service defined at https://gradle.com/terms-of-service. Do you accept these terms? [yes, no] yes
   
   Gradle Terms of Service accepted.
   
   Publishing build scan...
   https://gradle.com/s/7ee5saas3seo2
   ----
   
   Click the link and explore which tasks were executed, which dependencies were downloaded, and many more details:
   
   image::build-scan-3.png[]
   
   [.text-right]
   **Next Step:** <<partr2_build_lifecycle#partr2_build_lifecycle,The Build Lifecycle>> >>

/docs/userguide/authoring-builds/tutorial/partr2_build_lifecycle.adoc
=====================================================================

.. code-block::

   = Part 2: The Build Lifecycle
   
   Learn about the Gradle build lifecycle and what each phase represents.
   
   ****
   **In this section, you will:**
   
   - Understand the Build Lifecycle
   - Register and configure two tasks
   - Run the task to view the phases in action
   ****
   
   == Step 0. Before you Begin
   
   1. You initialized your Java app in <<partr1_gradle_init.adoc#part1_begin,part 1>>.
   
   == Step 1. Understanding the Build Lifecycle
   
   A Gradle build has three distinct phases:
   
   Phase 1 - Initialization  :: During the initialization phase, Gradle determines which projects will take part in the build, and creates a `Project` instance for each project.
   
   Phase 2 - Configuration  :: During the configuration phase, the `Project` objects are configured using the build scripts of all projects in the build. Gradle determines the set of tasks to be executed.
   
   Phase 3 - Execution  :: During the execution phase, Gradle executes each of the selected tasks.
   
   When Gradle is invoked to execute a task, the lifecycle begins.
   Let's see it in action.
   
   image::gradle-build-lifecycle.png[]
   
   == Step 2. Update the Settings File
   
   Add the following line to the top of the Settings file:
   
   .settings.gradle.kts
   [source, kotlin]
   ----
   println("SETTINGS FILE: This is executed during the initialization phase")
   ----
   
   == Step 3. Update the Build Script
   
   Add the following lines to the bottom of the Build script:
   
   .app/build.gradle.kts
   [source, kotlin]
   ----
   println("BUILD SCRIPT: This is executed during the configuration phase")
   
   tasks.register("task1"){
       println("REGISTER TASK1: This is executed during the configuration phase")
   }
   
   tasks.register("task2"){
       println("REGISTER TASK2: This is executed during the configuration phase")
   }
   
   tasks.named("task1"){
       println("NAMED TASK1: This is executed during the configuration phase")
       doFirst {
           println("NAMED TASK1 - doFirst: This is executed during the execution phase")
       }
       doLast {
           println("NAMED TASK1 - doLast: This is executed during the execution phase")
       }
   }
   
   tasks.named("task2"){
       println("NAMED TASK2: This is executed during the configuration phase")
       doFirst {
           println("NAMED TASK2 - doFirst: This is executed during the execution phase")
       }
       doLast {
           println("NAMED TASK2 - doLast: This is executed during the execution phase")
       }
   }
   ----
   
   == Step 4. Run a Gradle Task
   
   Run the `task1` task that you registered and configured in Step 3:
   
   [source,text]
   ----
   $ ./gradlew task1
   
   SETTINGS FILE: This is executed during the initialization phase     //<1>
   
   > Configure project :app
   BUILD SCRIPT: This is executed during the configuration phase       //<2>
   REGISTER TASK1: This is executed during the configuration phase     //<2>
   NAMED TASK1: This is executed during the configuration phase        //<2>
   
   > Task :app:task1
   NAMED TASK1 - doFirst: This is executed during the execution phase  //<3>
   NAMED TASK1 - doLast: This is executed during the execution phase   //<3>
   
   BUILD SUCCESSFUL in 25s
   5 actionable tasks: 3 executed, 2 up-to-date
   ----
   <1> *Initialization*: Gradle executes `settings.gradle.kts` to determine the projects to be built and creates a `Project` object for each one.
   <2> *Configuration*: Gradle configures each project by executing the `build.gradle.kts` files. It resolves dependencies and creates a dependency graph of all the available tasks.
   <3> *Execution*: Gradle executes the tasks passed on the command line and any prerequisite tasks.
   
   It is important to note that while `task1` was configured and executed, `task2` was not.
   This is called _task configuration avoidance_ and prevents unnecessary work.
   
   Task configuration avoidance is when Gradle avoids configuring `task2` when `task1` was called and `task1` does NOT depend. on `task2`.
   
   [.text-right]
   **Next Step:** <<partr3_multi_project_builds#partr3_multi_project_builds,Multi-Project Builds>> >>

/docs/userguide/authoring-builds/tutorial/partr3_multi_project_builds.adoc
==========================================================================

.. code-block::

   = Part 3: Multi-Project Builds
   
   Learn the basics of structuring Gradle projects using subprojects and composite builds.
   
   ****
   **In this section, you will:**
   
   - Understand Multi-Project builds
   - Understand Composite Builds
   - Add a subproject to your Build
   - Add a build to your Build
   ****
   
   == Step 0. Before you Begin
   
   1. You initialized your Java app in <<partr1_gradle_init.adoc#part1_begin,part 1>>.
   2. You understand the Gradle Build Lifecycle from <<partr2_build_lifecycle.adoc#part2_begin,part 2>>.
   
   == Step 1. About Multi-Project Builds
   
   Typically, builds contain multiple projects, such as shared libraries or separate applications that will be deployed in your ecosystem.
   
   In Gradle, a multi-project build consists of:
   
   - `settings.gradle(.kts)` file representing your Gradle build including required subprojects e.g. include("app", "model", "service")
   - `build.gradle(.kts)` and source code for each subproject in corresponding subdirectories
   
   Our build currently consists of a root project called `authoring-tutorial`, which has a single `app` subproject:
   
   [source,text]
   ----
   .                           // <1>
   較럭較 app                     // <2>
   較   ...                     // <3>
   較   較덕較 build.gradle.kts    // <4>
   較덕較 settings.gradle.kts     // <5>
   ----
   <1> The `authoring-tutorial` root project
   <2> The `app` subproject
   <3> The `app` source code
   <4> The `app` build script
   <5> The optional settings file
   
   == Step 2. Add another Subproject to the Build
   Imagine that our project is growing and requires a custom library to function.
   
   Let's create this imaginary `lib`.
   First, create a `lib` folder:
   
   [source,text]
   ----
   mkdir lib
   ----
   
   [source,text]
   ----
   cd lib
   ----
   
   Create a file called `build.gradle.kts` and add the following lines to it:
   
   .lib/build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("java")
   }
   
   repositories {
       // Use Maven Central for resolving dependencies.
       mavenCentral()
   }
   
   dependencies {
       testImplementation("org.junit.jupiter:junit-jupiter:5.9.3")
       testRuntimeOnly("org.junit.platform:junit-platform-launcher")
       implementation("com.google.guava:guava:32.1.1-jre")
   }
   
   tasks.named<Test>("test") {
       // Use JUnit Platform for unit tests.
       useJUnitPlatform()
   }
   
   tasks.register("task3"){
       println("REGISTER TASK3: This is executed during the configuration phase")
   }
   
   tasks.named("task3"){
       println("NAMED TASK3: This is executed during the configuration phase")
       doFirst {
           println("NAMED TASK3 - doFirst: This is executed during the execution phase")
       }
       doLast {
           println("NAMED TASK3 - doLast: This is executed during the execution phase")
       }
   }
   ----
   
   Your project should look like this:
   
   ----
   .
   較럭較 app
   較   ...
   較   較덕較 build.gradle.kts
   較럭較 lib
   較   較덕較 build.gradle.kts
   較덕較 settings.gradle.kts
   ----
   
   Let's add some code to the `lib` subproject.
   Create a new directory:
   
   [source,text]
   ----
   mkdir -p lib/src/main/java/com/gradle
   ----
   
   Create a Java class called `CustomLib` in a file called `CustomLib.java` with the following source code:
   
   .lib/src/main/java/com/gradle/CustomLib.java
   [source,java]
   ----
   package com.gradle;
   
   public class CustomLib {
       public static String identifier = "I'm a String from a lib.";
   }
   ----
   
   The project should now have the following file and directory structure:
   
   ----
   .
   較럭較 app
   較   較럭較 build.gradle.kts
   較   較덕較 src
   較       較덕較 main
   較           較덕較 java
   較               較덕較 authoring
   較                   較덕較 tutorial
   較                       較덕較 App.java
   較럭較 lib
   較   較럭較 build.gradle.kts
   較   較덕較 src
   較       較덕較 main
   較           較덕較 java
   較               較덕較 com
   較                   較덕較 gradle
   較                       較덕較 CustomLib.java
   較덕較 settings.gradle.kts
   ----
   
   However, the `lib` subproject does not belong to the build, and you won't be able to execute `task3`, until it is added to the `settings.gradle.kts` file.
   
   To add `lib` to the build, update the `settings.gradle.kts` file in the root accordingly:
   
   .settings.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("org.gradle.toolchains.foojay-resolver-convention") version "0.8.0"
   }
   
   rootProject.name = "authoring-tutorial"
   
   include("app")
   include("lib") // Add lib to the build
   ----
   
   Let's add the `lib` subproject as an `app` dependency in `app/build.gradle.kts`:
   
   .app/build.gradle.kts
   [source,kotlin]
   ----
   dependencies {
       implementation(project(":lib")) // Add lib as an app dependency
   }
   ----
   
   Update the `app` source code so that it imports the `lib`:
   
   .app/src/main/java/authoring/tutorial/App.java
   [source,java]
   ----
   package authoring.tutorial;
   
   import com.gradle.CustomLib;
   
   public class App {
       public String getGreeting() {
           return "CustomLib identifier is: " + CustomLib.identifier;
       }
   
       public static void main(String[] args) {
           System.out.println(new App().getGreeting());
       }
   }
   ----
   
   Finally, let's run the `app` with the command `./gradlew run`:
   
   [source]
   ----
   $ ./gradlew run
   
   > Configure project :app
   
   > Task :app:processResources NO-SOURCE
   > Task :lib:compileJava
   > Task :lib:processResources NO-SOURCE
   > Task :lib:classes
   > Task :lib:jar
   > Task :app:compileJava
   > Task :app:classes
   
   > Task :app:run
   CustomLib identifier is: I'm a String from a lib.
   
   BUILD SUCCESSFUL in 11s
   8 actionable tasks: 6 executed, 2 up-to-date
   ----
   
   Our build for the root project `authoring-tutorial` now includes two subprojects, `app` and `lib`.
   `app` depends on `lib`.
   You can build `lib` independent of `app`.
   However, to build `app`, Gradle will also build `lib`.
   
   == Step 3. Understand Composite Builds
   A composite build is simply a build that includes other builds.
   
   Composite builds allow you to:
   
   - Extract your build logic from your project build (and re-use it among subprojects)
   - Combine builds that are usually developed independently (such as a plugin and an application)
   - Decompose a large build into smaller, more isolated chunks
   
   == Step 4. Add build to the Build
   
   Let's add a plugin to our build.
   First, create a new directory called `license-plugin` in the `gradle` directory:
   
   [source]
   ----
   cd gradle
   ----
   
   [source]
   ----
   mkdir license-plugin
   ----
   
   [source]
   ----
   cd license-plugin
   ----
   
   Once in the `gradle/license-plugin` directory, run `gradle init`.
   Make sure that you select the `Gradle plugin` project as well as the other options for the `init` task below:
   
   [source]
   ----
   $ gradle init --use-defaults --type kotlin-gradle-plugin --project-name license
   ----
   
   Your project should look like this:
   
   ----
   .
   較럭較 app
   較   ...
   較   較덕較 build.gradle.kts
   較럭較 lib
   較   ...
   較   較덕較 build.gradle.kts
   較럭較 gradle
   較    較덕較 license-plugin
   較        較럭較 settings.gradle.kts
   較        較덕較 plugin
   較            較럭較 build.gradle.kts
   較            較럭較 src
   較            較   較럭較 main
   較            較   較덕較 kotlin
   較            較       較덕較 com.gradle
   較            較           較덕較 LicensePlugin.kt
   較            較덕較 test
   較                較덕較 kotlin
   較                    較덕較 com.gradle
   較                        較덕較 LicencePluginTest.kt
   較덕較 settings.gradle.kts
   ----
   
   Take the time to look at the `LicensePlugin.kt` code and the `gradle/license-plugin/settings.gradle.kts` file.
   It's important to note that this is an entirely separate build with its own Settings file and Build script:
   
   .gradle/license-plugin/settings.gradle.kts
   [source,kotlin]
   ----
   rootProject.name = "license"
   include("plugin")
   ----
   
   To add our `license-plugin` build to the root project, update the root `settings.gradle.kts` file accordingly:
   
   .settings.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("org.gradle.toolchains.foojay-resolver-convention") version "0.8.0"
   }
   
   rootProject.name = "authoring-tutorial"
   
   include("app")
   include("subproject")
   
   includeBuild("gradle/license-plugin") // Add the new build
   ----
   
   You can view the structure of the root project by running `./gradlew projects` in the root folder `authoring-tutorial`:
   
   [source]
   ----
   $ ./gradlew projects
   
   ------------------------------------------------------------
   Root project 'authoring-tutorial'
   ------------------------------------------------------------
   
   Root project 'authoring-tutorial'
   +--- Project ':app'
   \--- Project ':lib'
   
   Included builds
   \--- Included build ':license-plugin'
   ----
   
   Our build for the root project `authoring-tutorial` now includes two subprojects, `app` and `lib`, and another build, `license-plugin`.
   
   When in the project root, running:
   
   - `./gradlew build` - Builds `app` and `lib`
   - `./gradlew :app:build` - Builds `app` and `lib`
   - `./gradlew :lib:build` - Builds `lib` only
   - `./gradlew :license-plugin:plugin:build` - Builds `license-plugin` only
   
   There are many ways to design a project's architecture with Gradle.
   
   Multi-project builds are great for organizing projects with many modules such as `mobile-app`, `web-app`, `api`, `lib`, and `documentation` that have dependencies between them.
   
   Composite (include) builds are great for separating build logic (i.e., convention plugins) or testing systems (i.e., patching a library)
   
   [.text-right]
   **Next Step:** <<partr4_settings_file#partr4_settings_file,Settings File>> >>

/docs/userguide/authoring-builds/tutorial/partr4_settings_file.adoc
===================================================================

.. code-block::

   = Part 4: Writing the Settings File
   
   Learn the basics of authoring Gradle by developing the Settings File.
   
   ****
   **In this section, you will:**
   
   - Understand the Settings object
   - Understand the Settings file
   - Understand Gradle scripting
   ****
   
   == Step 0. Before you Begin
   
   1. You initialized your Java app in <<partr1_gradle_init.adoc#part1_begin,part 1>>.
   2. You understand the Gradle Build Lifecycle from <<partr2_build_lifecycle.adoc#part2_begin,part 2>>.
   3. You added a subproject and a separate Build in <<partr3_multi_project_builds#part3_begin, part3>>.
   
   == Step 1. Gradle scripts
   
   Build scripts and setting files are code.
   They are written in Kotlin or Groovy.
   
   You use the link:{kotlinDslPath}[Kotlin DSL], link:{groovyDslPath}#[Groovy DSL] and link:{javadocPath}#[Gradle APIs] to write the scripts.
   
   The methods that can be used within a Gradle script primarily include:
   
   - Gradle APIs - such as `getRootProject()` from the link:{javadocPath}#[Settings API]
   - Blocks defined in the DSL - such as the `plugins{}` block from link:{kotlinDslPath}/gradle/org.gradle.kotlin.dsl/-kotlin-settings-script/index.html[KotlinSettingsScript]
   - Extensions defined by Plugins - such as `implementation()` and `api()` provided by the `java` plugin when applied
   
   == Step 2. The `Settings` object
   
   The settings file is the entry point of every Gradle build.
   
   During the initialization phase, Gradle finds the settings file in your project root directory.
   
   When the settings file, `settings.gradle(.kts)`, is found, Gradle instantiates a link:{groovyDslPath}#[Settings] object.
   
   One of the purposes of the link:{groovyDslPath}#[Settings] object is to allow you to declare all the projects to be included in the build.
   
   You can use any of the methods and properties on the link:{groovyDslPath}#[Settings] interface directly in your settings file.
   
   For example:
   
   [source,kotlin]
   ----
    includeBuild("some-build")                         // Delegates to Settings.includeBuild()
    reportsDir = findProject("/myInternalProject")     // Delegates to Settings.findProject()
   ----
   
   == Step 3. The Settings file
   
   Let's break down the settings file in our project root directory:
   
   .settings.gradle.kts
   [source,kotlin]
   ----
   plugins {                                                                   // <1>
       id("org.gradle.toolchains.foojay-resolver-convention") version "0.4.0"  // <2>
   }
   
   rootProject.name = "authoring-tutorial"                                     // <3>
   
   include("app")                                                              // <4>
   include("lib")
   
   includeBuild("gradle/license-plugin")                                       // <5>
   ----
   <1> `plugins({})` method from link:{kotlinDslPath}/gradle/org.gradle.kotlin.dsl/-kotlin-settings-script/index.html[KotlinSettingsScript] in the Kotlin DSL
   <2> `id()` method from the link:{kotlinDslPath}/gradle/org.gradle.plugin.use/-plugin-dependencies-spec/index.html[PluginDependenciesSpec API]
   <3> `getRootProject()` method from the link:{kotlinDslPath}/gradle/org.gradle.api.initialization/-settings/index.html[Settings API]
   <4> `include()` method from the link:{kotlinDslPath}/gradle/org.gradle.api.initialization/-settings/index.html[Settings API]
   <5> `includeBuild()` method from the link:{kotlinDslPath}/gradle/org.gradle.api.initialization/-settings/index.html[Settings API]
   
   [.text-right]
   **Next Step:** <<partr5_build_scripts#partr5_build_scripts,Writing a Build Script>> >>

/docs/userguide/authoring-builds/tutorial/partr5_build_scripts.adoc
===================================================================

.. code-block::

   = Part 5: Writing a Build Script
   
   Learn the basics of authoring Gradle by developing the Build Script.
   
   ****
   **In this section, you will:**
   
   - Understand the Project object
   - Update the Build script
   - Update the Plugin
   - Apply the Plugin
   - Run a task from the Plugin
   ****
   
   == Step 0. Before you Begin
   
   1. You initialized your Java app in <<partr1_gradle_init.adoc#part1_begin,part 1>>.
   2. You understand the Gradle Build Lifecycle from <<partr2_build_lifecycle.adoc#part2_begin,part 2>>.
   3. You added a subproject and a separate Build in <<partr3_multi_project_builds#part3_begin, part3>>.
   4. You viewed a Settings file in <<partr4_settings_file.adoc#part4_begin,part 4>>.
   
   == Step 1. The `Project` object
   
   Build scripts invoke Gradle APIs to configure the build.
   
   During the configuration phase, Gradle finds the build script(s) in the root and subproject directories.
   
   When a build script, `build.gradle(.kts)`, is found, Gradle configures a link:{javadocPath}#[Project] object.
   
   The purpose of the link:{javadocPath}#[Project] object is to create a collection of link:{javadocPath}#[Task] objects, apply plugins, and retrieve dependencies.
   
   You can use any of the methods and properties on the link:{javadocPath}#[Project] interface directly in your script.
   
   For example:
   
   [source,kotlin]
   ----
    defaultTasks("some-task")      // Delegates to Project.defaultTasks()
    reportsDir = file("reports")   // Delegates to Project.file() and the Java Plugin
   ----
   
   == Step 2. The Build script
   
   Let's break down the build script for the plugin:
   
   .gradle/license-plugin/plugin/build.gradle.kts
   [source,kotlin]
   ----
   plugins {                                                             // <1>
       `java-gradle-plugin`                                              // <2>
       id("org.jetbrains.kotlin.jvm") version "1.9.0"                    // <3>
   }
   
   repositories {                                                        // <4>
       mavenCentral()                                                    // <5>
   }
   
   dependencies {                                                        // <6>
       testImplementation("org.jetbrains.kotlin:kotlin-test-junit5")     // <7>
       testRuntimeOnly("org.junit.platform:junit-platform-launcher")
   }
   
   gradlePlugin {                                                        // <8>
       val greeting by plugins.creating {                                // <9>
           id = "com.gradle.greeting"
           implementationClass = "com.gradle.LicensePlugin"
       }
   }
   
   val functionalTestSourceSet = sourceSets.create("functionalTest") {}  // <10>
   
   // Additional lines //
   
   val functionalTest by tasks.registering(Test::class) {
       testClassesDirs = functionalTestSourceSet.output.classesDirs
       classpath = functionalTestSourceSet.runtimeClasspath
       useJUnitPlatform()
   }
   
   // Additional lines //
   ----
   <1> Use the `plugins{}` block from link:{kotlinDslPath}/gradle/org.gradle.kotlin.dsl/-kotlin-settings-script/index.html[KotlinSettingsScript] in the Kotlin DSL
   <2> Apply the Java Gradle plugin development plugin to add support for developing Gradle plugins
   <3> Apply the Kotlin JVM plugin to add support for Kotlin
   <4> Use link:{kotlinDslPath}/gradle/org.gradle.api/-project/repositories.html[`Project.repositories()`] to configure the repositories for this project
   <5> Use link:https://repo.maven.apache.org/maven2/[Maven Central] for resolving dependencies
   <6> Use link:{kotlinDslPath}/gradle/org.gradle.api/-project/dependencies.html[`Project.dependencies()`] to configure the dependencies for this project
   <7> Use the Kotlin JUnit 5 integration
   <8> Use the `gradlePlugin{}` block from link:{kotlinDslPath}/gradle/org.gradle.plugin.devel/-gradle-plugin-development-extension/index.html[GradlePluginDevelopmentExtension] in the Kotlin DSL
   <9> Define the plugin `id` and `implementationClass`
   <10> Additional test configuration including tasks
   
   Plugins, which enhance your build capabilities, are included like this:
   
   [source,kotlin]
   ----
   plugins {
       id("java")                          // core plugin, no version required
       id("org.some.plugin") version "2.8" // community plugin, version required
   }
   ----
   
   The repositories section lets Gradle know where to pull dependencies from:
   
   [source,kotlin]
   ----
   repositories {
       mavenCentral()  // get dependencies from the Maven central repository
   }
   ----
   
   Dependencies are requirements for building your application or library:
   
   [source,kotlin]
   ----
   dependencies {
       implementation("org.apache.commons:commons-lang3:3.13.0")   // group: 'org.apache.commons', name: 'commons-lang3', version: '3.13.0'
   }
   ----
   
   In this example, `implementation()` means that the `commons-lang3` library must be added to the Java classpath.
   
   Every dependency declared for a Gradle project must apply to a scope.
   That is, the dependency is either needed at compile time, runtime, or both.
   This is called a configuration and the `implementation` configuration is used when the dependency is only needed in the runtime classpath.
   
   Configuration blocks (not to be confused with dependency configurations above) are typically further configuration required by an applied plugin:
   
   [source,kotlin]
   ----
   gradlePlugin {                                              // <8>
       val greeting by plugins.creating {                      // <9>
           id = "com.gradle.greeting"
           implementationClass = "com.gradle.LicensePlugin"
       }
   }
   ----
   
   When the `java-gradle-plugin` is applied, users must configure the plugin they are developing using the `gradlePlugin{}` configuration block.
   
   Tasks are units of work executed during your build.
   They can be defined by plugins or inline:
   
   [source,kotlin]
   ----
   val functionalTest by tasks.registering(Test::class) {
       testClassesDirs = functionalTestSourceSet.output.classesDirs
       classpath = functionalTestSourceSet.runtimeClasspath
       useJUnitPlatform()
   }
   
   tasks.named<Test>("test") {
       // Use JUnit Jupiter for unit tests.
       useJUnitPlatform()
   }
   ----
   
   == Step 3. Update the Build scripts
   
   Build init creates a "hello world" plugin when creating a Gradle plugin project:
   
   .gradle/license-plugin/plugin/build.gradle.kts
   [source,kotlin]
   ----
   gradlePlugin {
       val greeting by plugins.creating {
           id = "com.gradle.greeting"
           implementationClass = "com.gradle.LicensePlugin"
       }
   }
   
   ----
   
   Over the following sections, we will write a plugin that automatically generates license headers for source code files.
   Let's update the build script with the proper name for our new `license` plugin:
   
   .gradle/license-plugin/plugin/build.gradle.kts
   [source,kotlin]
   ----
   gradlePlugin {
       val license by plugins.creating {   // Update name to license
           id = "com.gradle.license"       // Update id to com.gradle.license
           implementationClass = "com.gradle.LicensePlugin"
       }
   }
   ----
   
   == Step 3. Apply the Plugin
   
   Let's apply our `license` plugin to the `app` subproject:
   
   .app/build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       application
       id("com.gradle.license")    // Apply the license plugin
   }
   ----
   
   == Step 4. View Plugin Task
   
   The source code for the `license` plugin is also the "hello world" sample created by Gradle init:
   
   .gradle/license-plugin/plugin/src/main/kotlin/com/gradle/LicensePlugin.kt
   [source,kotlin]
   ----
   class LicensePlugin: Plugin<Project> {
       override fun apply(project: Project) {                          // Apply plugin
           project.tasks.register("greeting") { task ->                // Register a task
               task.doLast {
                   println("Hello from plugin 'com.gradle.greeting'")  // Hello world printout
               }
           }
       }
   }
   ----
   
   As we can see, the `license` plugin, when applied, contains a `greeting` task with a simple print statement.
   
   == Step 5. View Plugin Tasks
   
   When the `license` plugin is applied to the `app` project, the `greeting` task becomes available:
   
   To view the task in the root directory, run:
   
   [source]
   ----
   $ ./gradlew tasks --all
   
   ------------------------------------------------------------
   Tasks runnable from root project 'authoring-tutorial'
   ------------------------------------------------------------
   
   ...
   
   Other tasks
   -----------
   app:greeting
   app:task1
   app:task2
   lib:task3
   ----
   
   Finally, run the `greeting` task using `./gradlew greeting` or:
   
   [source]
   ----
   $ ./gradlew :app:greeting
   
   > Task :app:greeting
   Hello from plugin 'com.gradle.greeting'
   ----
   
   [.text-right]
   **Next Step:** <<partr6_writing_tasks#partr6_writing_tasks,Writing Tasks>> >>

/docs/userguide/authoring-builds/tutorial/partr6_writing_tasks.adoc
===================================================================

.. code-block::

   = Part 6: Writing Tasks
   
   Learn the basics of authoring Gradle tasks by creating a simple one in your Build script.
   
   ****
   **In this section, you will:**
   
   - Understand Tasks
   - Create a custom Task for the Plugin
   ****
   
   == Step 0. Before you Begin
   
   1. You initialized your Java app in <<partr1_gradle_init.adoc#part1_begin,part 1>>.
   2. You understand the Gradle Build Lifecycle from <<partr2_build_lifecycle.adoc#part2_begin,part 2>>.
   3. You added a subproject and a separate Build in <<partr3_multi_project_builds#part3_begin, part3>>.
   4. You viewed a Settings file in <<partr4_settings_file.adoc#part4_begin,part 4>>.
   5. You authored a Build script in <<partr5_build_scripts.adoc#part5_begin,part 5>>.
   
   == Step 1. Understand Tasks
   A Task is an executable piece of code that contains sequences of actions.
   
   Actions are added to a Task via the `doFirst{}` and `doLast{}` closures.
   
   A Task can depend on other tasks.
   
   == Step 2. Register and Configure Tasks
   
   Early on in the tutorial, we registered and configured `task1` in the `app` build script:
   
   .app/build.gradle.kts
   [source,kotlin]
   ----
   tasks.register("task1"){
       println("REGISTER TASK1: This is executed during the configuration phase")
   }
   
   tasks.named("task1"){
       println("NAMED TASK1: This is executed during the configuration phase")
       doFirst {
           println("NAMED TASK1 - doFirst: This is executed during the execution phase")
       }
       doLast {
           println("NAMED TASK1 - doLast: This is executed during the execution phase")
       }
   }
   ----
   
   You can use the link:{kotlinDslPath}/gradle/org.gradle.api.tasks/-task-container/index.html[register()] method to create new tasks.
   
   You can use the link:{kotlinDslPath}/gradle/org.gradle.api.tasks/-task-collection/index.html[named()] method to configure existing tasks.
   
   == Step 3. Create a custom Task
   
   To create a custom task, you must subclass link:{kotlinDslPath}/gradle/org.gradle.api/-default-task/index.html[`DefaultTask`].
   
   Create a custom class called `LicenseTask` in `gradle/license-plugin/plugin/src/main/kotlin/com/gradle/LicensePlugin.kt` with the code below:
   
   .gradle/license-plugin/plugin/src/main/kotlin/com/gradle/LicensePlugin.kt
   [source,kotlin]
   ----
   package com.gradle
   
   import org.gradle.api.Project
   import org.gradle.api.Plugin
   import org.gradle.api.DefaultTask
   import org.gradle.api.tasks.Input
   import org.gradle.api.tasks.TaskAction
   import java.io.File
   import java.io.InputStream
   import java.nio.charset.Charset
   
   abstract class LicenseTask : DefaultTask() {
       @Input
       val fileName = project.rootDir.toString() + "/license.txt"
   
       @TaskAction
       fun action() {
           // Read the license text
           val licenseText = File(fileName).readText()
           // Walk the directories looking for java or kt files
           File(project.rootDir.toString()).walk().forEach {
               if (it.extension == "java") { // || it.extension == "kt") {
                   // Read the source code
                   var ins: InputStream = it.inputStream()
                   var content = ins.readBytes().toString(Charset.defaultCharset())
                   // Write the license and the source code to the file
                   it.writeText(licenseText + content)
               }
           }
       }
   }
   ----
   
   The `LicenseTask` class encapsulates the task action logic and declares any inputs and outputs the task expects.
   
   The task action is annotated with `@TaskAction`.
   Inside, the logic first finds a file called "license.txt".
   This file contains text for an Apache license:
   
   ----
   /*
   * Licensed under the Apache License
   */
   ----
   
   The task then looks for files with the extension `.java` and `.kts` and adds a license header.
   
   The task has a single input, the license file name, annotated with `@Input`.
   
   Gradle uses the `@Input` annotation to determine if the task needs to run.
   If the task has not run before or if the input value has changed since the previous execution, then Gradle will execute the task.
   
   While a custom class has been created, it is not yet added to the `LicensePlugin`.
   Running `LicenseTask` is not currently possible.
   
   [.text-right]
   **Next Step:** <<partr7_writing_plugins#partr7_writing_plugins,Writing Plugins>> >>

/docs/userguide/authoring-builds/tutorial/partr7_writing_plugins.adoc
=====================================================================

.. code-block::

   = Part 7: Writing Plugins
   
   Learn the basics of writing and applying Gradle plugins.
   
   ****
   **In this section, you will:**
   
   - Add a custom task to the Plugin
   - Apply the Plugin to a subproject
   - Use the Plugin
   ****
   
   == Step 0. Before you Begin
   
   1. You initialized your Java app in <<partr1_gradle_init.adoc#part1_begin,part 1>>.
   2. You understand the Gradle Build Lifecycle from <<partr2_build_lifecycle.adoc#part2_begin,part 2>>.
   3. You added a subproject and a separate Build in <<partr3_multi_project_builds#part3_begin, part3>>.
   4. You viewed a Settings file in <<partr4_settings_file.adoc#part4_begin,part 4>>.
   5. You authored a Build script in <<partr5_build_scripts.adoc#part5_begin,part 5>>.
   6. You authored a Task in <<partr6_writing_tasks.adoc#part6_begin,part 6>>.
   
   == Step 1. Develop the Plugin
   
   Let's tie our custom `LicenseTask` to our plugin.
   
   Update the `LicensePlugin` with the code below:
   
   .gradle/license-plugin/plugin/src/main/kotlin/com/gradle/LicensePlugin.kt
   [source,kotlin]
   ----
   class LicensePlugin: Plugin<Project> {
       override fun apply(project: Project) {
           project.tasks.register("license", LicenseTask::class.java) { task ->
               task.description = "add a license header to source code"   // Add description
               task.group = "from license plugin"                          // Add group
           }
       }
   }
   ----
   
   == Step 2. Add a license.txt file
   
   Add a file called `license.txt` to the root directory of the project and add the following text to it:
   
   .license.txt
   [source,text]
   ----
   /*
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
   ----
   
   == Step 3. Apply the Plugin
   
   Apply the plugin to the `app` subproject:
   
   .app/build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       application
       id("com.gradle.license") // Apply custom plugin
   }
   ----
   
   Make sure the plugin is correctly applied by listing the available tasks in the `app` subproject:
   
   [source,text]
   ----
   $ ./gradlew :app:tasks
   
   ------------------------------------------------------------
   Tasks runnable from project ':app'
   ------------------------------------------------------------
   
   ...
   
   From license plugin tasks
   -------------------------
   license - add a license header to source code
   ----
   
   == Step 4. Run the custom Task
   
   Finally, it's time to run the new task.
   
   First, let's inspect some source code:
   
   .app/src/main/java/authoring/tutorial/App.java
   [source,java]
   ----
   package authoring.tutorial;
   
   import com.gradle.CustomLib;
   
   public class App {
       public String getGreeting() {
           return "CustomLib identifier is: " + CustomLib.identifier;
       }
   
       public static void main(String[] args) {
           System.out.println(new App().getGreeting());
       }
   }
   ----
   
   Next, let's run the task with `./gradlew :app:license`:
   
   [source,text]
   ----
   $ ./gradlew :app:license
   
   > Task :license-plugin:plugin:compileKotlin UP-TO-DATE
   > Task :license-plugin:plugin:compileJava NO-SOURCE
   > Task :license-plugin:plugin:pluginDescriptors UP-TO-DATE
   > Task :license-plugin:plugin:processResources UP-TO-DATE
   > Task :license-plugin:plugin:classes UP-TO-DATE
   > Task :license-plugin:plugin:jar UP-TO-DATE
   
   > Configure project :app
   
   > Task :app:license
   
   BUILD SUCCESSFUL in 410ms
   5 actionable tasks: 1 executed, 4 up-to-date
   ----
   
   Now inspect the same source code, which should include a license header:
   
   .app/src/main/java/authoring/tutorial/App.java
   [source,java]
   ----
   /*
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
   package authoring.tutorial;
   
   import com.gradle.CustomLib;
   
   public class App {
       public String getGreeting() {
           return "CustomLib identifier is: " + CustomLib.identifier;
       }
   
       public static void main(String[] args) {
           System.out.println(new App().getGreeting());
       }
   }
   ----

/Section: 游릭 Structuring Builds
=================================


/docs/userguide/authoring-builds/structuring/multi_project_builds.adoc
======================================================================

.. code-block::

   = Structuring Projects with Gradle
   
   It is important to structure your Gradle project to optimize build performance.
   A multi-project build is the standard in Gradle.
   
   image::structuring-builds-1.png[]
   
   A multi-project build consists of one root project and one or more subprojects.
   Gradle can build the root project and any number of the subprojects in a single execution.
   
   == Project locations
   
   Multi-project builds contain a single root project in a directory that Gradle views as the root path: `.`.
   
   Subprojects are located physically under the root path: `./subproject`.
   
   A subproject has <<intro_multi_project_builds#sec:project_path,a path>>, which denotes the position of that subproject in the multi-project build.
   In most cases, the project path is consistent with its location in the file system.
   
   The project structure is created in the `settings.gradle(.kts)` file.
   The settings file must be present in the root directory.
   
   == A simple multi-project build
   
   Let's look at a _basic_ multi-project build example that contains a root project and a single subproject.
   
   The root project is called `basic-multiproject`, located somewhere on your machine.
   From Gradle's perspective, the root is the top-level directory `.`.
   
   The project contains a single subproject called `./app`:
   
   [.multi-language-sample]
   =====
   [source, kotlin]
   ----
   .
   較럭較 app
   較   ...
   較   較덕較 build.gradle.kts
   較덕較 settings.gradle.kts
   ----
   =====
   [.multi-language-sample]
   =====
   [source, groovy]
   ----
   .
   較럭較 app
   較   ...
   較   較덕較 build.gradle
   較덕較 settings.gradle
   ----
   =====
   
   This is the recommended project structure for starting any Gradle project.
   The <<build_init_plugin#build_init_plugin,build init plugin>> also generates skeleton projects that follow this structure - a root project with a single subproject:
   
   The `settings.gradle(.kts)` file describes the project structure to Gradle:
   
   ====
   include::sample[dir="snippets/multiproject/basic-multiproject/kotlin",files="settings.gradle.kts[]"]
   include::sample[dir="snippets/multiproject/basic-multiproject/groovy",files="settings.gradle[]"]
   ====
   
   In this case, Gradle will look for a build file for the `app` subproject in the `./app` directory.
   
   You can view the structure of a multi-project build by running the `projects` command:
   
   ----
   $ ./gradlew -q projects
   include::{snippetsPath}/multiproject/basic-multiproject/tests/projects.out[]
   ----
   
   In this example, the `app` subproject is a Java application that applies the <<application_plugin#application_plugin,application plugin>> and configures the main class.
   The application prints `Hello World` to the console:
   
   ====
   include::sample[dir="snippets/multiproject/basic-multiproject/kotlin",files="app/build.gradle.kts[]"]
   include::sample[dir="snippets/multiproject/basic-multiproject/groovy",files="app/build.gradle[]"]
   .app/src/main/java/com/example/Hello.java
   [source, java]
   ----
   include::{snippetsPath}/multiproject/basic-multiproject/groovy/app/src/main/java/com/example/Hello.java[]
   ----
   ====
   
   You can run the application by executing the `run` task from the <<application_plugin#application_plugin,application plugin>> in the project root:
   ----
   $ ./gradlew -q run
   include::{snippetsPath}/multiproject/basic-multiproject/tests/run.out[]
   ----
   
   == Adding a subproject
   
   In the settings file, you can use the `include` method to add another subproject to the root project:
   
   ====
   include::sample[dir="snippets/multiproject/standardLayouts/kotlin",files="settings.gradle.kts[tags=hierarchical-layout]"]
   include::sample[dir="snippets/multiproject/standardLayouts/groovy",files="settings.gradle[tags=hierarchical-layout]"]
   ====
   
   The `include` method takes <<intro_multi_project_builds#sec:project_path,project paths>> as arguments.
   The project path is assumed to be equal to the relative physical file system path.
   For example, a path `services:api` is mapped by default to a folder `./services/api` (relative to the project root `.`).
   
   More examples of how to work with the project path can be found in the DSL documentation of link:{groovyDslPath}#[])++[Settings.include(java.lang.String[\])].
   
   Let's add another subproject called `lib` to the previously created project.
   
   All we need to do is add another `include` statement in the root settings file:
   ====
   include::sample[dir="snippets/multiproject/multiple-subprojects/kotlin",files="settings.gradle.kts[]"]
   include::sample[dir="snippets/multiproject/multiple-subprojects/groovy",files="settings.gradle[]"]
   ====
   
   Gradle will then look for the build file of the new `lib` subproject in the `./lib/` directory:
   
   [.multi-language-sample]
   =====
   [source, kotlin]
   ----
   .
   較럭較 app
   較   ...
   較   較덕較 build.gradle.kts
   較럭較 lib
   較   ...
   較   較덕較 build.gradle.kts
   較덕較 settings.gradle.kts
   ----
   =====
   [.multi-language-sample]
   =====
   [source, groovy]
   ----
   .
   較럭較 app
   較   ...
   較   較덕較 build.gradle
   較럭較 lib
   較   ...
   較   較덕較 build.gradle
   較덕較 settings.gradle
   ----
   =====
   
   == Project Descriptors
   
   To further describe the project architecture to Gradle, the settings file provides _project descriptors_.
   
   You can modify these descriptors in the settings file at any time.
   
   To access a descriptor, you can:
   
   ====
   include::sample[dir="snippets/multiproject/customLayout/kotlin",files="settings.gradle.kts[tags=lookup-project]"]
   include::sample[dir="snippets/multiproject/customLayout/groovy",files="settings.gradle[tags=lookup-project]"]
   ====
   
   Using this descriptor, you can change the name, project directory, and build file of a project:
   
   ====
   include::sample[dir="snippets/multiproject/customLayout/kotlin",files="settings.gradle.kts[tags=change-project]"]
   include::sample[dir="snippets/multiproject/customLayout/groovy",files="settings.gradle[tags=change-project]"]
   ====
   
   Consult the link:{javadocPath}#[ProjectDescriptor] class in the API documentation for more information.
   
   == Modifying a subproject path
   
   Let's take a hypothetical project with the following structure:
   
   [.multi-language-sample]
   =====
   [source, kotlin]
   ----
   .
   較럭較 app
   較   ...
   較   較덕較 build.gradle.kts
   較럭較 subs // Gradle may see this as a subproject
   較   較덕較 web // Gradle may see this as a subproject
   較       較덕較 my-web-module // Intended subproject
   較           ...
   較           較덕較 build.gradle.kts
   較덕較 settings.gradle.kts
   ----
   =====
   [.multi-language-sample]
   =====
   [source, groovy]
   ----
   .
   較럭較 app
   較   ...
   較   較덕較 build.gradle
   較럭較 subs // Gradle may see this as a subproject
   較   較덕較 web // Gradle may see this as a subproject
   較       較덕較 my-web-module // Intended subproject
   較           ...
   較           較덕較 build.gradle
   較덕較 settings.gradle
   ----
   =====
   
   If your `settings.gradle(.kts)` looks like this:
   
   ```
   include(':subs:web:my-web-module')
   ```
   
   Gradle sees a subproject with a logical project name of `:subs:web:my-web-module` and two, possibly unintentional, other subprojects logically named `:subs` and `:subs:web`.
   This can lead to phantom build directories, especially when using `allprojects{}` or `subproject{}`.
   
   To avoid this, you can use:
   
   ```
   include(':subs:web:my-web-module')
   project(':subs:web:my-web-module').projectDir = "subs/web/my-web-module"
   ```
   
   So that you only end up with a single subproject named `:subs:web:my-web-module`.
   
   Or you can use:
   
   ```
   include(':my-web-module')
   project(':my-web-module').projectDir = "subs/web/my-web-module"
   ```
   
   So that you only end up with a single subproject named `:my-web-module`.
   
   So, while the physical project layout is the same, the logical results are different.
   
   == Naming recommendations
   
   As your project grows, naming and consistency get increasingly more important.
   To keep your builds maintainable, we recommend the following:
   
   1. *Keep default project names for subprojects*:
   It is possible to configure custom project names in the settings file.
   However, it뗩 an unnecessary extra effort for the developers to track which projects belong to what folders.
   
   2. *Use lower case hyphenation for all project names*:
   All letters are lowercase, and words are separated with a dash (`-`) character.
   
   3. *Define the root project name in the settings file*:
   The `rootProject.name` effectively assigns a name to the build, used in reports like Build Scans.
   If the root project name is not set, the name will be the container directory name, which can be unstable (i.e., you can check out your project in any directory).
   The name will be generated randomly if the root project name is not set and checked out to a file system's root (e.g., `/` or `C:\`).

/docs/userguide/authoring-builds/structuring/declaring_dependencies_between_subprojects.adoc
============================================================================================

.. code-block::

   = Declaring Dependencies between Subprojects
   
   What if one subproject depends on another subproject?
   What if one project needs the artifact produced by another project?
   
   image::structuring-builds-2.png[]
   
   This is a common use case for multi-project builds.
   Gradle offers <<declaring_dependencies.adoc#sub:project_dependencies,project dependencies>> for this.
   
   == Depending on another project
   
   Let's explore a theoretical multi-project build with the following layout:
   
   [.multi-language-sample]
   =====
   [source, kotlin]
   ----
   .
   較럭較 api
   較   較럭較 src
   較   較   較덕較...
   較   較덕較 build.gradle.kts
   較럭較 services
   較   較덕較 person-service
   較       較럭較 src
   較       較   較덕較...
   較       較덕較 build.gradle.kts
   較럭較 shared
   較   較럭較 src
   較   較   較덕較...
   較   較덕較 build.gradle.kts
   較덕較 settings.gradle.kts
   ----
   =====
   [.multi-language-sample]
   =====
   [source, groovy]
   ----
   .
   較럭較 api
   較   較럭較 src
   較   較   較덕較...
   較   較덕較 build.gradle
   較럭較 services
   較   較덕較 person-service
   較       較럭較 src
   較       較   較덕較...
   較       較덕較 build.gradle
   較럭較 shared
   較   較럭較 src
   較   較   較덕較...
   較   較덕較 build.gradle
   較덕較 settings.gradle
   ----
   =====
   
   In this example, there are three subprojects called `shared`, `api`, and `person-service`:
   
   1. The `person-service` subproject depends on the other two subprojects, `shared` and `api`.
   2. The `api` subproject depends on the `shared` subproject.
   
   We use the `:` separator to define a <<intro_multi_project_builds#sec:project_path,project path>> such as `services:person-service` or `:shared`.
   Consult the DSL documentation of link:{groovyDslPath}#[])++[Settings.include(java.lang.String[\])] for more information about defining project paths.
   
   ====
   include::sample[dir="snippets/multiproject/basic-dependencies/kotlin",files="settings.gradle.kts[];shared/build.gradle.kts[];api/build.gradle.kts[];services/person-service/build.gradle.kts[]"]
   include::sample[dir="snippets/multiproject/basic-dependencies/groovy",files="settings.gradle[];shared/build.gradle[];api/build.gradle[];services/person-service/build.gradle[]"]
   ====
   
   A project dependency affects execution order.
   It causes the other project to be built first and adds the output with the classes of the other project to the classpath.
   It also adds the dependencies of the other project to the classpath.
   
   If you execute `./gradlew :api:compile`, first the `shared` project is built, and then the `api` project is built.
   
   == Depending on artifacts produced by another project
   
   Sometimes, you might want to depend on the output of a specific task within another project rather than the entire project.
   However, explicitly declaring a task dependency from one project to another is discouraged as it introduces unnecessary coupling between tasks.
   
   The recommended way to model dependencies, where a task in one project depends on the output of another, is to produce the output and mark it as an "outgoing" artifact.
   Gradle's <<cross_project_publications#cross_project_publications,dependency management engine>> allows you to share arbitrary artifacts between projects and build them on demand.

/docs/userguide/authoring-builds/structuring/sharing_build_logic_between_subprojects.adoc
=========================================================================================

.. code-block::

   = Sharing Build Logic between Subprojects
   
   Subprojects in a multi-project build typically share some common dependencies.
   
   image::structuring-builds-3.png[]
   
   Instead of copying and pasting the same Java version and libraries in each subproject build script, Gradle provides a special directory for storing shared build logic that can be automatically applied to subprojects.
   
   == Share logic in `buildSrc`
   
   `buildSrc` is a Gradle-recognized and protected directory which comes with some benefits:
   
   1. *Reusable Build Logic*:
   +
   `buildSrc` allows you to organize and centralize your custom build logic, tasks, and plugins in a structured manner.
   The code written in buildSrc can be reused across your project, making it easier to maintain and share common build functionality.
   
   2. *Isolation from the Main Build*:
   +
   Code placed in `buildSrc` is isolated from the other build scripts of your project.
   This helps keep the main build scripts cleaner and more focused on project-specific configurations.
   
   3. *Automatic Compilation and Classpath*:
   +
   The contents of the `buildSrc` directory are automatically compiled and included in the classpath of your main build.
   This means that classes and plugins defined in buildSrc can be directly used in your project's build scripts without any additional configuration.
   
   4. *Ease of Testing*:
   +
   Since `buildSrc` is a separate build, it allows for easy testing of your custom build logic.
   You can write tests for your build code, ensuring that it behaves as expected.
   
   5. *Gradle Plugin Development*:
   +
   If you are developing custom Gradle plugins for your project, `buildSrc` is a convenient place to house the plugin code.
   This makes the plugins easily accessible within your project.
   
   The `buildSrc` directory is treated as an <<composite_builds.adoc#composite_build_intro,included build>>.
   
   For multi-project builds, there can be only one `buildSrc` directory, which must be in the root project directory.
   
   NOTE: The downside of using `buildSrc` is that any change to it will invalidate every task in your project and require a rerun.
   
   `buildSrc` uses the same <<java_plugin.adoc#javalayout,source code conventions>> applicable to Java, Groovy, and Kotlin projects.
   It also provides direct access to the Gradle API.
   
   A typical project including `buildSrc` has the following layout:
   
   [.multi-language-sample]
   =====
   [source, kotlin]
   ----
   .
   較럭較 buildSrc
   較   較럭較 src
   較   較   較덕較main
   較   較      較덕較kotlin
   較   較         較덕較MyCustomTask.kt    // <1>
   較   較럭較 shared.gradle.kts   // <2>
   較   較덕較 build.gradle.kts
   較럭較 api
   較   較럭較 src
   較   較   較덕較...
   較   較덕較 build.gradle.kts    // <3>
   較럭較 services
   較   較덕較 person-service
   較       較럭較 src
   較       較   較덕較...
   較       較덕較 build.gradle.kts    // <3>
   較럭較 shared
   較   較럭較 src
   較   較   較덕較...
   較   較덕較 build.gradle.kts
   較덕較 settings.gradle.kts
   ----
   <1> Create the `MyCustomTask` task.
   <2> A shared build script.
   <3> Uses the `MyCustomTask` task and shared build script.
   =====
   [.multi-language-sample]
   =====
   [source, groovy]
   ----
   .
   較럭較 buildSrc
   較   較럭較 src
   較   較   較덕較main
   較   較      較덕較kotlin
   較   較         較덕較MyCustomTask.groovy    // <1>
   較   較럭較 shared.gradle   // <2>
   較   較덕較 build.gradle
   較럭較 api
   較   較럭較 src
   較   較   較덕較...
   較   較덕較 build.gradle    // <3>
   較럭較 services
   較   較덕較 person-service
   較       較럭較 src
   較       較   較덕較...
   較       較덕較 build.gradle    // <3>
   較럭較 shared
   較   較럭較 src
   較   較   較덕較...
   較   較덕較 build.gradle
   較덕較 settings.gradle
   ----
   <1> Create the `MyCustomTask` task.
   <2> A shared build script.
   <3> Uses the `MyCustomTask` task and shared build script.
   =====
   
   In the `buildSrc`, the build script `shared.gradle(.kts)` is created.
   It contains dependencies and other build information that is common to multiple subprojects:
   
   [.multi-language-sample]
   =====
   .shared.gradle.kts
   [source, kotlin]
   ----
   repositories {
       mavenCentral()
   }
   
   dependencies {
       implementation("org.slf4j:slf4j-api:1.7.32")
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .shared.gradle
   [source, groovy]
   ----
   repositories {
       mavenCentral()
   }
   
   dependencies {
       implementation 'org.slf4j:slf4j-api:1.7.32'
   }
   ----
   =====
   
   In the `buildSrc`, the `MyCustomTask` is also created.
   It is a helper task that is used as part of the build logic for multiple subprojects:
   
   [.multi-language-sample]
   =====
   .MyCustomTask.kt
   [source, kotlin]
   ----
   import org.gradle.api.DefaultTask
   import org.gradle.api.tasks.TaskAction
   
   open class MyCustomTask : DefaultTask() {
       @TaskAction
       fun calculateSum() {
           // Custom logic to calculate the sum of two numbers
           val num1 = 5
           val num2 = 7
           val sum = num1 + num2
   
           // Print the result
           println("Sum: $sum")
       }
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .MyCustomTask.groovy
   [source, groovy]
   ----
   import org.gradle.api.DefaultTask
   import org.gradle.api.tasks.TaskAction
   
   class MyCustomTask extends DefaultTask {
       @TaskAction
       void calculateSum() {
           // Custom logic to calculate the sum of two numbers
           int num1 = 5
           int num2 = 7
           int sum = num1 + num2
   
           // Print the result
           println "Sum: $sum"
       }
   }
   ----
   =====
   
   The `MyCustomTask` task is used in the build script of the `api` and `shared` projects.
   The task is automatically available because it's part of `buildSrc`.
   
   The `shared.build(.kts)` file is also applied:
   
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source, kotlin]
   ----
   // Apply any other configurations specific to your project
   
   // Use the build script defined in buildSrc
   apply(from = rootProject.file("buildSrc/shared.gradle"))
   
   // Use the custom task defined in buildSrc
   tasks.register<MyCustomTask>("myCustomTask")
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle
   [source, groovy]
   ----
   // Apply any other configurations specific to your project
   
   // Use the build script defined in buildSrc
   apply from: rootProject.file('buildSrc/shared.gradle')
   
   // Use the custom task defined in buildSrc
   tasks.register('myCustomTask', MyCustomTask)
   ----
   =====
   
   == Share logic using convention plugins
   
   Gradle's recommended way of organizing build logic is to use its plugin system.
   
   We can write a plugin that encapsulates the build logic common to several subprojects in a project.
   This kind of plugin is called a *convention plugin*.
   
   While writing plugins is outside the scope of this section, the recommended way to build a Gradle project is to put common build logic in a convention plugin located in the `buildSrc`.
   
   Let's take a look at an example project:
   
   [.multi-language-sample]
   =====
   [source, kotlin]
   ----
   .
   較럭較 buildSrc
   較   較럭較 src
   較   較   較덕較main
   較   較      較덕較kotlin
   較   較         較덕較myproject.java-conventions.gradle  // <1>
   較   較덕較 build.gradle.kts
   較럭較 api
   較   較럭較 src
   較   較   較덕較...
   較   較덕較 build.gradle.kts    // <2>
   較럭較 services
   較   較덕較 person-service
   較       較럭較 src
   較       較   較덕較...
   較       較덕較 build.gradle.kts    // <2>
   較럭較 shared
   較   較럭較 src
   較   較   較덕較...
   較   較덕較 build.gradle.kts    // <2>
   較덕較 settings.gradle.kts
   ----
   <1> Create the `myproject.java-conventions` convention plugin.
   <2> Applies the `myproject.java-conventions` convention plugin.
   =====
   [.multi-language-sample]
   =====
   [source, groovy]
   ----
   .
   較럭較 buildSrc
   較   較럭較 src
   較   較   較덕較main
   較   較      較덕較kotlin
   較   較         較덕較myproject.java-conventions.gradle.kts  // <1>
   較   較덕較 build.gradle
   較럭較 api
   較   較럭較 src
   較   較   較덕較...
   較   較덕較 build.gradle    // <2>
   較럭較 services
   較   較덕較 person-service
   較       較럭較 src
   較       較   較덕較...
   較       較덕較 build.gradle    // <2>
   較럭較 shared
   較   較럭較 src
   較   較   較덕較...
   較   較덕較 build.gradle    // <2>
   較덕較 settings.gradle
   ----
   <1> Create the `myproject.java-conventions` convention plugin.
   <2> Applies the `myproject.java-conventions` convention plugin.
   =====
   
   This build contains three subprojects:
   
   ====
   include::sample[dir="snippets/multiproject/dependencies-java/kotlin",files="settings.gradle.kts[]"]
   include::sample[dir="snippets/multiproject/dependencies-java/groovy",files="settings.gradle[]"]
   ====
   
   The source code for the convention plugin created in the `buildSrc` directory is as follows:
   
   ====
   include::sample[dir="snippets/multiproject/dependencies-java/kotlin",files="buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts[]"]
   include::sample[dir="snippets/multiproject/dependencies-java/groovy",files="buildSrc/src/main/groovy/myproject.java-conventions.gradle[]"]
   ====
   
   The convention plugin is applied to the `api`, `shared`, and `person-service` subprojects:
   
   ====
   include::sample[dir="snippets/multiproject/dependencies-java/kotlin",files="api/build.gradle.kts[];shared/build.gradle.kts[];services/person-service/build.gradle.kts[]"]
   include::sample[dir="snippets/multiproject/dependencies-java/groovy",files="api/build.gradle[];shared/build.gradle[];services/person-service/build.gradle[]"]
   ====
   
   == Do not use cross-project configuration
   
   An improper way to share build logic between subprojects is _cross-project configuration_ via the link:{javadocPath}#[`subprojects {}`] and link:{javadocPath}#[`allprojects {}`] DSL constructs.
   
   TIP:  Avoid using `subprojects {}` and `allprojects {}`.
   
   With cross-configuration, build logic can be injected into a subproject which is not obvious when looking at its build script.
   
   In the long run, cross-configuration usually grows in complexity and becomes a burden.
   Cross-configuration can also introduce configuration-time coupling between projects, which can prevent optimizations like configuration-on-demand from working properly.
   
   === Convention plugins versus cross-configuration
   
   The two most common uses of cross-configuration can be better modeled using convention plugins:
   
   1. Applying plugins or other configurations to subprojects of a certain type. +
   Often, the cross-configuration logic is `if subproject is of type X, then configure Y`.
   This is equivalent to applying `X-conventions` plugin directly to a subproject.
   2. Extracting information from subprojects of a certain type. +
   This use case can be modeled using <<cross_project_publications.adoc#sec:simple-sharing-artifacts-between-projects,outgoing configuration variants>>.

/docs/userguide/authoring-builds/structuring/composite_builds.adoc
==================================================================

.. code-block::

   = Composite Builds
   
   A composite build is a build that includes other builds.
   
   image::structuring-builds-4.png[]
   
   A composite build is similar to a Gradle multi-project build, except that instead of including `subprojects`, entire `builds` are included.
   
   Composite builds allow you to:
   
   * Combine builds that are usually developed independently, for instance, when trying out a bug fix in a library that your application uses.
   * Decompose a large multi-project build into smaller, more isolated chunks that can be worked on independently or together as needed.
   
   A build that is included in a composite build is referred to as an *included build*.
   Included builds do not share any configuration with the composite build or the other included builds.
   Each included build is configured and executed in isolation.
   
   == Defining a composite build
   
   The following example demonstrates how two Gradle builds, normally developed separately, can be combined into a composite build.
   
   [source,text]
   ----
   my-composite
   較럭較 gradle
   較럭較 gradlew
   較럭較 settings.gradle.kts
   較럭較 build.gradle.kts
   較럭較 my-app
   較   較럭較 settings.gradle.kts
   較   較덕較 app
   較       較럭較 build.gradle.kts
   較       較덕較 src/main/java/org/sample/my-app/Main.java
   較덕較 my-utils
       較럭較 settings.gradle.kts
       較럭較 number-utils
       較   較럭較 build.gradle.kts
       較   較덕較 src/main/java/org/sample/numberutils/Numbers.java
       較덕較 string-utils
           較럭較 build.gradle.kts
           較덕較 src/main/java/org/sample/stringutils/Strings.java
   ----
   
   The `my-utils` multi-project build produces two Java libraries, `number-utils` and `string-utils`.
   The `my-app` build produces an executable using functions from those libraries.
   
   The `my-app` build does not depend directly on `my-utils`.
   Instead, it declares binary dependencies on the libraries produced by `my-utils`:
   
   ====
   include::sample[dir="samples/build-organization/composite-builds/basic/kotlin",files="my-app/app/build.gradle.kts[tags=app_dependencies]"]
   include::sample[dir="samples/build-organization/composite-builds/basic/groovy",files="my-app/app/build.gradle[tags=app_dependencies]"]
   ====
   
   === Defining a composite build via `--include-build`
   
   The `--include-build` command-line argument turns the executed build into a composite, substituting dependencies from the included build into the executed build.
   
   For example, the output of `./gradlew run --include-build ../my-utils` run from `my-app`:
   
   ----
   $ ./gradlew --include-build ../my-utils run
   include::{samplesPath}/build-organization/composite-builds/basic/tests/basicCli.out[]
   ----
   
   === Defining a composite build via the settings file
   
   It's possible to make the above arrangement persistent by using link:{groovyDslPath}#[Settings.includeBuild(java.lang.Object)] to declare the included build in the `settings.gradle(.kts)` file.
   
   The settings file can be used to add subprojects and included builds simultaneously.
   
   Included builds are added by location:
   
   .settings.gradle.kts
   [source,kotlin]
   ----
   includeBuild("my-utils")
   ----
   
   In the example, the settings.gradle(.kts) file combines otherwise separate builds:
   
   ====
   include::sample[dir="samples/build-organization/composite-builds/basic/kotlin",files="settings.gradle.kts[]"]
   include::sample[dir="samples/build-organization/composite-builds/basic/groovy",files="settings.gradle[]"]
   ====
   
   To execute the `run` task in the `my-app` build from `my-composite`, run `./gradlew my-app:app:run`.
   
   You can optionally define a `run` task in `my-composite` that depends on `my-app:app:run` so that you can execute `./gradlew run`:
   
   ====
   include::sample[dir="samples/build-organization/composite-builds/basic/kotlin",files="build.gradle.kts[tags=run]"]
   include::sample[dir="samples/build-organization/composite-builds/basic/groovy",files="build.gradle[tags=run]"]
   ====
   
   === Including builds that define Gradle plugins
   
   A special case of included builds are builds that define Gradle plugins.
   
   These builds should be included using the `includeBuild` statement inside the `pluginManagement {}` block of the settings file.
   
   Using this mechanism, the included build may also contribute a settings plugin that can be applied in the settings file itself:
   
   ====
   include::sample[dir="snippets/developingPlugins/testingPlugins/kotlin/include-plugin-build",files="settings.gradle.kts[tags=include-build]"]
   include::sample[dir="snippets/developingPlugins/testingPlugins/groovy/include-plugin-build",files="settings.gradle[tags=include-build]"]
   ====
   
   == Restrictions on included builds
   
   Most builds can be included in a composite, including other composite builds.
   There are some restrictions.
   
   In a regular build, Gradle ensures that each project has a unique _project path_.
   It makes projects identifiable and addressable without conflicts.
   
   In a composite build, Gradle adds additional qualification to each project from an included build to avoid project path conflicts.
   The full path to identify a project in a composite build is called a _build-tree path_.
   It consists of a _build path_ of an included build and a _project path_ of the project.
   
   By default, build paths and project paths are derived from directory names and structure on disk.
   Since included builds can be located anywhere on disk, their build path is determined by the name of the containing directory.
   This can sometimes lead to conflicts.
   
   To summarize, the included builds must fulfill these requirements:
   
   * Each included build must have a unique build path.
   * Each included build path must not conflict with any project path of the main build.
   
   These conditions guarantee that each project can be uniquely identified even in a composite build.
   
   If conflicts arise, the way to resolve them is by changing the _build name_ of an included build:
   
   .settings.gradle.kts
   [source,kotlin]
   ----
   includeBuild("some-included-build") {
       name = "other-name"
   }
   ----
   
   [NOTE]
   ====
   When a composite build is included in another composite build, both builds have the same parent.
   In other words, the nested composite build structure is flattened.
   ====
   
   == Interacting with a composite build
   
   Interacting with a composite build is generally similar to a regular multi-project build.
   Tasks can be executed, tests can be run, and builds can be imported into the IDE.
   
   === Executing tasks
   
   Tasks from an included build can be executed from the command-line or IDE in the same way as tasks from a regular multi-project build.
   Executing a task will result in task dependencies being executed, as well as those tasks required to build dependency artifacts from other included builds.
   
   You can call a task in an included build using a fully qualified path, for example, `:included-build-name:project-name:taskName`.
   Project and task names can be <<command_line_interface.adoc#sec:name_abbreviation,abbreviated>>.
   
   ----
   $ ./gradlew :included-build:subproject-a:compileJava
   > Task :included-build:subproject-a:compileJava
   
   $ ./gradlew :i-b:sA:cJ
   > Task :included-build:subproject-a:compileJava
   ----
   
   To <<command_line_interface.adoc#sec:excluding_tasks_from_the_command_line,exclude a task from the command line>>, you need to provide the fully qualified path to the task.
   
   NOTE: Included build tasks are automatically executed to generate required dependency artifacts, or the <<#included_build_task_dependencies,including build can declare a dependency on a task from an included build>>.
   
   === Importing into the IDE
   
   One of the most useful features of composite builds is IDE integration.
   
   Importing a composite build permits sources from separate Gradle builds to be easily developed together.
   For every included build, each subproject is included as an IntelliJ IDEA Module or Eclipse Project.
   Source dependencies are configured, providing cross-build navigation and refactoring.
   
   == Declaring dependencies substituted by an included build
   
   By default, Gradle will configure each included build to determine the dependencies it can provide.
   The algorithm for doing this is simple.
   Gradle will inspect the group and name for the projects in the included build and substitute project dependencies for any external dependency matching `${project.group}:${project.name}`.
   
   [NOTE]
   ====
   By default, substitutions are not registered for the _main_ build.
   
   To make the (sub)projects of the main build addressable by `${project.group}:${project.name}`, you can tell Gradle to treat the main build like an included build by self-including it: `includeBuild(".")`.
   ====
   
   There are cases when the default substitutions determined by Gradle are insufficient or must be corrected for a particular composite.
   For these cases, explicitly declaring the substitutions for an included build is possible.
   
   For example, a single-project build called `anonymous-library`, produces a Java utility library but does not declare a value for the group attribute:
   
   ====
   include::sample[dir="samples/build-organization/composite-builds/declared-substitution/kotlin/anonymous-library",files="build.gradle.kts[]"]
   include::sample[dir="samples/build-organization/composite-builds/declared-substitution/groovy/anonymous-library",files="build.gradle[]"]
   ====
   
   When this build is included in a composite, it will attempt to substitute for the dependency module `undefined:anonymous-library` (`undefined` being the default value for `project.group`, and `anonymous-library` being the root project name).
   Clearly, this isn't useful in a composite build.
   
   To use the unpublished library in a composite build, you can explicitly declare the substitutions that it provides:
   
   ====
   include::sample[dir="samples/build-organization/composite-builds/declared-substitution/kotlin",files="settings.gradle.kts[tags=composite_substitution]"]
   include::sample[dir="samples/build-organization/composite-builds/declared-substitution/groovy",files="settings.gradle[tags=composite_substitution]"]
   ====
   
   With this configuration, the `my-app` composite build will substitute any dependency on `org.sample:number-utils` with a dependency on the root project of `anonymous-library`.
   
   === Deactivate included build substitutions for a configuration
   
   If you need to <<declaring_dependencies.adoc#sec:resolvable-consumable-configs,resolve>> a published version of a module that is also available as part of an included build, you can deactivate the included build substitution rules on the link:{groovyDslPath}#[ResolutionStrategy] of the Configuration that is resolved.
   This is necessary because the rules are globally applied in the build, and Gradle does not consider published versions during resolution by default.
   
   For example, we create a separate `publishedRuntimeClasspath` configuration that gets resolved to the published versions of modules that also exist in one of the local builds.
   This is done by deactivating global dependency substitution rules:
   
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-deactivateGlobalSubstitution/kotlin",files="build.gradle.kts[tags=disableGlobalDependencySubstitutionRules]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-deactivateGlobalSubstitution/groovy",files="build.gradle[tags=disableGlobalDependencySubstitutionRules]"]
   ====
   
   A use-case would be to compare published and locally built JAR files.
   
   === Cases where included build substitutions must be declared
   
   Many builds will function automatically as an included build, without declared substitutions.
   Here are some common cases where declared substitutions are required:
   
   * When the `archivesBaseName` property is used to set the name of the published artifact.
   * When a configuration other than `default` is published.
   * When the `MavenPom.addFilter()` is used to publish artifacts that don't match the project name.
   * When the `maven-publish` or `ivy-publish` plugins are used for publishing and the publication coordinates don't match `${project.group}:${project.name}`.
   
   === Cases where composite build substitutions won't work
   
   Some builds won't function correctly when included in a composite, even when dependency substitutions are explicitly declared.
   This limitation is because a substituted project dependency will always point to the `default` configuration of the target project.
   Any time the artifacts and dependencies specified for the default configuration of a project don't match what is published to a repository, the composite build may exhibit different behavior.
   
   Here are some cases where the published module metadata may be different from the project default configuration:
   
   * When a configuration other than `default` is published.
   * When the `maven-publish` or `ivy-publish` plugins are used.
   * When the `POM` or `ivy.xml` file is tweaked as part of publication.
   
   Builds using these features function incorrectly when included in a composite build.
   
   == Depending on tasks in an included build
   
   While included builds are isolated from one another and cannot declare direct dependencies, a composite build can declare task dependencies on its included builds.
   The included builds are accessed using link:{groovyDslPath}#[Gradle.getIncludedBuilds()] or link:{groovyDslPath}#[Gradle.includedBuild(java.lang.String)], and a task reference is obtained via the link:{groovyDslPath}#[IncludedBuild.task(java.lang.String)] method.
   
   Using these APIs, it is possible to declare a dependency on a task in a particular included build:
   
   ====
   include::sample[dir="samples/build-organization/composite-builds/basic/kotlin",files="build.gradle.kts[tags=run]"]
   include::sample[dir="samples/build-organization/composite-builds/basic/groovy",files="build.gradle[tags=run]"]
   ====
   
   Or you can declare a dependency on tasks with a certain path in some or all of the included builds:
   
   ====
   include::sample[dir="samples/build-organization/composite-builds/hierarchical-multirepo/kotlin",files="build.gradle.kts"]
   include::sample[dir="samples/build-organization/composite-builds/hierarchical-multirepo/groovy",files="build.gradle"]
   ====
   
   == Limitations of composite builds
   
   Limitations of the current implementation include:
   
   * No support for included builds with publications that don't mirror the project default configuration. +
   See <<#included_build_substitution_limitations,Cases where composite builds won't work>>.
   * Multiple composite builds may conflict when run in parallel if more than one includes the same build. +
   Gradle does not share the project lock of a shared composite build between Gradle invocations to prevent concurrent execution.

/docs/userguide/authoring-builds/structuring/multi_project_configuration_and_execution.adoc
===========================================================================================

.. code-block::

   = Configuration On Demand
   
   Configuration-on-demand attempts to configure only the relevant projects for the requested tasks, i.e., it only evaluates the build script file of projects participating in the build.
   This way, the configuration time of a large multi-project build can be reduced.
   
   The configuration-on-demand feature is _incubating_, so only some builds are guaranteed to work correctly.
   The feature works well for <<#sec:decoupled_projects,decoupled>> multi-project builds.
   
   In configuration-on-demand mode, projects are configured as follows:
   
   * The root project is always configured.
   * The project in the directory where the build is executed is also configured, but only when Gradle is executed without any tasks. +
   This way, the default tasks behave correctly when projects are configured on demand.
   * The standard project dependencies are supported, and relevant projects are configured. +
   If project A has a compile dependency on project B, then building A causes the configuration of both projects.
   * The task dependencies declared via the task path are supported and cause relevant projects to be configured. +
   Example: `someTask.dependsOn(":some-other-project:someOtherTask")`
   * A task requested via task path from the command line (or tooling API) causes the relevant project to be configured. +
   For example, building `project-a:project-b:someTask` causes configuration of `project-b`.
   
   == Enable `configuration-on-demand`
   
   You can enable configuration-on-demand using the `--configure-on-demand` flag or adding `org.gradle.configureondemand=true` to the `gradle.properties` file.
   
   To configure on demand with every build run, see <<build_environment.adoc#sec:gradle_configuration_properties,Gradle properties>>.
   
   To configure on demand for a given build, see <<command_line_interface.adoc#sec:command_line_performance,command-line performance-oriented options>>.
   
   == Decoupled projects
   
   Gradle allows projects to access each other's configurations and tasks during the configuration and execution phases.
   While this flexibility empowers build authors, it limits Gradle's ability to perform optimizations such as <<#sec:parallel_execution,parallel project builds>> and <<#configuration_and_execution,configuration on demand>>.
   
   Projects are considered decoupled when they interact solely through declared dependencies and task dependencies.
   Any direct modification or reading of another project's object creates coupling between the projects.
   Coupling during configuration can result in flawed build outcomes when using 'configuration on demand', while coupling during execution can affect parallel execution.
   
   One common source of coupling is configuration injection, such as using `allprojects{}` or `subprojects{}` in build scripts.
   
   To avoid coupling issues, it's recommended to:
   
   - Refrain from referencing other subprojects' build scripts and prefer cross-configuration from the root project.
   - Avoid dynamically changing other projects' configurations during execution.
   
   As Gradle evolves, it aims to provide features that leverage decoupled projects while offering solutions for common use cases like configuration injection without introducing coupling.
   
   == Parallel projects
   
   Gradle's parallel execution feature optimizes CPU utilization to accelerate builds by concurrently executing tasks from different projects.
   
   To enable parallel execution, use the `--parallel` <<command_line_interface.adoc#sec:command_line_performance,command-line argument>> or configure your <<build_environment.adoc#sec:gradle_configuration_properties,build environment>>.
   Gradle automatically determines the optimal number of parallel threads based on CPU cores.
   
   During parallel execution, each worker handles a specific project exclusively.
   Task dependencies are respected, with workers prioritizing upstream tasks.
   However, tasks may not execute in alphabetical order, as in sequential mode.
   It's crucial to correctly declare task dependencies and inputs/outputs to avoid ordering issues.

/Section: 游릭 Developing Tasks
===============================


/docs/userguide/authoring-builds/tasks/more_about_tasks.adoc
============================================================

.. code-block::

   = Tasks
   
   A task represents some *independent unit of work* that a build performs, such as compiling classes, creating a JAR, generating Javadoc, or publishing archives to a repository.
   
   image::writing-tasks-1.png[]
   
   == Listing tasks
   
   All available tasks in your project come from Gradle plugins and build scripts.
   
   You can list all the available tasks in a project by running the following command in the terminal:
   
   [source,text]
   ----
   $ ./gradlew tasks
   ----
   
   Let's take a very basic Gradle project as an example.
   The project has the following structure:
   
   ====
   [.multi-language-sample]
   =====
   [source,kotlin]
   ----
   gradle-project
   較럭較 app
   較   較럭較 build.gradle.kts    // empty file - no build logic
   較   較덕較 ...                 // some java code
   較럭較 settings.gradle.kts     // includes app subproject
   較럭較 gradle
   較   較덕較 ...
   較럭較 gradlew
   較덕較 gradlew.bat
   ----
   =====
   [.multi-language-sample]
   =====
   [source,groovy]
   ----
   gradle-project
   較럭較 app
   較   較럭較 build.gradle    // empty file - no build logic
   較   較덕較 ...             // some java code
   較럭較 settings.gradle     // includes app subproject
   較럭較 gradle
   較   較덕較 ...
   較럭較 gradlew
   較덕較 gradlew.bat
   ----
   =====
   ====
   
   The settings file contains the following:
   
   ====
   [.multi-language-sample]
   =====
   .settings.gradle.kts
   [source,kotlin]
   ----
   rootProject.name = "gradle-project"
   include("app")
   ----
   =====
   [.multi-language-sample]
   =====
   .settings.gradle
   [source,groovy]
   ----
   rootProject.name = 'gradle-project'
   include('app')
   ----
   =====
   ====
   
   Currently, the `app` subproject's build file is empty.
   
   To see the tasks available in the `app` subproject, run `./gradlew :app:tasks`:
   
   [source,text]
   ----
   $ ./gradlew :app:tasks
   
   > Task :app:tasks
   
   ------------------------------------------------------------
   Tasks runnable from project ':app'
   ------------------------------------------------------------
   
   Help tasks
   ----------
   buildEnvironment - Displays all buildscript dependencies declared in project ':app'.
   dependencies - Displays all dependencies declared in project ':app'.
   dependencyInsight - Displays the insight into a specific dependency in project ':app'.
   help - Displays a help message.
   javaToolchains - Displays the detected java toolchains.
   kotlinDslAccessorsReport - Prints the Kotlin code for accessing the currently available project extensions and conventions.
   outgoingVariants - Displays the outgoing variants of project ':app'.
   projects - Displays the sub-projects of project ':app'.
   properties - Displays the properties of project ':app'.
   resolvableConfigurations - Displays the configurations that can be resolved in project ':app'.
   tasks - Displays the tasks runnable from project ':app'.
   ----
   
   We observe that only a small number of help tasks are available at the moment.
   This is because the core of Gradle only provides tasks that analyze your build.
   Other tasks, such as the those that build your project or compile your code, are added by plugins.
   
   Let's explore this by adding the <<base_plugin.adoc#base_plugin,Gradle core `base` plugin>> to the `app` build script:
   
   ====
   [.multi-language-sample]
   =====
   .app/build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("base")
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .app/build.gradle
   [source,groovy]
   ----
   plugins {
       id('base')
   }
   ----
   =====
   ====
   
   The `base` plugin adds central lifecycle tasks.
   Now when we run `./gradlew app:tasks`, we can see the `assemble` and `build` tasks are available:
   
   [source,text]
   ----
   $ ./gradlew :app:tasks
   
   > Task :app:tasks
   
   ------------------------------------------------------------
   Tasks runnable from project ':app'
   ------------------------------------------------------------
   
   Build tasks
   -----------
   assemble - Assembles the outputs of this project.
   build - Assembles and tests this project.
   clean - Deletes the build directory.
   
   Help tasks
   ----------
   buildEnvironment - Displays all buildscript dependencies declared in project ':app'.
   dependencies - Displays all dependencies declared in project ':app'.
   dependencyInsight - Displays the insight into a specific dependency in project ':app'.
   help - Displays a help message.
   javaToolchains - Displays the detected java toolchains.
   outgoingVariants - Displays the outgoing variants of project ':app'.
   projects - Displays the sub-projects of project ':app'.
   properties - Displays the properties of project ':app'.
   resolvableConfigurations - Displays the configurations that can be resolved in project ':app'.
   tasks - Displays the tasks runnable from project ':app'.
   
   Verification tasks
   ------------------
   check - Runs all checks.
   ----
   
   If we run the `build` task, we see that not much happens:
   
   [source,text]
   ----
   $ ./gradlew :app:build
   
   > Task :app:assemble UP-TO-DATE
   > Task :app:check UP-TO-DATE
   > Task :app:build UP-TO-DATE
   ----
   
   == Task outcomes
   
   When Gradle executes a task, it labels the task with outcomes via the console.
   
   image::author-tasks-1.png[]
   
   These labels are based on whether a task has actions to execute and if Gradle executed them.
   Actions include, but are not limited to, compiling code, zipping files, and publishing archives.
   
   `(no label)` or `EXECUTED`:: *Task executed its actions.*
   * Task has actions and Gradle executed them.
   * Task has no actions and some dependencies, and Gradle executed one or more of the dependencies. See also <<lifecycle_tasks.adoc#sec:lifecycle_tasks,Lifecycle Tasks>>.
   
   `UP-TO-DATE`:: *Task's outputs did not change.*
   * Task has outputs and inputs but they have not changed. See <<incremental_build.adoc#incremental_build,Incremental Build>>.
   * Task has actions, but the task tells Gradle it did not change its outputs.
   * Task has no actions and some dependencies, but all the dependencies are `UP-TO-DATE`, `SKIPPED` or `FROM-CACHE`. See <<lifecycle_tasks.adoc#sec:lifecycle_tasks,Lifecycle Tasks>>.
   * Task has no actions and no dependencies.
   
   `FROM-CACHE`:: *Task's outputs could be found from a previous execution.*
   * Task has outputs restored from the build cache. See <<build_cache.adoc#build_cache,Build Cache>>.
   
   `SKIPPED`:: *Task did not execute its actions.*
   * Task has been explicitly excluded from the command-line. See <<command_line_interface.adoc#sec:excluding_tasks_from_the_command_line,Excluding tasks from execution>>.
   * Task has an `onlyIf` predicate return false. See <<#sec:using_a_predicate,Using a predicate>>.
   
   `NO-SOURCE`:: *Task did not need to execute its actions.*
   * Task has inputs and outputs, but <<incremental_build.adoc#skip-when-empty,no sources>> (i.e., inputs were not found).
   
   == Task categories
   
   Gradle distinguishes between two categories of tasks:
   
   1. *Lifecycle tasks*
   2. *Actionable tasks*
   
   **Lifecycle tasks** define targets you can call, such as `:build` your project.
   Lifecycle tasks do not provide Gradle with actions.
   They must be _wired_ to actionable tasks.
   The <<base_plugin.adoc#base_plugin,`base` Gradle plugin>> only adds lifecycle tasks.
   
   **Actionable tasks** define actions for Gradle to take, such as `:compileJava`, which compiles the Java code of your project.
   Actions include creating JARs, zipping files, publishing archives, and much more.
   Plugins like the <<java_library_plugin.adoc#java_library_plugin,`java-library` plugin>> adds actionable tasks.
   
   Let's update the build script of the previous example, which is currently an empty file so that our `app` subproject is a Java library:
   
   ====
   [.multi-language-sample]
   =====
   .app/build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("java-library")
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .app/build.gradle
   [source,groovy]
   ----
   plugins {
       id('java-library')
   }
   ----
   =====
   ====
   
   Once again, we list the available tasks to see what new tasks are available:
   
   [source,text]
   ----
   $ ./gradlew :app:tasks
   
   > Task :app:tasks
   
   ------------------------------------------------------------
   Tasks runnable from project ':app'
   ------------------------------------------------------------
   
   Build tasks
   -----------
   assemble - Assembles the outputs of this project.
   build - Assembles and tests this project.
   buildDependents - Assembles and tests this project and all projects that depend on it.
   buildNeeded - Assembles and tests this project and all projects it depends on.
   classes - Assembles main classes.
   clean - Deletes the build directory.
   jar - Assembles a jar archive containing the classes of the 'main' feature.
   testClasses - Assembles test classes.
   
   Documentation tasks
   -------------------
   javadoc - Generates Javadoc API documentation for the 'main' feature.
   
   Help tasks
   ----------
   buildEnvironment - Displays all buildscript dependencies declared in project ':app'.
   dependencies - Displays all dependencies declared in project ':app'.
   dependencyInsight - Displays the insight into a specific dependency in project ':app'.
   help - Displays a help message.
   javaToolchains - Displays the detected java toolchains.
   outgoingVariants - Displays the outgoing variants of project ':app'.
   projects - Displays the sub-projects of project ':app'.
   properties - Displays the properties of project ':app'.
   resolvableConfigurations - Displays the configurations that can be resolved in project ':app'.
   tasks - Displays the tasks runnable from project ':app'.
   
   Verification tasks
   ------------------
   check - Runs all checks.
   test - Runs the test suite.
   ----
   
   We see that many new tasks are available such as `jar` and `testClasses`.
   
   Additionally, the `java-library` plugin has wired actionable tasks to lifecycle tasks.
   If we call the `:build` task, we can see several tasks have been executed, including the `:app:compileJava` task.
   
   [source,text]
   ----
   $./gradlew :app:build
   
   > Task :app:compileJava
   > Task :app:processResources NO-SOURCE
   > Task :app:classes
   > Task :app:jar
   > Task :app:assemble
   > Task :app:compileTestJava
   > Task :app:processTestResources NO-SOURCE
   > Task :app:testClasses
   > Task :app:test
   > Task :app:check
   > Task :app:build
   ----
   
   The actionable `:compileJava` task is wired to the lifecycle `:build` task.
   
   == Incremental tasks
   
   A key feature of Gradle tasks is their incremental nature.
   
   Gradle can reuse results from prior builds.
   Therefore, if we've built our project before and made only minor changes, rerunning `:build` will not require Gradle to perform extensive work.
   
   For example, if we modify only the test code in our project, leaving the production code unchanged, executing the build will solely recompile the test code.
   Gradle marks the tasks for the production code as `UP-TO-DATE`, indicating that it remains unchanged since the last successful build:
   
   [source,text]
   ----
   $./gradlew :app:build
   
   lkassovic@MacBook-Pro temp1 % ./gradlew :app:build
   > Task :app:compileJava UP-TO-DATE
   > Task :app:processResources NO-SOURCE
   > Task :app:classes UP-TO-DATE
   > Task :app:jar UP-TO-DATE
   > Task :app:assemble UP-TO-DATE
   > Task :app:compileTestJava
   > Task :app:processTestResources NO-SOURCE
   > Task :app:testClasses
   > Task :app:test
   > Task :app:check UP-TO-DATE
   > Task :app:build UP-TO-DATE
   ----
   
   == Caching tasks
   
   Gradle can reuse results from past builds using the build cache.
   
   To enable this feature, activate the build cache by using the `--build-cache` <<command_line_interface#command_line_interface,command line>> parameter or by setting `org.gradle.caching=true` in your <<build_environment#sec:gradle_configuration_properties,`gradle.properties`>> file.
   
   This optimization has the potential to accelerate your builds significantly:
   
   [source,text]
   ----
   $./gradlew :app:clean :app:build --build-cache
   
   > Task :app:compileJava FROM-CACHE
   > Task :app:processResources NO-SOURCE
   > Task :app:classes UP-TO-DATE
   > Task :app:jar
   > Task :app:assemble
   > Task :app:compileTestJava FROM-CACHE
   > Task :app:processTestResources NO-SOURCE
   > Task :app:testClasses UP-TO-DATE
   > Task :app:test FROM-CACHE
   > Task :app:check UP-TO-DATE
   > Task :app:build
   ----
   
   When Gradle can fetch outputs of a task from the cache, it labels the task with `FROM-CACHE`.
   
   The build cache is handy if you switch between branches regularly.
   Gradle supports both local and remote build caches.
   
   == Task dependencies
   
   Gradle inherently understands the dependencies among tasks.
   Consequently, it can determine the tasks that need execution when you target a specific task.
   
   Let's add a dependency to our example `app` subproject and turn it into an application by modifying the settings file and the file script of our example:
   
   ====
   [.multi-language-sample]
   =====
   .settings.gradle.kts
   [source,kotlin]
   ----
   rootProject.name = "gradle-project"
   include("app")
   include("some-logic")
   ----
   =====
   [.multi-language-sample]
   =====
   .settings.gradle
   [source,groovy]
   ----
   rootProject.name = 'gradle-project'
   include('app')
   include('some-logic')
   ----
   =====
   ====
   
   Let's imagine that the `app` subproject now depends on another subproject called `some-logic`, which contains some Java code.
   We then add this dependency in the `app` build script:
   
   ====
   [.multi-language-sample]
   =====
   .app/build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("application")                       // app is now a java application
   }
   
   application {
       mainClass.set("hello.HelloWorld")       // main class name required by the application plugin
   }
   
   dependencies {
       implementation(project(":some-logic"))  // dependency on some-logic
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .app/build.gradle
   [source,groovy]
   ----
   plugins {
       id('application')                       // app is now a java application
   }
   
   application {
       mainClass = 'hello.HelloWorld'          // main class name required by the application plugin
   }
   
   dependencies {
       implementation(project(':some-logic'))  // dependency on some-logic
   }
   ----
   =====
   ====
   
   If we run `:app:build` again, we see the Java code of `some-logic` is also compiled by Gradle automatically:
   
   [source,text]
   ----
   $./gradlew :app:build
   
   > Task :app:processResources NO-SOURCE
   > Task :app:processTestResources NO-SOURCE
   > Task :some-logic:compileJava UP-TO-DATE
   > Task :some-logic:processResources NO-SOURCE
   > Task :some-logic:classes UP-TO-DATE
   > Task :some-logic:jar UP-TO-DATE
   > Task :app:compileJava
   > Task :app:classes
   > Task :app:jar UP-TO-DATE
   > Task :app:startScripts
   > Task :app:distTar
   > Task :app:distZip
   > Task :app:assemble
   > Task :app:compileTestJava UP-TO-DATE
   > Task :app:testClasses UP-TO-DATE
   > Task :app:test
   > Task :app:check
   > Task :app:build
   
   BUILD SUCCESSFUL in 430ms
   9 actionable tasks: 5 executed, 4 up-to-date
   ----
   
   == Developing tasks
   
   When developing Gradle tasks, you have two choices:
   
   1. Use an existing Gradle task type such as `Zip`, `Copy`, or `Delete`
   2. Create your own Gradle task type such as `MyResolveTask` or `CustomTaskUsingToolchains`.
   
   Task types are simply subclasses of the Gradle link:{javadocPath}#[`Task`] class.
   
   We refer to item (2) as *implementing* a Gradle task which involves extending Gradle's link:{javadocPath}#[`DefaultTask`] class.
   
   When using Gradle tasks, there are two states to consider:
   
   1. *Registering* a task - using a task (implemented by you or provided by Gradle) in your build logic.
   2. *Configuring* a task - defining inputs and outputs for a registered task.
   
   Registration is commonly done with the link:{javadocPath}#[`register()`] method.
   Configuring a task is commonly done with the link:{javadocPath}#[`named()`] method:
   
   ====
   [.multi-language-sample]
   =====
   [source,kotlin]
   ----
   tasks.register<Copy>("myCopy")                              // <1>
   
   tasks.named<Copy>("myCopy") {                               // <2>
       from("resources")
       into("target")
       include("**/*.txt", "**/*.xml", "**/*.properties")
   }
   ----
   <1> Register the `myCopy` task of type `Copy` to let Gradle know we intend to use it in our build logic.
   <2> Configure the registered `myCopy` task with the inputs and outputs it needs according to its link:{javadocPath}#[API].
   =====
   [.multi-language-sample]
   =====
   [source,groovy]
   ----
   tasks.register(Copy, "myCopy")                              // <1>
   
   tasks.named(Copy, "myCopy") {                               // <2>
       from "resources"
       into "target"
       include "**/*.txt", "**/*.xml", "**/*.properties"
   }
   ----
   <1> Register the `myCopy` task of type `Copy` to let Gradle know we intend to use it in our build logic.
   <2> Configure the registered `myCopy` task with the inputs and outputs it needs according to its link:{javadocPath}#[API].
   =====
   ====
   
   == Registering tasks
   
   You define actions for Gradle to take by registering tasks in build scripts or plugins.
   
   Tasks are defined using strings for task names:
   
   ====
   include::sample[dir="snippets/tasks/defineUsingStringTaskNames/kotlin",files="build.gradle.kts[tags=simple_register]"]
   include::sample[dir="snippets/tasks/defineUsingStringTaskNames/groovy",files="build.gradle[tags=simple_register]"]
   ====
   
   In the example above, the task is added to the link:{javadocPath}#[`TasksCollection`] using the link:{javadocPath}#[`register()`] method in link:{javadocPath}#[`TaskContainer`].
   
   == Configuring tasks
   
   Gradle tasks must be configured to complete their action(s) successfully.
   If a task needs to ZIP a file, it must be configured with the file name and location.
   You can refer to the link:{javadocPath}#[API] for the Gradle `Zip` task to learn how to configure it appropriately.
   
   Let뗩 look at the `Copy` task provided by Gradle as an example.
   We first register a task called `myCopy` of type `Copy` in the build script:
   
   ====
   include::sample[dir="snippets/tasks/configureUsingBlock/kotlin",files="build.gradle.kts[tags=declare-task]"]
   include::sample[dir="snippets/tasks/configureUsingBlock/groovy",files="build.gradle[tags=declare-task]"]
   ====
   
   This registers a copy task with no default behavior.
   Since the task is of type `Copy`, a Gradle supported task type, it can be configured using its link:{javadocPath}#[API].
   
   The following examples show several ways to achieve the same configuration:
   
   === 1. Using the `named()` method:
   
   Use `named()` to configure an existing task registered elsewhere:
   
   ====
   include::sample[dir="snippets/tasks/configureUsingVar/kotlin",files="build.gradle.kts[tags=configure]"]
   include::sample[dir="snippets/tasks/configureUsingVar/groovy",files="build.gradle[tags=configure]"]
   ====
   
   === 2. Using a configuration block:
   
   Use a block to configure the task immediately upon registering it:
   
   ====
   include::sample[dir="snippets/tasks/defineAndConfigure/kotlin",files="build.gradle.kts[tags=no-description]"]
   include::sample[dir="snippets/tasks/defineAndConfigure/groovy",files="build.gradle[tags=no-description]"]
   ====
   
   === 3. Name method as call:
   
   A popular option that is only supported in Groovy is the shorthand notation:
   
   [source,groovy]
   ----
   copy {
       from("resources")
       into("target")
       include("**/*.txt", "**/*.xml", "**/*.properties")
   }
   ----
   
   NOTE: This option breaks task configuration avoidance and is not recommended!
   
   Regardless of the method chosen, the task is configured with the name of the files to be copied and the location of the files.
   
   == Implementing tasks
   
   Gradle provides many task types including `Delete`, `Javadoc`, `Copy`, `Exec`, `Tar`, and `Pmd`.
   You can implement a custom task type if Gradle does not provide a task type that meets your build logic needs.
   
   To create a custom task class, you extend link:{javadocPath}#[`DefaultTask`] and make the extending class abstract:
   
   ====
   include::sample[dir="snippets/tasks/customTask/kotlin",files="build.gradle.kts[tags=define-task]"]
   include::sample[dir="snippets/tasks/customTask/groovy",files="build.gradle[tags=define-task]"]
   ====
   
   You can learn more about developing custom task types in <<more_about_tasks.adoc#sec:implementing_tasks,Implementing Tasks>>.
   
   == Task configuration avoidance
   
   To significantly reduce build time, Gradle provides the configuration avoidance API.
   
   The configuration avoidance API avoids configuring tasks if they are not used for a build.
   For example, when running a `compile` task (with the `java` plugin applied), other unrelated tasks (such as `clean`, `test`, `javadocs`), will not be executed.
   
   To avoid creating and configuring a task not needed for a build, you should use the link:{javadocPath}#[`register()`] method instead of the `create()` method in link:{javadocPath}#[TaskContainer].
   
   When a task is registered using the link:{javadocPath}#[`register()`] method, it is known to the build.
   The method provides a link:{javadocPath}#[`TaskProvider`].
   It can be configured, and references to it can be passed around, but the task object itself has not been created, and its actions have not been executed.
   The registered task will remain in this state until something in the build needs the instantiated task object.
   If the task object is never needed, the task will remain registered, and the cost of creating and configuring the task will be avoided.
   
   You can learn more about best practices for task configuration avoidance in <<task_configuration_avoidance.adoc#task_configuration_avoidance,Avoiding Unnecessary Task Configuration>>.
   
   == Adding dependencies
   
   There are several ways you can define the dependencies of a task.
   
   Defining dependencies using task names and the link:{javadocPath}#[dependsOn()`] method is simplest.
   
   The following is an example which adds a dependency from `taskX` to `taskY`:
   
   ====
   [.multi-language-sample]
   =====
   [source,kotlin]
   ----
   tasks.register("taskX") {
       dependsOn("taskY")
   }
   ----
   =====
   [.multi-language-sample]
   =====
   [source,groovy]
   ----
   tasks.register("taskX") {
       dependsOn "taskY"
   }
   ----
   =====
   ====
   
   ====
   ----
   $ gradle -q taskX
   include::{snippetsPath}/tasks/addDependencyUsingPath/tests/addDependencyUsingPath.out[]
   ----
   ====
   
   For more information about task dependencies, see the link:{javadocPath}#[Task] API.
   
   == Ordering tasks
   
   In some cases, it is useful to control the _order_ in which two tasks will execute, without introducing an explicit dependency between those tasks.
   
   The primary difference between a task _ordering_ and a task _dependency_ is that an ordering rule does not influence which tasks will be executed, only the order in which they will be executed.
   
   Task ordering can be useful in a number of scenarios:
   
   * Enforce sequential ordering of tasks (e.g., `build` never runs before `clean`).
   * Run build validations early in the build (e.g., validate I have the correct credentials before starting the work for a release build).
   * Get feedback faster by running quick verification tasks before long verification tasks (e.g., unit tests should run before integration tests).
   * A task that aggregates the results of all tasks of a particular type (e.g., test report task combines the outputs of all executed test tasks).
   
   Two ordering rules are available: "_must run after_" and "_should run after_".
   
   To specify a "must run after" or "should run after" ordering between 2 tasks, you use the link:{javadocPath}#[Task.mustRunAfter(java.lang.Object++...++)] and link:{javadocPath}#[Task.shouldRunAfter(java.lang.Object++...++)] methods.
   These methods accept a task instance, a task name, or any other input accepted by link:{javadocPath}#[Task.dependsOn(java.lang.Object++...++)].
   
   When you use "must run after", you specify that `taskY` must always run after `taskX` when the build requires the execution of `taskX` and `taskY`.
   So if you only run `taskY` with `mustRunAfter`, you won't cause `taskX` to run.
   This is expressed as `taskY.mustRunAfter(taskX)`.
   
   ====
   include::sample[dir="snippets/tasks/mustRunAfter/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/tasks/mustRunAfter/groovy",files="build.gradle[]"]
   
   ----
   $ gradle -q taskY taskX
   include::{snippetsPath}/tasks/mustRunAfter/tests/mustRunAfter.out[]
   ----
   ====
   
   The "should run after" ordering rule is similar but less strict, as it will be ignored in two situations:
   
   1. If using that rule introduces an ordering cycle.
   2. When using parallel execution and all task dependencies have been satisfied apart from the "should run after" task, then this task will be run regardless of whether or not its "should run after" dependencies have been run.
   
   You should use "should run after" where the ordering is helpful but not strictly required:
   
   ====
   include::sample[dir="snippets/tasks/shouldRunAfter/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/tasks/shouldRunAfter/groovy",files="build.gradle[]"]
   
   ----
   $ gradle -q taskY taskX
   include::{snippetsPath}/tasks/shouldRunAfter/tests/shouldRunAfter.out[]
   ----
   ====
   
   In the examples above, it is still possible to execute `taskY` without causing `taskX` to run:
   
   ====
   ----
   $ gradle -q taskY
   include::{snippetsPath}/tasks/mustRunAfter/tests/mustRunAfterSingleTask.out[]
   ----
   ====
   
   The 랍hould run after ordering rule will be ignored if it introduces an ordering cycle:
   
   ====
   include::sample[dir="snippets/tasks/shouldRunAfterWithCycle/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/tasks/shouldRunAfterWithCycle/groovy",files="build.gradle[]"]
   
   ----
   $ gradle -q taskX
   include::{snippetsPath}/tasks/shouldRunAfterWithCycle/tests/shouldRunAfterWithCycle.out[]
   ----
   ====
   
   Note that `taskY.mustRunAfter(taskX)` or `taskY.shouldRunAfter(taskX)` does not imply any execution dependency between the tasks:
   
   * It is possible to execute `taskX` and `taskY` independently. The ordering rule only has an effect when both tasks are scheduled for execution.
   * When run with `--continue`, it is possible for `taskY` to execute if `taskX` fails.
   
   == Finalizer tasks
   
   Finalizer tasks are automatically added to the task graph when the finalized task is scheduled to run.
   
   To specify a finalizer task, you use the link:{javadocPath}#[Task.finalizedBy(java.lang.Object...)] method.
   This method accepts a task instance, a task name, or any other input accepted by link:{javadocPath}#[Task.dependsOn(java.lang.Object...)]:
   
   ====
   include::sample[dir="snippets/tasks/finalizers/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/tasks/finalizers/groovy",files="build.gradle[]"]
   
   ----
   $ gradle -q taskX
   include::{snippetsPath}/tasks/finalizers/tests/taskFinalizers.out[]
   ----
   ====
   
   Finalizer tasks are executed even if the finalized task fails or if the finalized task is considered `UP-TO-DATE`:
   
   ====
   include::sample[dir="snippets/tasks/finalizersWithFailure/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/tasks/finalizersWithFailure/groovy",files="build.gradle[]"]
   
   ----
   $ gradle -q taskX
   include::{snippetsPath}/tasks/finalizersWithFailure/tests-groovy/taskFinalizersWithFailureGroovy.out[]
   ----
   ====
   
   Finalizer tasks are useful when the build creates a resource that must be cleaned up, regardless of whether the build fails or succeeds.
   An example of such a resource is a web container that is started before an integration test task and must be shut down, even if some tests fail.
   
   == Skipping tasks
   
   Gradle offers multiple ways to skip the execution of a task.
   
   === 1. Using a predicate
   
   You can use link:{javadocPath}#[`Task.onlyIf`] to attach a predicate to a task.
   The task's actions will only be executed if the predicate is evaluated to be `true`.
   
   The predicate is passed to the task as a parameter and returns `true` if the task will execute and `false` if the task will be skipped.
   The predicate is evaluated just before the task is executed.
   
   Passing an optional reason string to `onlyIf()` is useful for explaining why the task is skipped:
   
   ====
   include::sample[dir="snippets/tutorial/taskOnlyIf/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/tutorial/taskOnlyIf/groovy",files="build.gradle[]"]
   
   ----
   $ gradle hello -PskipHello
   include::{snippetsPath}/tutorial/taskOnlyIf/tests/taskOnlyIf.out[]
   ----
   ====
   
   To find why a task was skipped, run the build with the `--info` logging level.
   
   ====
   ----
   $ gradle hello -PskipHello --info
   include::{snippetsPath}/tutorial/taskOnlyIf/tests/taskOnlyIf-info.out[]
   ----
   ====
   
   === 2. Using `StopExecutionException`
   
   If the logic for skipping a task can't be expressed with a predicate, you can use the link:{javadocPath}#[`StopExecutionException`].
   
   If this exception is thrown by an action, the task action as well as the execution of any following action is skipped.
   The build continues by executing the next task:
   
   ====
   include::sample[dir="snippets/tutorial/stopExecutionException/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/tutorial/stopExecutionException/groovy",files="build.gradle[]"]
   
   ----
   $ gradle -q myTask
   include::{snippetsPath}/tutorial/stopExecutionException/tests/stopExecutionException.out[]
   ----
   ====
   
   This feature is helpful if you work with tasks provided by Gradle.
   It allows you to add _conditional_ execution of the built-in actions of such a task.footnote:[You might be wondering why there is neither an import for the `StopExecutionException` nor do we access it via its fully qualified name. The reason is that Gradle adds a set of default imports to your script (see <<writing_build_scripts.adoc#script-default-imports,Default imports>>).]
   
   === 3. Enabling and Disabling tasks
   
   Every task has an `enabled` flag, which defaults to `true`.
   Setting it to `false` prevents executing the task's actions.
   
   A disabled task will be labeled `SKIPPED`:
   
   ====
   include::sample[dir="snippets/tutorial/disableTask/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/tutorial/disableTask/groovy",files="build.gradle[]"]
   
   ----
   $ gradle disableMe
   include::{snippetsPath}/tutorial/disableTask/tests/disableTask.out[]
   ----
   ====
   
   === 4. Task timeouts
   
   Every task has a `timeout` property, which can be used to limit its execution time.
   When a task reaches its timeout, its task execution thread is interrupted.
   The task will be marked as `FAILED`.
   
   <<sec:finalizer_tasks,Finalizer tasks>> are executed.
   If `--continue` is used, other tasks continue running.
   
   Tasks that don't respond to interrupts can't be timed out.
   All of Gradle's built-in tasks respond to timeouts.
   
   ====
   include::sample[dir="snippets/tasks/timeout/kotlin",files="build.gradle.kts[tags=without-import]"]
   include::sample[dir="snippets/tasks/timeout/groovy",files="build.gradle[]"]
   ====
   
   

/docs/userguide/authoring-builds/tasks/lifecycle_tasks.adoc
===========================================================

.. code-block::

   = Lifecycle Tasks
   
   Lifecycle tasks are tasks that do not do work themselves.
   These tasks have no actions.
   They serve as _targets_ for the build.
   
   image::writing-tasks-2.png[]
   
   Lifecycle tasks represent various concepts:
   
   * a work-flow step (e.g., run all checks with `check`)
   * a buildable thing (e.g., create a debug 32-bit executable for native components with `debug32MainExecutable`)
   * a convenience task to execute many of the same logical tasks (e.g., run all compilation tasks with `compileAll`)
   
   The <<base_plugin.adoc#base_plugin,Gradle `base` plugin>> defines several lifecycle tasks, including `build`, `assemble`, and `check`.
   
   A well-organized setup of lifecycle tasks enhances the accessibility of your build for new users and simplifies integration with CI.
   
   == Task group and description
   
   Let's consider a basic Java application as an example.
   The build contains a subproject called `app`.
   
   Let's list the available tasks in `app` at the moment:
   
   [source, text]
   ----
   $ ./gradlew :app:tasks
   
   > Task :app:tasks
   
   ------------------------------------------------------------
   Tasks runnable from project ':app'
   ------------------------------------------------------------
   
   Application tasks
   -----------------
   run - Runs this project as a JVM application
   
   Build tasks
   -----------
   assemble - Assembles the outputs of this project.
   ----
   
   When listing available tasks in the `app` subproject, we see that tasks are grouped.
   Here, the `:run` task is part of the `Application` group with the description `Runs this project as a JVM application`.
   
   == Private and hidden tasks
   
   Gradle doesn't support marking a task as _private_.
   
   However, tasks will only show up when running `:tasks` if `task.group` is set or no other task depends on it.
   
   For instance, the following task will not appear when running `./gradlew :app:tasks` because it does not have a group; it is called a _hidden_ task:
   
   ====
   [.multi-language-sample]
   =====
   .app/build.gradle.kts
   [source,kotlin]
   ----
   tasks.register("helloTask") {
       println("Hello")
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .app/build.gradle
   [source,groovy]
   ----
   tasks.register("helloTask") {
       println("Hello")
   }
   ----
   =====
   ====
   
   Although `helloTask` is not listed, it can still be executed by Gradle:
   
   [source, text]
   ----
   $ ./gradlew :app:tasks
   
   > Task :app:tasks
   
   ------------------------------------------------------------
   Tasks runnable from project ':app'
   ------------------------------------------------------------
   
   Application tasks
   -----------------
   run - Runs this project as a JVM application
   
   Build tasks
   -----------
   assemble - Assembles the outputs of this project.
   ----
   
   Let's add a group to the same task:
   
   ====
   [.multi-language-sample]
   =====
   .app/build.gradle.kts
   [source,kotlin]
   ----
   tasks.register("helloTask") {
       group = "Other"
       println("Hello")
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .app/build.gradle
   [source,groovy]
   ----
   tasks.register("helloTask") {
       group = "Other"
       println("Hello")
   }
   ----
   =====
   ====
   
   Now that the group is added, the task is visible:
   
   [source, text]
   ----
   $ ./gradlew :app:tasks
   
   > Task :app:tasks
   
   ------------------------------------------------------------
   Tasks runnable from project ':app'
   ------------------------------------------------------------
   
   Application tasks
   -----------------
   run - Runs this project as a JVM application
   
   Build tasks
   -----------
   assemble - Assembles the outputs of this project.
   
   Other tasks
   -----------
   helloTask
   ----
   
   In contrast, `./gradlew tasks --all` will show all tasks; _hidden_ and _visible_ tasks are listed.
   
   == Grouping tasks
   
   If you want to customize which tasks are shown to users when listed, you can group tasks and set the visibility of each group.
   
   NOTE: Remember, even if you _hide_ tasks, they are still available, and Gradle can still run them.
   
   Let's start with an example built by Gradle `init` for a Java application with multiple subprojects.
   The project structure is as follows:
   
   ====
   [.multi-language-sample]
   =====
   [source,kotlin]
   ----
   gradle-project
   較럭較 app
   較   較럭較 build.gradle.kts
   較   較덕較 src                 // some java code
   較       較덕較 ...
   較럭較 utilities
   較   較럭較 build.gradle.kts
   較   較덕較 src                 // some java code
   較       較덕較 ...
   較럭較 list
   較   較럭較 build.gradle.kts
   較   較덕較 src                 // some java code
   較       較덕較 ...
   較럭較 buildSrc
   較   較럭較 build.gradle.kts
   較   較럭較 settings.gradle.kts
   較   較덕較 src                 // common build logic
   較       較덕較 ...
   較럭較 settings.gradle.kts
   較럭較 gradle
   較럭較 gradlew
   較덕較 gradlew.bat
   ----
   =====
   [.multi-language-sample]
   =====
   [source,groovy]
   ----
   gradle-project
   較럭較 app
   較   較럭較 build.gradle
   較   較덕較 src             // some java code
   較       較덕較 ...
   較럭較 utilities
   較   較럭較 build.gradle
   較   較덕較 src             // some java code
   較       較덕較 ...
   較럭較 list
   較   較럭較 build.gradle
   較   較덕較 src             // some java code
   較       較덕較 ...
   較럭較 buildSrc
   較   較럭較 build.gradle
   較   較럭較 settings.gradle
   較   較덕較 src             // common build logic
   較       較덕較 ...
   較럭較 settings.gradle
   較럭較 gradle
   較럭較 gradlew
   較덕較 gradlew.bat
   ----
   =====
   ====
   
   Run `app:tasks` to see available tasks in the `app` subproject:
   
   [source,text]
   ----
   $ ./gradlew :app:tasks
   
   > Task :app:tasks
   
   ------------------------------------------------------------
   Tasks runnable from project ':app'
   ------------------------------------------------------------
   
   Application tasks
   -----------------
   run - Runs this project as a JVM application
   
   Build tasks
   -----------
   assemble - Assembles the outputs of this project.
   build - Assembles and tests this project.
   buildDependents - Assembles and tests this project and all projects that depend on it.
   buildNeeded - Assembles and tests this project and all projects it depends on.
   classes - Assembles main classes.
   clean - Deletes the build directory.
   jar - Assembles a jar archive containing the classes of the 'main' feature.
   testClasses - Assembles test classes.
   
   Distribution tasks
   ------------------
   assembleDist - Assembles the main distributions
   distTar - Bundles the project as a distribution.
   distZip - Bundles the project as a distribution.
   installDist - Installs the project as a distribution as-is.
   
   Documentation tasks
   -------------------
   javadoc - Generates Javadoc API documentation for the 'main' feature.
   
   Help tasks
   ----------
   buildEnvironment - Displays all buildscript dependencies declared in project ':app'.
   dependencies - Displays all dependencies declared in project ':app'.
   dependencyInsight - Displays the insight into a specific dependency in project ':app'.
   help - Displays a help message.
   javaToolchains - Displays the detected java toolchains.
   kotlinDslAccessorsReport - Prints the Kotlin code for accessing the currently available project extensions and conventions.
   outgoingVariants - Displays the outgoing variants of project ':app'.
   projects - Displays the sub-projects of project ':app'.
   properties - Displays the properties of project ':app'.
   resolvableConfigurations - Displays the configurations that can be resolved in project ':app'.
   tasks - Displays the tasks runnable from project ':app'.
   
   Verification tasks
   ------------------
   check - Runs all checks.
   test - Runs the test suite.
   ----
   
   If we look at the list of tasks available, even for a standard Java project, it's extensive.
   Many of these tasks are rarely required directly by developers using the build.
   
   We can configure the `:tasks` task and limit the tasks shown to a certain group.
   
   Let's create our own group so that all tasks are hidden by default by updating the `app` build script:
   
   ====
   [.multi-language-sample]
   =====
   .app/build.gradle.kts
   [source,kotlin]
   ----
   val myBuildGroup = "my app build"               // Create a group name
   
   tasks.register<TaskReportTask>("tasksAll") {    // Register the tasksAll task
       group = myBuildGroup
       description = "Show additional tasks."
       setShowDetail(true)
   }
   
   tasks.named<TaskReportTask>("tasks") {          // Move all existing tasks to the group
       displayGroup = myBuildGroup
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .app/build.gradle
   [source,groovy]
   ----
   def myBuildGroup = "my app build"               // Create a group name
   
   tasks.register(TaskReportTask, "tasksAll") {    // Register the tasksAll task
       group = myBuildGroup
       description = "Show additional tasks."
       setShowDetail(true)
   }
   
   tasks.named(TaskReportTask, "tasks") {          // Move all existing tasks to the group
       displayGroup = myBuildGroup
   }
   ----
   =====
   ====
   
   Now, when we list tasks available in `app`, the list is shorter:
   
   [source, text]
   ----
   $ ./gradlew :app:tasks
   
   > Task :app:tasks
   
   ------------------------------------------------------------
   Tasks runnable from project ':app'
   ------------------------------------------------------------
   
   My app build tasks
   ------------------
   tasksAll - Show additional tasks.
   ----
   
   == Lifecycle tasks
   
   Lifecycle tasks can be particularly beneficial for separating work between users or machines (CI vs local).
   For example, a developer on a local machine might not want to run an entire build on every single change.
   
   Let's expose three additional tasks in our example, the `build` task, the `check` task, and the `run` task by adding the following lines to the `app` build script:
   
   ====
   [.multi-language-sample]
   =====
   .app/build.gradle.kts
   [source,kotlin]
   ----
   tasks.build {
       group = myBuildGroup
   }
   
   tasks.check {
       group = myBuildGroup
       description = "Runs checks (including tests)."
   }
   
   tasks.named("run") {
       group = myBuildGroup
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .app/build.gradle
   [source,groovy]
   ----
   tasks.build {
       group = myBuildGroup
   }
   
   tasks.check {
       group = myBuildGroup
       description = "Runs checks (including tests)."
   }
   
   tasks.named('run') {
       group = myBuildGroup
   }
   ----
   =====
   ====
   
   If we now look at the `app:tasks` list, we can see the three tasks are available:
   
   [source, text]
   ----
   $ ./gradlew :app:tasks
   
   > Task :app:tasks
   
   ------------------------------------------------------------
   Tasks runnable from project ':app'
   ------------------------------------------------------------
   
   My app build tasks
   ------------------
   build - Assembles and tests this project.
   check - Runs checks (including tests).
   run - Runs this project as a JVM application
   tasksAll - Show additional tasks.
   ----
   
   This is already useful if the standard lifecycle tasks are sufficient.
   Moving the groups around helps clarify the tasks you expect to used in your build.
   
   In many cases, there are more specific requirements that you want to address.
   One common scenario is running quality checks without running tests.
   Currently, the `:check` task runs tests and the code quality checks.
   Instead, we want to run code quality checks all the time, but not the lengthy test.
   
   To add a quality check lifecycle task, we introduce an additional lifecycle task called `qualityCheck` and a plugin called link:https://github.com/spotbugs/spotbugs[`spotbugs`].
   
   To add a lifecycle task, use link:{javadocPath}#[`tasks.register()`].
   The only thing you need to provide is a name.
   Put this task in our group and wire the actionable tasks that belong to this new lifecycle task using the link:{javadocPath}#[`dependsOn()`] method:
   
   ====
   [.multi-language-sample]
   =====
   .app/build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("com.github.spotbugs") version "6.0.7"           // spotbugs plugin
   }
   
   tasks.register("qualityCheck") {                        // qualityCheck task
       group = myBuildGroup                                // group
       description = "Runs checks (excluding tests)."      // description
       dependsOn(tasks.classes, tasks.spotbugsMain)        // dependencies
       dependsOn(tasks.testClasses, tasks.spotbugsTest)    // dependencies
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .app/build.gradle
   [source,groovy]
   ----
   plugins {
       id 'com.github.spotbugs' version '6.0.7'            // spotbugs plugin
   }
   
   tasks.register('qualityCheck') {                        // qualityCheck task
       group = myBuildGroup                                // group
       description = 'Runs checks (excluding tests).'      // description
       dependsOn tasks.classes, tasks.spotbugsMain         // dependencies
       dependsOn tasks.testClasses, tasks.spotbugsTest     // dependencies
   }
   ----
   =====
   ====
   
   Note that you don't need to list all the tasks that Gradle will execute.
   Just specify the targets you want to collect here.
   Gradle will determine which other tasks it needs to call to reach these goals.
   
   In the example, we add the `classes` task, a lifecycle task to compile all our production code, and the `spotbugsMain` task, which checks our production code.
   
   We also add a description that will show up in the task list that helps distinguish the two check tasks better.
   
   Now, if run './gradlew :app:tasks', we can see that our new `qualityCheck` lifecycle task is available:
   
   [source, text]
   ----
   $ ./gradlew :app:tasks
   
   > Task :app:tasks
   
   ------------------------------------------------------------
   Tasks runnable from project ':app'
   ------------------------------------------------------------
   
   My app build tasks
   ------------------
   build - Assembles and tests this project.
   check - Runs checks (including tests).
   qualityCheck - Runs checks (excluding tests).
   run - Runs this project as a JVM application
   tasksAll - Show additional tasks.
   ----
   
   If we run it, we can see that it runs checkstyle but not the tests:
   
   [source,text]
   ----
   $ ./gradlew :app:qualityCheck
   
   > Task :buildSrc:checkKotlinGradlePluginConfigurationErrors
   > Task :buildSrc:generateExternalPluginSpecBuilders UP-TO-DATE
   > Task :buildSrc:extractPrecompiledScriptPluginPlugins UP-TO-DATE
   > Task :buildSrc:compilePluginsBlocks UP-TO-DATE
   > Task :buildSrc:generatePrecompiledScriptPluginAccessors UP-TO-DATE
   > Task :buildSrc:generateScriptPluginAdapters UP-TO-DATE
   > Task :buildSrc:compileKotlin UP-TO-DATE
   > Task :buildSrc:compileJava NO-SOURCE
   > Task :buildSrc:compileGroovy NO-SOURCE
   > Task :buildSrc:pluginDescriptors UP-TO-DATE
   > Task :buildSrc:processResources UP-TO-DATE
   > Task :buildSrc:classes UP-TO-DATE
   > Task :buildSrc:jar UP-TO-DATE
   > Task :app:processResources NO-SOURCE
   > Task :app:processTestResources NO-SOURCE
   > Task :list:compileJava UP-TO-DATE
   > Task :utilities:compileJava UP-TO-DATE
   > Task :app:compileJava
   > Task :app:classes
   > Task :app:compileTestJava
   > Task :app:testClasses
   > Task :app:spotbugsTest
   > Task :app:spotbugsMain
   > Task :app:qualityCheck
   
   BUILD SUCCESSFUL in 1s
   16 actionable tasks: 5 executed, 11 up-to-date
   ----
   
   So far, we have looked at tasks in individual subprojects, which is useful for local development when you work on code in one subproject.
   
   With this setup, developers only need to know that they can call Gradle with `:subproject-name:tasks` to see which tasks are available and useful for them.
   
   == Global lifecycle tasks
   
   Another place to invoke lifecycle tasks is within the root build; this is especially useful for Continuous Integration (CI).
   
   Gradle tasks play a crucial role in CI or CD systems, where activities like compiling all code, running tests, or building and packaging the complete application are typical.
   To facilitate this, you can include lifecycle tasks that span multiple subprojects.
   
   NOTE: Gradle has been around for a long time, and you will frequently observe build files in the root directory serving various purposes.
   In older Gradle versions, many tasks were defined within the root Gradle build file, resulting in various issues.
   Therefore, exercise caution when determining the content of this file.
   
   One of the few elements that should be placed in the root build file is global lifecycle tasks.
   
   Let's continue using the Gradle `init` Java application multi-project as an example.
   
   This time, we're incorporating a build script in the root project.
   We'll establish two groups for our global lifecycle tasks: one for tasks relevant to local development, such as running all checks, and another exclusively for our CI system.
   
   Once again, we narrowed down the tasks listed to our specific groups:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   val globalBuildGroup = "My global build"
   val ciBuildGroup = "My CI build"
   
   tasks.named<TaskReportTask>("tasks") {
       displayGroups = listOf<String>(globalBuildGroup, ciBuildGroup)
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   def globalBuildGroup = "My global build"
   def ciBuildGroup = "My CI build"
   
   tasks.named(TaskReportTask, "tasks") {
       displayGroups = [globalBuildGroup, ciBuildGroup]
   }
   ----
   =====
   ====
   
   You could hide the CI tasks if you wanted to by updating `displayGroups`.
   
   Currently, the root project exposes no tasks:
   
   [source, text]
   ----
   $ ./gradlew :tasks
   
   > Task :tasks
   
   ------------------------------------------------------------
   Tasks runnable from root project 'gradle-project'
   ------------------------------------------------------------
   
   No tasks
   ----
   
   NOTE: In this file, we don't apply a plugin!
   
   Let's add a `qualityCheckApp` task to execute all code quality checks in the `app` subproject.
   Similarly, for CI purposes, we implement a `checkAll` task that runs all tests:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   tasks.register("qualityCheckApp") {
       group = globalBuildGroup
       description = "Runs checks on app (globally)"
       dependsOn(":app:qualityCheck" )
   }
   
   tasks.register("checkAll") {
       group = ciBuildGroup
       description = "Runs checks for all projects (CI)"
       dependsOn(subprojects.map { ":${it.name}:check" })
       dependsOn(gradle.includedBuilds.map { it.task(":checkAll") })
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   tasks.register("qualityCheckApp") {
       group = globalBuildGroup
       description = "Runs checks on app (globally)"
       dependsOn(":app:qualityCheck")
   }
   
   tasks.register("checkAll") {
       group = ciBuildGroup
       description = "Runs checks for all projects (CI)"
       dependsOn subprojects.collect { ":${it.name}:check" }
       dependsOn gradle.includedBuilds.collect { it.task(":checkAll") }
   }
   ----
   =====
   ====
   
   So we can now ask Gradle to show us the tasks for the root project and, by default, it will only show us the `qualityCheckAll` task (and optionally the `checkAll` task depending on the value of `displayGroups`).
   
   It should be clear what a user should run locally:
   
   [source, text]
   ----
   $ ./gradlew :tasks
   
   > Task :tasks
   
   ------------------------------------------------------------
   Tasks runnable from root project 'gradle-project'
   ------------------------------------------------------------
   
   My CI build tasks
   -----------------
   checkAll - Runs checks for all projects (CI)
   
   My global build tasks
   ---------------------
   qualityCheckApp - Runs checks on app (globally)
   ----
   
   If we run the `:checkAll` task, we see that it compiles all the code and runs the code quality checks (including `spotbug`):
   
   [source,text]
   ----
   $ ./gradlew :checkAll
   
   > Task :buildSrc:checkKotlinGradlePluginConfigurationErrors
   > Task :buildSrc:generateExternalPluginSpecBuilders UP-TO-DATE
   > Task :buildSrc:extractPrecompiledScriptPluginPlugins UP-TO-DATE
   > Task :buildSrc:compilePluginsBlocks UP-TO-DATE
   > Task :buildSrc:generatePrecompiledScriptPluginAccessors UP-TO-DATE
   > Task :buildSrc:generateScriptPluginAdapters UP-TO-DATE
   > Task :buildSrc:compileKotlin UP-TO-DATE
   > Task :buildSrc:compileJava NO-SOURCE
   > Task :buildSrc:compileGroovy NO-SOURCE
   > Task :buildSrc:pluginDescriptors UP-TO-DATE
   > Task :buildSrc:processResources UP-TO-DATE
   > Task :buildSrc:classes UP-TO-DATE
   > Task :buildSrc:jar UP-TO-DATE
   > Task :utilities:processResources NO-SOURCE
   > Task :app:processResources NO-SOURCE
   > Task :utilities:processTestResources NO-SOURCE
   > Task :app:processTestResources NO-SOURCE
   > Task :list:compileJava
   > Task :list:processResources NO-SOURCE
   > Task :list:classes
   > Task :list:jar
   > Task :utilities:compileJava
   > Task :utilities:classes
   > Task :utilities:jar
   > Task :utilities:compileTestJava NO-SOURCE
   > Task :utilities:testClasses UP-TO-DATE
   > Task :utilities:test NO-SOURCE
   > Task :utilities:check UP-TO-DATE
   > Task :list:compileTestJava
   > Task :list:processTestResources NO-SOURCE
   > Task :list:testClasses
   > Task :app:compileJava
   > Task :app:classes
   > Task :app:compileTestJava
   > Task :app:testClasses
   > Task :list:test
   > Task :list:check
   > Task :app:test
   > Task :app:spotbugsTest
   > Task :app:spotbugsMain
   > Task :app:check
   > Task :checkAll
   
   BUILD SUCCESSFUL in 1s
   21 actionable tasks: 12 executed, 9 up-to-date
   ----
   
   == Task name abbreviation
   
   When specifying tasks on the command line, providing the complete task name is unnecessary.
   You can provide enough of the task name to identify the task uniquely.
   
   For example, instead of running `./gradlew :checkAll`, we can run `./gradlew :chAl`:
   
   [source,text]
   ----
   $ ./gradlew :chAl
   
   > Task :buildSrc:checkKotlinGradlePluginConfigurationErrors
   > Task :buildSrc:generateExternalPluginSpecBuilders UP-TO-DATE
   ...
   > Task :app:test UP-TO-DATE
   > Task :app:check UP-TO-DATE
   > Task :checkAll UP-TO-DATE
   
   BUILD SUCCESSFUL in 412ms
   21 actionable tasks: 1 executed, 20 up-to-date
   ----
   
   The same applies to project names.
   You can execute the `:check` task in the `utitlities` subproject with the `gradle uti:che` command.
   
   You can use https://en.wikipedia.org/wiki/Camel_case[camel case] patterns for more complex abbreviations.
   
   Calling tasks without the colon `:` in front is not advised.
   If you do so, Gradle will attempt to find matching tasks in all the subprojects, and you won't precisely know which tasks will be invoked.
   For instance, Gradle will skip projects where the task is unavailable.
   
   It is recommended that you adhere to the ':' notation, ensuring the appropriate lifecycle tasks are available so that everyone is aware of the intended usage in your build.
   
   == Exclude tasks from execution
   
   You can exclude a task from execution using the `-x` or `--exclude-task` command-line option and provide the task's name to exclude.
   
   For instance, you can run the `check` task but exclude the `test` task from running.
   This approach can lead to unexpected outcomes, particularly if you exclude an actionable task that produces results needed by other tasks.
   Instead of relying on the `-x` parameter, defining a suitable lifecycle task for the desired action is recommended.
   
   Using `-x` is a practice that should be avoided, although still commonly observed.

/docs/userguide/authoring-builds/tasks/actionable_tasks.adoc
============================================================

.. code-block::

   = Actionable Tasks
   
   Actionable tasks describe work in Gradle.
   These tasks have actions.
   
   image::writing-tasks-3.png[]
   
   In Gradle core, the `compileJava` task compiles the Java source code.
   The `Jar` and `Zip` tasks zip files into archives.
   
   == Task inputs and outputs
   
   Actionable tasks have inputs and outputs.
   Inputs and outputs can be files, directories, or variables.
   
   In actionable tasks:
   
   - *Inputs* consist of a collection of files, folders, and/or configuration data. +
   For instance, the `javaCompile` task takes inputs such as Java source files and build script configurations like the Java version.
   - *Outputs* refer to one or multiple files or folders. +
   For instance, the `javaCompile` produces class files as output.
   
   Then, the `jar` task takes these class files as input and produces a JAR archive.
   
   Clearly defined task inputs and outputs serve two purposes:
   
   1. They inform Gradle about task dependencies. +
   For example, if Gradle understands that the output of the `compileJava` task serves as the input for the `jar` task, it will prioritize running `compileJava` first.
   2. They facilitate incremental building. +
   For example, suppose Gradle recognizes that the inputs and outputs of a task remain unchanged. In that case, it can leverage results from previous build runs or the build cache, avoiding rerunning the task action altogether.
   
   When you apply a plugin like the `java-library` plugin, Gradle will automatically register some tasks and configure them with defaults.
   
   Let's define a task that packages JARs and a start script into an archive in an imaginary sample project:
   
   ====
   [.multi-language-sample]
   =====
   [source,kotlin]
   ----
   gradle-project
   較럭較 app
   較   較럭較 build.gradle.kts    // app build logic
   較   較럭較 run.sh              // script file
   較   較덕較 ...                 // some java code
   較럭較 settings.gradle.kts     // includes app subproject
   較럭較 gradle
   較럭較 gradlew
   較덕較 gradlew.bat
   ----
   =====
   [.multi-language-sample]
   =====
   [source,groovy]
   ----
   gradle-project
   較럭較 app
   較   較럭較 build.gradle    // app build logic
   較   較럭較 run.sh          // script file
   較   較덕較 ...             // some java code
   較럭較 settings.gradle     // includes app subproject
   較럭較 gradle
   較럭較 gradlew
   較덕較 gradlew.bat
   ----
   =====
   ====
   
   The `run.sh` script can execute the Java app (once packaged as a JAR) from the build:
   
   .app/run.sh
   [source,bash]
   ----
   java -cp 'libs/*' gradle.project.app.App
   ----
   
   Let's register a new task called `packageApp` using link:{javadocPath}#[`task.register()`]:
   
   ====
   [.multi-language-sample]
   =====
   .app/build.gradle.kts
   [source,kotlin]
   ----
   tasks.register<Zip>("packageApp") {
   
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .app/build.gradle
   [source,groovy]
   ----
   tasks.register(Zip, "packageApp") {
   
   }
   ----
   =====
   ====
   
   We used an existing implementation from Gradle core which is the link:{javadocPath}#[`Zip`] task implementation (i.e., a subclass of link:{javadocPath}#[`DefaultTask`]).
   Because we register a new task here, it's not pre-configured.
   We need to configure the inputs and outputs.
   
   Defining inputs and outputs is what makes a task an actionable task.
   
   For the link:{javadocPath}#[`Zip`] task type, we can use the link:{javadocPath}#[`from()`] method to add a file to the inputs.
   In our case, we add the run script.
   
   If the input is a file we create or edit directly, like a run file or Java source code, it's usually located somewhere in our project directory.
   To ensure we use the correct location, we use link:{javadocPath}#[`layout.projectDirectory`] and define a relative path to the project directory root.
   
   We provide the outputs of the `jar` task as well as the JAR of all the dependencies (using link:{javadocPath}#[`configurations`]link:{javadocPath}#[`.runtimeClasspath`]) as additional inputs.
   
   For outputs, we need to define two properties.
   
   First, the destination directory, which should be a directory inside the build folder.
   We can access this through link:{javadocPath}#[`layout`].
   
   Second, we need to specify a name for the zip file, which we've called `myApplication.zip`
   
   Here is what the complete task looks like:
   
   ====
   [.multi-language-sample]
   =====
   .app/build.gradle.kts
   [source,kotlin]
   ----
   val packageApp = tasks.register<Zip>("packageApp") {
       from(layout.projectDirectory.file("run.sh"))                // input - run.sh file
       from(tasks.jar) {                                           // input - jar task output
           into("libs")
       }
       from(configurations.runtimeClasspath) {                     // input - jar of dependencies
           into("libs")
       }
       destinationDirectory.set(layout.buildDirectory.dir("dist")) // output - location of the zip file
       archiveFileName.set("myApplication.zip")                    // output - name of the zip file
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .app/build.gradle
   [source,groovy]
   ----
   def packageApp = tasks.register(Zip, 'packageApp') {
       from layout.projectDirectory.file('run.sh')                 // input - run.sh file
       from tasks.jar {                                            // input - jar task output
           into 'libs'
       }
       from configurations.runtimeClasspath {                      // input - jar of dependencies
           into 'libs'
       }
       destinationDirectory.set(layout.buildDirectory.dir('dist')) // output - location of the zip file
       archiveFileName.set('myApplication.zip')                    // output - name of the zip file
   }
   ----
   =====
   ====
   
   If we run our `packageApp` task, `myApplication.zip` is produced:
   
   [source,text]
   ----
   $./gradlew :app:packageApp
   
   > Task :app:compileJava
   > Task :app:processResources NO-SOURCE
   > Task :app:classes
   > Task :app:jar
   > Task :app:packageApp
   
   BUILD SUCCESSFUL in 1s
   3 actionable tasks: 3 executed
   ----
   
   Gradle executed a number of tasks it required to build the JAR file, which included the compilation of the code of the `app` project and the compilation of code dependencies.
   
   Looking at the newly created ZIP file, we can see that it contains everything needed to run the Java application:
   
   [source,bash]
   ----
   > unzip -l ./app/build/dist/myApplication.zip
   
   Archive:  ./app/build/dist/myApplication.zip
     Length      Date    Time    Name
   ---------  ---------- -----   ----
          42  01-31-2024 14:16   run.sh
           0  01-31-2024 14:22   libs/
         847  01-31-2024 14:22   libs/app.jar
     3041591  01-29-2024 14:20   libs/guava-32.1.2-jre.jar
        4617  01-29-2024 14:15   libs/failureaccess-1.0.1.jar
        2199  01-29-2024 14:15   libs/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar
       19936  01-29-2024 14:15   libs/jsr305-3.0.2.jar
      223979  01-31-2024 14:16   libs/checker-qual-3.33.0.jar
       16017  01-31-2024 14:16   libs/error_prone_annotations-2.18.0.jar
   ---------                     -------
     3309228                     9 files
   ----
   
   Actionable tasks should be wired to lifecycle tasks so that a developer only needs to run lifecycle tasks.
   
   So far, we called our new task directly.
   Let's wire it to a lifecycle task.
   
   The following is added to the build script so that the `packageApp` actionable task is wired to the `build` lifecycle task using link:{javadocPath}#[`dependsOn()`]:
   
   ====
   [.multi-language-sample]
   =====
   .app/build.gradle.kts
   [source,kotlin]
   ----
   tasks.build {
       dependsOn(packageApp)
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .app/build.gradle
   [source,groovy]
   ----
   tasks.build {
       dependsOn(packageApp)
   }
   ----
   =====
   ====
   
   We see that running `:build` also runs `:packageApp`:
   
   [source,text]
   ----
   $ ./gradlew :app:build
   
   > Task :app:compileJava UP-TO-DATE
   > Task :app:processResources NO-SOURCE
   > Task :app:classes UP-TO-DATE
   > Task :app:jar UP-TO-DATE
   > Task :app:startScripts
   > Task :app:distTar
   > Task :app:distZip
   > Task :app:assemble
   > Task :app:compileTestJava
   > Task :app:processTestResources NO-SOURCE
   > Task :app:testClasses
   > Task :app:test
   > Task :app:check
   > Task :app:packageApp
   > Task :app:build
   
   BUILD SUCCESSFUL in 1s
   8 actionable tasks: 6 executed, 2 up-to-date
   ----
   
   You could define your own lifecycle task if needed.
   
   == Task implementation by extending `DefaultTask`
   
   To address more individual needs, and if no existing plugins provide the build functionality you need, you can create your own task implementation.
   
   Implementing a class means creating a custom class (i.e., _type_), which is done by subclassing link:{javadocPath}#[`DefaultTask`]
   
   Let's start with an example built by Gradle `init` for a simple Java application with the source code in the `app` subproject and the common build logic in `buildSrc`:
   
   ====
   [.multi-language-sample]
   =====
   [source,kotlin]
   ----
   gradle-project
   較럭較 app
   較   較럭較 build.gradle.kts
   較   較덕較 src                 // some java code
   較       較덕較 ...
   較럭較 buildSrc
   較   較럭較 build.gradle.kts
   較   較럭較 settings.gradle.kts
   較   較덕較 src                 // common build logic
   較       較덕較 ...
   較럭較 settings.gradle.kts
   較럭較 gradle
   較럭較 gradlew
   較덕較 gradlew.bat
   ----
   =====
   [.multi-language-sample]
   =====
   [source,groovy]
   ----
   gradle-project
   較럭較 app
   較   較럭較 build.gradle
   較   較덕較 src             // some java code
   較       較덕較 ...
   較럭較 buildSrc
   較   較럭較 build.gradle
   較   較럭較 settings.gradle
   較   較덕較 src             // common build logic
   較       較덕較 ...
   較럭較 settings.gradle
   較럭較 gradle
   較럭較 gradlew
   較덕較 gradlew.bat
   ----
   =====
   ====
   
   We create a class called `GenerateReportTask` in `./buildSrc/src/main/kotlin/GenerateReportTask.kt` or `./buildSrc/src/main/groovy/GenerateReportTask.groovy`.
   
   To let Gradle know that we are implementing a task, we extend the `DefaultTask` class that comes with Gradle.
   It's also beneficial to make our task class `abstract` because Gradle will handle many things automatically:
   
   ====
   [.multi-language-sample]
   =====
   .buildSrc/src/main/kotlin/GenerateReportTask.kt
   [source,kotlin]
   ----
   import org.gradle.api.DefaultTask
   
   public abstract class GenerateReportTask : DefaultTask() {
   
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .buildSrc/src/main/groovy/GenerateReportTask.groovy
   [source,groovy]
   ----
   import org.gradle.api.DefaultTask
   
   public abstract class GenerateReportTask extends DefaultTask {
   
   }
   ----
   =====
   ====
   
   Next, we define the inputs and outputs using properties and annotations.
   In this context, properties in Gradle act as references to the actual values behind them, allowing Gradle to track inputs and outputs between tasks.
   
   For the input of our task, we use a `DirectoryProperty` from Gradle.
   We annotate it with `@InputDirectory` to indicate that it is an input to the task:
   
   ====
   [.multi-language-sample]
   =====
   .buildSrc/src/main/kotlin/GenerateReportTask.kt
   [source,kotlin]
   ----
   import org.gradle.api.DefaultTask
   import org.gradle.api.tasks.InputDirectory
   
   public abstract class GenerateReportTask : DefaultTask() {
   
       @get:InputDirectory
       lateinit var sourceDirectory: File
   
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .buildSrc/src/main/groovy/GenerateReportTask.groovy
   [source,groovy]
   ----
   import org.gradle.api.DefaultTask
   import org.gradle.api.tasks.InputDirectory
   
   public abstract class GenerateReportTask extends DefaultTask {
   
       @InputDirectory
       File sourceDirectory
   
   }
   ----
   =====
   ====
   
   Similarly, for the output, we use a `RegularFileProperty` and annotate it with `@OutputFile`.
   
   ====
   [.multi-language-sample]
   =====
   .buildSrc/src/main/kotlin/GenerateReportTask.kt
   [source,kotlin]
   ----
   import org.gradle.api.DefaultTask
   import org.gradle.api.tasks.InputDirectory
   import org.gradle.api.tasks.OutputFile
   
   public abstract class GenerateReportTask : DefaultTask() {
   
       @get:InputDirectory
       lateinit var sourceDirectory: File
   
       @get:OutputFile
       lateinit var reportFile: File
   
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .buildSrc/src/main/groovy/GenerateReportTask.groovy
   [source,groovy]
   ----
   import org.gradle.api.DefaultTask
   import org.gradle.api.tasks.InputDirectory
   import org.gradle.api.tasks.OutputFile
   
   public abstract class GenerateReportTask extends DefaultTask {
   
       @InputDirectory
       File sourceDirectory
   
       @OutputFile
       File reportFile
   
   }
   ----
   =====
   ====
   
   With inputs and outputs defined, the only thing that remains is the actual task action, which is implemented in a method annotated with `@TaskAction`.
   Inside this method, we write code accessing inputs and outputs using Gradle-specific APIs:
   
   ====
   [.multi-language-sample]
   =====
   .buildSrc/src/main/kotlin/GenerateReportTask.kt
   [source,kotlin]
   ----
   import org.gradle.api.DefaultTask
   import org.gradle.api.tasks.InputDirectory
   import org.gradle.api.tasks.OutputFile
   import org.gradle.api.tasks.TaskAction
   
   public abstract class GenerateReportTask : DefaultTask() {
   
       @get:InputDirectory
       lateinit var sourceDirectory: File
   
       @get:OutputFile
       lateinit var reportFile: File
   
       @TaskAction
       fun generateReport() {
           val fileCount = sourceDirectory.listFiles().count { it.isFile }
           val directoryCount = sourceDirectory.listFiles().count { it.isDirectory }
   
           val reportContent = """
               |Report for directory: ${sourceDirectory.absolutePath}
               |------------------------------
               |Number of files: $fileCount
               |Number of subdirectories: $directoryCount
           """.trimMargin()
   
           reportFile.writeText(reportContent)
           println("Report generated at: ${reportFile.absolutePath}")
       }
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .buildSrc/src/main/groovy/GenerateReportTask.groovy
   [source,groovy]
   ----
   import org.gradle.api.DefaultTask
   import org.gradle.api.tasks.InputDirectory
   import org.gradle.api.tasks.OutputFile
   import org.gradle.api.tasks.TaskAction
   
   public abstract class GenerateReportTask extends DefaultTask {
   
       @InputDirectory
       File sourceDirectory
   
       @OutputFile
       File reportFile
   
       @TaskAction
       void generateReport() {
           def fileCount = sourceDirectory.listFiles().count { it.isFile() }
           def directoryCount = sourceDirectory.listFiles().count { it.isDirectory() }
   
           def reportContent = """
               Report for directory: ${sourceDirectory.absolutePath}
               ------------------------------
               Number of files: $fileCount
               Number of subdirectories: $directoryCount
           """.trim()
   
           reportFile.text = reportContent
           println("Report generated at: ${reportFile.absolutePath}")
       }
   }
   ----
   =====
   ====
   
   The task action generates a report of the files in the `sourceDirectory`.
   
   In the application build file, we register a task of type `GenerateReportTask` using `task.register()` and name it `generateReport`.
   At the same time, we configure the inputs and outputs of the task:
   
   ====
   [.multi-language-sample]
   =====
   .app/build.gradle.kts
   [source,kotlin]
   ----
   tasks.register<GenerateReportTask>("generateReport") {
       sourceDirectory = file("src/main")
       reportFile = file("${layout.buildDirectory}/reports/directoryReport.txt")
   }
   
   tasks.build {
       dependsOn("generateReport")
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .app/build.gradle
   [source,groovy]
   ----
   import org.gradle.api.tasks.Copy
   
   tasks.register(GenerateReportTask, "generateReport") {
       sourceDirectory = file("src/main")
       reportFile = file("${layout.buildDirectory}/reports/directoryReport.txt")
   }
   
   tasks.build.dependsOn("generateReport")
   ----
   =====
   ====
   
   The `generateReport` task is wired to the `build` task.
   
   By running the build, we observe that our start script generation task is executed, and it's `UP-TO-DATE` in subsequent builds.
   Gradle's incremental building and caching mechanisms work seamlessly with custom tasks:
   
   [source,text]
   ----
   ./gradlew :app:build
   ----
   
   [source, text]
   ----
   > Task :buildSrc:checkKotlinGradlePluginConfigurationErrors
   > Task :buildSrc:compileKotlin UP-TO-DATE
   > Task :buildSrc:compileJava NO-SOURCE
   > Task :buildSrc:compileGroovy NO-SOURCE
   > Task :buildSrc:pluginDescriptors UP-TO-DATE
   > Task :buildSrc:processResources NO-SOURCE
   > Task :buildSrc:classes UP-TO-DATE
   > Task :buildSrc:jar UP-TO-DATE
   > Task :app:compileJava UP-TO-DATE
   > Task :app:processResources NO-SOURCE
   > Task :app:classes UP-TO-DATE
   > Task :app:jar UP-TO-DATE
   > Task :app:startScripts UP-TO-DATE
   > Task :app:distTar UP-TO-DATE
   > Task :app:distZip UP-TO-DATE
   > Task :app:assemble UP-TO-DATE
   > Task :app:compileTestJava UP-TO-DATE
   > Task :app:processTestResources NO-SOURCE
   > Task :app:testClasses UP-TO-DATE
   > Task :app:test UP-TO-DATE
   > Task :app:check UP-TO-DATE
   
   > Task :app:generateReport
   Report generated at: ./app/build/reports/directoryReport.txt
   
   > Task :app:packageApp
   > Task :app:build
   
   BUILD SUCCESSFUL in 1s
   13 actionable tasks: 10 executed, 3 up-to-date
   ----
   
   == Task actions
   
   A task action is the code that implements what a task is doing, as demonstrated in the previous section.
   For example, the `javaCompile` task action calls the Java compiler to transform source code into byte code.
   
   It is possible to dynamically modify task actions for tasks that are already registered.
   This is helpful for testing, patching, or modifying core build logic.
   
   Let's look at an example of a simple Gradle build with one `app` subproject that makes up a Java application  containing one Java class and using Gradle's `application` plugin.
   The project has common build logic in the `buildSrc` folder where `my-convention-plugin` resides:
   
   ====
   [.multi-language-sample]
   =====
   .app/build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("my-convention-plugin")
   }
   
   version = "1.0"
   
   application {
       mainClass = "org.example.app.App"
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .app/build.gradle
   [source,groovy]
   ----
   plugins {
       id 'my-convention-plugin'
   }
   
   version = '1.0'
   
   application {
       mainClass = 'org.example.app.App'
   }
   ----
   =====
   ====
   
   We define a task called `printVersion` in the build file of the `app`:
   
   ====
   [.multi-language-sample]
   =====
   .buildSrc/src/main/kotlin/PrintVersion.kt
   [source,kotlin]
   ----
   import org.gradle.api.DefaultTask
   import org.gradle.api.provider.Property
   import org.gradle.api.tasks.Input
   import org.gradle.api.tasks.TaskAction
   
   abstract class PrintVersion : DefaultTask() {
   
       // Configuration code
       @get:Input
       abstract val version: Property<String>
   
       // Execution code
       @TaskAction
       fun print() {
           println("Version: ${version.get()}")
       }
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .buildSrc/src/main/groovy/PrintVersion.groovy
   [source,groovy]
   ----
   import org.gradle.api.DefaultTask
   import org.gradle.api.provider.Property
   import org.gradle.api.tasks.Input
   import org.gradle.api.tasks.TaskAction
   
   abstract class PrintVersion extends DefaultTask {
   
       // Configuration code
       @Input
       abstract Property<String> getVersion()
   
       // Execution code
       @TaskAction
       void printVersion() {
           println("Version: ${getVersion().get()}")
       }
   }
   ----
   =====
   ====
   
   This task does one simple thing: it prints out the version of the project to the command line.
   
   The class extends `DefaultTask` and it has one `@Input`, which is of type `Property<String>`.
   It has one method that is annotated with `@TaskAction`, which prints out the version.
   
   Note that the task implementation clearly distinguishes between "Configuration code" and "Execution code".
   
   The configuration code is executed during Gradle's configuration phase.
   It builds up a model of the project in memory so that Gradle knows what it needs to do for a certain build invocation.
   Everything around the task actions, like the input or output properties, is part of this configuration code.
   
   The code inside the task action method is the execution code that does the actual work.
   It accesses the inputs and outputs to do some work if the task is part of the task graph and if it can't be skipped because it's UP-TO-DATE or it's taken FROM-CACHE.
   
   Once a task implementation is complete, it can be used in a build setup.
   In our convention plugin, `my-convention-plugin`, we can register a new task that uses the new task implementation:
   
   ====
   [.multi-language-sample]
   =====
   .app/build.gradle.kts
   [source,kotlin]
   ----
   tasks.register<PrintVersion>("printVersion") {
   
       // Configuration code
       version = project.version as String
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .app/build.gradle
   [source,groovy]
   ----
   tasks.register(PrintVersion, "printVersion") {
   
       // Configuration code
       version = project.version.toString()
   }
   ----
   =====
   ====
   
   Inside the configuration block for the task, we can write configuration phase code which modifies the values of input and output properties of the task.
   The task action is not referred to here in any way.
   
   It is possible to write simple tasks like this one in a more compact way and directly in the build script without creating a separate class for the task.
   
   Let's register another task and call it `printVersionDynamic`.
   
   This time, we do not define a type for the task, which means the task will be of the general type `DefaultTask`.
   This general type does not define any task actions, meaning it does not have methods annotated with `@TaskAction`.
   This type is useful for defining 'lifecycle tasks':
   
   ====
   [.multi-language-sample]
   =====
   .app/build.gradle.kts
   [source,kotlin]
   ----
   tasks.register("printVersionDynamic") {
   
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .app/build.gradle
   [source,groovy]
   ----
   tasks.register("printVersionDynamic") {
   
   }
   ----
   =====
   ====
   
   However, the default task type can also be used to define tasks with custom actions dynamically, without additional classes.
   This is done by using the `doFirst{}` or `doLast{}` construct.
   Similar to defining a method and annotating this `@TaskAction`, this adds an action to a task.
   
   The methods are called `doFirst{}` and `doLast{}` because the task can have multiple actions.
   If the task already has an action defined, you can use this distinction to decide if your additional action should run before or after the existing actions:
   
   ====
   [.multi-language-sample]
   =====
   .app/build.gradle.kts
   [source,kotlin]
   ----
   tasks.register("printVersionDynamic") {
       doFirst {
           // Task action = Execution code
           // Run before exiting actions
       }
       doLast {
           // Task action = Execution code
           // Run after existing actions
       }
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .app/build.gradle
   [source,groovy]
   ----
   tasks.register("printVersionDynamic") {
       doFirst {
           // Task action = Execution code
           // Run before exiting actions
       }
       doLast {
           // Task action = Execution code
           // Run after existing actions
       }
   }
   ----
   =====
   ====
   
   If you only have one action, which is the case here because we start with an empty task, we typically use the `doLast{}` method.
   
   In the task, we first declare the version we want to print as an input dynamically.
   Instead of declaring a property and annotating it with `@Input`, we use the general inputs properties that all tasks have.
   Then, we add the action code, a `println()` statement, inside the `doLast{}` method:
   
   ====
   [.multi-language-sample]
   =====
   .app/build.gradle.kts
   [source,kotlin]
   ----
   tasks.register("printVersionDynamic") {
       inputs.property("version", project.version.toString())
       doLast {
           println("Version: ${inputs.properties["version"]}")
       }
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .app/build.gradle
   [source,groovy]
   ----
   tasks.register("printVersionDynamic") {
       inputs.property("version", project.version)
       doLast {
           println("Version: ${inputs.properties["version"]}")
       }
   }
   ----
   =====
   ====
   
   We saw two alternative approaches to implementing a custom task in Gradle.
   
   The dynamic setup makes it more compact.
   However, it's easy to mix configuration and execution time states when writing dynamic tasks.
   You can also see that 'inputs' are untyped in dynamic tasks, which can lead to issues.
   When you implement your custom task as a class, you can clearly define the inputs as properties with a dedicated type.
   
   Dynamic modification of task actions can provide value for tasks that are already registered, but which you need to modify for some reason.
   
   Let's take the `compileJava` task as an example.
   
   Once the task is registered, you can't remove it.
   You could, instead, clear its actions:
   
   ====
   [.multi-language-sample]
   =====
   .app/build.gradle.kts
   [source,kotlin]
   ----
   tasks.compileJava {
       // Clear existing actions
       actions.clear()
   
       // Add a new action
       doLast {
           println("Custom action: Compiling Java classes...")
       }
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .app/build.gradle
   [source,groovy]
   ----
   tasks.compileJava {
       // Clear existing actions
       actions.clear()
   
       // Add a new action
       doLast {
           println("Custom action: Compiling Java classes...")
       }
   }
   ----
   =====
   ====
   
   It's also difficult, and in certain cases impossible, to remove certain task dependencies that have been set up already by the plugins you are using.
   You could, instead, modify its behavior:
   
   ====
   [.multi-language-sample]
   =====
   .app/build.gradle.kts
   [source,kotlin]
   ----
   tasks.compileJava {
       // Modify the task behavior
       doLast {
           val outputDir = File("$buildDir/compiledClasses")
           outputDir.mkdirs()
   
           val compiledFiles = sourceSets["main"].output.files
           compiledFiles.forEach { compiledFile ->
               val destinationFile = File(outputDir, compiledFile.name)
               compiledFile.copyTo(destinationFile, true)
           }
   
           println("Java compilation completed. Compiled classes copied to: ${outputDir.absolutePath}")
       }
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .app/build.gradle
   [source,groovy]
   ----
   tasks.compileJava {
       // Modify the task behavior
       doLast {
           def outputDir = file("$buildDir/compiledClasses")
           outputDir.mkdirs()
   
           def compiledFiles = sourceSets["main"].output.files
           compiledFiles.each { compiledFile ->
               def destinationFile = new File(outputDir, compiledFile.name)
               compiledFile.copyTo(destinationFile)
           }
   
           println("Java compilation completed. Compiled classes copied to: ${outputDir.absolutePath}")
       }
   }
   ----
   =====
   ====

/docs/userguide/authoring-builds/tasks/lazy_configuration.adoc
==============================================================

.. code-block::

   = Configuring Tasks Lazily
   
   Knowing when and where a particular value is configured is difficult to track as a build grows in complexity.
   Gradle provides several ways to manage this using *lazy configuration*.
   
   image::writing-tasks-4.png[]
   
   == Lazy properties
   
   Gradle provides lazy properties, which delay calculating a property뗩 value until it뗩 actually required.
   
   Lazy properties provide three main benefits:
   
   1. Build authors can wire together Gradle models without worrying when a particular property뗩 value will be known. +
   For example, you may want to set the input source files of a task based on the source directories property of an extension, but the extension property value isn't known until the build script or some other plugin configures them.
   2. Build authors can wire an output property of a task into an input property of some other task, and Gradle automatically determines the task dependencies based on this connection. +
   Property instances carry information about which task, if any, produces their value.
   Build authors do not need to worry about keeping task dependencies in sync with configuration changes.
   3. Build authors can avoid resource-intensive work during the configuration phase, which can greatly impact build performance. +
   For example, when a configuration value comes from parsing a file but is only used when functional tests are run, using a property instance to capture this means that the file is parsed only when the functional tests are run (and not when `clean` is run, for example).
   
   Gradle represents lazy properties with two interfaces:
   
   1. link:{javadocPath}#[Provider] represents a value that can only be queried and cannot be changed.
   ** Properties with these types are read-only.
   ** The method link:{javadocPath}#[Provider.get()] returns the current value of the property.
   ** A `Provider` can be created from another `Provider` using link:{javadocPath}#[Provider.map(Transformer)].
   ** Many other types extend `Provider` and can be used wherever a `Provider` is required.
   
   2. link:{javadocPath}#[Property] represents a value that can be queried and changed.
   ** Properties with these types are configurable.
   ** `Property` extends the `Provider` interface.
   ** The method link:{javadocPath}#[Property.set(T)] specifies a value for the property, overwriting whatever value may have been present.
   ** The method link:{javadocPath}#[Property.set(Provider)] specifies a `Provider` for the value for the property, overwriting whatever value may have been present.
   This allows you to wire together `Provider` and `Property` instances before the values are configured.
   ** A `Property` can be created by the factory method link:{javadocPath}#[ObjectFactory.property(Class)].
   
   Lazy properties are intended to be passed around and only queried when required.
   This typically happens during the <<build_lifecycle.adoc#sec:build_phases,execution phase>>.
   
   The following demonstrates a task with a configurable `greeting` property and a read-only `message` property:
   
   ====
   include::sample[dir="snippets/providers/propertyAndProvider/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/providers/propertyAndProvider/groovy",files="build.gradle[]"]
   ====
   <1> A task that displays a greeting
   <2> A configurable greeting
   <3> Read-only property calculated from the greeting
   <4> Configure the greeting
   <5> Alternative notation to calling Property.set()
   
   ----
   $ gradle greeting
   include::{snippetsPath}/providers/propertyAndProvider/tests/usePropertyAndProvider.out[]
   ----
   
   The `Greeting` task has a property of type `Property<String>` to represent the configurable greeting and a property of type `Provider<String>` to represent the calculated, read-only, message.
   The message `Provider` is created from the greeting `Property` using the `map()` method; its value is kept up-to-date as the value of the greeting property changes.
   
   == Creating a Property or Provider instance
   
   Neither `Provider` nor its subtypes, such as `Property`, are intended to be implemented by a build script or plugin.
   Gradle provides factory methods to create instances of these types instead.
   
   In the previous example, two factory methods were presented:
   
   - link:{javadocPath}#[ObjectFactory.property(Class)] create a new `Property` instance.
   An instance of the link:{javadocPath}#[ObjectFactory] can be referenced from link:{javadocPath}#[Project.getObjects()] or by injecting `ObjectFactory` through a constructor or method.
   - link:{javadocPath}#[Provider.map(Transformer)] creates a new `Provider` from an existing `Provider` or `Property` instance.
   
   See the <<#lazy_configuration_reference,Quick Reference>> for all of the types and factories available.
   
   A `Provider` can also be created by the factory method link:{groovyDslPath}#[ProviderFactory.provider(Callable)].
   
   [NOTE]
   ====
   There are no specific methods to create a provider using a `groovy.lang.Closure`.
   
   When writing a plugin or build script with Groovy, you can use the `map(Transformer)` method with a closure, and Groovy will convert the closure to a `Transformer`.
   
   Similarly, when writing a plugin or build script with Kotlin, the Kotlin compiler will convert a Kotlin function into a `Transformer`.
   ====
   
   == Connecting properties together
   
   An important feature of lazy properties is that they can be connected together so that changes to one property are automatically reflected in other properties.
   
   Here is an example where the property of a task is connected to a property of a project extension:
   
   ====
   include::sample[dir="snippets/providers/connectProperties/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/providers/connectProperties/groovy",files="build.gradle[]"]
   ====
   
   ----
   $ gradle greeting
   include::{snippetsPath}/providers/connectProperties/tests/connectProperties.out[]
   ----
   
   This example calls the link:{javadocPath}#[Property.set(Provider)] method to attach a `Provider` to a `Property` to supply the value of the property.
   In this case, the `Provider` happens to be a `Property` as well, but you can connect any `Provider` implementation, for example one created using `Provider.map()`
   
   == Working with files
   
   In <<working_with_files.adoc#working_with_files,Working with Files>>, we introduced four collection types for `File`-like objects:
   
   [%header%autowidth,compact]
   |===
   | Read-only Type | Configurable Type
   
   | link:{javadocPath}#[FileCollection]
   | link:{javadocPath}#[ConfigurableFileCollection]
   
   | link:{javadocPath}#[FileTree]
   | link:{javadocPath}#[ConfigurableFileTree]
   |===
   
   All of these types are also considered lazy types.
   
   There are more strongly typed models used to represent elements of the file system:
   link:{javadocPath}#[Directory] and link:{javadocPath}#[RegularFile].
   These types shouldn't be confused with the standard Java link:{javaApi}/java/io/File.html[File] type as they are used to tell Gradle that you expect more specific values such as a directory or a non-directory, regular file.
   
   Gradle provides two specialized `Property` subtypes for dealing with values of these types:
   link:{javadocPath}#[RegularFileProperty] and link:{javadocPath}#[DirectoryProperty]. link:{javadocPath}#[ObjectFactory] has methods to create these: link:{javadocPath}#[ObjectFactory.fileProperty()] and link:{javadocPath}#[ObjectFactory.directoryProperty()].
   
   A `DirectoryProperty` can also be used to create a lazily evaluated `Provider` for a `Directory` and `RegularFile` via link:{javadocPath}#[DirectoryProperty.dir(String)] and link:{javadocPath}#[DirectoryProperty.file(String)] respectively.
   These methods create providers whose values are calculated relative to the location for the `DirectoryProperty` they were created from.
   The values returned from these providers will reflect changes to the `DirectoryProperty`.
   
   ====
   include::sample[dir="snippets/providers/fileAndDirectoryProperty/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/providers/fileAndDirectoryProperty/groovy",files="build.gradle[]"]
   ====
   
   [.multi-language-text.lang-groovy]
   ----
   $ gradle generate
   include::{snippetsPath}/providers/fileAndDirectoryProperty/tests/workingWithFilesGroovy.out[]
   ----
   [.multi-language-text.lang-kotlin]
   ----
   $ gradle generate
   include::{snippetsPath}/providers/fileAndDirectoryProperty/tests/workingWithFilesKotlin.out[]
   ----
   
   This example creates providers that represent locations in the project and build directories through link:{javadocPath}#[Project.getLayout()] with link:{javadocPath}#[ProjectLayout.getBuildDirectory()] and link:{javadocPath}#[ProjectLayout.getProjectDirectory()].
   
   To close the loop, note that a `DirectoryProperty`, or a simple `Directory`, can be turned into a `FileTree` that allows the files and directories contained in the directory to be queried with link:{javadocPath}#[DirectoryProperty.getAsFileTree()] or link:{javadocPath}#[Directory.getAsFileTree()].
   From a `DirectoryProperty` or a `Directory`, you can create `FileCollection` instances containing a set of the files contained in the directory with link:{javadocPath}#[DirectoryProperty.files(Object++...++)] or link:{javadocPath}#[Directory.files(Object++...++)].
   
   == Working with task inputs and outputs
   
   Many builds have several tasks connected together, where one task consumes the outputs of another task as an input.
   
   To make this work, we need to configure each task to know where to look for its inputs and where to place its outputs.
   Ensure that the producing and consuming tasks are configured with the same location and attach task dependencies between the tasks.
   This can be cumbersome and brittle if any of these values are configurable by a user or configured by multiple plugins, as task properties need to be configured in the correct order and locations, and task dependencies kept in sync as values change.
   
   The `Property` API makes this easier by keeping track of the value of a property and the task that produces the value.
   
   As an example, consider the following plugin with a producer and consumer task which are wired together:
   
   ====
   include::sample[dir="snippets/providers/implicitTaskInputFileDependency/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/providers/implicitTaskInputFileDependency/groovy",files="build.gradle[]"]
   ====
   
   [.multi-language-text.lang-groovy]
   ----
   $ gradle consumer
   include::{snippetsPath}/providers/implicitTaskInputFileDependency/tests/implicitTaskInputFileDependencyGroovy.out[]
   ----
   [.multi-language-text.lang-kotlin]
   ----
   $ gradle consumer
   include::{snippetsPath}/providers/implicitTaskInputFileDependency/tests/implicitTaskInputFileDependencyKotlin.out[]
   ----
   
   In the example above, the task outputs and inputs are connected before any location is defined.
   The setters can be called at any time before the task is executed, and the change will automatically affect all related input and output properties.
   
   Another important thing to note in this example is the absence of any explicit task dependency.
   Task outputs represented using `Providers` keep track of which task produces their value, and using them as task inputs will implicitly add the correct task dependencies.
   
   Implicit task dependencies also work for input properties that are not files:
   
   ====
   include::sample[dir="snippets/providers/implicitTaskInputDependency/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/providers/implicitTaskInputDependency/groovy",files="build.gradle[]"]
   ====
   
   [.multi-language-text.lang-groovy]
   ----
   $ gradle consumer
   include::{snippetsPath}/providers/implicitTaskInputDependency/tests/implicitTaskInputDependencyGroovy.out[]
   ----
   [.multi-language-text.lang-kotlin]
   ----
   $ gradle consumer
   include::{snippetsPath}/providers/implicitTaskInputDependency/tests/implicitTaskInputDependencyKotlin.out[]
   ----
   
   == Working with collections
   
   Gradle provides two lazy property types to help configure `Collection` properties.
   
   These work exactly like any other `Provider` and, just like file providers, they have additional modeling around them:
   
   * For `List` values the interface is called link:{javadocPath}#[ListProperty]. +
   You can create a new `ListProperty` using link:{javadocPath}#[ObjectFactory.listProperty(Class)] and specifying the element type.
   * For `Set` values the interface is called link:{javadocPath}#[SetProperty]. +
   You can create a new `SetProperty` using link:{javadocPath}#[ObjectFactory.setProperty(Class)] and specifying the element type.
   
   This type of property allows you to overwrite the entire collection value with link:{javadocPath}#[HasMultipleValues.set(Iterable)] and link:{javadocPath}#[HasMultipleValues.set(Provider)] or add new elements through the various `add` methods:
   
   * link:{javadocPath}#[HasMultipleValues.add(T)]: Add a single element to the collection
   * link:{javadocPath}#[HasMultipleValues.add(Provider)]: Add a lazily calculated element to the collection
   * link:{javadocPath}#[HasMultipleValues.addAll(Provider)]: Add a lazily calculated collection of elements to the list
   
   Just like every `Provider`, the collection is calculated when link:{javadocPath}#[Provider.get()] is called. The following example shows the link:{javadocPath}#[ListProperty] in action:
   
   ====
   include::sample[dir="snippets/providers/listProperty/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/providers/listProperty/groovy",files="build.gradle[]"]
   ====
   
   [.multi-language-text.lang-groovy]
   ----
   $ gradle consumer
   include::{snippetsPath}/providers/listProperty/tests/listPropertyGroovy.out[]
   ----
   [.multi-language-text.lang-kotlin]
   ----
   $ gradle consumer
   include::{snippetsPath}/providers/listProperty/tests/listPropertyKotlin.out[]
   ----
   
   == Working with maps
   
   Gradle provides a lazy link:{javadocPath}#[MapProperty] type to allow `Map` values to be configured.
   You can create a `MapProperty` instance using link:{javadocPath}#[ObjectFactory.mapProperty(Class, Class)].
   
   Similar to other property types, a `MapProperty` has a link:{javadocPath}#[set()] method that you can use to specify the value for the property.
   Some additional methods allow entries with lazy values to be added to the map.
   
   ====
   include::sample[dir="snippets/providers/mapProperty/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/providers/mapProperty/groovy",files="build.gradle[]"]
   ====
   
   ----
   $ gradle generate
   include::{snippetsPath}/providers/mapProperty/tests/mapProperty.out[]
   ----
   
   == Applying a convention to a property
   
   Often, you want to apply some _convention_, or default value to a property to be used if no value has been configured.
   You can use the `convention()` method for this.
   This method accepts either a value or a `Provider`, and this will be used as the value until some other value is configured.
   
   ====
   include::sample[dir="snippets/providers/propertyConvention/kotlin",files="build.gradle.kts[tags=conventions]"]
   include::sample[dir="snippets/providers/propertyConvention/groovy",files="build.gradle[tags=conventions]"]
   ====
   
   ----
   $ gradle show
   include::{snippetsPath}/providers/propertyConvention/tests/propertyConvention.out[]
   ----
   
   == Making a property unmodifiable
   
   Most properties of a task or project are intended to be configured by plugins or build scripts so that they can use specific values for that build.
   
   For example, a property that specifies the output directory for a compilation task may start with a value specified by a plugin.
   Then a build script might change the value to some custom location, then this value is used by the task when it runs.
   However, once the task starts to run, we want to prevent further property changes.
   This way we avoid errors that result from different consumers, such as the task action, Gradle's up-to-date checks, build caching, or other tasks, using different values for the property.
   
   Lazy properties provide several methods that you can use to disallow changes to their value once the value has been configured.
   The link:{javadocPath}#[finalizeValue()] method calculates the _final_ value for the property and prevents further changes to the property.
   
   ```
   libVersioning.version.finalizeValue()
   ```
   
   When the property's value comes from a `Provider`, the provider is queried for its current value, and the result becomes the final value for the property.
   This final value replaces the provider and the property no longer tracks the value of the provider.
   Calling this method also makes a property instance unmodifiable and any further attempts to change the value of the property will fail.
   Gradle automatically makes the properties of a task final when the task starts execution.
   
   The link:{javadocPath}#[finalizeValueOnRead()] method is similar, except that the property's final value is not calculated until the value of the property is queried.
   
   ```
   modifiedFiles.finalizeValueOnRead()
   ```
   
   In other words, this method calculates the final value lazily as required, whereas `finalizeValue()` calculates the final value eagerly.
   This method can be used when the value may be expensive to calculate or may not have been configured yet.
   You also want to ensure that all consumers of the property see the same value when they query the value.
   
   == Guidelines
   
   Guidelines to be successful with the Provider API:
   
   1. The link:{javadocPath}#[Property] and link:{javadocPath}#[Provider] types have all of the overloads you need to query or configure a value. For this reason, you should follow the following guidelines:
   ** For configurable properties, expose the link:{javadocPath}#[Property] directly through a single getter.
   ** For non-configurable properties, expose an link:{javadocPath}#[Provider] directly through a single getter.
   
   2. Avoid simplifying calls like `obj.getProperty().get()` and `obj.getProperty().set(T)` in your code by introducing additional getters and setters.
   
   3. When migrating your plugin to use providers, follow these guidelines:
   ** If it's a new property, expose it as a link:{javadocPath}#[Property] or link:{javadocPath}#[Provider] using a single getter.
   ** If it's incubating, change it to use a link:{javadocPath}#[Property] or link:{javadocPath}#[Provider] using a single getter.
   ** If it's a stable property, add a new link:{javadocPath}#[Property] or link:{javadocPath}#[Provider] and deprecate the old one. You should wire the old getter/setters into the new property as appropriate.
   
   == Provider Files API Reference
   
   Use these types for _read-only_ values:
   
   link:{javadocPath}#[Provider]<link:{javadocPath}#[RegularFile]>:: File on disk
   Factories;;
   * link:{javadocPath}#[Provider.map(Transformer)].
   * link:{javadocPath}#[Provider.flatMap(Transformer)].
   * link:{javadocPath}#[DirectoryProperty.file(String)]
   
   link:{javadocPath}#[Provider]<link:{javadocPath}#[Directory]>:: Directory on disk
   Factories;;
   * link:{javadocPath}#[Provider.map(Transformer)].
   * link:{javadocPath}#[Provider.flatMap(Transformer)].
   * link:{javadocPath}#[DirectoryProperty.dir(String)]
   
   link:{javadocPath}#[FileCollection]:: Unstructured collection of files
   Factories;;
   * link:{groovyDslPath}#[]++)[Project.files(Object++[]++)]
       * link:{javadocPath}#[ProjectLayout.files(Object++...++)]
       * link:{javadocPath}#[DirectoryProperty.files(Object++...++)]
   
   link:{javadocPath}#[FileTree]:: Hierarchy of files
   Factories;;
   * link:{groovyDslPath}#[Project.fileTree(Object)] will produce a link:{javadocPath}#[ConfigurableFileTree], or you can use link:{javadocPath}#[Project.zipTree(Object)] and link:{javadocPath}#[Project.tarTree(Object)]
   * link:{javadocPath}#[DirectoryProperty.getAsFileTree()]
   
   == Property Files API Reference
   
   Use these types for _mutable_ values:
   
   link:{javadocPath}#[RegularFileProperty]:: File on disk
   Factories;;
   * link:{javadocPath}#[ObjectFactory.fileProperty()]
   
   link:{javadocPath}#[DirectoryProperty]:: Directory on disk
   Factories;;
   * link:{javadocPath}#[ObjectFactory.directoryProperty()]
   
   link:{javadocPath}#[ConfigurableFileCollection]:: Unstructured collection of files
   Factories;;
   * link:{javadocPath}#[ObjectFactory.fileCollection()]
   
   link:{javadocPath}#[ConfigurableFileTree]:: Hierarchy of files
   Factories;;
   * link:{javadocPath}#[ObjectFactory.fileTree()]
   
   link:{javadocPath}#[SourceDirectorySet]:: Hierarchy of source directories
   Factories;;
   * link:{javadocPath}#[ObjectFactory.sourceDirectorySet(String, String)]
   
   == Lazy Collections API Reference
   
   Use these types for _mutable_ values:
   
   link:{javadocPath}#[ListProperty<T>]:: a property whose value is `List<T>`
   Factories;;
   * link:{javadocPath}#[ObjectFactory.listProperty(Class)]
   
   link:{javadocPath}#[SetProperty<T>]:: a property whose value is `Set<T>`
   Factories;;
   * link:{javadocPath}#[ObjectFactory.setProperty(Class)]
   
   == Lazy Objects API Reference
   
   Use these types for _read only_ values:
   
   link:{javadocPath}#[Provider<T>]:: a property whose value is an instance of `T`
   Factories;;
   * link:{javadocPath}#[Provider.map(Transformer)].
   * link:{javadocPath}#[Provider.flatMap(Transformer)].
   * link:{groovyDslPath}#[ProviderFactory.provider(Callable)]. Always prefer one of the other factory methods over this method.
   
   Use these types for _mutable_ values:
   
   link:{javadocPath}#[Property<T>]:: a property whose value is an instance of `T`
   Factories;;
   * link:{javadocPath}#[ObjectFactory.property(Class)]

/docs/userguide/authoring-builds/tasks/worker_api.adoc
======================================================

.. code-block::

   = Developing Parallel Tasks
   
   Gradle provides an API that can split tasks into sections that can be executed in parallel.
   
   image::writing-tasks-5.png[]
   
   This allows Gradle to fully utilize the resources available and complete builds faster.
   
   == The Worker API
   The Worker API provides the ability to break up the execution of a task action into discrete units of work and then execute that work concurrently and asynchronously.
   
   == Worker API example
   The best way to understand how to use the API is to go through the process of converting an existing custom task to use the Worker API:
   
   1. You'll start by creating a custom task class that generates MD5 hashes for a configurable set of files.
   2. Then, you'll convert this custom task to use the Worker API.
   3. Then, we'll explore running the task with different levels of isolation.
   
   In the process, you'll learn about the basics of the Worker API and the capabilities it provides.
   
   === Step 1. Create a custom task class
   
   First, create a custom task that generates MD5 hashes of a configurable set of files.
   
   In a new directory, create a `buildSrc/build.gradle(.kts)` file:
   
   ====
   include::sample[dir="snippets/workerApi/md5CustomTask/kotlin",files="buildSrc/build.gradle.kts[]"]
   include::sample[dir="snippets/workerApi/md5CustomTask/groovy",files="buildSrc/build.gradle[]"]
   ====
   <1> Your custom task class will use https://commons.apache.org/proper/commons-codec/[Apache Commons Codec] to generate MD5 hashes.
   
   Next, create a custom task class in your `buildSrc/src/main/java` directory.
   You should name this class `CreateMD5`:
   
   .buildSrc/src/main/java/CreateMD5.java
   [source,java]
   ----
   include::{snippetsPath}/workerApi/md5CustomTask/groovy/buildSrc/src/main/java/CreateMD5.java[]
   ----
   <1> link:{javadocPath}#[SourceTask] is a convenience type for tasks that operate on a set of source files.
   <2> The task output will go into a configured directory.
   <3> The task iterates over all the files defined as "source files" and creates an MD5 hash of each.
   <4> Insert an artificial sleep to simulate hashing a large file (the sample files won't be that large).
   <5> The MD5 hash of each file is written to the output directory into a file of the same name with an "md5" extension.
   
   Next, create a `build.gradle(.kts)` that registers your new `CreateMD5` task:
   
   ====
   include::sample[dir="snippets/workerApi/md5CustomTask/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/workerApi/md5CustomTask/groovy",files="build.gradle[]"]
   ====
   <1> Apply the `base` plugin so that you'll have a `clean` task to use to remove the output.
   <2> MD5 hash files will be written to `build/md5`.
   <3> This task will generate MD5 hash files for every file in the `src` directory.
   
   You will need some source to generate MD5 hashes from.
   Create three files in the `src` directory:
   
   .src/einstein.txt
   [source,text]
   ----
   include::{snippetsPath}/workerApi/md5CustomTask/groovy/src/einstein.txt[]
   ----
   
   .src/feynman.txt
   [source,text]
   ----
   include::{snippetsPath}/workerApi/md5CustomTask/groovy/src/feynman.txt[]
   ----
   
   .src/hawking.txt
   [source,text]
   ----
   include::{snippetsPath}/workerApi/md5CustomTask/groovy/src/hawking.txt[]
   ----
   
   At this point, you can test your task by running it `./gradlew md5`:
   
   [listing]
   ----
   $ gradle md5
   ----
   
   The output should look similar to:
   
   [listing]
   ----
   include::{snippetsPath}/workerApi/md5CustomTask/tests/md5Task1.out[]
   ----
   
   In the `build/md5` directory, you should now see corresponding files with an `md5` extension containing MD5 hashes of the files from the `src` directory.
   Notice that the task takes at least 9 seconds to run because it hashes each file one at a time (i.e., three files at ~3 seconds apiece).
   
   === Step 2. Convert to the Worker API
   
   Although this task processes each file in sequence, the processing of each file is independent of any other file.
   This work can be done in parallel and take advantage of multiple processors.
   This is where the Worker API can help.
   
   To use the Worker API, you need to define an interface that represents the parameters of each unit of work and extends `org.gradle.workers.WorkParameters`.
   
   For the generation of MD5 hash files, the unit of work will require two parameters:
   
   1. the file to be hashed and,
   2. the file to write the hash to.
   
   There is no need to create a concrete implementation because Gradle will generate one for us at runtime.
   
   .buildSrc/src/main/java/MD5WorkParameters.java
   [source,java]
   ----
   include::{snippetsPath}/workerApi/md5NoIsolation/groovy/buildSrc/src/main/java/MD5WorkParameters.java[]
   ----
   <1> Use `Property` objects to represent the source and MD5 hash files.
   
   Then, you need to refactor the part of your custom task that does the work for each individual file into a separate class.
   This class is your "unit of work" implementation, and it should be an abstract class that extends `org.gradle.workers.WorkAction`:
   
   .buildSrc/src/main/java/GenerateMD5.java
   [source,java]
   ----
   include::{snippetsPath}/workerApi/md5NoIsolation/groovy/buildSrc/src/main/java/GenerateMD5.java[]
   ----
   <1> Do not implement the `getParameters()` method - Gradle will inject this at runtime.
   
   Now, change your custom task class to submit work to the
   link:{javadocPath}#[WorkerExecutor] instead of doing the work itself.
   
   .buildSrc/src/main/java/CreateMD5.java
   [source,java]
   ----
   include::{snippetsPath}/workerApi/md5NoIsolation/groovy/buildSrc/src/main/java/CreateMD5.java[]
   ----
   <1> The link:{javadocPath}#[WorkerExecutor] service is required in order to submit your work.
   Create an abstract getter method annotated `javax.inject.Inject`, and Gradle will inject the service at runtime when the task is created.
   <2> Before submitting work, get a `WorkQueue` object with the desired isolation mode (described below).
   <3> When submitting the unit of work, specify the unit of work implementation, in this case `GenerateMD5`, and configure its parameters.
   
   At this point, you should be able to rerun your task:
   
   [listing]
   ----
   $ gradle clean md5
   
   include::{snippetsPath}/workerApi/md5NoIsolation/tests/md5Task1.out[]
   ----
   
   The results should look the same as before, although the MD5 hash files may be generated in a different order since the units of work are executed in parallel.
   This time, however, the task runs much faster.
   This is because the Worker API executes the MD5 calculation for each file in parallel rather than in sequence.
   
   === Step 3. Change the isolation mode
   
   The isolation mode controls how strongly Gradle will isolate items of work from each other and the rest of the Gradle runtime.
   
   There are three methods on `WorkerExecutor` that control this:
   
   1. `noIsolation()`
   2. `classLoaderIsolation()`
   3. `processIsolation()`
   
   The `noIsolation()` mode is the lowest level of isolation and will prevent a unit of work from changing the project state.
   This is the fastest isolation mode because it requires the least overhead to set up and execute the work item.
   However, it will use a single shared classloader for all units of work.
   This means that each unit of work can affect one another through static class state.
   It also means that every unit of work uses the same version of libraries on the buildscript classpath.
   If you wanted the user to be able to configure the task to run with a different (but compatible) version of the
   link:https://commons.apache.org/proper/commons-codec/[Apache Commons Codec] library, you would need to use a different isolation mode.
   
   First, you must change the dependency in `buildSrc/build.gradle` to be `compileOnly`.
   This tells Gradle that it should use this dependency when building the classes, but should not put it on the build script classpath:
   
   ====
   include::sample[dir="snippets/workerApi/md5ClassloaderIsolation/kotlin",files="buildSrc/build.gradle.kts[]"]
   include::sample[dir="snippets/workerApi/md5ClassloaderIsolation/groovy",files="buildSrc/build.gradle[]"]
   ====
   
   Next, change the `CreateMD5` task to allow the user to configure the version of the codec library that they want to use.
   It will resolve the appropriate version of the library at runtime and configure the workers to use this version.
   
   The `classLoaderIsolation()` method tells Gradle to run this work in a thread with an isolated classloader:
   
   .buildSrc/src/main/java/CreateMD5.java
   [source, groovy]
   ----
   include::{snippetsPath}/workerApi/md5ClassloaderIsolation/groovy/buildSrc/src/main/java/CreateMD5.java[]
   ----
   <1> Expose an input property for the codec library classpath.
   <2> Configure the classpath on the link:{javadocPath}#[ClassLoaderWorkerSpec] when creating the work queue.
   
   Next, you need to configure your build so that it has a repository to look up the codec version at task execution time.
   We also create a dependency to resolve our codec library from this repository:
   
   ====
   include::sample[dir="snippets/workerApi/md5ClassloaderIsolation/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/workerApi/md5ClassloaderIsolation/groovy",files="build.gradle[]"]
   ====
   
   <1> Add a repository to resolve the codec library - this can be a different repository than the one used to build the `CreateMD5` task class.
   <2> Add a _configuration_ to resolve our codec library version.
   <3> Configure an alternate, compatible version of https://commons.apache.org/proper/commons-codec/[Apache Commons Codec].
   <4> Configure the `md5` task to use the configuration as its classpath.
   Note that the configuration will not be resolved until the task is executed.
   
   Now, if you run your task, it should work as expected using the configured version of the codec library:
   
   [listing]
   ----
   $ gradle clean md5
   
   include::{snippetsPath}/workerApi/md5ClassloaderIsolation/tests/md5Task1.out[]
   ----
   
   === Step 4. Create a Worker Daemon
   
   Sometimes, it is desirable to utilize even greater levels of isolation when executing items of work.
   For instance, external libraries may rely on certain system properties to be set, which may conflict between work items.
   Or a library might not be compatible with the version of JDK that Gradle is running with and may need to be run with a different version.
   
   The Worker API can accommodate this using the `processIsolation()` method that causes the work to execute in a separate "worker daemon".
   These worker daemon processes will persist across builds and can be reused during subsequent builds.
   However, if system resources get low, Gradle will stop unused worker daemons.
   
   To utilize a worker daemon, use the `processIsolation()` method when creating the `WorkQueue`.
   You may also want to configure custom settings for the new process:
   
   .buildSrc/src/main/java/CreateMD5.java
   [source,java]
   ----
   include::{snippetsPath}/workerApi/md5ProcessIsolation/groovy/buildSrc/src/main/java/CreateMD5.java[]
   ----
   <1> Change the isolation mode to `PROCESS`.
   <2> Set up the link:{javadocPath}#[JavaForkOptions] for the new process.
   
   Now, you should be able to run your task, and it will work as expected but using worker daemons instead:
   
   [listing]
   ----
   $ gradle clean md5
   
   include::{snippetsPath}/workerApi/md5ProcessIsolation/tests/md5Task1.out[]
   ----
   
   Note that the execution time may be high.
   This is because Gradle has to start a new process for each worker daemon, which is expensive.
   
   However, if you run your task a second time, you will see that it runs much faster.
   This is because the worker daemon(s) started during the initial build have persisted and are available for use immediately during subsequent builds:
   
   [listing]
   ----
   $ gradle clean md5
   
   include::{snippetsPath}/workerApi/md5ProcessIsolation/tests/md5Task2.out[]
   ----
   
   == Isolation modes
   
   Gradle provides three isolation modes that can be configured when creating a link:{javadocPath}#[WorkQueue] and are specified using one of the following methods on link:{javadocPath}#[WorkerExecutor]:
   
   link:{javadocPath}#[`WorkerExecutor.noIsolation()`]::
   This states that the work should be run in a thread with minimal isolation. +
   For instance, it will share the same classloader that the task is loaded from.
   This is the fastest level of isolation.
   
   link:{javadocPath}#[`WorkerExecutor.classLoaderIsolation()`]::
   This states that the work should be run in a thread with an isolated classloader.  +
   The classloader will have the classpath from the classloader that the unit of work implementation class was loaded from as well as any additional classpath entries added through link:{javadocPath}#[`ClassLoaderWorkerSpec.getClasspath()`].
   
   link:{javadocPath}#[`WorkerExecutor.processIsolation()`]::
   This states that the work should be run with a maximum isolation level by executing the work in a separate process. +
   The classloader of the process will use the classpath from the classloader that the unit of work was loaded from as well as any additional classpath entries added through link:{javadocPath}#[`ClassLoaderWorkerSpec.getClasspath()`].
   Furthermore, the process will be a _worker daemon_ that will stay alive and can be reused for future work items with the same requirements.
   This process can be configured with different settings than the Gradle JVM using link:{javadocPath}#[ProcessWorkerSpec.forkOptions(org.gradle.api.Action)].
   
   === Worker Daemons
   
   When using `processIsolation()`, Gradle will start a long-lived _worker daemon_ process that can be reused for future work items.
   
   ====
   include::sample[dir="snippets/workerApi/workerDaemon/kotlin",files="build.gradle.kts[tags=worker-daemon]"]
   include::sample[dir="snippets/workerApi/workerDaemon/groovy",files="build.gradle[tags=worker-daemon]"]
   ====
   
   When a unit of work for a worker daemon is submitted, Gradle will first look to see if a compatible, idle daemon already exists.
   If so, it will send the unit of work to the idle daemon, marking it as busy.
   If not, it will start a new daemon.
   When evaluating compatibility, Gradle looks at a number of criteria, all of which can be controlled through link:{javadocPath}#[ProcessWorkerSpec.forkOptions(org.gradle.api.Action)].
   
   By default, a worker daemon starts with a maximum heap of 512MB.
   This can be changed by adjusting the workers' fork options.
   
   executable::
   A daemon is considered compatible only if it uses the same Java executable.
   
   classpath::
   A daemon is considered compatible if its classpath contains all the classpath entries requested. +
   Note that a daemon is considered compatible only if the classpath exactly matches the requested classpath.
   
   heap settings::
   A daemon is considered compatible if it has at least the same heap size settings as requested. +
   In other words, a daemon that has higher heap settings than requested would be considered compatible.
   
   jvm arguments::
   A daemon is compatible if it has set all the JVM arguments requested. +
   Note that a daemon is compatible if it has additional JVM arguments beyond those requested (except for those treated especially, such as heap settings, assertions, debug, etc.).
   
   system properties::
   A daemon is considered compatible if it has set all the system properties requested with the same values. +
   Note that a daemon is compatible if it has additional system properties beyond those requested.
   
   environment variables::
   A daemon is considered compatible if it has set all the environment variables requested with the same values. +
   Note that a daemon is compatible if it has more environment variables than requested.
   
   bootstrap classpath::
   A daemon is considered compatible if it contains all the bootstrap classpath entries requested. +
   Note that a daemon is compatible if it has more bootstrap classpath entries than requested.
   
   debug::
   A daemon is considered compatible only if debug is set to the same value as requested (`true` or `false`).
   
   enable assertions::
   A daemon is considered compatible only if enable assertions are set to the same value as requested (`true` or `false`).
   
   default character encoding::
   A daemon is considered compatible only if the default character encoding is set to the same value as requested.
   
   Worker daemons will remain running until the build daemon that started them is stopped or system memory becomes scarce.
   When system memory is low, Gradle will stop worker daemons to minimize memory consumption.
   
   NOTE: A step-by-step description of converting a normal task action to use the worker API can be found in the section on <<worker_api.adoc#tasks_parallel_worker,developing parallel tasks>>.
   
   == Cancellation and timeouts
   
   To support cancellation (e.g., when the user stops the build with CTRL+C) and task timeouts, custom tasks should react to interrupting their executing thread.
   The same is true for work items submitted via the worker API.
   If a task does not respond to an interrupt within 10s, the daemon will shut down to free up system resources.

/docs/userguide/authoring-builds/tasks/custom_tasks.adoc
========================================================

.. code-block::

   = Advanced Tasks
   
   == Incremental tasks
   
   In Gradle, implementing a task that skips execution when its inputs and outputs are already `UP-TO-DATE` is simple and efficient, thanks to the <<incremental_build.adoc#incremental_build,Incremental Build>> feature.
   
   However, there are times when only a few input files have changed since the last execution, and it is best to avoid reprocessing all the unchanged inputs.
   This situation is common in tasks that transform input files into output files on a one-to-one basis.
   
   To optimize your build process you can use an incremental task.
   This approach ensures that only out-of-date input files are processed, improving build performance.
   
   === Implementing an incremental task
   
   For a task to process inputs incrementally, that task must contain an _incremental_ task action.
   
   This is a task action method that has a single link:{groovyDslPath}#[InputChanges] parameter.
   That parameter tells Gradle that the action only wants to process the changed inputs.
   
   In addition, the task needs to declare at least one incremental file input property by using either link:{javadocPath}#[`@Incremental`] or link:{javadocPath}#[`@SkipWhenEmpty`]:
   
   ====
   [.multi-language-sample]
   =====
   [source,kotlin]
   .build.gradle.kts
   ----
   public class IncrementalReverseTask : DefaultTask() {
   
       @get:Incremental
       @get:InputDirectory
       val inputDir: DirectoryProperty = project.objects.directoryProperty()
   
       @get:OutputDirectory
       val outputDir: DirectoryProperty = project.objects.directoryProperty()
   
       @get:Input
       val inputProperty: RegularFileProperty = project.objects.fileProperty() // File input property
   
       @TaskAction
       fun execute(inputs: InputChanges) { // InputChanges parameter
           val msg = if (inputs.isIncremental) "CHANGED inputs are out of date"
                     else "ALL inputs are out of date"
           println(msg)
       }
   }
   ----
   =====
   [.multi-language-sample]
   =====
   [source,groovy]
   .build.gradle
   ----
   class IncrementalReverseTask extends DefaultTask {
   
       @Incremental
       @InputDirectory
       def File inputDir
   
       @OutputDirectory
       def File outputDir
   
       @Input
       def inputProperty // File input property
   
       @TaskAction
       void execute(InputChanges inputs) { // InputChanges parameter
           println inputs.incremental ? "CHANGED inputs are out of date"
                                      : "ALL inputs are out of date"
       }
   }
   ----
   =====
   ====
   
   [IMPORTANT]
   ====
   To query incremental changes for an input file property, that property must always return the same instance.
   The easiest way to accomplish this is to use one of the following property types: link:{javadocPath}#[`RegularFileProperty`], link:{javadocPath}#[`DirectoryProperty`] or link:{javadocPath}#[`ConfigurableFileCollection`].
   
   You can learn more about `RegularFileProperty` and `DirectoryProperty` in <<lazy_configuration#lazy_configuration,Lazy Configuration>>.
   ====
   
   The incremental task action can use link:{groovyDslPath}#[`InputChanges.getFileChanges()`] to find out what files have changed for a given file-based input property, be it of type `RegularFileProperty`, `DirectoryProperty` or `ConfigurableFileCollection`.
   
   The method returns an `Iterable` of type link:{javadocPath}#[FileChanges], which in turn can be queried for the following:
   
   * the link:{javadocPath}#[affected file]
   * the link:{javadocPath}#[change type] (`ADDED`, `REMOVED` or `MODIFIED`)
   * the link:{javadocPath}#[normalized path] of the changed file
   * the link:{javadocPath}#[file type] of the changed file
   
   The following example demonstrates an incremental task that has a directory input.
   It assumes that the directory contains a collection of text files and copies them to an output directory, reversing the text within each file:
   
   ====
   include::sample[dir="snippets/tasks/incrementalTask/kotlin",files="build.gradle.kts[tags=incremental-task]"]
   include::sample[dir="snippets/tasks/incrementalTask/groovy",files="build.gradle[tags=incremental-task]"]
   ====
   
   NOTE: The type of the `inputDir` property, its annotations, and the `execute()` action use `getFileChanges()` to process the subset of files that have changed since the last build.
   The action deletes a target file if the corresponding input file has been removed.
   
   If, for some reason, the task is executed non-incrementally (by running with `--rerun-tasks`, for example), all files are reported as `ADDED`, irrespective of the previous state.
   In this case, Gradle automatically removes the previous outputs, so the incremental task must only process the given files.
   
   For a simple transformer task like the above example, the task action must generate output files for any out-of-date inputs and delete output files for any removed inputs.
   
   IMPORTANT: A task may only contain a single incremental task action.
   
   === Which inputs are considered out of date?
   
   When a task has been previously executed, and the only changes since that execution are to incremental input file properties, Gradle can intelligently determine which input files need to be processed, a concept known as incremental execution.
   
   In this scenario, the link:{groovyDslPath}#[`InputChanges.getFileChanges()`] method, available in the `org.gradle.work.InputChanges` class, provides details for all input files associated with the given property that have been `ADDED`, `REMOVED` or `MODIFIED`.
   
   However, there are many cases where Gradle cannot determine which input files need to be processed (i.e., non-incremental execution). Examples include:
   
   * There is no history available from a previous execution.
   * You are building with a different version of Gradle.
   Currently, Gradle does not use task history from a different version.
   * An link:{javadocPath}#[`upToDateWhen`] criterion added to the task returns `false`.
   * An input property has changed since the previous execution.
   * A non-incremental input file property has changed since the previous execution.
   * One or more output files have changed since the previous execution.
   
   In these cases, Gradle will report all input files as `ADDED`, and the `getFileChanges()` method will return details for all the files that comprise the given input property.
   
   You can check if the task execution is incremental or not with the link:{groovyDslPath}#[`InputChanges.isIncremental()`] method.
   
   === An incremental task in action
   
   Consider an instance of `IncrementalReverseTask` executed against a set of inputs for the first time.
   
   In this case, all inputs will be considered `ADDED`, as shown here:
   
   ====
   include::sample[dir="snippets/tasks/incrementalTask/kotlin",files="build.gradle.kts[tags=reverse]"]
   include::sample[dir="snippets/tasks/incrementalTask/groovy",files="build.gradle[tags=reverse]"]
   ====
   
   The build layout:
   
   [source, text]
   ----
   .
   較럭較 build.gradle
   較덕較 inputs
       較럭較 1.txt
       較럭較 2.txt
       較덕較 3.txt
   ----
   
   [source, text]
   ----
   $ gradle -q incrementalReverse
   include::{snippetsPath}/tasks/incrementalTask/tests/incrementalTaskFirstRun.out[]
   ----
   
   Naturally, when the task is executed again with no changes, then the entire task is `UP-TO-DATE`, and the task action is not executed:
   
   [source, text]
   ----
   $ gradle incrementalReverse
   include::{snippetsPath}/tasks/incrementalTask/tests/incrementalTaskNoChange.out[]
   ----
   
   When an input file is modified in some way or a new input file is added, then re-executing the task results in those files being returned by link:{groovyDslPath}#[`InputChanges.getFileChanges()`].
   
   The following example modifies the content of one file and adds another before running the incremental task:
   
   ====
   include::sample[dir="snippets/tasks/incrementalTask/kotlin",files="build.gradle.kts[tags=updated-inputs]"]
   include::sample[dir="snippets/tasks/incrementalTask/groovy",files="build.gradle[tags=updated-inputs]"]
   
   ----
   $ gradle -q updateInputs incrementalReverse
   include::{snippetsPath}/tasks/incrementalTask/tests/incrementalTaskUpdatedInputs.out[]
   ----
   ====
   
   NOTE: The various mutation tasks (`updateInputs`, `removeInput`, etc) are only present to demonstrate the behavior of incremental tasks.
   They should not be viewed as the kinds of tasks or task implementations you should have in your own build scripts.
   
   When an existing input file is removed, then re-executing the task results in that file being returned by link:{groovyDslPath}#[`InputChanges.getFileChanges()`] as `REMOVED`.
   
   The following example removes one of the existing files before executing the incremental task:
   
   ====
   include::sample[dir="snippets/tasks/incrementalTask/kotlin",files="build.gradle.kts[tags=removed-input]"]
   include::sample[dir="snippets/tasks/incrementalTask/groovy",files="build.gradle[tags=removed-input]"]
   
   ----
   $ gradle -q removeInput incrementalReverse
   include::{snippetsPath}/tasks/incrementalTask/tests/incrementalTaskRemovedInput.out[]
   ----
   ====
   
   Gradle cannot determine which input files are out-of-date when an _output_ file is deleted (or modified).
   In this case, details for _all_ the input files for the given property are returned by link:{groovyDslPath}#[`InputChanges.getFileChanges()`].
   
   The following example removes one of the output files from the build directory.
   However, all the input files are considered to be `ADDED`:
   
   ====
   include::sample[dir="snippets/tasks/incrementalTask/kotlin",files="build.gradle.kts[tags=removed-output]"]
   include::sample[dir="snippets/tasks/incrementalTask/groovy",files="build.gradle[tags=removed-output]"]
   
   ----
   $ gradle -q removeOutput incrementalReverse
   include::{snippetsPath}/tasks/incrementalTask/tests/incrementalTaskRemovedOutput.out[]
   ----
   ====
   
   The last scenario we want to cover concerns what happens when a non-file-based input property is modified.
   In such cases, Gradle cannot determine how the property impacts the task outputs, so the task is executed non-incrementally.
   This means that _all_ input files for the given property are returned by link:{groovyDslPath}#[`InputChanges.getFileChanges()`] and they are all treated as `ADDED`.
   
   The following example sets the project property `taskInputProperty` to a new value when running the `incrementalReverse` task.
   That project property is used to initialize the task's `inputProperty` property, as you can see in the <<ex:incremental_task_definition,first example of this section>>.
   
   Here is the expected output in this case:
   
   ====
   ----
   $ gradle -q -PtaskInputProperty=changed incrementalReverse
   include::{snippetsPath}/tasks/incrementalTask/tests/incrementalTaskChangedProperty.out[]
   ----
   ====
   
   
   == Command Line options
   
   Sometimes, a user wants to declare the value of an exposed task property on the command line instead of the build script.
   Passing property values on the command line is particularly helpful if they change more frequently.
   
   The task API supports a mechanism for marking a property to automatically generate a corresponding command line parameter with a specific name at runtime.
   
   === Step 1. Declare a command-line option
   
   To expose a new command line option for a task property, annotate the corresponding setter method of a property with link:{javadocPath}#[Option]:
   
   ```
   @Option(option = "flag", description = "Sets the flag")
   ```
   
   An option requires a mandatory identifier.
   You can provide an optional description.
   
   A task can expose as many command line options as properties available in the class.
   
   Options may be declared in superinterfaces of the task class as well.
   If multiple interfaces declare the same property but with different option flags, they will both work to set the property.
   
   In the example below, the custom task `UrlVerify` verifies whether a URL can be resolved by making an HTTP call and checking the response code. The URL to be verified is configurable through the property `url`.
   The setter method for the property is annotated with link:{javadocPath}#[@Option]:
   
   [source.multi-language-sample,java]
   .UrlVerify.java
   ----
   include::{snippetsPath}/tasks/commandLineOption-stringOption/groovy/buildSrc/src/main/java/UrlVerify.java[tag=custom-task-implementation]
   ----
   
   All options declared for a task can be <<#sec:listing_task_options,rendered as console output>> by running the `help` task and the `--task` option.
   
   === Step 2. Use an option on the command line
   
   There are a few rules for options on the command line:
   
   - The option uses a double-dash as a prefix, e.g., `--url`.
   A single dash does not qualify as valid syntax for a task option.
   - The option argument follows directly after the task declaration, e.g., `verifyUrl --url=http://www.google.com/`.
   - Multiple task options can be declared in any order on the command line following the task name.
   
   Building upon the earlier example, the build script creates a task instance of type `UrlVerify` and provides a value from the command line through the exposed option:
   
   ====
   include::sample[dir="snippets/tasks/commandLineOption-stringOption/kotlin",files="build.gradle.kts[tags=task]"]
   include::sample[dir="snippets/tasks/commandLineOption-stringOption/groovy",files="build.gradle[tags=task]"]
   ====
   
   ----
   $ gradle -q verifyUrl --url=http://www.google.com/
   include::{snippetsPath}/tasks/commandLineOption-stringOption/tests/taskCommandLineOption.out[]
   ----
   
   === Supported data types for options
   
   Gradle limits the data types that can be used for declaring command line options.
   
   The use of the command line differs per type:
   
   `boolean`, `Boolean`, `Property<Boolean>`::
   Describes an option with the value `true` or `false`. +
   Passing the option on the command line treats the value as `true`.
   For example, `--foo` equates to `true`. +
   The absence of the option uses the default value of the property.
   For each boolean option, an opposite option is created automatically.
   For example, `--no-foo` is created for the provided option `--foo` and `--bar` is created for `--no-bar`.
   Options whose name starts with `--no` are disabled options and set the option value to `false`.
   An opposite option is only created if no option with the same name already exists for the task.
   
   `Double`, `Property<Double>`::
   Describes an option with a double value. +
   Passing the option on the command line also requires a value, e.g., `--factor=2.2` or `--factor 2.2`.
   
   `Integer`, `Property<Integer>`::
   Describes an option with an integer value. +
   Passing the option on the command line also requires a value, e.g., `--network-timeout=5000` or `--network-timeout 5000`.
   
   `Long`, `Property<Long>`::
   Describes an option with a long value. +
   Passing the option on the command line also requires a value, e.g., `--threshold=2147483648` or `--threshold 2147483648`.
   
   `String`, `Property<String>`::
   Describes an option with an arbitrary String value. +
   Passing the option on the command line also requires a value, e.g., `--container-id=2x94held` or `--container-id 2x94held`.
   
   `enum`, `Property<enum>`::
   Describes an option as an enumerated type. +
   Passing the option on the command line also requires a value e.g., `--log-level=DEBUG` or `--log-level debug`. +
   The value is not case-sensitive.
   
   `List<T>` where `T` is `Double`, `Integer`, `Long`, `String`, `enum`::
   Describes an option that can take multiple values of a given type. +
   The values for the option have to be provided as multiple declarations, e.g., `--image-id=123 --image-id=456`. +
   Other notations, such as comma-separated lists or multiple values separated by a space character, are currently not supported.
   
   `ListProperty<T>`, `SetProperty<T>` where `T` is `Double`, `Integer`, `Long`, `String`, `enum`::
   Describes an option that can take multiple values of a given type. +
   The values for the option have to be provided as multiple declarations, e.g., `--image-id=123 --image-id=456`. +
   Other notations, such as comma-separated lists or multiple values separated by a space character, are currently not supported.
   
   `DirectoryProperty`, `RegularFileProperty`::
   Describes an option with a file system element. +
   Passing the option on the command line also requires a value representing a path, e.g., `--output-file=file.txt` or `--output-dir outputDir`. +
   Relative paths are resolved relative to the project directory of the project that owns this property instance.
   See link:{javadocPath}#[`FileSystemLocationProperty.set()`].
   
   === Documenting available values for an option
   
   Theoretically, an option for a property type `String` or `List<String>` can accept any arbitrary value.
   Accepted values for such an option can be documented programmatically with the help of the annotation link:{javadocPath}#[OptionValues]:
   
   ```
   @OptionValues('file')
   ```
   
   This annotation may be assigned to any method that returns a `List` of one of the supported data types.
   You need to specify an option identifier to indicate the relationship between the option and available values.
   
   NOTE: Passing a value on the command line not supported by the option does not fail the build or throw an exception. You must implement custom logic for such behavior in the task action.
   
   The example below demonstrates the use of multiple options for a single task.
   The task implementation provides a list of available values for the option `output-type`:
   
   [source.multi-language-sample,java]
   .UrlProcess.java
   ----
   include::{snippetsPath}/tasks/commandLineOption-optionValues/groovy/buildSrc/src/main/java/UrlProcess.java[tag=custom-task-implementation]
   ----
   
   === Listing command line options
   
   Command line options using the annotations link:{javadocPath}#[Option] and link:{javadocPath}#[OptionValues] are self-documenting.
   
   You will see <<#sec:declaring_task_option,declared options>> and their <<#sec:documenting_available_task_option_values,available values>> reflected in the console output of the `help` task.
   The output renders options alphabetically, except for boolean disable options, which appear following the enable option:
   
   ----
   $ gradle -q help --task processUrl
   include::{snippetsPath}/tasks/commandLineOption-optionValues/tests/helpTaskOptions.out[]
   ----
   
   === Limitations
   
   Support for declaring command line options currently comes with a few limitations.
   
   - Command line options can only be declared for custom tasks via annotation.
   There's no programmatic equivalent for defining options.
   - Options cannot be declared globally, e.g., on a project level or as part of a plugin.
   - When assigning an option on the command line, the task exposing the option needs to be spelled out explicitly, e.g., `gradle check --tests abc` does not work even though the `check` task depends on the `test` task.
   - If you specify a task option name that conflicts with the name of a built-in Gradle option, use the `--` delimiter before calling your task to reference that option.
   For more information, see <<command_line_interface.adoc#sec:disambiguate_task_options_from_built_in_options, Disambiguate Task Options from Built-in Options>>.
   
   == Verification failures
   
   Normally, exceptions thrown during task execution result in a failure that immediately terminates a build.
   The outcome of the task will be `FAILED`, the result of the build will be `FAILED`, and no further tasks will be executed.
   When <<command_line_interface.adoc#sec:continue_build_on_failure, running with the `--continue` flag>>, Gradle will continue to run other requested tasks in the build after encountering a task failure.
   However, any tasks that depend on a failed task will not be executed.
   
   There is a special type of exception that behaves differently when downstream tasks only rely on the outputs of a failing task.
   A task can throw a subtype of link:{javadocPath}#[VerificationException] to indicate that it has failed in a controlled manner such that its output is still valid for consumers.
   A task depends on the *outcome* of another task when it directly depends on it using `dependsOn`.
   When Gradle is run with `--continue`, consumer tasks that depend on a producer task's output (via a relationship between task inputs and outputs) can still run after the consumer fails.
   
   A failed unit test, for instance, will cause a failing outcome for the test task.
   However, this doesn't prevent another task from reading and processing the (valid) test results the task produced.
   Verification failures are used in exactly this manner by the <<test_report_aggregation_plugin.adoc#test_report_aggregation_plugin, `Test Report Aggregation Plugin`>>.
   
   Verification failures are also useful for tasks that need to report a failure even after producing useful output consumable by other tasks.
   
   ====
   include::sample[dir="snippets/failures/verificationFailure/kotlin",files="build.gradle.kts[tags=verification-failure]"]
   include::sample[dir="snippets/failures/verificationFailure/groovy",files="build.gradle[tags=verification-failure]"]
   ====
   ----
   $ gradle postProcess --continue
   include::{snippetsPath}/failures/verificationFailure/tests/verificationFailure.out[]
   ----
   <1> *Register Output*: The `process` task writes its output to a log file.
   <2> *Modify Output*: The task writes to its output file as it executes.
   <3> *Task Failure*: The task throws a `VerificationException` and fails at this point.
   <4> *Continue to Modify Output*: This line never runs due to the exception stopping the task.
   <5> *Consume Output*: The `postProcess` task depends on the output of the `process` task due to using that task's outputs as its own inputs.
   <6> *Use Partial Result*: With the `--continue` flag set, Gradle still runs the requested `postProcess` task despite the `process` task's failure.  `postProcess` can read and display the partial (though still valid) result.

/Section: 游릭 Developing Plugins
=================================


/docs/userguide/authoring-builds/plugins/custom_plugins.adoc
============================================================

.. code-block::

   = Understanding Plugins
   
   Gradle comes with a set of powerful core systems such as dependency management, task execution, and project configuration.
   But everything else it can do is supplied by plugins.
   
   Plugins encapsulate logic for specific tasks or integrations, such as compiling code, running tests, or deploying artifacts.
   By applying plugins, users can easily add new features to their build process without having to write complex code from scratch.
   
   This plugin-based approach allows Gradle to be lightweight and modular.
   It also promotes code reuse and maintainability, as plugins can be shared across projects or within an organization.
   
   Before reading this chapter, it's recommended that you first read the <<gradle_directories.adoc#gradle_directories,Learning The Basics>> and complete the <<partr1_gradle_init.adoc#partr1_gradle_init,Tutorial>>.
   
   == Plugins Introduction
   
   Plugins can be sourced from Gradle or the Gradle community.
   But when users want to organize their build logic or need specific build capabilities not provided by existing plugins, they can develop their own.
   
   As such, we distinguish between three different kinds of plugins:
   
   1. *Core Plugins* - plugins that come from Gradle.
   2. *Community Plugins* - plugins that come from link:https://plugins.gradle.org/[Gradle Plugin Portal] or a public repository.
   3. *Local or Custom Plugins* - plugins that you develop yourself.
   
   === Core Plugins
   The term *core plugin* refers to a plugin that is part of the Gradle distribution such as the <<java_library_plugin.adoc#java_library_plugin,Java Library Plugin>>.
   They are always available.
   
   === Community Plugins
   The term *community plugin* refers to a plugin published to the Gradle Plugin Portal (or another public repository) such as the link:https://plugins.gradle.org/plugin/com.diffplug.gradle.spotless[Spotless Plugin].
   In order for Gradle to find the plugin, you must declare the repository that provides the plugin.
   
   === Local or Custom Plugins
   The term *local or custom plugin* refers to a plugin you write yourself for your own build.
   
   == Custom plugins
   
   There are three types of *custom plugins*:
   
   [cols="~,~,~,~,~"]
   |===
   |# |Type |Location: |Most likely: |Benefit:
   
   |<<sec:build_script_plugins,1>>
   |<<sec:build_script_plugins,Build script plugins>>
   |Build script
   |A local plugin
   |Plugin is automatically compiled and included in the classpath of the build script.
   
   |<<sec:precompile_script_plugin,2>>
   |<<sec:precompile_script_plugin,Precompiled script plugins>>
   |<<sharing_build_logic_between_subprojects.adoc#sec:using_buildsrc,`buildSrc`>> folder
   |A convention plugin
   |Plugin is automatically compiled, tested, and available on the classpath of the build script. The plugin is visible to every build script used by the build.
   
   |<<sec:custom_plugins_standalone_project,3>>
   |<<sec:custom_plugins_standalone_project,Binary plugins>>
   |Standalone project
   |A shared plugin
   |Plugin JAR is produced and published. The plugin can be used in multiple builds and shared with others.
   |===
   
   == Build script plugins
   
   *Build script plugins* are typically small, local plugins written in build files for tasks specific to a single build or project and do not need to be reused across multiple projects.
   
   To create a Gradle plugin, you need to write a class that implements the link:{javadocPath}#[Plugin] interface in one of your build files.
   
   The following sample creates a `GreetingPlugin`, which adds a `hello` task to a project:
   
   ====
   include::sample[dir="snippets/customPlugins/customPlugin/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/customPlugins/customPlugin/groovy",files="build.gradle[]"]
   ====
   
   ----
   $ gradle -q hello
   include::{snippetsPath}/customPlugins/customPlugin/tests/customPlugin.out[]
   ----
   
   The `Project` object is passed as a parameter in `apply()`, which the plugin can use to configure the project however it needs to (such as adding tasks, configuring dependencies, etc.)
   
   == Precompiled script plugins
   
   *Precompiled script plugins* are compiled into class files and packaged into a JAR before they are executed.
   They are best used as *convention plugins* that share build logic across projects or as a way to neatly organize build logic.
   
   To create a precompiled script plugin, you can:
   
   1. Use Gradle's Kotlin DSL - The plugin is a `.gradle.kts` file, and apply `id("kotlin-dsl")`.
   2. Use Gradle's Groovy DSL - The plugin is a `.gradle` file, and apply `id("groovy-gradle-plugin")`.
   3. Write a Java, Scala, Kotlin, or Groovy class - The plugin is an abstract class that implements the `Plugin<Project>` interface, and apply `id("java-gradle-plugin")`.
   
   To apply a precompiled script plugin, you need to know its ID.
   The ID is derived from the plugin script's filename and its (optional) package declaration.
   
   For example, the script `src/main/\*/java-library-convention.gradle(.kts)` has a plugin ID of `java-library-convention` (assuming it has no package declaration).
   Likewise, `src/main/\*/my/java-library-convention.gradle(.kts)` has a plugin ID of `my.java-library-convention` as long as it has a package declaration of `my`.
   
   Precompiled script plugin names have two important limitations:
   
   * They cannot start with `org.gradle`.
   * They cannot have the same name as a <<plugin_reference#plugin_reference,core plugin>>.
   
   When the plugin is applied to a project, Gradle creates an instance of the plugin class and calls the instance's link:{javadocPath}#[Plugin.apply()] method.
   
   NOTE: A new instance of a `Plugin` is created within each project applying that plugin.
   
   Let's rewrite the `GreetingPlugin` script plugin as a precompiled script plugin:
   
   ====
   include::sample[dir="snippets/plugins/greetingPlugin/kotlin",files="buildSrc/src/main/kotlin/com/example/ConventionGreetingPlugin.gradle.kts[]"]
   include::sample[dir="snippets/plugins/greetingPlugin/groovy",files="buildSrc/src/main/groovy/com/example/ConventionGreetingPlugin.gradle[]"]
   ====
   
   The `GreetingPlugin` can now be applied in other subprojects' builds by using its ID:
   
   ====
   include::sample[dir="snippets/plugins/greetingPlugin/kotlin",files="app/build.gradle.kts[tag=use-plugin]"]
   include::sample[dir="snippets/plugins/greetingPlugin/groovy",files="app/build.gradle[tag=use-plugin]"]
   ====
   
   == Convention Plugins
   
   A *convention plugin* is typically a plugin that configures existing core and community plugins with your own conventions (i.e. default values) such as setting the Java version by using `java.toolchain.languageVersion.set(JavaLanguageVersion.of(17))`.
   Convention plugins are also used to enforce project standards and help streamline the build process.
   They can apply and configure plugins, create new tasks and extensions, set dependencies, and much more.
   
   Let's take an example build with three subprojects: one for `data-model`, one for `database-logic` and one for `app` code.
   The project has the following structure:
   
   [source, text]
   ----
   .
   較럭較 buildSrc
   較   較럭較 src
   較   較   較덕較...
   較   較덕較 build.gradle.kts
   較럭較 data-model
   較   較럭較 src
   較   較   較덕較...
   較   較덕較 build.gradle.kts
   較럭較 database-logic
   較   較럭較 src
   較   較   較덕較...
   較   較덕較 build.gradle.kts
   較럭較 app
   較   較럭較 src
   較   較   較덕較...
   較   較덕較 build.gradle.kts
   較덕較 settings.gradle.kts
   ----
   
   The build file of the `database-logic` subproject is as follows:
   
   ====
   include::sample[dir="snippets/plugins/pluginProject/kotlin",files="database-logic/build.gradle.kts[]"]
   include::sample[dir="snippets/plugins/pluginProject/groovy",files="database-logic/build.gradle[]"]
   ====
   
   We apply the `java-library` plugin and add the `org.jetbrains.kotlin.jvm` plugin for Kotlin support.
   We also configure Kotlin, Java, tests and more.
   
   Our build file is beginning to grow...
   
   The more plugins we apply and the more plugins we configure, the larger it gets.
   There's also repetition in the build files of the `app` and `data-model` subprojects, especially when configuring common extensions like setting the Java version and Kotlin support.
   
   To address this, we use convention plugins.
   This allows us to avoid repeating configuration in each build file and keeps our build scripts more concise and maintainable.
   In convention plugins, we can encapsulate arbitrary build configuration or custom build logic.
   
   To develop a convention plugin, we recommend using <<sharing_build_logic_between_subprojects.adoc#sec:using_buildsrc,`buildSrc`>>  which represents a completely separate Gradle build.
   `buildSrc` has its own settings file to define where dependencies of this build are located.
   
   We add a Kotlin script called `my-java-library.gradle.kts` inside the `buildSrc/src/main/kotlin` directory.
   Or conversely, a Groovy script called `my-java-library.gradle` inside the `buildSrc/src/main/groovy` directory.
   We put all the plugin application and configuration from the `database-logic` build file into it:
   
   ====
   include::sample[dir="snippets/plugins/pluginProject/kotlin",files="buildSrc/src/main/kotlin/my-java-library.gradle.kts[]"]
   include::sample[dir="snippets/plugins/pluginProject/groovy",files="buildSrc/src/main/groovy/my-java-library.gradle[]"]
   ====
   
   The name of the file `my-java-library` is the ID of our brand-new plugin, which we can now use in all of our subprojects.
   
   The `database-logic` build file becomes much simpler by removing all the redundant build logic and applying our convention `my-java-library` plugin instead:
   
   ====
   [.multi-language-sample]
   =====
   .database-logic/build.gradle.kts
   [source,kotlin]
   ----
   plugins {
       id("my-java-library")
   }
   ----
   =====
   [.multi-language-sample]
   =====
   ..database-logic/build.gradle
   [source,groovy]
   ----
   plugins {
       id('my-java-library')
   }
   ----
   =====
   ====
   
   This convention plugin enables us to easily share common configurations across all our build files.
   Any modifications can be made in one place, simplifying maintenance.
   
   == Binary plugins
   
   *Binary plugins* in Gradle are plugins that are built as standalone JAR files and applied to a project using the `plugins{}` block in the build script.
   
   Let's move our `GreetingPlugin` to a standalone project so that we can publish it and share it with others.
   The plugin is essentially moved from the `buildSrc` folder to its own build called `greeting-plugin`.
   
   NOTE: You can publish the plugin from `buildSrc`, but this is not recommended practice. Plugins that are ready for publication should be in their own build.
   
   `greeting-plugin` is simply a Java project that produces a JAR containing the plugin classes.
   
   The easiest way to package and publish a plugin to a repository is to use the <<java_gradle_plugin.adoc#java_gradle_plugin,Gradle Plugin Development Plugin>>.
   This plugin provides the necessary tasks and configurations (including the plugin metadata) to compile your script into a plugin that can be applied in other builds.
   
   Here is a simple build script for the `greeting-plugin` project using the Gradle Plugin Development Plugin:
   
   ====
   include::sample[dir="snippets/plugins/customPlugin/kotlin/java-gradle-plugin",files="build.gradle.kts[tags=use-and-configure-plugin]"]
   include::sample[dir="snippets/plugins/customPlugin/groovy/java-gradle-plugin",files="build.gradle[tags=use-and-configure-plugin]"]
   ====
   
   For more on publishing plugins, see <<publishing_gradle_plugins.adoc#plugin-publishing-plugin,Publishing Plugins>>.
   
   ==  Project vs Settings vs Init plugins
   
   In the example used through this section, the plugin accepts the link:{groovyDslPath}#[Project] type as a type parameter.
   Alternatively, the plugin can accept a parameter of type link:{groovyDslPath}#[Settings] to be applied in a settings script, or a parameter of type link:{groovyDslPath}#[Gradle] to be applied in an initialization script.
   
   The difference between these types of plugins lies in the scope of their application:
   
   Project Plugin :: A project plugin is a plugin that is applied to a specific project in a build.
   It can customize the build logic, add tasks, and configure the project-specific settings.
   
   Settings Plugin :: A settings plugin is a plugin that is applied in the `settings.gradle` or `settings.gradle.kts` file.
   It can configure settings that apply to the entire build, such as defining which projects are included in the build, configuring build script repositories, and applying common configurations to all projects.
   
   Init Plugin :: An init plugin is a plugin that is applied in the `init.gradle` or `init.gradle.kts` file.
   It can configure settings that apply globally to all Gradle builds on a machine, such as configuring the Gradle version, setting up default repositories, or applying common plugins to all builds.

/docs/userguide/authoring-builds/plugins/implementing_gradle_plugins.adoc
=========================================================================

.. code-block::

   = Understanding Implementation Options for Plugins
   
   The choice between script, precompiled script, or binary plugins depends on your specific requirements and preferences.
   
   *Script Plugins* are simple and easy to write as they are written directly in the build script.
   They are written in Kotlin DSL or Groovy DSL.
   They are suitable for small, one-off tasks or for quick experimentation.
   However, they can become hard to maintain as the build script grows in size and complexity.
   
   *Precompiled Script Plugins* are Kotlin DSL scripts compiled into Java class files packaged in a library.
   They offer better performance and maintainability compared to script plugins, and they can be reused across different projects.
   You can also write them in Groovy DSL but that is not recommended.
   
   *Binary Plugins* are full-fledged plugins written in Java or Kotlin, compiled into JAR files, and published to a repository.
   They offer the best performance, maintainability, and reusability.
   They are suitable for complex build logic that needs to be shared across projects, builds, and teams.
   You can also write them in Scala or Groovy but that is not recommended.
   
   
   Here is a breakdown of all options for implementing Gradle plugins:
   
   [cols="~,~,~,~,~,~"]
   |===
   |*#* |*Using:* |*Type:* |*The Plugin is:* |*Created by applying:* |*Recommended?*
   
   |1
   |Kotlin DSL
   |Script
   |in a `.gradle.kts` file as an abstract class that implements the `apply(Project project)` method of the `Plugin<Project>` interface.
   |
   |Nofootnote:1[<<custom_plugins#sec:build_script_plugins,*Script plugins*>> are hard to maintain, test, and do not support defining new reusable types. They are not recommended.]
   
   |2
   |Groovy DSL
   |Script
   |in a `.gradle` file as an abstract class that implements the `apply(Project project)` method of the `Plugin<Project>` interface.
   |
   |Nofootnote:1[]
   
   |3
   |Kotlin DSL
   |Pre-compiled script
   |a `.gradle.kts` file
   |`id("kotlin-dsl")`
   |Yesfootnote:3[It is recommended to use a statically-typed language like *Java* or *Kotlin* for implementing plugins to reduce the likelihood of binary incompatibilities. If using Groovy, consider using `@groovy.transform.CompileStatic`.]
   
   |4
   |Groovy DSL
   |Pre-compiled script
   |a `.gradle` file
   |`id("groovy-gradle-plugin")`
   |Nofootnote:2[<<custom_plugins#sec:precompile_script_plugin,*Pre-compiled script*>> plugins are best used as <<custom_plugins#sec:convention_plugins,*convention plugins*>> written in Kotlin DSL or Java.]
   
   |5
   |Kotlin DSL
   |Binary
   |a `.gradle.kts` file
   |`id("kotlin-dsl")` +
   `id("com.gradle.plugin-publish")`
   |Yesfootnote:3[]
   
   |6
   |Groovy DSL
   |Binary
   |a `.gradle` file
   |`id("groovy-gradle-plugin")` +
   `id("com.gradle.plugin-publish")`
   |Nofootnote:3[]
   
   |7
   |Java
   |Binary
   |an abstract class that implements the `apply(Project project)` method of the `Plugin<Project>` interface.
   |`id("java-gradle-plugin")` +
   `id("com.gradle.plugin-publish")`
   |Yesfootnote:3[<<custom_plugins#sec:custom_plugins_standalone_project,*Binary plugins*>> should be used when logic needs to be shared across independent projects. They allow for structuring code into classes and packages, are cacheable, support versioning, and are easily testable.]
   
   |8
   |Kotlin
   |Binary
   |an abstract class that implements the `apply(Project project)` method of the `Plugin<Project>` interface.
   |`id("java-gradle-plugin")` +
   `id("org.jetbrains.kotlin.jvm")` +
   `id("com.gradle.plugin-publish")`
   |Yesfootnote:3[]
   
   |9
   |Groovy
   |Binary
   |an abstract class that implements the `apply(Project project)` method of the `Plugin<Project>` interface.
   |`id("java-gradle-plugin")` +
   `id("groovy")` +
   `id("com.gradle.plugin-publish")`
   |Nofootnote:3[]
   
   |10
   |Scala
   |Binary
   |an abstract class that implements the `apply(Project project)` method of the `Plugin<Project>` interface.
   |`id("java-gradle-plugin")` +
   `id("scala")` +
   `id("com.gradle.plugin-publish")`
   |Nofootnote:3[]
   |===
   
   If you suspect issues with your plugin code, try creating a link:https://scans.gradle.com/[Build Scan] to identify bottlenecks.
   The link:https://github.com/gradle/gradle-profiler[Gradle profiler] can help automate Build Scan generation and gather more low-level information.

/docs/userguide/authoring-builds/plugins/implementing_gradle_plugins_precompiled.adoc
=====================================================================================

.. code-block::

   = Implementing Pre-compiled Script Plugins
   
   A *precompiled script plugin* is typically a Kotlin script that has been compiled and distributed as Java class files packaged in a library.
   These scripts are intended to be consumed as binary Gradle plugins and are recommended for use as convention plugins.
   
   == The plugin ID
   
   The plugin ID for a precompiled script is derived from its file name and optional package declaration.
   
   For example, a script named `code-quality.gradle(.kts)` located in `src/main/groovy` (or `src/main/kotlin`) without a package declaration would be exposed as the `code-quality` plugin:
   
   [source,kotlin]
   ----
   plugins {
       id("code-quality")
   }
   ----
   
   On the other hand, a script named `code-quality.gradle(.kts)` located in `src/main/groovy/my` (or `src/main/kotlin/my`) with the package declaration `my` would be exposed as the `my.code-quality` plugin:
   
   [source,kotlin]
   ----
   plugins {
       id("my.code-quality")
   }
   ----
   
   == Working with files
   
   You should use Gradle's <<custom_gradle_types.adoc#managed_properties,managed properties>> and `project.layout` to select file or directory locations.
   This will enable <<lazy_configuration.adoc#lazy_configuration,lazy configuration>> so that the actual location will only be resolved when the file is needed and can be reconfigured at any time during build configuration.
   
   Let's start by creating a convention plugin called `greetings`:
   
   ====
   include::sample[dir="snippets/plugins/greeting/kotlin", files="buildSrc/src/main/kotlin/greetings.gradle.kts[tags=extension]"]
   include::sample[dir="snippets/plugins/greeting/groovy", files="buildSrc/src/main/groovy/greetings.gradle[tags=extension]"]
   ====
   
   You can find out more about working with files lazily in <<working_with_files.adoc#working_with_files,Working with Files>>.
   
   == Making a plugin configurable using extensions
   
   *Extension objects* are commonly used in plugins to expose configuration options and additional functionality to build scripts.
   
   When you apply a plugin that defines an extension, you can access the extension object and configure its properties or call its methods to customize the behavior of the plugin or tasks provided by the plugin.
   
   A link:{groovyDslPath}#[Project] has an associated link:{javadocPath}#[ExtensionContainer] object that contains all the settings and properties for the plugins that have been applied to the project.
   You can provide configuration for your plugin by adding an extension object to this container.
   
   Let's update our `greetings` example:
   
   ====
   include::sample[dir="snippets/plugins/greeting/kotlin", files="buildSrc/src/main/kotlin/greetings.gradle.kts[tags=create-extension]"]
   include::sample[dir="snippets/plugins/greeting/groovy", files="buildSrc/src/main/groovy/greetings.gradle[tags=create-extension]"]
   ====
   
   You can set the value of the `message` property directly with `extension.message.set("Hi from Gradle,")`.
   
   However, the `GreetingPluginExtension` object becomes available as a project property with the same name as the extension object.
   You can now access `message` like so:
   
   ====
   include::sample[dir="snippets/plugins/greeting/kotlin", files="buildSrc/src/main/kotlin/greetings.gradle.kts[tags=update]"]
   include::sample[dir="snippets/plugins/greeting/groovy", files="buildSrc/src/main/groovy/greetings.gradle[tags=update]"]
   ====
   
   You can find out more about implementing project extensions in <<custom_gradle_types.adoc#custom_gradle_types,Developing Custom Gradle Types>>.
   
   == Adding default configuration as conventions
   
   In plugins, you can define default values, also known as *conventions*, using the `project` object.
   
   Convention properties are properties that are initialized with default values but can be overridden:
   
   ====
   include::sample[dir="snippets/plugins/greeting/kotlin", files="buildSrc/src/main/kotlin/greetings.gradle.kts[tags=convention]"]
   include::sample[dir="snippets/plugins/greeting/groovy", files="buildSrc/src/main/groovy/greetings.gradle[tags=convention]"]
   ====
   
   `extension.message.convention(...)` sets a convention for the `message` property of the extension.
   This convention specifies that the value of `message` should default to the content of a file named `defaultGreeting.txt` located in the build directory of the project.
   
   If the `message` property is not explicitly set, its value will be automatically set to the content of `defaultGreeting.txt`.
   
   == Mapping extension properties to task properties
   
   Using an extension and mapping it to a custom task's input/output properties is common in plugins.
   
   In this example, the message property of the `GreetingPluginExtension` is mapped to the message property of the `GreetingTask` as an input:
   
   ====
   include::sample[dir="snippets/plugins/greeting/kotlin", files="buildSrc/src/main/kotlin/greetings.gradle.kts[tags=task]"]
   include::sample[dir="snippets/plugins/greeting/groovy", files="buildSrc/src/main/groovy/greetings.gradle[tags=task]"]
   ====
   
   ----
   $ gradle -q hello
   include::{snippetsPath}/plugins/greeting/tests/greeting.out[]
   ----
   
   This means that changes to the extension's `message` property will trigger the task to be considered out-of-date, ensuring that the task is re-executed with the new message.
   
   You can find out more about types that you can use in task implementations and extensions in <<lazy_configuration.adoc#lazy_configuration,Lazy Configuration>>.
   
   == Applying external plugins
   
   In order to apply an external plugin in a precompiled script plugin, it has to be added to the plugin project's implementation classpath in the plugin's build file:
   
   ====
   include::sample[dir="snippets/plugins/precompiledScriptPlugins-externalPlugins/kotlin",files="buildSrc/build.gradle.kts[]"]
   include::sample[dir="snippets/plugins/precompiledScriptPlugins-externalPlugins/groovy",files="buildSrc/build.gradle[]"]
   ====
   
   It can then be applied in the precompiled script plugin:
   ====
   include::sample[dir="snippets/plugins/precompiledScriptPlugins-externalPlugins/kotlin",files="buildSrc/src/main/kotlin/my-plugin.gradle.kts[]"]
   include::sample[dir="snippets/plugins/precompiledScriptPlugins-externalPlugins/groovy",files="buildSrc/src/main/groovy/my-plugin.gradle[]"]
   ====
   
   The plugin version in this case is defined in the dependency declaration.

/docs/userguide/authoring-builds/plugins/implementing_gradle_plugins_binary.adoc
================================================================================

.. code-block::

   = Implementing Binary Plugins
   
   *Binary plugins* refer to plugins that are compiled and distributed as JAR files.
   These plugins are usually written in Java or Kotlin and provide custom functionality or tasks to a Gradle build.
   
   == Using the Plugin Development plugin
   
   The <<java_gradle_plugin.adoc#java_gradle_plugin,Gradle Plugin Development plugin>> can be used to assist in developing Gradle plugins.
   
   This plugin will automatically apply the <<java_plugin.adoc#java_plugin,Java Plugin>>, add the `gradleApi()` dependency to the `api` configuration, generate the required plugin descriptors in the resulting JAR file, and configure the <<plugins.adoc#sec:plugin_markers,Plugin Marker Artifact>> to be used when publishing.
   
   To apply and configure the plugin, add the following code to your build file:
   
   ====
   include::sample[dir="snippets/plugins/customPlugin/kotlin/java-gradle-plugin",files="build.gradle.kts[tags=use-and-configure-plugin]"]
   include::sample[dir="snippets/plugins/customPlugin/groovy/java-gradle-plugin",files="build.gradle[tags=use-and-configure-plugin]"]
   ====
   
   Writing and using <<actionable_tasks.adoc#sec:task_groups,custom task types>> is recommended when developing plugins as it automatically benefits from <<incremental_build.adoc#incremental_build,incremental builds>>.
   As an added benefit of applying the plugin to your project, the task `validatePlugins` automatically checks for an existing input/output annotation for every public property defined in a custom task type implementation.
   
   == Creating a plugin ID
   
   Plugin IDs are meant to be globally unique, similar to Java package names (i.e., a reverse domain name).
   This format helps prevent naming collisions and allows grouping plugins with similar ownership.
   
   An explicit plugin identifier simplifies applying the plugin to a project.
   Your plugin ID should combine components that reflect the namespace (a reasonable pointer to you or your organization) and the name of the plugin it provides.
   For example, if your Github account is named `foo` and your plugin is named `bar`, a suitable plugin ID might be `com.github.foo.bar`.
   Similarly, if the plugin was developed at the `baz` organization, the plugin ID might be `org.baz.bar`.
   
   Plugin IDs should adhere to the following guidelines:
   
   - May contain any alphanumeric character, '.', and '-'.
   - Must contain at least one '.' character separating the namespace from the plugin's name.
   - Conventionally use a lowercase reverse domain name convention for the namespace.
   - Conventionally use only lowercase characters in the name.
   - `org.gradle`, `com.gradle`, and `com.gradleware` namespaces may not be used.
   - Cannot start or end with a '.' character.
   - Cannot contain consecutive '.' characters (i.e., '..').
   
   A namespace that identifies ownership and a name is sufficient for a plugin ID.
   
   When bundling multiple plugins in a single JAR artifact, adhering to the same naming conventions is recommended.
   This practice helps logically group related plugins.
   
   There is no limit to the number of plugins that can be defined and registered (by different identifiers) within a single project.
   
   The identifiers for plugins written as a class should be defined in the project's build script containing the plugin classes.
   For this, the `java-gradle-plugin` needs to be applied:
   
   ====
   include::sample[dir="snippets/developingPlugins/pluginIdentifier/kotlin",files="buildSrc/build.gradle.kts[]"]
   include::sample[dir="snippets/developingPlugins/pluginIdentifier/groovy",files="buildSrc/build.gradle[]"]
   ====
   
   == Working with files
   
   When developing plugins, it's a good idea to be flexible when accepting input configuration for file locations.
   
   It is recommended to use Gradle's <<custom_gradle_types.adoc#managed_properties,managed properties>> and `project.layout` to select file or directory locations.
   This will enable lazy configuration so that the actual location will only be resolved when the file is needed and can be reconfigured at any time during build configuration.
   
   This Gradle build file defines a task `GreetingToFileTask` that writes a greeting to a file.
   It also registers two tasks: `greet`, which creates the file with the greeting, and `sayGreeting`, which prints the file's contents.
   The `greetingFile` property is used to specify the file path for the greeting:
   
   ====
   include::sample[dir="snippets/tasks/customTaskWithFileProperty/kotlin",files="build.gradle.kts[tags=all]"]
   include::sample[dir="snippets/tasks/customTaskWithFileProperty/groovy",files="build.gradle[tags=all]"]
   ====
   
   ----
   $ gradle -q sayGreeting
   include::{snippetsPath}/tasks/customTaskWithFileProperty/tests/lazyFileProperties.out[]
   ----
   
   In this example, we configure the `greet` task `destination` property as a closure/provider, which is evaluated with
   the link:{groovyDslPath}#[Project.file(java.lang.Object)] method to turn the return value of the closure/provider into a `File` object at the last minute.
   Note that we specify the `greetingFile` property value _after_ the task configuration.
   This lazy evaluation is a key benefit of accepting any value when setting a file property and then resolving that value when reading the property.
   
   You can learn more about working with files lazily in <<working_with_files.adoc#working_with_files,Working with Files>>.
   
   == Making a plugin configurable using extensions
   
   Most plugins offer configuration options for build scripts and other plugins to customize how the plugin works.
   Plugins do this using *extension objects*.
   
   A link:{groovyDslPath}#[Project] has an associated link:{javadocPath}#[ExtensionContainer] object that contains all the settings and properties for the plugins that have been applied to the project.
   You can provide configuration for your plugin by adding an extension object to this container.
   
   An extension object is simply an object with Java Bean properties representing the configuration.
   
   Let's add a `greeting` extension object to the project, which allows you to configure the greeting:
   
   ====
   include::sample[dir="snippets/customPlugins/customPluginNoConvention/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/customPlugins/customPluginNoConvention/groovy",files="build.gradle[]"]
   ====
   
   ----
   $ gradle -q hello
   include::{snippetsPath}/customPlugins/customPluginNoConvention/tests/customPluginNoConvention.out[]
   ----
   
   In this example, `GreetingPluginExtension` is an object with a property called `message`.
   The extension object is added to the project with the name `greeting`.
   This object becomes available as a project property with the same name as the extension object.
   `the<GreetingPluginExtension>()` is equivalent to `project.extensions.getByType(GreetingPluginExtension::class.java)`.
   
   Often, you have several related properties you need to specify on a single plugin.
   Gradle adds a configuration block for each extension object, so you can group settings:
   
   ====
   include::sample[dir="snippets/customPlugins/customPluginWithAdvancedConvention/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/customPlugins/customPluginWithAdvancedConvention/groovy",files="build.gradle[]"]
   ====
   
   ----
   $ gradle -q hello
   include::{snippetsPath}/customPlugins/customPluginWithAdvancedConvention/tests/customPluginWithAdvancedConvention.out[]
   ----
   
   [.multi-language-text.lang-kotlin]
   In this example, several settings can be grouped within the `configure<GreetingPluginExtension>` block.
   The link:{javadocPath}#[`configure`] function is used to configure an extension object.
   It provides a convenient way to set properties or apply configurations to these objects.
   The type used in the build script's `configure` function (`GreetingPluginExtension`) must match the extension type.
   Then, when the block is executed, the receiver of the block is the extension.
   
   [.multi-language-text.lang-groovy]
   In this example, several settings can be grouped within the `greeting` closure. The name of the closure block in the build script (`greeting`) must match the extension object name.
   Then, when the closure is executed, the fields on the extension object will be mapped to the variables within the closure based on the standard Groovy closure delegate feature.
   
   == Declaring a DSL configuration container
   
   Using an extension object _extends_ the Gradle DSL to add a project property and DSL block for the plugin.
   Because an extension object is a regular object, you can provide your own DSL nested inside the plugin block by adding properties and methods to the extension object.
   
   Let's consider the following build script for illustration purposes.
   
   ====
   include::sample[dir="snippets/developingPlugins/namedDomainObjectContainer/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/developingPlugins/namedDomainObjectContainer/groovy",files="build.gradle[]"]
   ====
   
   The DSL exposed by the plugin exposes a container for defining a set of environments.
   Each environment the user configures has an arbitrary but declarative name and is represented with its own DSL configuration block.
   The example above instantiates a development, staging, and production environment, including its respective URL.
   
   Each environment must have a data representation in code to capture the values.
   The name of an environment is immutable and can be passed in as a constructor parameter.
   Currently, the only other parameter the data object stores is a URL.
   
   The following `ServerEnvironment` object fulfills those requirements:
   
   .ServerEnvironment.java
   [source,java]
   ----
   include::{snippetsPath}/developingPlugins/namedDomainObjectContainer/groovy/buildSrc/src/main/java/org/myorg/ServerEnvironment.java[tags=snippet]
   ----
   
   Gradle exposes the factory method
   link:{javadocPath}#[ObjectFactory.domainObjectContainer(Class, NamedDomainObjectFactory)]
   to create a container of data objects.
   The parameter the method takes is the class representing the data.
   The created instance of type link:{javadocPath}#[NamedDomainObjectContainer] can be exposed to the end user by adding it to the extension container with a specific name.
   
   It's common for a plugin to post-process the captured values within the plugin implementation, e.g., to configure tasks:
   
   .ServerEnvironmentPlugin.java
   [source,java]
   ----
   include::{snippetsPath}/developingPlugins/namedDomainObjectContainer/groovy/buildSrc/src/main/java/org/myorg/ServerEnvironmentPlugin.java[tags=snippet]
   ----
   
   In the example above, a deployment task is created dynamically for every user-configured environment.
   
   You can find out more about implementing project extensions in <<custom_gradle_types.adoc#custom_gradle_types,Developing Custom Gradle Types>>.
   
   == Modeling DSL-like APIs
   DSLs exposed by plugins should be readable and easy to understand.
   
   For example, let's consider the following extension provided by a plugin.
   In its current form, it offers a "flat" list of properties for configuring the creation of a website:
   
   ====
   include::sample[dir="snippets/developingPlugins/pluginExtension/kotlin",files="build-flat.gradle.kts[]"]
   include::sample[dir="snippets/developingPlugins/pluginExtension/groovy",files="build-flat.gradle[]"]
   ====
   
   As the number of exposed properties grows, you should introduce a nested, more expressive structure.
   
   The following code snippet adds a new configuration block named `customData` as part of the extension.
   This provides a stronger indication of what those properties mean:
   
   ====
   include::sample[dir="snippets/developingPlugins/pluginExtension/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/developingPlugins/pluginExtension/groovy",files="build.gradle[]"]
   ====
   
   Implementing the backing objects for such an extension is simple.
   First, introduce a new data object for managing the properties `websiteUrl` and `vcsUrl`:
   
   .CustomData.java
   [source,java]
   ----
   include::{snippetsPath}/developingPlugins/pluginExtension/groovy/buildSrc/src/main/java/org/myorg/CustomData.java[tags=snippet]
   ----
   
   In the extension, create an instance of the `CustomData` class and a method to delegate the captured values to the data instance.
   
   To configure underlying data objects, define a parameter of type link:{javadocPath}#[Action].
   
   The following example demonstrates the use of `Action` in an extension definition:
   
   .SiteExtension.java
   [source,java]
   ----
   include::{snippetsPath}/developingPlugins/pluginExtension/groovy/buildSrc/src/main/java/org/myorg/SiteExtension.java[tags=snippet]
   ----
   
   == Mapping extension properties to task properties
   
   Plugins commonly use an extension to capture user input from the build script and map it to a custom task's input/output properties.
   The build script author interacts with the extension's DSL, while the plugin implementation handles the underlying logic:
   
   ====
   include::sample[dir="snippets/plugins/mappingExtensions/kotlin",files="app/build.gradle.kts[tags=snippet]"]
   include::sample[dir="snippets/plugins/mappingExtensions/groovy",files="app/build.gradle[tags=snippet]"]
   ====
   
   In this example, the `MyExtension` class defines an `inputParameter` property that can be set in the build script.
   The `MyPlugin` class configures this extension and uses its `inputParameter` value to configure the `MyCustomTask` task.
   The `MyCustomTask` task then uses this input parameter in its logic.
   
   You can learn more about types you can use in task implementations and extensions in <<lazy_configuration.adoc#lazy_configuration,Lazy Configuration>>.
   
   == Adding default configuration with conventions
   
   Plugins should provide sensible defaults and standards in a specific context, reducing the number of decisions users need to make.
   Using the `project` object, you can define default values.
   These are known as *conventions*.
   
   Conventions are properties that are initialized with default values and can be overridden by the user in their build script.
   For example:
   
   ====
   include::sample[dir="snippets/customPlugins/customPluginWithConvention/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/customPlugins/customPluginWithConvention/groovy",files="build.gradle[]"]
   ====
   
   ----
   $ gradle -q hello
   include::{snippetsPath}/customPlugins/customPluginWithConvention/tests/customPluginWithConvention.out[]
   ----
   
   In this example, `GreetingPluginExtension` is a class that represents the convention.
   The message property is the convention property with a default value of 'Hello from GreetingPlugin'.
   
   Users can override this value in their build script:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   GreetingPluginExtension {
       message = "Custom message"
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   GreetingPluginExtension {
       message = 'Custom message'
   }
   ----
   =====
   ====
   
   [source,text]
   ----
   $ gradle -q hello
   Custom message
   ----
   
   == Separating capabilities from conventions
   
   Separating capabilities from conventions in plugins allows users to choose which tasks and conventions to apply.
   
   For example, the Java Base plugin provides un-opinionated (i.e., generic) functionality like `SourceSets`, while the Java plugin adds tasks and conventions familiar to Java developers like `classes`, `jar` or `javadoc`.
   
   When designing your own plugins, consider developing two plugins  one for capabilities and another for conventions  to offer flexibility to users.
   
   In the example below, `MyPlugin` contains conventions, and `MyBasePlugin` defines capabilities.
   Then, `MyPlugin` applies `MyBasePlugin`, this is called _plugin composition_.
   To apply a plugin from another one:
   
   .MyBasePlugin.java
   [source,java]
   ----
   include::{snippetsPath}/developingPlugins/capabilitiesVsConventions/groovy/buildSrc/src/main/java/MyBasePlugin.java[]
   ----
   
   .MyPlugin.java
   [source,java]
   ----
   include::{snippetsPath}/developingPlugins/capabilitiesVsConventions/groovy/buildSrc/src/main/java/MyPlugin.java[]
   ----
   
   == Reacting to plugins
   
   A common pattern in Gradle plugin implementations is configuring the runtime behavior of existing plugins and tasks in a build.
   
   For example, a plugin could assume that it is applied to a Java-based project and automatically reconfigure the standard source directory:
   
   .InhouseStrongOpinionConventionJavaPlugin.java
   [source,java]
   ----
   include::{snippetsPath}/developingPlugins/reactingToPlugins/groovy/buildSrc/src/main/java/InhouseStrongOpinionConventionJavaPlugin.java[tags=snippet]
   ----
   
   The drawback to this approach is that it automatically forces the project to apply the Java plugin, imposing a strong opinion on it (i.e., reducing flexibility and generality).
   In practice, the project applying the plugin might not even deal with Java code.
   
   Instead of automatically applying the Java plugin, the plugin could react to the fact that the consuming project applies the Java plugin.
   Only if that is the case, then a certain configuration is applied:
   
   .InhouseConventionJavaPlugin.java
   [source,java]
   ----
   include::{snippetsPath}/developingPlugins/reactingToPlugins/groovy/buildSrc/src/main/java/InhouseConventionJavaPlugin.java[tags=snippet]
   ----
   
   Reacting to plugins is preferred over applying plugins if there is no good reason to assume that the consuming project has the expected setup.
   
   The same concept applies to task types:
   
   .InhouseConventionWarPlugin.java
   [source,java]
   ----
   include::{snippetsPath}/developingPlugins/reactingToPlugins/groovy/buildSrc/src/main/java/InhouseConventionWarPlugin.java[tags=snippet]
   ----
   
   == Reacting to build features
   
   Plugins can access the status of build features in the build.
   The link:{javadocPath}#[Build Features API] allows checking whether the user requested a particular Gradle feature and if it is active in the current build.
   An example of a build feature is the <<configuration_cache.adoc#config_cache,configuration cache>>.
   
   There are two main use cases:
   
   - Using the status of build features in reports or statistics.
   - Incrementally adopting experimental Gradle features by disabling incompatible plugin functionality.
   
   Below is an example of a plugin that utilizes both of the cases.
   
   .Reacting to build features
   [source,java]
   ----
   include::{snippetsPath}/developingPlugins/reactingToBuildFeatures/groovy/buildSrc/src/main/java/MyPlugin.java[tags=my-plugin]
   ----
   <1> The `BuildFeatures` service can be injected into plugins, tasks, and other managed types.
   <2> Accessing the `requested` status of a feature for reporting.
   <3> Using the `active` status of a feature to disable incompatible functionality.
   
   === Build feature properties
   
   A `BuildFeature` status properties are represented with `Provider<Boolean>` types.
   
   The link:{javadocPath}#[`BuildFeature.getRequested()`] status of a build feature determines if the user requested to enable or disable the feature.
   
   When the `requested` provider value is:
   
   - `true` -- the user opted in for using the feature
   - `false` -- the user opted out from using the feature
   - `undefined` -- the user neither opted in nor opted out from using the feature
   
   The link:{javadocPath}#[`BuildFeature.getActive()`] status of a build feature is always defined.
   It represents the effective state of the feature in the build.
   
   When the `active` provider value is:
   
   - `true` -- the feature _may_ affect the build behavior in a way specific to the feature
   - `false` -- the feature will not affect the build behavior
   
   Note that the `active` status does not depend on the `requested` status.
   Even if the user requests a feature, it may still not be active due to other build options being used in the build.
   Gradle can also activate a feature by default, even if the user did not specify a preference.
   
   == Providing default dependencies
   
   The implementation of a plugin sometimes requires the use of an external dependency.
   
   You might want to automatically download an artifact using Gradle뗩 dependency management mechanism and later use it in the action of a task type declared in the plugin.
   Ideally, the plugin implementation does not need to ask the user for the coordinates of that dependency - it can simply predefine a sensible default version.
   
   Let뗩 look at an example of a plugin that downloads files containing data for further processing.
   The plugin implementation declares a custom configuration that allows for <<declaring_dependencies.adoc#declaring-dependencies,assigning those external dependencies with dependency coordinates>>:
   
   .DataProcessingPlugin.java
   [source,java]
   ----
   include::{snippetsPath}/developingPlugins/defaultDependency/groovy/buildSrc/src/main/java/org/myorg/DataProcessingPlugin.java[tags=snippet]
   ----
   
   .DataProcessing.java
   [source,java]
   ----
   include::{snippetsPath}/developingPlugins/defaultDependency/groovy/buildSrc/src/main/java/org/myorg/DataProcessing.java[tags=snippet]
   ----
   
   This approach is convenient for the end user as there is no need to actively declare a dependency.
   The plugin already provides all the details about this implementation.
   
   But what if the user wants to redefine the default dependency?
   
   No problem.
   The plugin also exposes the custom configuration that can be used to assign a different dependency.
   Effectively, the default dependency is overwritten:
   
   ====
   include::sample[dir="snippets/developingPlugins/defaultDependency/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/developingPlugins/defaultDependency/groovy",files="build.gradle[]"]
   ====
   
   You will find that this pattern works well for tasks that require an external dependency when the task's action is executed.
   You can go further and abstract the version to be used for the external dependency by exposing an extension property (e.g.
   `toolVersion` in link:{groovyDslPath}#[the JaCoCo plugin]).
   
   === Minimizing the use of external libraries
   
   Using external libraries in your Gradle projects can bring great convenience, but be aware that they can introduce complex dependency graphs.
   Gradle's `buildEnvironment` task can help you visualize these dependencies, including those of your plugins.
   Keep in mind that plugins share the same classloader, so conflicts may arise with different versions of the same library.
   
   To demonstrate let뗩 assume the following build script:
   
   ====
   include::sample[dir="snippets/developingPlugins/externalLibraries/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/developingPlugins/externalLibraries/groovy",files="build.gradle[]"]
   ====
   
   The output of the task clearly indicates the classpath of the `classpath` configuration:
   
   ----
   $ gradle buildEnvironment
   include::{snippetsPath}/developingPlugins/externalLibraries/tests/buildEnvironment.out[]
   ----
   
   A Gradle plugin does not run in its own, isolated classloader, so you must consider whether you truly need a library or if a simpler solution suffices.
   
   For logic that is executed as part of task execution, use the <<worker_api.adoc#tasks_parallel_worker, Worker API>> that allows you to isolate libraries.
   
   == Providing multiple variants of a plugin
   
   The most convenient way to configure additional plugin variants is to use <<feature_variants.adoc#feature_variants,feature variants>>, a concept available in all Gradle projects that apply one of the Java plugins:
   
   [source,kotlin]
   ----
   dependencies {
       implementation 'com.google.guava:guava:30.1-jre'        // Regular dependency
       featureVariant 'com.google.guava:guava-gwt:30.1-jre'    // Feature variant dependency
   }
   ----
   
   In the following example, each plugin variant is developed in isolation.
   A separate source set is compiled and packaged in a separate jar for each variant.
   
   The following sample demonstrates how to add a variant that is compatible with Gradle 7.0+ while the "main" variant is compatible with older versions:
   
   ====
   include::sample[dir="snippets/developingPlugins/pluginWithVariants/kotlin",files="build.gradle.kts[tags=add-plugin-variant]"]
   include::sample[dir="snippets/developingPlugins/pluginWithVariants/groovy",files="build.gradle[tags=add-plugin-variant]"]
   ====
   
   NOTE: Only Gradle versions 7 or higher can be explicitly targeted by a variant, as support for this was only added in Gradle 7.
   
   First, we declare a separate _source set_ and a _feature variant_ for our Gradle7 plugin variant.
   Then, we do some specific wiring to turn the feature into a proper Gradle plugin variant:
   
   <1> Assign the <<component_capabilities.adoc#declaring-component-capabilities,implicit capability that corresponds to the components GAV>> to the variant.
   <2> Assign the <<variant_attributes.adoc#sub:gradle_plugins_default_attributes,Gradle API version attribute>> to all <<declaring_dependencies.adoc#sec:resolvable-consumable-configs,consumable configurations>> of our Gradle7 variant. Gradle uses this information to determine which variant to select during plugin resolution.
   <3> Configure the `processGradle7Resources` task to ensure the plugin descriptor file is added to the Gradle7 variant Jar.
   <4> Add a dependency to the `gradleApi()` for our new variant so that the API is visible during compilation time.
   
   Note that there is currently no convenient way to access the API of other Gradle versions as the one you are building the plugin with.
   Ideally, every variant should be able to declare a dependency on the API of the minimal Gradle version it supports.
   This will be improved in the future.
   
   The above snippet assumes that all variants of your plugin have the plugin class at the same location.
   That is, if your plugin class is `org.example.GreetingPlugin`, you need to create a second variant of that class in `src/gradle7/java/org/example`.
   
   === Using version-specific variants of multi-variant plugins
   
   Given a dependency on a multi-variant plugin, Gradle will automatically choose its variant that best matches the current Gradle version when it resolves any of:
   
   * plugins specified in the <<plugins.adoc#sec:plugins_block,`plugins {}` block>>;
   * `buildscript` classpath dependencies;
   * dependencies in the root project of the <<sharing_build_logic_between_subprojects.adoc#sec:using_buildsrc,build source (`buildSrc`)>> that appear on the compile or runtime classpath;
   * dependencies in a project that applies the <<java_gradle_plugin.adoc#java_gradle_plugin,Java Gradle Plugin Development plugin>> or the <<kotlin_dsl.adoc#sec:kotlin-dsl_plugin,Kotlin DSL plugin>>, appearing on the compile or runtime classpath.
   
   The best matching variant is the variant that targets the highest Gradle API version and does not exceed the current build's Gradle version.
   
   In all other cases, a plugin variant that does not specify the supported Gradle API version is preferred if such a variant is present.
   
   In projects that use plugins as dependencies, requesting the variants of plugin dependencies that support a different Gradle version is possible.
   This allows a multi-variant plugin that depends on other plugins to access their APIs, which are exclusively provided in their version-specific variants.
   
   This snippet makes the <<#plugin-with-variants,plugin variant `gradle7` defined above>> consume the matching variants of its dependencies on other multi-variant plugins:
   
   ====
   include::sample[dir="snippets/developingPlugins/pluginWithVariants/kotlin",files="build.gradle.kts[tags=consume-plugin-variant]"]
   include::sample[dir="snippets/developingPlugins/pluginWithVariants/groovy",files="build.gradle[tags=consume-plugin-variant]"]
   ====
   
   == Reporting problems
   
   Plugins can report problems through Gradle's problem-reporting APIs.
   The APIs report rich, structured information about problems happening during the build.
   This information can be used by different user interfaces such as Gradle's console output, Build Scans, or IDEs to communicate problems to the user in the most appropriate way.
   
   The following example shows an issue reported from a plugin:
   
   ====
   include::sample[dir="snippets/developingPlugins/problemReporting/kotlin/buildSrc/src/main/java/org/myorg",files="ProblemReportingPlugin.java[tags=snippet]"]
   ====
   
   <1> The `Problem` service is injected into the plugin.
   <2> A problem reporter, is created for the plugin. While the namespace is up to the plugin author, it is recommended that the plugin ID be used.
   <3> A problem is reported. This problem is recoverable so that the build will continue.
   
   For a full example, see our link:#[end-to-end sample].
   
   === Problem building
   
   When reporting a problem, a wide variety of information can be provided.
   The link:{javaDocPath}#[ProblemSpec] describes all the information that can be provided.
   
   === Reporting problems
   
   When it comes to reporting problems, we support three different modes:
   
   - link:{javadocPath}#[Reporting] a problem is used for reporting problems that are recoverable, and the build should continue.
   - link:{javadocPath}#[Throwing] a problem is used for reporting problems that are not recoverable, and the build should fail.
   - link:{javadocPath}#[Rethrowing] a problem is used to wrap an already thrown exception. Otherwise, the behavior is the same as `Throwing`.
   
   For more details, see the link:{javaDocPath}#[ProblemReporter] documentation.
   
   === Problem aggregation
   
   When reporting problems, Gradle will aggregate similar problems by sending them through the Tooling API based on the problem's category label.
   
   - When a problem is reported, the _first_ occurrence is going to be reported as a link:{javaDocPath}#[ProblemDescriptor], containing the complete information about the problem.
   - Any subsequent occurrences of the same problem will be reported as a link:{javaDocPath}#[ProblemAggregationDescriptor]. This descriptor will arrive at the _end_ of the build and contain the number of occurrences of the problem.
   - If for any bucket (i.e., category and label pairing), the number of collected occurrences is greater than 10.000, then it will be sent immediately instead of at the end of the build.

/docs/userguide/authoring-builds/plugins/testing_gradle_plugins.adoc
====================================================================

.. code-block::

   = Testing Gradle plugins
   
   Testing plays a crucial role in the development process by ensuring reliable and high-quality software.
   This principle applies to build code, including Gradle plugins.
   
   == The sample project
   
   This section revolves around a sample project called the "URL verifier plugin".
   This plugin creates a task named `verifyUrl` that checks whether a given URL can be resolved via HTTP GET.
   The end user can provide the URL via an extension named `verification`.
   
   The following build script assumes that the plugin JAR file has been published to a binary repository.
   The script demonstrates how to apply the plugin to the project and configure its exposed extension:
   
   ====
   include::sample[dir="snippets/developingPlugins/testingPlugins/kotlin/include-plugin-build",files="build.gradle.kts[]"]
   include::sample[dir="snippets/developingPlugins/testingPlugins/groovy/include-plugin-build",files="build.gradle[]"]
   ====
   <1> Applies the plugin to the project
   <2> Configures the URL to be verified through the exposed extension
   
   Executing the `verifyUrl` task renders a success message if the HTTP GET call to the configured URL returns with a 200 response code:
   
   [source,shell]
   ----
   $ gradle verifyUrl
   
   include::{snippetsPath}/developingPlugins/testingPlugins/tests/verifyUrl.out[]
   ----
   
   Before diving into the code, let's first revisit the different types of tests and the tooling that supports implementing them.
   
   == The importance of testing
   
   Testing is a crucial part of the software development life cycle, ensuring that software functions correctly and meets quality standards before release.
   Automated testing allows developers to refactor and improve code with confidence.
   
   === The testing pyramid
   
   Manual Testing :: While manual testing is straightforward, it is error-prone and requires human effort. For Gradle plugins, manual testing involves using the plugin in a build script.
   
   Automated Testing :: Automated testing includes unit, integration, and functional testing.
   
   image::testing-pyramid.png[float=right]
   
   The testing pyramid introduced by Mike Cohen in his book link:https://www.mountaingoatsoftware.com/books/succeeding-with-agile-software-development-using-scrum[Succeeding with Agile: Software Development Using Scrum] describes three types of automated tests:
   
   1. *Unit Testing:* Verifies the smallest units of code, typically methods, in isolation. It uses Stubs or Mocks to isolate code from external dependencies.
   
   2. *Integration Testing:* Validates that multiple units or components work together.
   
   3. *Functional Testing:* Tests the system from the end user's perspective, ensuring correct functionality. End-to-end tests for Gradle plugins simulate a build, apply the plugin, and execute specific tasks to verify functionality.
   
   === Tooling support
   
   Testing Gradle plugins, both manually and automatically, is simplified with the appropriate tools.
   The table below provides a summary of each testing approach.
   You can choose any test framework you're comfortable with.
   
   For detailed explanations and code examples, refer to the specific sections below:
   
   [cols="20%,80%",options="header"]
   |======================
   |Test type                               |Tooling support
   |<<manual-tests,Manual tests>>           |<<composite_builds.adoc#composite_builds,Gradle composite builds>>
   |<<unit-tests,Unit tests>>               |Any JVM-based test framework
   |<<integration-tests,Integration tests>> |Any JVM-based test framework
   |<<functional-tests,Functional tests>>   |Any JVM-based test framework and <<test_kit.adoc#test_kit,Gradle TestKit>>
   |======================
   
   == Setting up manual tests
   
   The <<composite_builds.adoc#composite_builds,composite builds>> feature of Gradle makes it easy to test a plugin manually.
   The standalone plugin project and the consuming project can be combined into a single unit, making it straightforward to try out or debug changes without re-publishing the binary file:
   
   ----
   .
   較럭較 include-plugin-build   // <1>
   較   較럭較 build.gradle
   較   較덕較 settings.gradle
   較덕較 url-verifier-plugin    // <2>
       較럭較 build.gradle
       較럭較 settings.gradle
       較덕較 src
   ----
   <1> Consuming project that includes the plugin project
   <2> The plugin project
   
   There are two ways to include a plugin project in a consuming project:
   
   1. By using the command line option `--include-build`.
   
   2. By using the method `includeBuild` in `settings.gradle`.
   
   The following code snippet demonstrates the use of the settings file:
   
   ====
   include::sample[dir="snippets/developingPlugins/testingPlugins/kotlin/include-plugin-build",files="settings.gradle.kts[tags=include-build]"]
   include::sample[dir="snippets/developingPlugins/testingPlugins/groovy/include-plugin-build",files="settings.gradle[tags=include-build]"]
   ====
   
   The command line output of the `verifyUrl` task from the project `include-plugin-build` <<verify-url-cmd-output,looks exactly the same as shown in the introduction>>, except that it now executes as part of a composite build.
   
   Manual testing has its place in the development process, but it is not a replacement for automated testing.
   
   == Setting up automated tests
   
   Setting up a suite of tests early on is crucial to the success of your plugin.
   Automated tests become an invaluable safety net when upgrading the plugin to a new Gradle version or enhancing/refactoring the code.
   
   === Organizing test source code
   
   We recommend implementing a good distribution of unit, integration, and functional tests to cover the most important use cases.
   Separating the source code for each test type automatically results in a project that is more maintainable and manageable.
   
   By default, the Java project creates a convention for organizing unit tests in the directory `src/test/java`.
   Additionally, if you apply the Groovy plugin, source code under the directory `src/test/groovy` is considered for compilation (with the same standard for Kotlin under the directory `src/test/kotlin`).
   Consequently, source code directories for other test types should follow a similar pattern:
   
   ----
   .
   較덕較 src
       較럭較 functionalTest
       較   較덕較 groovy      // <1>
       較럭較 integrationTest
       較   較덕較 groovy      // <2>
       較럭較 main
       較   較럭較 java        // <3>
       較덕較 test
           較덕較 groovy      // <4>
   ----
   <1> Source directory containing functional tests
   <2> Source directory containing integration tests
   <3> Source directory containing production source code
   <4> Source directory containing unit tests
   
   NOTE: The directories `src/integrationTest/groovy` and `src/functionalTest/groovy` are not based on an existing standard convention for Gradle projects.
   You are free to choose any project layout that works best for you.
   
   You can configure the source directories for compilation and test execution.
   
   The link:{userManualPath}#jvm_test_suite_plugin[Test Suite plugin] provides a DSL and API to model multiple groups of automated tests into test suites in JVM-based projects.
   You can also rely on third-party plugins for convenience, such as the link:https://github.com/nebula-plugins/nebula-project-plugin#nebula-facet-plugin[Nebula Facet plugin] or the link:https://github.com/unbroken-dome/gradle-testsets-plugin[TestSets plugin].
   
   === Modeling test types
   
   NOTE: A new configuration DSL for modeling the below `integrationTest` suite is available via the incubating <<jvm_test_suite_plugin.adoc#jvm_test_suite_plugin,JVM Test Suite>> plugin.
   
   In Gradle, source code directories are represented using the concept of <<java_plugin.adoc#source_sets,source sets>>.
   A source set is configured to point to one or more directories containing source code.
   When you define a source set, Gradle automatically sets up compilation tasks for the specified directories.
   
   A pre-configured source set can be created with one line of build script code.
   The source set automatically registers configurations to define dependencies for the sources of the source set:
   
   [source,groovy]
   ----
   // Define a source set named 'test' for test sources
   sourceSets {
       test {
           java {
               srcDirs = ['src/test/java']
           }
       }
   }
   // Specify a test implementation dependency on JUnit
   dependencies {
       testImplementation 'junit:junit:4.12'
   }
   ----
   
   We use that to define an `integrationTestImplementation` dependency to the project itself, which represents the "main" variant of our project (i.e., the compiled plugin code):
   
   ====
   include::sample[dir="snippets/developingPlugins/testingPlugins/kotlin/url-verifier-plugin",files="build.gradle.kts[tags=test-source-set]"]
   include::sample[dir="snippets/developingPlugins/testingPlugins/groovy/url-verifier-plugin",files="build.gradle[tags=test-source-set]"]
   ====
   
   Source sets are responsible for compiling source code, but they do not deal with executing the bytecode.
   For test execution, a corresponding task of type link:{javadocPath}#[Test] needs to be established.
   The following setup shows the execution of integration tests, referencing the classes and runtime classpath of the integration test source set:
   
   ====
   include::sample[dir="snippets/developingPlugins/testingPlugins/kotlin/url-verifier-plugin",files="build.gradle.kts[tags=test-task]"]
   include::sample[dir="snippets/developingPlugins/testingPlugins/groovy/url-verifier-plugin",files="build.gradle[tags=test-task]"]
   ====
   
   === Configuring a test framework
   
   Gradle does not dictate the use of a specific test framework. Popular choices include link:https://junit.org/[JUnit], link:https://testng.org/[TestNG] and link:http://spockframework.org/[Spock].
   Once you choose an option, you have to add its dependency to the compile classpath for your tests.
   
   The following code snippet shows how to use Spock for implementing tests:
   
   ====
   include::sample[dir="snippets/developingPlugins/testingPlugins/kotlin/url-verifier-plugin",files="build.gradle.kts[tags=test-framework]"]
   include::sample[dir="snippets/developingPlugins/testingPlugins/groovy/url-verifier-plugin",files="build.gradle[tags=test-framework]"]
   ====
   
   NOTE: Spock is a Groovy-based BDD test framework that even includes APIs for creating Stubs and Mocks.
   The Gradle team prefers Spock over other options for its expressiveness and conciseness.
   
   == Implementing automated tests
   
   This section discusses representative implementation examples for unit, integration, and functional tests.
   All test classes are based on the use of Spock, though it should be relatively easy to adapt the code to a different test framework.
   
   === Implementing unit tests
   
   The URL verifier plugin emits HTTP GET calls to check if a URL can be resolved successfully.
   The method `DefaultHttpCaller.get(String)` is responsible for calling a given URL and returns an instance of type `HttpResponse`. `HttpResponse` is a POJO containing information about the HTTP response code and message:
   
   .HttpResponse.java
   [source,java]
   ----
   include::{snippetsPath}/developingPlugins/testingPlugins/groovy/url-verifier-plugin/src/main/java/org/myorg/http/HttpResponse.java[]
   ----
   
   The class `HttpResponse` represents a good candidate for a unit test.
   It does not reach out to any other classes nor does it use the Gradle API.
   
   .HttpResponseTest.groovy
   [source,groovy]
   ----
   include::{snippetsPath}/developingPlugins/testingPlugins/groovy/url-verifier-plugin/src/test/groovy/org/myorg/http/HttpResponseTest.groovy[]
   ----
   
   IMPORTANT: When writing unit tests, it's important to test boundary conditions and various forms of invalid input.
   Try to extract as much logic as possible from classes that use the Gradle API to make it testable as unit tests.
   It will result in maintainable code and faster test execution.
   
   You can use the link:{javadocPath}#[ProjectBuilder] class to create link:{groovyDslPath}#[Project] instances to use when you test your plugin implementation.
   
   [source.multi-language-sample,java]
   .src/test/java/org/example/GreetingPluginTest.java
   ----
   include::{snippetsPath}/plugins/customPlugin/groovy/java-gradle-plugin/src/test/java/org/example/GreetingPluginTest.java[tag=test-plugin]
   ----
   
   === Implementing integration tests
   
   Let's look at a class that reaches out to another system, the piece of code that emits the HTTP calls.
   At the time of executing a test for the class `DefaultHttpCaller`, the runtime environment needs to be able to reach out to the internet:
   
   .DefaultHttpCaller.java
   [source,java]
   ----
   include::{snippetsPath}/developingPlugins/testingPlugins/groovy/url-verifier-plugin/src/main/java/org/myorg/http/DefaultHttpCaller.java[]
   ----
   
   Implementing an integration test for `DefaultHttpCaller` doesn't look much different from the unit test shown in the previous section:
   
   .DefaultHttpCallerIntegrationTest.groovy
   [source,groovy]
   ----
   include::{snippetsPath}/developingPlugins/testingPlugins/groovy/url-verifier-plugin/src/integrationTest/groovy/org/myorg/http/DefaultHttpCallerIntegrationTest.groovy[]
   ----
   
   === Implementing functional tests
   
   Functional tests verify the correctness of the plugin end-to-end.
   In practice, this means applying, configuring, and executing the functionality of the plugin implementation.
   The `UrlVerifierPlugin` class exposes an extension and a task instance that uses the URL value configured by the end user:
   
   .UrlVerifierPlugin.java
   [source,java]
   ----
   include::{snippetsPath}/developingPlugins/testingPlugins/groovy/url-verifier-plugin/src/main/java/org/myorg/UrlVerifierPlugin.java[]
   ----
   
   Every Gradle plugin project should apply the <<java_gradle_plugin.adoc#java_gradle_plugin,plugin development plugin>> to reduce boilerplate code.
   By applying the plugin development plugin, the test source set is preconfigured for the use with TestKit.
   If we want to use a custom source set for functional tests and leave the default test source set for only unit tests, we can configure the plugin development plugin to look for TestKit tests elsewhere.
   
   ====
   include::sample[dir="snippets/developingPlugins/testingPlugins/kotlin/url-verifier-plugin",files="build.gradle.kts[tags=source-set-config]"]
   include::sample[dir="snippets/developingPlugins/testingPlugins/groovy/url-verifier-plugin",files="build.gradle[tags=source-set-config]"]
   ====
   
   Functional tests for Gradle plugins use an instance of `GradleRunner` to execute the build under test.
   `GradleRunner` is an API provided by TestKit, which internally uses the Tooling API to execute the build.
   
   The following example applies the plugin to the build script under test, configures the extension and executes the build with the task `verifyUrl`.
   Please see the <<test_kit.adoc#test_kit,TestKit documentation>> to get more familiar with the functionality of TestKit.
   
   .UrlVerifierPluginFunctionalTest.groovy
   [source,groovy]
   ----
   include::{snippetsPath}/developingPlugins/testingPlugins/groovy/url-verifier-plugin/src/functionalTest/groovy/org/myorg/UrlVerifierPluginFunctionalTest.groovy[]
   ----
   
   ==== IDE integration
   
   TestKit determines the plugin classpath by running a specific Gradle task.
   You will need to execute the `assemble` task to initially generate the plugin classpath or to reflect changes to it even when running TestKit-based functional tests from the IDE.
   
   Some IDEs provide a convenience option to delegate the "test classpath generation and execution" to the build.
   In IntelliJ, you can find this option under Preferences... > Build, Execution, Deployment > Build Tools > Gradle > Runner > Delegate IDE build/run actions to Gradle.
   
   image::intellij-delegate-to-build.png[]

/docs/userguide/authoring-builds/plugins/publishing_gradle_plugins.adoc
=======================================================================

.. code-block::

   = Publishing Plugins to the Gradle Plugin Portal
   :portal: Gradle Plugin Portal
   :plugin: Greeting Plugin
   :publishplugin: Plugin Publishing Plugin
   :plugin-reference-documentation: https://plugins.gradle.org/docs/publish-plugin[reference documentation of the {publishplugin}]
   
   Publishing a plugin is the primary way to make it available for others to use.
   While you can publish to a private repository to restrict access, publishing to the https://plugins.gradle.org[{portal}] makes your plugin available to anyone in the world.
   
   image::plugin-portal-page.png[]
   
   This guide shows you how to use the link:https://plugins.gradle.org/plugin/com.gradle.plugin-publish[`com.gradle.plugin-publish`] plugin to publish plugins to the https://plugins.gradle.org[{portal}] using a convenient DSL.
   This approach streamlines configuration steps and provides validation checks to ensure your plugin meets the {portal}'s criteria.
   
   == Prerequisites
   
   You'll need an existing Gradle plugin project for this tutorial. If you don't have one, use the link:#[Greeting plugin sample].
   
   Attempting to publish this plugin will safely fail with a permission error, so don't worry about cluttering up the {portal} with a trivial example plugin.
   
   == Account setup
   
   Before publishing your plugin, you must create an account on the {portal}.
   Follow the instructions on the https://plugins.gradle.org/user/register[registration page] to create an account and obtain an API key from your profile page's "API Keys" tab.
   
   image::plugin-portal-registration-page.png[]
   
   Store your API key in your Gradle configuration (gradle.publish.key and gradle.publish.secret) or use a plugin like Seauc Credentials plugin or Gradle Credentials plugin for secure management.
   
   image::plugin-portal-api-keys.png[]
   
   It is common practice to copy and paste the text into your <<build_environment.adoc#sec:gradle_configuration_properties,$HOME/.gradle/gradle.properties>> file, but you can also place it in any other valid location.
   All the plugin requires is that the `gradle.publish.key` and `gradle.publish.secret` are available as project properties when the appropriate Plugin Portal tasks are executed.
   
   If you are concerned about placing your credentials in `gradle.properties`, check out the https://plugins.gradle.org/plugin/de.qaware.seu.as.code.credentials[Seauc Credentials plugin] or the https://plugins.gradle.org/plugin/nu.studer.credentials[Gradle Credentials plugin].
   
   == Adding the {publishplugin}
   
   To publish your plugin, add the `com.gradle.plugin-publish` plugin to your project's `build.gradle` or `build.gradle.kts` file:
   
   ====
   include::sample[dir="snippets/developingPlugins/publishingPlugins/kotlin",files="build.gradle.kts[tags=plugins_block]"]
   include::sample[dir="snippets/developingPlugins/publishingPlugins/groovy",files="build.gradle[tags=plugins_block]"]
   ====
   
   The latest version of the {publishplugin} can be found on the https://plugins.gradle.org/plugin/com.gradle.plugin-publish[{portal}].
   
   NOTE: Since version 1.0.0 the Plugin Publish Plugin automatically applies the
   <<java_gradle_plugin.adoc#java_gradle_plugin,Java Gradle Plugin Development Plugin>> (assists with developing Gradle plugins) and the
   <<publishing_maven.adoc#publishing_maven, Maven Publish Plugin>> (generates plugin publication metadata).
   If using older versions of the Plugin Publish Plugin, these helper plugins must be applied explicitly.
   
   == Configuring the {publishplugin}
   
   Configure the `com.gradle.plugin-publish` plugin in your `build.gradle` or `build.gradle.kts` file.
   
   ====
   include::sample[dir="snippets/developingPlugins/publishingPlugins/kotlin",files="build.gradle.kts[tags=global_config]"]
   include::sample[dir="snippets/developingPlugins/publishingPlugins/groovy",files="build.gradle[tags=global_config]"]
   ====
   <1> Make sure your project has a `group` set which is used to identify the artifacts (jar and metadata) you publish for your plugins
   in the repository of the {portal} and which is descriptive of the plugin author or the organization the plugins belong too.
   <2> Set the version of your project, which will also be used as the version of your plugins.
   <3> Use the `gradlePlugin` block provided by the <<java_gradle_plugin.adoc#java_gradle_plugin,Java Gradle Plugin Development Plugin>>
   to configure further options for your plugin publication.
   <4> Set the website for your plugin's project.
   <5> Provide the source repository URI so that others can find it, if they want to contribute.
   <6> Set specific properties for each plugin you want to publish; see next section.
   
   Define common properties for all plugins, such as group, version, website, and source repository, using the `gradlePlugin{}` block:
   
   ====
   include::sample[dir="snippets/developingPlugins/publishingPlugins/kotlin",files="build.gradle.kts[tags=per_plugin_config]"]
   include::sample[dir="snippets/developingPlugins/publishingPlugins/groovy",files="build.gradle[tags=per_plugin_config]"]
   ====
   <1> Plugin specific configuration also goes into the `gradlePlugin` block.
   <2> This is where we previously added global properties.
   <3> Each plugin you publish will have its own block inside `plugins`.
   <4> The name of a plugin block must be unique for each plugin you publish; this is a property used only locally by your build and will not be part of the publication.
   <5> Set the unique `id` of the plugin, as it will be identified in the publication.
   <6> Set the plugin name in human-readable form.
   <7> Set a description to be displayed on the portal. It provides useful information to people who want to use your plugin.
   <8> Specifies the categories your plugin covers. It makes the plugin more likely to be discovered by people needing its functionality.
   
   For example, consider the configuration for the https://plugins.gradle.org/plugin/org.ysb33r.gradletest[GradleTest plugin], already published to the {portal}.
   
   ====
   include::sample[dir="snippets/developingPlugins/publishingPlugins/kotlin",files="build.gradle.kts[tags=plugin_example]"]
   include::sample[dir="snippets/developingPlugins/publishingPlugins/groovy",files="build.gradle[tags=plugin_example]"]
   ====
   
   If you browse the associated page on the {portal} for the https://plugins.gradle.org/plugin/org.ysb33r.gradletest[GradleTest plugin], you will see how the specified metadata is displayed.
   
   image::plugin-portal-plugin-page.png[]
   
   === Sources & Javadoc ===
   
   The Plugin Publish Plugin automatically generates and publishes the <<building_java_projects.adoc#sec:java_packaging,Javadoc, and sources JARs>> for your plugin publication.
   
   === Sign artifacts ===
   
   Starting from version 1.0.0 of Plugin Publish Plugin, the signing of published plugin artifacts has been made automatic.
   To enable it, all that's needed is to apply the <<signing_plugin.adoc#signing_plugin,`signing`>> plugin in your build.
   
   === Shadow dependencies ===
   
   Starting from version 1.0.0 of Plugin Publish Plugin, shadowing your plugin's dependencies (ie, publishing it as a fat jar) has been made automatic.
   To enable it, all that's needed is to apply the https://github.com/johnrengelman/shadow[`com.github.johnrengelman.shadow`] plugin in your build.
   
   == Publishing the plugin
   
   If you publish your plugin internally for use within your organization, you can publish it like any other code artifact.
   See the <<publishing_ivy.adoc#publishing_ivy,Ivy>> and <<publishing_maven.adoc#publishing_maven,Maven>> chapters on publishing artifacts.
   
   If you are interested in publishing your plugin to be used by the wider Gradle community, you can publish it to http://plugins.gradle.org[Gradle Plugin Portal].
   This site provides the ability to search for and gather information about plugins contributed by the Gradle community.
   Please refer to the corresponding <<publishing_gradle_plugins.adoc#publishing_portal,section>> on making your plugin available on this site.
   
   === Publish locally
   
   To check how the artifacts of your published plugin look or to use it only locally or internally in your company, you can publish it to any Maven repository, including a local folder.
   You only need to <<publishing_maven.adoc#publishing_maven:repositories,configure repositories for publishing>>.
   Then, you can run the `publish` task to publish your plugin to all repositories you have defined (but not the {portal}).
   
   ====
   include::sample[dir="snippets/developingPlugins/publishingPlugins/kotlin",files="build.gradle.kts[tags=local_repository]"]
   include::sample[dir="snippets/developingPlugins/publishingPlugins/groovy",files="build.gradle[tags=local_repository]"]
   ====
   
   To use the repository in another build, add it to <<plugins.adoc#sec:custom_plugin_repositories,the repositories of the `pluginManagement {}` block>> in your `settings.gradle(.kts)` file.
   
   === Publish to the Plugin Portal
   
   Publish the plugin by using the `publishPlugin` task:
   
   [listing]
   ----
   $ ./gradlew publishPlugins
   ----
   
   You can validate your plugins before publishing using the `--validate-only` flag:
   
   [listing]
   ----
   $ ./gradlew publishPlugins --validate-only
   ----
   
   If you have not configured your `gradle.properties` for the {portal}, you can specify them on the command-line:
   
   [listing]
   ----
   $ ./gradlew publishPlugins -Pgradle.publish.key=<key> -Pgradle.publish.secret=<secret>
   ----
   
   NOTE: You will encounter a permission failure if you attempt to publish the example Greeting Plugin with the ID used in this section.
   That's expected and ensures the portal won't be overrun with multiple experimental and duplicate greeting-type plugins.
   
   After approval, your plugin will be available on the Gradle Plugin Portal for others to discover and use.
   
   == Consume the published plugin
   
   Once you successfully publish a plugin, it won't immediately appear on the Portal.
   It also needs to pass an approval process, which is manual and relatively slow for the initial version of your plugin, but is fully automatic for subsequent versions.
   For further details, see https://plugins.gradle.org/docs/publish-plugin-new#approval[here].
   
   Once your plugin is approved, you can find instructions for its use at a URL of the form *+https://plugins.gradle.org/plugin/<your-plugin-id>+*.
   For example, the Greeting Plugin example is already on the portal at https://plugins.gradle.org/plugin/org.example.greeting.
   
   == Plugins published without {portal}
   
   If your plugin was published without using the <<java_gradle_plugin.adoc#java_gradle_plugin,Java Gradle Plugin Development Plugin>>, the publication will be lacking <<plugins.adoc#sec:plugin_markers,Plugin Marker Artifact>>, which is needed for <<plugins.adoc#sec:plugins_block,plugins DSL>> to locate the plugin.
   In this case, the recommended way to resolve the plugin in another project is to add a `resolutionStrategy` section to the `pluginManagement {}` block of the project's settings file, as shown below.
   
   ====
   include::sample[dir="snippets/plugins/customPlugin/kotlin/consumer",files="settings.gradle.kts[tags=use-legacy-plugin]"]
   include::sample[dir="snippets/plugins/customPlugin/groovy/consumer",files="settings.gradle[tags=use-legacy-plugin]"]
   ====

/Section: 游릭 Best Practices
=============================


/docs/userguide/authoring-builds/best-practices/organizing_gradle_projects.adoc
===============================================================================

.. code-block::

   = Organizing Gradle Projects
   
   Source code and build logic of every software project should be organized in a meaningful way.
   This page lays out the best practices that lead to readable, maintainable projects.
   The following sections also touch on common problems and how to avoid them.
   
   == Separate language-specific source files
   
   Gradle's language plugins establish conventions for discovering and compiling source code.
   For example, a project applying the <<java_plugin.adoc#java_plugin,Java plugin>> will automatically compile the code in the directory `src/main/java`.
   Other language plugins follow the same pattern.
   The last portion of the directory path usually indicates the expected language of the source files.
   
   Some compilers are capable of cross-compiling multiple languages in the same source directory.
   The Groovy compiler can handle the scenario of mixing Java and Groovy source files located in `src/main/groovy`.
   Gradle recommends that you place sources in directories according to their language, because builds are more performant and both the user and build can make stronger assumptions.
   
   The following source tree contains Java and Kotlin source files. Java source files live in `src/main/java`, whereas Kotlin source files live in `src/main/kotlin`.
   
   ====
   [.multi-language-sample]
   =====
   [source,kotlin]
   ----
   .
   較럭較 build.gradle.kts
   較덕較 src
       較덕較 main
           較럭較 java
           較먝 較덕較 HelloWorld.java
           較덕較 kotlin
               較덕較 Utils.kt
   ----
   =====
   [.multi-language-sample]
   =====
   [source,groovy]
   ----
   .
   較럭較 build.gradle
   較덕較 src
       較덕較 main
           較럭較 java
           較먝 較덕較 HelloWorld.java
           較덕較 kotlin
               較덕較 Utils.kt
   ----
   =====
   ====
   
   == Separate source files per test type
   
   It's very common that a project defines and executes different types of tests e.g. unit tests, integration tests, functional tests or smoke tests.
   Optimally, the test source code for each test type should be stored in dedicated source directories.
   Separated test source code has a positive impact on maintainability and separation of concerns as you can run test types independent from each other.
   
   Have a look at the link:#[sample]
   that demonstrates how a separate integration tests configuration can be added to a Java-based project.
   
   == Use standard conventions as much as possible
   
   All Gradle core plugins follow the software engineering paradigm link:https://en.wikipedia.org/wiki/Convention_over_configuration[convention over configuration].
   The plugin logic provides users with sensible defaults and standards, the conventions, in a certain context.
   Let뗩 take the <<java_plugin.adoc#java_plugin,Java plugin>> as an example.
   
   * It defines the directory `src/main/java` as the default source directory for compilation.
   * The output directory for compiled source code and other artifacts (like the JAR file) is `build`.
   
   By sticking to the default conventions, new developers to the project immediately know how to find their way around.
   While those conventions can be reconfigured, it makes it harder to build script users and authors to manage the build logic and its outcome.
   Try to stick to the default conventions as much as possible except if you need to adapt to the layout of a legacy project.
   Refer to the reference page of the relevant plugin to learn about its default conventions.
   
   == Always define a settings file
   
   Gradle tries to locate a `settings.gradle` (Groovy DSL) or a `settings.gradle.kts` (Kotlin DSL) file with every invocation of the build.
   For that purpose, the runtime walks the hierarchy of the directory tree up to the root directory.
   The algorithm stops searching as soon as it finds the settings file.
   
   Always add a `settings.gradle` to the root directory of your build to avoid the initial performance impact.
   The file can either be empty or define the desired name of the project.
   
   A multi-project build must have a `settings.gradle(.kts)` file in the root project of the multi-project hierarchy.
   It is required because the settings file defines which projects are taking part in a <<multi_project_builds.adoc#multi_project_builds,multi-project build>>.
   Besides defining included projects, you might need it to <<organizing_gradle_projects.adoc#organizing_gradle_projects,add libraries to your build script classpath>>.
   
   The following example shows a standard Gradle project layout:
   
   ====
   [.multi-language-sample]
   =====
   [source,kotlin]
   ----
   .
   較럭較 settings.gradle.kts
   較럭較 subproject-one
   較   較덕較 build.gradle.kts
   較덕較 subproject-two
       較덕較 build.gradle.kts
   ----
   =====
   [.multi-language-sample]
   =====
   [source,groovy]
   ----
   .
   較럭較 settings.gradle
   較럭較 subproject-one
   較   較덕較 build.gradle
   較덕較 subproject-two
       較덕較 build.gradle
   ----
   =====
   ====
   
   == Use `buildSrc` to abstract imperative logic
   
   Complex build logic is usually a good candidate for being encapsulated either as custom task or binary plugin.
   Custom task and plugin implementations should not live in the build script.
   It is very convenient to use `buildSrc` for that purpose as long as the code does not need to be shared among multiple, independent projects.
   
   The directory `buildSrc` is treated as an <<composite_builds.adoc#composite_build_intro,included build>>. Upon discovery of the directory, Gradle automatically compiles and tests this code and puts it in the classpath of your build script.
   For multi-project builds there can be only one `buildSrc` directory, which has to sit in the root project directory.
   `buildSrc` should be preferred over <<plugins.adoc#sec:script_plugins,script plugins>> as it is easier to maintain, refactor and test the code.
   
   `buildSrc` uses the same <<java_plugin.adoc#javalayout,source code conventions>> applicable to Java and Groovy projects.
   It also provides direct access to the Gradle API. Additional dependencies can be declared in a dedicated `build.gradle` under `buildSrc`.
   
   .Custom buildSrc build script
   ====
   include::sample[dir="snippets/java/multiproject/kotlin",files="buildSrc/build.gradle.kts[]"]
   include::sample[dir="snippets/java/multiproject/groovy",files="buildSrc/build.gradle[]"]
   ====
   
   A typical project including `buildSrc` has the following layout.
   Any code under `buildSrc` should use a package similar to application code.
   Optionally, the `buildSrc` directory can host a build script if additional configuration is needed (e.g. to apply plugins or to declare dependencies).
   
   ====
   [.multi-language-sample]
   =====
   [source,kotlin]
   ----
   .
   較럭較 buildSrc
   較먝 較럭較 build.gradle.kts
   較먝 較덕較 src
   較먝     較럭較 main
   較먝     較먝 較덕較 java
   較먝     較먝     較덕較 com
   較먝     較먝         較덕較 enterprise
   較먝     較먝             較럭較 Deploy.java
   較먝     較먝             較덕較 DeploymentPlugin.java
   較먝     較덕較 test
   較먝         較덕較 java
   較먝             較덕較 com
   較먝                 較덕較 enterprise
   較먝                     較덕較 DeploymentPluginTest.java
   較럭較 settings.gradle.kts
   較럭較 subproject-one
   較   較덕較 build.gradle.kts
   較덕較 subproject-two
       較덕較 build.gradle.kts
   ----
   =====
   [.multi-language-sample]
   =====
   [source,groovy]
   ----
   .
   較럭較 buildSrc
   較먝 較럭較 build.gradle
   較먝 較덕較 src
   較먝     較럭較 main
   較먝     較먝 較덕較 java
   較먝     較먝     較덕較 com
   較먝     較먝         較덕較 enterprise
   較먝     較먝             較럭較 Deploy.java
   較먝     較먝             較덕較 DeploymentPlugin.java
   較먝     較덕較 test
   較먝         較덕較 java
   較먝             較덕較 com
   較먝                 較덕較 enterprise
   較먝                     較덕較 DeploymentPluginTest.java
   較럭較 settings.gradle
   較럭較 subproject-one
   較   較덕較 build.gradle
   較덕較 subproject-two
       較덕較 build.gradle
   ----
   =====
   ====
   
   [NOTE]
   ====
   A change in `buildSrc` causes the whole project to become out-of-date.
   
   Thus, when making small incremental changes, the <<command_line_interface#sec:command_line_execution_options, `--no-rebuild` command-line option>> is often helpful to get faster feedback.
   Remember to run a full build regularly.
   ====
   
   == Declare properties in `gradle.properties` file
   
   In Gradle, properties can be defined in the build script, in a `gradle.properties` file or as parameters on the command line.
   
   It's common to declare properties on the command line for ad-hoc scenarios.
   For example you may want to pass in a specific property value to control runtime behavior just for this one invocation of the build.
   Properties in a build script can easily become a maintenance headache and convolute the build script logic.
   The `gradle.properties` helps with keeping properties separate from the build script and should be explored as viable option.
   It's a good location for placing <<build_environment.adoc#sec:gradle_configuration_properties,properties that control the build environment>>.
   
   A typical project setup places the `gradle.properties` file in the root directory of the build.
   Alternatively, the file can also live in the `<<directory_layout.adoc#dir:gradle_user_home,GRADLE_USER_HOME>>` directory if you want it to apply to all builds on your machine.
   
   ====
   [.multi-language-sample]
   =====
   [source,kotlin]
   ----
   .
   較럭較 gradle.properties
   較덕較 settings.gradle.kts
   較럭較 subproject-a
   較   較덕較 build.gradle.kts
   較덕較 subproject-b
       較덕較 build.gradle.kts
   ----
   =====
   [.multi-language-sample]
   =====
   [source,groovy]
   ----
   .
   較럭較 gradle.properties
   較덕較 settings.gradle
   較럭較 subproject-a
   較   較덕較 build.gradle
   較덕較 subproject-b
       較덕較 build.gradle
   ----
   =====
   ====
   
   == Avoid overlapping task outputs
   
   Tasks should define inputs and outputs to get the performance benefits of <<incremental_build.adoc#incremental_build,incremental build functionality>>.
   When declaring the outputs of a task, make sure that the directory for writing outputs is unique among all the tasks in your project.
   
   Intermingling or overwriting output files produced by different tasks compromises up-to-date checking causing slower builds.
   In turn, these filesystem changes may prevent Gradle's <<build_cache.adoc#build_cache,build cache>> from properly identifying and caching what would otherwise be cacheable tasks.
   
   == Standardizing builds with a custom Gradle distribution
   
   Often enterprises want to standardize the build platform for all projects in the organization by defining common conventions or rules.
   You can achieve that with the help of initialization scripts.
   <<init_scripts.adoc#init_scripts,Initialization scripts>> make it extremely easy to apply build logic across all projects on a single machine.
   For example, to declare a in-house repository and its credentials.
   
   There are some drawbacks to the approach.
   First of all, you will have to communicate the setup process across all developers in the company.
   Furthermore, updating the initialization script logic uniformly can prove challenging.
   
   Custom Gradle distributions are a practical solution to this very problem.
   A custom Gradle distribution is comprised of the standard Gradle distribution plus one or many custom initialization scripts.
   The initialization scripts come bundled with the distribution and are applied every time the build is run.
   Developers only need to point their checked-in <<gradle_wrapper.adoc#gradle_wrapper_reference,Wrapper>> files to the URL of the custom Gradle distribution.
   
   Custom Gradle distributions may also contain a `gradle.properties` file in the root of the distribution, which provide an organization-wide <<build_environment.adoc#sec:gradle_configuration_properties,set of properties that control the build environment>>.
   
   The following steps are typical for creating a custom Gradle distribution:
   
   1. Implement logic for downloading and repackaging a Gradle distribution.
   2. Define one or many initialization scripts with the desired logic.
   3. Bundle the initialization scripts with the Gradle distribution.
   4. Upload the Gradle distribution archive to a HTTP server.
   5. Change the Wrapper files of all projects to point to the URL of the custom Gradle distribution.
   
   .Building a custom Gradle distribution
   ====
   include::sample[dir="snippets/organizingGradleProjects/customGradleDistribution/groovy",files="build.gradle[]"]
   ====

/docs/userguide/authoring-builds/best-practices/authoring_maintainable_build_scripts.adoc
=========================================================================================

.. code-block::

   = Best practices for authoring maintainable builds
   
   Gradle has a rich API with several approaches to creating build logic.
   The associated flexibility can easily lead to unnecessarily complex builds with custom code commonly added directly to build scripts.
   In this chapter, we present several best practices that will help you develop expressive and maintainable builds that are easy to use.
   
   NOTE: The third-party link:https://github.com/nebula-plugins/gradle-lint-plugin[Gradle lint plugin] helps with enforcing a desired code style in build scripts if that's something that would interest you.
   
   == Avoid using imperative logic in scripts
   
   The Gradle runtime does not enforce a specific style for build logic.
   For that very reason, it's easy to end up with a build script that mixes declarative DSL elements with imperative, procedural code.
   Let's talk about some concrete examples.
   
   
   * _Declarative code:_ Built-in, language-agnostic DSL elements (e.g. link:{groovyDslPath}#[Project.dependencies{}] or link:{groovyDslPath}#[Project.repositories{}]) or DSLs exposed by plugins
   * _Imperative code:_ Conditional logic or very complex task action implementations
   
   The end goal of every build script should be to only contain declarative language elements which makes the code easier to understand and maintain.
   Imperative logic should live in binary plugins and which in turn is applied to the build script.
   As a side product, you automatically enable your team to link:#[reuse the plugin logic in other projects] if you publish the artifact to a binary repository.
   
   The following sample build shows a negative example of using conditional logic directly in the build script.
   While this code snippet is small, it is easy to imagine a full-blown build script using numerous procedural statements and the impact it would have on readability and maintainability.
   By moving the code into a class, it can also be tested individually.
   
   .A build script using conditional logic to create a task
   ====
   include::sample[dir="snippets/bestPractices/conditionalLogic-dont/kotlin", files="build.gradle.kts[]"]
   include::sample[dir="snippets/bestPractices/conditionalLogic-dont/groovy", files="build.gradle[]"]
   ====
   
   Let's compare the build script with the same logic implemented as a binary plugin.
   The code might look more involved at first but clearly looks more like typical application code.
   This particular plugin class lives in the <<sharing_build_logic_between_subprojects.adoc#sec:using_buildsrc,`buildSrc` directory>> which makes it available to the build script automatically.
   
   .A binary plugin implementing imperative logic
   ====
   include::sample[dir="snippets/bestPractices/conditionalLogic-do/groovy/buildSrc/src/main/java/com/enterprise", files="ReleasePlugin.java[]"]
   ====
   
   Now that the build logic has been translated into a plugin, you can apply it in the build script.
   The build script has been shrunk from 8 lines of code to a one liner.
   
   .A build script applying a plugin that encapsulates imperative logic
   ====
   include::sample[dir="snippets/bestPractices/conditionalLogic-do/kotlin", files="build.gradle.kts[]"]
   include::sample[dir="snippets/bestPractices/conditionalLogic-do/groovy", files="build.gradle[]"]
   ====
   
   == Avoid using internal Gradle APIs
   
   Use of Gradle internal APIs in plugins and build scripts has the potential to break builds when either Gradle or plugins change.
   
   The following packages are listed in the
   link:https://github.com/gradle/gradle/blob/6961503e70aa634653e71413224831fd3fa3ec2d/build-logic/basics/src/main/kotlin/gradlebuild/basics/PublicApi.kt[Gradle public API definition]
   and the
   link:https://github.com/gradle/gradle/blob/6961503e70aa634653e71413224831fd3fa3ec2d/build-logic/basics/src/main/kotlin/gradlebuild/basics/PublicKotlinDslApi.kt[Kotlin DSL API definition], except any subpackage with `internal` in the name.
   
   // If these list is modified due changes in the public API definitions, update the permalinks too
   .Gradle API packages
   ----
   org.gradle
   org.gradle.api.*
   org.gradle.authentication.*
   org.gradle.build.*
   org.gradle.buildinit.*
   org.gradle.caching.*
   org.gradle.concurrent.*
   org.gradle.deployment.*
   org.gradle.external.javadoc.*
   org.gradle.ide.*
   org.gradle.ivy.*
   org.gradle.jvm.*
   org.gradle.language.*
   org.gradle.maven.*
   org.gradle.nativeplatform.*
   org.gradle.normalization.*
   org.gradle.platform.*
   org.gradle.plugin.devel.*
   org.gradle.plugin.use
   org.gradle.plugin.management
   org.gradle.plugins.*
   org.gradle.process.*
   org.gradle.testfixtures.*
   org.gradle.testing.jacoco.*
   org.gradle.tooling.*
   org.gradle.swiftpm.*
   org.gradle.model.*
   org.gradle.testkit.*
   org.gradle.testing.*
   org.gradle.vcs.*
   org.gradle.work.*
   org.gradle.workers.*
   org.gradle.util.*
   ----
   
   .Kotlin DSL API packages
   ----
   org.gradle.kotlin.dsl
   org.gradle.kotlin.dsl.precompile
   ----
   
   === Alternatives for oft-used internal APIs
   
   To provide a nested DSL for your custom task, don't use `org.gradle.internal.reflect.Instantiator`; use link:{javadocPath}#[ObjectFactory] instead.
   It may also be helpful to read <<lazy_configuration.adoc#lazy_configuration,the chapter on lazy configuration>>.
   
   Don't use `org.gradle.api.internal.ConventionMapping`.
   Use link:{javadocPath}#[Provider] and/or link:{javadocPath}#[Property].
   You can find an example for capturing user input to configure runtime behavior in the <<implementing_gradle_plugins_binary.adoc#capturing_user_input_to_configure_plugin_runtime_behavior,implementing plugins section>>.
   
   Instead of `org.gradle.internal.os.OperatingSystem`, use another method to detect operating system, such as link:https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/SystemUtils.html[Apache commons-lang SystemUtils] or `System.getProperty("os.name")`.
   
   Use other collections or I/O frameworks instead of `org.gradle.util.CollectionUtils`, `org.gradle.util.internal.GFileUtils`, and other classes under `org.gradle.util.*`.
   
   == Follow conventions when declaring tasks
   
   The task API gives a build author a lot of flexibility to declare tasks in a build script.
   For optimal readability and maintainability follow these rules:
   
   * The task type should be the only key-value pair within the parentheses after the task name.
   * Other configuration should be done within the task's configuration block.
   * <<tutorial_using_tasks.adoc#sec:hello_world,Task actions>> added when declaring a task should only be declared with the methods link:{groovyDslPath}#[Task.doFirst{}] or link:{groovyDslPath}#[Task.doLast{}].
   * When declaring an ad-hoc task  one that doesn't have an explicit type 댹맟ou should use link:{groovyDslPath}#[Task.doLast{}] if you're only declaring a single action.
   * A task should <<#sec:improving_task_discoverability,define a group and description>>.
   
   .Definition of tasks following best practices
   ====
   include::sample[dir="snippets/bestPractices/taskDefinition/kotlin", files="build.gradle.kts[]"]
   include::sample[dir="snippets/bestPractices/taskDefinition/groovy", files="build.gradle[]"]
   ====
   
   == Improve task discoverability
   
   Even new users to a build should to be able to find crucial information quickly and effortlessly.
   In Gradle you can declare a link:{groovyDslPath}#[group] and a link:{groovyDslPath}#[description] for any task of the build.
   The <<command_line_interface.adoc#sec:listing_tasks,tasks report>> uses the assigned values to organize and render the task for easy discoverability.
   Assigning a group and description is most helpful for any task that you expect build users to invoke.
   
   The example task `generateDocs` generates documentation for a project in the form of HTML pages.
   The task should be organized underneath the bucket `Documentation`.
   The description should express its intent.
   
   .A task declaring the group and description
   ====
   include::sample[dir="snippets/bestPractices/taskGroupDescription/kotlin", files="build.gradle.kts[]"]
   include::sample[dir="snippets/bestPractices/taskGroupDescription/groovy", files="build.gradle[]"]
   ====
   
   The output of the tasks report reflects the assigned values.
   
   ----
   > gradle tasks
   
   > Task :tasks
   
   Documentation tasks
   -------------------
   generateDocs - Generates the HTML documentation for this project.
   ----
   
   == Minimize logic executed during the configuration phase
   
   It's important for every build script developer to understand the different phases of the <<build_lifecycle.adoc#build_lifecycle,build lifecycle>> and their implications on performance and evaluation order of build logic.
   During the configuration phase the project and its domain objects should be _configured_, whereas the execution phase only executes the actions of the task(s) requested on the command line plus their dependencies.
   Be aware that any code that is not part of a task action will be executed with _every single run_ of the build.
   A link:https://scans.gradle.com/get-started[build scan] can help you with identifying the time spent during each of the lifecycle phases.
   It's an invaluable tool for diagnosing common performance issues.
   
   Let's consider the following incantation of the anti-pattern described above.
   In the build script you can see that the dependencies assigned to the configuration `printArtifactNames` are resolved outside of the task action.
   
   .Executing logic during configuration should be avoided
   ====
   include::sample[dir="snippets/bestPractices/logicDuringConfiguration-dont/kotlin", files="build.gradle.kts[tags=config-logic]"]
   include::sample[dir="snippets/bestPractices/logicDuringConfiguration-dont/groovy", files="build.gradle[tags=config-logic]"]
   ====
   
   The code for resolving the dependencies should be moved into the task action to avoid the performance impact of resolving the dependencies before they are actually needed.
   
   .Executing logic during execution phase is preferred
   ====
   include::sample[dir="snippets/bestPractices/logicDuringConfiguration-do/kotlin", files="build.gradle.kts[tags=config-logic]"]
   include::sample[dir="snippets/bestPractices/logicDuringConfiguration-do/groovy", files="build.gradle[tags=config-logic]"]
   ====
   
   == Avoid using the `GradleBuild` task type
   
   The link:{groovyDslPath}#[GradleBuild] task type allows a build script to define a task that invokes another Gradle build.
   The use of this type is generally discouraged.
   There are some corner cases where the invoked build doesn't expose the same runtime behavior as from the command line or through the Tooling API leading to unexpected results.
   
   Usually, there's a better way to model the requirement.
   The appropriate approach depends on the problem at hand. Here're some options:
   
   * Model the build as <<multi_project_builds.adoc#multi_project_builds,multi-project build>> if the intention is to execute tasks from different modules as unified build.
   * Use <<composite_builds.adoc#composite_builds,composite builds>> for projects that are physically separated but should occasionally be built as a single unit.
   
   == Avoid inter-project configuration
   
   Gradle does not restrict build script authors from reaching into the domain model from one project into another one in a <<multi_project_builds.adoc#multi_project_builds,multi-project build>>.
   Strongly-coupled projects hurts <<performance.adoc#parallel_execution,build execution performance>> as well as readability and maintainability of code.
   
   The following practices should be avoided:
   
   * Explicitly depending on a task from another project via link:{groovyDslPath}#[]++)[Task.dependsOn(java.lang.Object++...++)].
   * Setting property values or calling methods on domain objects from another project.
   * Executing another portion of the build with <<#sec:avoiding_use_of_gradlebuild,GradleBuild>>.
   * Declaring unnecessary <<declaring_dependencies.adoc#sub:project_dependencies,project dependencies>>.
   
   == Externalize and encrypt your passwords
   
   Most builds need to consume one or many passwords.
   The reasons for this need may vary.
   Some builds need a password for publishing artifacts to a secured binary repository, other builds need a password for downloading binary files.
   Passwords should always kept safe to prevent fraud.
   Under no circumstance should you add the password to the build script in plain text or declare it in `gradle.properties` file in the project's directory.
   Those files usually live in a version control repository and can be viewed by anyone that has access to it.
   
   Passwords together with any other sensitive data should be kept external from the version controlled project files.
   Gradle exposes an API for providing credentials in link:{groovyDslPath}#[ProviderFactory]
   as well as <<declaring_repositories.adoc#sec:handling_credentials,Artifact Repositories>>
   that allows to supply credential values using <<build_environment#sec:gradle_configuration_properties,Gradle properties>>
   when they are needed by the build. This way the credentials can be stored in the `gradle.properties` file that
   resides in the user's home directory or be injected to the build using command line arguments or environment variables.
   
   If you store sensitive credentials in user home's `gradle.properties`, consider encrypting them. At the moment Gradle does not provide a built-in mechanism for encrypting, storing and accessing passwords.
   A good solution for solving this problem is the link:https://github.com/etiennestuder/gradle-credentials-plugin[Gradle Credentials plugin].
   
   == Don't anticipate configuration creation
   
   Gradle will create certain configurations, such as `default` or `archives`, using a "check if needed" strategy.
   That means it will only create these configurations if they **do not** already exist.
   
   You should **not** ever create these configurations yourself.
   Names such as these, and the names of configurations associated with source sets, should be considered implicitly "reserved".
   The exact list of reserved names depends on which plugins are applied and how your build is configured.
   
   This situation will be announced with the following deprecation warnings:
   
   ```
   Configuration customCompileClasspath already exists with permitted usage(s):
   	Consumable - this configuration can be selected by another project as a dependency
   	Resolvable - this configuration can be resolved by this project to a set of files
   	Declarable - this configuration can have dependencies added to it
   Yet Gradle expected to create it with the usage(s):
   	Resolvable - this configuration can be resolved by this project to a set of files
   ```
   
   Gradle will then attempt to mutate the allowed usage to match the expected usage and will emit a second warning:
   
   ```
   Gradle will mutate the usage of this configuration to match the expected usage. This may cause unexpected behavior. Creating configurations with reserved names has been deprecated. This is scheduled to be removed in Gradle 9.0. Create source sets prior to creating or accessing the configurations associated with them.
   ```
   
   Some configurations may have their usage locked against mutation.
   In this case your build will fail and this warning will be immediately followed by an exception with the message:
   
   ```
   Gradle cannot mutate the usage of configuration 'customCompileClasspath' because it is locked.
   ```
   
   If you encounter this error you must either:
   
   1. Change the name of your configuration to avoid the conflict.
   2. If changing the name is not possible, ensure the allowed usage (consumable, resolvable, declarable against) for your configuration is aligned with Gradle's expectations.
   
   As a best practice, you should not "anticipate" configuration creation - let Gradle create the configuration first and then adjust it.
   Or, if possible, use non-conflicting names for your custom configurations by renaming them when you see this warning.

/Section: 游릭 Other Topics
===========================


/docs/userguide/authoring-builds/other/directory_layout.adoc
============================================================

.. code-block::

   = Gradle-managed Directories
   
   Gradle uses two main directories to perform and manage its work: the <<#dir:gradle_user_home>> and the <<#dir:project_root>>.
   
   image::author-gradle-2.png[]
   
   == Gradle User Home directory
   
   By default, the Gradle User Home (`~/.gradle` or `C:\Users\<USERNAME>\.gradle`) stores global configuration properties, initialization scripts, caches, and log files.
   
   It can be set with the environment variable `GRADLE_USER_HOME`.
   
   TIP: Not to be confused with the `GRADLE_HOME`, the optional installation directory for Gradle.
   
   It is roughly structured as follows:
   
   [listing]
   ----
   較럭較 caches // <1>
   較   較럭較 4.8 // <2>
   較   較럭較 4.9 // <2>
   較   較럭較 긽
   較   較럭較 jars-3 // <3>
   較   較덕較 modules-2 // <3>
   較럭較 daemon // <4>
   較   較럭較 긽
   較   較럭較 4.8
   較   較덕較 4.9
   較럭較 init.d // <5>
   較   較덕較 my-setup.gradle
   較럭較 jdks // <6>
   較   較럭較 긽
   較   較덕較 jdk-14.0.2+12
   較럭較 wrapper
   較   較덕較 dists // <7>
   較       較럭較 긽
   較       較럭較 gradle-4.8-bin
   較       較럭較 gradle-4.9-all
   較       較덕較 gradle-4.9-bin
   較덕較 gradle.properties // <8>
   ----
   <1> Global cache directory (for everything that is not project-specific).
   <2> Version-specific caches (e.g., to support incremental builds).
   <3> Shared caches (e.g., for artifacts of dependencies).
   <4> Registry and logs of the <<gradle_daemon.adoc#gradle_daemon, Gradle Daemon>>.
   <5> Global <<init_scripts.adoc#init_scripts, initialization scripts>>.
   <6> JDKs downloaded by the <<toolchains.adoc#sec:provisioning, toolchain support>>.
   <7> Distributions downloaded by the <<gradle_wrapper.adoc#gradle_wrapper_reference,Gradle Wrapper>>.
   <8> Global <<build_environment.adoc#sec:gradle_configuration_properties,Gradle configuration properties>>.
   
   === Cleanup of caches and distributions
   Gradle automatically cleans its user home directory.
   
   By default, the cleanup runs in the background when the Gradle daemon is stopped or shut down.
   
   If using `--no-daemon`, it runs in the foreground after the build session.
   
   The following cleanup strategies are applied periodically (by default, once every 24 hours):
   
   - Version-specific caches in all `caches/<GRADLE_VERSION>/` directories are checked for whether they are still in use.
   +
   If not, directories for release versions are deleted after 30 days of inactivity, and snapshot versions after 7 days.
   - Shared caches in `caches/` (e.g., `jars-*`) are checked for whether they are still in use.
   +
   If no Gradle version still uses them, they are deleted.
   - Files in shared caches used by the current Gradle version in `caches/` (e.g., `jars-3` or `modules-2`) are checked for when they were last accessed.
   +
   Depending on whether the file can be recreated locally or downloaded from a remote repository, it will be deleted after 7 or 30 days, respectively.
   - Gradle distributions in `wrapper/dists/` are checked for whether they are still in use, i.e., whether there's a corresponding version-specific cache directory.
   +
   Unused distributions are deleted.
   
   ==== Configuring cleanup of caches and distributions
   The retention periods of the various caches can be configured.
   
   Caches are classified into four categories:
   
   - *Released wrapper distributions:* Distributions and related version-specific caches corresponding to released versions (e.g., `4.6.2` or `8.0`).
   +
   Default retention for unused versions is 30 days.
   - *Snapshot wrapper distributions:* Distributions and related version-specific caches corresponding to snapshot versions (e.g. `7.6-20221130141522+0000`).
   +
   Default retention for unused versions is 7 days.
   - *Downloaded resources:* Shared caches downloaded from a remote repository (e.g., cached dependencies).
   +
   Default retention for unused resources is 30 days.
   - *Created resources:* Shared caches that Gradle creates during a build (e.g., artifact transforms).
   +
   Default retention for unused resources is 7 days.
   
   The retention period for each category can be configured independently via an init script in Gradle User Home:
   
   ====
   include::sample[dir="snippets/initScripts/cacheRetention/kotlin",files="gradleUserHome/init.d/cache-settings.gradle.kts"]
   include::sample[dir="snippets/initScripts/cacheRetention/groovy",files="gradleUserHome/init.d/cache-settings.gradle"]
   ====
   
   The frequency at which cache cleanup is invoked is also configurable.
   
   There are three possible settings:
   
   - *DEFAULT:* Cleanup is performed periodically in the background (currently once every 24 hours).
   - *DISABLED:* Never cleanup Gradle User Home.
   +
   This is useful in cases where Gradle User Home is ephemeral or delaying cleanup is desirable until an explicit point.
   - *ALWAYS:* Cleanup is performed at the end of each build session.
   +
   This is useful in cases where it's desirable to ensure that cleanup has occurred before proceeding.
   +
   However, this performs cache cleanup during the build (rather than in the background), which can be expensive, so this option should only be used when necessary.
   
   To disable cache cleanup:
   
   ====
   include::sample[dir="snippets/initScripts/disableCacheCleanup/kotlin",files="gradleUserHome/init.d/cache-settings.gradle.kts"]
   include::sample[dir="snippets/initScripts/disableCacheCleanup/groovy",files="gradleUserHome/init.d/cache-settings.gradle"]
   ====
   
   NOTE: Cache cleanup settings can only be configured via init scripts and should be placed under the `init.d` directory in Gradle User Home.
   This effectively couples the configuration of cache cleanup to the Gradle User Home those settings apply to and limits the possibility of different conflicting settings from different projects being applied to the same directory.
   
   ==== Multiple versions of Gradle sharing a Gradle User Home
   It is common to share a single Gradle User Home between multiple versions of Gradle.
   
   As stated above, caches in Gradle User Home are version-specific.
   Different versions of Gradle will perform maintenance on only the version-specific caches associated with each version.
   
   On the other hand, some caches are shared between versions (e.g., the dependency artifact cache or the artifact transform cache).
   
   Beginning with Gradle version 8.0, the cache cleanup settings can be configured to custom retention periods.
   However, older versions have fixed retention periods (7 or 30 days, depending on the cache).
   These shared caches could be accessed by versions of Gradle with different settings to retain cache artifacts.
   
   This means that:
   
   - If the retention period is _not_ customized, all versions that perform cleanup will have the same retention periods. There will be no effect due to sharing a Gradle User Home with multiple versions.
   - If the retention period is customized for Gradle versions greater than or equal to version 8.0 to use retention periods _shorter_ than the previously fixed periods, there will also be no effect.
   +
   The versions of Gradle aware of these settings will cleanup artifacts earlier than the previously fixed retention periods, and older versions will effectively not participate in the cleanup of shared caches.
   - If the retention period is customized for Gradle versions greater than or equal to version 8.0 to use retention periods _longer_ than the previously fixed periods, the older versions of Gradle may clean the shared caches earlier than what is configured.
   +
   In this case, if it is desirable to maintain these shared cache entries for newer versions for longer retention periods, they will not be able to share a Gradle User Home with older versions. They will need to use a separate directory.
   
   Another consideration when sharing the Gradle User Home with versions of Gradle before version 8.0 is that the DSL elements to configure the cache retention settings are unavailable in earlier versions, so this must be accounted for in any init script shared between versions.
   This can easily be handled by conditionally applying a version-compliant script.
   
   NOTE: The version-compliant script should reside somewhere other than the `init.d` directory (such as a sub-directory), so it is not automatically applied.
   
   To configure cache cleanup in a version-safe manner:
   
   ====
   include::sample[dir="snippets/initScripts/multiVersionCacheRetention/kotlin",files="gradleUserHome/init.d/cache-settings.gradle.kts"]
   include::sample[dir="snippets/initScripts/multiVersionCacheRetention/groovy",files="gradleUserHome/init.d/cache-settings.gradle"]
   ====
   
   Version-compliant cache configuration script:
   
   ====
   include::sample[dir="snippets/initScripts/multiVersionCacheRetention/kotlin",files="gradleUserHome/init.d/gradle8/cache-settings.gradle.kts"]
   include::sample[dir="snippets/initScripts/multiVersionCacheRetention/groovy",files="gradleUserHome/init.d/gradle8/cache-settings.gradle"]
   ====
   
   === Cache marking
   Beginning with Gradle version 8.1, Gradle supports marking caches with a `CACHEDIR.TAG` file.
   
   It follows the format described in https://bford.info/cachedir/[the Cache Directory Tagging Specification].
   The purpose of this file is to allow tools to identify the directories that do not need to be searched or backed up.
   
   By default, the directories `caches`, `wrapper/dists`, `daemon`, and `jdks` in the Gradle User Home are marked with this file.
   
   ==== Configuring cache marking
   The cache marking feature can be configured via an init script in the Gradle User Home:
   
   ====
   include::sample[dir="snippets/initScripts/cacheMarking/kotlin",files="gradleUserHome/init.d/cache-settings.gradle.kts"]
   include::sample[dir="snippets/initScripts/cacheMarking/groovy",files="gradleUserHome/init.d/cache-settings.gradle"]
   ====
   
   NOTE: Cache marking settings can only be configured via init scripts and should be placed under the `init.d` directory in Gradle User Home. This effectively couples the configuration of cache marking to the Gradle User Home to which those settings apply and limits the possibility of different conflicting settings from different projects being applied to the same directory.
   
   == Project Root directory
   
   The project root directory contains all source files from your project.
   
   It also contains files and directories Gradle generates, such as `.gradle` and `build`.
   
   While the former are usually checked into source control, the latter are transient files Gradle uses to support features like incremental builds.
   
   The anatomy of a typical project root directory looks as follows:
   
   [listing,subs=+macros]
   ----
   較럭較 .gradle                 // <1>
   較   較럭較 4.8                 // <2>
   較   較럭較 4.9                 // <2>
   較   較덕較 긽
   較럭較 build                   // <3>
   較럭較 gradle
   較   較덕較 wrapper             // <4>
   較럭較 gradle.properties       // <5>
   較럭較 gradlew                 // <6>
   較럭較 gradlew.bat             // <6>
   較럭較 settings.gradle.kts     // <7>
   較럭較 subproject-one          // <8>
   |   較덕較 build.gradle.kts    // <9>
   較럭較 subproject-two          // <8>
   |   較덕較 build.gradle.kts    // <9>
   較덕較 긽
   ----
   <1> Project-specific cache directory generated by Gradle.
   <2> Version-specific caches (e.g., to support incremental builds).
   <3> The build directory of this project into which Gradle generates all build artifacts.
   <4> Contains the JAR file and configuration of the <<gradle_wrapper.adoc#gradle_wrapper_reference,Gradle Wrapper>>.
   <5> Project-specific <<build_environment.adoc#sec:gradle_configuration_properties,Gradle configuration properties>>.
   <6> Scripts for executing builds using the <<gradle_wrapper.adoc#gradle_wrapper_reference,Gradle Wrapper>>.
   <7> The project's <<organizing_gradle_projects.adoc#sec:settings_file, settings file>> where the list of subprojects is defined.
   <8> Usually, a project is organized into one or multiple subprojects.
   <9> Each subproject has its own Gradle build script.
   
   === Project cache cleanup
   
   From version 4.10 onwards, Gradle automatically cleans the project-specific cache directory.
   
   After building the project, version-specific cache directories in `.gradle/{gradleVersion}/` are checked periodically (at most, every 24 hours) to determine whether they are still in use.
   They are deleted if they haven't been used for 7 days.
   
   [.text-right]
   **Next Step:** <<build_lifecycle.adoc#build_lifecycle,Learn about the Gradle Build Lifecycle>> >>

/docs/userguide/authoring-builds/other/working_with_files.adoc
==============================================================

.. code-block::

   = Working With Files
   
   Almost every Gradle build interacts with files in some way: think source files, file dependencies, reports and so on. That's why Gradle comes with a comprehensive API that makes it simple to perform the file operations you need.
   
   The API has two parts to it:
   
    * Specifying which files and directories to process
    * Specifying what to do with them
   
   The <<#sec:locating_files,File paths in depth>> section covers the first of these in detail, while subsequent sections, like <<#sec:copying_files,File copying in depth>>, cover the second. To begin with, we'll show you examples of the most common scenarios that users encounter.
   
   == Copying a single file
   
   You copy a file by creating an instance of Gradle's builtin link:{groovyDslPath}#[Copy] task and configuring it with the location of the file and where you want to put it. This example mimics copying a generated report into a directory that will be packed into an archive, such as a ZIP or TAR:
   
   .How to copy a single file
   ====
   include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-single-file-example]"]
   include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-single-file-example]"]
   ====
   
   The link:{groovyDslPath}#[ProjectLayout] class is used to find a file or directory path relative to the current project.
   This is a common way to make build scripts work regardless of the project path.
   The file and directory paths are then used to specify what file to copy using link:{groovyDslPath}#[]++)[Copy.from(java.lang.Object...)] and which directory to copy it to using link:{groovyDslPath}#[Copy.into(java.lang.Object)].
   
   Although hard-coded paths make for simple examples, they also make the build brittle. It's better to use a reliable, single source of truth, such as a task or shared project property. In the following modified example, we use a report task defined elsewhere that has the report's location stored in its `outputFile` property:
   
   .Prefer task/project properties over hard-coded paths
   ====
   include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-single-file-example-with-task-properties]"]
   include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-single-file-example-with-task-properties]"]
   ====
   
   We have also assumed that the reports will be archived by `archiveReportsTask`, which provides us with the directory that will be archived and hence where we want to put the copies of the reports.
   
   == Copying multiple files
   
   You can extend the previous examples to multiple files very easily by providing multiple arguments to `from()`:
   
   .Using multiple arguments with from()
   ====
   include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-multiple-files-example]"]
   include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-multiple-files-example]"]
   ====
   
   Two files are now copied into the archive directory. You can also use multiple `from()` statements to do the same thing, as shown in the first example of the section <<#sec:copying_files, File copying in depth>>.
   
   Now consider another example: what if you want to copy all the PDFs in a directory without having to specify each one? To do this, attach inclusion and/or exclusion patterns to the copy specification. Here we use a string pattern to include PDFs only:
   
   .Using a flat filter
   ====
   include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-multiple-files-with-flat-filter-example]"]
   include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-multiple-files-with-flat-filter-example]"]
   ====
   
   One thing to note, as demonstrated in the following diagram, is that only the PDFs that reside directly in the `reports` directory are copied:
   
   .The effect of a flat filter on copying
   image::copy-with-flat-filter-example.png[]
   
   You can include files in subdirectories by using an Ant-style glob pattern (`\**/*`), as done in this updated example:
   
   .Using a deep filter
   ====
   include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-multiple-files-with-deep-filter-example]"]
   include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-multiple-files-with-deep-filter-example]"]
   ====
   
   This task has the following effect:
   
   .The effect of a deep filter on copying
   image::copy-with-deep-filter-example.png[]
   
   One thing to bear in mind is that a deep filter like this has the side effect of copying the directory structure below `reports` as well as the files. If you just want to copy the files without the directory structure, you need to use an explicit `fileTree(_dir_) { _includes_ }.files` expression. We talk more about the difference between file trees and file collections in the <<#sec:file_trees,File trees>> section.
   
   This is just one of the variations in behavior you're likely to come across when dealing with file operations in Gradle builds. Fortunately, Gradle provides elegant solutions to almost all those use cases. Read the _in-depth_ sections later in the chapter for more detail on how the file operations work in Gradle and what options you have for configuring them.
   
   == Copying directory hierarchies
   
   You may have a need to copy not just files, but the directory structure they reside in as well. This is the default behavior when you specify a directory as the `from()` argument, as demonstrated by the following example that copies everything in the `reports` directory, including all its subdirectories, to the destination:
   
   .Copying an entire directory
   ====
   include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-directory-example]"]
   include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-directory-example]"]
   ====
   
   The key aspect that users struggle with is controlling how much of the directory structure goes to the destination. In the above example, do you get a `toArchive/reports` directory or does everything in `reports` go straight into `toArchive`? The answer is the latter. If a directory is part of the `from()` path, then it _won't_ appear in the destination.
   
   So how do you ensure that `reports` itself is copied across, but not any other directory in `${layout.buildDirectory}`? The answer is to add it as an include pattern:
   
   .Copying an entire directory, including itself
   ====
   include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-directory-including-itself-example]"]
   include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-directory-including-itself-example]"]
   ====
   
   You'll get the same behavior as before except with one extra level of directory in the destination, i.e. `toArchive/reports`.
   
   One thing to note is how the `include()` directive applies only to the `from()`, whereas the directive in the previous section applied to the whole task.
   These different levels of granularity in the copy specification allow you to easily handle most requirements that you will come across.
   You can learn more about this in the section on <<sub:using_child_copy_specifications,child specifications>>.
   
   == Creating archives (zip, tar, etc.)
   
   From the perspective of Gradle, packing files into an archive is effectively a copy in which the destination is the archive file rather than a directory on the file system. This means that creating archives looks a lot like copying, with all of the same features!
   
   The simplest case involves archiving the entire contents of a directory, which this example demonstrates by creating a ZIP of the `toArchive` directory:
   
   .Archiving a directory as a ZIP
   ====
   include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=create-archive-example]"]
   include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=create-archive-example]"]
   ====
   
   Notice how we specify the destination and name of the archive instead of an `into()`: both are required. You often won't see them explicitly set, because most projects apply the <<base_plugin.adoc#base_plugin,Base Plugin>>. It provides some conventional values for those properties. The next example demonstrates this and you can learn more about the conventions in the <<#sec:archive_naming,archive naming>> section.
   
   Each type of archive has its own task type, the most common ones being link:{groovyDslPath}#[Zip], link:{groovyDslPath}#[Tar] and link:{groovyDslPath}#[Jar]. They all share most of the configuration options of `Copy`, including filtering and renaming.
   
   One of the most common scenarios involves copying files into specified subdirectories of the archive. For example, let's say you want to package all PDFs into a `docs` directory in the root of the archive. This `docs` directory doesn't exist in the source location, so you have to create it as part of the archive. You do this by adding an `into()` declaration for just the PDFs:
   
   .Using the Base Plugin for its archive name convention
   ====
   include::sample[dir="snippets/files/archivesWithBasePlugin/kotlin",files="build.gradle.kts[tags=create-archive-with-base-plugin-example]"]
   include::sample[dir="snippets/files/archivesWithBasePlugin/groovy",files="build.gradle[tags=create-archive-with-base-plugin-example]"]
   ====
   
   As you can see, you can have multiple `from()` declarations in a copy specification, each with its own configuration. See <<#sub:using_child_copy_specifications,Using child copy specifications>> for more information on this feature.
   
   == Unpacking archives
   
   Archives are effectively self-contained file systems, so unpacking them is a case of copying the files from that file system onto the local file system 댹맖r even into another archive.
   Gradle enables this by providing some wrapper functions that make archives available as hierarchical collections of files (<<sec:file_trees,file trees>>).
   
   The two functions of interest are link:{groovyDslPath}#[Project.zipTree(java.lang.Object)] and link:{groovyDslPath}#[Project.tarTree(java.lang.Object)], which produce a link:{javadocPath}#[FileTree] from a corresponding archive file. That file tree can then be used in a `from()` specification, like so:
   
   .Unpacking a ZIP file
   ====
   include::sample[dir="snippets/files/archives/kotlin",files="build.gradle.kts[tags=unpack-archive-example]"]
   include::sample[dir="snippets/files/archives/groovy",files="build.gradle[tags=unpack-archive-example]"]
   ====
   
   As with a normal copy, you can control which files are unpacked via <<#sec:filtering_files,filters>> and even <<#sec:renaming_files,rename files>> as they are unpacked.
   
   More advanced processing can be handled by the link:{groovyDslPath}#[eachFile()] method. For example, you might need to extract different subtrees of the archive into different paths within the destination directory. The following sample uses the method to extract the files within the archive's `libs` directory into the root destination directory, rather than into a `libs` subdirectory:
   
   .Unpacking a subset of a ZIP file
   ====
   include::sample[dir="snippets/files/archives/kotlin",files="build.gradle.kts[tags=unpack-archive-subset-example]"]
   include::sample[dir="snippets/files/archives/groovy",files="build.gradle[tags=unpack-archive-subset-example]"]
   ====
   <1> Extracts only the subset of files that reside in the `libs` directory
   <2> Remaps the path of the extracting files into the destination directory by dropping the `libs` segment from the file path
   <3> Ignores the empty directories resulting from the remapping, see Caution note below
   
   [CAUTION]
   ====
   You can not change the destination path of empty directories with this technique.
   You can learn more in https://github.com/gradle/gradle/issues/2940[this issue].
   ====
   
   If you're a Java developer and are wondering why there is no `jarTree()` method, that's because `zipTree()` works perfectly well for JARs, WARs and EARs.
   
   == Creating "uber" or "fat" JARs
   
   In the Java space, applications and their dependencies typically used to be packaged as separate JARs within a single distribution archive. That still happens, but there is another approach that is now common: placing the classes and resources of the dependencies directly into the application JAR, creating what is known as an uber or fat JAR.
   
   Gradle makes this approach easy to accomplish. Consider the aim: to copy the contents of other JAR files into the application JAR. All you need for this is the link:{groovyDslPath}#[Project.zipTree(java.lang.Object)] method and the link:{groovyDslPath}#[Jar] task, as demonstrated by the `uberJar` task in the following example:
   
   .Creating a Java uber or fat JAR
   ====
   include::sample[dir="snippets/files/archivesWithJavaPlugin/kotlin",files="build.gradle.kts[tags=create-uber-jar-example]"]
   include::sample[dir="snippets/files/archivesWithJavaPlugin/groovy",files="build.gradle[tags=create-uber-jar-example]"]
   ====
   
   In this case, we're taking the runtime dependencies of the project  `configurations.runtimeClasspath.files`  and wrapping each of the JAR files with the `zipTree()` method. The result is a collection of ZIP file trees, the contents of which are copied into the uber JAR alongside the application classes.
   
   == Creating directories
   
   Many tasks need to create directories to store the files they generate, which is why Gradle automatically manages this aspect of tasks when they explicitly define file and directory outputs. You can learn about this feature in the <<incremental_build.adoc#incremental_build,incremental build>> section of the user manual. All core Gradle tasks ensure that any output directories they need are created if necessary using this mechanism.
   
   In cases where you need to create a directory manually, you can use the standard `{javaApi}/java/nio/file/Files.html#createDirectories-java.nio.file.Path-java.nio.file.attribute.FileAttribute++...++-[Files.createDirectories]` or `{javaApi}/java/io/File.html#mkdirs--[File.mkdirs]` methods from within your build scripts or custom task implementations. Here's a simple example that creates a single `images` directory in the project folder:
   
   .Manually creating a directory
   ====
   include::sample[dir="snippets/files/misc/kotlin",files="build.gradle.kts[tags=mkdir-example]"]
   include::sample[dir="snippets/files/misc/groovy",files="build.gradle[tags=mkdir-example]"]
   ====
   
   As described in the {antManual}/Tasks/mkdir.html[Apache Ant manual], the `mkdir` task will automatically create all necessary directories in the given path and will do nothing if the directory already exists.
   
   == Moving files and directories
   
   Gradle has no API for moving files and directories around, but you can use the <<ant.adoc#ant,Apache Ant integration>> to easily do that, as shown in this example:
   
   .Moving a directory using the Ant task
   ====
   include::sample[dir="snippets/files/misc/kotlin",files="build.gradle.kts[tags=move-example]"]
   include::sample[dir="snippets/files/misc/groovy",files="build.gradle[tags=move-example]"]
   ====
   
   This is not a common requirement and should be used sparingly as you lose information and can easily break a build. It's generally preferable to copy directories and files instead.
   
   == Renaming files on copy
   
   The files used and generated by your builds sometimes don't have names that suit, in which case you want to rename those files as you copy them. Gradle allows you to do this as part of a copy specification using the `rename()` configuration.
   
   The following example removes the "-staging" marker from the names of any files that have it:
   
   .Renaming files as they are copied
   ====
   include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=rename-on-copy-example]"]
   include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=rename-on-copy-example]"]
   ====
   
   You can use regular expressions for this, as in the above example, or closures that use more complex logic to determine the target filename. For example, the following task truncates filenames:
   
   .Truncating filenames as they are copied
   ====
   include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=truncate-names-example]"]
   include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=truncate-names-example]"]
   ====
   
   As with filtering, you can also apply renaming to a subset of files by configuring it as part of a child specification on a `from()`.
   
   == Deleting files and directories
   
   You can easily delete files and directories using either the link:{groovyDslPath}#[Delete] task or the link:{groovyDslPath}#[Project.delete(org.gradle.api.Action)] method.
   In both cases, you specify which files and directories to delete in a way supported by the link:{groovyDslPath}#[]++)[Project.files(java.lang.Object...)] method.
   
   For example, the following task deletes the entire contents of a build's output directory:
   
   .Deleting a directory
   ====
   include::sample[dir="snippets/files/misc/kotlin",files="build.gradle.kts[tags=delete-example]"]
   include::sample[dir="snippets/files/misc/groovy",files="build.gradle[tags=delete-example]"]
   ====
   
   If you want more control over which files are deleted, you can't use inclusions and exclusions in the same way as for copying files.
   Instead, you have to use the builtin filtering mechanisms of `FileCollection` and `FileTree`.
   The following example does just that to clear out temporary files from a source directory:
   
   .Deleting files matching a specific pattern
   ====
   include::sample[dir="snippets/files/misc/kotlin",files="build.gradle.kts[tags=delete-with-filter-example]"]
   include::sample[dir="snippets/files/misc/groovy",files="build.gradle[tags=delete-with-filter-example]"]
   ====
   
   You'll learn more about file collections and file trees in the next section.
   
   == File paths in depth
   
   In order to perform some action on a file, you need to know where it is, and that's the information provided by file paths. Gradle builds on the standard Java `{javaApi}/java/io/File.html[File]` class, which represents the location of a single file, and provides new APIs for dealing with collections of paths. This section shows you how to use the Gradle APIs to specify file paths for use in tasks and file operations.
   
   But first, an important note on using hard-coded file paths in your builds.
   
   
   === On hard-coded file paths
   
   Many examples in this chapter use hard-coded paths as string literals. This makes them easy to understand, but it's not good practice for real builds. The problem is that paths often change and the more places you need to change them, the more likely you are to miss one and break the build.
   
   Where possible, you should use tasks, task properties, and <<writing_build_scripts.adoc#sec:extra_properties,project properties>>  in that order of preference  to configure file paths. For example, if you were to create a task that packages the compiled classes of a Java application, you should aim for something like this:
   
   .How to minimize the number of hard-coded paths in your build
   ====
   include::sample[dir="snippets/files/sampleJavaProject/kotlin",files="build.gradle.kts[tags=link-task-properties]"]
   include::sample[dir="snippets/files/sampleJavaProject/groovy",files="build.gradle[tags=link-task-properties]"]
   ====
   
   See how we're using the `compileJava` task as the source of the files to package and we've created a project property `archivesDirPath` to store the location where we put archives, on the basis we're likely to use it elsewhere in the build.
   
   Using a task directly as an argument like this relies on it having <<incremental_build.adoc#sec:task_inputs_outputs,defined outputs>>, so it won't always be possible.
   In addition, this example could be improved further by relying on the Java plugin's convention for `destinationDirectory` rather than overriding it, but it does demonstrate the use of project properties.
   
   === Single files and directories
   
   Gradle provides the link:{groovyDslPath}#[Project.file(java.lang.Object)] method for specifying the location of a single file or directory.
   Relative paths are resolved relative to the project directory, while absolute paths remain unchanged.
   
   [CAUTION]
   ====
   Never use `new File(relative path)` unless passed to `file()` or `files()` or `from()` or other methods being defined in terms of `file()` or `files()`.
   Otherwise this creates a path relative to the current working directory (CWD).
   Gradle can make no guarantees about the location of the CWD, which means builds that rely on it may break at any time.
   ====
   
   Here are some examples of using the `file()` method with different types of argument:
   
   .Locating files
   ====
   include::sample[dir="snippets/files/file/kotlin",files="build.gradle.kts[tags=simple-params]"]
   include::sample[dir="snippets/files/file/groovy",files="build.gradle[tags=simple-params]"]
   ====
   
   As you can see, you can pass strings, `File` instances and `{javaApi}/java/nio/file/Path.html[Path]` instances to the `file()` method, all of which result in an absolute `File` object. You can find other options for argument types in the reference guide, linked in the previous paragraph.
   
   What happens in the case of multi-project builds? The `file()` method will always turn relative paths into paths that are relative to the current project directory, which may be a child project. If you want to use a path that's relative to the _root project_ directory, then you need to use the special link:{groovyDslPath}#[Project.getRootDir()] property to construct an absolute path, like so:
   
   .Creating a path relative to a parent project
   ====
   include::sample[dir="snippets/files/misc/kotlin/project2",files="build.gradle.kts[tags=using-root-dir-property]"]
   include::sample[dir="snippets/files/misc/groovy/project2",files="build.gradle[tags=using-root-dir-property]"]
   ====
   
   Let's say you're working on a multi-project build in a `dev/projects/AcmeHealth` directory. You use the above example in the build of the library you're fixing  at `AcmeHealth/subprojects/AcmePatientRecordLib/build.gradle`. The file path will resolve to the absolute version of `dev/projects/AcmeHealth/shared/config.xml`.
   
   The `file()` method can be used to configure any task that has a property of type `File`. Many tasks, though, work on multiple files, so we look at how to specify sets of files next.
   
   === File collections
   
   A _file collection_ is simply a set of file paths that's represented by the link:{javadocPath}#[FileCollection] interface. _Any_ file paths.
   It's important to understand that the file paths don't have to be related in any way, so they don't have to be in the same directory or even have a shared parent directory.
   You will also find that many parts of the Gradle API use `FileCollection`, such as the copying API discussed later in this chapter and <<declaring_dependencies.adoc#sec:what-are-dependency-configurations,dependency configurations>>.
   
   The recommended way to specify a collection of files is to use the link:{javadocPath}#[ProjectLayout.files(java.lang.Object++...++)] method, which returns a `FileCollection` instance.
   This method is very flexible and allows you to pass multiple strings, `File` instances, collections of strings, collections of ``File``s, and more.
   You can even pass in tasks as arguments if they have <<incremental_build.adoc#sec:task_inputs_outputs,defined outputs>>.
   Learn about all the supported argument types in the reference guide.
   
   CAUTION: `files()` properly handle relative paths and `File(relative path)` instances, resolving them relative to the project directory.
   
   As with the link:{groovyDslPath}#[Project.file(java.lang.Object)] method covered in the <<#sec:single_file_paths,previous section>>, all relative paths are evaluated relative to the current project directory. The following example demonstrates some of the variety of argument types you can use  strings, `File` instances, a list and a `{javaApi}/java/nio/file/Path.html[Path]`:
   
   .Creating a file collection
   ====
   include::sample[dir="snippets/files/fileCollections/kotlin",files="build.gradle.kts[tags=simple-params]"]
   include::sample[dir="snippets/files/fileCollections/groovy",files="build.gradle[tags=simple-params]"]
   ====
   
   File collections have some important attributes in Gradle. They can be:
   
    * created lazily
    * iterated over
    * filtered
    * combined
   
   _Lazy creation_ of a file collection is useful when you need to evaluate the files that make up a collection at the time a build runs. In the following example, we query the file system to find out what files exist in a particular directory and then make those into a file collection:
   
   .Implementing a file collection
   ====
   include::sample[dir="snippets/files/fileCollections/kotlin",files="build.gradle.kts[tags=closure]"]
   include::sample[dir="snippets/files/fileCollections/groovy",files="build.gradle[tags=closure]"]
   ====
   
   .Output of **`gradle -q list`**
   ----
   > gradle -q list
   include::{snippetsPath}/files/fileCollections/tests/fileCollectionsWithClosure.out[]
   ----
   
   The key to lazy creation is passing a closure (in Groovy) or a `Provider` (in Kotlin) to the `files()` method. Your closure/provider simply needs to return a value of a type accepted by `files()`, such as `List<File>`, `String`, `FileCollection`, etc.
   
   _Iterating over a file collection_ can be done through the `each()` method (in Groovy) or `forEach` method (in Kotlin) on the collection or using the collection in a `for` loop. In both approaches, the file collection is treated as a set of `File` instances, i.e. your iteration variable will be of type `File`.
   
   The following example demonstrates such iteration as well as how you can convert file collections to other types using the `as` operator or supported properties:
   
   .Using a file collection
   ====
   include::sample[dir="snippets/files/fileCollections/kotlin",files="build.gradle.kts[tags=usage]"]
   include::sample[dir="snippets/files/fileCollections/groovy",files="build.gradle[tags=usage]"]
   ====
   
   You can also see at the end of the example _how to combine file collections_ using the `+` and `-` operators to merge and subtract them. An important feature of the resulting file collections is that they are _live_. In other words, when you combine file collections in this way, the result always reflects what's currently in the source file collections, even if they change during the build.
   
   For example, imagine `collection` in the above example gains an extra file or two after `union` is created. As long as you use `union` after those files are added to `collection`, `union` will also contain those additional files. The same goes for the `different` file collection.
   
   Live collections are also important when it comes to _filtering_. If you want to use a subset of a file collection, you can take advantage of the link:{javadocPath}#[FileCollection.filter(org.gradle.api.specs.Spec)] method to determine which files to "keep". In the following example, we create a new collection that consists of only the files that end with .txt in the source collection:
   
   .Filtering a file collection
   ====
   include::sample[dir="snippets/files/fileCollections/kotlin",files="build.gradle.kts[tags=filtering-file-collections]"]
   include::sample[dir="snippets/files/fileCollections/groovy",files="build.gradle[tags=filtering-file-collections]"]
   ====
   
   .Output of **`gradle -q filterTextFiles`**
   ----
   > gradle -q filterTextFiles
   include::{snippetsPath}/files/fileCollections/tests/fileCollectionsFiltering.out[]
   ----
   
   If `collection` changes at any time, either by adding or removing files from itself, then `textFiles` will immediately reflect the change because it is also a live collection. Note that the closure you pass to `filter()` takes a `File` as an argument and should return a boolean.
   
   === File trees
   
   A _file tree_ is a file collection that retains the directory structure of the files it contains and has the type link:{javadocPath}#[FileTree]. This means that all the paths in a file tree must have a shared parent directory. The following diagram highlights the distinction between file trees and file collections in the common case of copying files:
   
   .The differences in how file trees and file collections behave when copying files
   image::file-collection-vs-file-tree.png[]
   
   NOTE: Although `FileTree` extends `FileCollection` (an is-a relationship), their behaviors do differ. In other words, you can use a file tree wherever a file collection is required, but remember: a file collection is a flat list/set of files, while a file tree is a file and directory hierarchy. To convert a file tree to a flat collection, use the link:{javadocPath}#[FileTree.getFiles()] property.
   
   The simplest way to create a file tree is to pass a file or directory path to the link:{groovyDslPath}#[Project.fileTree(java.lang.Object)] method. This will create a tree of all the files and directories in that base directory (but not the base directory itself). The following example demonstrates how to use the basic method and, in addition, how to filter the files and directories using Ant-style patterns:
   
   .Creating a file tree
   ====
   include::sample[dir="snippets/files/fileTrees/kotlin",files="build.gradle.kts[tags=define]"]
   include::sample[dir="snippets/files/fileTrees/groovy",files="build.gradle[tags=define]"]
   ====
   
   You can see more examples of supported patterns in the API docs for link:{javadocPath}#[PatternFilterable]. Also, see the API documentation for `fileTree()` to see what types you can pass as the base directory.
   
   By default, `fileTree()` returns a `FileTree` instance that applies some default exclude patterns for convenience  the same defaults as Ant in fact. For the complete default exclude list, see http://ant.apache.org/manual/dirtasks.html#defaultexcludes[the Ant manual].
   
   If those default excludes prove problematic, you can workaround the issue by changing the default excludes in the settings script:
   
   .Changing default excludes in the settings script
   ====
   include::sample[dir="snippets/files/copy/kotlin",files="settings.gradle.kts[tags=change-default-exclusions]"]
   include::sample[dir="snippets/files/copy/groovy",files="settings.gradle[tags=change-default-exclusions]"]
   ====
   
   NOTE: Currently, Gradle's default excludes are configured via Ant's `DirectoryScanner` class.
   
   IMPORTANT: Gradle does not support changing default excludes during the execution phase.
   
   You can do many of the same things with file trees that you can with file collections:
   
    * iterate over them (depth first)
    * filter them (using link:{javadocPath}#[FileTree.matching(org.gradle.api.Action)] and Ant-style patterns)
    * merge them
   
   You can also traverse file trees using the link:{javadocPath}#[FileTree.visit(org.gradle.api.Action)] method. All of these techniques are demonstrated in the following example:
   
   .Using a file tree
   ====
   include::sample[dir="snippets/files/fileTrees/kotlin",files="build.gradle.kts[tags=use]"]
   include::sample[dir="snippets/files/fileTrees/groovy",files="build.gradle[tags=use]"]
   ====
   
   We've discussed how to create your own file trees and file collections, but it's also worth bearing in mind that many Gradle plugins provide their own instances of file trees, such as <<building_java_projects.adoc#sec:java_source_sets,Java's source sets>>. These can be used and manipulated in exactly the same way as the file trees you create yourself.
   
   Another specific type of file tree that users commonly need is the archive, i.e. ZIP files, TAR files, etc. We look at those next.
   
   === Using archives as file trees
   
   An archive is a directory and file hierarchy packed into a single file. In other words, it's a special case of a file tree, and that's exactly how Gradle treats archives. Instead of using the `fileTree()` method, which only works on normal file systems, you use the link:{groovyDslPath}#[Project.zipTree(java.lang.Object)] and link:{groovyDslPath}#[Project.tarTree(java.lang.Object)] methods to wrap archive files of the corresponding type (note that JAR, WAR and EAR files are ZIPs). Both methods return `FileTree` instances that you can then use in the same way as normal file trees. For example, you can extract some or all of the files of an archive by copying its contents to some directory on the file system. Or you can merge one archive into another.
   
   Here are some simple examples of creating archive-based file trees:
   
   .Using an archive as a file tree
   ====
   include::sample[dir="snippets/files/fileTrees/kotlin",files="build.gradle.kts[tags=archive-trees]"]
   include::sample[dir="snippets/files/fileTrees/groovy",files="build.gradle[tags=archive-trees]"]
   ====
   
   You can see a practical example of extracting an archive file <<#sec:unpacking_archives_example,in among the common scenarios>> we cover.
   
   === Understanding implicit conversion to file collections
   
   Many objects in Gradle have properties which accept a set of input files.
   For example, the link:{groovyDslPath}#[JavaCompile] task has a `source` property that defines the source files to compile.
   You can set the value of this property using any of the types supported by the <<#sec:file_collections,files()>> method, as mentioned in the API docs.
   This means you can, for example, set the property to a `File`, `String`, collection, `FileCollection` or even a closure or `Provider`.
   
   *This is a feature of specific tasks*!
   That means implicit conversion will not happen for just any task that has a `FileCollection` or `FileTree` property.
   If you want to know whether implicit conversion happens in a particular situation, you will need to read the relevant documentation, such as the corresponding task's API docs.
   Alternatively, you can remove all doubt by explicitly using link:{javadocPath}#[ProjectLayout.files(java.lang.Object++...++)] in your build.
   
   Here are some examples of the different types of arguments that the `source` property can take:
   
   .Specifying a set of files
   ====
   include::sample[dir="snippets/files/inputFiles/kotlin",files="build.gradle.kts[tags=set-input-files]"]
   include::sample[dir="snippets/files/inputFiles/groovy",files="build.gradle[tags=set-input-files]"]
   ====
   
   One other thing to note is that properties like `source` have corresponding methods in core Gradle tasks. Those methods follow the convention of _appending_ to collections of values rather than replacing them. Again, this method accepts any of the types supported by the <<#sec:file_collections,files()>> method, as shown here:
   
   .Appending a set of files
   ====
   include::sample[dir="snippets/files/inputFiles/kotlin",files="build.gradle.kts[tags=add-input-files]"]
   include::sample[dir="snippets/files/inputFiles/groovy",files="build.gradle[tags=add-input-files]"]
   ====
   
   As this is a common convention, we recommend that you follow it in your own custom tasks. Specifically, if you plan to add a method to configure a collection-based property, make sure the method appends rather than replaces values.
   
   == File copying in depth
   
   The basic process of copying files in Gradle is a simple one:
   
    * Define a task of type link:{groovyDslPath}#[Copy]
    * Specify which files (and potentially directories) to copy
    * Specify a destination for the copied files
   
   But this apparent simplicity hides a rich API that allows fine-grained control of which files are copied, where they go, and what happens to them as they are copied  renaming of the files and token substitution of file content are both possibilities, for example.
   
   Let's start with the last two items on the list, which form what is known as a _copy specification_. This is formally based on the link:{javadocPath}#[CopySpec] interface, which the `Copy` task implements, and offers:
   
    * A link:{javadocPath}#[CopySpec.from(java.lang.Object...)] method to define what to copy
    * An link:{javadocPath}#[CopySpec.into(java.lang.Object)] method to define the destination
   
   `CopySpec` has several additional methods that allow you to control the copying process, but these two are the only required ones. `into()` is straightforward, requiring a directory path as its argument in any form supported by the link:{groovyDslPath}#[Project.file(java.lang.Object)] method. The `from()` configuration is far more flexible.
   
   Not only does `from()` accept multiple arguments, it also allows several different types of argument. For example, some of the most common types are:
   
    * A `String`  treated as a file path or, if it starts with "file://", a file URI
    * A `File`  used as a file path
    * A `FileCollection` or `FileTree`  all files in the collection are included in the copy
    * A task 댹맚he files or directories that form a task's <<incremental_build.adoc#sec:task_inputs_outputs,defined outputs>> are included
   
   In fact, `from()` accepts all the same arguments as link:{groovyDslPath}#[]++)[Project.files(java.lang.Object...)] so see that method for a more detailed list of acceptable types.
   
   Something else to consider is what type of thing a file path refers to:
   
    * A file  the file is copied as is
    * A directory  this is effectively treated as a file tree: everything in it, including subdirectories, is copied. However, the directory itself is not included in the copy.
    * A non-existent file  the path is ignored
   
   Here is an example that uses multiple `from()` specifications, each with a different argument type. You will probably also notice that `into()` is configured lazily using a closure (in Groovy) or a Provider (in Kotlin)  a technique that also works with `from()`:
   
   .Specifying copy task source files and destination directory
   ====
   include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-task-2]"]
   include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-task-2]"]
   ====
   
   Note that the lazy configuration of `into()` is different from a <<#sub:using_child_copy_specifications,child specification>>, even though the syntax is similar. Keep an eye on the number of arguments to distinguish between them.
   
   === Filtering files
   
   You've already seen that you can filter file collections and file trees directly in a `Copy` task, but you can also apply filtering in any copy specification through the link:{javadocPath}#[CopySpec.include(java.lang.String...)] and link:{javadocPath}#[CopySpec.exclude(java.lang.String...)] methods.
   
   Both of these methods are normally used with Ant-style include or exclude patterns, as described in link:{javadocPath}#[PatternFilterable]. You can also perform more complex logic by using a closure that takes a link:{javadocPath}#[FileTreeElement] and returns `true` if the file should be included or `false` otherwise. The following example demonstrates both forms, ensuring that only .html and .jsp files are copied, except for those .html files with the word "DRAFT" in their content:
   
   .Selecting the files to copy
   ====
   include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-task-with-patterns]"]
   include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-task-with-patterns]"]
   ====
   
   A question you may ask yourself at this point is what happens when inclusion and exclusion patterns overlap? Which pattern wins? Here are the basic rules:
   
    * If there are no explicit inclusions or exclusions, everything is included
    * If at least one inclusion is specified, only files and directories matching the patterns are included
    * Any exclusion pattern overrides any inclusions, so if a file or directory matches at least one exclusion pattern, it won't be included, regardless of the inclusion patterns
   
   Bear these rules in mind when creating combined inclusion and exclusion specifications so that you end up with the exact behavior you want.
   
   Note that the inclusions and exclusions in the above example will apply to _all_ `from()` configurations. If you want to apply filtering to a subset of the copied files, you'll need to use <<sub:using_child_copy_specifications,child specifications>>.
   
   === Renaming files
   
   The <<#sec:renaming_files_example,example of how to rename files on copy>> gives you most of the information you need to perform this operation. It demonstrates the two options for renaming:
   
    * Using a regular expression
    * Using a closure
   
   Regular expressions are a flexible approach to renaming, particularly as Gradle supports regex groups that allow you to remove and replaces parts of the source filename. The following example shows how you can remove the string "-staging" from any filename that contains it using a simple regular expression:
   
   .Renaming files as they are copied
   ====
   include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=rename-files]"]
   include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=rename-files]"]
   ====
   
   You can use any regular expression supported by the Java `{javaApi}/java/util/regex/Pattern.html[Pattern]` class and the substitution string (the second argument of `rename()` works on the same principles as the `{javaApi}/java/util/regex/Matcher.html#appendReplacement(java.lang.StringBuffer,%20java.lang.String)[Matcher.appendReplacement()]` method.
   
   .Regular expressions in Groovy build scripts
   --
   There are two common issues people come across when using regular expressions in this context:
   
   1. If you use a slashy string (those delimited by '/') for the first argument, you _must_ include the parentheses for `rename()` as shown in the above example.
   2. It's safest to use single quotes for the second argument, otherwise you need to escape the '$' in group substitutions, i.e. `"\$1\$2"`.
   
   The first is a minor inconvenience, but slashy strings have the advantage that you don't have to escape backslash ('\') characters in the regular expression. The second issue stems from Groovy's support for embedded expressions using `${ }` syntax in double-quoted and slashy strings.
   --
   
   The closure syntax for `rename()` is straightforward and can be used for any requirements that simple regular expressions can't handle. You're given the name of a file and you return a new name for that file, or `null` if you don't want to change the name. Do be aware that the closure will be executed for every file that's copied, so try to avoid expensive operations where possible.
   
   === Filtering file content (token substitution, templating, etc.)
   
   Not to be confused with filtering which files are copied, _file content filtering_ allows you to transform the content of files while they are being copied. This can involve basic templating that uses token substitution, removal of lines of text, or even more complex filtering using a full-blown template engine.
   
   The following example demonstrates several forms of filtering, including token substitution using the link:{javadocPath}#[CopySpec.expand(java.util.Map)] method and another using link:{javadocPath}#[CopySpec.filter(java.lang.Class)] with an https://ant.apache.org/manual/Types/filterchain.html[Ant filter]:
   
   .Filtering files as they are copied
   ====
   include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=filter-files]"]
   include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=filter-files]"]
   ====
   
   The `filter()` method has two variants, which behave differently:
   
    * one takes a `{javaApi}/java/io/FilterReader.html[FilterReader]` and is designed to work with Ant filters, such as `ReplaceTokens`
    * one takes a closure or link:{javadocPath}#[Transformer] that defines the transformation for each line of the source file
   
   Note that both variants assume the source files are text based. When you use the `ReplaceTokens` class with `filter()`, the result is a template engine that replaces tokens of the form `@tokenName@` (the Ant-style token) with values that you define.
   
   The `expand()` method treats the source files as https://docs.groovy-lang.org/latest/html/api/groovy/text/SimpleTemplateEngine.html[Groovy templates], which evaluate and expand expressions of the form `${expression}`. You can pass in property names and values that are then expanded in the source files. `expand()` allows for more than basic token substitution as the embedded expressions are full-blown Groovy expressions.
   
   NOTE: It's good practice to specify the character set when reading and writing the file, otherwise the transformations won't work properly for non-ASCII text. You configure the character set with the link:{javadocPath}#[CopySpec.setFilteringCharset(String)] property. If it's not specified, the JVM default character set is used, which is likely to be different from the one you want.
   
   === Setting file permissions
   
   For any `CopySpec` involved in copying files, may it be the `Copy` task itself, or any child specifications, you can explicitly set the permissions the destination files will have, via the link:{javadocPath}#[CopySpec.filePermissions {}] configurations block.
   You can do the same for directories too, independently of files, via the link:{javadocPath}#[CopySpec.dirPermissions {}] configurations block.
   
   NOTE: Not setting permissions explicitly will preserve the permissions of the original files or directories.
   
   .Setting permissions for destination files
   ====
   include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=file-permissions]"]
   include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=file-permissions]"]
   ====
   
   For a detailed description of file permissions see link:{javadocPath}#[FilePermissions] and link:{javadocPath}#[UserClassFilePermissions].
   For details on the convenience method used in the samples see link:{javadocPath}#[ConfigurableFilePermissions.unix(String)].
   
   Using empty configuration blocks for file or directory permissions still sets them explicitly, just to fixed default values.
   In fact everything that's inside one of these configurations blocks is relative to the default values.
   Default permissions differ for files and directories:
   
    * *file*: read & write for *owner*, read for *group*, read for *other* (*0644*, *rw-r--r--*)
    * *directory*: read, write & execute for *owner*, read & execute for *group*, read & execute for *other* (*0755*, *rwxr-xr-x*)
   
   === Using the `CopySpec` class
   
   A copy specification (or copy spec for short) determines what gets copied to where, and what happens to files during the copy. You've alread seen many examples in the form of configuration for `Copy` and archiving tasks. But copy specs have two attributes that are worth covering in more detail:
   
    1. They can be independent of tasks
    2. They are hierarchical
   
   The first of these attributes allows you to _share copy specs within a build_. The second provides fine-grained control within the overall copy specification.
   
   ==== Sharing copy specs
   
   Consider a build that has several tasks that copy a project's static website resources or add them to an archive. One task might copy the resources to a folder for a local HTTP server and another might package them into a distribution. You could manually specify the file locations and appropriate inclusions each time they are needed, but human error is more likely to creep in, resulting in inconsistencies between tasks.
   
   One solution Gradle provides is the link:{groovyDslPath}#[Project.copySpec(org.gradle.api.Action)] method. This allows you to create a copy spec outside of a task, which can then be attached to an appropriate task using the link:{javadocPath}#[CopySpec.with(org.gradle.api.file.CopySpec...)] method. The following example demonstrates how this is done:
   
   .Sharing copy specifications
   ====
   include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=standalone-copyspec]"]
   include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=standalone-copyspec]"]
   ====
   
   Both the `copyAssets` and `distApp` tasks will process the static resources under `src/main/webapp`, as specified by `webAssetsSpec`.
   
   [NOTE]
   ====
   The configuration defined by `webAssetsSpec` will _not_ apply to the app classes included by the `distApp` task. That's because `from appClasses` is its own child specification independent of `with webAssetsSpec`.
   
   This can be confusing to understand, so it's probably best to treat `with()` as an extra `from()` specification in the task. Hence it doesn't make sense to define a standalone copy spec without at least one `from()` defined.
   ====
   
   If you encounter a scenario in which you want to apply the same copy configuration to _different_ sets of files, then you can share the configuration block directly without using `copySpec()`. Here's an example that has two independent tasks that happen to want to process image files only:
   
   .Sharing copy patterns only
   ====
   include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=shared-copy-patterns]"]
   include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=shared-copy-patterns]"]
   ====
   
   In this case, we assign the copy configuration to its own variable and apply it to whatever `from()` specification we want. This doesn't just work for inclusions, but also exclusions, file renaming, and file content filtering.
   
   ==== Using child specifications
   
   If you only use a single copy spec, the file filtering and renaming will apply to _all_ the files that are copied. Sometimes this is what you want, but not always. Consider the following example that copies files into a directory structure that can be used by a Java Servlet container to deliver a website:
   
   .Creating an exploded WAR for a Servlet container
   image::exploded-war-child-copy-spec-example.png[]
   
   This is not a straightforward copy as the `WEB-INF` directory and its subdirectories don't exist within the project, so they must be created during the copy. In addition, we only want HTML and image files going directly into the root folder  `build/explodedWar`  and only JavaScript files going into the `js` directory. So we need separate filter patterns for those two sets of files.
   
   The solution is to use _child specifications_, which can be applied to both `from()` and `into()` declarations. The following task definition does the necessary work:
   
   .Nested copy specs
   ====
   include::sample[dir="snippets/files/sampleJavaProject/kotlin",files="build.gradle.kts[tags=nested-specs]"]
   include::sample[dir="snippets/files/sampleJavaProject/groovy",files="build.gradle[tags=nested-specs]"]
   ====
   
   Notice how the `src/dist` configuration has a nested inclusion specification: that's the child copy spec. You can of course add content filtering and renaming here as required. A child copy spec is still a copy spec.
   
   The above example also demonstrates how you can copy files into a subdirectory of the destination either by using a child `into()` on a `from()` or a child `from()` on an `into()`. Both approaches are acceptable, but you may want to create and follow a convention to ensure consistency across your build files.
   
   [NOTE]
   ====
   Don't get your `into()` specifications mixed up! ]
   For a normal copy 댹맖ne to the filesystem rather than an archive  there should always be _one_ "root" `into()` that simply specifies the overall destination directory of the copy.
   Any other `into()` should have a child spec attached and its path will be relative to the root `into()`.
   ====
   
   One final thing to be aware of is that a child copy spec inherits its destination path, include patterns, exclude patterns, copy actions, name mappings and filters from its parent. So be careful where you place your configuration.
   
   === Copying files in your own tasks
   
   WARNING: Using the `Project.copy` method at execution time, as described here, is not compatible with the <<configuration_cache.adoc#config_cache:requirements:use_project_during_execution,configuration cache>>.
   A possible solution is to implement the task as a proper class and use link:{javadocPath}#[FileSystemOperations.copy] method instead, as described in the <<configuration_cache.adoc#config_cache:troubleshooting,configuration cache chapter>>.
   
   There might be occasions when you want to copy files or directories as _part_ of a task. For example, a custom archiving task based on an unsupported archive format might want to copy files to a temporary directory before they are then archived. You still want to take advantage of Gradle's copy API, but without introducing an extra `Copy` task.
   
   The solution is to use the link:{groovyDslPath}#[Project.copy(org.gradle.api.Action)] method. It works the same way as the `Copy` task by configuring it with a copy spec. Here's a trivial example:
   
   .Copying files using the copy() method without up-to-date check
   ====
   include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-method]"]
   include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-method]"]
   ====
   
   The above example demonstrates the basic syntax and also highlights two major limitations of using the `copy()` method:
   
    1. The `copy()` method is not <<incremental_build.adoc#incremental_build,incremental>>. The example's `copyMethod` task will _always_ execute because it has no information about what files make up the task's inputs. You have to manually define the task inputs and outputs.
   
    2. Using a task as a copy source, i.e. as an argument to `from()`, won't set up an automatic task dependency between your task and that copy source. As such, if you are using the `copy()` method as part of a task action, you must explicitly declare all inputs and outputs in order to get the correct behavior.
   
   The following example shows you how to workaround these limitations by using the <<incremental_build.adoc#sec:task_input_output_runtime_api,dynamic API for task inputs and outputs>>:
   
   .Copying files using the copy() method with up-to-date check
   ====
   include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=copy-method-with-dependency]"]
   include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=copy-method-with-dependency]"]
   ====
   
   These limitations make it preferable to use the `Copy` task wherever possible, because of its builtin support for incremental building and task dependency inference. That is why the `copy()` method is intended for use by <<custom_tasks.adoc#custom_tasks,custom tasks>> that need to copy files as part of their function. Custom tasks that use the `copy()` method should declare the necessary inputs and outputs relevant to the copy action.
   
   === Mirroring directories and file collections with the `Sync` task
   
   The link:{groovyDslPath}#[Sync] task, which extends the `Copy` task, copies the source files into the destination directory and then removes any files from the destination directory which it did not copy. In other words, it synchronizes the contents of a directory with its source. This can be useful for doing things such as installing your application, creating an exploded copy of your archives, or maintaining a copy of the project's dependencies.
   
   Here is an example which maintains a copy of the project's runtime dependencies in the `build/libs` directory.
   
   .Using the Sync task to copy dependencies
   ====
   include::sample[dir="snippets/files/sync/kotlin",files="build.gradle.kts[tags=copy-dependencies]"]
   include::sample[dir="snippets/files/sync/groovy",files="build.gradle[tags=copy-dependencies]"]
   ====
   
   You can also perform the same function in your own tasks with the link:{groovyDslPath}#[Project.sync(org.gradle.api.Action)] method.
   
   === Deploying single files into application servers
   
   When working with application servers, you can use a `Copy` task to deploy the application archive (e.g. a WAR file).
   Since you are deploying a single file, the destination directory of the `Copy` is the whole deployment directory.
   The deployment directory sometimes does contain unreadable files like named pipes, so Gradle may have problems doing up-to-date checks.
   In order to support this use-case, you can use link:{groovyDslPath}#[Task.doNotTrackState()].
   
   .Using Copy to deploy a WAR file
   ====
   include::sample[dir="snippets/files/deployWarWithCopy/kotlin",files="build.gradle.kts"]
   include::sample[dir="snippets/files/deployWarWithCopy/groovy",files="build.gradle"]
   ====
   
   === Installing executables
   
   When you are building a standalone executable, you may want to install this file on your system, so it ends up in your path.
   You can use a `Copy` task to install the executable into shared directories like `/usr/local/bin`.
   The installation directory probably contains many other executables, some of which may even be unreadable by Gradle.
   To support the unreadable files in the `Copy` task's destination directory and to avoid time consuming up-to-date checks, you can use link:{groovyDslPath}#[Task.doNotTrackState()].
   
   .Using Copy to install an executable
   ====
   include::sample[dir="snippets/files/installExecutable/kotlin",files="build.gradle.kts"]
   include::sample[dir="snippets/files/installExecutable/groovy",files="build.gradle"]
   ====
   
   == Archive creation in depth
   
   Archives are essentially self-contained file systems and Gradle treats them as such. This is why working with archives is very similar to working with files and directories, including such things as file permissions.
   
   Out of the box, Gradle supports creation of both ZIP and TAR archives, and by extension Java's JAR, WAR and EAR formats 댹Java's archive formats are all ZIPs. Each of these formats has a corresponding task type to create them: link:{groovyDslPath}#[Zip], link:{groovyDslPath}#[Tar], link:{groovyDslPath}#[Jar], link:{groovyDslPath}#[War], and link:{groovyDslPath}#[Ear]. These all work the same way and are based on copy specifications, just like the `Copy` task.
   
   Creating an archive file is essentially a file copy in which the destination is implicit, i.e. the archive file itself. Here's a basic example that specifies the path and name of the target archive file:
   
   .Archiving a directory as a ZIP
   ====
   include::sample[dir="snippets/files/copy/kotlin",files="build.gradle.kts[tags=create-archive-example]"]
   include::sample[dir="snippets/files/copy/groovy",files="build.gradle[tags=create-archive-example]"]
   ====
   
   In the next section you'll learn about convention-based archive names, which can save you from always configuring the destination directory and archive name.
   
   The full power of copy specifications are available to you when creating archives, which means you can do content filtering, file renaming or anything else that is covered in the previous section. A particularly common requirement is copying files into subdirectories of the archive that don't exist in the source folders, something that can be achieved with `into()` <<#sub:using_child_copy_specifications,child specifications>>.
   
   Gradle does of course allow you create as many archive tasks as you want, but it's worth bearing in mind that many convention-based plugins provide their own. For example, the Java plugin adds a `jar` task for packaging a project's compiled classes and resources in a JAR. Many of these plugins provide sensible conventions for the names of archives as well as the copy specifications used. We recommend you use these tasks wherever you can, rather than overriding them with your own.
   
   === Archive naming
   
   Gradle has several conventions around the naming of archives and where they are created based on the plugins your project uses. The main convention is provided by the <<base_plugin.adoc#base_plugin,Base Plugin>>, which defaults to creating archives in the `layout.buildDirectory.dir("distributions")` directory and typically uses archive names of the form _[projectName]-[version].[type]_.
   
   The following example comes from a project named `archive-naming`, hence the `myZip` task creates an archive named `archive-naming-1.0.zip`:
   
   .Creation of ZIP archive
   ====
   include::sample[dir="snippets/files/archiveNaming/kotlin",files="build.gradle.kts[tags=zip-task]"]
   include::sample[dir="snippets/files/archiveNaming/groovy",files="build.gradle[tags=zip-task]"]
   ====
   
   .Output of **`gradle -q myZip`**
   ----
   > gradle -q myZip
   include::{snippetsPath}/files/archiveNaming/tests/archiveNaming.out[]
   ----
   
   Note that the name of the archive does _not_ derive from the name of the task that creates it.
   
   If you want to change the name and location of a generated archive file, you can provide values for the `archiveFileName` and `destinationDirectory` properties of the corresponding task.
   These override any conventions that would otherwise apply.
   
   Alternatively, you can make use of the default archive name pattern provided by link:{groovyDslPath}#[AbstractArchiveTask.getArchiveFileName()]: _[archiveBaseName]-[archiveAppendix]-[archiveVersion]-[archiveClassifier].[archiveExtension]_.
   You can set each of these properties on the task separately if you wish.
   Note that the Base Plugin uses the convention of project name for _archiveBaseName_, project version for _archiveVersion_ and the archive type for _archiveExtension_.
   It does not provide values for the other properties.
   
   This example  from the same project as the one above  configures just the `archiveBaseName` property, overriding the default value of the project name:
   
   .Configuration of archive task - custom archive name
   ====
   include::sample[dir="snippets/files/archiveNaming/kotlin",files="build.gradle.kts[tags=zip-task-with-custom-base-name]"]
   include::sample[dir="snippets/files/archiveNaming/groovy",files="build.gradle[tags=zip-task-with-custom-base-name]"]
   ====
   
   .Output of **`gradle -q myCustomZip`**
   ----
   > gradle -q myCustomZip
   include::{snippetsPath}/files/archiveNaming/tests/zipWithCustomName.out[]
   ----
   
   You can also override the default `archiveBaseName` value for _all_ the archive tasks in your build by using the _project_ property `archivesBaseName`, as demonstrated by the following example:
   
   .Configuration of archive task - appendix &amp; classifier
   ====
   include::sample[dir="snippets/files/archivesChangedBaseName/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/files/archivesChangedBaseName/groovy",files="build.gradle[]"]
   ====
   
   .Output of **`gradle -q echoNames`**
   ----
   > gradle -q echoNames
   include::{snippetsPath}/files/archivesChangedBaseName/tests/zipWithArchivesBaseName.out[]
   ----
   
   You can find all the possible archive task properties in the API documentation for link:{groovyDslPath}#[AbstractArchiveTask], but we have also summarized the main ones here:
   
   `archiveFileName`  `Property<String>`, default: `__archiveBaseName__-__archiveAppendix__-__archiveVersion__-__archiveClassifier__.__archiveExtension__`::
   The complete file name of the generated archive. If any of the properties in the default value are empty, their '-' separator is dropped.
   
   `archiveFile`  `Provider<RegularFile>`, _read-only_, default: `__destinationDirectory__/__archiveFileName__`::
   The absolute file path of the generated archive.
   
   `destinationDirectory`  `DirectoryProperty`, default: depends on archive type::
   The target directory in which to put the generated archive. By default, JARs and WARs go into `layout.buildDirectory.dir("libs")`. ZIPs and TARs go into `layout.buildDirectory.dir("distributions")`.
   
   `archiveBaseName`  `Property<String>`, default: `__project.name__`::
   The base name portion of the archive file name, typically a project name or some other descriptive name for what it contains.
   
   `archiveAppendix`  `Property<String>`, default: `null`::
   The appendix portion of the archive file name that comes immediately after the base name. It is typically used to distinguish between different forms of content, such as code and docs, or a minimal distribution versus a full or complete one.
   
   `archiveVersion`  `Property<String>`, default: `__project.version__`::
   The version portion of the archive file name, typically in the form of a normal project or product version.
   
   `archiveClassifier`  `Property<String>`, default: `null`::
   The classifier portion of the archive file name. Often used to distinguish between archives that target different platforms.
   
   `archiveExtension`  `Property<String>`, default: depends on archive type and compression type::
   The filename extension for the archive. By default, this is set based on the archive task type and the compression type (if you're creating a TAR). Will be one of: `zip`, `jar`, `war`, `tar`, `tgz` or `tbz2`. You can of course set this to a custom extension if you wish.
   
   === Sharing content between multiple archives
   
   <<#sub:sharing_copy_specs,As described earlier>>, you can use the link:{groovyDslPath}#[Project.copySpec(org.gradle.api.Action)] method to share content between archives.
   
   === Reproducible builds
   
   Sometimes it's desirable to recreate archives exactly the same, byte for byte, on different machines. You want to be sure that building an artifact from source code produces the same result no matter when and where it is built. This is necessary for projects like https://reproducible-builds.org/[reproducible-builds.org].
   
   Reproducing the same byte-for-byte archive poses some challenges since the order of the files in an archive is influenced by the underlying file system. Each time a ZIP, TAR, JAR, WAR or EAR is built from source, the order of the files inside the archive may change. Files that only have a different timestamp also causes differences in archives from build to build. All link:{groovyDslPath}#[AbstractArchiveTask] (e.g. Jar, Zip) tasks shipped with Gradle include support for producing reproducible archives.
   
   For example, to make a `Zip` task reproducible you need to set link:{groovyDslPath}#[Zip.isReproducibleFileOrder()] to `true` and link:{groovyDslPath}#[Zip.isPreserveFileTimestamps()] to `false`. In order to make all archive tasks in your build reproducible, consider adding the following configuration to your build file:
   
   .Activating reproducible archives
   ====
   include::sample[dir="snippets/files/archives/kotlin",files="build.gradle.kts[tags=reproducible]"]
   include::sample[dir="snippets/files/archives/groovy",files="build.gradle[tags=reproducible]"]
   ====
   
   Often you will want to publish an archive, so that it is usable from another project.
   This process is described in <<cross_project_publications.adoc#cross_project_publications,Cross-Project publications>>.

/docs/userguide/authoring-builds/other/logging.adoc
===================================================

.. code-block::

   = Logging
   
   The log is the main 'UI' of a build tool. If it is too verbose, real warnings and problems are easily hidden by this. On the other hand you need relevant information for figuring out if things have gone wrong. Gradle defines 6 log levels, as shown in <<#logLevels,Log levels>>. There are two Gradle-specific log levels, in addition to the ones you might normally see. Those levels are _QUIET_ and _LIFECYCLE_. The latter is the default, and is used to report build progress.
   
   == Log levels
   
   [horizontal]
   ERROR:: Error messages
   QUIET:: Important information messages
   WARNING:: Warning messages
   LIFECYCLE:: Progress information messages
   INFO:: Information messages
   DEBUG:: Debug messages
   
   NOTE: The rich components of the console (build status and work in progress area) are displayed regardless of the log level used. Before Gradle 4.0 those rich components were only displayed at log level `LIFECYCLE` or below.
   
   == Choosing a log level
   
   You can use the command line switches shown in <<#logLevelCommandLineOptions, Log level command-line options>> to choose different log levels. You can also configure the log level using `gradle.properties`, see <<build_environment.adoc#sec:gradle_configuration_properties,Gradle properties>>. In <<#stacktraces,Stacktrace command-line options>> you find the command line switches which affect stacktrace logging.
   
   .Log level command-line options
   [%header%autowidth,compact]
   |===
   | Option | Outputs Log Levels
   | `-q` or `--quiet` | QUIET and higher
   | `-w` or `--warn` | WARN and higher
   | no logging options | LIFECYCLE and higher
   | `-i` or `--info` | INFO and higher
   | `-d` or `--debug` | DEBUG and higher (that is, all log messages)
   |===
   
   CAUTION: The `DEBUG` log level can <<#sec:debug_security, expose security sensitive information to the console>>.
   
   
   === Stacktrace command-line options
   
   `-s` or `--stacktrace`::
   Truncated stacktraces are printed. We recommend this over full stacktraces. Groovy full stacktraces are extremely verbose (Due to the underlying dynamic invocation mechanisms. Yet they usually do not contain relevant information for what has gone wrong in _your_ code.) This option renders stacktraces for deprecation warnings.
   
   `-S` or `--full-stacktrace`::
   The full stacktraces are printed out. This option renders stacktraces for deprecation warnings.
   
   &lt;No stacktrace options&gt;::
   No stacktraces are printed to the console in case of a build error (e.g. a compile error). Only in case of internal exceptions will stacktraces be printed. If the `DEBUG` log level is chosen, truncated stacktraces are always printed.
   
   == Logging Sensitive Information
   
   Running Gradle with the `DEBUG` log level can expose security sensitive information to the console and build log.
   
   This information can include but is not limited to:
   
   - Environment variables
   - Private repository credentials
   - Build cache & Develocity Credentials
   - https://plugins.gradle.org/[Plugin Portal] publishing credentials
   
   The DEBUG log level should *not* be used when running on public Continuous Integration services.
   Build logs for public Continuous Integration services are world-viewable and can expose this sensitive information.
   Depending upon your organization's threat model, logging sensitive credentials in private CI may also be a vulnerability.
   Please discuss this with your organization's security team.
   
   Some CI providers attempt to scrub sensitive credentials from logs; however, this will be imperfect and usually only scrubs exact-matches of pre-configured secrets.
   
   If you believe a Gradle Plugin may be exposing sensitive information, please contact mailto:security@gradle.com[security@gradle.com] for disclosure assistance.
   
   == Writing your own log messages
   
   A simple option for logging in your build file is to write messages to standard output. Gradle redirects anything written to standard output to its logging system at the `QUIET` log level.
   
   .Using stdout to write log messages
   ====
   include::sample[dir="snippets/tutorial/logging/kotlin",files="build.gradle.kts[tags=use-println]"]
   include::sample[dir="snippets/tutorial/logging/groovy",files="build.gradle[tags=use-println]"]
   ====
   
   Gradle also provides a `logger` property to a build script, which is an instance of link:{javadocPath}#[Logger]. This interface extends the SLF4J `Logger` interface and adds a few Gradle specific methods to it. Below is an example of how this is used in the build script:
   
   .Writing your own log messages
   ====
   include::sample[dir="snippets/tutorial/logging/kotlin",files="build.gradle.kts[tags=use-logger]"]
   include::sample[dir="snippets/tutorial/logging/groovy",files="build.gradle[tags=use-logger]"]
   ====
   
   Use the link:https://www.slf4j.org/manual.html#typical_usage[typical SLF4J pattern] to replace a placeholder with an actual value as part of the log message.
   
   .Writing a log message with placeholder
   ====
   include::sample[dir="snippets/tutorial/logging/kotlin",files="build.gradle.kts[tags=use-logger-placeholder]"]
   include::sample[dir="snippets/tutorial/logging/groovy",files="build.gradle[tags=use-logger-placeholder]"]
   ====
   
   You can also hook into Gradle's logging system from within other classes used in the build (classes from the `buildSrc` directory for example). Simply use an SLF4J logger. You can use this logger the same way as you use the provided logger in the build script.
   
   .Using SLF4J to write log messages
   ====
   include::sample[dir="snippets/tutorial/logging/kotlin",files="build.gradle.kts[tags=use-slf4j]"]
   include::sample[dir="snippets/tutorial/logging/groovy",files="build.gradle[tags=use-slf4j]"]
   ====
   
   == Logging from external tools and libraries
   
   Internally, Gradle uses Ant and Ivy. Both have their own logging system. Gradle redirects their logging output into the Gradle logging system. There is a 1:1 mapping from the Ant/Ivy log levels to the Gradle log levels, except the Ant/Ivy `TRACE` log level, which is mapped to Gradle `DEBUG` log level. This means the default Gradle log level will not show any Ant/Ivy output unless it is an error or a warning.
   
   There are many tools out there which still use standard output for logging. By default, Gradle redirects standard output to the `QUIET` log level and standard error to the `ERROR` level. This behavior is configurable. The project object provides a link:{javadocPath}#[LoggingManager], which allows you to change the log levels that standard out or error are redirected to when your build script is evaluated.
   
   .Configuring standard output capture
   ====
   include::sample[dir="snippets/tutorial/logging/kotlin",files="build.gradle.kts[tags=capture-stdout]"]
   include::sample[dir="snippets/tutorial/logging/groovy",files="build.gradle[tags=capture-stdout]"]
   ====
   
   To change the log level for standard out or error during task execution, tasks also provide a link:{javadocPath}#[LoggingManager].
   
   .Configuring standard output capture for a task
   ====
   include::sample[dir="snippets/tutorial/logging/kotlin",files="build.gradle.kts[tags=task-capture-stdout]"]
   include::sample[dir="snippets/tutorial/logging/groovy",files="build.gradle[tags=task-capture-stdout]"]
   ====
   
   Gradle also provides integration with the Java Util Logging, Jakarta Commons Logging and Log4j logging toolkits. Any log messages which your build classes write using these logging toolkits will be redirected to Gradle's logging system.
   
   == Changing what Gradle logs
   
   [WARNING]
   ====
   The <<configuration_cache.adoc#config_cache,configuration cache>> limits the ability to customize Gradle's logging UI.
   The custom logger can only implement <<configuration_cache.adoc#config_cache:requirements:build_listeners,supported listener interfaces>>.
   These interfaces do not receive events when the configuration cache entry is reused, because the whole configuration phase is skipped.
   ====
   
   You can replace much of Gradle's logging UI with your own. You might do this, for example, if you want to customize the UI in some way - to log more or less information, or to change the formatting. You replace the logging using the link:{groovyDslPath}#[Gradle.useLogger(java.lang.Object)] method. This is accessible from a build script, or an init script, or via the embedding API. Note that this completely disables Gradle's default output. Below is an example init script which changes how task execution and build completion is logged.
   
   .Customizing what Gradle logs
   ====
   include::sample[dir="snippets/initScripts/customLogger/kotlin",files="customLogger.init.gradle.kts[]"]
   include::sample[dir="snippets/initScripts/customLogger/groovy",files="customLogger.init.gradle[]"]
   ====
   
   [.multi-language-text.lang-kotlin]
   ----
   $ gradle -I customLogger.init.gradle.kts build
   include::{snippetsPath}/initScripts/customLogger/tests/customLogger.out[]
   ----
   [.multi-language-text.lang-groovy]
   ----
   $ gradle -I customLogger.init.gradle build
   include::{snippetsPath}/initScripts/customLogger/tests/customLogger.out[]
   ----
   
   Your logger can implement any of the listener interfaces listed below. When you register a logger, only the logging for the interfaces that it implements is replaced. Logging for the other interfaces is left untouched. You can find out more about the listener interfaces in <<build_lifecycle.adoc#sec:build_phases,Build lifecycle events>>.
   
   * link:{javadocPath}#[BuildListener]footnote:config_cache_incompat[Not compatible with the configuration cache.]
   * link:{javadocPath}#[ProjectEvaluationListener]
   * link:{javadocPath}#[TaskExecutionGraphListener]
   * link:{javadocPath}#[TaskExecutionListener]footnote:config_cache_incompat[]
   * link:{javadocPath}#[TaskActionListener]footnote:config_cache_incompat[]

/docs/userguide/authoring-builds/other/potential_traps.adoc
===========================================================

.. code-block::

   = Avoiding traps
   
   == Groovy script variables
   
   For users of the Groovy DSL it is important to understand how Groovy deals with script variables.
   Groovy has two types of script variables.
   One with a local scope and one with a script-wide scope.
   
   === Example: Variables scope: local and script wide
   
   [source,groovy]
   .scope.groovy
   ----
   include::{snippetsPath}/tutorial/groovyScope/groovy/src/main/groovy/scope.groovy[]
   ----
   
   .Output of `groovy scope.groovy`
   ----
   > groovy scope.groovy
   include::{snippetsPath}/tutorial/groovyScope/tests/scope.out[]
   ----
   
   Variables which are declared with a type modifier are visible within closures but not visible within methods.
   
   == Configuration and execution phase
   
   It is important to keep in mind that Gradle has a distinct configuration and execution phase (see <<build_lifecycle.adoc#build_lifecycle,Build Lifecycle>>).
   
   .Distinct configuration and execution phase
   ====
   include::sample[dir="snippets/tutorial/mkdirTrap/kotlin", files="build.gradle.kts[]"]
   include::sample[dir="snippets/tutorial/mkdirTrap/groovy", files="build.gradle[]"]
   ====
   
   .Output of **`gradle -q compile`**
   ----
   > gradle -q compile
   include::{snippetsPath}/tutorial/mkdirTrap/tests/mkdirTrap.out[]
   ----
   
   As the creation of the directory happens during the configuration phase, the `clean` task removes the directory during the execution phase.

/docs/userguide/authoring-builds/other/build_environment.adoc
=============================================================

.. code-block::

   = Configuring the Build Environment
   
   Gradle provides multiple mechanisms for configuring the behavior of Gradle itself and specific projects.
   The following is a reference for using these mechanisms.
   
   When configuring Gradle behavior, you can use these methods, listed in order of highest to lowest precedence (the first one wins):
   
   [cols="1,1,1,2"]
   |===
   |Order |Method |Example |Notes
   
   |1
   |<<command_line_interface#command_line_interface, Command-line flags>>
   |`--build-cache`
   |These have precedence over properties and environment variables.
   
   |2
   |<<#sec:gradle_system_properties, System properties>>
   |`systemProp.http.proxyHost=somehost.org`
   |Stored in a `gradle.properties` file in a root project directory.
   
   |3
   |<<#sec:gradle_configuration_properties, Gradle properties>>
   |`org.gradle.caching=true`
   |Stored in a `gradle.properties` file in the `<<directory_layout.adoc#dir:gradle_user_home,GRADLE_USER_HOME>>`.
   
   |3.1
   |<<#sec:gradle_configuration_properties, Gradle properties>>
   |`org.gradle.caching=true`
   |Stored in a `gradle.properties` file in a project directory, then its parent project뗩 directory up to the project뗩 root directory.
   
   |3.2
   |<<#sec:gradle_configuration_properties, Gradle properties>>
   |`org.gradle.caching=true`
   |Stored in a `gradle.properties` file in the `<<sec:gradle_environment_variables,GRADLE_HOME>>`.
   
   |4
   |<<#sec:gradle_environment_variables, Environment variables>>
   |`GRADLE_OPTS`
   |Sourced by the environment that executes Gradle.
   |===
   
   == Configuring your build environment
   You can configure the build using the same mechanisms.
   
   You can also read information about the environment in the build logic.
   
   == 1. Command-line flags
   
   The command line interface, along with the available flags, is described in <<command_line_interface#command_line_interface,its own section>>.
   
   == 2. System properties
   
   Using the `-D` command-line option, you can pass a system property to the JVM, which runs Gradle.
   
   The `-D` option of the `gradle` command has the same effect as the `-D` option of the `java` command.
   
   You can also set system properties in `gradle.properties` files with the prefix `systemProp`:
   
   ----
   systemProp.gradle.wrapperUser=myuser
   systemProp.gradle.wrapperPassword=mypassword
   ----
   
   The following are _common_ system properties:
   
   *Gradle Properties*
   
   `gradle.wrapperUser=(myuser)`:: Specify username to download Gradle distributions <<gradle_wrapper.adoc#sec:authenticated_download,from servers using HTTP Basic Authentication>>.
   `gradle.wrapperPassword=(mypassword)`:: Specify password for downloading a Gradle distribution using the Gradle wrapper.
   `gradle.user.home=(path to directory)`:: Specify the `GRADLE_USER_HOME` directory.
   
   The Gradle Properties listed the <<#sec:gradle_configuration_properties,section below>> can also be set as system properties.
   
   *Networking Properties*
   
   `https.protocols`:: Specify the supported TLS versions in a comma-separated format. e.g., `TLSv1.2,TLSv1.3`.
   `http.proxyHost`:: The hostname, or address, of the proxy server. Default: `none`.
   `http.proxyPort`:: The port number of the proxy server. Default: `80`.
   `http.nonProxyHosts`:: Indicates the hosts that should be accessed without going through the proxy. Default: `localhost|127.*|[::1]`.
   `https.proxyHost`:: The hostname, or address, of the proxy server. Default: `none`.
   `https.proxyPort`:: The port number of the proxy server. Default: `443`.
   `socksProxyHost`:: The hostname, or address, of the proxy server. Default: `none`.
   `socksProxyPort`:: The port number of the proxy server. Default: `1080`.
   `socksProxyVersion`:: The version of the SOCKS protocol supported by the server. Default: `5` for SOCKS V5.
   `java.net.socks.username`:: Username to use if the SOCKSv5 server asks for authentication. Default: `none`.
   `java.net.socks.password`:: Password to use if the SOCKSv5 server asks for authentication. Default: `none`.
   
   *Runtime Environment Properties*
   
   `java.runtime.version=(string)`:: JRE version, e.g. `1.7.0_09-b05`.
   `java.version=(string)`:: JDK version, e.g., `1.7.0_09`.
   `java.home=(string)`:: JRE home directory, e.g., `C:\Program Files\Java\jdk1.7.0_09\jre`.
   `java.class.path=(string)`:: JRE classpath e.g., `.` (dot  used for current working directory).
   `java.library.path=(string)`:: JRE library search path for search native libraries. Typically taken from the environment variable PATH.
   `java.ext.dirs=(string)`:: JRE extension library path(s), e.g, `C:\Program Files\Java\jdk1.7.0_09\jre\lib\ext;C:\Windows\Sun\Java\lib\ext`.
   
   *Operating System Properties*
   
   `os.name=(string)`:: The OS뗩 name, e.g., `Windows 7`.
   `os.arch=(string)`:: The OS뗩 architecture, e.g., `x86`.
   `os.version=(string)`:: The OS뗩 version, e.g., `6.1`.
   
   *File System Properties*
   
   `file.separator=(string)`:: Symbol for file directory separator such as `d:\test\test.java`. Default is '\' for windows or '/' for Unix/Mac.
   `path.separator=(string)`:: Symbol for separating path entries, e.g., in PATH or CLASSPATH. Default is ';' for windows or ':' for Unix/Mac.
   `line.separator=(string)`:: Symbol for end-of-line (or new line). Default is "\r\n" for windows or "\n" for Unix/Mac OS X.
   
   *User Properties*
   
   `user.name=(string)`:: The user뗩 name.
   `user.home=(string)`:: The user뗩 home directory.
   `user.dir=(string)`:: The user뗩 current working directory.
   
   In a multi-project build, `systemProp` properties set in any project except the root will be *ignored*.
   Only the root project's `gradle.properties` file will be checked for properties that begin with `systemProp`.
   
   The following examples demonstrate how to use System properties.
   
   *Example 1:* Setting system properties with a `gradle.properties` file:
   ====
   include::sample[dir="snippets/tutorial/systemProperties/groovy",files="gradle.properties[]"]
   ====
   
   *Example 2:* Reading system properties at configuration time:
   ====
   include::sample[dir="snippets/tutorial/systemProperties/kotlin",files="init.gradle.kts[];settings.gradle.kts[];build.gradle.kts[tags=system-properties]"]
   include::sample[dir="snippets/tutorial/systemProperties/groovy",files="init.gradle[];settings.gradle[];build.gradle[tags=system-properties]"]
   ====
   
   *Example 3:* Reading system properties for consumption at execution time:
   ====
   include::sample[dir="snippets/tutorial/systemProperties/kotlin",files="build.gradle.kts[tags=system-properties-task-inputs]"]
   include::sample[dir="snippets/tutorial/systemProperties/groovy",files="build.gradle[tags=system-properties-task-inputs]"]
   ====
   
   *Example 4:* Setting system properties from the command line `-D gradle.wrapperUser=username`:
   ====
   ----
   $ gradle -Dsystem=commandLineValue
   ----
   ====
   
   == 3. Gradle properties
   
   Gradle provides several options that make it easy to configure the Java process that will be used to execute your build.
   
   While it's possible to configure these in your local environment via `GRADLE_OPTS` or `JAVA_OPTS`, it is useful to be able to store certain settings like JVM memory configuration and `JAVA_HOME` location in version control so that an entire team can work with a consistent environment.
   
   To do so, place these settings into a `gradle.properties` file and commit it to your version control system.
   
   The final configuration taken into account by Gradle is a combination of all Gradle properties set on the command line and your `gradle.properties` files.
   
   If an option is configured in multiple locations, the _first one_ found in any of these locations wins:
   
   . command line, set using `-D`.
   . `gradle.properties` in <<directory_layout.adoc#dir:gradle_user_home,`GRADLE_USER_HOME`>> directory.
   . `gradle.properties` in the project's directory, then its parent project's directory up to the build's root directory.
   . `gradle.properties` in the Gradle installation directory.
   
   NOTE: The location of the `GRADLE_USER_HOME` may have been changed beforehand via the `-Dgradle.user.home` system property passed on the command line.
   
   The following properties can be used to configure the Gradle build environment:
   
   `org.gradle.caching=(true,false)`::
   When set to `true`, Gradle will reuse task outputs from any previous build when possible, <<build_cache.adoc#build_cache,resulting in much faster builds>>.
   +
   _Default is `false`; the build cache is *not* enabled._
   
   `org.gradle.caching.debug=(true,false)`::
   When set to `true`, individual input property hashes and the build cache key for each task are <<build_cache.adoc#sec:task_output_caching,logged on the console>>.
   +
   _Default is `false`._
   
   `org.gradle.configuration-cache=(true,false)`::
   Enables <<configuration_cache.adoc#config_cache:usage:enable, configuration caching>>. Gradle will try to reuse the build configuration from previous builds.
   +
   _Default is `false`._
   
   `org.gradle.configuration-cache.inputs.unsafe.ignore.file-system-checks=(file path)`::
   Used to exclude file system checks on the specified path from configuration cache inputs fingerprinting.
   +
   _Default is `null`._
   
   `org.gradle.configuration-cache.inputs.unsafe.ignore.in-serialization=(true,false)`::
   Used to ignore inputs in task graph serialization.
   +
   _Default is `false`._
   
   `org.gradle.configuration-cache.problems=(fail,warn)`::
   Configures how the configuration cache <<configuration_cache.adoc#config_cache:usage:ignore_problems, handles problems>>.
   +
   Set to `warn` to report problems without failing the build.
   +
   Set to `fail` to report problems and fail the build if there are any problems.
   +
   _Default is `fail`._
   
   `org.gradle.configuration-cache.max-problems=(# of problems)`::
   Configures the <<configuration_cache.adoc#config_cache:usage:max_problems, maximum number of configuration cache problems>> allowed as warnings until Gradle fails the build.
   +
   _Default is `512`._
   
   `org.gradle.configureondemand=(true,false)`::
   Enables incubating configuration-on-demand, where Gradle will attempt to configure only necessary projects.
   +
   _Default is `false`._
   
   `org.gradle.console=(auto,plain,rich,verbose)`::
   Customize <<command_line_interface.adoc#sec:command_line_logging,console output>> coloring or verbosity.
   +
   _Default depends on how Gradle is invoked._
   
   `org.gradle.continue=(true,false)`::
   If enabled, continue task execution after a task failure, else stop task execution after a task failure.
   +
   _Default is `false`._
   
   `org.gradle.continuous.quietperiod=(# of quiet period millis)`::
   When using <<command_line_interface.adoc#sec:continuous_build,continuous build>>, Gradle will wait for the quiet period to pass before triggering another build.
   Any additional changes within this quiet period restart the quiet period countdown.
   +
   _Default is `250` milliseconds._
   
   `org.gradle.daemon=(true,false)`::
   When set to `true` the <<gradle_daemon.adoc#gradle_daemon, Gradle Daemon>> is used to run the build.
   +
   _Default is `true`._
   
   `org.gradle.daemon.healthcheckinterval=(# of millis)`::
   Gradle Daemon health will be checked after a specified number of milliseconds.
   +
   _Default is `10000;` (10 secs)._
   
   `org.gradle.daemon.idletimeout=(# of idle millis)`::
   Gradle Daemon will terminate itself after a specified number of idle milliseconds.
   +
   _Default is `10800000` (3 hours)._
   
   `org.gradle.daemon.registry.base=(directory)`::
   Specify a Daemon registry path where the daemon registry file (addresses of active daemons) and daemon log files reside.
   +
   _Default is `.` (local directory)._
   
   `org.gradle.debug=(true,false)`::
   When set to `true`, Gradle will run the build with remote debugging enabled, listening on port 5005.
   Note that this is equivalent to adding `-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005` to the JVM command line and will suspend the virtual machine until a debugger is attached.
   +
   _Default is `false`._
   
   `org.gradle.debug.host=(host address)`::
   Specifies the host address to listen on or connect to when debug is enabled.
   In the server mode on Java 9 and above, passing `*` for the host will make the server listen on all network interfaces.
   +
   _Default is `null`; no host address is passed to JDWP (on Java 9 and above, the loopback address is used, while earlier versions listen on all interfaces)._
   
   `org.gradle.debug.port=(port number)`::
   Specifies the port number to listen on when debug is enabled.
   +
   _Default is `5005`._
   
   `org.gradle.debug.server=(true,false)`::
   If set to `true` and debugging is enabled, Gradle will run the build with the socket-attach mode of the debugger.
   Otherwise, the socket-listen mode is used.
   +
   _Default is `true`._
   
   `org.gradle.debug.suspend=(true,false)`::
   When set to `true` and debugging is enabled, the JVM running Gradle will suspend until a debugger is attached.
   +
   _Default is `true`._
   
   `org.gradle.dependency.verification=(strict,lenient,off)`::
   Configures the dependency verification mode where in `strict` mode verification fails as early as possible, in order to avoid the use of compromised dependencies during the build.
   +
   _Default is `strict`._
   
   `org.gradle.internal.instrumentation.agent=(true,false)`::
   Enables the instrumentation Java agent for the daemon.
   +
   _Default is `true`._
   
   `org.gradle.java.home=(path to JDK home)`::
   Specifies the Java home for the Gradle build process.
   The value can be set to either a `jdk` or `jre` location; however, depending on what your build does, using a JDK is safer.
   This does not affect the version of Java used to launch the <<#sec:gradle_environment_variables,Gradle client VM>>.
   +
   _Default is derived from your environment (`JAVA_HOME` or the path to `java`) if the setting is unspecified._
   
   `org.gradle.jvmargs=(JVM arguments)`::
   Specifies the JVM arguments used for the Gradle Daemon.
   The setting is particularly useful for <<config_gradle.adoc#sec:configuring_jvm_memory,configuring JVM memory settings>> for build performance.
   This does not affect the JVM settings for the Gradle client VM.
   +
   _Default is `-Xmx512m "-XX:MaxMetaspaceSize=384m"`._
   
   `org.gradle.logging.level=(quiet,warn,lifecycle,info,debug)`::
   When set to quiet, warn, info, or debug, Gradle will use this <<logging.adoc#sec:choosing_a_log_level,log level>>.
   The values are not case-sensitive.
   +
   _Default is `lifecycle` level._
   
   `org.gradle.logging.stacktrace=(internal,all,full)`::
   Specifies whether stacktraces should be displayed as part of the build result upon an exception. See the <<command_line_interface.adoc#sec:command_line_debugging, `--stacktrace command-line option` for additional information>>.
   +
   When set to `internal`, a stacktrace is present in the output only in case of internal exceptions.
   +
   When set to `all` or `full`, a stacktrace is present in the output for all exceptions and build failures.
   +
   Using `full` doesn't truncate the stacktrace, which leads to a much more verbose output.
   +
   _Default is `internal`._
   
   `org.gradle.parallel=(true,false)`::
   When configured, Gradle will fork up to `org.gradle.workers.max` JVMs to execute <<performance.adoc#parallel_execution,projects in parallel>>.
   +
   _Default is `false`._
   
   `org.gradle.priority=(low,normal)`::
   Specifies the <<command_line_interface.adoc#sec:command_line_performance,scheduling priority>> for the Gradle daemon and all processes launched by it.
   +
   _Default is `normal`._
   
   `org.gradle.projectcachedir=(directory)`::
   Specify the project-specific cache directory. Defaults to `.gradle` in the root project directory."
   +
   _Default is `.gradle`._
   
   `org.gradle.unsafe.isolated-projects=(true,false)`::
   Enables project isolation which enables configuration caching.
   +
   _Default is `false`._
   
   `org.gradle.vfs.verbose=(true,false)`::
   Configures verbose logging when <<file_system_watching.adoc#sec:daemon_watch_fs,watching the file system>>.
   +
   _Default is `false`._
   
   `org.gradle.vfs.watch=(true,false)`::
   Toggles <<file_system_watching.adoc#sec:daemon_watch_fs,watching the file system>>.
   When enabled, Gradle reuses information it collects about the file system between builds.
   +
   _Default is `true` on operating systems where Gradle supports this feature._
   
   `org.gradle.vfs.watch.debug=(true,false)`::
   Enables debug events emitted in `native-platform` to be shown. Events are only shown when `--debug` is enabled or when the daemon is between builds.
   +
   _Default is `false`._
   
   `org.gradle.warning.mode=(all,fail,summary,none)`::
   When set to `all`, `summary` or `none`, Gradle will use <<command_line_interface.adoc#sec:command_line_logging,different warning type display>>.
   +
   _Default is `summary`._
   
   `org.gradle.welcome=(never,once)`::
   Controls whether Gradle should print a welcome message.
   +
   If set to `never`, then the welcome message will be suppressed.
   +
   If set to `once`, then the message is printed once for each new version of Gradle.
   +
   _Default is `once`._
   
   `org.gradle.workers.max=(max # of worker processes)`::
   When configured, Gradle will use a maximum of the <<command_line_interface.adoc#sec:command_line_performance,given number of workers>>.
   +
   _Default is the number of CPU processors._
   
   The following examples demonstrate how to use Gradle properties.
   
   *Example 1:* Setting Gradle properties with a `gradle.properties` file:
   ====
   include::sample[dir="snippets/tutorial/gradleProperties/groovy",files="gradle.properties[tags=gradle-properties]"]
   ====
   
   *Example 2:* Reading Gradle properties at configuration time:
   ====
   include::sample[dir="snippets/tutorial/gradleProperties/kotlin",files="settings.gradle.kts[tags=gradle-properties];build.gradle.kts[tags=gradle-properties]"]
   include::sample[dir="snippets/tutorial/gradleProperties/groovy",files="settings.gradle[tags=gradle-properties];build.gradle[tags=gradle-properties]"]
   ====
   
   [.multi-language-text.lang-kotlin]
   The link:https://kotlinlang.org/docs/delegated-properties.html[Kotlin delegated properties] are part of the Gradle Kotlin DSL.
   You need to explicitly specify the type as `String`.
   If you need to branch depending on the presence of the property, you can also use `String?` and check for `null`.
   
   [.multi-language-text.lang-groovy]
   Note that if a Gradle property has a dot in its name, using the dynamic Groovy names is not possible.
   You have to use the API or the dynamic array notation instead.
   
   *Example 3:* Reading Gradle properties for consumption at execution time:
   ====
   include::sample[dir="snippets/tutorial/gradleProperties/kotlin",files="build.gradle.kts[tags=gradle-properties-task-inputs]"]
   include::sample[dir="snippets/tutorial/gradleProperties/groovy",files="build.gradle[tags=gradle-properties-task-inputs]"]
   ====
   
   *Example 4:* Setting Gradle properties from the command line:
   ====
   ----
   $ gradle -DgradlePropertiesProp=commandLineValue
   ----
   ====
   
   Note that <<init_scripts.adoc#init_scripts, initialization scripts>> can't read Gradle properties directly.
   The earliest Gradle properties can be read in initialization scripts is on `settingsEvaluated {}`:
   
   *Example 5:* Reading Gradle properties from initialization scripts:
   ====
   include::sample[dir="snippets/tutorial/gradleProperties/kotlin",files="init.gradle.kts[tags=gradle-properties]"]
   include::sample[dir="snippets/tutorial/gradleProperties/groovy",files="init.gradle[tags=gradle-properties]"]
   ====
   
   Properties declared in a `gradle.properties` file present in a subproject directory are only available to that project and its children.
   
   == 4. Environment variables
   
   The following environment variables are available for the `gradle` command.
   
   `GRADLE_HOME`::
   Installation directory for Gradle.
   +
   Can be used to specify a local Gradle version instead of using the wrapper.
   +
   You can add `GRADLE_HOME/bin` to your `PATH` for specific applications and use-cases (such as testing an early release for Gradle).
   
   `JAVA_OPTS`::
   Used to pass JVM options and custom settings to the JVM.
   
   `GRADLE_OPTS`::
   Specifies JVM arguments to use when starting the Gradle client VM.
   +
   The client VM only handles command line input/output, so it is rare that one would need to change its VM options.
   +
   The actual build is run by the Gradle daemon, which is not affected by this environment variable.
   
   `<<directory_layout.adoc#dir:gradle_user_home,GRADLE_USER_HOME>>`::
   Specifies the `GRADLE_USER_HOME` directory for Gradle to store its global configuration properties, initialization scripts, caches, log files and more.
   +
   Defaults to `USER_HOME/.gradle` if not set.
   
   `JAVA_HOME`::
   Specifies the JDK installation directory to use for the client VM.
   +
   This VM is also used for the daemon unless a different one is specified in a Gradle properties file with `org.gradle.java.home`.
   
   `GRADLE_LIBS_REPO_OVERRIDE`::
   Overrides for the default Gradle library repository.
   +
   Can be used to specify a default Gradle repository URL in `org.gradle.plugins.ide.internal.resolver`.
   +
   Useful override to specify an internally hosted repository in case your company uses a firewall/proxy.
   
   
   The following examples demonstrate how to use environment variables.
   
   *Example 1:* Reading environment variables at configuration time:
   ====
   include::sample[dir="snippets/tutorial/environmentVariables/kotlin",files="init.gradle.kts[];settings.gradle.kts[];build.gradle.kts[tags=configuration]"]
   include::sample[dir="snippets/tutorial/environmentVariables/groovy",files="init.gradle[];settings.gradle[];build.gradle[tags=configuration]"]
   ====
   
   *Example 2:* Reading environment variables for consumption at execution time:
   ====
   include::sample[dir="snippets/tutorial/environmentVariables/kotlin",files="build.gradle.kts[tags=execution]"]
   include::sample[dir="snippets/tutorial/environmentVariables/groovy",files="build.gradle[tags=execution]"]
   ====

/docs/userguide/authoring-builds/other/init_scripts.adoc
========================================================

.. code-block::

   = Initialization Scripts
   
   Gradle provides a powerful mechanism for customizing the build based on the current environment.
   
   This mechanism also supports tools that wish to integrate with Gradle.
   
   == Basic usage
   
   Initialization scripts (a.k.a. _init scripts_) are similar to other scripts in Gradle.
   These scripts, however, are run before the build starts.
   
   Here are several possible uses:
   
   * Set up enterprise-wide configuration, such as where to find custom plugins.
   * Set up properties based on the current environment, such as a developer's machine vs. a continuous integration server.
   * Supply personal information about the user required by the build, such as repository or database authentication credentials.
   * Define machine-specific details, such as where JDKs are installed.
   * Register build listeners. External tools that wish to listen to Gradle events might find this useful.
   * Register build loggers. You could customize how Gradle logs the events that it generates.
   
   One main <<sharing_build_logic_between_subprojects.adoc#sec:using_buildsrc,limitation of init scripts>> is that they cannot access classes in the `buildSrc` project.
   
   == Using an init script
   
   There are several ways to use an init script:
   
   * Specify a file on the command line. The command line option is `-I` or `--init-script` followed by the path to the script.
   +
   The command line option can appear more than once, each time adding another init script. The build will fail if any files specified on the command line do not exist.
   * Put a file called `init.gradle` (or `init.gradle.kts` for Kotlin) in the `__$<<directory_layout.adoc#dir:gradle_user_home,GRADLE_USER_HOME>>__/` directory.
   * Put a file that ends with `.gradle` (or `.init.gradle.kts` for Kotlin) in the `__$<<directory_layout.adoc#dir:gradle_user_home,GRADLE_USER_HOME>>__/init.d/` directory.
   * Put a file that ends with `.gradle` (or `.init.gradle.kts` for Kotlin) in the `$<<installation.adoc#sec:linux_macos_users_2,__GRADLE_HOME__>>/init.d/` directory, in the Gradle distribution.
   +
   This lets you package a custom Gradle distribution containing custom build logic and plugins. You can combine this with the <<gradle_wrapper.adoc#gradle_wrapper_reference,Gradle wrapper>> to make custom logic available to all builds in your enterprise.
   
   If more than one init script is found, they will all be executed in the order specified above.
   
   Scripts in a given directory are executed in alphabetical order.
   For example, a tool can specify an init script on the command line and another in the home directory for defining the environment.
   Both scripts will run when Gradle is executed.
   
   == Writing an init script
   
   Like a Gradle build script, an init script is a Groovy or Kotlin script.
   Each init script has a link:{groovyDslPath}#[Gradle] instance associated with it.
   Any property reference and method call in the init script will delegate to this `Gradle` instance.
   
   Each init script also implements the link:{groovyDslPath}#[Script] interface.
   
   [NOTE]
   ====
   When writing init scripts, pay attention to the scope of the reference you are trying to access.
   For example, properties loaded from `gradle.properties` are available on `Settings` or `Project` instances but not on the `Gradle` one.
   ====
   
   === Configuring projects from an init script
   
   You can use an init script to configure the projects in the build.
   This works similarly to configuring projects in a multi-project build.
   
   The following sample shows how to perform extra configuration from an init script _before_ the projects are evaluated:
   
   ====
   include::sample[dir="snippets/initScripts/configurationInjection/kotlin",files="build.gradle.kts[];init.gradle.kts[]"]
   include::sample[dir="snippets/initScripts/configurationInjection/groovy",files="build.gradle[];init.gradle[]"]
   ====
   
   This sample uses this feature to configure an additional repository to be used only for specific environments.
   
   ==== Output when applying the init script
   [source.multi-language-sample,kotlin]
   ----
   > gradle --init-script init.gradle.kts -q showRepos
   include::{snippetsPath}/initScripts/configurationInjection/tests-common/initScriptConfiguration.out[]
   ----
   [source.multi-language-sample,groovy]
   ----
   > gradle --init-script init.gradle -q showRepos
   include::{snippetsPath}/initScripts/configurationInjection/tests-common/initScriptConfiguration.out[]
   ----
   
   == External dependencies for the init script
   
   Init scripts can also declare dependencies with the `initscript()` method, passing in a closure that declares the init script classpath.
   
   Declaring external dependencies for an init script:
   
   ====
   include::sample[dir="snippets/initScripts/externalDependency/kotlin",files="init.gradle.kts[tags=declare-classpath]"]
   include::sample[dir="snippets/initScripts/externalDependency/groovy",files="init.gradle[tags=declare-classpath]"]
   ====
   
   The closure passed to the `initscript()` method configures a link:{javadocPath}#[ScriptHandler] instance.
   You declare the init script classpath by adding dependencies to the `classpath` configuration.
   
   This is the same way you declare, for example, the Java compilation classpath.
   You can use any of the dependency types described in <<declaring_dependencies.adoc#declaring-dependencies,Declaring Dependencies>>, except project dependencies.
   
   Having declared the init script classpath, you can use the classes in your init script as you would any other classes on the classpath.
   The following example adds to the previous example and uses classes from the init script classpath.
   
   An init script with external dependencies:
   
   ====
   include::sample[dir="snippets/initScripts/externalDependency/kotlin",files="init.gradle.kts[tags=all];build.gradle.kts[]"]
   include::sample[dir="snippets/initScripts/externalDependency/groovy",files="init.gradle[tags=all];build.gradle[]"]
   ====
   
   Output when applying the init script:
   
   [source.multi-language-sample,kotlin]
   ----
   > gradle --init-script init.gradle.kts -q doNothing
   include::{snippetsPath}/initScripts/externalDependency/tests-common/externalInitDependency.out[]
   ----
   [source.multi-language-sample,groovy]
   ----
   > gradle --init-script init.gradle -q doNothing
   include::{snippetsPath}/initScripts/externalDependency/tests-common/externalInitDependency.out[]
   ----
   
   == Init script plugins
   
   Like a Gradle build script or a Gradle settings file, plugins can be applied to init scripts.
   
   Using plugins in init scripts:
   
   ====
   include::sample[dir="snippets/initScripts/plugins/kotlin",files="init.gradle.kts[tags=init-script-plugin];build.gradle.kts[tag=show-repos-task]"]
   include::sample[dir="snippets/initScripts/plugins/groovy",files="init.gradle[tags=init-script-plugin];build.gradle[tag=show-repos-task]"]
   ====
   
   Output when applying the init script:
   
   [source.multi-language-sample,kotlin]
   ----
   > gradle --init-script init.gradle.kts -q showRepositories
   include::{snippetsPath}/initScripts/plugins/tests-common/usePluginsInInitScripts.out[]
   ----
   [source.multi-language-sample,groovy]
   ----
   > gradle --init-script init.gradle -q showRepositories
   include::{snippetsPath}/initScripts/plugins/tests-common/usePluginsInInitScripts.out[]
   ----
   
   The plugin in the init script ensures that only a specified repository is used when running the build.
   
   When applying plugins within the init script, Gradle instantiates the plugin and calls the plugin instance's link:{javadocPath}#[Plugin.apply(T)] method.
   
   The `gradle` object is passed as a parameter, which can be used to configure all aspects of a build. Of course, the applied plugin can be resolved as an external dependency as described in <<#sec:custom_classpath,External dependencies for the init script>>

/docs/userguide/authoring-builds/other/custom_gradle_types.adoc
===============================================================

.. code-block::

   = Developing Custom Gradle Types
   
   There are several different kinds of "add-ons" to Gradle that you can develop, such as <<custom_plugins.adoc#custom_plugins,plugins>>, <<custom_tasks.adoc#custom_tasks,tasks>>,
   <<implementing_gradle_plugins_binary.adoc#capturing_user_input_to_configure_plugin_runtime_behavior,project extensions>> or <<artifact_transforms.adoc#sec:implementing-artifact-transforms,artifact transforms>>,
   that are all implemented as classes and other types that can run on the JVM.
   This chapter discusses some of the features and concepts that are common to these types.
   You can use these features to help implement custom Gradle types and provide a consistent DSL for your users.
   
   This chapter applies to the following types:
   
   - Plugin types.
   - Task types.
   - Artifact transform parameters types.
   - Worker API work action parameters types.
   - Extension objects created using `ExtensionContainer.create()`, for example a project extension registered by a plugin.
   - Objects created using `ObjectFactory.newInstance()`.
   - Objects created for a managed nested property.
   - Elements of a `NamedDomainObjectContainer`.
   
   == Configuration using properties
   
   The custom Gradle types that you implement often hold some configuration that you want to make available to build scripts and other plugins.
   For example, a download task may have configuration that specifies the URL to download from and the file system location to write the result to.
   
   === Managed properties
   
   Gradle provides its own _managed properties_ concept that allows you to declare each property as an abstract getter (Java, Groovy) or an abstract property (Kotlin).
   Gradle then provides the implementation for such a property automatically.
   It is called a _managed property_, as Gradle takes care of managing the state of the property.
   A property may be _mutable_, meaning that it has both a `get()` method and `set()` method, or _read-only_, meaning that it has only a `get()` method.
   _Read-only_ properties are also called _providers_.
   
   ==== Mutable managed properties
   
   To declare a mutable managed property, add an abstract getter method of type `Property<T>` - where `T` can be any serializable type or a fully Gradle <<#managed_types,managed type>>.
   (See the list further down for more specific property types.)
   The property must not have any setter methods.
   Here is an example of a task type with an `uri` property of type `URI`:
   
   .Mutable managed property
   ====
   [source.multi-language-sample,java]
   .Download.java
   ----
   include::{snippetsPath}/plugins/mutableManagedProperty/groovy/buildSrc/src/main/java/Download.java[tags=download]
   ----
   ====
   
   Note that for a property to be considered a mutable managed property, the property's getter methods must be `abstract` and have `public` or `protected` visibility.
   The property type must be one of the following:
   
   - `Property<T>`
   - `RegularFileProperty`
   - `DirectoryProperty`
   - `ListProperty<T>`
   - `SetProperty<T>`
   - `MapProperty<K, V>`
   - `ConfigurableFileCollection`
   - `ConfigurableFileTree`
   - `DomainObjectSet<T>`
   - `NamedDomainObjectContainer<T>`
   - `ExtensiblePolymorphicDomainObjectContainer<T>`
   - `DependencyCollector`
   
   Gradle creates values for managed properties in the same way as link:{javadocPath}#[ObjectFactory].
   
   ==== Read-only managed properties
   
   To declare a read-only managed property, also called provider, add a getter method of type `Provider<T>`.
   The method implementation then needs to derive the value, for example from other properties.
   
   Here is an example of a task type with a `uri` provider that is derived from a `location` property:
   
   .Read-only managed property
   ====
   [source.multi-language-sample,java]
   .Download.java
   ----
   include::{snippetsPath}/plugins/readOnlyManagedProperty/groovy/buildSrc/src/main/java/Download.java[tags=download]
   ----
   ====
   
   ==== Read-only managed nested properties
   
   To declare a read-only managed nested property, add an abstract getter method for the property to the type annotated with `@link:{javadocPath}#[Nested]`.
   The property should not have any setter methods.
   Gradle provides an implementation for the getter method, and also creates a value for the property.
   The nested type is also treated as a custom type, and can use the features discussed in this chapter.
   
   This pattern is useful when a custom type has a nested complex type which has the same lifecycle.
   If the lifecycle is different, consider using `Property<NestedType>` instead.
   
   Here is an example of a task type with a `resource` property. The `Resource` type is also a custom Gradle type and defines some managed properties:
   
   .Read-only managed nested property
   ====
   [source.multi-language-sample,java]
   .Download.java
   ----
   include::{snippetsPath}/plugins/readOnlyNestedProperty/groovy/buildSrc/src/main/java/Download.java[tags=download]
   include::{snippetsPath}/plugins/readOnlyNestedProperty/groovy/buildSrc/src/main/java/Resource.java[tags=resource]
   ----
   ====
   
   Note that for a property to be considered a read-only managed nested property, the property's getter methods must be `abstract` and have `public` or `protected` visibility.
   The property must not have any setter methods.
   In addition, the property getter must be annotated with `@link:{javadocPath}#[Nested]`.
   
   ==== Read-only managed "name" property
   
   If the type contains an abstract property called "name" of type `String`, Gradle provides an implementation for the getter
   method, and extends each constructor with a "name" parameter, which comes before all other constructor parameters. If the
   type is an interface, Gradle will provide a constructor with a single "name" parameter and `@Inject` semantics.
   
   You can have your type implement or extend the link:{javadocPath}#[Named] interface, which defines
   such a read-only "name" property.
   
   === Managed types
   
   A _managed type_ is an abstract class or interface with no fields and whose properties are all managed.
   That is, it is a type whose state is entirely managed by Gradle.
   
   A _named managed type_ is a managed type that additionally has an abstract property "name" of type `String`. Named
   managed types are especially useful as the element type of link:{javadocPath}#[NamedDomainObjectContainer] (see below).
   
   .Managed type defined as interface
   ====
   [source.multi-language-sample,java]
   .Resource.java
   ----
   include::{snippetsPath}/plugins/readOnlyNestedProperty/groovy/buildSrc/src/main/java/Resource.java[tags=resource]
   ----
   ====
   
   === Java bean properties.
   
   Sometimes you may see properties implemented in the Java bean property style.
   That is, they do not use a `Property<T>` or `Provider<T>` types but are instead implemented with concrete setter and getter methods (or corresponding conveniences in Groovy or Kotlin).
   This style of property definition is legacy in Gradle and is discouraged.
   Properties in Gradle's core plugins that are still of this style will be migrated to managed properties in future versions.
   
   == DSL support and extensibility
   
   When Gradle creates an instance of a custom type, it _decorates_ the instance to mix-in DSL and extensibility support.
   
   Each decorated instance implements link:{javadocPath}#[ExtensionAware], and so can have extension
   objects attached to it.
   
   Note that plugins and the elements of containers created using link:{javadocPath}#[Project.container()] are currently not decorated, due to backwards compatibility issues.
   
   == Service injection
   
   Gradle provides a number of useful services that can be used by custom Gradle types.
   For example, the link:{javadocPath}#[WorkerExecutor] service can be used by a task to run work in parallel, as seen in the <<worker_api.adoc#worker_api,worker API>> section.
   The services are made available through _service injection_.
   
   === Available services
   
   The following services are available for injection:
   
   - link:{javadocPath}#[ObjectFactory] - Allows model objects to be created. See <<#nested_objects>> for more details.
   - link:{groovyDslPath}#[ProjectLayout] - Provides access to key project locations. See <<lazy_configuration.adoc#working_with_files_in_lazy_properties,lazy configuration>> for more details. This service is unavailable in Worker API actions.
   - link:{groovyDslPath}#[BuildLayout] - Provides access to important locations for a Gradle build. This service is only available for injection in settings plugins.
   - link:{groovyDslPath}#[ProviderFactory] - Creates `Provider` instances. See <<lazy_configuration.adoc#lazy_configuration,lazy configuration>> for more details.
   - link:{javadocPath}#[WorkerExecutor] - Allows a task to run work in parallel. See <<worker_api.adoc#worker_api,the worker API>> for more details.
   - link:{javadocPath}#[FileSystemOperations] - Allows a task to run operations on the filesystem such as deleting files, copying files or syncing directories.
   - link:{javadocPath}#[ArchiveOperations] - Allows a task to run operations on archive files such as ZIP or TAR files.
   - link:{javadocPath}#[ExecOperations] - Allows a task to run external processes with dedicated support for running external `java` programs.
   - link:{javadocPath}#[ToolingModelBuilderRegistry] - Allows a plugin to registers a Gradle tooling API model.
   
   Out of the above, `ProjectLayout` and `WorkerExecutor` services are only available for injection in project plugins.
   
   === Constructor injection
   
   There are 2 ways that an object can receive the services that it needs. The first option is to add the service as a parameter of the class constructor.
   The constructor must be annotated with the `javax.inject.Inject` annotation.
   Gradle uses the declared type of each constructor parameter to determine the services that the object requires.
   The order of the constructor parameters and their names are not significant and can be whatever you like.
   
   Here is an example that shows a task type that receives an `ObjectFactory` via its constructor:
   
   .Constructor service injection
   ====
   [source.multi-language-sample,java]
   .Download.java
   ----
   include::{snippetsPath}/plugins/constructorServiceInjection/groovy/buildSrc/src/main/java/Download.java[tags=download]
   ----
   ====
   
   === Property injection
   
   Alternatively, a service can be injected by adding a property getter method annotated with the `javax.inject.Inject` annotation to the class.
   This can be useful, for example, when you cannot change the constructor of the class due to backwards compatibility constraints.
   This pattern also allows Gradle to defer creation of the service until the getter method is called, rather than when the instance is created. This can help with performance.
   Gradle uses the declared return type of the getter method to determine the service to make available. The name of the property is not significant and can be whatever you like.
   
   The property getter method must be `public` or `protected`. The method can be `abstract` or, in cases where this isn't possible, can have a dummy method body.
   The method body is discarded.
   
   Here is an example that shows a task type that receives a two services via property getter methods:
   
   .Property service injection
   ====
   [source.multi-language-sample,java]
   .Download.java
   ----
   include::{snippetsPath}/plugins/propertyServiceInjection/groovy/buildSrc/src/main/java/Download.java[tags=download]
   ----
   ====
   
   == Creating objects explicitly
   
   NOTE: Prefer letting Gradle create objects automatically by using <<#managed_properties,managed properties>>.
   
   A custom Gradle type can use the link:{javadocPath}#[ObjectFactory] service to create instances of Gradle types to use for its property values.
   These instances can make use of the features discussed in this chapter, allowing you to create objects and a nested DSL.
   
   In the following example, a project extension receives an `ObjectFactory` instance through its constructor.
   The constructor uses this to create a nested `Resource` object (also a custom Gradle type) and makes this object available through the `resource` property.
   
   .Nested object creation
   ====
   [source.multi-language-sample,java]
   .DownloadExtension.java
   ----
   include::{snippetsPath}/plugins/nestedObjects/groovy/buildSrc/src/main/java/DownloadExtension.java[tags=download-extension]
   include::{snippetsPath}/plugins/nestedObjects/groovy/buildSrc/src/main/java/Resource.java[tags=resource]
   ----
   ====
   
   == Collection types
   
   Gradle provides types for maintaining collections of objects, intended to work well to extends Gradle's DSLs and provide useful features such as lazy configuration.
   
   === NamedDomainObjectContainer
   
   A link:{javadocPath}#[NamedDomainObjectContainer] manages a set of objects, where each element has a name associated with it.
   The container takes care of creating and configuring the elements, and provides a DSL that build scripts can use to define and configure elements.
   It is intended to hold objects which are themselves configurable, for example a set of custom Gradle objects.
   
   Gradle uses `NamedDomainObjectContainer` type extensively throughout the API.
   For example, the `project.tasks` object used to manage the tasks of a project is a `NamedDomainObjectContainer<Task>`.
   
   You can create a container instance using the link:{javadocPath}#[ObjectFactory] service, which provides the link:{javadocPath}#[ObjectFactory.domainObjectContainer()] method.
   This is also available using the link:{javadocPath}#[Project.container()] method, however in a custom Gradle type it's
   generally better to use the injected `ObjectFactory` service instead of passing around a `Project` instance.
   
   You can also create a container instance using a <<read_only_managed_properties,read-only managed property>>, described above.
   
   In order to use a type with any of the `domainObjectContainer()` methods, it must either
   
   - be a <<managed_types,named managed type>>; or
   - expose a property named "`name`" as the unique, and constant, name for the object. The `domainObjectContainer(Class)`
     variant of the method creates new instances by calling the constructor of the class that takes a string argument, which is the desired name of the object.
   
   Objects created this way are treated as custom Gradle types, and so can make use of the features discussed in this chapter, for example service injection or
   managed properties.
   
   See the above link for `domainObjectContainer()` method variants that allow custom instantiation strategies.
   
   .Managing a collection of objects
   ====
   [source.multi-language-sample,java]
   .DownloadExtension.java
   ----
   include::{snippetsPath}/plugins/namedDomainObjectContainer/groovy/buildSrc/src/main/java/DownloadExtension.java[tags=download-extension]
   include::{snippetsPath}/plugins/namedDomainObjectContainer/groovy/buildSrc/src/main/java/Resource.java[tags=resource]
   ----
   ====
   
   For each container property, Gradle automatically adds a block to the Groovy and Kotlin DSL that you can use to configure the
   contents of the container:
   
   .Configure block
   ====
   [source.multi-language-sample,kotlin]
   .build.gradle.kts
   ----
   include::{snippetsPath}/plugins/namedDomainObjectContainer/kotlin/build.gradle.kts[]
   ----
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/plugins/namedDomainObjectContainer/groovy/build.gradle[]
   ----
   ====
   
   === ExtensiblePolymorphicDomainObjectContainer
   
   An link:{javadocPath}#[ExtensiblePolymorphicDomainObjectContainer] is a `NamedDomainObjectContainer` that allows you to
   define instantiation strategies for different types of objects.
   
   You can create an instance using the link:{javadocPath}#[ObjectFactory.polymorphicDomainObjectContainer()] method.
   
   === NamedDomainObjectSet
   
   A link:{javadocPath}#[NamedDomainObjectSet] holds a set of configurable objects, where each element has a name associated with it.
   This is similar to `NamedDomainObjectContainer`, however a `NamedDomainObjectSet` doesn't manage the objects in the collection. They need to be created and added manually.
   
   You can create an instance using the link:{javadocPath}#[ObjectFactory.namedDomainObjectSet()] method.
   
   === NamedDomainObjectList
   
   A link:{javadocPath}#[NamedDomainObjectList] holds a list of configurable objects, where each element has a name associated with it.
   This is similar to `NamedDomainObjectContainer`, however a `NamedDomainObjectList` doesn't manage the objects in the collection. They need to be created and added manually.
   
   You can create an instance using the link:{javadocPath}#[ObjectFactory.namedDomainObjectList()] method.
   
   === DomainObjectSet
   
   A link:{javadocPath}#[DomainObjectSet] simply holds a set of configurable objects.
   Compared to `NamedDomainObjectContainer`, a `DomainObjectSet` doesn't manage the objects in the collection. They need to be created and added manually.
   
   You can create an instance using the link:{javadocPath}#[ObjectFactory.domainObjectSet()] method.

/docs/userguide/authoring-builds/other/build_services.adoc
==========================================================

.. code-block::

   = Shared Build Services
   
   Sometimes, it is useful for several tasks to share some state or resource. For example, tasks might share a cache of pre-computed values in order to do their work faster.
   Or tasks might do their work using a web service or database instance.
   
   Gradle allows you to declare _build services_ to represent this state. A build service is simply an object that holds the state for tasks to use.
   Gradle takes care of the service lifecycle, and will create the service instance only when it is required and clean it up once it is no longer required.
   Gradle can also optionally take care of coordinating access to the build service, so that no more than a specified number of tasks can use the service concurrently.
   
   == Implementing a build service
   
   To implement a build service, create an abstract class that implements link:{javadocPath}#[BuildService].  Define methods on this type
   that you'd like tasks to use.
   A build service implementation is treated as a <<custom_gradle_types.adoc#custom_gradle_types,custom Gradle type>> and can use any of the features available to custom Gradle types.
   
   A build service can optionally take parameters, which Gradle injects into the service instance when creating it.
   To provide parameters, you define an abstract class (or interface) that
   holds the parameters.
   The parameters type must implement (or extend) link:{javadocPath}#[BuildServiceParameters].
   The service implementation can access the parameters using `this.getParameters()`.
   The parameters type is also a <<custom_gradle_types.adoc#custom_gradle_types,custom Gradle type>>.
   
   When the build service does not require any parameters, you can use link:{javadocPath}#[BuildServiceParameters.None] as the parameters type.
   
   A build service implementation can also optionally implement `AutoCloseable`, in which case Gradle will call the build service instance's `close()` method when it discards the service instance.
   This happens some time between completion of the last task that uses the build service and the end of the build.
   
   Here is an example of a service that takes parameters and is closeable:
   
   .Implementing a build service
   ====
   [source.multi-language-sample,java]
   .WebServer.java
   ----
   include::{snippetsPath}/plugins/buildService/groovy/buildSrc/src/main/java/WebServer.java[]
   ----
   ====
   
   Note that you should *not* implement the link:{javadocPath}#[BuildService.getParameters()] method, as Gradle will provide an implementation of this.
   
   A build service implementation must be thread-safe, as it will potentially be used by multiple tasks concurrently.
   
   == Using a build service from a task
   
   To use a build service from a task, you need to:
   
   1. Add a property to the task of type `Property<MyServiceType>`.
   2. Either annotate the property with `@Internal` or `@ServiceReference` (since 8.0).
   3. Assign a shared build service provider to the property (optional, when using `@ServiceReference(<serviceName>)`).
   4. Declare the association between the task and the service so Gradle can properly honor the build service lifecycle and its usage constraints (also optional, when using `@ServiceReference`).
   
   Note that using a service with any other annotation is currently not supported. For example, it is currently not possible
   to mark a service as an input to a task.
   
   === Annotating a shared build service property with `@Internal`
   
   When you annotate a shared build service property with `@Internal`, you need to do two more things:
   
   1. Explicitly assign a build service provider obtained when registering the service with link:{javadocPath}#[BuildServiceRegistry.registerIfAbsent()] to the property.
   2. Explicitly declare the association between the task and the service via the link:{javadocPath}#[Task.usesService].
   
   Here is an example of a task that consumes the previous service via a property annotated with `@Internal`:
   
   .Using a build service with explicit assignment
   ====
   [source.multi-language-sample,java]
   .Download.java
   ----
   include::{snippetsPath}/plugins/buildService/groovy/buildSrc/src/main/java/Download.java[]
   ----
   ====
   
   === Annotating a shared build service property with `@ServiceReference`
   
   NOTE: The `@ServiceReference` annotation is an <<feature_lifecycle.adoc#feature_lifecycle,incubating>> API and is subject to changing in a future release.
   
   Otherwise, when you annotate a shared build service property with `@ServiceReference`,
   there is no need to explicitly declare the association between the task and the service;
   also, if you provide a service name to the annotation, and a shared build service is registered with that name,
   it will be automatically assigned to the property when the task is created.
   
   Here is an example of a task that consumes the previous service via a property annotated with `@ServiceReference`:
   
   .Using a build service with automatic assignment
   ====
   [source.multi-language-sample,java]
   .Download.java
   ----
   include::{snippetsPath}/plugins/buildServiceUsingServiceReference/groovy/buildSrc/src/main/java/Download.java[]
   ----
   ====
   
   == Registering a build service and connecting it to tasks
   
   To create a build service, you register the service instance using the link:{javadocPath}#[BuildServiceRegistry.registerIfAbsent()] method.
   Registering the service does not create the service instance. This happens on demand when a task first uses the service. If no task uses the service during a build, the service instance will not be created.
   
   Currently, build services are scoped to a build, rather than to a project, and these services are available to be shared by the tasks of all projects.
   You can access the registry of shared build services via `Project.getGradle().getSharedServices()`.
   
   Here is an example of a plugin that registers the previous service when the task property consuming the service is annotated with `@Internal`:
   
   .Build service registration when task property is annotated with `@Internal`
   ====
   [source.multi-language-sample,java]
   .DownloadPlugin.java
   ----
   include::{snippetsPath}/plugins/buildService/groovy/buildSrc/src/main/java/DownloadPlugin.java[]
   ----
   ====
   
   The plugin registers the service and receives a `Provider<WebService>` back. This provider can be connected to task properties to pass the service to the task.
   Note that for a task property annotated with `@Internal`, the task property needs to (1) be explicitly assigned with the provider obtained during registation,
   and (2) you must tell Gradle the task uses the service via link:{javadocPath}#[Task.usesService].
   
   Compare that to when the task property consuming the service is annotated with `@ServiceReference`:
   
   .Build service registration when task property is annotated with `@ServiceReference`
   ====
   [source.multi-language-sample,java]
   .DownloadPlugin.java
   ----
   include::{snippetsPath}/plugins/buildServiceUsingServiceReference/groovy/buildSrc/src/main/java/DownloadPlugin.java[]
   ----
   ====
   
   As you can see, there is no need to assign the build service provider to the task, nor to declare explicitly that the task uses the service.
   
   === Using shared build services from configuration actions
   
   Generally, build services are intended to be used by tasks, as they usually represent some state that is potentially expensive to create, and you should avoid using
   them at configuration time. However, sometimes it can make sense to use the service at configuration time. This is possible, simply call `get()` on the provider.
   
   == Other ways of using a build service
   
   In addition to using a build service from a task, you can use a build service from a <<worker_api.adoc#converting_to_worker_api,worker API action>>, an <<artifact_transforms.adoc#sec:implementing-artifact-transforms,artifact transform>> or another build service.
   To do this, pass the build service `Provider` as a parameter of the consuming action or service, in the same way you pass other parameters to the action or service.
   
   For example, to pass a `MyServiceType` service to worker API action, you might add a property of type `Property<MyServiceType>` to the action's parameters object and
   then connect the `Provider<MyServiceType>` that you receive when registering the service to this property.
   
   .Build service usage from worker action
   ====
   [source.multi-language-sample,java]
   .Download.java
   ----
   include::{snippetsPath}/plugins/buildServiceFromWorkAction/groovy/buildSrc/src/main/java/Download.java[]
   ----
   ====
   
   
   Currently, it is not possible to use a build service with a worker API action that uses ClassLoader or process isolation modes.
   
   == Concurrent access to the service
   
   You can constrain concurrent execution when you register the service, by using the `Property` object returned from link:{javadocPath}#[BuildServiceSpec.getMaxParallelUsages()].
   When this property has no value, which is the default, Gradle does not constrain access to the service. When this property has a value > 0, Gradle will allow no more than the specified number of tasks to use the service concurrently.
   
   IMPORTANT: When the consuming task property is annotated with `@Internal`, for the constraint to take effect, the build service *must* be registered with the consuming task via
   link:{groovyDslPath}#[Task.usesService(Provider<? extends BuildService<?>>)].
   This is not necessary if, instead, the consuming property is annotated with `@ServiceReference`.
   
   == Receiving information about task execution
   
   A build service can be used to receive events as tasks are executed. To do this, create and register a build service that implements link:{javadocPath}#[OperationCompletionListener]:
   
   .Build service implementing `OperationCompletionListener`
   ====
   [source.multi-language-sample,java]
   .TaskEventsService.java
   ----
   include::{snippetsPath}/plugins/buildServiceListener/groovy/buildSrc/src/main/java/TaskEventsService.java[tags=build-service]
   ----
   ====
   <1> Implement the `OperationCompletionListener` interface in addition to the `BuildService` interface.
   <2> Check if the finish event is a link:{javadocPath}#[TaskFinishEvent].
   
   Then, in the plugin you can use the methods on the link:{javadocPath}#[BuildEventsListenerRegistry] service to start receiving events:
   
   .Registering BuildService in the `BuildEventsListenerRegistry`
   ====
   [source.multi-language-sample,java]
   .TaskEventsPlugin.java
   ----
   include::{snippetsPath}/plugins/buildServiceListener/groovy/buildSrc/src/main/java/TaskEventsPlugin.java[]
   ----
   ====
   <1> Use <<custom_gradle_types.adoc#service_injection,service injection>> to obtain an instance of the `BuildEventsListenerRegistry`.
   <2> Register the build service as usual.
   <3> Use the service `Provider` to subscribe the build service to build events.

/docs/userguide/authoring-builds/other/dataflow_actions.adoc
============================================================

.. code-block::

   = Dataflow Actions
   
   NOTE: The dataflow actions support is an <<feature_lifecycle.adoc#feature_lifecycle,incubating>> feature, and the details described here may change.
   
   A preferred way of executing work in a Gradle build is using a task.
   However, there are some kinds of work that do not fit tasks well, for example, custom handling of the build failure.
   What if you want to play a cheerful sound when the build succeeds and a sad one when it fails?
   This work piece has to process the task execution result, so it cannot be a task itself.
   
   The dataflow actions API provides a way to schedule such kind of work.
   A dataflow action is a parameterized isolated piece of work that becomes eligible for execution as soon as all of its input parameters become available.
   
   == Implementing a dataflow action
   
   The first step is to implement the action itself.
   To do that you create a class implementing link:{javadocPath}#[FlowAction] interface.
   The `execute` method must be implemented because this is where the work happens.
   An action implementation is treated as a <<custom_gradle_types.adoc#custom_gradle_types,custom Gradle type>> and can use any of the features available to custom Gradle types.
   In particular, some Gradle services can be injected into the implementation.
   
   A dataflow action may accept parameters.
   To provide parameters, you define an abstract class (or interface) to hold the parameters.
   The parameters type must implement (or extend) link:{javadocPath}#[FlowParameters].
   The action implementation gets the parameters as an argument of the `execute` method.
   The parameters type is also a <<custom_gradle_types.adoc#custom_gradle_types,custom Gradle type>>.
   
   When the action requires no parameters, you can use link:{javadocPath}#[FlowParameters.None] as the parameters type.
   
   Here is an example of a dataflow action that takes a shared build service and a file path as parameters.
   ====
   [source.multi-language-sample,java]
   .SoundPlay.java
   ----
   include::{snippetsPath}/dataflowActions/playSound/groovy/plugin/src/main/java/org/gradle/sample/sound/SoundPlay.java[]
   ----
   ====
   <1> Parameters in the parameter type must be annotated. If a parameter is annotated with link:{javadocPath}#[`@ServiceReference`] then a suitable shared build service implementation is automatically assigned to the parameter when the action is created, according to the <<build_services.adoc#sec:service_references,usual rules>>.
   <2> All other parameters must be annotated with link:{javadocPath}#[`@Input`].
   
   == Lifecycle event providers
   
   Besides the usual value providers, Gradle provides dedicated providers for build lifecycle events, like build completion.
   These providers are intended for dataflow actions and provide additional ordering guarantees when used as inputs.
   The ordering also applies if you derive a provider from the event provider by, for example, calling `map` or `flatMap`.
   You can obtain these providers from the link:{javadocPath}#[FlowProviders] class.
   
   WARNING: If you're not using a lifecycle event provider as an input to the dataflow action, then the exact timing when the action is executed is not defined and may change in the next version of Gradle.
   
   
   == Supplying the action for execution
   
   You should not create `FlowAction` objects manually.
   Instead, you request to execute them in the appropriate scope of link:{javadocPath}#[`FlowScope`].
   When doing that, you can configure the parameters for task to use.
   
   ====
   [source.multi-language-sample,java]
   .SoundFeedbackPlugin.java
   ----
   include::{snippetsPath}/dataflowActions/playSound/groovy/plugin/src/main/java/org/gradle/sample/sound/SoundFeedbackPlugin.java[tag=flow-action]
   ----
   ====
   <1> Use service injection to obtain `FlowScope` and `FlowProviders` instances. They are available for project and settings plugins.
   <2> Use an appropriate scope to run your actions. As the name suggests, actions in the `always` scope are executed every time the build runs.
   <3> Specify the class that implements the action.
   <4> Use the spec argument to configure the action parameters.
   <5> A lifecycle event provider can be mapped into something else while preserving the action ordering.
   
   As a result, when you run the build, and it completes successfully, the action will play the "tada" sound. If the build fails at configuration or execution time, then you'll hear "sad-trombone" -- assuming, of course, that build configuration proceeds far enough for the action to be registered.

/docs/userguide/authoring-builds/other/test_kit.adoc
====================================================

.. code-block::

   = Testing Build Logic with TestKit
   
   The Gradle TestKit (a.k.a. just TestKit) is a library that aids in testing Gradle plugins and build logic generally. At this time, it is focused on _functional_ testing. That is, testing build logic by exercising it as part of a programmatically executed build. Over time, the TestKit will likely expand to facilitate other kinds of tests.
   
   == Usage
   
   To use the TestKit, include the following in your plugin's build:
   
   .Declaring the TestKit dependency
   ====
   include::sample[dir="snippets/testKit/junitQuickstart/kotlin",files="build.gradle.kts[tags=declare-gradle-testkit-dependency]"]
   include::sample[dir="snippets/testKit/junitQuickstart/groovy",files="build.gradle[tags=declare-gradle-testkit-dependency]"]
   ====
   
   The `gradleTestKit()` encompasses the classes of the TestKit, as well as the <<third_party_integration.adoc#embedding,Gradle Tooling API client>>. It does not include a version of https://junit.org[JUnit], https://testng.org[TestNG], or any other test execution framework. Such a dependency must be explicitly declared.
   
   .Declaring the JUnit dependency
   ====
   include::sample[dir="snippets/testKit/junitQuickstart/kotlin",files="build.gradle.kts[tags=declare-junit-dependency]"]
   include::sample[dir="snippets/testKit/junitQuickstart/groovy",files="build.gradle[tags=declare-junit-dependency]"]
   ====
   
   == Functional testing with the Gradle runner
   
   The link:{javadocPath}#[GradleRunner] facilitates programmatically executing Gradle builds, and inspecting the result.
   
   A contrived build can be created (e.g. programmatically, or from a template) that exercises the 랇ogic under test. The build can then be executed, potentially in a variety of ways (e.g. different combinations of tasks and arguments). The correctness of the logic can then be verified by asserting the following, potentially in combination:
   
   * The build's output;
   * The build's logging (i.e. console output);
   * The set of tasks executed by the build and their results (e.g. FAILED, UP-TO-DATE etc.).
   
   After creating and configuring a runner instance, the build can be executed via the link:{javadocPath}#[GradleRunner.build()] or link:{javadocPath}#[GradleRunner.buildAndFail()] methods depending on the anticipated outcome.
   
   The following demonstrates the usage of the Gradle runner in a Java JUnit test:
   
   === Example: Using GradleRunner with Java and JUnit
   
   [source,java,indent=0]
   .BuildLogicFunctionalTest.java
   ----
   include::{snippetsPath}/testKit/junitQuickstart/groovy/src/test/java/org/gradle/sample/BuildLogicFunctionalTest.java[tag=functional-test-junit]
   ----
   
   Any test execution framework can be used.
   
   As Gradle build scripts can also be written in the Groovy programming language, it is often a productive choice to write Gradle functional tests in Groovy. Furthermore, it is recommended to use the (Groovy based) https://code.google.com/p/spock/[Spock test execution framework] as it offers many compelling features over the use of JUnit.
   
   The following demonstrates the usage of the Gradle runner in a Groovy Spock test:
   
   === Example: Using GradleRunner with Groovy and Spock
   
   [source,groovy,indent=0]
   .BuildLogicFunctionalTest.groovy
   ----
   include::{snippetsPath}/testKit/spockQuickstart/groovy/src/test/groovy/org/gradle/sample/BuildLogicFunctionalTest.groovy[tag=functional-test-spock]
   ----
   
   It is a common practice to implement any custom build logic (like plugins and task types) that is more complex in nature as external classes in a standalone project. The main driver behind this approach is bundle the compiled code into a JAR file, publish it to a binary repository and reuse it across various projects.
   
   == Getting the plugin-under-test into the test build
   
   The GradleRunner uses the <<third_party_integration.adoc#embedding,Tooling API>> to execute builds. An implication of this is that the builds are executed in a separate process (i.e. not the same process executing the tests). Therefore, the test build does not share the same classpath or classloaders as the test process and the code under test is not implicitly available to the test build.
   
   [NOTE]
   ====
   GradleRunner supports the same range of Gradle versions as the Tooling API.
   The supported versions are defined in the <<third_party_integration.adoc#sec:embedding_compatibility,compatibility matrix>>.
   
   Builds with older Gradle versions _may_ still work but there are no guarantees.
   ====
   
   Starting with version 2.13, Gradle provides a conventional mechanism to inject the code under test into the test build.
   
   === Automatic injection with the Java Gradle Plugin Development plugin
   
   The <<java_gradle_plugin.adoc#java_gradle_plugin,Java Gradle Plugin development plugin>> can be used to assist in the development of Gradle plugins.
   Starting with Gradle version 2.13, the plugin provides a direct integration with TestKit.
   When applied to a project, the plugin automatically adds the `gradleTestKit()` dependency to the `testApi` configuration.
   Furthermore, it automatically generates the classpath for the code under test and injects it via link:{javadocPath}#[GradleRunner.withPluginClasspath()] for any `GradleRunner` instance created by the user.
   It's important to note that the mechanism currently _only_ works if the plugin under test is applied using the <<plugins.adoc#sec:plugins_block,plugins DSL>>.
   If the <<#sub:gradle-runner-gradle-version,target Gradle version>> is prior to 2.8, automatic plugin classpath injection is not performed.
   
   The plugin uses the following conventions for applying the TestKit dependency and injecting the classpath:
   
   * Source set containing code under test: `sourceSets.main`
   * Source set used for injecting the plugin classpath: `sourceSets.test`
   
   Any of these conventions can be reconfigured with the help of the class link:{javadocPath}#[GradlePluginDevelopmentExtension].
   
   The following Groovy-based sample demonstrates how to automatically inject the plugin classpath by using the standard conventions applied by the Java Gradle Plugin Development plugin.
   
   .Using the Java Gradle Development plugin for generating the plugin metadata
   ====
   include::sample[dir="snippets/testKit/automaticClasspathInjectionQuickstart/kotlin",files="build.gradle.kts[tags=automatic-classpath]"]
   include::sample[dir="snippets/testKit/automaticClasspathInjectionQuickstart/groovy",files="build.gradle[tags=automatic-classpath]"]
   ====
   
   
   === Example: Automatically injecting the code under test classes into test builds
   
   [source,groovy,indent=0]
   .src/test/groovy/org/gradle/sample/BuildLogicFunctionalTest.groovy
   ----
   include::{snippetsPath}/testKit/automaticClasspathInjectionQuickstart/groovy/src/test/groovy/org/gradle/sample/BuildLogicFunctionalTest.groovy[tag=functional-test-classpath-setup-automatic]
   ----
   
   The following build script demonstrates how to reconfigure the conventions provided by the Java Gradle Plugin Development plugin for a project that uses a custom `Test` source set.
   
   NOTE: A new configuration DSL for modeling the below `functionalTest` suite is available via the incubating <<jvm_test_suite_plugin.adoc#jvm_test_suite_plugin,JVM Test Suite>> plugin.
   
   .Reconfiguring the classpath generation conventions of the Java Gradle Development plugin
   ====
   include::sample[dir="snippets/testKit/automaticClasspathInjectionCustomTestSourceSet/kotlin",files="build.gradle.kts[tags=custom-test-source-set]"]
   include::sample[dir="snippets/testKit/automaticClasspathInjectionCustomTestSourceSet/groovy",files="build.gradle[tags=custom-test-source-set]"]
   ====
   
   
   == Controlling the build environment
   
   The runner executes the test builds in an isolated environment by specifying a dedicated "working directory" in a directory inside the JVM's temp directory (i.e. the location specified by the `java.io.tmpdir` system property, typically `/tmp`). Any configuration in the default Gradle User Home (e.g. `~/.gradle/gradle.properties`) is not used for test execution. The TestKit does not expose a mechanism for fine grained control of all aspects of the environment (e.g., JDK). Future versions of the TestKit will provide improved configuration options.
   
   The TestKit uses dedicated daemon processes that are automatically shut down after test execution.
   
   The dedicated working directory is not deleted by the runner after the build.
   The TestKit provides two ways to specify a location that is regularly cleaned, such as the project's build folder:
   
   * The `org.gradle.testkit.dir` system property;
   * The link:{javadocPath}#[GradleRunner.withTestKitDir(file testKitDir)] method.
   
   == The Gradle version used to test
   
   The Gradle runner requires a Gradle distribution in order to execute the build. The TestKit does not depend on all of Gradle's implementation.
   
   By default, the runner will attempt to find a Gradle distribution based on where the `GradleRunner` class was loaded from. That is, it is expected that the class was loaded from a Gradle distribution, as is the case when using the `gradleTestKit()` dependency declaration.
   
   When using the runner as part of tests _being executed by Gradle_ (e.g. executing the `test` task of a plugin project), the same distribution used to execute the tests will be used by the runner. When using the runner as part of tests _being executed by an IDE_, the same distribution of Gradle that was used when importing the project will be used. This means that the plugin will effectively be tested with the same version of Gradle that it is being built with.
   
   Alternatively, a different and specific version of Gradle to use can be specified by the any of the following `GradleRunner` methods:
   
   * link:{javadocPath}#[GradleRunner.withGradleVersion(java.lang.String)]
   * link:{javadocPath}#[GradleRunner.withGradleInstallation(java.io.File)]
   * link:{javadocPath}#[GradleRunner.withGradleDistribution(java.net.URI)]
   
   This can potentially be used to test build logic across Gradle versions. The following demonstrates a cross-version compatibility test written as Groovy Spock test:
   
   === Example: Specifying a Gradle version for test execution
   
   [source,groovy,indent=0]
   .BuildLogicFunctionalTest.groovy
   ----
   include::{snippetsPath}/testKit/gradleVersion/groovy/src/test/groovy/org/gradle/sample/BuildLogicFunctionalTest.groovy[tag=functional-test-spock-gradle-version]
   ----
   
   === Feature support when testing with different Gradle versions
   
   It is possible to use the GradleRunner to execute builds with Gradle 1.0 and later. However, some runner features are not supported on earlier versions. In such cases, the runner will throw an exception when attempting to use the feature.
   
   The following table lists the features that are sensitive to the Gradle version being used.
   
   .Gradle version compatibility
   [%header%autowidth,compact]
   |===
   | Feature | Minimum Version | Description
   
   | Inspecting executed tasks
   | 2.5
   | Inspecting the executed tasks, using link:{javadocPath}#[BuildResult.getTasks()] and similar methods.
   
   | <<#sub:test-kit-classpath-injection,Plugin classpath injection>>
   | 2.8
   | Injecting the code under test vialink:{javadocPath}#[GradleRunner.withPluginClasspath(java.lang.Iterable)].
   
   | <<#sub:test-kit-debug,Inspecting build output in debug mode>>
   | 2.9
   | Inspecting the build's text output when run in debug mode, using link:{javadocPath}#[BuildResult.getOutput()].
   
   | <<#sub:test-kit-automatic-classpath-injection,Automatic plugin classpath injection>>
   | 2.13
   | Injecting the code under test automatically via link:{javadocPath}#[GradleRunner.withPluginClasspath()] by applying the Java Gradle Plugin Development plugin.
   
   | Setting environment variables to be used by the build.
   | 3.5
   | The Gradle Tooling API only supports setting environment variables in later versions.
   |===
   
   
   == Debugging build logic
   
   The runner uses the <<third_party_integration.adoc#embedding,Tooling API>> to execute builds. An implication of this is that the builds are executed in a separate process (i.e. not the same process executing the tests). Therefore, executing your _tests_ in debug mode does not allow you to debug your build logic as you may expect. Any breakpoints set in your IDE will be not be tripped by the code being exercised by the test build.
   
   The TestKit provides two different ways to enable the debug mode:
   
   * Setting `org.gradle.testkit.debug` system property to `true` for the JVM _using_ the `GradleRunner` (i.e. not the build being executed with the runner);
   * Calling the link:{javadocPath}#[GradleRunner.withDebug(boolean)] method.
   
   The system property approach can be used when it is desirable to enable debugging support without making an adhoc change to the runner configuration. Most IDEs offer the capability to set JVM system properties for test execution, and such a feature can be used to set this system property.
   
   == Testing with the Build Cache
   
   To enable the <<build_cache.adoc#build_cache,Build Cache>> in your tests, you can pass the `--build-cache` argument to link:{javadocPath}#[GradleRunner] or use one of the other methods described in <<build_cache.adoc#sec:build_cache_enable,Enable the build cache>>. You can then check for the task outcome link:{javadocPath}#[TaskOutcome.FROM_CACHE] when your plugin's custom task is cached. This outcome is only valid for Gradle 3.5 and newer.
   
   === Example: Testing cacheable tasks
   
   [source,groovy,indent=0]
   .BuildLogicFunctionalTest.groovy
   ----
   include::{snippetsPath}/testKit/testKitFunctionalTestSpockBuildCache/groovy/src/test/groovy/org/gradle/sample/BuildLogicFunctionalTest.groovy[tag=functional-test-build-cache]
   ----
   
   Note that TestKit re-uses a Gradle User Home between tests (see link:{javadocPath}#[GradleRunner.withTestKitDir(java.io.File)]) which contains the default location for the local build cache.
   For testing with the build cache, the build cache directory should be cleaned between tests.
   The easiest way to accomplish this is to configure the local build cache to use a temporary directory.
   
   === Example: Clean build cache between tests
   
   [source,groovy,indent=0]
   .BuildLogicFunctionalTest.groovy
   ----
   include::{snippetsPath}/testKit/testKitFunctionalTestSpockBuildCache/groovy/src/test/groovy/org/gradle/sample/BuildLogicFunctionalTest.groovy[tag=clean-build-cache]
   ----

/docs/userguide/authoring-builds/other/ant.adoc
===============================================

.. code-block::

   = Using Ant from Gradle
   
   Gradle provides excellent integration with Ant. You can use individual Ant tasks or entire Ant builds in your Gradle builds. In fact, you will find that it's far easier and more powerful using Ant tasks in a Gradle build script, than it is to use Ant's XML format. You could even use Gradle simply as a powerful Ant task scripting tool.
   
   Ant can be divided into two layers. The first layer is the Ant language. It provides the syntax for the `build.xml` file, the handling of the targets, special constructs like macrodefs, and so on. In other words, everything except the Ant tasks and types. Gradle understands this language, and allows you to import your Ant `build.xml` directly into a Gradle project. You can then use the targets of your Ant build as if they were Gradle tasks.
   
   The second layer of Ant is its wealth of Ant tasks and types, like `javac`, `copy` or `jar`. For this layer Gradle provides integration simply by relying on Groovy, and the fantastic `AntBuilder`.
   
   Finally, since build scripts are Groovy scripts, you can always execute an Ant build as an external process. Your build script may contain statements like: `"ant clean compile".execute()`.footnote:[In Groovy you can execute Strings. To learn more about executing external processes with Groovy have a look in 'Groovy in Action' 9.3.2 or at the Groovy wiki]
   
   You can use Gradle's Ant integration as a path for migrating your build from Ant to Gradle. For example, you could start by importing your existing Ant build. Then you could move your dependency declarations from the Ant script to your build file. Finally, you could move your tasks across to your build file, or replace them with some of Gradle's plugins. This process can be done in parts over time, and you can have a working Gradle build during the entire process.
   
   WARNING: Ant integration is not fully compatible with the <<configuration_cache.adoc#config_cache,configuration cache>>.
   Using link:{javadocPath}#[Task.ant] to run Ant task in the task action may work, but importing the Ant build is not supported.
   
   == Using Ant tasks and types in your build
   
   In your build script, a property called `ant` is provided by Gradle. This is a reference to an link:{javadocPath}#[AntBuilder] instance. This `AntBuilder` is used to access Ant tasks, types and properties from your build script. There is a very simple mapping from Ant's `build.xml` format to Groovy, which is explained below.
   
   You execute an Ant task by calling a method on the `AntBuilder` instance. You use the task name as the method name. For example, you execute the Ant `echo` task by calling the `ant.echo()` method. The attributes of the Ant task are passed as Map parameters to the method. Below is an example of the `echo` task. Notice that we can also mix Groovy code and the Ant task markup. This can be extremely powerful.
   
   .Using an Ant task
   ====
   include::sample[dir="snippets/ant/useAntTask/kotlin",files="build.gradle.kts"]
   include::sample[dir="snippets/ant/useAntTask/groovy",files="build.gradle"]
   ====
   
   .Output of `gradle hello`
   ----
   > gradle hello
   include::{snippetsPath}/ant/useAntTask/tests/useAntTask.out[]
   ----
   
   You pass nested text to an Ant task by passing it as a parameter of the task method call. In this example, we pass the message for the `echo` task as nested text:
   
   .Passing nested text to an Ant task
   ====
   include::sample[dir="snippets/ant/taskWithNestedText/kotlin",files="build.gradle.kts"]
   include::sample[dir="snippets/ant/taskWithNestedText/groovy",files="build.gradle"]
   ====
   
   .Output of `gradle hello`
   ----
   > gradle hello
   include::{snippetsPath}/ant/taskWithNestedText/tests/taskWithNestedText.out[]
   ----
   
   You pass nested elements to an Ant task inside a closure. Nested elements are defined in the same way as tasks, by calling a method with the same name as the element we want to define.
   
   .Passing nested elements to an Ant task
   ====
   include::sample[dir="snippets/ant/taskWithNestedElements/kotlin",files="build.gradle.kts"]
   include::sample[dir="snippets/ant/taskWithNestedElements/groovy",files="build.gradle"]
   ====
   
   You can access Ant types in the same way that you access tasks, using the name of the type as the method name. The method call returns the Ant data type, which you can then use directly in your build script. In the following example, we create an Ant `path` object, then iterate over the contents of it.
   
   .Using an Ant type
   ====
   include::sample[dir="snippets/ant/useAntType/kotlin",files="build.gradle.kts"]
   include::sample[dir="snippets/ant/useAntType/groovy",files="build.gradle"]
   ====
   
   More information about `AntBuilder` can be found in 'Groovy in Action' 8.4 or at the https://groovy-lang.org/scripting-ant.html[Groovy Wiki].
   
   === Using custom Ant tasks in your build
   
   To make custom tasks available in your build, you can use the `taskdef` (usually easier) or `typedef` Ant task, just as you would in a `build.xml` file. You can then refer to the custom Ant task as you would a built-in Ant task.
   
   .Using a custom Ant task
   ====
   include::sample[dir="snippets/ant/useExternalAntTask/kotlin",files="build.gradle.kts[tags=configure-task]"]
   include::sample[dir="snippets/ant/useExternalAntTask/groovy",files="build.gradle[tags=configure-task]"]
   ====
   
   You can use Gradle's dependency management to assemble the classpath to use for the custom tasks. To do this, you need to define a custom configuration for the classpath, then add some dependencies to the configuration. This is described in more detail in link:#[Declaring Dependencies].
   
   .Declaring the classpath for a custom Ant task
   ====
   include::sample[dir="snippets/ant/useExternalAntTaskWithConfig/kotlin",files="build.gradle.kts[tags=define-classpath]"]
   include::sample[dir="snippets/ant/useExternalAntTaskWithConfig/groovy",files="build.gradle[tags=define-classpath]"]
   ====
   
   To use the classpath configuration, use the `asPath` property of the custom configuration.
   
   .Using a custom Ant task and dependency management together
   ====
   include::sample[dir="snippets/ant/useExternalAntTaskWithConfig/kotlin",files="build.gradle.kts[tags=use-classpath]"]
   include::sample[dir="snippets/ant/useExternalAntTaskWithConfig/groovy",files="build.gradle[tags=use-classpath]"]
   ====
   
   == Importing an Ant build
   
   You can use the `ant.importBuild()` method to import an Ant build into your Gradle project. When you import an Ant build, each Ant target is treated as a Gradle task. This means you can manipulate and execute the Ant targets in exactly the same way as Gradle tasks.
   
   .Importing an Ant build
   ====
   include::sample[dir="snippets/ant/hello/kotlin",files="build.gradle.kts"]
   include::sample[dir="snippets/ant/hello/groovy",files="build.gradle"]
   ====
   
   ====
   include::sample[dir="snippets/ant/hello/groovy",files="build.xml"]
   ====
   
   .Output of `gradle hello`
   ----
   > gradle hello
   include::{snippetsPath}/ant/hello/tests/antHello.out[]
   ----
   
   You can add a task which depends on an Ant target:
   
   .Task that depends on Ant target
   ====
   include::sample[dir="snippets/ant/dependsOnAntTarget/kotlin",files="build.gradle.kts"]
   include::sample[dir="snippets/ant/dependsOnAntTarget/groovy",files="build.gradle"]
   ====
   
   .Output of `gradle intro`
   ----
   > gradle intro
   include::{snippetsPath}/ant/dependsOnAntTarget/tests/dependsOnAntTarget.out[]
   ----
   
   Or, you can add behaviour to an Ant target:
   
   .Adding behaviour to an Ant target
   ====
   include::sample[dir="snippets/ant/addBehaviourToAntTarget/kotlin",files="build.gradle.kts"]
   include::sample[dir="snippets/ant/addBehaviourToAntTarget/groovy",files="build.gradle"]
   ====
   
   .Output of `gradle hello`
   ----
   > gradle hello
   include::{snippetsPath}/ant/addBehaviourToAntTarget/tests/addBehaviourToAntTarget.out[]
   ----
   
   It is also possible for an Ant target to depend on a Gradle task:
   
   .Ant target that depends on Gradle task
   ====
   include::sample[dir="snippets/ant/dependsOnTask/kotlin",files="build.gradle.kts"]
   include::sample[dir="snippets/ant/dependsOnTask/groovy",files="build.gradle"]
   ====
   
   ====
   include::sample[dir="snippets/ant/dependsOnTask/groovy",files="build.xml"]
   ====
   
   .Output of `gradle hello`
   ----
   > gradle hello
   include::{snippetsPath}/ant/dependsOnTask/tests/dependsOnTask.out[]
   ----
   
   Sometimes it may be necessary to rename the task generated for an Ant target to avoid a naming collision with existing Gradle tasks. To do this, use the link:{javadocPath}#[AntBuilder.importBuild(java.lang.Object, org.gradle.api.Transformer)] method.
   
   .Renaming imported Ant targets
   ====
   include::sample[dir="snippets/ant/renameTask/kotlin",files="build.gradle.kts"]
   include::sample[dir="snippets/ant/renameTask/groovy",files="build.gradle"]
   ====
   
   ====
   include::sample[dir="snippets/ant/renameTask/groovy",files="build.xml"]
   ====
   
   .Output of `gradle a-hello`
   ----
   > gradle a-hello
   include::{snippetsPath}/ant/renameTask/tests/renameAntDelegate.out[]
   ----
   
   Note that while the second argument to this method should be a link:{javadocPath}#[Transformer], when programming in Groovy we can simply use a closure instead of an anonymous inner class (or similar) due to http://mrhaki.blogspot.ie/2013/11/groovy-goodness-implicit-closure.html[Groovy's support for automatically coercing closures to single-abstract-method types].
   
   == Ant properties and references
   
   There are several ways to set an Ant property, so that the property can be used by Ant tasks. You can set the property directly on the `AntBuilder` instance. The Ant properties are also available as a Map which you can change. You can also use the Ant `property` task. Below are some examples of how to do this.
   
   .Setting an Ant property
   ====
   include::sample[dir="snippets/ant/properties/kotlin",files="build.gradle.kts[tags=set-property]"]
   include::sample[dir="snippets/ant/properties/groovy",files="build.gradle[tags=set-property]"]
   ====
   
   Many Ant tasks set properties when they execute. There are several ways to get the value of these properties. You can get the property directly from the `AntBuilder` instance. The Ant properties are also available as a Map. Below are some examples.
   
   .Getting an Ant property
   ====
   include::sample[dir="snippets/ant/properties/groovy",files="build.xml[tags=getproperty]"]
   ====
   
   ====
   include::sample[dir="snippets/ant/properties/kotlin",files="build.gradle.kts[tags=get-property]"]
   include::sample[dir="snippets/ant/properties/groovy",files="build.gradle[tags=get-property]"]
   ====
   
   There are several ways to set an Ant reference:
   
   .Setting an Ant reference
   ====
   include::sample[dir="snippets/ant/properties/kotlin",files="build.gradle.kts[tags=set-reference]"]
   include::sample[dir="snippets/ant/properties/groovy",files="build.gradle[tags=set-reference]"]
   ====
   
   ====
   include::sample[dir="snippets/ant/properties/groovy",files="build.xml[tags=setreference]"]
   ====
   
   There are several ways to get an Ant reference:
   
   .Getting an Ant reference
   ====
   include::sample[dir="snippets/ant/properties/groovy",files="build.xml[tags=getreference]"]
   ====
   
   ====
   include::sample[dir="snippets/ant/properties/kotlin",files="build.gradle.kts[tags=get-reference]"]
   include::sample[dir="snippets/ant/properties/groovy",files="build.gradle[tags=get-reference]"]
   ====
   
   == Ant logging
   
   Gradle maps Ant message priorities to Gradle log levels so that messages logged from Ant appear in the Gradle output. By default, these are mapped as follows:
   
   .Ant message priority mapping
   [cols="a,a", options="header"]
   |===
   | Ant Message Priority
   | Gradle Log Level
   
   | _VERBOSE_
   | `DEBUG`
   
   | _DEBUG_
   | `DEBUG`
   
   | _INFO_
   | `INFO`
   
   | _WARN_
   | `WARN`
   
   | _ERROR_
   | `ERROR`
   |===
   
   
   === Fine tuning Ant logging
   
   The default mapping of Ant message priority to Gradle log level can sometimes be problematic. For example, there is no message priority that maps directly to the `LIFECYCLE` log level, which is the default for Gradle. Many Ant tasks log messages at the _INFO_ priority, which means to expose those messages from Gradle, a build would have to be run with the log level set to `INFO`, potentially logging much more output than is desired.
   
   Conversely, if an Ant task logs messages at too high of a level, to suppress those messages would require the build to be run at a higher log level, such as `QUIET`. However, this could result in other, desirable output being suppressed.
   
   To help with this, Gradle allows the user to fine tune the Ant logging and control the mapping of message priority to Gradle log level. This is done by setting the priority that should map to the default Gradle `LIFECYCLE` log level using the link:{javadocPath}#[AntBuilder.setLifecycleLogLevel(java.lang.String)] method. When this value is set, any Ant message logged at the configured priority or above will be logged at least at `LIFECYCLE`. Any Ant message logged below this priority will be logged at most at `INFO`.
   
   For example, the following changes the mapping such that Ant _INFO_ priority messages are exposed at the `LIFECYCLE` log level.
   
   .Fine tuning Ant logging
   ====
   include::sample[dir="snippets/ant/antLogging/kotlin",files="build.gradle.kts"]
   include::sample[dir="snippets/ant/antLogging/groovy",files="build.gradle"]
   ====
   
   .Output of `gradle hello`
   ----
   > gradle hello
   include::{snippetsPath}/ant/antLogging/tests/antLogging.out[]
   ----
   
   On the other hand, if the `lifecycleLogLevel` was set to _ERROR_, Ant messages logged at the _WARN_ priority would no longer be logged at the `WARN` log level. They would now be logged at the `INFO` level and would be suppressed by default.
   
   == API
   
   The Ant integration is provided by link:{javadocPath}#[AntBuilder].

/Topic: 游댯 Authoring JVM Builds
=================================


/docs/userguide/jvm/building_java_projects.adoc
===============================================

.. code-block::

   = Building Java & JVM projects
   
   Gradle uses a convention-over-configuration approach to building JVM-based projects that borrows several conventions from Apache Maven. In particular, it uses the same default directory structure for source files and resources, and it works with Maven-compatible repositories.
   
   We will look at Java projects in detail in this chapter, but most of the topics apply to other supported JVM languages as well, such as link:https://kotlinlang.org/docs/reference/using-gradle.html#targeting-the-jvm[Kotlin], <<groovy_plugin.adoc#groovy_plugin,Groovy>> and <<scala_plugin.adoc#scala_plugin,Scala>>.
   If you don't have much experience with building JVM-based projects with Gradle, take a look at the link:#[Java samples] for step-by-step instructions on how to build various types of basic Java projects.
   
   [NOTE]
   ====
   The example in this section use the Java Library Plugin.
   However the described features are shared by all JVM plugins.
   Specifics of the different plugins are available in their dedicated documentation.
   ====
   
   TIP: There are a number of hands-on samples that you can explore for link:#[Java], link:#[Groovy], link:#[Scala] and link:#[Kotlin].
   
   == Introduction
   
   The simplest build script for a Java project applies the <<java_library_plugin.adoc#java_library_plugin,Java Library Plugin>> and optionally sets the project version and selects the <<toolchains.adoc#toolchains,Java toolchain>> to use:
   
   .Applying the Java Library Plugin
   ====
   include::sample[dir="snippets/java/basic/kotlin",files="build.gradle.kts[tags=apply-java-plugin]"]
   include::sample[dir="snippets/java/basic/groovy",files="build.gradle[tags=apply-java-plugin]"]
   ====
   
   By applying the Java Library Plugin, you get a whole host of features:
   
    * A `compileJava` task that compiles all the Java source files under _src/main/java_
    * A `compileTestJava` task for source files under _src/test/java_
    * A `test` task that runs the tests from _src/test/java_
    * A `jar` task that packages the `main` compiled classes and resources from _src/main/resources_ into a single JAR named _<project>-<version>.jar_
    * A `javadoc` task that generates Javadoc for the `main` classes
   
   This isn't sufficient to build any non-trivial Java project  at the very least, you'll probably have some file dependencies. But it means that your build script only needs the information that is specific to _your_ project.
   
   [NOTE]
   ====
   Although the properties in the example are optional, we recommend that you specify them in your projects.
   Configuring the toolchain protects against problems with the project being built with different Java versions.
   The version string is important for tracking the progression of the project.
   The project version is also used in archive names by default.
   ====
   
   The Java Library Plugin also integrates the above tasks into the standard <<base_plugin.adoc#sec:base_tasks,Base Plugin lifecycle tasks>>:
   
    * `jar` is attached to `assemble`
    * `test` is attached to `check`
   
   The rest of the chapter explains the different avenues for customizing the build to your requirements. You will also see later how to adjust the build for libraries, applications, web apps and enterprise apps.
   
   == Declaring your source files via source sets
   
   Gradle's Java support was the first to introduce a new concept for building source-based projects: _source sets_. The main idea is that source files and resources are often logically grouped by type, such as application code, unit tests and integration tests. Each logical group typically has its own sets of file dependencies, classpaths, and more. Significantly, the files that form a source set _don't have to be located in the same directory_!
   
   Source sets are a powerful concept that tie together several aspects of compilation:
   
    * the source files and where they're located
    * the compilation classpath, including any required dependencies (via Gradle <<dependency_management_terminology.adoc#sub:terminology_configuration,configurations>>)
    * where the compiled class files are placed
   
   You can see how these relate to one another in this diagram:
   
   .Source sets and Java compilation
   image::java-sourcesets-compilation.png[]
   
   The shaded boxes represent properties of the source set itself.
   On top of that, the Java Library Plugin automatically creates a compilation task for every source set you or a plugin defines  named `compile__SourceSet__Java`  and several <<java_plugin.adoc#java_source_set_configurations,dependency configurations>>.
   
   .The `main` source set
   --
   Most language plugins, Java included, automatically create a source set called `main`, which is used for the project's production code. This source set is special in that its name is not included in the names of the configurations and tasks, hence why you have just a `compileJava` task and `compileOnly` and `implementation` configurations rather than `compileMainJava`, `mainCompileOnly` and `mainImplementation` respectively.
   --
   
   Java projects typically include resources other than source files, such as properties files, that may need processing  for example by replacing tokens within the files  and packaging within the final JAR.
   The Java Library Plugin handles this by automatically creating a dedicated task for each defined source set called `process__SourceSet__Resources` (or `processResources` for the `main` source set).
   The following diagram shows how the source set fits in with this task:
   
   .Processing non-source files for a source set
   image::java-sourcesets-process-resources.png[]
   
   As before, the shaded boxes represent properties of the source set, which in this case comprises the locations of the resource files and where they are copied to.
   
   In addition to the `main` source set, the Java Library Plugin defines a `test` source set that represents the project's tests.
   This source set is used by the `test` task, which runs the tests.
   You can learn more about this task and related topics in the <<java_testing.adoc#java_testing,Java testing>> chapter.
   
   Projects typically use this source set for unit tests, but you can also use it for integration, acceptance and other types of test if you wish.
   The alternative approach is to <<#sec:custom_java_source_sets,define a new source set>> for each of your other test types, which is typically done for one or both of the following reasons:
   
    * You want to keep the tests separate from one another for aesthetics and manageability
    * The different test types require different compilation or runtime classpaths or some other difference in setup
   
   You can see an example of this approach in the Java testing chapter, which shows you <<java_testing.adoc#sec:configuring_java_integration_tests,how to set up integration tests>> in a project.
   
   You'll learn more about source sets and the features they provide in:
   
    * <<#sec:custom_java_source_set_paths,Customizing file and directory locations>>
    * <<java_testing.adoc#sec:configuring_java_integration_tests,Configuring Java integration tests>>
   
   === Source set configurations
   
   When a source set is created, it also creates a number of configurations as described above.
   Build logic should **not** attempt to create or access these configurations until they are first created by the source set.
   
   When creating a source set, if one of these automatically created configurations already exists, Gradle will emit a deprecation warning.
   If the existing configuration's role is different than the role that the source set would have assigned, its role will be mutated to the correct value and another deprecation warning will be emitted.
   
   The build below demonstrates this unwanted behavior.
   
   .Configurations created prior to their associated source sets
   ====
   include::sample[dir="snippets/java/sourceSets-badConfNames/kotlin",files="build.gradle.kts[tags=create-configurations]"]
   include::sample[dir="snippets/java/sourceSets-badConfNames/groovy",files="build.gradle[tags=create-configurations]"]
   ====
   
   In this case, the following deprecation warning is emitted:
   
   ```
   When creating configurations during sourceSet custom setup, Gradle found that configuration customCompileClasspath already exists with permitted usage(s):
   	Consumable - this configuration can be selected by another project as a dependency
   	Resolvable - this configuration can be resolved by this project to a set of files
   	Declarable - this configuration can have dependencies added to it
   Yet Gradle expected to create it with the usage(s):
   	Resolvable - this configuration can be resolved by this project to a set of files
   ```
   
   Following two simple best practices will avoid this problem:
   
   1. Don't create configurations with names that will be used by source sets, such as names ending in `Api`, `Implementation`, `ApiElements`, `CompileOnly`, `CompileOnlyApi`, `RuntimeOnly`, `RuntimeClasspath` or `RuntimeElements`.
   (This list is not exhaustive.)
   2. Create any custom source sets prior to any custom configurations.
   
   Remember that any time you reference a configuration within the `configurations` container - with or without supplying an initialization action - Gradle will create the configuration.
   Sometimes when using the Groovy DSL this creation is not obvious, as in the example below, where `myCustomConfiguration` is created prior to the call to `extendsFrom`.
   
   .Custom Configuration creation in Groovy
   ====
   include::sample[dir="snippets/java/customConfs-creation/groovy",files="build.gradle[tags=create-configurations]"]
   ====
   
   For more information see <<authoring_maintainable_build_scripts.adoc#sec:dont_anticipate_configuration_creation, Don't anticipate configuration creation>>.
   
   == Managing your dependencies
   
   The vast majority of Java projects rely on libraries, so managing a project's dependencies is an important part of building a Java project.
   Dependency management is a big topic, so we will focus on the basics for Java projects here.
   If you'd like to dive into the detail, check out the <<core_dependency_management.adoc#dependency_management_in_gradle,introduction to dependency management>>.
   
   Specifying the dependencies for your Java project requires just three pieces of information:
   
    * Which dependency you need, such as a name and version
    * What it's needed for, e.g. compilation or running
    * Where to look for it
   
   The first two are specified in a `dependencies {}` block and the third in a `repositories {}` block. For example, to tell Gradle that your project requires version 3.6.7 of http://hibernate.org/[Hibernate] Core to compile and run your production code, and that you want to download the library from the Maven Central repository, you can use the following fragment:
   
   .Declaring dependencies
   ====
   include::sample[dir="snippets/java/basic/kotlin",files="build.gradle.kts[tags=java-dependency-mgmt]"]
   include::sample[dir="snippets/java/basic/groovy",files="build.gradle[tags=java-dependency-mgmt]"]
   ====
   
   The Gradle terminology for the three elements is as follows:
   
    * _Repository_ (ex: `mavenCentral()`)  where to look for the modules you declare as dependencies
    * _Configuration_ (ex: `implementation`)  a named collection of dependencies, grouped together for a specific goal such as compiling or running a module 댹마 more flexible form of Maven scopes
    * _Module coordinate_ (ex: `org.hibernate:hibernate-core-3.6.7.Final`)  the ID of the dependency, usually in the form '__<group>__:__<module>__:__<version>__' (or '__<groupId>__:__<artifactId>__:__<version>__' in Maven terminology)
   
   You can find a more comprehensive glossary of dependency management terms <<dependency_management_terminology.adoc#dependency_management_terminology,here>>.
   
   As far as configurations go, the main ones of interest are:
   
    * `compileOnly` 댹맍or dependencies that are necessary to compile your production code but shouldn't be part of the runtime classpath
    * `implementation` (supersedes `compile`) 댹맛sed for compilation and runtime
    * `runtimeOnly` (supersedes `runtime`)  only used at runtime, not for compilation
    * `testCompileOnly`  same as `compileOnly` except it's for the tests
    * `testImplementation` 댹맚est equivalent of `implementation`
    * `testRuntimeOnly` 댹맚est equivalent of `runtimeOnly`
   
   You can learn more about these and how they relate to one another in the <<java_plugin.adoc#sec:java_plugin_and_dependency_management,plugin reference chapter>>.
   
   Be aware that the <<java_library_plugin.adoc#java_library_plugin,Java Library Plugin>> offers two additional configurations  `api` and `compileOnlyApi`  for dependencies that are required for compiling both the module and any modules that depend on it.
   
   .Why no `compile` configuration?
   --
   The Java Library Plugin has historically used the `compile` configuration for dependencies that are required to both compile and run a project's production code.
   It is now deprecated, and will issue warnings when used, because it doesn't distinguish between dependencies that impact the public API of a Java library project and those that don't.
   You can learn more about the importance of this distinction in <<#sec:building_java_libraries,Building Java libraries>>.
   --
   
   We have only scratched the surface here, so we recommend that you read the dedicated dependency management chapters once you're comfortable with the basics of building Java projects with Gradle. Some common scenarios that require further reading include:
   
    * Defining a custom <<declaring_repositories.adoc#sec:maven_repo,Maven\->> or <<declaring_repositories.adoc#sec:ivy_repositories,Ivy-compatible>> repository
    * Using dependencies from a <<declaring_repositories.adoc#sub:flat_dir_resolver,local filesystem directory>>
    * Declaring dependencies with <<dynamic_versions.adoc#sub:declaring_dependency_with_changing_version,changing>> (e.g. SNAPSHOT) and <<dynamic_versions.adoc#sub:declaring_dependency_with_dynamic_version,dynamic>> (range) versions
    * Declaring a sibling <<declaring_dependencies.adoc#sub:project_dependencies,project as a dependency>>
    * <<dependency_constraints.adoc#dependency-constraints,Controlling transitive dependencies and their versions>>
    * Testing your fixes to a 3rd-party dependency via <<composite_builds.adoc#composite_builds,composite builds>> (a better alternative to publishing to and consuming from <<declaring_repositories.adoc#sub:maven_local,Maven Local>>)
   
   You'll discover that Gradle has a rich API for working with dependencies 댹맖ne that takes time to master, but is straightforward to use for common scenarios.
   
   
   == Compiling your code
   
   Compiling both your production and test code can be trivially easy if you follow the conventions:
   
    1. Put your production source code under the _src/main/java_ directory
    2. Put your test source code under _src/test/java_
    3. Declare your production compile dependencies in the `compileOnly` or `implementation` configurations (see previous section)
    4. Declare your test compile dependencies in the `testCompileOnly` or `testImplementation` configurations
    5. Run the `compileJava` task for the production code and `compileTestJava` for the tests
   
   Other JVM language plugins, such as the one for <<groovy_plugin.adoc#groovy_plugin,Groovy>>, follow the same pattern of conventions. We recommend that you follow these conventions wherever possible, but you don't have to. There are several options for customization, as you'll see next.
   
   === Customizing file and directory locations
   
   Imagine you have a legacy project that uses an _src_ directory for the production code and _test_ for the test code. The conventional directory structure won't work, so you need to tell Gradle where to find the source files. You do that via source set configuration.
   
   Each source set defines where its source code resides, along with the resources and the output directory for the class files. You can override the convention values by using the following syntax:
   
   .Declaring custom source directories
   ====
   include::sample[dir="snippets/java/customDirs/kotlin",files="build.gradle.kts[tags=custom-src-dirs]"]
   include::sample[dir="snippets/java/customDirs/groovy",files="build.gradle[tags=custom-src-dirs]"]
   ====
   
   Now Gradle will only search directly in _src_ and _test_ for the respective source code. What if you don't want to override the convention, but simply want to _add_ an extra source directory, perhaps one that contains some third-party source code you want to keep separate? The syntax is similar:
   
   .Declaring custom source directories additively
   ====
   include::sample[dir="snippets/java/customDirs/kotlin",files="build.gradle.kts[tags=custom-extra-src-dir]"]
   include::sample[dir="snippets/java/customDirs/groovy",files="build.gradle[tags=custom-extra-src-dir]"]
   ====
   
   Crucially, we're using the _method_ `srcDir()` here to append a directory path, whereas setting the `srcDirs` property replaces any existing values. This is a common convention in Gradle: setting a property replaces values, while the corresponding method appends values.
   
   You can see all the properties and methods available on source sets in the DSL reference for link:{groovyDslPath}#[SourceSet] and link:{groovyDslPath}#[SourceDirectorySet]. Note that `srcDirs` and `srcDir()` are both on `SourceDirectorySet`.
   
   === Changing compiler options
   
   Most of the compiler options are accessible through the corresponding task, such as `compileJava` and `compileTestJava`. These tasks are of type link:{groovyDslPath}#[JavaCompile], so read the task reference for an up-to-date and comprehensive list of the options.
   
   For example, if you want to use a separate JVM process for the compiler and prevent compilation failures from failing the build, you can use this configuration:
   
   .Setting Java compiler options
   ====
   include::sample[dir="snippets/java/basic/kotlin",files="build.gradle.kts[tags=java-compiler-options]"]
   include::sample[dir="snippets/java/basic/groovy",files="build.gradle[tags=java-compiler-options]"]
   ====
   
   That's also how you can change the verbosity of the compiler, disable debug output in the byte code and configure where the compiler can find annotation processors.
   
   === Targeting a specific Java version
   
   By default, Gradle will compile Java code to the language level of the JVM running Gradle.
   If you need to target a specific version of Java when compiling, Gradle provides multiple options:
   
   1. Using <<toolchains.adoc#toolchains,Java toolchains>> is a preferred way to target a language version. +
   A toolchain uniformly handles compilation, execution and Javadoc generation, and it can be configured on the project level.
   2. Using link:{groovyDslPath}#[`release`] property is possible starting from Java 10. +
   Selecting a Java release makes sure that compilation is done with the configured language level and against the JDK APIs from that Java version.
   3. Using `sourceCompatibility` and `targetCompatibility` properties. +
   Although not generally advised, these options were historically used to configure the Java version during compilation.
   
   ==== Using toolchains
   
   When Java code is compiled using a specific toolchain, the actual compilation is carried out by a compiler of the specified Java version.
   The compiler provides access to the language features and JDK APIs for the requested Java language version.
   
   In the simplest case, the toolchain can be configured for a project using the `java` extension.
   This way, not only compilation benefits from it, but also other tasks such as `test` and `javadoc` will also consistently use the same toolchain.
   
   ====
   include::sample[dir="snippets/java/toolchain-basic/kotlin",files="build.gradle.kts[tags=toolchain]"]
   include::sample[dir="snippets/java/toolchain-basic/groovy",files="build.gradle[tags=toolchain]"]
   ====
   
   You can learn more about this in the <<toolchains.adoc#toolchains,Java toolchains>> guide.
   
   ==== Using Java release version
   
   Setting the link:{groovyDslPath}#[release] flag ensures the specified language level is used regardless of which compiler actually performs the compilation.
   To use this feature, the compiler must support the requested release version.
   It is possible to specify an earlier release version while compiling with a more recent <<#sec:compiling_with_toolchain,toolchain>>.
   
   Gradle supports using the release flag from Java 10.
   It can be configured on the compilation task as follows.
   
   .Setting Java release flag
   ====
   include::sample[dir="snippets/java/basic/kotlin",files="build.gradle.kts[tags=java-release-flag]"]
   include::sample[dir="snippets/java/basic/groovy",files="build.gradle[tags=java-release-flag]"]
   ====
   
   The release flag provides guarantees similar to toolchains.
   It validates that the Java sources are not using language features introduced in later Java versions, and also that the code does not access APIs from more recent JDKs.
   The bytecode produced by the compiler also corresponds to the requested Java version, meaning that the compiled code cannot be executed on older JVMs.
   
   The `release` option of the Java compiler was introduced in Java 9.
   However, using this option with Gradle is only possible starting with Java 10, due to a https://bugs.openjdk.java.net/browse/JDK-8139607[bug in Java 9].
   
   ==== Using Java compatibility options
   
   WARNING: Using compatibility properties can lead to runtime failures when executing compiled code due to weaker guarantees they provide.
   Instead, consider using <<#sec:compiling_with_toolchain,toolchains>> or the <<#sec:compiling_with_release,release>> flag.
   
   The `sourceCompatibility` and `targetCompatibility` options correspond to the Java compiler options `-source` and `-target`.
   They are considered a legacy mechanism for targeting a specific Java version.
   However, these options do not protect against the use of APIs introduced in later Java versions.
   
   `sourceCompatibility`::
   Defines the language version of Java used in your source files.
   
   `targetCompatibility`::
   Defines the minimum JVM version your code should run on, i.e. it determines the version of the bytecode generated by the compiler.
   
   These options can be set per link:{groovyDslPath}#[JavaCompile] task, or on the `java { }` extension for all compile tasks, using properties with the same names.
   
   ==== Targeting Java 6 and Java 7
   
   Gradle itself can only run on a JVM with Java version 8 or higher.
   However, Gradle still supports compiling, testing, generating Javadocs and executing applications for Java 6 and Java 7.
   Java 5 and below are not supported.
   
   NOTE: If using Java 10+, leveraging the `release` flag might be an easier solution, see above.
   
   To use Java 6 or Java 7, the following tasks need to be configured:
   
   * `JavaCompile` task to fork and use the correct Java home
   * `Javadoc` task to use the correct `javadoc` executable
   * `Test` and the `JavaExec` task to use the correct `java` executable.
   
   With the usage of Java toolchains, this can be done as follows:
   
   .Configuring Java 7 build
   ====
   include::sample[dir="snippets/java/crossCompilation/kotlin",files="build.gradle.kts[tags=java-cross-compilation]"]
   include::sample[dir="snippets/java/crossCompilation/groovy",files="build.gradle[tags=java-cross-compilation]"]
   ====
   
   The only requirement is that Java 7 is installed and has to be either in <<toolchains.adoc#sec:auto_detection,a location Gradle can detect automatically>> or <<toolchains.adoc#sec:custom_loc,explicitly configured>>.
   
   === Compiling independent sources separately
   
   Most projects have at least two independent sets of sources: the production code and the test code.
   Gradle already makes this scenario part of its Java convention, but what if you have other sets of sources?
   One of the most common scenarios is when you have separate integration tests of some form or other.
   In that case, a custom source set may be just what you need.
   
   You can see a complete example for setting up integration tests in the <<java_testing.adoc#sec:configuring_java_integration_tests,Java testing chapter>>. You can set up other source sets that fulfil different roles in the same way. The question then becomes: when should you define a custom source set?
   
   To answer that question, consider whether the sources:
   
    1. Need to be compiled with a unique classpath
    2. Generate classes that are handled differently from the `main` and `test` ones
    3. Form a natural part of the project
   
   If your answer to both 3 and either one of the others is yes, then a custom source set is probably the right approach. For example, integration tests are typically part of the project because they test the code in `main`. In addition, they often have either their own dependencies independent of the `test` source set or they need to be run with a custom `Test` task.
   
   Other common scenarios are less clear cut and may have better solutions. For example:
   
    * Separate API and implementation JARs 댹말t may make sense to have these as separate projects, particularly if you already have a multi-project build
    * Generated sources 댹말f the resulting sources should be compiled with the production code, add their path(s) to the `main` source set and make sure that the `compileJava` task depends on the task that generates the sources
   
   If you're unsure whether to create a custom source set or not, then go ahead and do so. It should be straightforward and if it's not, then it's probably not the right tool for the job.
   
   == Managing resources
   
   Many Java projects make use of resources beyond source files, such as images, configuration files and localization data.
   Sometimes these files simply need to be packaged unchanged and sometimes they need to be processed as template files or in some other way.
   Either way, the Java Library Plugin adds a specific link:{groovyDslPath}#[Copy] task for each source set that handles the processing of its associated resources.
   
   The task's name follows the convention of `process__SourceSet__Resources` 댹맖r `processResources` for the `main` source set 댹마nd it will automatically copy any files in _src/[sourceSet]/resources_ to a directory that will be included in the production JAR. This target directory will also be included in the runtime classpath of the tests.
   
   Since `processResources` is an instance of the `ProcessResources` task, you can perform any of the processing described in the <<working_with_files.adoc#sec:copying_files,Working With Files>> chapter.
   
   === Java properties files and reproducible builds
   
   You can easily create Java properties files via the link:{groovyDslPath}#[WriteProperties] task, which fixes a well-known problem with `Properties.store()` that can reduce the usefulness of <<incremental_build.adoc#incremental_build,incremental builds>>.
   
   The standard Java API for writing properties files produces a unique file every time, even when the same properties and values are used, because it includes a timestamp in the comments. Gradle's `WriteProperties` task generates exactly the same output byte-for-byte if none of the properties have changed. This is achieved by a few tweaks to how a properties file is generated:
   
   * no timestamp comment is added to the output
   * the line separator is system independent, but can be configured explicitly (it defaults to `'\n'`)
   * the properties are sorted alphabetically
   
   Sometimes it can be desirable to recreate archives in a byte for byte way on different machines. You want to be sure that building an artifact from source code produces the same result, byte for byte, no matter when and where it is built. This is necessary for projects like reproducible-builds.org.
   
   These tweaks not only lead to better incremental build integration, but they also help with https://reproducible-builds.org[reproducible builds]. In essence, reproducible builds guarantee that you will see the same results from a build execution  including test results and production binaries 댹맕o matter when or on what system you run it.
   
   == Running tests
   
   Alongside providing automatic compilation of unit tests in _src/test/java_, the Java Library Plugin has native support for running tests that use JUnit 3, 4 & 5 (JUnit 5 support https://docs.gradle.org/4.6/release-notes.html#junit-5-support[came in Gradle 4.6]) and TestNG.
   You get:
   
    * An automatic `test` task of type link:{groovyDslPath}#[Test], using the `test` source set
    * An HTML test report that includes the results from _all_ `Test` tasks that run
    * Easy filtering of which tests to run
    * Fine-grained control over how the tests are run
    * The opportunity to create your own test execution and test reporting tasks
   
   You do _not_ get a `Test` task for every source set you declare, since not every source set represents tests! That's why you typically need to <<#sec:custom_java_source_sets,create your own `Test` tasks>> for things like integration and acceptance tests if they can't be included with the `test` source set.
   
   As there is a lot to cover when it comes to testing, the topic has its <<java_testing.adoc#java_testing,own chapter>> in which we look at:
   
    * How tests are run
    * How to run a subset of tests via filtering
    * How Gradle discovers tests
    * How to configure test reporting and add your own reporting tasks
    * How to make use of specific JUnit and TestNG features
   
   You can also learn more about configuring tests in the DSL reference for link:{groovyDslPath}#[Test].
   
   
   == Packaging and publishing
   
   How you package and potentially publish your Java project depends on what type of project it is.
   Libraries, applications, web applications and enterprise applications all have differing requirements.
   In this section, we will focus on the bare bones provided by the Java Library Plugin.
   
   By default, the Java Library Plugin provides the `jar` task that packages all the compiled production classes and resources into a single JAR.
   This JAR is also automatically built by the `assemble` task.
   Furthermore, the plugin can be configured to provide the `javadocJar` and `sourcesJar` tasks to package Javadoc and source code if so desired.
   If a publishing plugin is used, these tasks will automatically run during publishing or can be called directly.
   
   .Configure a project to publish Javadoc and sources
   ====
   include::sample[dir="snippets/signing/maven-publish/kotlin",files="build.gradle.kts[tags=defining-sources-jar-task]"]
   include::sample[dir="snippets/signing/maven-publish/groovy",files="build.gradle[tags=defining-sources-jar-task]"]
   ====
   
   If you want to create an 'uber' (AKA 'fat') JAR, then you can use a task definition like this:
   
   .Creating a Java uber or fat JAR
   ====
   include::sample[dir="snippets/files/archivesWithJavaPlugin/kotlin",files="build.gradle.kts[tags=create-uber-jar-example]"]
   include::sample[dir="snippets/files/archivesWithJavaPlugin/groovy",files="build.gradle[tags=create-uber-jar-example]"]
   ====
   
   See link:{groovyDslPath}#[Jar] for more details on the configuration options available to you.
   And note that you need to use `archiveClassifier` rather than `archiveAppendix` here for correct publication of the JAR.
   
   You can use one of the publishing plugins to publish the JARs created by a Java project:
   
    * <<publishing_maven.adoc#publishing_maven,Maven Publish Plugin>>
    * <<publishing_ivy.adoc#publishing_ivy,Ivy Publish Plugin>>
   
   === Modifying the JAR manifest
   
   Each instance of the `Jar`, `War` and `Ear` tasks has a `manifest` property that allows you to customize the _MANIFEST.MF_ file that goes into the corresponding archive. The following example demonstrates how to set attributes in the JAR's manifest:
   
   .Customization of MANIFEST.MF
   ====
   include::sample[dir="snippets/tutorial/manifest/kotlin",files="build.gradle.kts[tags=add-to-manifest]"]
   include::sample[dir="snippets/tutorial/manifest/groovy",files="build.gradle[tags=add-to-manifest]"]
   ====
   
   See link:{javadocPath}#[Manifest] for the configuration options it provides.
   
   You can also create standalone instances of `Manifest`. One reason for doing so is to share manifest information between JARs. The following example demonstrates how to share common attributes between JARs:
   
   .Creating a manifest object.
   ====
   include::sample[dir="snippets/tutorial/manifest/kotlin",files="build.gradle.kts[tags=custom-manifest]"]
   include::sample[dir="snippets/tutorial/manifest/groovy",files="build.gradle[tags=custom-manifest]"]
   ====
   
   Another option available to you is to merge manifests into a single `Manifest` object. Those source manifests can take the form of a text for or another `Manifest` object. In the following example, the source manifests are all text files except for `sharedManifest`, which is the `Manifest` object from the previous example:
   
   .Separate MANIFEST.MF for a particular archive
   ====
   include::sample[dir="snippets/tutorial/manifest/kotlin",files="build.gradle.kts[tags=merge]"]
   include::sample[dir="snippets/tutorial/manifest/groovy",files="build.gradle[tags=merge]"]
   ====
   
   Manifests are merged in the order they are declared in the `from` statement. If the base manifest and the merged manifest both define values for the same key, the merged manifest wins by default. You can fully customize the merge behavior by adding `eachEntry` actions in which you have access to a link:{javadocPath}#[ManifestMergeDetails] instance for each entry of the resulting manifest. Note that the merge is done lazily, either when generating the JAR or when `Manifest.writeTo()` or `Manifest.getEffectiveManifest()` are called.
   
   Speaking of `writeTo()`, you can use that to easily write a manifest to disk at any time, like so:
   
   .Saving a MANIFEST.MF to disk
   ====
   include::sample[dir="snippets/tutorial/manifest/kotlin",files="build.gradle.kts[tags=write]"]
   include::sample[dir="snippets/tutorial/manifest/groovy",files="build.gradle[tags=write]"]
   ====
   
   == Generating API documentation
   
   The Java Library Plugin provides a `javadoc` task of type link:{groovyDslPath}#[Javadoc], that will generate standard Javadocs for all your production code, i.e. whatever source is in the `main` source set.
   The task supports the core Javadoc and standard doclet options described in the link:{javadocReferenceUrl}#options[Javadoc reference documentation].
   See link:{javadocPath}#[CoreJavadocOptions] and link:{javadocPath}#[StandardJavadocDocletOptions] for a complete list of those options.
   
   As an example of what you can do, imagine you want to use Asciidoc syntax in your Javadoc comments. To do this, you need to add Asciidoclet to Javadoc's doclet path. Here's an example that does just that:
   
   .Using a custom doclet with Javadoc
   ====
   include::sample[dir="snippets/java/basic/kotlin",files="build.gradle.kts[tags=using-custom-doclet]"]
   include::sample[dir="snippets/java/basic/groovy",files="build.gradle[tags=using-custom-doclet]"]
   ====
   
   You don't have to create a configuration for this, but it's an elegant way to handle dependencies that are required for a unique purpose.
   
   You might also want to create your own Javadoc tasks, for example to generate API docs for the tests:
   
   .Defining a custom Javadoc task
   ====
   include::sample[dir="snippets/java/basic/kotlin",files="build.gradle.kts[tags=defining-custom-javadoc-task]"]
   include::sample[dir="snippets/java/basic/groovy",files="build.gradle[tags=defining-custom-javadoc-task]"]
   ====
   
   These are just two non-trivial but common customizations that you might come across.
   
   == Cleaning the build
   
   The Java Library Plugin adds a `clean` task to your project by virtue of applying the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   This task simply deletes everything in the `layout.buildDirectory` directory, hence why you should always put files generated by the build in there.
   The task is an instance of link:{groovyDslPath}#[Delete] and you can change what directory it deletes by setting its `dir` property.
   
   == Building JVM components
   
   All of the specific JVM plugins are built on top of the <<java_plugin.adoc#java_plugin,Java Plugin>>.
   The examples above only illustrated concepts provided by this base plugin and shared with all JVM plugins.
   
   Read on to understand which plugins fits which project type, as it is recommended to pick a specific plugin instead of applying the Java Plugin directly.
   
   == Building Java libraries
   
   The unique aspect of library projects is that they are used (or "consumed") by other Java projects.
   That means the dependency metadata published with the JAR file  usually in the form of a Maven POM 댹 is crucial.
   In particular, consumers of your library should be able to distinguish between two different types of dependencies: those that are only required to compile your library and those that are also required to compile the consumer.
   
   Gradle manages this distinction via the <<java_library_plugin.adoc#java_library_plugin,Java Library Plugin>>, which introduces an _api_ configuration in addition to the _implementation_ one covered in this chapter.
   If the types from a dependency appear in public fields or methods of your library's public classes, then that dependency is exposed via your library's public API and should therefore be added to the _api_ configuration.
   Otherwise, the dependency is an internal implementation detail and should be added to _implementation_.
   
   If you're unsure of the difference between an API and implementation dependency, the <<java_library_plugin.adoc#sec:java_library_recognizing_dependencies,Java Library Plugin chapter>> has a detailed explanation. In addition, you can explore a basic, practical link:#[sample of building a Java library].
   
   == Building Java applications
   
   Java applications packaged as a JAR aren't set up for easy launching from the command line or a desktop environment.
   The <<application_plugin.adoc#application_plugin,Application Plugin>> solves the command line aspect by creating a distribution that includes the production JAR, its dependencies and launch scripts Unix-like and Windows systems.
   
   See the plugin's chapter for more details, but here's a quick summary of what you get:
   
    * `assemble` creates ZIP and TAR distributions of the application containing everything needed to run it
    * A `run` task that starts the application from the build (for easy testing)
    * Shell and Windows Batch scripts to start the application
   
   You can see a basic example of building a Java application in the corresponding link:#[sample].
   
   
   == Building Java web applications
   
   Java web applications can be packaged and deployed in a number of ways depending on the technology you use. For example, you might use https://projects.spring.io/spring-boot/[Spring Boot] with a fat JAR or a https://www.reactivemanifesto.org/[Reactive]-based system running on https://netty.io/[Netty]. Whatever technology you use, Gradle and its large community of plugins will satisfy your needs. Core Gradle, though, only directly supports traditional Servlet-based web applications deployed as WAR files.
   
   That support comes via the <<war_plugin.adoc#war_plugin,War Plugin>>, which automatically applies the Java Plugin and adds an extra packaging step that does the following:
   
    * Copies static resources from _src/main/webapp_ into the root of the WAR
    * Copies the compiled production classes into a _WEB-INF/classes_ subdirectory of the WAR
    * Copies the library dependencies into a _WEB-INF/lib_ subdirectory of the WAR
   
   This is done by the `war` task, which effectively replaces the `jar` task  although that task remains 댹마nd is attached to the `assemble` lifecycle task. See the plugin's chapter for more details and configuration options.
   
   There is no core support for running your web application directly from the build, but we do recommend that you try the https://plugins.gradle.org/plugin/org.gretty[Gretty] community plugin, which provides an embedded Servlet container.
   
   == Building Java EE applications
   
   Java enterprise systems have changed a lot over the years, but if you're still deploying to JEE application servers, you can make use of the <<ear_plugin.adoc#ear_plugin,Ear Plugin>>. This adds conventions and a task for building EAR files. The plugin's chapter has more details.
   
   == Building Java Platforms
   
   A Java platform represents a set of dependency declarations and constraints that form a cohesive unit to be applied on consuming projects.
   The platform has no source and no artifact of its own.
   It maps in the Maven world to a https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Management[BOM].
   
   The support comes via the <<java_platform_plugin.adoc#java_platform_plugin,Java Platform plugin>>, which sets up the different configurations and publication components.
   
   NOTE: This plugin is the exception as it does not apply the Java Plugin.
   
   == Enabling Java preview features
   
   WARNING: Using a Java preview feature is very likely to make your code incompatible with that compiled without a feature preview.
   As a consequence, we strongly recommend you not to publish libraries compiled with preview features and restrict the use of feature previews to toy projects.
   
   To enable Java link:https://openjdk.java.net/jeps/12[preview features] for compilation, test execution and runtime, you can use the following DSL snippet:
   
   .Enabling Java feature preview
   ====
   include::sample[dir="snippets/java/preview/kotlin",files="build.gradle.kts[tags=enabling-feature-preview]"]
   include::sample[dir="snippets/java/preview/groovy",files="build.gradle[tags=enabling-feature-preview]"]
   ====
   
   == Building other JVM language projects
   
   If you want to leverage the multi language aspect of the JVM, most of what was described here will still apply.
   
   Gradle itself provides <<groovy_plugin.adoc#groovy_plugin,Groovy>> and <<scala_plugin.adoc#scala_plugin,Scala>> plugins.
   The plugins automatically apply support for compiling Java code and can be further enhanced by combining them with the `java-library` plugin.
   
   === Compilation dependency between languages
   
   These plugins create a dependency between Groovy/Scala compilation and Java compilation (of source code in the `java` folder of a source set).
   You can change this default behavior by adjusting the classpath of the involved compile tasks as shown in the following example:
   
   .Changing the classpath of compile tasks
   ====
   include::sample[dir="snippets/tutorial/compileTaskClasspath/kotlin",files="build.gradle.kts[tags=compile-task-classpath]"]
   include::sample[dir="snippets/tutorial/compileTaskClasspath/groovy",files="build.gradle[tags=compile-task-classpath]"]
   ====
   
   1. By setting the `compileGroovy` classpath to be only `sourceSets.main.compileClasspath`, we effectively remove the previous dependency on `compileJava` that was declared by having the classpath also take into consideration `sourceSets.main.java.classesDirectory`
   2. By adding `sourceSets.main.groovy.classesDirectory` to the `compileJava` `classpath`, we effectively declare a dependency on the `compileGroovy` task
   
   All of this is possible through the use of <<lazy_configuration.adoc#lazy_configuration,directory properties>>.
   
   === Extra language support
   
   Beyond core Gradle, there are other https://plugins.gradle.org/search?term=jvm[great plugins] for more JVM languages!

/docs/userguide/jvm/java_testing.adoc
=====================================

.. code-block::

   :metadata-file-spec: https://github.com/gradle/gradle/blob/master/platforms/documentation/docs/src/docs/design/gradle-module-metadata-1.0-specification.md
   
   = Testing in Java & JVM projects
   
   Testing on the JVM is a rich subject matter. There are many different testing libraries and frameworks, as well as many different types of test. All need to be part of the build, whether they are executed frequently or infrequently. This chapter is dedicated to explaining how Gradle handles differing requirements between and within builds, with significant coverage of how it integrates with the two most common testing frameworks: https://junit.org/[JUnit] and https://testng.org/[TestNG].
   
   It explains:
   
    * Ways to control how the tests are run (<<#sec:test_execution,Test execution>>)
    * How to select specific tests to run (<<#test_filtering,Test filtering>>)
    * What test reports are generated and how to influence the process (<<#test_reporting,Test reporting>>)
    * How Gradle finds tests to run (<<#sec:test_detection,Test detection>>)
    * How to make use of the major frameworks' mechanisms for grouping tests together (<<#test_grouping,Test grouping>>)
   
   But first, let's look at the basics of JVM testing in Gradle.
   
   NOTE: A new configuration DSL for modeling test execution phases is available via the incubating <<jvm_test_suite_plugin.adoc#jvm_test_suite_plugin,JVM Test Suite>> plugin.
   
   == The basics
   
   All JVM testing revolves around a single task type: link:{groovyDslPath}#[Test]. This runs a collection of test cases using any supported test library  JUnit, JUnit Platform or TestNG 댹마nd collates the results. You can then turn those results into a report via an instance of the link:{groovyDslPath}#[TestReport] task type.
   
   In order to operate, the `Test` task type requires just two pieces of information:
   
    * Where to find the compiled test classes (property: link:{groovyDslPath}#[Test.getTestClassesDirs()])
    * The execution classpath, which should include the classes under test as well as the test library that you're using (property: link:{groovyDslPath}#[Test.getClasspath()])
   
   When you're using a JVM language plugin  such as the <<java_plugin.adoc#java_plugin,Java Plugin>> 댹맟ou will automatically get the following:
   
    * A dedicated `test` source set for unit tests
    * A `test` task of type `Test` that runs those unit tests
   
   The JVM language plugins use the source set to configure the task with the appropriate execution classpath and the directory containing the compiled test classes. In addition, they attach the `test` task to the `check` <<lifecycle_tasks.adoc#sec:lifecycle_tasks,lifecycle task>>.
   
   It's also worth bearing in mind that the `test` source set automatically creates <<java_plugin.adoc#java_source_set_configurations,corresponding dependency configurations>>  of which the most useful are `testImplementation` and `testRuntimeOnly`  that the plugins tie into the `test` task's classpath.
   
   All you need to do in most cases is configure the appropriate compilation and runtime dependencies and add any necessary configuration to the `test` task. The following example shows a simple setup that uses JUnit Platform and changes the maximum heap size for the tests' JVM to 1 gigabyte:
   
   .A basic configuration for the 'test' task
   ====
   include::sample[dir="snippets/java/basic/kotlin",files="build.gradle.kts[tags=java-basic-test-config]"]
   include::sample[dir="snippets/java/basic/groovy",files="build.gradle[tags=java-basic-test-config]"]
   ====
   
   The link:{groovyDslPath}#[Test] task has many generic configuration options as well as several framework-specific ones that you can find described in link:{javadocPath}#[JUnitOptions], link:{javadocPath}#[JUnitPlatformOptions] and link:{javadocPath}#[TestNGOptions]. We cover a significant number of them in the rest of the chapter.
   
   If you want to set up your own `Test` task with its own set of test classes, then the easiest approach is to create your own source set and `Test` task instance, as shown in <<#sec:configuring_java_integration_tests,Configuring integration tests>>.
   
   == Test execution
   
   Gradle executes tests in a separate ('forked') JVM, isolated from the main build process. This prevents classpath pollution and excessive memory consumption for the build process. It also allows you to run the tests with different JVM arguments than the build is using.
   
   You can control how the test process is launched via several properties on the `Test` task, including the following:
   
   `maxParallelForks`  default: 1::
   You can run your tests in parallel by setting this property to a value greater than 1. This may make your test suites complete faster, particularly if you run them on a multi-core CPU. When using parallel test execution, make sure your tests are properly isolated from one another. Tests that interact with the filesystem are particularly prone to conflict, causing intermittent test failures.
   +
   Your tests can distinguish between parallel test processes by using the value of the `org.gradle.test.worker` property, which is unique for each process. You can use this for anything you want, but it's particularly useful for filenames and other resource identifiers to prevent the kind of conflict we just mentioned.
   
   `forkEvery`  default: 0 (no maximum)::
   This property specifies the maximum number of test classes that Gradle should run on a test process before its disposed of and a fresh one created. This is mainly used as a way to manage leaky tests or frameworks that have static state that can't be cleared or reset between tests.
   +
   *Warning: a low value (other than 0) can severely hurt the performance of the tests*
   
   `ignoreFailures`  default: false::
   If this property is `true`, Gradle will continue with the project's build once the tests have completed, even if some of them have failed. Note that, by default, the `Test` task always executes every test that it detects, irrespective of this setting.
   
   `failFast` 댹 (since Gradle 4.6) default: false::
   Set this to `true` if you want the build to fail and finish as soon as one of your tests fails. This can save a lot of time when you have a long-running test suite and is particularly useful when running the build on continuous integration servers. When a build fails before all tests have run, the test reports only include the results of the tests that have completed, successfully or not.
   +
   You can also enable this behavior by using the `--fail-fast` command line option, or disable it respectively with `--no-fail-fast`.
   
   `testLogging` 댹맋efault: _not set_::
   This property represents a set of options that control which test events are logged and at what level. You can also configure other logging behavior via this property. See link:{javadocPath}#[TestLoggingContainer] for more detail.
   
   `dryRun`  default: false::
   If this property is `true`, Gradle will simulate the execution of the tests without actually running them. This will still generate reports, allowing for inspection of what tests were selected. This can be used to verify that your test filtering configuration is correct without actually running the tests.
   +
   You can also enable this behavior by using the `--test-dry-run` command-line option, or disable it respectively with `--no-test-dry-run`.
   
   See link:{groovyDslPath}#[Test] for details on all the available configuration options.
   
   --
   The test process can exit unexpectedly if configured incorrectly. For instance, if the Java executable does not exist or an invalid JVM argument is provided, the test process will fail to start. Similarly, if a test makes programmatic changes to the test process, this can also cause unexpected failures.
   
   For example, issues may occur if a `{javaApi}/java/lang/SecurityManager.html[SecurityManager]` is modified in a test because
   Gradle's internal messaging depends on reflection and socket communication, which may be disrupted if the permissions on the security manager change. In this particular case, you should restore the original `SecurityManager` after the test so that the
   gradle test worker process can continue to function.
   --
   
   == Test filtering
   
   It's a common requirement to run subsets of a test suite, such as when you're fixing a bug or developing a new test case. Gradle provides two mechanisms to do this:
   
    * Filtering (the preferred option)
    * Test inclusion/exclusion
   
   Filtering supersedes the inclusion/exclusion mechanism, but you may still come across the latter in the wild.
   
   With Gradle's test filtering you can select tests to run based on:
   
    * A fully-qualified class name or fully qualified method name, e.g. `org.gradle.SomeTest`, `org.gradle.SomeTest.someMethod`
    * A simple class name or method name if the pattern starts with an upper-case letter, e.g. `SomeTest`, `SomeTest.someMethod` (since Gradle 4.7)
    * '*' wildcard matching
   
   You can enable filtering either in the build script or via the `--tests` command-line option. Here's an example of some filters that are applied every time the build runs:
   
   .Filtering tests in the build script
   ====
   include::sample[dir="snippets/testing/filtering/kotlin",files="build.gradle.kts[tags=test-filtering]"]
   include::sample[dir="snippets/testing/filtering/groovy",files="build.gradle[tags=test-filtering]"]
   ====
   
   For more details and examples of declaring filters in the build script, please see the link:{javadocPath}#[TestFilter] reference.
   
   The command-line option is especially useful to execute a single test method. When you use `--tests`, be aware that the inclusions declared in the build script are still honored. It is also possible to supply multiple `--tests` options, all of whose patterns will take effect. The following sections have several examples of using the command-line option.
   
   NOTE: Not all test frameworks play well with filtering. Some advanced, synthetic tests may not be fully compatible.
   However, the vast majority of tests and use cases work perfectly well with Gradle's filtering mechanism.
   
   The following two sections look at the specific cases of simple class/method names and fully-qualified names.
   
   === Simple name pattern
   
   Since 4.7, Gradle has treated a pattern starting with an uppercase letter as a simple class name, or a class name + method name. For example, the following command lines run either all or exactly one of the tests in the `SomeTestClass` test case, regardless of what  package it's in:
   
   ```
   # Executes all tests in SomeTestClass
   gradle test --tests SomeTestClass
   
   # Executes a single specified test in SomeTestClass
   gradle test --tests SomeTestClass.someSpecificMethod
   
   gradle test --tests SomeTestClass.*someMethod*
   ```
   
   === Fully-qualified name pattern
   
   Prior to 4.7 or if the pattern doesn't start with an uppercase letter, Gradle treats the pattern as fully-qualified. So if you want to use the test class name irrespective of its package, you would use `--tests *.SomeTestClass`. Here are some more examples:
   
   ```
   # specific class
   gradle test --tests org.gradle.SomeTestClass
   
   # specific class and method
   gradle test --tests org.gradle.SomeTestClass.someSpecificMethod
   
   # method name containing spaces
   gradle test --tests "org.gradle.SomeTestClass.some method containing spaces"
   
   # all classes at specific package (recursively)
   gradle test --tests 'all.in.specific.package*'
   
   # specific method at specific package (recursively)
   gradle test --tests 'all.in.specific.package*.someSpecificMethod'
   
   gradle test --tests '*IntegTest'
   
   gradle test --tests '*IntegTest*ui*'
   
   gradle test --tests '*ParameterizedTest.foo*'
   
   # the second iteration of a parameterized test
   gradle test --tests '*ParameterizedTest.*[2]'
   ```
   
   Note that the wildcard '*' has no special understanding of the '.' package separator. It's purely text based. So `--tests *.SomeTestClass` will match any package, regardless of its 'depth'.
   
   You can also combine filters defined at the command line with <<command_line_interface.adoc#sec:continuous_build, continuous build>> to re-execute a subset of tests immediately after every change to a production or test source file. The following executes all tests in the 'com.mypackage.foo' package or subpackages whenever a change triggers the tests to run:
   
   ```
   gradle test --continuous --tests "com.mypackage.foo.*"
   ```
   
   == Test reporting
   
   The `Test` task generates the following results by default:
   
    * An HTML test report
    * XML test results in a format compatible with the Ant JUnit report task 댹맖ne that is supported by many other tools, such as CI servers
    * An efficient binary format of the results used by the `Test` task to generate the other formats
   
   In most cases, you'll work with the standard HTML report, which automatically includes the results from _all_ your `Test` tasks, even the ones you explicitly add to the build yourself. For example, if you add a `Test` task for integration tests, the report will include the results of both the unit tests and the integration tests if both tasks are run.
   
   NOTE: To aggregate test results across multiple subprojects, see the <<test_report_aggregation_plugin#test_report_aggregation_plugin,Test Report Aggregation Plugin>>.
   
   Unlike with many of the testing configuration options, there are several project-level <<java_plugin.adoc#sec:java_convention_properties,convention properties that affect the test reports>>. For example, you can change the destination of the test results and reports like so:
   
   .Changing the default test report and results directories
   ====
   include::sample[dir="snippets/java/customDirs/kotlin",files="build.gradle.kts[tags=custom-report-dirs]"]
   include::sample[dir="snippets/java/customDirs/groovy",files="build.gradle[tags=custom-report-dirs]"]
   ====
   
   .Output of **`gradle -q showDirs`**
   ----
   > gradle -q showDirs
   include::{snippetsPath}/java/customDirs/tests/javaCustomReportDirs.out[]
   ----
   
   Follow the link to the convention properties for more details.
   
   There is also a standalone link:{groovyDslPath}#[TestReport] task type that you can use to generate a custom HTML test report. All it requires are a value for `destinationDir` and the test results you want included in the report. Here is a sample which generates a combined report for the unit tests from all subprojects:
   
   .Creating a unit test report for subprojects
   ====
   include::sample[dir="snippets/testing/testReport/kotlin",files="buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts[tags=test-report];build.gradle.kts[tags=test-report]"]
   include::sample[dir="snippets/testing/testReport/groovy",files="buildSrc/src/main/groovy/myproject.java-conventions.gradle[tags=test-report];build.gradle[tags=test-report]"]
   ====
   
   In this example, we use a convention plugin `myproject.java-conventions` to expose the test results from a project to Gradle's <<variant_model.adoc#understanding-variant-selection,variant aware dependency management engine>>.
   
   The plugin declares a consumable `binaryTestResultsElements` configuration that represents the binary test results of the `test` task.
   In the aggregation project's build file, we declare the `testReportData` configuration and depend on all of the projects that we want to aggregate the results from. Gradle will automatically select the binary test result variant from each of the subprojects instead of the project's jar file.
   Lastly, we add a `testReport` task that aggregates the test results from the `testResultsDirs` property, which contains all of the binary test results resolved from the `testReportData` configuration.
   
   You should note that the `TestReport` type combines the results from multiple test tasks and needs to aggregate the results of individual test classes. This means that if a given test class is executed by multiple test tasks, then the test report will include executions of that class, but it can be hard to distinguish individual executions of that class and their output.
   
   === Communicating test results to CI servers and other tools via XML files
   
   The Test tasks creates XML files describing the test results, in the JUnit XML pseudo standard.
   It is common for CI servers and other tooling to observe test results via these XML files.
   
   By default, the files are written to `layout.buildDirectory.dir("test-results/$testTaskName")` with a file per test class.
   The location can be changed for all test tasks of a project, or individually per test task.
   
   .Changing JUnit XML results location for all test tasks
   ====
   include::sample[dir="snippets/testing/junit-xml-results/kotlin",files="build.gradle.kts[tags=configure-location-convention]"]
   include::sample[dir="snippets/testing/junit-xml-results/groovy",files="build.gradle[tags=configure-location-convention]"]
   ====
   
   With the above configuration, the XML files will be written to `layout.buildDirectory.dir("junit-xml/$testTaskName")`.
   
   .Changing JUnit XML results location for a particular test task
   ====
   include::sample[dir="snippets/testing/junit-xml-results/kotlin",files="build.gradle.kts[tags=configure-location-task]"]
   include::sample[dir="snippets/testing/junit-xml-results/groovy",files="build.gradle[tags=configure-location-task]"]
   ====
   
   With the above configuration, the XML files for the `test` task will be written to `layout.buildDirectory.dir("test-results/test-junit-xml")`.
   The location of the XML files for other test tasks will be unchanged.
   
   ==== Configuration options
   
   The content of the XML files can also be configured to convey the results differently, by configuring the
   link:{javadocPath}#[JUnitXmlReport] options.
   
   .Configuring how the results are conveyed
   ====
   include::sample[dir="snippets/testing/junit-xml-results/kotlin",files="build.gradle.kts[tags=configure-content]"]
   include::sample[dir="snippets/testing/junit-xml-results/groovy",files="build.gradle[tags=configure-content]"]
   ====
   
   ===== outputPerTestCase
   
   The `outputPerTestCase` option, when enabled, associates any output logging generated during a test case to that test case in the results.
   When disabled (the default) output is associated with the test class as whole and not the individual test cases (e.g. test methods) that produced the logging output.
   Most modern tools that observe JUnit XML files support the 랊utput per test case format.
   
   If you are using the XML files to communicate test results, it is recommended to enable this option as it provides more useful reporting.
   
   ===== mergeReruns
   
   When `mergeReruns` is enabled, if a test fails but is then retried and succeeds, its failures will be recorded as `<flakyFailure>` instead of `<failure>`, within one `<testcase>`.
   This is effectively the reporting produced by the link:https://maven.apache.org/components/surefire/maven-surefire-plugin/examples/rerun-failing-tests.html[surefire plugin of Apache Maven묗 when enabling reruns.
   If your CI server understands this format, it will indicate that the test was flaky.
   If it does not, it will indicate that the test succeeded as it will ignore the `<flakyFailure>` information.
   If the test does not succeed (i.e. it fails for every retry), it will be indicated as having failed whether your tool understands this format or not.
   
   When `mergeReruns` is disabled (the default), each execution of a test will be listed as a separate test case.
   
   If you are using link:https://scans.gradle.com[build scans] or link:https://gradle.com/gradle-enterprise-solution-overview/failure-analytics/[Develocity],
   flaky tests will be detected regardless of this setting.
   
   Enabling this option is especially useful when using a CI tool that uses the XML test results to determine build failure instead of relying on Gradle's determination of whether the build failed or not,
   and you wish to not consider the build failed if all failed tests passed when retried.
   This is the case for the Jenkins CI server and its link:https://plugins.jenkins.io/junit/[JUnit plugin].
   With `mergeReruns` enabled, tests that pass-on-retry will no longer cause this Jenkins plugin to consider the build to have failed.
   However, failed test executions will be omitted from the Jenkins test result visualizations as it does not consider `<flakyFailure>` information.
   The separate link:https://plugins.jenkins.io/flaky-test-handler[Flaky Test Handler Jenkins plugin] can be used in addition to the JUnit Jenkins plugin to have such 랁laky failures also be visualized.
   
   Tests are grouped and merged based on their reported name.
   When using any kind of test parameterization that affects the reported test name,
   or any other kind of mechanism that produces a potentially dynamic test name,
   care should be taken to ensure that the test name is stable and does not unnecessarily change.
   
   Enabling the `mergeReruns` option does not add any retry/rerun functionality to test execution.
   Rerunning can be enabled by the test execution framework (e.g. JUnit's link:https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[@RepeatedTest]),
   or via the separate link:https://github.com/gradle/test-retry-gradle-plugin[Test Retry Gradle plugin].
   
   == Test detection
   
   By default, Gradle will run all tests that it detects, which it does by inspecting the compiled test classes. This detection uses different criteria depending on the test framework used.
   
   For _JUnit_, Gradle scans for both JUnit 3 and 4 test classes. A class is considered to be a JUnit test if it:
   
    * Ultimately inherits from `TestCase` or `GroovyTestCase`
    * Is annotated with `@RunWith`
    * Contains a method annotated with `@Test` or a super class does
   
   For _TestNG_, Gradle scans for methods annotated with `@Test`.
   
   Note that abstract classes are not executed. In addition, be aware that Gradle scans up the inheritance tree into jar files on the test classpath. So if those JARs contain test classes, they will also be run.
   
   If you don't want to use test class detection, you can disable it by setting the `scanForTestClasses` property on link:{groovyDslPath}#[Test] to `false`. When you do that, the test task uses only the `includes` and `excludes` properties to find test classes.
   
   If `scanForTestClasses` is false and no include or exclude patterns are specified, Gradle defaults to running any class that matches the patterns `+**/*Tests.class+` and `+**/*Test.class+`, excluding those that match `+**/Abstract*.class+`.
   
   NOTE: With http://junit.org/junit5/docs/current/user-guide[JUnit Platform], only `includes` and `excludes` are used to filter test classes  `scanForTestClasses` has no effect.
   
   == Test logging
   
   Gradle allows fine-tuned control over events that are logged to the console.
   Logging is configurable on a per-log-level basis and by default, the following events are logged:
   
   [cols="1,1,1"]
   |===
   |When the log level is |Events that are logged | Additional configuration
   | `ERROR`, `QUIET` or `WARNING`
   | None
   | None
   | `LIFECYCLE`
   | link:{javadocPath}#[Test failures]
   | Exception format is link:{javadocPath}#[SHORT]
   | `INFO`
   | link:{javadocPath}#[Test failures], link:{javadocPath}#[skipped tests], link:{javadocPath}#[test standard output] and link:{javadocPath}#[test standard error]
   | Stacktraces are truncated.
   | `DEBUG`
   | link:{javadocPath}#[All events]
   | Full stacktraces are logged.
   |===
   
   Test logging can be modified on a per-log-level basis by adjusting the appropriate link:{javadocPath}#[TestLogging] instances in the link:{javadocPath}#[testLogging] property of the test task.
   For example, to adjust the `INFO` level test logging configuration, modify the
   link:{javadocPath}#[TestLoggingContainer.getInfo()] property.
   
   == Test grouping
   
   JUnit, JUnit Platform and TestNG allow sophisticated groupings of test methods.
   
   NOTE: This section applies to grouping individual test classes or methods within a collection of tests that serve the same testing purpose (unit tests, integration tests, acceptance tests, etc.).
   For dividing test classes based upon their purpose, see the incubating <<jvm_test_suite_plugin.adoc#jvm_test_suite_plugin,JVM Test Suite>> plugin.
   
   JUnit 4.8 introduced the concept of categories for grouping JUnit 4 tests classes and methods.footnote:[The JUnit wiki contains a detailed description on how to work with JUnit categories: https://github.com/junit-team/junit/wiki/Categories[].] link:{groovyDslPath}#[Test.useJUnit(org.gradle.api.Action)] allows you to specify the JUnit categories you want to include and exclude. For example, the following configuration includes tests in `CategoryA` and excludes those in `CategoryB` for the `test` task:
   
   .JUnit Categories
   ====
   include::sample[dir="snippets/testing/junit-categories/kotlin",files="build.gradle.kts[tags=test-categories]"]
   include::sample[dir="snippets/testing/junit-categories/groovy",files="build.gradle[tags=test-categories]"]
   ====
   
   http://junit.org/junit5/docs/current/user-guide[JUnit Platform] introduced http://junit.org/junit5/docs/current/user-guide/#writing-tests-tagging-and-filtering[tagging] to replace categories. You can specify the included/excluded tags via link:{javadocPath}#[Test.useJUnitPlatform(org.gradle.api.Action)], as follows:
   
   .JUnit Platform Tags
   ====
   include::sample[dir="snippets/testing/junitplatform-tagging/kotlin",files="build.gradle.kts[tags=test-tags]"]
   include::sample[dir="snippets/testing/junitplatform-tagging/groovy",files="build.gradle[tags=test-tags]"]
   ====
   
   The TestNG framework uses the concept of test groups for a similar effect.footnote:[The TestNG documentation contains more details about test groups: http://testng.org/doc/documentation-main.html#test-groups[].] You can configure which test groups to include or exclude during the test execution via the link:{groovyDslPath}#[Test.useTestNG(org.gradle.api.Action)] setting, as seen here:
   
   .Grouping TestNG tests
   ====
   include::sample[dir="snippets/testing/testng-groups/kotlin",files="build.gradle.kts[tags=test-config]"]
   include::sample[dir="snippets/testing/testng-groups/groovy",files="build.gradle[tags=test-config]"]
   ====
   
   == Using JUnit 5
   
   http://junit.org/junit5[JUnit 5] is the latest version of the well-known JUnit test framework.
   Unlike its predecessor, JUnit 5 is modularized and composed of several modules:
   
       JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage
   
   The JUnit Platform serves as a foundation for launching testing frameworks on the JVM. JUnit Jupiter is the combination of the new http://junit.org/junit5/docs/current/user-guide/#writing-tests[programming model]
    and http://junit.org/junit5/docs/current/user-guide/#extensions[extension model] for writing tests and extensions in JUnit 5. JUnit Vintage provides a `TestEngine` for running JUnit 3 and JUnit 4 based tests on the platform.
   
   The following code enables JUnit Platform support in `build.gradle`:
   
   .Enabling JUnit Platform to run your tests
   ====
   include::sample[dir="snippets/testing/junitplatform-jupiter/kotlin",files="build.gradle.kts[tags=enabling-junit-platform]"]
   include::sample[dir="snippets/testing/junitplatform-jupiter/groovy",files="build.gradle[tags=enabling-junit-platform]"]
   ====
   
   See link:{javadocPath}#[Test.useJUnitPlatform()] for more details.
   
   === Compiling and executing JUnit Jupiter tests
   
   To enable JUnit Jupiter support in Gradle, all you need to do is add the following dependency:
   
   .JUnit Jupiter dependencies
   ====
   include::sample[dir="snippets/testing/junitplatform-jupiter/kotlin",files="build.gradle.kts[tags=jupiter-dependencies]"]
   include::sample[dir="snippets/testing/junitplatform-jupiter/groovy",files="build.gradle[tags=jupiter-dependencies]"]
   ====
   
   You can then put your test cases into _src/test/java_ as normal and execute them with `gradle test`.
   
   === Executing legacy tests with JUnit Vintage
   
   If you want to run JUnit 3/4 tests on JUnit Platform, or even mix them with Jupiter tests, you should add extra JUnit Vintage Engine dependencies:
   
   .JUnit Vintage dependencies
   ====
   include::sample[dir="snippets/testing/junitplatform-mix/kotlin",files="build.gradle.kts[tags=vintage-dependencies]"]
   include::sample[dir="snippets/testing/junitplatform-mix/groovy",files="build.gradle[tags=vintage-dependencies]"]
   ====
   
   In this way, you can use `gradle test` to test JUnit 3/4 tests on JUnit Platform, without the need to rewrite them.
   
   === Filtering test engine
   
   JUnit Platform allows you to use different test engines. JUnit currently provides two `TestEngine` implementations out of the box:
   https://junit.org/junit5/docs/current/api/org.junit.jupiter.engine/module-summary.html[junit-jupiter-engine] and https://junit.org/junit5/docs/current/api/org.junit.vintage.engine/module-summary.html[junit-vintage-engine].
   You can also write and plug in your own `TestEngine` implementation as documented https://junit.org/junit5/docs/current/user-guide/#launcher-api-engines-custom[here].
   
   By default, all test engines on the test runtime classpath will be used.
   To control specific test engine implementations explicitly, you can add the following setting to your build script:
   
   .Filter specific engines
   ====
   include::sample[dir="snippets/testing/junitplatform-engine/kotlin",files="build.gradle.kts[tags=filter-engine]"]
   include::sample[dir="snippets/testing/junitplatform-engine/groovy",files="build.gradle[tags=filter-engine]"]
   ====
   
   == Test execution order in TestNG
   
   TestNG allows explicit control of the execution order of tests when you use a _testng.xml_ file. Without such a file  or an equivalent one configured by link:{javadocPath}#[TestNGOptions.getSuiteXmlBuilder()]  you can't specify the test execution order. However, what you _can_ do is control whether all aspects of a test  including its associated `@BeforeXXX` and `@AfterXXX` methods, such as those annotated with `@Before/AfterClass` and `@Before/AfterMethod`먹댹마re executed before the next test starts. You do this by setting the link:{javadocPath}#[TestNGOptions.getPreserveOrder()] property to `true`. If you set it to `false`, you may encounter scenarios in which the execution order is something like: `TestA.doBeforeClass()` -> `TestB.doBeforeClass()` -> `TestA` tests.
   
   While preserving the order of tests is the default behavior when directly working with _testng.xml_ files, the https://jitpack.io/com/github/cbeust/testng/master/javadoc/org/testng/TestNG.html[TestNG API] that is used by Gradle's TestNG integration executes tests in unpredictable order by default.footnote:[The TestNG documentation contains more details about test ordering when working with `testng.xml` files: http://testng.org/doc/documentation-main.html#testng-xml[].] The ability to preserve test execution order was introduced with TestNG version 5.14.5. Setting the `preserveOrder` property to `true` for an older TestNG version will cause the build to fail.
   
   .Preserving order of TestNG tests
   ====
   include::sample[dir="snippets/testing/testng-preserveorder/kotlin",files="build.gradle.kts[tags=test-config]"]
   include::sample[dir="snippets/testing/testng-preserveorder/groovy",files="build.gradle[tags=test-config]"]
   ====
   
   The `groupByInstance` property controls whether tests should be grouped by instance rather than by class. The http://testng.org/doc/documentation-main.html#dependencies-with-annotations[TestNG documentation] explains the difference in more detail, but essentially, if you have a test method `A()` that depends on `B()`, grouping by instance ensures that each A-B pairing, e.g. `B(1)`-`A(1)`, is executed before the next pairing. With group by class, all `B()` methods are run and then all `A()` ones.
   
   Note that you typically only have more than one instance of a test if you're using a data provider to parameterize it. Also, grouping tests by instances was introduced with TestNG version 6.1. Setting the `groupByInstances` property to `true` for an older TestNG version will cause the build to fail.
   
   .Grouping TestNG tests by instances
   ====
   include::sample[dir="snippets/testing/testng-groupbyinstances/kotlin",files="build.gradle.kts[tags=test-config]"]
   include::sample[dir="snippets/testing/testng-groupbyinstances/groovy",files="build.gradle[tags=test-config]"]
   ====
   
   === TestNG parameterized methods and reporting
   
   TestNG supports http://testng.org/doc/documentation-main.html#parameters[parameterizing test methods], allowing a particular test method to be executed multiple times with different inputs. Gradle includes the parameter values in its reporting of the test method execution.
   
   Given a parameterized test method named `aTestMethod` that takes two parameters, it will be reported with the name `aTestMethod(toStringValueOfParam1, toStringValueOfParam2)`. This makes it easy to identify the parameter values for a particular iteration.
   
   
   == Configuring integration tests
   
   A common requirement for projects is to incorporate integration tests in one form or another.
   Their aim is to verify that the various parts of the project are working together properly.
   This often means that they require special execution setup and dependencies compared to unit tests.
   
   The simplest way to add integration tests to your build is by leveraging the incubating <<jvm_test_suite_plugin.adoc#jvm_test_suite_plugin,JVM Test Suite>> plugin.
   If an incubating solution is not something for you, here are the steps you need to take in your build:
   
    1. Create a new <<building_java_projects.adoc#sec:java_source_sets,source set>> for them
    2. Add the dependencies you need to the appropriate configurations for that source set
    3. Configure the compilation and runtime classpaths for that source set
    4. Create a task to run the integration tests
   
   You may also need to perform some additional configuration depending on what form the integration tests take. We will discuss those as we go.
   
   Let's start with a practical example that implements the first three steps in a build script, centered around a new source set `intTest`:
   
   .Setting up working integration tests
   ====
   include::sample[dir="snippets/java/basic/kotlin",files="build.gradle.kts[tags=practical-integ-test-source-set]"]
   include::sample[dir="snippets/java/basic/groovy",files="build.gradle[tags=practical-integ-test-source-set]"]
   ====
   
   This will set up a new source set called `intTest` that automatically creates:
   
    * `intTestImplementation`, `intTestCompileOnly`, `intTestRuntimeOnly` configurations (and <<java_plugin.adoc#java_source_set_configurations, a few others>> that are less commonly needed)
    * A `compileIntTestJava` task that will compile all the source files under _src/intTest/java_
   
   NOTE: If you are working with the IntelliJ IDE, you may wish to flag the directories in these additional source sets as containing test source rather than production source as explained in the <<idea_plugin.adoc#sec:idea_identify_additional_source_sets,Idea Plugin>> documentation.
   
   The example also does the following, not all of which you may need for your specific integration tests:
   
    * Adds the production classes from the `main` source set to the compilation and runtime classpaths of the integration tests  `sourceSets.main.output` is a <<working_with_files.adoc#sec:file_collections,file collection>> of all the directories containing compiled production classes and resources
    * Makes the `intTestImplementation` configuration extend from `implementation`, which means that all the declared dependencies of the production code also become dependencies of the integration tests
    * Does the same for the `intTestRuntimeOnly` configuration
   
   In most cases, you want your integration tests to have access to the classes under test, which is why we ensure that those are included on the compilation and runtime classpaths in this example. But some types of test interact with the production code in a different way. For example, you may have tests that run your application as an executable and verify the output. In the case of web applications, the tests may interact with your application via HTTP. Since the tests don't need direct access to the classes under test in such cases, you don't need to add the production classes to the test classpath.
   
   Another common step is to attach all the unit test dependencies to the integration tests as well  via `intTestImplementation.extendsFrom testImplementation`  but that only makes sense if the integration tests require _all_ or nearly all the same dependencies that the unit tests have.
   
   There are a couple of other facets of the example you should take note of:
   
    * `+=` allows you to append paths and collections of paths to `compileClasspath` and `runtimeClasspath` instead of overwriting them
    * If you want to use the convention-based configurations, such as `intTestImplementation`, you _must_ declare the dependencies _after_ the new source set
   
   Creating and configuring a source set automatically sets up the compilation stage, but it does nothing with respect to running the integration tests. So the last piece of the puzzle is a custom test task that uses the information from the new source set to configure its runtime classpath and the test classes:
   
   .Defining a working integration test task
   ====
   include::sample[dir="snippets/java/basic/kotlin",files="build.gradle.kts[tags=integ-test-task]"]
   include::sample[dir="snippets/java/basic/groovy",files="build.gradle[tags=integ-test-task]"]
   ====
   
   Again, we're accessing a source set to get the relevant information, i.e. where the compiled test classes are 댹맚he `testClassesDirs` property 댹마nd what needs to be on the classpath when running them 댹`classpath`.
   
   Users commonly want to run integration tests after the unit tests, because they are often slower to run and you want the build to fail early on the unit tests rather than later on the integration tests. That's why the above example adds a `shouldRunAfter()` declaration. This is preferred over `mustRunAfter()` so that Gradle has more flexibility in executing the build in parallel.
   
   For information on how to determine code coverage for tests in additional source sets, see the <<jacoco_plugin#jacoco_plugin,JaCoCo Plugin>> and the <<jacoco_report_aggregation_plugin#jacoco_report_aggregation_plugin, JaCoCo Report Aggregation Plugin>> chapters.
   
   == Testing Java Modules
   
   If you are <<java_library_plugin.adoc#java_library_plugin,developing Java Modules>>, everything described in this chapter still applies and any of the supported test frameworks can be used.
   However, there are some things to consider depending on whether you need module information to be available, and module boundaries to be enforced, during test execution.
   In this context, the terms _whitebox testing_ (module boundaries are deactivated or relaxed) and _blackbox testing_ (module boundaries are in place) are often used.
   Whitebox testing is used/needed for unit testing and blackbox testing fits functional or integration test requirements.
   
   Sample: link:#[Java Modules multi-project with integration tests]
   
   === Whitebox unit test execution on the classpath
   
   The simplest setup to write unit tests for functions or classes in modules is to _not_ use module specifics during test execution.
   For this, you just need to write tests the same way you would write them for normal libraries.
   If you don't have a `module-info.java` file in your test source set (`src/test/java`) this source set will be considered as traditional Java library during compilation and test runtime.
   This means, all dependencies, including Jars with module information, are put on the classpath.
   The advantage is that all internal classes of your (or other) modules are then accessible directly in tests.
   This may be a totally valid setup for unit testing, where we do not care about the larger module structure, but only about testing single functions.
   
   [NOTE]
   ====
   If you are using Eclipse: By default, Eclipse also runs unit tests as modules using module patching (see <<#sec:java_testing_modular_patching,below>>).
   In an imported Gradle project, unit testing a module with the Eclipse test runner might fail.
   You then need to manually adjust the classpath/module path in the test run configuration or delegate test execution to Gradle.
   
   This only concerns the test execution.
   Unit test compilation and development works fine in Eclipse.
   ====
   
   === Blackbox integration testing
   
   For integration tests, you have the option to define the test set itself as additional module.
   You do this similar to how you turn your main sources into a module:
   by adding a `module-info.java` file to the corresponding source set (e.g. `integrationTests/java/module-info.java`).
   
   You can find a full example that includes blackbox integration tests link:#[here].
   
   NOTE: In Eclipse, compiling multiple modules in one project is https://bugs.eclipse.org/bugs/show_bug.cgi?id=520667[currently not support].
   Therefore the integration test (blackbox) setup described here only works in Eclipse if the tests are moved to a separate subproject.
   
   === Whitebox test execution with module patching
   
   Another approach for whitebox testing is to stay in the module world by _patching_ the tests into the module under test.
   This way, module boundaries stay in place, but the tests themselves become part of the module under test and can then access the module's internals.
   
   For which uses cases this is relevant and how this is best done is a topic of discussion.
   There is no general best approach at the moment.
   Thus, there is no special support for this in Gradle right now.
   
   You can however, setup module patching for tests like this:
   
   * Add a `module-info.java` to your test source set that is a copy of the main `module-info.java` with additional dependencies needed for testing (e.g. `requires org.junit.jupiter.api`).
   * Configure both the `testCompileJava` and `test` tasks with arguments to patch the main classes with the test classes as shown below.
   
   .Patch module for testing using command line arguments
   ====
   include::sample[dir="snippets/testing/patch-module/kotlin",files="build.gradle.kts[tags=patchArgs]"]
   include::sample[dir="snippets/testing/patch-module/groovy",files="build.gradle[tags=patchArgs]"]
   ====
   
   NOTE: If custom arguments are used for patching, these are not picked up by Eclipse and IDEA.
   You will most likely see invalid compilation errors in the IDE.
   
   == Skipping the tests
   
   If you want to skip the tests when running a build, you have a few options. You can either do it via <<command_line_interface.adoc#sec:excluding_tasks_from_the_command_line,command line arguments>> or <<more_about_tasks.adoc#sec:skipping_tasks,in the build script>>. To do it on the command line, you can use the `-x` or `--exclude-task` option like so:
   
       gradle build -x test
   
   This excludes the `test` task and any other task that it _exclusively_ depends on, i.e. no other task depends on the same task. Those tasks will not be marked "SKIPPED" by Gradle, but will simply not appear in the list of tasks executed.
   
   Skipping a test via the build script can be done a few ways. One common approach is to make test execution conditional via the link:{groovyDslPath}#[Task.onlyIf(String, org.gradle.api.specs.Spec)] method. The following sample skips the `test` task if the project has a property called `mySkipTests`:
   
   .Skipping the unit tests based on a project property
   ====
   include::sample[dir="snippets/java/basic/kotlin",files="build.gradle.kts[tags=skip-tests-condition]"]
   include::sample[dir="snippets/java/basic/groovy",files="build.gradle[tags=skip-tests-condition]"]
   ====
   
   In this case, Gradle will mark the skipped tests as "SKIPPED" rather than exclude them from the build.
   
   == Forcing tests to run
   
   In well-defined builds, you can rely on Gradle to only run tests if the tests themselves or the production code change. However, you may encounter situations where the tests rely on a third-party service or something else that might change but can't be modeled in the build.
   
   You can always use the `--rerun` <<command_line_interface.adoc#sec:builtin_task_options,built-in task option>> to force a task to rerun.
   
       gradle test --rerun
   
   Alternatively, if <<build_cache.adoc#sec:build_cache_enable,build caching>> is not enabled, you can also force tests to run by cleaning the output of the relevant `Test` task  say `test`  and running the tests again, like so:
   
       gradle cleanTest test
   
   `cleanTest` is based on a <<more_about_tasks.adoc#sec:task_rules,task rule>> provided by the <<base_plugin.adoc#sec:base_tasks,Base Plugin>>. You can use it for _any_ task.
   
   == Debugging when running tests
   
   On the few occasions that you want to debug your code while the tests are running, it can be helpful if you can attach a debugger at that point. You can either set the link:{groovyDslPath}#[Test.getDebug()] property to `true` or use the `--debug-jvm` command line option, or use `--no-debug-jvm` to set it to false.
   
   When debugging for tests is enabled, Gradle will start the test process suspended and listening on port 5005.
   
   You can also enable debugging in the DSL, where you can also configure other properties:
   
       test {
           debugOptions {
               enabled = true
               host = 'localhost'
               port = 4455
               server = true
               suspend = true
           }
       }
   
   With this configuration the test JVM will behave just like when passing the `--debug-jvm` argument but it will listen on port 4455.
   
   To debug the test process remotely via network,  the `host` needs to be set to the machine's IP address or `"*"` (listen on all interfaces).
   
   == Using test fixtures
   
   === Producing and using test fixtures within a single project
   
   Test fixtures are commonly used to setup the code under test, or provide utilities aimed at facilitating the tests of a component.
   Java projects can enable test fixtures support by applying the `java-test-fixtures` plugin, in addition to the `java` or `java-library` plugins:
   
   .Applying the Java test fixtures plugin
   ====
   include::sample[dir="snippets/java/fixtures/kotlin",files="lib/build.gradle.kts[tags=use-plugin]"]
   include::sample[dir="snippets/java/fixtures/groovy",files="lib/build.gradle[tags=use-plugin]"]
   ====
   
   This will automatically create a `testFixtures` source set, in which you can write your test fixtures.
   Test fixtures are configured so that:
   
   - they can see the _main_ source set classes
   - _test_ sources can see the _test fixtures_ classes
   
   For example for this main class:
   
   [source,java,indent=0]
   .src/main/java/com/acme/Person.java
   ----
   include::{snippetsPath}/java/fixtures/groovy/lib/src/main/java/com/acme/Person.java[tags=sample]
   ----
   
   A test fixture can be written in `src/testFixtures/java`:
   
   [source,java,indent=0]
   .src/testFixtures/java/com/acme/Simpsons.java
   ----
   include::{snippetsPath}/java/fixtures/groovy/lib/src/testFixtures/java/com/acme/Simpsons.java[tags=sample]
   ----
   
   === Declaring dependencies of test fixtures
   
   Similarly to the link:#[Java Library Plugin], test fixtures expose an API and an implementation configuration:
   
   .Declaring test fixture dependencies
   ====
   include::sample[dir="snippets/java/fixtures/kotlin",files="lib/build.gradle.kts[tags=test_fixtures_deps]"]
   include::sample[dir="snippets/java/fixtures/groovy",files="lib/build.gradle[tags=test_fixtures_deps]"]
   ====
   
   It's worth noticing that if a dependency is an _implementation_ dependency of test fixtures, then _when compiling tests that depend on those test fixtures_, the implementation dependencies will _not leak_ into the compile classpath.
   This results in improved separation of concerns and better compile avoidance.
   
   === Consuming test fixtures of another project
   
   Test fixtures are not limited to a single project.
   It is often the case that a dependent project tests also needs the test fixtures of the dependency.
   This can be achieved very easily using the `testFixtures` keyword:
   
   .Adding a dependency on test fixtures of another project
   ====
   include::sample[dir="snippets/java/fixtures/kotlin",files="build.gradle.kts[tags=consumer_dependencies]"]
   include::sample[dir="snippets/java/fixtures/groovy",files="build.gradle[tags=consumer_dependencies]"]
   ====
   
   === Publishing test fixtures
   
   One of the advantages of using the `java-test-fixtures` plugin is that test fixtures are published.
   By convention, test fixtures will be published with an artifact having the `test-fixtures` classifier.
   For both Maven and Ivy, an artifact with that classifier is simply published alongside the regular artifacts.
   However, if you use the `maven-publish` or `ivy-publish` plugin, test fixtures are published as additional variants in {metadata-file-spec}[Gradle Module Metadata] and you can directly depend on test fixtures of external libraries in another Gradle project:
   
   .Adding a dependency on test fixtures of an external library
   ====
   include::sample[dir="snippets/java/fixtures/kotlin",files="build.gradle.kts[tags=external-test-fixtures-dependency]"]
   include::sample[dir="snippets/java/fixtures/groovy",files="build.gradle[tags=external-test-fixtures-dependency]"]
   ====
   
   It's worth noting that if the external project is _not_ publishing Gradle Module Metadata, then resolution will fail with an error indicating that such a variant cannot be found:
   
   .Output of **`gradle dependencyInsight --configuration functionalTestClasspath --dependency gson`**
   ----
   > gradle dependencyInsight --configuration functionalTestClasspath --dependency gson
   include::{snippetsPath}/java/fixtures/tests/dependencyInsight.out[]
   ----
   
   The error message mentions the missing `com.google.code.gson:gson-test-fixtures` capability, which is indeed not defined for this library.
   That's because by convention, for projects that use the `java-test-fixtures` plugin, Gradle automatically creates test fixtures variants with a capability whose name is the name of the main component, with the appendix `-test-fixtures`.
   
   NOTE: If you publish your library and use test fixtures, but do not want to publish the fixtures, you can deactivate publishing of the _test fixtures variants_ as shown below.
   
   .Disable publishing of test fixtures variants
   ====
   include::sample[dir="snippets/java/fixtures/kotlin/lib",files="build.gradle.kts[tags=disable-test-fixtures-publishing]"]
   include::sample[dir="snippets/java/fixtures/groovy/lib",files="build.gradle[tags=disable-test-fixtures-publishing]"]
   ====

/docs/userguide/jvm/dependency_management_for_java_projects.adoc
================================================================

.. code-block::

   = Managing Dependencies of JVM Projects
   
   This chapter explains how to apply basic dependency management concepts to JVM-based projects.
   For a detailed introduction to dependency management, see <<core_dependency_management.adoc#dependency_management_in_gradle,dependency management in Gradle>>.
   
   == Dissecting a typical build script
   
   Let's have a look at a very simple build script for a JVM-based project.
   It applies the <<java_library_plugin.adoc#java_library_plugin,Java Library plugin>> which automatically introduces a standard project layout, provides tasks for performing typical work and adequate support for dependency management.
   
   .Dependency declarations for a JVM-based project
   ====
   include::sample[dir="snippets/artifacts/dependencyBasics/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/artifacts/dependencyBasics/groovy",files="build.gradle[]"]
   ====
   
   The link:{groovyDslPath}#[Project.dependencies{}] code block declares that Hibernate core 3.6.7.Final is required to compile the project's production source code. It also states that junit &gt;= 4.0 is required to compile the project's tests. All dependencies are supposed to be looked up in the Maven Central repository as defined by link:{groovyDslPath}#[Project.repositories{}]. The following sections explain each aspect in more detail.
   
   == Declaring module dependencies
   
   There are various <<declaring_dependencies.adoc#sec:dependency-types,types of dependencies>> that you can declare.
   One such type is a _module dependency_.
   A <<declaring_dependencies.adoc#sub:module_dependencies,module dependency>> represents a dependency on a module with a specific version built outside the current build.
   Modules are usually stored in a repository, such as Maven Central, a corporate Maven or Ivy repository, or a directory in the local file system.
   
   To define an module dependency, you add it to a <<#sec:configurations_java_tutorial,dependency configuration>>:
   
   .Definition of a module dependency
   ====
   include::sample[dir="snippets/artifacts/externalDependencies/kotlin",files="build.gradle.kts[tags=define-dependency]"]
   include::sample[dir="snippets/artifacts/externalDependencies/groovy",files="build.gradle[tags=define-dependency]"]
   ====
   
   To find out more about defining dependencies, have a look at <<declaring_dependencies.adoc#declaring-dependencies,Declaring Dependencies>>.
   
   == Using dependency configurations
   
   A link:{groovyDslPath}#[Configuration] is a named set of dependencies and artifacts. There are three main purposes for a _configuration_:
   
   Declaring dependencies::
   A plugin uses configurations to make it easy for build authors to declare what other subprojects or external artifacts are needed for various purposes during the execution of tasks defined by the plugin. For example a plugin may need the Spring web framework dependency to compile the source code.
   Resolving dependencies::
   A plugin uses configurations to find (and possibly download) inputs to the tasks it defines. For example Gradle needs to download Spring web framework JAR files from Maven Central.
   Exposing artifacts for consumption::
   A plugin uses configurations to define what _artifacts_ it generates for other projects to consume. For example the project would like to publish its compiled source code packaged in the JAR file to an in-house Artifactory repository.
   
   With those three purposes in mind, let's take a look at a few of the <<java_library_plugin.adoc#sec:java_library_configurations_graph,standard configurations defined by the Java Library Plugin>>.
   
   implementation::
   The dependencies required to compile the production source of the project which _are not_ part of the API exposed by the project. For example the project uses Hibernate for its internal persistence layer implementation.
   api::
   The dependencies required to compile the production source of the project which _are_ part of the API exposed by the project. For example the project uses Guava and exposes public interfaces with Guava classes in their method signatures.
   testImplementation::
   The dependencies required to compile and run the test source of the project. For example the project decided to write test code with the test framework JUnit.
   
   Various plugins add further standard configurations.
   You can also define your own custom configurations in your build via link:{groovyDslPath}#[Project.configurations{}].
   See <<declaring_dependencies.adoc#sec:what-are-dependency-configurations,What are dependency configurations>> for the details of defining and customizing dependency configurations.
   
   == Declaring common Java repositories
   
   How does Gradle know where to find the files for external dependencies? Gradle looks for them in a _repository_.
   A repository is a collection of modules, organized by `group`, `name` and `version`.
   Gradle understands different <<declaring_repositories.adoc#sec:repository-types,repository types>>, such as Maven and Ivy, and supports various ways of accessing the repository via HTTP or other protocols.
   
   By default, Gradle does not define any repositories. You need to define at least one with the help of link:{groovyDslPath}#[Project.repositories{}] before you can use module dependencies. One option is use the Maven Central repository:
   
   .Usage of Maven central repository
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=maven-central]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=maven-central]"]
   ====
   
   You can also have repositories on the local file system. This works for both Maven and Ivy repositories.
   
   .Usage of a local Ivy directory
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=local-ivy-repo]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=local-ivy-repo]"]
   ====
   
   A project can have multiple repositories. Gradle will look for a dependency in each repository in the order they are specified, stopping at the first repository that contains the requested module.
   
   To find out more about defining repositories, have a look at <<declaring_repositories.adoc#declaring-repositories,Declaring Repositories>>.
   
   == Publishing artifacts
   
   To learn more about publishing artifacts, have a look at <<publishing_setup.adoc#publishing_components,publishing plugins>>.

/Section: 游릭 Java Toolchains
==============================


/docs/userguide/jvm/toolchains.adoc
===================================

.. code-block::

   = Toolchains for JVM projects
   
   Working on multiple projects can require interacting with multiple versions of the Java language.
   Even within a single project different parts of the codebase may be fixed to a particular language level due to backward compatibility requirements.
   This means different versions of the same tools (a toolchain) must be installed and managed on each machine that builds the project.
   
   A **Java toolchain** is a set of tools to build and run Java projects, which is usually provided by the environment via local JRE or JDK installations.
   Compile tasks may use `javac` as their compiler, test and exec tasks may use the `java` command while `javadoc` will be used to generate documentation.
   
   By default, Gradle uses the same Java toolchain for running Gradle itself and building JVM projects.
   However, this may only sometimes be desirable.
   Building projects with different Java versions on different developer machines and CI servers may lead to unexpected issues.
   Additionally, you may want to build a project using a Java version that is not supported for running Gradle.
   
   In order to improve reproducibility of the builds and make build requirements clearer, Gradle allows configuring toolchains on both project and task levels.
   
   == Toolchains for projects
   
   You can define what toolchain to use for a project by stating the Java language version in the `java` extension block:
   
   ====
   include::sample[dir="snippets/java/toolchain-basic/kotlin",files="build.gradle.kts[tags=toolchain]"]
   include::sample[dir="snippets/java/toolchain-basic/groovy",files="build.gradle[tags=toolchain]"]
   ====
   
   Executing the build (e.g. using `gradle check`) will now handle several things for you and others running your build:
   
   1. Gradle configures all compile, test and javadoc tasks to use the defined toolchain.
   2. Gradle detects <<#sec:auto_detection,locally installed toolchains>>.
   3. Gradle chooses a toolchain matching the requirements (any Java 17 toolchain for the example above).
   4. If no matching toolchain is found, Gradle can automatically download a matching one based on the configured <<#sub:download_repositories,toolchain download repositories>>.
   
   [NOTE]
   ====
   Toolchain support is available in the Java plugins and for the tasks they define.
   
   For the Groovy plugin, compilation is supported but not yet Groovydoc generation.
   For the Scala plugin, compilation and Scaladoc generation are supported.
   ====
   
   === Selecting toolchains by vendor
   
   In case your build has specific requirements from the used JRE/JDK, you may want to define the vendor for the toolchain as well.
   link:{javadocPath}#[`JvmVendorSpec`] has a list of well-known JVM vendors recognized by Gradle.
   The advantage is that Gradle can handle any inconsistencies across JDK versions in how exactly the JVM encodes the vendor information.
   
   ====
   include::sample[dir="snippets/java/toolchain-filters/kotlin/",files="build.gradle.kts[tags=toolchain-known-vendor]"]
   include::sample[dir="snippets/java/toolchain-filters/groovy/",files="build.gradle[tags=toolchain-known-vendor]"]
   ====
   
   If the vendor you want to target is not a known vendor, you can still restrict the toolchain to those matching the `java.vendor` system property of the available toolchains.
   
   The following snippet uses filtering to include a subset of available toolchains.
   This example only includes toolchains whose `java.vendor` property contains the given match string.
   The matching is done in a case-insensitive manner.
   
   ====
   include::sample[dir="snippets/java/toolchain-filters/kotlin/",files="build.gradle.kts[tags=toolchain-matching-vendor]"]
   include::sample[dir="snippets/java/toolchain-filters/groovy/",files="build.gradle[tags=toolchain-matching-vendor]"]
   ====
   
   === Selecting toolchains by virtual machine implementation
   
   If your project requires a specific implementation, you can filter based on the implementation as well.
   Currently available implementations to choose from are:
   
   `VENDOR_SPECIFIC`::
   Acts as a placeholder and matches any implementation from any vendor (e.g. hotspot, zulu, ...)
   `J9`::
   Matches only virtual machine implementations using the OpenJ9/IBM J9 runtime engine.
   
   For example, to use an https://www.eclipse.org/openj9/[IBM] JVM, distributed via https://adoptopenjdk.net/[AdoptOpenJDK],
   you can specify the filter as shown in the example below.
   
   ====
   include::sample[dir="snippets/java/toolchain-filters/kotlin/",files="build.gradle.kts[tags=toolchain-matching-implementation]"]
   include::sample[dir="snippets/java/toolchain-filters/groovy/",files="build.gradle[tags=toolchain-matching-implementation]"]
   ====
   
   NOTE: The Java major version, the vendor (if specified) and implementation (if specified) will be tracked as an input for compilation and test execution.
   
   === Configuring toolchain specifications
   
   Gradle allows configuring multiple properties that affect the selection of a toolchain, such as language version or vendor.
   Even though these properties can be configured independently, the configuration must follow certain rules in order to form a _valid_ specification.
   
   A `JavaToolchainSpec` is considered _valid_ in two cases:
   
   1. when no properties have been set, i.e. the specification is _empty_;
   2. when `languageVersion` has been set, optionally followed by setting any other property.
   
   In other words, if a vendor or an implementation are specified, they must be accompanied by the language version.
   Gradle distinguishes between toolchain specifications that configure the language version and the ones that do not.
   A specification without a language version, in most cases, would be treated as a one that selects the toolchain of the current build.
   
   Usage of _invalid_ instances of `JavaToolchainSpec` results in a build error since Gradle 8.0.
   
   
   == Toolchains for tasks
   
   In case you want to tweak which toolchain is used for a specific task, you can specify the exact tool a task is using.
   For example, the `Test` task exposes a `JavaLauncher` property that defines which java executable to use for launching the tests.
   
   In the example below, we configure all java compilation tasks to use Java 8.
   Additionally, we introduce a new `Test` task that will run our unit tests using a JDK 17.
   
   ====
   include::sample[dir="samples/java/jvm-multi-project-with-toolchains/kotlin",files="list/build.gradle.kts[tags=customToolchain]"]
   include::sample[dir="samples/java/jvm-multi-project-with-toolchains/groovy/",files="list/build.gradle[tags=customToolchain]"]
   ====
   
   In addition, in the `application` subproject, we add another Java execution task to run our application with JDK 17.
   
   ====
   include::sample[dir="samples/java/jvm-multi-project-with-toolchains/kotlin",files="application/build.gradle.kts[tags=customExec]"]
   include::sample[dir="samples/java/jvm-multi-project-with-toolchains/groovy/",files="application/build.gradle[tags=customExec]"]
   ====
   
   Depending on the task, a JRE might be enough while for other tasks (e.g. compilation), a JDK is required.
   By default, Gradle prefers installed JDKs over JREs if they can satisfy the requirements.
   
   Toolchains tool providers can be obtained from the link:{javadocPath}#[`javaToolchains`] extension.
   
   Three tools are available:
   
   * A `JavaCompiler` which is the tool used by the link:{groovyDslPath}#[JavaCompile] task
   * A `JavaLauncher` which is the tool used by the link:{groovyDslPath}#[JavaExec] or link:{groovyDslPath}#[Test] tasks
   * A `JavadocTool` which is the tool used by the link:{groovyDslPath}#[Javadoc] task
   
   === Integration with tasks relying on a Java executable or Java home
   
   Any task that can be configured with a path to a Java executable, or a Java home location, can benefit from toolchains.
   
   While you will not be able to wire a toolchain tool directly, they all have the metadata that gives access to their full path or to the path of the Java installation they belong to.
   
   For example, you can configure the `java` executable for a task as follows:
   
   ====
   include::sample[dir="snippets/java/toolchain-config-task/kotlin/",files="build.gradle.kts[tags=java-executable]"]
   include::sample[dir="snippets/java/toolchain-config-task/groovy/",files="build.gradle[tags=java-executable]"]
   ====
   
   As another example, you can configure the _Java Home_ for a task as follows:
   
   ====
   include::sample[dir="snippets/java/toolchain-config-task/kotlin/",files="build.gradle.kts[tags=java-home]"]
   include::sample[dir="snippets/java/toolchain-config-task/groovy/",files="build.gradle[tags=java-home]"]
   ====
   
   If you require a path to a specific tool such as Java compiler, you can obtain it as follows:
   
   ====
   include::sample[dir="snippets/java/toolchain-config-task/kotlin/",files="build.gradle.kts[tags=java-compiler]"]
   include::sample[dir="snippets/java/toolchain-config-task/groovy/",files="build.gradle[tags=java-compiler]"]
   ====
   
   WARNING: The examples above use tasks with `RegularFileProperty` and `DirectoryProperty` properties which allow lazy configuration.
   Doing respectively `launcher.get().executablePath`, `launcher.get().metadata.installationPath` or `compiler.get().executablePath` instead will give you the full path for the given toolchain but note that this may realize (and provision) a toolchain eagerly.
   
   == Auto detection of installed toolchains
   
   By default, Gradle automatically detects local JRE/JDK installations so no further configuration is required by the user.
   The following is a list of common package managers, tools, and locations that are supported by the JVM auto-detection.
   
   JVM auto-detection knows how to work with:
   
   * Operation-system specific locations: Linux, macOS, Windows
   * Package Managers: https://asdf-vm.com/#/[Asdf-vm], https://github.com/shyiko/jabba[Jabba], https://sdkman.io/[SDKMAN!]
   * https://maven.apache.org/guides/mini/guide-using-toolchains.html[Maven Toolchain] specifications
   * https://www.jetbrains.com/help/idea/sdk.html#jdk-from-ide[IntelliJ IDEA] installations
   
   Among the set of all detected JRE/JDK installations, one will be picked according to the <<sec:precedence,Toolchain Precedence Rules>>.
   
   NOTE: Whether you are using toolchain auto-detection or you are configuring <<sec:custom_loc>>, installations that are non-existing or without a `bin/java` executable will be ignored with a warning, but they won't generate an error.
   
   === How to disable auto-detection
   
   In order to disable auto-detection, you can use the `org.gradle.java.installations.auto-detect` Gradle property:
   
   * Either start gradle using `-Porg.gradle.java.installations.auto-detect=false`
   * Or put `org.gradle.java.installations.auto-detect=false` into your `gradle.properties` file.
   
   == Auto-provisioning
   
   If Gradle can't find a locally available toolchain that matches the requirements of the build, it can automatically download one (as long as a toolchain download repository has been configured; for detail, see <<#sub:download_repositories,relevant section>>).
   Gradle installs the downloaded JDKs in the <<directory_layout.adoc#dir:gradle_user_home,Gradle User Home>>.
   
   NOTE: Gradle only downloads JDK versions for GA releases.
   There is no support for downloading early access versions.
   
   Once installed in the <<directory_layout.adoc#dir:gradle_user_home,Gradle User Home>>, a provisioned JDK becomes one of the JDKs visible to <<#sec:auto_detection,auto-detection>> and can be used by any subsequent builds, just like any other JDK installed on the system.
   
   Since auto-provisioning only kicks in when auto-detection fails to find a matching JDK, auto-provisioning can only download new JDKs and is in no way involved in updating any of the already installed ones.
   None of the auto-provisioned JDKs will ever be revisited and automatically updated by auto-provisioning, even if there is a newer minor version available for them.
   
   === Toolchain Download Repositories
   
   Toolchain download repository definitions are added to a build by applying specific settings plugins.
   For details on writing such plugins, consult the <<toolchain_plugins.adoc#toolchain_plugins,Toolchain Resolver Plugins>> page.
   
   One example of a toolchain resolver plugin is the https://github.com/gradle/disco-toolchains[Disco Toolchains Plugin], based on the https://github.com/foojayio/discoapi[foojay Disco API].
   It even has a convention variant, which automatically takes care of all the needed configuration, just by being applied:
   
   ====
   include::sample[dir="snippets/java/toolchain-foojay/kotlin/",files="settings.gradle.kts[tags=plugin-application]"]
   include::sample[dir="snippets/java/toolchain-foojay/groovy/",files="settings.gradle[tags=plugin-application]"]
   ====
   
   In general, when applying toolchain resolver plugins, the toolchain download resolvers provided by them also need to be configured.
   Let's illustrate with an example.
   Consider two toolchain resolver plugins applied by the build:
   
   * One is the Foojay plugin mentioned above, which downloads toolchains via the `FoojayToolchainResolver` it provides.
   * The other contains a **FICTITIOUS** resolver named `MadeUpResolver`.
   
   The following example uses these toolchain resolvers in a build via the `toolchainManagement` block in the settings file:
   
   ====
   include::sample[dir="snippets/java/toolchain-management/kotlin/",files="settings.gradle.kts[tags=toolchain-management]"]
   include::sample[dir="snippets/java/toolchain-management/groovy/",files="settings.gradle[tags=toolchain-management]"]
   ====
   <1> In the `toolchainManagement` block, the `jvm` block contains configuration for Java toolchains.
   <2> The `javaRepositories` block defines named Java toolchain repository configurations.
   Use the `resolverClass` property to link these configurations to plugins.
   <3> Toolchain declaration order matters.
   Gradle downloads from the first repository that provides a match, starting with the first repository in the list.
   <4> You can configure toolchain repositories with the same set of <<declaring_repositories.adoc#sec:authentication_schemes,authentication and authorization options>> used for dependency management.
   
   WARNING: The `jvm` block in `toolchainManagement` only resolves after applying a toolchain resolver plugin.
   
   === Viewing and debugging toolchains
   
   Gradle can display the list of all detected toolchains including their metadata.
   
   For example, to show all toolchains of a project, run:
   
   ```
   gradle -q javaToolchains
   ```
   
   .Output of **`gradle -q javaToolchains`**
   ----
   > gradle -q javaToolchains
   
    + Options
        | Auto-detection:     Enabled
        | Auto-download:      Enabled
   
    + AdoptOpenJDK 1.8.0_242
        | Location:           /Users/username/myJavaInstalls/8.0.242.hs-adpt/jre
        | Language Version:   8
        | Vendor:             AdoptOpenJDK
        | Architecture:       x86_64
        | Is JDK:             false
        | Detected by:        Gradle property 'org.gradle.java.installations.paths'
   
    + Microsoft JDK 16.0.2+7
        | Location:           /Users/username/.sdkman/candidates/java/16.0.2.7.1-ms
        | Language Version:   16
        | Vendor:             Microsoft
        | Architecture:       aarch64
        | Is JDK:             true
        | Detected by:        SDKMAN!
   
    + OpenJDK 15-ea
        | Location:           /Users/user/customJdks/15.ea.21-open
        | Language Version:   15
        | Vendor:             AdoptOpenJDK
        | Architecture:       x86_64
        | Is JDK:             true
        | Detected by:        environment variable 'JDK16'
   
    + Oracle JDK 1.7.0_80
        | Location:           /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre
        | Language Version:   7
        | Vendor:             Oracle
        | Architecture:       x86_64
        | Is JDK:             false
        | Detected by:        MacOS java_home
   ----
   
   This can help to debug which toolchains are available to the build, how they are detected and what kind of metadata Gradle knows about those toolchains.
   
   === How to disable auto provisioning
   
   In order to disable auto-provisioning, you can use the `org.gradle.java.installations.auto-download` Gradle property:
   
   * Either start gradle using `-Porg.gradle.java.installations.auto-download=false`
   * Or put `org.gradle.java.installations.auto-download=false` into a `gradle.properties` file.
   
   == Custom toolchain locations
   
   If auto-detecting local toolchains is not sufficient or disabled, there are additional ways you can let Gradle know about installed toolchains.
   
   If your setup already provides environment variables pointing to installed JVMs, you can also let Gradle know about which environment variables to take into account.
   Assuming the environment variables `JDK8` and `JRE17` point to valid java installations, the following instructs Gradle to resolve those environment variables and consider those installations when looking for a matching toolchain.
   
   ----
   org.gradle.java.installations.fromEnv=JDK8,JRE17
   ----
   
   Additionally, you can provide a comma-separated list of paths to specific installations using the `org.gradle.java.installations.paths` property.
   For example, using the following in your `gradle.properties` will let Gradle know which directories to look at when detecting toolchains.
   Gradle will treat these directories as possible installations but will not descend into any nested directories.
   
   ----
   org.gradle.java.installations.paths=/custom/path/jdk1.8,/shared/jre11
   ----
   
   [NOTE]
   ====
   Gradle does not prioritize custom toolchains over <<sec:auto_detection,auto-detected>> toolchains.
   If you enable auto-detection in your build, custom toolchains extend the set of toolchain locations.
   Gradle picks a toolchain according to the <<sec:precedence,precedence rules>>.
   ====
   
   == Toolchain installations precedence
   
   Gradle will sort all the JDK/JRE installations matching the toolchain specification of the build and will pick the first one.
   Sorting is done based on the following rules:
   
   . the installation currently running Gradle is preferred over any other
   . JDK installations are preferred over JRE ones
   . certain vendors take precedence over others; their ordering (from the highest priority to lowest):
   .. ADOPTIUM
   .. ADOPTOPENJDK
   .. AMAZON
   .. APPLE
   .. AZUL
   .. BELLSOFT
   .. GRAAL_VM
   .. HEWLETT_PACKARD
   .. IBM
   .. JETBRAINS
   .. MICROSOFT
   .. ORACLE
   .. SAP
   .. TENCENT
   .. everything else
   . higher major versions take precedence over lower ones
   . higher minor versions take precedence over lower ones
   . installation paths take precedence according to their lexicographic ordering (last resort criteria for deterministically deciding
   between installations of the same type, from the same vendor and with the same version)
   
   All these rules are applied as multilevel sorting criteria, *in the order shown*.
   Let's illustrate with an example.
   A toolchain specification requests Java version 17.
   Gradle detects the following matching installations:
   
   * Oracle JRE v17.0.1
   * Oracle JDK v17.0.0
   * Microsoft JDK 17.0.0
   * Microsoft JRE 17.0.1
   * Microsoft JDK 17.0.1
   
   Assume that Gradle runs on a major Java version other than 17.
   Otherwise, that installation would have priority.
   
   When we apply the above rules to sort this set we will end up with following ordering:
   
   . Microsoft JDK 17.0.1
   . Microsoft JDK 17.0.0
   . Oracle JDK v17.0.0
   . Microsoft JRE v17.0.1
   . Oracle JRE v17.0.1
   
   Gradle prefers JDKs over JREs, so the JREs come last.
   Gradle prefers the Microsoft vendor over Oracle, so the Microsoft installations come first.
   Gradle prefers higher version numbers, so JDK 17.0.1 comes before JDK 17.0.0.
   
   So Gradle picks the first match in this order: Microsoft JDK 17.0.1.
   
   == Toolchains for plugin authors
   
   When creating a plugin or a task that uses toolchains, it is essential to provide sensible defaults and allow users to override them.
   
   For JVM projects, it is usually safe to assume that the `java` plugin has been applied to the project.
   The `java` plugin is automatically applied for the core Groovy and Scala plugins, as well as for the Kotlin plugin.
   In such a case, using the toolchain defined via the `java` extension as a default value for the tool property is appropriate.
   This way, the users will need to configure the toolchain only once on the project level.
   
   The example below showcases how to use the default toolchain as convention while allowing users to individually configure the toolchain per task.
   
   ====
   include::sample[dir="snippets/java/toolchain-task/kotlin/",files="build.gradle.kts[tags=custom-toolchain-task-with-java]"]
   include::sample[dir="snippets/java/toolchain-task/groovy/",files="build.gradle[tags=custom-toolchain-task-with-java]"]
   ====
   <1> We declare a `JavaLauncher` property on the task.
   The property must be marked as a <<incremental_build.adoc#sec:task_input_nested_inputs,`@Nested` input>> to make sure the task is responsive to toolchain changes.
   <2> We obtain the toolchain spec from the `java` extension to use it as a default.
   <3> Using the `JavaToolchainService` we get a provider of the `JavaLauncher` that matches the toolchain.
   <4> Finally, we wire the launcher provider as a convention for our property.
   
   In a project where the `java` plugin was applied, we can use the task as follows:
   
   ====
   include::sample[dir="snippets/java/toolchain-task/kotlin/",files="build.gradle.kts[tags=custom-toolchain-task-with-java-usage]"]
   include::sample[dir="snippets/java/toolchain-task/groovy/",files="build.gradle[tags=custom-toolchain-task-with-java-usage]"]
   ====
   <1> The toolchain defined on the `java` extension is used by default to resolve the launcher.
   <2> The custom task without additional configuration will use the default Java 8 toolchain.
   <3> The other task overrides the value of the launcher by selecting a different toolchain using `javaToolchains` service.
   
   When a task needs access to toolchains without the `java` plugin being applied the toolchain service can be used directly.
   If an <<#sec:configuring_toolchain_specifications, unconfigured>> toolchain spec is provided to the service, it will always return a tool provider for the toolchain that is running Gradle.
   This can be achieved by passing an empty lambda when requesting a tool: `javaToolchainService.launcherFor({})`.
   
   You can find more details on defining custom tasks in the <<more_about_tasks.adoc#more_about_tasks, Authoring tasks>> documentation.
   
   == Toolchains limitations
   
   Gradle may detect toolchains incorrectly when it's running in a JVM compiled against `musl`, an https://musl.libc.org/[alternative implementation] of the C standard library.
   JVMs compiled against `musl` can sometimes override the `LD_LIBRARY_PATH` environment variable to control dynamic library resolution.
   This can influence forked java processes launched by Gradle, resulting in unexpected behavior.
   
   As a consequence, using multiple java toolchains is discouraged in environments with the `musl` library.
   This is the case in most Alpine distributions  consider using another distribution, like Ubuntu, instead.
   If you are using a single toolchain, the JVM running Gradle, to build and run your application, you can safely ignore this limitation.

/docs/userguide/jvm/toolchain_plugins.adoc
==========================================

.. code-block::

   = Toolchain Resolver Plugins
   
   In Gradle version 7.6 and above, Gradle provides a way to define Java toolchain auto-provisioning logic in plugins.
   This page explains how to author a toolchain resolver plugin.
   For details on how toolchain auto-provisioning interacts with these plugins, see <<toolchains.adoc#sub:download_repositories,Toolchains>>.
   
   == Provide a download URI
   
   Toolchain resolver plugins provide logic to map a link:{javadocPath}#[toolchain request] to a link:{javadocPath}#[download response].
   At the moment the download response only contains a download URL, but may be extended in the future.
   
   WARNING: For the download URL only secure protocols like `https` are accepted.
   This is required to make sure no one can tamper with the download in flight.
   
   The plugins provide the mapping logic via an implementation of link:{javadocPath}#[JavaToolchainResolver]:
   
   .JavaToolchainResolverImplementation.java
   [source,java]
   ----
   include::{snippetsPath}/java/toolchain-management/groovy/buildSrc/src/main/java/org/myorg/JavaToolchainResolverImplementation.java[tags=java-toolchain-resolver-implementation]
   ----
   <1> This class is `abstract` because `JavaToolchainResolver` is a <<build_services.adoc#build_services,build service>>. Gradle provides dynamic implementations for certain abstract methods at runtime.
   <2> The mapping method returns a download response wrapped in an `Optional`. If the resolver implementation can't provide a matching toolchain, the enclosing `Optional` contains an empty value.
   
   == Register the resolver in a plugin
   
   Use a settings plugin (`Plugin<Settings>`) to register the `JavaToolchainResolver` implementation:
   
   .JavaToolchainResolverPlugin.java
   [source,java]
   ----
   include::{snippetsPath}/java/toolchain-management/groovy/buildSrc/src/main/java/org/myorg/JavaToolchainResolverPlugin.java[tags=java-toolchain-resolver-plugin]
   ----
   <1> The plugin uses <<custom_gradle_types.adoc#property_injection,property injection>>, so it must be `abstract` and a settings plugin.
   <2> To register the resolver implementation, use property injection to access the link:{javadocPath}#[JavaToolchainResolverRegistry] Gradle service.
   <3> Resolver plugins must apply the `jvm-toolchain-management` base plugin. This dynamically adds the `jvm` block to `toolchainManagement`, which makes registered toolchain repositories usable from the build.

/Section: 游릭 JVM Plugins
==========================


/docs/userguide/jvm/java_library_plugin.adoc
============================================

.. code-block::

   = The Java Library Plugin
   
   The Java Library plugin expands the capabilities of the <<java_plugin.adoc#java_plugin,Java Plugin (`java`)>> by providing specific knowledge about Java libraries.
   In particular, a Java library exposes an API to consumers (i.e., other projects using the Java or the Java Library plugin).
   All the source sets, tasks and configurations exposed by the Java plugin are implicitly available when using this plugin.
   
   
   == Usage
   
   To use the Java Library plugin, include the following in your build script:
   
   .Using the Java Library plugin
   ====
   include::sample[dir="snippets/java-library/quickstart/kotlin",files="build.gradle.kts[tags=use-plugin]"]
   include::sample[dir="snippets/java-library/quickstart/groovy",files="build.gradle[tags=use-plugin]"]
   ====
   
   
   == API and implementation separation
   
   The key difference between the standard Java plugin and the Java Library plugin is that the latter introduces the concept of an _API_ exposed to consumers. A library is a Java component meant to be consumed by other components. It's a very common use case in multi-project builds, but also as soon as you have external dependencies.
   
   The plugin exposes two <<declaring_dependencies.adoc#sec:what-are-dependency-configurations,configurations>> that can be used to declare dependencies: `api` and `implementation`.
   The `api` configuration should be used to declare dependencies which are exported by the library API, whereas the `implementation` configuration should be used to declare dependencies which are internal to the component.
   
   .Declaring API and implementation dependencies
   ====
   include::sample[dir="snippets/java-library/quickstart/kotlin",files="build.gradle.kts[tags=dependencies]"]
   include::sample[dir="snippets/java-library/quickstart/groovy",files="build.gradle[tags=dependencies]"]
   ====
   
   
   Dependencies appearing in the `api` configurations will be transitively exposed to consumers of the library, and as such will appear on the compile classpath of consumers. Dependencies found in the `implementation` configuration will, on the other hand, not be exposed to consumers, and therefore not leak into the consumers' compile classpath. This comes with several benefits:
   
   * dependencies do not leak into the compile classpath of consumers anymore, so you will never accidentally depend on a transitive dependency
   * faster compilation thanks to reduced classpath size
   * less recompilations when implementation dependencies change: consumers would not need to be recompiled
   * cleaner publishing: when used in conjunction with the new `maven-publish` plugin, Java libraries produce POM files that distinguish exactly between what is required to compile against the library and what is required to use the library at runtime (in other words, don't mix what is needed to compile the library itself and what is needed to compile against the library).
   
   NOTE: The `compile` and `runtime` configurations have been removed with Gradle 7.0.
   Please refer to the <<upgrading_version_6.adoc#sec:configuration_removal, upgrade guide>> how to migrate to `implementation` and `api` configurations`.
   
   If your build consumes a published module with POM metadata, the Java and Java Library plugins both honor api and implementation separation through the scopes used in the POM.
   Meaning that the compile classpath only includes Maven `compile` scoped dependencies, while the runtime classpath adds the Maven `runtime` scoped dependencies as well.
   
   This often does not have an effect on modules published with Maven, where the POM that defines the project is directly published as metadata.
   There, the compile scope includes both dependencies that were required to compile the project (i.e. implementation dependencies) and dependencies required to compile against the published library (i.e. API dependencies).
   For most published libraries, this means that all dependencies belong to the compile scope.
   If you encounter such an issue with an existing library, you can consider a <<component_metadata_rules.adoc#sec:component_metadata_rules,component metadata rule>> to fix the incorrect metadata in your build.
   However, as mentioned above, if the library is published with Gradle, the produced POM file only puts `api` dependencies into the compile scope and the remaining `implementation` dependencies into the runtime scope.
   
   If your build consumes modules with Ivy metadata, you might be able to activate api and implementation separation as described <<variant_model.adoc#sub:ivy-mapping-to-variants,here>> if all modules follow a certain structure.
   
   NOTE: Separating compile and runtime scope of modules is active by default in Gradle 5.0+.
   In Gradle 4.6+, you need to activate it by adding `enableFeaturePreview('IMPROVED_POM_SUPPORT')` in _settings.gradle_.
   
   == Recognizing API and implementation dependencies
   
   This section will help you identify API and Implementation dependencies in your code using simple rules of thumb. The first of these is:
   
    * Prefer the `implementation` configuration over `api` when possible
   
   This keeps the dependencies off of the consumer's compilation classpath. In addition, the consumers will immediately fail to compile if any implementation types accidentally leak into the public API.
   
   So when should you use the `api` configuration? An API dependency is one that contains at least one type that is exposed in the library binary interface, often referred to as its ABI (Application Binary Interface). This includes, but is not limited to:
   
   * types used in super classes or interfaces
   * types used in public method parameters, including generic parameter types (where _public_ is something that is visible to compilers. I.e. , _public_, _protected_ and _package private_ members in the Java world)
   * types used in public fields
   * public annotation types
   
   By contrast, any type that is used in the following list is irrelevant to the ABI, and therefore should be declared as an `implementation` dependency:
   
   * types exclusively used in method bodies
   * types exclusively used in private members
   * types exclusively found in internal classes (future versions of Gradle will let you declare which packages belong to the public API)
   
   The following class makes use of a couple of third-party libraries, one of which is exposed in the class's public API and the other is only used internally. The import statements don't help us determine which is which, so we have to look at the fields, constructors and methods instead:
   
   === Example: Making the difference between API and implementation
   
   [source.multi-language-sample,java]
   .src/main/java/org/gradle/HttpClientWrapper.java
   ----
   include::{snippetsPath}/java-library/quickstart/groovy/src/main/java/org/gradle/HttpClientWrapper.java[tag=sample]
   ----
   
   The _public_ constructor of `HttpClientWrapper` uses `HttpClient` as a parameter, so it is exposed to consumers and therefore belongs to the API. Note that `HttpGet` and `HttpEntity` are used in the signature of a _private_ method, and so they don't count towards making HttpClient an API dependency.
   
   On the other hand, the `ExceptionUtils` type, coming from the `commons-lang` library, is only used in a method body (not in its signature), so it's an implementation dependency.
   
   Therefore, we can deduce that `httpclient` is an API dependency, whereas `commons-lang` is an implementation dependency. This conclusion translates into the following declaration in the build script:
   
   .Declaring API and implementation dependencies
   ====
   include::sample[dir="snippets/java-library/quickstart/kotlin",files="build.gradle.kts[tags=dependencies]"]
   include::sample[dir="snippets/java-library/quickstart/groovy",files="build.gradle[tags=dependencies]"]
   ====
   
   
   == The Java Library plugin configurations
   
   The following graph describes how configurations are setup when the Java Library plugin is in use.
   
   image::java-library-ignore-deprecated-main.png[]
   
   * The configurations in _green_ are the ones a user should use to declare dependencies
   * The configurations in _pink_ are the ones used when a component compiles, or runs against the library
   * The configurations in _blue_ are internal to the component, for its own use
   
   And the next graph describes the test configurations setup:
   
   image::java-library-ignore-deprecated-test.png[]
   
   The role of each configuration is described in the following tables:
   
   .Java Library plugin - configurations used to declare dependencies
   [%header%autowidth,compact]
   |===
   | Configuration name | Role | Consumable? | Resolvable? | Description
   
   | `api`
   | Declaring API dependencies
   | no
   | no
   | This is where you declare dependencies which are transitively exported to consumers, for compile time and runtime.
   
   | `implementation`
   | Declaring implementation dependencies
   | no
   | no
   | This is where you declare dependencies which are purely internal and not meant to be exposed to consumers (they are still exposed to consumers at runtime).
   
   | `compileOnly`
   | Declaring compile only dependencies
   | no
   | no
   | This is where you declare dependencies which are required at compile time, but not at runtime. This typically includes dependencies which are shaded when found at runtime.
   
   | `compileOnlyApi`
   | Declaring compile only API dependencies
   | no
   | no
   | This is where you declare dependencies which are required at compile time by your module and consumers, but not at runtime. This typically includes dependencies which are shaded when found at runtime.
   
   | `runtimeOnly`
   | Declaring runtime dependencies
   | no
   | no
   | This is where you declare dependencies which are only required at runtime, and not at compile time.
   
   | `testImplementation`
   | Test dependencies
   | no
   | no
   | This is where you declare dependencies which are used to compile tests.
   
   | `testCompileOnly`
   | Declaring test compile only dependencies
   | no
   | no
   | This is where you declare dependencies which are only required at test compile time, but should not leak into the runtime. This typically includes dependencies which are shaded when found at runtime.
   
   | `testRuntimeOnly`
   | Declaring test runtime dependencies
   | no
   | no
   | This is where you declare dependencies which are only required at test runtime, and not at test compile time.
   |===
   
   .Java Library plugin  configurations used by consumers
   [%header%autowidth,compact]
   |===
   | Configuration name | Role | Consumable? | Resolvable? | Description
   
   | `apiElements`
   | For compiling against this library
   | yes
   | no
   | This configuration is meant to be used by consumers, to retrieve all the elements necessary to compile against this library.
   
   | `runtimeElements`
   | For executing this library
   | yes
   | no
   | This configuration is meant to be used by consumers, to retrieve all the elements necessary to run against this library.
   |===
   
   .Java Library plugin - configurations used by the library itself
   [%header%autowidth,compact]
   |===
   | Configuration name | Role | Consumable? | Resolvable? | Description
   
   | compileClasspath
   | For compiling this library
   | no
   | yes
   | This configuration contains the compile classpath of this library, and is therefore used when invoking the java compiler to compile it.
   
   | runtimeClasspath
   | For executing this library
   | no
   | yes
   | This configuration contains the runtime classpath of this library
   
   | testCompileClasspath
   | For compiling the tests of this library
   | no
   | yes
   | This configuration contains the test compile classpath of this library.
   
   | testRuntimeClasspath
   | For executing tests of this library
   | no
   | yes
   | This configuration contains the test runtime classpath of this library
   |===
   
   == Building Modules for the Java Module System
   
   Since Java 9, Java itself offers a https://www.oracle.com/corporate/features/understanding-java-9-modules.html[module system] that allows for strict encapsulation during compile and runtime.
   You can turn a Java library into a _Java Module_ by creating a `module-info.java` file in the `main/java` source folder.
   
   ```
   src
   較덕較 main
       較덕較 java
           較덕較 module-info.java
   ```
   
   In the module info file, you declare a _module name_, which packages of your module you want to _export_ and which other modules you _require_.
   
   [source,java,indent=0]
   .module-info.java file
   ----
   include::{snippetsPath}/java-library/module/groovy/src/main/java/module-info.java[]
   ----
   
   To tell the Java compiler that a Jar is a module, as opposed to a traditional Java library, Gradle needs to place it on the so called _module path_.
   It is an alternative to the _classpath_, which is the traditional way to tell the compiler about compiled dependencies.
   Gradle will automatically put a Jar of your dependencies on the module path, instead of the classpath, if these three things are true:
   
   * `java.modularity.inferModulePath` is *not* turned off
   * We are actually building a module (as opposed to a traditional library) which we expressed by adding the `module-info.java` file.
     (Another option is to add the `Automatic-Module-Name` Jar manifest attribute as <<#sec:java_library_modular_auto,described further down>>.)
   * The Jar our module depends on is itself a module, which Gradles decides based on the presence of a `module-info.class` -- the compiled version of the module descriptor -- in the Jar.
     (Or, alternatively, the presence of an `Automatic-Module-Name` attribute the Jar manifest)
   
   In the following, some more details about defining Java modules and how that interacts with Gradle's dependency management are described.
   You can also look at a link:#[ready made example] to try out the Java Module support directly.
   
   === Declaring module dependencies
   
   There is a direct relationship to the dependencies you declare in the build file and the module dependencies you declare in the `module-info.java` file.
   Ideally the declarations should be in sync as seen in the following table.
   
   .Mapping between Java module directives and Gradle configurations to declare dependencies
   [%header%autowidth,compact]
   |===
   | Java Module Directive | Gradle Configuration | Purpose
   
   | `requires`
   | `implementation`
   | Declaring implementation dependencies
   
   | `requires transitive`
   | `api`
   | Declaring API dependencies
   
   | `requires static`
   | `compileOnly`
   | Declaring compile only dependencies
   
   | `requires static transitive`
   | `compileOnlyApi`
   | Declaring compile only API dependencies
   |===
   
   Gradle currently does not automatically check if the dependency declarations are in sync.
   This may be added in future versions.
   
   For more details on declaring module dependencies, please refer to https://www.oracle.com/corporate/features/understanding-java-9-modules.html[documentation on the Java Module System].
   
   === Declaring package visibility and services
   
   The Java module system supports additional more fine granular encapsulation concepts than Gradle itself currently does.
   For example, you explicitly need to declare which packages are part of your API and which are only visible inside your module.
   Some of these capabilities might be added to Gradle itself in future versions.
   For now, please refer to https://www.oracle.com/corporate/features/understanding-java-9-modules.html[documentation on the Java Module System] to learn how to use these features in Java Modules.
   
   === Declaring module versions
   
   Java Modules also have a version that is encoded as part of the module identity in the `module-info.class` file.
   This version can be inspected when a module is running.
   
   .Declare the module version in the build script or directly as compile task option
   ====
   include::sample[dir="snippets/java-library/module/kotlin",files="build.gradle.kts[tags=declareVersion]"]
   include::sample[dir="snippets/java-library/module/groovy",files="build.gradle[tags=declareVersion]"]
   ====
   
   === Using libraries that are not modules
   
   You probably want to use external libraries, like OSS libraries from Maven Central, in your modular Java project.
   Some libraries, in their newer versions, are already full modules with a module descriptor.
   For example, `com.google.code.gson:gson:2.8.9` that has the module name `com.google.gson`.
   
   Others, like `org.apache.commons:commons-lang3:3.10`, may not offer a full module descriptor but will at least contain an `Automatic-Module-Name` entry in their manifest file to define the module's name (`org.apache.commons.lang3` in the example).
   Such modules, that only have a name as module description, are called _automatic module_ that export **all** their packages and can read **all** modules on the module path.
   
   A third case are traditional libraries that provide no module information at all -- for example `commons-cli:commons-cli:1.4`.
   Gradle puts such libraries on the classpath instead of the module path.
   The classpath is then treated as one module (the so called _unnamed_ module) by Java.
   
   .Dependencies to modules and libraries declared in build file
   ====
   include::sample[dir="snippets/java-library/module/kotlin",files="build.gradle.kts[tags=dependencies]"]
   include::sample[dir="snippets/java-library/module/groovy",files="build.gradle[tags=dependencies]"]
   ====
   
   [source,java,indent=0]
   .Module dependencies declared in module-info.java file
   ----
   include::{snippetsPath}/java-library/module/kotlin/src/main/java/module-info.java[]
   ----
   
   While a real module cannot directly depend on the unnamed module (only by adding command line flags), automatic modules can also see the unnamed module.
   Thus, if you cannot avoid to rely on a library without module information, you can wrap that library in an automatic module as part of your project.
   How you do that is described in the next section.
   
   Another way to deal with non-modules is to enrich existing Jars with module descriptors yourself using <<artifact_transforms.adoc#sec:abm_artifact_transforms,artifact transforms>>.
   link:#[This sample] contains a small _buildSrc_ plugin registering such a transform which you may use and adjust to your needs.
   This can be interesting if you want to build a fully <<application_plugin.adoc#sec:application_modular,modular application>> and want the java runtime to treat everything as a real module.
   
   === Disabling Java Module support
   
   In rare cases, you might want to disable the built-in Java Module support and define the module path by other means.
   To achieve this, you can disable the functionality to automatically put any Jar on the module path.
   Then Gradle puts Jars with module information on the classpath, even if you have a `module-info.java` in your source set.
   This corresponds to the behaviour of Gradle versions <7.0.
   
   To make this work, you need to set `modularity.inferModulePath = false` on the Java extension (for all tasks) or on individual tasks.
   
   .Disable Gradle's module path inference
   ====
   include::sample[dir="snippets/java-library/module-disabled/kotlin",files="build.gradle.kts[tags=disableModulePath]"]
   include::sample[dir="snippets/java-library/module-disabled/groovy",files="build.gradle[tags=disableModulePath]"]
   ====
   
   === Building an automatic module
   
   If you can, you should always write complete `module-info.java` descriptors for your modules.
   Still, there are a few cases where you might consider to (initally) only provide a _module name_ for an automatic module:
   
   - You are working on a library that is **not** a module but you want to make it usable as such in the next release.
     Adding an `Automatic-Module-Name` is a good first step (most popular OSS libraries on Maven central have done it by now).
   - As discussed in the previous section, an automatic module can be used as an adapter between your real modules and a traditional library on the classpath.
   
   To turn a normal Java project into an _automatic module_, just add the manifest entry with the module name:
   
   .Declare an automatic module name as Jar manifest attribute
   ====
   include::sample[dir="snippets/java-library/module/kotlin",files="build.gradle.kts[tags=automaticModuleName]"]
   include::sample[dir="snippets/java-library/module/groovy",files="build.gradle[tags=automaticModuleName]"]
   ====
   
   [NOTE]
   ===
   You can define an automatic module as part of a multi-project that otherwise defines real modules (e.g. as an adapter to another library).
   While this works fine in the Gradle build, such automatic module projects are not correctly recognized by IDEA/Eclipse at the moment.
   You can work around it by manually adding the Jar built for the automatic module to the dependencies of the project that does not find it in the IDE's UI.
   ===
   
   == Using classes instead of jar for compilation
   
   A feature of the `java-library` plugin is that projects which consume the library only require the classes folder for compilation, instead of the full JAR.
   This enables lighter inter-project dependencies as resources processing (`processResources` task) and archive construction (`jar` task) are no longer executed when only Java code compilation is performed during development.
   
   NOTE: The usage or not of the classes output instead of the JAR is a _consumer_ decision.
   For example, Groovy consumers will request classes _and_ processed resources as these may be needed for executing AST transformation as part of the compilation process.
   
   === Increased memory usage for consumers
   
   An indirect consequence is that up-to-date checking will require more memory, because Gradle will snapshot individual class files instead of a single jar.
   This may lead to increased memory consumption for large projects, with the benefit of having the `compileJava` task up-to-date in more cases (e.g. changing resources no longer changes the input for `compileJava` tasks of upstream projects)
   
   === Significant build performance drop on Windows for huge multi-projects
   
   Another side effect of the snapshotting of individual class files, only affecting Windows systems, is that the performance can significantly drop when processing a very large amount of class files on the compile classpath.
   This only concerns very large multi-projects where a lot of classes are present on the classpath by using many `api` or (deprecated) `compile` dependencies.
   To mitigate this, you can set the `org.gradle.java.compile-classpath-packaging` system property to `true` to change the behavior of the Java Library plugin to use jars instead of class folders for everything on the compile classpath.
   Note, since this has other performance impacts and potentially side effects, by triggering all jar tasks at compile time, it is only recommended to activate this if you suffer from the described performance issue on Windows.
   
   == Distributing a library
   
   Aside from <<publishing_setup.adoc#publishing_components,publishing>> a library to a component repository, you may sometimes need to package a library and its dependencies in a distribution deliverable.
   The <<java_library_distribution_plugin.adoc#java_library_distribution_plugin,Java Library Distribution Plugin>> is there to help you do just that.

/docs/userguide/jvm/application_plugin.adoc
===========================================

.. code-block::

   = The Application Plugin
   
   The Application plugin facilitates creating an executable JVM application. It makes it easy to start the application locally during development, and to package the application as a TAR and/or ZIP including operating system specific start scripts.
   
   Applying the Application plugin also implicitly applies the <<java_plugin.adoc#java_plugin,Java plugin>>. The `main` source set is effectively the 라pplication.
   
   Applying the Application plugin also implicitly applies the <<distribution_plugin.adoc#distribution_plugin,Distribution plugin>>. A `main` distribution is created that packages up the application, including code dependencies and generated start scripts.
   
   
   == Building JVM applications
   
   To use the application plugin, include the following in your build script:
   
   .Using the application plugin
   ====
   include::sample[dir="snippets/java/application/kotlin",files="build.gradle.kts[tags=use-plugin]"]
   include::sample[dir="snippets/java/application/groovy",files="build.gradle[tags=use-plugin]"]
   ====
   
   The only mandatory configuration for the plugin is the specification of the main class (i.e. entry point) of the application.
   
   .Configure the application main class
   ====
   include::sample[dir="snippets/java/application/kotlin",files="build.gradle.kts[tags=mainClass-conf]"]
   include::sample[dir="snippets/java/application/groovy",files="build.gradle[tags=mainClass-conf]"]
   ====
   
   You can run the application by executing the `run` task (type: link:{javadocPath}#[JavaExec]). This will compile the main source set, and launch a new JVM with its classes (along with all runtime dependencies) as the classpath and using the specified main class. You can launch the application in debug mode with `gradle run --debug-jvm` (see link:{javadocPath}#[JavaExec.setDebug(boolean)]).
   
   Since Gradle 4.9, the command line arguments can be passed with `--args`. For example, if you want to launch the application with command line arguments `foo --bar`, you can use `gradle run --args="foo --bar"` (see link:{javadocPath}#[JavaExec.setArgsString(java.lang.String)].
   
   If your application requires a specific set of JVM settings or system properties, you can configure the `applicationDefaultJvmArgs` property. These JVM arguments are applied to the `run` task and also considered in the generated start scripts of your distribution.
   
   .Configure default JVM settings
   ====
   include::sample[dir="snippets/java/application/kotlin",files="build.gradle.kts[tags=application-defaultjvmargs]"]
   include::sample[dir="snippets/java/application/groovy",files="build.gradle[tags=application-defaultjvmargs]"]
   ====
   
   If your application's start scripts should be in a different directory than `bin`, you can configure the `executableDir` property.
   
   .Configure custom directory for start scripts
   ====
   include::sample[dir="snippets/java/application/kotlin",files="build.gradle.kts[tags=executableDir-conf]"]
   include::sample[dir="snippets/java/application/groovy",files="build.gradle[tags=executableDir-conf]"]
   ====
   
   == Building applications using the Java Module System
   
   Gradle supports the building of https://www.oracle.com/corporate/features/understanding-java-9-modules.html[Java Modules] as described in the <<java_library_plugin.adoc#sec:java_library_modular,corresponding section of the Java Library plugin documentation>>.
   Java modules can also be runnable and you can use the application plugin to run and package such a modular application.
   For this, you need to do two things in addition to what you do for a non-modular application.
   
   First, you need to add a `module-info.java` file to describe your application module.
   Please refer to the <<java_library_plugin.adoc#sec:java_library_modular,Java Library plugin documentation>> for more details on this topic.
   
   Second, you need to tell Gradle the name of the module you want to run in addition to the main class name like this:
   
   .Configure the modular application's main module
   ====
   include::sample[dir="snippets/java/application/kotlin",files="build.gradle.kts[tags=mainModule-conf]"]
   include::sample[dir="snippets/java/application/groovy",files="build.gradle[tags=mainModule-conf]"]
   ====
   
   That's all.
   If you run your application, by executing the `run` task or through a <<#sec:the_distribution,generated start script>>, it will run as module and respect module boundaries at runtime.
   For example, reflective access to an internal package from another module can fail.
   
   The configured _main class_ is also baked into the `module-info.class` file of your application Jar.
   If you run the modular application directly using the `java` command, it is then sufficient to provide the module name.
   
   You can also look at a link:#[ready made example] that includes a modular application as part of a multi-project.
   
   == Building a distribution
   
   A distribution of the application can be created, by way of the <<distribution_plugin.adoc#distribution_plugin,Distribution plugin>> (which is automatically applied). A `main` distribution is created with the following content:
   
   .Distribution content
   [%header%autowidth]
   |===
   | Location | Content
   
   | (root dir)
   | `src/dist`
   
   | `lib`
   | All runtime dependencies and main source set class files.
   
   | `bin`
   | Start scripts (generated by `startScripts` task).
   |===
   
   Static files to be added to the distribution can be simply added to `src/dist`. More advanced customization can be done by configuring the link:{javadocPath}#[CopySpec] exposed by the main distribution.
   
   .Include output from other tasks in the application distribution
   ====
   include::sample[dir="snippets/java/application/kotlin",files="build.gradle.kts[tags=distribution-spec]"]
   include::sample[dir="snippets/java/application/groovy",files="build.gradle[tags=distribution-spec]"]
   ====
   
   By specifying that the distribution should include the task's output files (see <<incremental_build.adoc#sec:task_inputs_outputs, incremental builds>>), Gradle knows that the task that produces the files must be invoked before the distribution can be assembled and will take care of this for you.
   
   You can run `gradle installDist` to create an image of the application in `build/install/__projectName__`. You can run `gradle distZip` to create a ZIP containing the distribution, `gradle distTar` to create an application TAR or `gradle assemble` to build both.
   
   === Customizing start script generation
   
   The application plugin can generate Unix (suitable for Linux, macOS etc.) and Windows start scripts out of the box.
   The start scripts launch a JVM with the specified settings defined as part of the original build and runtime environment (e.g. `JAVA_OPTS` env var).
   The default script templates are based on the same scripts used to launch Gradle itself, that ship as part of a Gradle distribution.
   
   The start scripts are completely customizable.
   Please refer to the documentation of link:{groovyDslPath}#[CreateStartScripts] for more details and customization examples.
   
   == Tasks
   
   The Application plugin adds the following tasks to the project.
   
   `run`  link:{groovyDslPath}#[JavaExec]::
   _Depends on_: `classes`
   +
   Starts the application.
   
   `startScripts`  link:{groovyDslPath}#[CreateStartScripts]::
   _Depends on_: `jar`
   +
   Creates OS specific scripts to run the project as a JVM application.
   
   `installDist`  link:{groovyDslPath}#[Sync]::
   _Depends on_: `jar`, `startScripts`
   +
   Installs the application into a specified directory.
   
   `distZip`  link:{groovyDslPath}#[Zip]::
   _Depends on_: `jar`, `startScripts`
   +
   Creates a full distribution ZIP archive including runtime libraries and OS specific scripts.
   
   `distTar`  link:{groovyDslPath}#[Tar]::
   _Depends on_: `jar`, `startScripts`
   +
   Creates a full distribution TAR archive including runtime libraries and OS specific scripts.
   
   == Application extension
   
   The Application Plugin adds an extension to the project, which you can use to configure its behavior. See the link:{groovyDslPath}#[JavaApplication] DSL documentation for more information on the properties available on the extension.
   
   You can configure the extension via the `application {}` block shown earlier, for example using the following in your build script:
   
   ====
   include::sample[dir="snippets/java/application/kotlin",files="build.gradle.kts[tags=executableDir-conf]"]
   include::sample[dir="snippets/java/application/groovy",files="build.gradle[tags=executableDir-conf]"]
   ====
   
   == License of start scripts
   
   The start scripts generated for the application are licensed under the https://www.apache.org/licenses/LICENSE-2.0[Apache 2.0 Software License].
   
   == Convention properties (deprecated)
   
   This plugin also adds some convention properties to the project, which you can use to configure its behavior. These are *deprecated* and superseded by the extension described above. See the link:{groovyDslPath}#[Project] DSL documentation for information on them.
   
   Unlike the extension properties, these properties appear as top-level project properties in the build script. For example, to change the application name you can just add the following to your build script:
   
   ====
   include::sample[dir="snippets/java/application/kotlin",files="build.gradle.kts[tags=applicationName-conf]"]
   include::sample[dir="snippets/java/application/groovy",files="build.gradle[tags=applicationName-conf]"]
   ====

/docs/userguide/jvm/java_platform_plugin.adoc
=============================================

.. code-block::

   :maven-bom: https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Management
   :spring-boot-bom: https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-build-systems.html#using-boot-dependency-management
   :metadata-file-spec: https://github.com/gradle/gradle/blob/master/platforms/documentation/docs/src/docs/design/gradle-module-metadata-latest-specification.md
   
   = The Java Platform Plugin
   
   The Java Platform plugin brings the ability to declare platforms for the Java ecosystem.
   A platform can be used for different purposes:
   
   - a description of modules which are published together (and for example, share the same version)
   - a set of recommended versions for heterogeneous libraries. A typical example includes the {spring-boot-bom}[Spring Boot BOM]
   - <<sec:java_platform_consumption,sharing a set of dependency versions>> between subprojects
   
   A platform is a special kind of software component which doesn't contain any sources:
   it is only used to reference other libraries, so that they play well together during dependency resolution.
   
   Platforms can be published as {metadata-file-spec}[Gradle Module Metadata] and {maven-bom}[Maven BOMs].
   
   NOTE: The `java-platform` plugin cannot be used in combination with the `java` or `java-library` plugins in a given project.
   Conceptually a project is either a platform, with no binaries, _or_ produces binaries.
   
   == Usage
   
   To use the Java Platform plugin, include the following in your build script:
   
   .Using the Java Platform plugin
   ====
   include::sample[dir="snippets/java-platform/quickstart/kotlin",files="build.gradle.kts[tags=use-plugin]"]
   include::sample[dir="snippets/java-platform/quickstart/groovy",files="build.gradle[tags=use-plugin]"]
   ====
   
   
   == API and runtime separation
   
   A major difference between a Maven BOM and a Java platform is that in Gradle dependencies and <<dependency_management_terminology.adoc#sub:terminology_dependency_constraint,constraints>> are declared and scoped to a configuration and the ones extending it.
   While many users will only care about declaring constraints for _compile time_ dependencies, thus inherited by runtime and tests ones, it allows declaring dependencies or constraints that only apply to runtime or test.
   
   For this purpose, the plugin exposes two <<declaring_dependencies.adoc#sec:what-are-dependency-configurations,configurations>> that can be used to declare dependencies: `api` and `runtime`.
   The `api` configuration should be used to declare constraints and dependencies which should be used when compiling against the platform, whereas the `runtime` configuration should be used to declare constraints or dependencies which are visible at runtime.
   
   .Declaring API and runtime constraints
   ====
   include::sample[dir="snippets/java-platform/quickstart/kotlin",files="build.gradle.kts[tags=constraints]"]
   include::sample[dir="snippets/java-platform/quickstart/groovy",files="build.gradle[tags=constraints]"]
   ====
   
   Note that this example makes use of _constraints_ and not dependencies.
   In general, this is what you would like to do: constraints will only apply if such a component is added to the dependency graph, either directly or transitively.
   This means that all constraints listed in a platform would not add a dependency unless another component brings it in: they can be seen as _recommendations_.
   
   [NOTE]
   ====
   For example, if a platform declares a constraint on `org:foo:1.1`, and that nothing else brings in a dependency on `foo`, `foo` will _not_ appear in the graph.
   However, if `foo` appears, then usual conflict resolution would kick in.
   If a dependency brings in `org:foo:1.0`, then we would select `org:foo:1.1` to satisfy the platform constraint.
   ====
   
   By default, in order to avoid the common mistake of adding a dependency in a platform instead of a constraint, Gradle will fail if you try to do so.
   If, for some reason, you also want to add _dependencies_ in addition to constraints, you need to enable it explicitly:
   
   .Allowing declaration of dependencies
   ====
   include::sample[dir="snippets/java-platform/quickstart/kotlin",files="build.gradle.kts[tags=allow-dependencies]"]
   include::sample[dir="snippets/java-platform/quickstart/groovy",files="build.gradle[tags=allow-dependencies]"]
   ====
   
   == Local project constraints
   
   If you have a multi-project build and want to publish a platform that links to subprojects, you can do it by declaring constraints on the subprojects which belong to the platform, as in the example below:
   
   .Declaring constraints on subprojects
   ====
   include::sample[dir="snippets/java-platform/multiproject/kotlin/platform",files="build.gradle.kts[tags=project-constraints]"]
   include::sample[dir="snippets/java-platform/multiproject/groovy/platform",files="build.gradle[tags=project-constraints]"]
   ====
   
   The project notation will become a classical `group:name:version` notation in the published metadata.
   
   == Sourcing constraints from another platform
   
   Sometimes the platform you define is an extension of another existing platform.
   
   In order to have your platform include the constraints from that third party platform, it needs to be imported as a `platform` _dependency_:
   
   .Importing a platform
   ====
   include::sample[dir="snippets/java-platform/quickstart/kotlin",files="build.gradle.kts[tags=platform]"]
   include::sample[dir="snippets/java-platform/quickstart/groovy",files="build.gradle[tags=platform]"]
   ====
   
   == Publishing platforms
   
   Publishing Java platforms is done by applying the `maven-publish` plugin and configuring a Maven publication that uses the `javaPlatform` component:
   
   .Publishing as a BOM
   ====
   include::sample[dir="snippets/java-platform/multiproject/kotlin/platform",files="build.gradle.kts[tags=publishing]"]
   include::sample[dir="snippets/java-platform/multiproject/groovy/platform",files="build.gradle[tags=publishing]"]
   ====
   
   This will generate a BOM file for the platform, with a `<dependencyManagement>` block where its `<dependencies>` correspond to the constraints defined in the platform module.
   
   == Consuming platforms
   
   Because a Java Platform is a special kind of component, a dependency on a Java platform has to be declared using the `platform` or `enforcedPlatform` keyword, as explained in the <<platforms.adoc#sub:bom_import,managing transitive dependencies>> section.
   For example, if you want to share dependency versions between subprojects, you can define a platform module which would declare all versions:
   
   .Recommend versions in a platform module
   ====
   include::sample[dir="snippets/java-platform/recommender/kotlin/platform",files="build.gradle.kts[tags=define-platform]"]
   include::sample[dir="snippets/java-platform/recommender/groovy/platform",files="build.gradle[tags=define-platform]"]
   ====
   
   And then have subprojects depend on the platform to get recommendations:
   
   .Get recommendations from a platform
   ====
   include::sample[dir="snippets/java-platform/recommender/kotlin/consumer",files="build.gradle.kts[tags=get-recommendations]"]
   include::sample[dir="snippets/java-platform/recommender/groovy/consumer",files="build.gradle[tags=get-recommendations]"]
   ====

/docs/userguide/jvm/groovy_plugin.adoc
======================================

.. code-block::

   = The Groovy Plugin
   
   The Groovy plugin extends the <<java_plugin.adoc#java_plugin,Java plugin>> to add support for https://groovy-lang.org/[Groovy] projects.
   It can deal with Groovy code, mixed Groovy and Java code, and even pure Java code (although we don't necessarily recommend to use it for the latter).
   The plugin supports _joint compilation_, which allows you to freely mix and match Groovy and Java code, with dependencies in both directions.
   For example, a Groovy class can extend a Java class that in turn extends a Groovy class.
   This makes it possible to use the best language for the job, and to rewrite any class in the other language if needed.
   
   Note that if you want to benefit from the <<java_library_plugin.adoc#sec:java_library_separation,API / implementation separation>>, you can also apply the `java-library` plugin to your Groovy project.
   
   
   == Usage
   
   To use the Groovy plugin, include the following in your build script:
   
   .Using the Groovy plugin
   ====
   include::sample[dir="snippets/groovy/quickstart/kotlin",files="build.gradle.kts[tags=use-plugin]"]
   include::sample[dir="snippets/groovy/quickstart/groovy",files="build.gradle[tags=use-plugin]"]
   ====
   
   == Tasks
   
   The Groovy plugin adds the following tasks to the project.
   Information about altering the dependencies to Java compile tasks are found <<building_java_projects.adoc#sec:building_jvm_lang,here>>.
   
   `compileGroovy`  link:{groovyDslPath}#[GroovyCompile]::
   _Depends on_: `compileJava`
   +
   Compiles production Groovy source files.
   
   `compileTestGroovy`  link:{groovyDslPath}#[GroovyCompile]::
   _Depends on_: `compileTestJava`
   +
   Compiles test Groovy source files.
   
   `compile__SourceSet__Groovy`  link:{groovyDslPath}#[GroovyCompile]::
   _Depends on_: `compile__SourceSet__Java`
   +
   Compiles the given source set's Groovy source files.
   
   `groovydoc`  link:{groovyDslPath}#[Groovydoc]::
   +
   Generates API documentation for the production Groovy source files.
   
   The Groovy plugin adds the following dependencies to tasks added by the Java plugin.
   
   .Groovy plugin - additional task dependencies
   [%header%autowidth,compact]
   |===
   | Task name | Depends on
   | `classes` | `compileGroovy`
   | `testClasses` | `compileTestGroovy`
   | `__sourceSet__Classes` | `compile__SourceSet__Groovy`
   |===
   
   .Groovy plugin - tasks
   image::groovyPluginTasks.png[]
   
   
   == Project layout
   
   The Groovy plugin assumes the project layout shown in <<#groovylayout,Groovy Layout>>. All the Groovy source directories can contain Groovy _and_ Java code. The Java source directories may only contain Java source code.footnote:[Gradle uses the same conventions as introduced by Russel Winder's link:https://gant.github.io/[Gant tool].] None of these directories need to exist or have anything in them; the Groovy plugin will simply compile whatever it finds.
   
   include::javaProjectMainLayout.adoc[]
   
   `src/main/groovy`::
   Production Groovy source. May also contain Java source files for joint compilation.
   
   include::javaProjectTestLayout.adoc[]
   
   `src/test/groovy`::
   Test Groovy source. May also contain Java source files for joint compilation.
   
   include::javaProjectGenericLayout.adoc[]
   
   `src/__sourceSet__/groovy`::
   Groovy source files for the given source set. May also contain Java source files for joint compilation.
   
   
   === Changing the project layout
   
   Just like the Java plugin, the Groovy plugin allows you to configure custom locations for Groovy production and test source files.
   
   .Custom Groovy source layout
   ====
   include::sample[dir="snippets/groovy/customizedLayout/kotlin",files="build.gradle.kts[tags=custom-source-locations]"]
   include::sample[dir="snippets/groovy/customizedLayout/groovy",files="build.gradle[tags=custom-source-locations]"]
   ====
   
   == Dependency management
   
   Because Gradle's build language is based on Groovy, and parts of Gradle are implemented in Groovy, Gradle already ships with a Groovy library. Nevertheless, Groovy projects need to explicitly declare a Groovy dependency. This dependency will then be used on compile and runtime class paths. It will also be used to get hold of the Groovy compiler and Groovydoc tool, respectively.
   
   If Groovy is used for production code, the Groovy dependency should be added to the `implementation` configuration:
   
   .Configuration of Groovy dependency
   ====
   include::sample[dir="snippets/groovy/quickstart/kotlin",files="build.gradle.kts[tags=groovy-dependency]"]
   include::sample[dir="snippets/groovy/quickstart/groovy",files="build.gradle[tags=groovy-dependency]"]
   ====
   
   If Groovy is only used for test code, the Groovy dependency should be added to the `testImplementation` configuration:
   
   .Configuration of Groovy test dependency
   ====
   include::sample[dir="snippets/groovy/groovyDependency/kotlin",files="build.gradle.kts[tags=groovy-test-dependency]"]
   include::sample[dir="snippets/groovy/groovyDependency/groovy",files="build.gradle[tags=groovy-test-dependency]"]
   ====
   
   To use the Groovy library that ships with Gradle, declare a `localGroovy()` dependency. Note that different Gradle versions ship with different Groovy versions; as such, using `localGroovy()` is less safe then declaring a regular Groovy dependency.
   
   .Configuration of bundled Groovy dependency
   ====
   include::sample[dir="snippets/groovy/groovyDependency/kotlin",files="build.gradle.kts[tags=bundled-groovy-dependency]"]
   include::sample[dir="snippets/groovy/groovyDependency/groovy",files="build.gradle[tags=bundled-groovy-dependency]"]
   ====
   
   == Automatic configuration of groovyClasspath
   
   The `GroovyCompile` and `Groovydoc` tasks consume Groovy code in two ways: on their `classpath`, and on their `groovyClasspath`. The former is used to locate classes referenced by the source code, and will typically contain the Groovy library along with other libraries. The latter is used to load and execute the Groovy compiler and Groovydoc tool, respectively, and should only contain the Groovy library and its dependencies.
   
   Unless a task's `groovyClasspath` is configured explicitly, the Groovy (base) plugin will try to infer it from the task's `classpath`. This is done as follows:
   
   * If a `groovy-all(-indy)` Jar is found on `classpath`, that jar will be added to `groovyClasspath`.
   * If a `groovy(-indy)` jar is found on `classpath`, and the project has at least one repository declared, a corresponding `groovy(-indy)` repository dependency will be added to `groovyClasspath`.
   * Otherwise, execution of the task will fail with a message saying that `groovyClasspath` could not be inferred.
   
   Note that the `-indy` variation of each jar refers to the version with `invokedynamic` support.
   
   == Convention properties
   
   The Groovy plugin does not add any convention properties to the project.
   
   == Source set properties
   
   The Groovy plugin adds the following extensions to each source set in the project. You can use these properties in your build script as though they were properties of the source set object.
   
   === Groovy Plugin  source set properties
   
   `groovy`  link:{groovyDslPath}#[GroovySourceDirectorySet] (read-only)::
   _Default value_: Not null
   +
   The Groovy source files of this source set. Contains all `.groovy` and `.java` files found in the Groovy source directories, and excludes all other types of files.
   
   `groovy.srcDirs`  `Set&lt;File&gt;`::
   _Default value_: `[__projectDir__/src/__name__/groovy]`
   +
   The source directories containing the Groovy source files of this source set. May also contain Java source files for joint compilation. Can set using anything described in <<working_with_files.adoc#sec:specifying_multiple_files,Specifying Multiple Files>>.
   
   `allGroovy`  link:{javadocPath}#[FileTree] (read-only)::
   _Default value_: Not null
   +
   All Groovy source files of this source set. Contains only the `.groovy` files found in the Groovy source directories.
   
   These properties are provided by a convention object of type link:{groovyDslPath}#[GroovySourceSet].
   
   The Groovy plugin also modifies some source set properties:
   
   === Groovy Plugin - modified source set properties
   
   [%header%autowidth,compact]
   |===
   | Property name | Change
   | `allJava` | Adds all `.java` files found in the Groovy source directories.
   | `allSource` | Adds all source files found in the Groovy source directories.
   |===
   
   
   == GroovyCompile
   
   The Groovy plugin adds a link:{groovyDslPath}#[GroovyCompile] task for each source set in the project.
   The task type shares much with the `JavaCompile` task by extending `AbstractCompile` (see <<building_java_projects.adoc#sec:compile, the relevant Java Plugin section>>).
   The `GroovyCompile` task supports most configuration options of the official Groovy compiler.
   The task can also leverage the <<toolchains.adoc#toolchains,Java toolchain support>>.
   
   .Groovy plugin - GroovyCompile properties
   [%header%autowidth,compact]
   |===
   | Task Property | Type | Default Value
   
   |  `classpath`
   | link:{javadocPath}#[FileCollection]
   | `__sourceSet__.compileClasspath`
   
   |  `source`
   | link:{javadocPath}#[FileTree].
   Can set using anything described in <<working_with_files.adoc#sec:specifying_multiple_files,Specifying Multiple Files>>.
   | `__sourceSet__.groovy`
   
   |  `destinationDirectory`
   | `File`.
   | `__sourceSet__.groovy.destinationDirectory`
   
   |  `groovyClasspath`
   | link:{javadocPath}#[FileCollection]
   | `groovy` configuration if non-empty; Groovy library found on `classpath` otherwise
   
   |  `javaLauncher`
   | `Property<JavaLauncher>`, see the <<toolchains.adoc#toolchains,toolchain documentation>>.
   | None but will be configured if a toolchain is defined on the `java` extension.
   |===
   
   === Compilation avoidance
   
   _Caveat: Groovy compilation avoidance is an incubating feature since Gradle 5.6. There are known inaccuracies so please enable it at your own risk._
   
   To enable the incubating support for Groovy compilation avoidance, add a link:{javadocPath}#[`enableFeaturePreview`] to your settings file:
   
   ====
   [.multi-language-sample]
   =====
   .settings.gradle
   [source, groovy]
   ----
   enableFeaturePreview('GROOVY_COMPILATION_AVOIDANCE')
   ----
   =====
   [.multi-language-sample]
   =====
   .settings.gradle.kts
   [source,kotlin]
   ----
   enableFeaturePreview("GROOVY_COMPILATION_AVOIDANCE")
   ----
   =====
   ====
   
   If a dependent project has changed in an https://en.wikipedia.org/wiki/Application_binary_interface[ABI]-compatible way (only its private API has changed), then Groovy compilation tasks will be up-to-date.
   This means that if project `A` depends on project `B` and a class in `B` is changed in an ABI-compatible way (typically, changing only the body of a method), then Gradle won't recompile `A`.
   
   See <<java_plugin.adoc#sec:java_compile_avoidance,Java compile avoidance>> for a detailed list of the types of changes that do not affect the ABI and are ignored.
   
   However, similar to Java's annotation processing, there are various ways to https://melix.github.io/blog/2011/05/12/customizing_groovy_compilation_process.html[customize the Groovy compilation process], for which implementation details matter.
   Some well-known examples are https://groovy-lang.org/metaprogramming.html#_code_generation_transformations[Groovy AST transformations].
   In these cases, these dependencies must be declared separately in a classpath called `astTransformationClasspath`:
   
   .Declaring AST transformations
   ====
   include::sample[dir="snippets/groovy/compilationAvoidance/kotlin/ast-transformation-consumer", files="build.gradle.kts[tags=groovy-compilation-avoidance]"]
   include::sample[dir="snippets/groovy/compilationAvoidance/groovy/ast-transformation-consumer", files="build.gradle[tags=groovy-compilation-avoidance]"]
   ====
   
   == Incremental Groovy compilation
   
   Since 5.6, Gradle introduces an experimental incremental Groovy compiler. To enable incremental compilation for Groovy, you need:
   
   * Enable <<groovy_plugin.adoc#sec:groovy_compilation_avoidance,Groovy compilation avoidance>>.
   * Explicitly enable incremental Groovy compilation in the build script:
   
   .Enable incremental Groovy compilation
   ====
   include::sample[dir="snippets/groovy/incrementalCompilation/kotlin",files="buildSrc/src/main/kotlin/myproject.groovy-conventions.gradle.kts[tags=enable-groovy-incremental]"]
   include::sample[dir="snippets/groovy/incrementalCompilation/groovy",files="buildSrc/src/main/groovy/myproject.groovy-conventions.gradle[tags=enable-groovy-incremental]"]
   ====
   
   This gives you the following benefits:
   
   * Incremental builds are much faster.
   * If only a small set of Groovy source files are changed, only the affected source files will be recompiled.
     Classes that don't need to be recompiled remain unchanged in the output directory.
     For example, if you only change a few Groovy test classes, you don't need to recompile all Groovy test source files  only the changed ones need to be recompiled.
   
   To understand how incremental compilation works, see <<java_plugin.adoc#sec:incremental_compile,Incremental Java compilation>> for a detailed overview.
   Note that there're several differences from Java incremental compilation:
   
   The Groovy compiler doesn't keep `@Retention` in generated annotation class bytecode (https://issues.apache.org/jira/browse/GROOVY-9185[GROOVY-9185]), thus all annotations are `RUNTIME`.
   This means that changes to source-retention annotations won't trigger a full recompilation.
   
   === Known issues
   
   Also see <<java_plugin.adoc#sec:incremental_compilation_known_issues,Known issues for incremental Java compilation>>.
   
   * Changes to resources won't trigger a recompilation, this might result in some incorrectness  for example https://mrhaki.blogspot.com/2013/01/groovy-goodness-adding-extra-methods.html[Extension Modules].
   
   == Compiling and testing for Java 6 or Java 7
   
   With <<toolchains.adoc#toolchains,toolchain support>> added to `GroovyCompile`, it is possible to compile Groovy code using a different Java version than the one running Gradle.
   If you also have Java source files, this will also configure `JavaCompile` to use the right Java compiler is used, as can be seen in the <<building_java_projects.adoc#sec:java_cross_compilation,Java plugin>> documentation.
   
   === Example: Configure Java 7 build for Groovy
   
   ====
   include::sample[dir="snippets/groovy/crossCompilation/kotlin",files="build.gradle.kts[tags=groovy-cross-compilation]"]
   include::sample[dir="snippets/groovy/crossCompilation/groovy",files="build.gradle[tags=groovy-cross-compilation]"]
   ====
   

/docs/userguide/jvm/scala_plugin.adoc
=====================================

.. code-block::

   = The Scala Plugin
   
   The Scala plugin extends the <<java_plugin.adoc#java_plugin,Java plugin>> to add support for https://www.scala-lang.org/[Scala] projects.
   The plugin also supports _joint compilation_, which allows you to freely mix and match Scala and Java code with dependencies in both directions.
   For example, a Scala class can extend a Java class that in turn extends a Scala class.
   This makes it possible to use the best language for the job, and to rewrite any class in the other language if needed.
   
   Note that if you want to benefit from the <<java_library_plugin.adoc#sec:java_library_separation,API / implementation separation>>, you can also apply the `java-library` plugin to your Scala project.
   
   
   == Usage
   
   To use the Scala plugin, include the following in your build script:
   
   .Using the Scala plugin
   ====
   include::sample[dir="snippets/scala/quickstart/kotlin",files="build.gradle.kts[tags=use-plugin]"]
   include::sample[dir="snippets/scala/quickstart/groovy",files="build.gradle[tags=use-plugin]"]
   ====
   
   == Tasks
   
   The Scala plugin adds the following tasks to the project.
   Information about altering the dependencies to Java compile tasks are found <<building_java_projects.adoc#sec:building_jvm_lang,here>>.
   
   `compileScala`  link:{groovyDslPath}#[ScalaCompile]::
   _Depends on_: `compileJava`
   +
   Compiles production Scala source files.
   
   `compileTestScala`  link:{groovyDslPath}#[ScalaCompile]::
   _Depends on_: `compileTestJava`
   +
   Compiles test Scala source files.
   
   `compile__SourceSet__Scala`  link:{groovyDslPath}#[ScalaCompile]::
   _Depends on_: `compile__SourceSet__Java`
   +
   Compiles the given source set's Scala source files.
   
   `scaladoc`  link:{groovyDslPath}#[ScalaDoc]::
   +
   Generates API documentation for the production Scala source files.
   
   The `ScalaCompile` and `ScalaDoc` tasks support <<toolchains.adoc#toolchains,Java toolchains>> out of the box.
   
   The Scala plugin adds the following dependencies to tasks added by the Java plugin.
   
   .Scala plugin - additional task dependencies
   [cols="a,a", options="header"]
   |===
   | Task name
   | Depends on
   |  `classes`
   |  `compileScala`
   
   |  `testClasses`
   |  `compileTestScala`
   
   |  `__sourceSet__Classes`
   |  `compile__SourceSet__Scala`
   |===
   
   .Scala plugin - tasks
   image::scalaPluginTasks.png[]
   
   
   == Project layout
   
   The Scala plugin assumes the project layout shown below. All the Scala source directories can contain Scala _and_ Java code. The Java source directories may only contain Java source code. None of these directories need to exist or have anything in them; the Scala plugin will simply compile whatever it finds.
   
   include::javaProjectMainLayout.adoc[]
   
   `src/main/scala`::
   Production Scala source. May also contain Java source files for joint compilation.
   
   include::javaProjectTestLayout.adoc[]
   
   `src/test/scala`::
   Test Scala source. May also contain Java source files for joint compilation.
   
   include::javaProjectGenericLayout.adoc[]
   
   `src/__sourceSet__/scala`::
   Scala source files for the given source set. May also contain Java source files for joint compilation.
   
   
   === Changing the project layout
   
   Just like the Java plugin, the Scala plugin allows you to configure custom locations for Scala production and test source files.
   
   .Custom Scala source layout
   ====
   include::sample[dir="snippets/scala/customizedLayout/kotlin",files="build.gradle.kts[tags=custom-source-locations]"]
   include::sample[dir="snippets/scala/customizedLayout/groovy",files="build.gradle[tags=custom-source-locations]"]
   ====
   
   == Dependency management
   
   Scala projects need to declare a `scala-library` dependency. This dependency will then be used on compile and runtime class paths. It will also be used to get hold of the Scala compiler and Scaladoc tool, respectively.footnote:[See <<#sec:configure_scala_classpath,Automatic configuration of Scala classpath>>.]
   
   If Scala is used for production code, the `scala-library` dependency should be added to the `implementation` configuration:
   
   .Declaring a Scala dependency for production code
   ====
   include::sample[dir="snippets/scala/quickstart/kotlin",files="build.gradle.kts[tags=scala-dependency]"]
   include::sample[dir="snippets/scala/quickstart/groovy",files="build.gradle[tags=scala-dependency]"]
   ====
   
   If you want to use Scala 3 instead of the `scala-library` dependency you should add the `scala3-library_3` dependency:
   
   .Declaring a Scala 3 dependency for production code
   ====
   include::sample[dir="snippets/scala/scala3/kotlin",files="build.gradle.kts"]
   include::sample[dir="snippets/scala/scala3/groovy",files="build.gradle"]
   ====
   
   If Scala is only used for test code, the `scala-library` dependency should be added to the `testImplementation` configuration:
   
   .Declaring a Scala dependency for test code
   ====
   include::sample[dir="snippets/scala/scalaDependency/kotlin",files="build.gradle.kts[tags=scala-test-dependency]"]
   include::sample[dir="snippets/scala/scalaDependency/groovy",files="build.gradle[tags=scala-test-dependency]"]
   ====
   
   == Automatic configuration of scalaClasspath
   
   The `ScalaCompile` and `ScalaDoc` tasks consume Scala code in two ways: on their `classpath`, and on their `scalaClasspath`. The former is used to locate classes referenced by the source code, and will typically contain `scala-library` along with other libraries. The latter is used to load and execute the Scala compiler and Scaladoc tool, respectively, and should only contain the `scala-compiler` library and its dependencies.
   
   Unless a task's `scalaClasspath` is configured explicitly, the Scala (base) plugin will try to infer it from the task's `classpath`. This is done as follows:
   
   * If a `scala-library` jar is found on `classpath`, and the project has at least one repository declared, a corresponding `scala-compiler` repository dependency will be added to `scalaClasspath`.
   * Otherwise, execution of the task will fail with a message saying that `scalaClasspath` could not be inferred.
   
   
   == Configuring the Zinc compiler
   
   The Scala plugin uses a configuration named `zinc` to resolve the https://github.com/sbt/zinc[Zinc compiler] and its dependencies.
   Gradle will provide a default version of Zinc, but if you need to use a particular Zinc version, you can change it.
   Gradle supports version 1.6.0 of Zinc and above.
   
   .Declaring a version of the Zinc compiler to use
   ====
   include::sample[dir="snippets/scala/zincDependency/kotlin",files="build.gradle.kts[tags=zinc-dependency]"]
   include::sample[dir="snippets/scala/zincDependency/groovy",files="build.gradle[tags=zinc-dependency]"]
   ====
   
   The Zinc compiler itself needs a compatible version of `scala-library` that may be different from the version required by your application.
   Gradle takes care of specifying a compatible version of `scala-library` for you.
   
   You can diagnose problems with the version of the Zinc compiler selected by running <<viewing_debugging_dependencies.adoc#sec:debugging-build-scans,dependencyInsight>> for the `zinc` configuration.
   
   .Zinc compatibility table
   [%header%autowidth,compact]
   |===
   | Gradle version    | Supported Zinc versions | Zinc coordinates | Required Scala version | Supported Scala compilation version
   
   | 7.5 and newer     | link:https://github.com/sbt/zinc[SBT Zinc]. Versions 1.6.0 and above. | `org.scala-sbt:zinc_2.13` | Scala `2.13.x` is required for _running_ Zinc. | Scala `2.10.x` through `3.x` can be compiled.
   | 6.0 to 7.5        | link:https://github.com/sbt/zinc[SBT Zinc]. Versions 1.2.0 and above. | `org.scala-sbt:zinc_2.12` | Scala `2.12.x` is required for _running_ Zinc. | Scala `2.10.x` through `2.13.x` can be compiled.
   | 1.x through 5.x   | link:https://github.com/typesafehub/zinc[**Deprecated** Typesafe Zinc compiler.] Versions 0.3.0 and above, except for 0.3.2 through 0.3.5.2. | `com.typesafe.zinc:zinc` | Scala `2.10.x` is required for _running_ Zinc. | Scala `2.9.x` through `2.12.x` can be compiled.
   
   |===
   
   == Adding plugins to the Scala compiler
   
   The Scala plugin adds a configuration named `scalaCompilerPlugins` which is used to declare and resolve optional compiler plugins.
   
   .Adding a dependency on a Scala compiler plugin
   ====
   include::sample[dir="snippets/scala/compilerPlugin/kotlin",files="build.gradle.kts[tags=compiler-plugin]"]
   include::sample[dir="snippets/scala/compilerPlugin/groovy",files="build.gradle[tags=compiler-plugin]"]
   ====
   
   == Convention properties
   
   The Scala plugin does not add any convention properties to the project.
   
   == Source set properties
   
   The Scala plugin adds the following extensions to each source set in the project. You can use these  in your build script as though they were properties of the source set object.
   
   `scala`  link:{groovyDslPath}#[SourceDirectorySet] (read-only)::
   The Scala source files of this source set. Contains all `.scala` and `.java` files found in the Scala source directories, and excludes all other types of files. _Default value:_ non-null.
   
   `scala.srcDirs`  `Set&lt;File&gt;`::
   The source directories containing the Scala source files of this source set. May also contain Java source files for joint compilation.
   Can set using anything described in <<working_with_files.adoc#sec:specifying_multiple_files,Understanding implicit conversion to file collections>>.
   _Default value:_ `[__projectDir__/src/__name__/scala]`.
   
   `allScala`  link:{javadocPath}#[FileTree] (read-only)::
   All Scala source files of this source set. Contains only the `.scala` files found in the Scala source directories. _Default value:_ non-null.
   
   These extensions are backed by an object of type link:{groovyDslPath}#[ScalaSourceSet].
   
   The Scala plugin also modifies some source set properties:
   
   .Scala plugin - source set properties
   [%header%autowidth,compact]
   |===
   | Property name | Change
   | `allJava` | Adds all `.java` files found in the Scala source directories.
   | `allSource` | Adds all source files found in the Scala source directories.
   |===
   
   == Target bytecode level and Java APIs version
   
   When running the Scala compile task, Gradle will always add a parameter to configure the Java target for the Scala compiler that is derived from the Gradle configuration:
   
   * When using toolchains, the `-release` option, or `target` for older Scala versions, is selected, with a version matching the Java language level of the toolchain configured.
   * When not using toolchains, Gradle will always pass a `target` flag -- with exact value dependent on the Scala version -- to compile to Java 8 bytecode.
   
   NOTE: This means that using toolchains with a recent Java version and an old Scala version can result in failures because Scala only supported Java 8 bytecode for some time.
   The solution is then to either use the right Java version in the toolchain or explicitly downgrade the target when needed.
   
   The following table explains the values computed by Gradle:
   
   .Scala target parameter based on project configuration
   [%header%autowidth,compact]
   |===
   | Scala version | Toolchain in use | Parameter value
   .2+| version < `2.13.1`                 | yes   | `-target:jvm-1.<java_version>`
                                           | no    | `-target:jvm-1.8`
   .2+| `2.13.1` \<= version < `2.13.9`    | yes   | `-target:<java_version>`
                                           | no    | `-target:8`
   .2+| `2.13.9` \<= version < `3.0`       | yes   | `-release:<java_version>`
                                           | no    | `-target:8`
   .2+| `3.0` \<= version                  | yes   | `-release:<java_version>`
                                           | no    | `-Xtarget:8`
   |===
   
   Setting any of these flags explicitly, or using flags containing `java-output-version`, on link:{groovyDslPath}#[`ScalaCompile.scalaCompileOptions.additionalParameters`] disables that logic in favor of the explicit flag.
   
   == Compiling in external process
   
   Scala compilation takes place in an external process.
   
   Memory settings for the external process default to the defaults of the JVM. To adjust memory settings, configure the `scalaCompileOptions.forkOptions` property as needed:
   
   .Adjusting memory settings
   ====
   include::sample[dir="snippets/scala/zinc/kotlin",files="build.gradle.kts[tags=adjust-memory]"]
   include::sample[dir="snippets/scala/zinc/groovy",files="build.gradle[tags=adjust-memory]"]
   ====
   
   == Incremental compilation
   
   By compiling only classes whose source code has changed since the previous compilation, and classes affected by these changes, incremental compilation can significantly reduce Scala compilation time. It is particularly effective when frequently compiling small code increments, as is often done at development time.
   
   The Scala plugin defaults to incremental compilation by integrating with https://github.com/typesafehub/zinc[Zinc], a standalone version of https://github.com/harrah/xsbt[sbt]'s incremental Scala compiler. If you want to disable the incremental compilation, set `force = true` in your build file:
   
   .Forcing all code to be compiled
   ====
   include::sample[dir="snippets/scala/force/kotlin",files="build.gradle.kts[tags=force-compilation]"]
   include::sample[dir="snippets/scala/force/groovy",files="build.gradle[tags=force-compilation]"]
   ====
   
   _Note:_ This will only cause all classes to be recompiled if at least one input source file has changed. If there are no changes to the source files, the `compileScala` task will still be considered `UP-TO-DATE` as usual.
   
   The Zinc-based Scala Compiler supports joint compilation of Java and Scala code. By default, all Java and Scala code under `src/main/scala` will participate in joint compilation. Even Java code will be compiled incrementally.
   
   Incremental compilation requires dependency analysis of the source code. The results of this analysis are stored in the file designated by `scalaCompileOptions.incrementalOptions.analysisFile` (which has a sensible default). In a multi-project build, analysis files are passed on to downstream `ScalaCompile` tasks to enable incremental compilation across project boundaries. For `ScalaCompile` tasks added by the Scala plugin, no configuration is necessary to make this work. For other `ScalaCompile` tasks that you might add, the property `scalaCompileOptions.incrementalOptions.publishedCode` needs to be configured to point to the classes folder or Jar archive by which the code is passed on to compile class paths of downstream `ScalaCompile` tasks. Note that if `publishedCode` is not set correctly, downstream tasks may not recompile code affected by upstream changes, leading to incorrect compilation results.
   
   Note that Zinc's Nailgun based daemon mode is not supported. Instead, we plan to enhance Gradle's own compiler daemon to stay alive across Gradle invocations, reusing the same Scala compiler. This is expected to yield another significant speedup for Scala compilation.
   
   == Eclipse Integration
   
   When the Eclipse plugin encounters a Scala project, it adds additional configuration to make the project work with Scala IDE out of the box. Specifically, the plugin adds a Scala nature and dependency container.
   
   == IntelliJ IDEA Integration
   
   When the IDEA plugin encounters a Scala project, it adds additional configuration to make the project work with IDEA out of the box. Specifically, the plugin adds a Scala SDK (IntelliJ IDEA 14+) and a Scala compiler library that matches the Scala version on the project's class path. The Scala plugin is backwards compatible with earlier versions of IntelliJ IDEA and it is possible to add a Scala facet instead of the default Scala SDK by configuring `targetVersion` on link:{groovyDslPath}#[IdeaModel].
   
   .Explicitly specify a target IntelliJ IDEA version
   ====
   include::sample[dir="snippets/scala/ideaTargetVersion/kotlin",files="build.gradle.kts[tags=scala-idea-target-version]"]
   include::sample[dir="snippets/scala/ideaTargetVersion/groovy",files="build.gradle[tags=scala-idea-target-version]"]
   ====
   

/Topic: 游댯 Working With Dependencies
======================================


/docs/userguide/dep-man/dependency_management.adoc
==================================================

.. code-block::

   = Learning the Basics
   include::core_dependency_management.adoc[leveloffset=+1]
   include::declaring_repositories.adoc[leveloffset=+1]
   include::declaring_dependencies.adoc[leveloffset=+1]
   include::library_vs_application.adoc[leveloffset=+1]
   include::viewing_debugging_dependencies.adoc[leveloffset=+1]
   include::dependency_resolution.adoc[leveloffset=+1]
   include::dependency_verification.adoc[leveloffset=+1]
   
   = Declaring Versions
   include::single_versions.adoc[leveloffset=+1]
   include::rich_versions.adoc[leveloffset=+1]
   include::dynamic_versions.adoc[leveloffset=+1]
   include::dependency_locking.adoc[leveloffset=+1]
   
   = Controlling Transitive Dependencies
   include::dependency_constraints.adoc[leveloffset=+1]
   include::dependency_downgrade_and_exclude.adoc[leveloffset=+1]
   include::platforms.adoc[leveloffset=+1]
   include::dependency_version_alignment.adoc[leveloffset=+1]
   include::dependency_capability_conflict.adoc[leveloffset=+1]
   include::component_metadata_rules.adoc[leveloffset=+1]
   include::resolution_rules.adoc[leveloffset=+1]
   
   = Producing and Consuming Variants of Libraries
   include::component_capabilities.adoc[leveloffset=+1]
   include::feature_variants.adoc[leveloffset=+1]
   include::variant_model.adoc[leveloffset=+1]
   include::variant_attributes.adoc[leveloffset=+1]
   include::cross_project_publications.adoc[leveloffset=+1]
   include::artifact_transforms.adoc[leveloffset=+1]
   
   = Working in a Multi-repo Environment
   include::composite_builds.adoc[leveloffset=+1]
   
   = Publishing Libraries
   include::publishing_setup.adoc[leveloffset=+1]
   include::publishing_gradle_module_metadata.adoc[leveloffset=+1]
   include::publishing_signing.adoc[leveloffset=+1]
   include::publishing_customization.adoc[leveloffset=+1]
   
   include::dependency_management_terminology.adoc[leveloffset=+1]
   
   

/docs/userguide/dep-man/dependency_management_terminology.adoc
==============================================================

.. code-block::

   = Dependency Management Terminology
   
   Dependency management comes with a wealth of terminology.
   Here you can find the most commonly-used terms including references to the user guide to learn about their practical application.
   
   == Artifact
   
   A file or directory produced by a build, such as a JAR, a ZIP distribution, or a native executable.
   
   Artifacts are typically designed to be used or consumed by users or other projects, or deployed to hosting systems.
   In such cases, the artifact is a single file.
   Directories are common in the case of inter-project dependencies to avoid the cost of producing the publishable artifact.
   
   == Capability
   
   A capability identifies a feature offered by one or multiple components.
   A capability is identified by coordinates similar to the coordinates used for <<sub:terminology_module_version,module versions>>.
   By default, each module version offers a capability that matches its coordinates, for example `com.google:guava:18.0`.
   Capabilities can be used to express that a component provides multiple <<sub:terminology_feature_variant,feature variants>> or that two different components implement the same feature (and thus cannot be used together).
   For more details, see the section on <<component_capabilities.adoc#declaring-component-capabilities,capabilities>>.
   
   == Component
   
   Any single version of a <<dependency_management_terminology.adoc#sub:terminology_module,module>>.
   
   For external libraries, the term component refers to one published version of the library.
   
   In a build, components are defined by plugins (e.g. the Java Library plugin) and provide a simple way to define a publication for publishing.
   They comprise <<#sub:terminology_artifact,artifacts>> as well as the appropriate <<#sub:terminology_artifact,metadata>> that describes a component's <<#sub:terminology_variant,variants>> in detail.
   For example, the `java` component in its default setup consists of a JAR 댹맗roduced by the `jar` task 댹마nd the dependency information of the Java _api_ and _runtime_ variants.
   It may also define additional variants, for example _sources_ and _Javadoc_, with the corresponding artifacts.
   
   == Configuration
   
   A configuration is a named set of <<#sub:terminology_dependency,dependencies>> grouped together for a specific goal.
   Configurations provide access to the underlying, resolved <<#sub:terminology_module,modules>> and their artifacts.
   For more information, see the sections on <<declaring_dependencies.adoc#sec:what-are-dependency-configurations,dependency configurations>> as well as <<declaring_dependencies.adoc#sec:resolvable-consumable-configs,resolvable and consumable configurations>>.
   
   NOTE: The word "configuration" is an overloaded term and has a different meaning outside of the context of dependency management.
   
   == Dependency
   
   A dependency is a pointer to another piece of software required to build, test or run a <<#sub:terminology_module,module>>.
   For more information, see the section on <<declaring_dependencies.adoc#declaring-dependencies,declaring dependencies>>.
   
   == Dependency constraint
   
   A dependency constraint defines requirements that need to be met by a module to make it a valid resolution result for the dependency.
   For example, a dependency constraint can narrow down the set of supported module versions.
   Dependency constraints can be used to express such requirements for transitive dependencies.
   For more information, see the sections on <<dependency_constraints.adoc#dependency-constraints,upgrading>> and <<dependency_downgrade_and_exclude.adoc#downgrading_versions_and_excluding_dependencies,downgrading>> transitive dependencies.
   
   == Feature Variant
   
   A feature variant is a <<#sub:terminology_variant,variant>> representing a feature of a component that can be individually selected or not.
   A feature variant is identified by one or more <<#sub:terminology_capability,capabilities>>.
   For more information, see the sections on <<feature_variants.adoc#feature_variants,modeling feature variants and optional dependencies>>.
   
   == Module
   
   A piece of software that evolves over time e.g. link:https://github.com/google/guava[Google Guava].
   Every module has a name. Each release of a module is optimally represented by a <<#sub:terminology_module_version,module version>>.
   For convenient consumption, modules can be hosted in a <<#sub:terminology_repository,repository>>.
   
   == Module metadata
   
   Releases of a <<#sub:terminology_module,module>> provide metadata.
   Metadata is the data that describes the module in more detail e.g. information about the location of artifacts or required <<#sub:terminology_transitive_dependency,transitive dependencies>>.
   Gradle offers its own metadata format called link:https://github.com/gradle/gradle/blob/master/platforms/documentation/docs/src/docs/design/gradle-module-metadata-latest-specification.md[Gradle Module Metadata] (`.module` file) but also supports Maven (`.pom`) and Ivy (`ivy.xml`) metadata.
   See the section on <<publishing_gradle_module_metadata.adoc#sec:understanding-gradle-module-md,understanding Gradle Module Metadata>> for more information on the supported metadata formats.
   
   == Component metadata rule
   
   A component metadata rule is a rule that modifies a component's metadata after it was fetched from a repository, e.g. to add missing information or to correct wrong information.
   In contrast to <<#sub:terminology_resolution_rule,resolution rules>>, component metadata rules are applied *before* resolution starts.
   Component metadata rules are defined as part of the build logic and can be shared through plugins.
   For more information, see the section on <<component_metadata_rules.adoc#sec:component_metadata_rules,fixing metadata with component metadata rules>>.
   
   == Module version
   
   A module version represents a distinct set of changes of a released <<#sub:terminology_module,module>>.
   For example `18.0` represents the version of the module with the coordinates `com.google:guava:18.0`.
   In practice there's no limitation to the scheme of the module version.
   Timestamps, numbers, special suffixes like `-GA` are all allowed identifiers.
   The most widely-used versioning strategy is link:https://semver.org/[semantic versioning].
   
   == Platform
   
   A platform is a set of modules aimed to be used together. There are different categories of platforms, corresponding to different use cases:
   
   - module set: often a set of modules published together as a whole. Using one module of the set often means we want to use the same version for all modules of the set. For example, if using `groovy` 1.2, also use `groovy-json` 1.2.
   - runtime environment: a set of libraries known to work well together. e.g., the Spring Platform, recommending versions for both Spring and components that work well with Spring.
   - deployment environment: Java runtime, application server, ...
   
   In addition Gradle defines <<dependency_version_alignment.adoc#sec:virtual_platform,virtual platforms>>.
   
   NOTE: Maven's BOM (bill-of-material) is a popular kind of platform that <<platforms.adoc#sub:bom_import, Gradle supports>>.
   
   == Publication
   
   A description of the files and metadata that should be published to a repository as a single entity for use by consumers.
   
   A publication has a name and consists of one or more artifacts plus information about those artifacts (the <<#sub:terminology_module_metadata,metadata>>).
   
   == Repository
   
   A repository hosts a set of <<#sub:terminology_module,modules>>, each of which may provide one or many releases (components) indicated by a <<#sub:terminology_module_version,module version>>.
   The repository can be based on a binary repository product (e.g. Artifactory or Nexus) or a directory structure in the filesystem.
   For more information, see <<declaring_repositories.adoc#declaring-repositories,Declaring Repositories>>.
   
   == Resolution rule
   
   A resolution rule influences the behavior of how a <<#sub:terminology_dependency,dependency>> is resolved directly.
   Resolution rules are defined as part of the build logic.
   For more information, see the section on <<resolution_rules.adoc#resolution_rules,customizing resolution of a dependency directly>>.
   
   == Transitive dependency
   
   A variant of a <<#sub:terminology_component,component>> can have dependencies on other modules to work properly, so-called transitive dependencies.
   Releases of a module hosted on a <<#sub:terminology_repository,repository>> can provide <<#sub:terminology_module_metadata,metadata>> to declare those transitive dependencies.
   By default, Gradle resolves transitive dependencies automatically.
   The version selection for transitive dependencies can be influenced by declaring <<dependency_constraints.adoc#dependency-constraints,dependency constraints>>.
   
   == Variant (of a component)
   
   Each <<#sub:terminology_component,component>> consists of one or more variants.
   A variant consists of a set of artifacts and defines a set of dependencies.
   It is identified by a set of <<sub:terminology_attribute,attributes>> and <<sub:terminology_capability,capabilities>>.
   
   Gradle's dependency resolution is variant-aware and selects one or more variants of each component after a component (i.e. one version of a module) has been selected.
   It may also fail if the variant selection result is ambiguous, meaning that Gradle does not have enough information to select one of multiple mutual exclusive variants.
   In that case, more information can be provided through <<#sub:terminology_attribute,variant attributes>>.
   Examples of variants each Java components typically offers are _api_ and _runtime_ variants.
   Others examples are JDK8 and JDK11 variants.
   For more information, see the section on <<variant_model.adoc#understanding-variant-selection,variant selection>>.
   
   == Variant Attribute
   
   Attributes are used to identify and select <<#sub:terminology_variant,variants>>.
   A variant has one or more attributes defined, for example `org.gradle.usage=java-api`, `org.gradle.jvm.version=11`.
   When dependencies are resolved, a set of attributes are requested and Gradle finds the best fitting variant(s) for each component in the dependency graph.
   Compatibility and disambiguation rules can be implemented for an attribute to express compatibility between values (e.g. Java 8 is compatible with Java 11, but Java 11 should be preferred if the requested version is 11 or higher).
   Such rules are typically provided by plugins.
   For more information, see the sections on <<variant_model.adoc#understanding-variant-selection,variant selection>> and <<variant_attributes.adoc#variant_attributes,declaring attributes>>.

/Section: 游릭 The Basics
=========================


/docs/userguide/dep-man/01-core-dependency-management/core_dependency_management.adoc
=====================================================================================

.. code-block::

   = Dependency Management
   
   Software projects rarely work in isolation.
   Projects often rely on reusable functionality from libraries.
   Some projects organize unrelated functionality into separate parts of a modular system.
   
   Dependency management is an automated technique for declaring, resolving, and using functionality required by a project.
   
   TIP: For an overview of dependency management terms, see <<dependency_management_terminology.adoc#dependency_management_terminology,Dependency Management Terminology>>.
   
   == Dependency Management in Gradle
   
   .Dependencies management at a glance
   image::dependency-management-resolution.png[]
   
   Gradle has built-in support for dependency management.
   
   Let's explore the main concepts with the help of a theoretical but common project:
   
   * This project builds Java source code.
   * Some Java source files import classes from the link:https://github.com/google/guava[Google Guava] library.
   * This project uses link:http://junit.org/junit5/[JUnit] for testing.
   
   The Gradle build file might look as follows:
   
   .Gradle build file with dependencies
   ====
   include::sample[dir="snippets/dependencyManagement/introductionCoreDependencies/kotlin",files="build.gradle.kts"]
   include::sample[dir="snippets/dependencyManagement/introductionCoreDependencies/groovy",files="build.gradle"]
   ====
   
   <1> *Here we define repositories for the project.*
   
   <2> *Here we declare remote and local repositories for dependency locations.*
   +
   You can <<declaring_repositories.adoc#declaring-repositories,declare _repositories_>> to tell Gradle where to fetch local or remote _dependencies_. +
   In this example, Gradle fetches _dependencies_ from the link:https://repo1.maven.org/maven2/[Maven Central] and link:https://maven.google.com/[Google] _repositories_. +
   During a build, Gradle locates and downloads the dependencies, a process called <<dependency_resolution.adoc#sec:how-gradle-downloads-deps,_dependency resolution_>>.
   Gradle then <<dependency_resolution.adoc#sec:dependency_cache,stores resolved dependencies in a local cache>> called the _dependency cache_.
   Subsequent builds use this cache to avoid unnecessary network calls and speed up the build process.
   
   <3> *Here we define dependencies used by the project.*
   
   <4> *Here we declare the specific dependency name and version within a scope.*
   +
   You can add code to your Java project from an external library such as `com.google.common.base` (a Guava package) which becomes a _dependency_. +
   In this example, the theoretical project uses Guava version 32.1.2-jre and JUnit 4.13.2 as _dependencies_. +
   A build engineer can <<declaring_dependencies.adoc#declaring-dependencies,declare dependencies>> for different scopes. For example, you can declare dependencies that are only used at compile time.
   Gradle calls the <<declaring_dependencies.adoc#sec:what-are-dependency-configurations,scope of a dependency>> a _configuration_.
   
   Repositories offer dependencies in multiple formats.
   For information about the formats supported by Gradle, see <<declaring_dependencies.adoc#sec:dependency-types,dependency types>>.
   
   Metadata describes dependencies.
   Some examples of metadata include:
   
   * coordinates for finding the dependency in a repository
   * information about the project that created the dependency
   * the authors of the dependency
   * other dependencies required for a dependency to work properly, known as _transitive dependencies_
   
   You can <<dependency_constraints.adoc#dependency-constraints,customize Gradle's handling of transitive dependencies>> based on the requirements of a project.
   
   Projects with hundreds of declared dependencies can be difficult to debug.
   Gradle provides tools to visualize and analyze a project's dependency graph (i.e. dependency tree).
   You can use a link:https://scans.gradle.com/get-started[Build Scan(TM)] or <<viewing_debugging_dependencies.adoc#sec:debugging-build-scans,built-in tasks>>.
   
   .Build scan dependencies report
   image::gradle-core-test-build-scan-dependencies.png[]

/docs/userguide/dep-man/01-core-dependency-management/declaring_repositories.adoc
=================================================================================

.. code-block::

   = Declaring repositories
   
   Gradle can resolve dependencies from one or many repositories based on Maven, Ivy or flat directory formats.
   Check out the <<#sec:repository-types,full reference on all types of repositories>> for more information.
   
   == Declaring a publicly-available repository
   
   Organizations building software may want to leverage public binary repositories to download and consume open source dependencies.
   Popular public repositories include <<#sub:maven_central,Maven Central>> and the <<#sub:maven_google,Google Android>> repository.
   Gradle provides built-in shorthand notations for these widely-used repositories.
   
   .Declaring a repository with the help of shorthand notations
   image::dependency-management-shortcut-repositories.png[]
   
   Under the covers Gradle resolves dependencies from the respective URL of the public repository defined by the shorthand notation.
   All shorthand notations are available via the link:{groovyDslPath}#[RepositoryHandler] API.
   Alternatively, you can <<#sec:declaring_custom_repository,spell out the URL of the repository>> for more fine-grained control.
   
   === Maven Central repository
   
   Maven Central is a popular repository hosting open source libraries for consumption by Java projects.
   
   To declare the link:https://repo.maven.apache.org/maven2/[Maven Central repository] for your build add this to your script:
   
   .Adding central Maven repository
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=maven-central]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=maven-central]"]
   ====
   
   === Google Maven repository
   
   The Google repository hosts Android-specific artifacts including the Android SDK. For usage examples, see the link:https://developer.android.com/studio/build/dependencies.html#google-maven[relevant Android documentation].
   
   To declare the link:https://maven.google.com/[Google Maven repository] add this to your build script:
   
   .Adding Google Maven repository
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=maven-google]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=maven-google]"]
   ====
   
   == Declaring a custom repository by URL
   
   Most enterprise projects set up a binary repository available only within an intranet.
   In-house repositories enable teams to publish internal binaries, setup user management and security measure and ensure uptime and availability.
   Specifying a custom URL is also helpful if you want to declare a less popular, but publicly-available repository.
   
   Repositories with custom URLs can be specified as Maven or Ivy repositories by calling the corresponding methods available on the link:{groovyDslPath}#[RepositoryHandler] API.
   Gradle supports other protocols than `http` or `https` as part of the custom URL e.g. `file`, `sftp` or `s3`.
   For a full coverage see the <<#sec:repository-types,section on supported repository types>>.
   
   You can also <<#sub:defining_custom_pattern_layout_for_an_ivy_repository,define your own repository layout>> by using `ivy { }` repositories as they are very flexible in terms of how modules are organised in a repository.
   
   == Declaring multiple repositories
   
   You can define more than one repository for resolving dependencies.
   Declaring multiple repositories is helpful if some dependencies are only available in one repository but not the other.
   You can mix any type of repository described in the <<#sec:repository-types,reference section>>.
   
   This example demonstrates how to declare various named and custom URL repositories for a project:
   
   .Declaring multiple repositories
   ====
   include::sample[dir="snippets/dependencyManagement/declaringRepositories-multipleRepositories/kotlin",files="build.gradle.kts[tags=multiple-repositories]"]
   include::sample[dir="snippets/dependencyManagement/declaringRepositories-multipleRepositories/groovy",files="build.gradle[tags=multiple-repositories]"]
   ====
   
   [NOTE]
   ====
   The order of declaration determines how Gradle will check for dependencies at runtime.
   If Gradle finds a module descriptor in a particular repository, it will attempt to download all of the artifacts for that module from _the same repository_.
   You can learn more about the inner workings of <<dependency_resolution.adoc#sec:how-gradle-downloads-deps, dependency downloads>>.
   ====
   
   === Strict limitation to declared repositories
   
   Maven POM metadata can reference additional repositories.
   These will be _ignored_ by Gradle, which will only use the repositories declared in the build itself.
   
   NOTE: This is a reproducibility safe-guard but also a security protection.
   Without it, an updated version of a dependency could pull artifacts from anywhere into your build.
   
   == Supported repository types
   
   Gradle supports a wide range of sources for dependencies, both in terms of format and in terms of connectivity.
   You may resolve dependencies from:
   
   * Different formats
   ** a <<#sec:maven_repo,Maven compatible>> artifact repository (e.g: Maven Central)
   ** an <<#sec:ivy_repositories,Ivy compatible>> artifact repository (including custom layouts)
   ** <<#sub:flat_dir_resolver,local (flat) directories>>
   * with different connectivity
   ** <<#sec:authentication_schemes, authenticated repositories>>
   ** a wide variety of <<#sec:supported_transport_protocols,remote protocols>> such as HTTPS, SFTP, AWS S3 and Google Cloud Storage
   
   === Flat directory repository
   
   Some projects might prefer to store dependencies on a shared drive or as part of the project source code instead of a binary repository product. If you want to use a (flat) filesystem directory as a repository, simply type:
   
   .Flat repository resolver
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=flat-dir-multi]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=flat-dir-multi]"]
   ====
   
   This adds repositories which look into one or more directories for finding dependencies.
   
   This type of repository does not support any meta-data formats like Ivy XML or Maven POM files.
   Instead, Gradle will dynamically generate a module descriptor (without any dependency information) based on the presence of artifacts.
   
   [NOTE]
   ====
   As Gradle prefers to use modules whose descriptor has been created from real meta-data rather than being generated, flat directory repositories cannot be used to override artifacts with real meta-data from other repositories declared in the build.
   
   For example, if Gradle finds only `jmxri-1.2.1.jar` in a flat directory repository, but `jmxri-1.2.1.pom` in another repository that supports meta-data, it will use the second repository to provide the module.
   
   For the use case of overriding remote artifacts with local ones consider using an Ivy or Maven repository instead whose URL points to a local directory.
   ====
   
   If you only work with flat directory repositories you don't need to set all attributes of a dependency.
   
   === Local repositories
   
   The following sections describe repositories format, Maven or Ivy.
   These can be declared as local repositories, using a local filesystem path to access them.
   
   The difference with the flat directory repository is that they do respect a format and contain metadata.
   
   When such a repository is configured, Gradle totally bypasses its <<dependency_resolution.adoc#sec:dependency_cache,dependency cache>> for it as there can be no guarantee that content may not change between executions.
   Because of that limitation, they can have a performance impact.
   
   They also make build reproducibility much harder to achieve and their use should be limited to tinkering or prototyping.
   
   == Maven repositories
   
   Many organizations host dependencies in an in-house Maven repository only accessible within the company's network.
   Gradle can declare Maven repositories by URL.
   
   For adding a custom Maven repository you can do:
   
   .Adding custom Maven repository
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=maven-like-repo]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=maven-like-repo]"]
   ====
   
   === Setting up composite Maven repositories
   
   Sometimes a repository will have the POMs published to one location, and the JARs and other artifacts published at another location.
   To define such a repository, you can do:
   
   .Adding additional Maven repositories for JAR files
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=maven-like-repo-with-jar-repo]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=maven-like-repo-with-jar-repo]"]
   ====
   
   Gradle will look at the base `url` location for the POM and the JAR.
   If the JAR can't be found there, the extra `artifactUrls` are used to look for JARs.
   
   === Accessing authenticated Maven repositories
   
   You can specify credentials for Maven repositories secured by different type of authentication.
   
   See <<#sec:supported_transport_protocols>> for authentication options.
   
   === Local Maven repository
   
   Gradle can consume dependencies available in the link:https://maven.apache.org/guides/introduction/introduction-to-repositories.html[local Maven repository].
   Declaring this repository is beneficial for teams that publish to the local Maven repository with one project and consume the artifacts by Gradle in another project.
   
   NOTE: Gradle stores resolved dependencies in <<dependency_resolution.adoc#sec:dependency_cache,its own cache>>.
   A build does not need to declare the local Maven repository even if you resolve dependencies from a Maven-based, remote repository.
   
   WARNING: Before adding Maven local as a repository, you should <<#sec:case-for-maven-local, make sure this is really required>>.
   
   To declare the local Maven cache as a repository add this to your build script:
   
   .Adding the local Maven cache as a repository
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=maven-local]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=maven-local]"]
   ====
   
   Gradle uses the same logic as Maven to identify the location of your local Maven cache.
   If a local repository location is defined in a `settings.xml`, this location will be used.
   The `settings.xml` in `<home directory of the current user>/.m2` takes precedence over the `settings.xml` in `__M2_HOME__/conf`.
   If no `settings.xml` is available, Gradle uses the default location `<home directory of the current user>/.m2/repository`.
   
   == The case for mavenLocal()
   
   As a general advice, you should avoid adding `mavenLocal()` as a repository.
   There are different issues with using `mavenLocal()` that you should be aware of:
   
   * Maven uses it as a cache, not a repository, meaning it can contain partial modules.
   ** For example, if Maven never downloaded the source or javadoc files for a given module, Gradle will not find them either since it <<dependency_resolution.adoc#sec:how-gradle-downloads-deps,searches for files in a single repository>> once a module has been found.
   * As a <<sub:local-repos,local repository>>, Gradle does not trust its content, because:
   ** Origin of artifacts cannot be tracked, which is a correctness and security problem
   ** Artifacts can be easily overwritten, which is a security, correctness and reproducibility problem
   * To mitigate the fact that metadata and/or artifacts can be changed, Gradle does not perform <<dependency_resolution.adoc#sec:dependency_cache,any caching>> for <<sub:local-repos,local repositories>>
   ** As a consequence, your builds are slower
   ** Given that order of repositories is important, adding `mavenLocal()` _first_ means that all your builds are going to be slower
   
   There are a few cases where you might have to use `mavenLocal()`:
   
   * For interoperability with Maven
   ** For example, project A is built with Maven, project B is built with Gradle, and you need to share the artifacts during development
   ** It is _always_ preferable to use an internal full featured repository instead
   ** In case this is not possible, you should limit this to _local builds only_
   * For interoperability with Gradle itself
   ** In a multi-repository world, you want to check that changes to project A work with project B
   ** It is preferable to use <<composite_builds.adoc#composite_builds, composite builds>> for this use case
   ** If for some reason neither composite builds nor full featured repository are possible, then `mavenLocal()` is a last resort option
   
   After all these warnings, if you end up using `mavenLocal()`, consider combining it with <<#sec:repository-content-filtering,a repository filter>>.
   This will make sure it only provides what is expected and nothing else.
   
   == Ivy repositories
   
   Organizations might decide to host dependencies in an in-house Ivy repository. Gradle can declare Ivy repositories by URL.
   
   === Defining an Ivy repository with a standard layout
   
   To declare an Ivy repository using the standard layout no additional customization is needed. You just declare the URL.
   
   .Ivy repository
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=ivy-repo]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=ivy-repo]"]
   ====
   
   === Defining a named layout for an Ivy repository
   
   You can specify that your repository conforms to the Ivy or Maven default layout by using a named layout.
   
   .Ivy repository with named layout
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=ivy-repo-with-maven-layout]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=ivy-repo-with-maven-layout]"]
   ====
   
   Valid named layout values are `'gradle'` (the default), `'maven'` and `'ivy'`. See link:{groovyDslPath}#[IvyArtifactRepository.layout(java.lang.String)] in the API documentation for details of these named layouts.
   
   === Defining custom pattern layout for an Ivy repository
   
   To define an Ivy repository with a non-standard layout, you can define a _pattern_ layout for the repository:
   
   .Ivy repository with pattern layout
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=ivy-repo-with-pattern-layout]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=ivy-repo-with-pattern-layout]"]
   ====
   
   To define an Ivy repository which fetches Ivy files and artifacts from different locations, you can define separate patterns to use to locate the Ivy files and artifacts:
   
   Each `artifact` or `ivy` specified for a repository adds an _additional_ pattern to use. The patterns are used in the order that they are defined.
   
   .Ivy repository with multiple custom patterns
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=ivy-repo-with-custom-pattern]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=ivy-repo-with-custom-pattern]"]
   ====
   
   Optionally, a repository with pattern layout can have its `'organisation'` part laid out in Maven style, with forward slashes replacing dots as separators. For example, the organisation `my.company` would then be represented as `my/company`.
   
   .Ivy repository with Maven compatible layout
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=ivy-repo-with-m2compatible-layout]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=ivy-repo-with-m2compatible-layout]"]
   ====
   
   === Accessing authenticated Ivy repositories
   
   You can specify credentials for Ivy repositories secured by basic authentication.
   
   .Ivy repository with authentication
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=authenticated-ivy-repo]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=authenticated-ivy-repo]"]
   ====
   
   See <<#sec:supported_transport_protocols>> for authentication options.
   
   == Repository content filtering
   
   Gradle exposes an API to declare what a repository may or may not contain.
   There are different use cases for it:
   
   - performance, when you know a dependency will never be found in a specific repository
   - security, by avoiding leaking what dependencies are used in a private project
   - reliability, when some repositories contain corrupted metadata or artifacts
   
   It's even more important when considering that the declared order of repositories matter.
   
   === Declaring a repository filter
   
   .Declaring repository contents
   ====
   include::sample[dir="snippets//dependencyManagement/declaringRepositories-filtering/kotlin",files="build.gradle.kts[tags=repository-filter]"]
   include::sample[dir="snippets/dependencyManagement/declaringRepositories-filtering/groovy",files="build.gradle[tags=repository-filter]"]
   ====
   
   By default, repositories include everything and exclude nothing:
   
   * If you declare an include, then it excludes everything _but_ what is included.
   * If you declare an exclude, then it includes everything _but_ what is excluded.
   * If you declare both includes and excludes, then it includes only what is explicitly included and not excluded.
   
   It is possible to filter either by explicit _group_, _module_ or _version_, either strictly or using regular expressions.
   When using a strict version, it is possible to use a version range, using <<single_versions.adoc#single-version-declarations,the format supported>> by Gradle.
   In addition, there are filtering options by resolution context: configuration name or even configuration attributes.
   See link:{javadocPath}#[RepositoryContentDescriptor] for details.
   
   === Declaring content exclusively found in one repository
   
   Filters declared using the <<#sec:declaring-repository-filter,repository-level content filter>> are not exclusive.
   This means that declaring that a repository _includes_ an artifact doesn't mean that the other repositories can't have it either: you must declare what every repository contains in extension.
   
   Alternatively, Gradle provides an API which lets you declare that a repository _exclusively includes_ an artifact.
   If you do so:
   
   - an artifact declared in a repository _can't_ be found in any other
   - exclusive repository content must be declared in extension (just like for <<#sec:declaring-repository-filter, repository-level content>>)
   
   .Declaring exclusive repository contents
   ====
   include::sample[dir="snippets/dependencyManagement/declaringRepositories-filtering/kotlin",files="build.gradle.kts[tags=exclusive-repository-filter]"]
   include::sample[dir="snippets/dependencyManagement/declaringRepositories-filtering/groovy",files="build.gradle[tags=exclusive-repository-filter]"]
   ====
   
   It is possible to filter either by explicit _group_, _module_ or _version_, either strictly or using regular expressions.
   See link:{javadocPath}#[InclusiveRepositoryContentDescriptor] for details.
   
   [NOTE]
   ====
   If you leverage exclusive content filtering in the <<plugins.adoc#sec:custom_plugin_repositories,`pluginManagement` section of the `settings.gradle(.kts)`>>, it becomes illegal to add more repositories through the project `buildscript.repositories`.
   In that case, the build configuration will fail.
   
   Your options are either to declare all repositories in settings or to use non-exclusive content filtering.
   ====
   
   === Maven repository filtering
   
   For <<sec:maven_repo,Maven repositories>>, it's often the case that a repository would either contain releases or snapshots.
   Gradle lets you declare what kind of artifacts are found in a repository using this DSL:
   
   .Splitting snapshots and releases
   ====
   include::sample[dir="snippets/dependencyManagement/declaringRepositories-filtering/kotlin",files="build.gradle.kts[tags=repository-snapshots]"]
   include::sample[dir="snippets/dependencyManagement/declaringRepositories-filtering/groovy",files="build.gradle[tags=repository-snapshots]"]
   ====
   
   == Supported metadata sources
   
   When searching for a module in a repository, Gradle, by default, checks for <<declaring_dependencies.adoc#sec:supported-metadata-formats,supported metadata file formats>> in that repository.
   In a Maven repository, Gradle looks for a `.pom` file, in an ivy repository it looks for an `ivy.xml` file and in a flat directory repository it looks directly for `.jar` files as it does not expect any metadata.
   Starting with 5.0, Gradle also looks for `.module` (Gradle module metadata) files.
   
   However, if you define a customized repository you might want to configure this behavior.
   For example, you can define a Maven repository without `.pom` files but only jars.
   To do so, you can configure _metadata sources_ for any repository.
   
   .Maven repository that supports artifacts without metadata
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=maven-repo-with-metadata-sources]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=maven-repo-with-metadata-sources]"]
   ====
   
   You can specify multiple sources to tell Gradle to keep looking if a file was not found.
   In that case, the order of checking for sources is predefined.
   
   The following metadata sources are supported:
   
   .Supported metadata sources
   [%header%autowidth,compact]
   |===
   | Metadata source | Description | Order | Maven | Ivy / flat dir
   
   | `gradleMetadata()`
   | Look for Gradle `.module` files
   | 1st
   | yes
   | yes
   
   | `mavenPom()`
   | Look for Maven `.pom` files
   | 2nd
   | yes
   | yes
   
   | `ivyDescriptor()`
   | Look for `ivy.xml` files
   | 2nd
   | no
   | yes
   
   | `artifact()`
   | Look directly for artifact
   | 3rd
   | yes
   | yes
   |===
   
   --
   The defaults for Ivy and Maven repositories change with Gradle 6.0.
   Before 6.0, `artifact()` was included in the defaults.
   Leading to some inefficiency when modules are missing completely.
   
   To restore this behavior, for example, for Maven central you can use:
   ```
   mavenCentral { metadataSources { mavenPom(); artifact() } }
   ```
   
   In a similar way, you can opt into the new behavior in older Gradle versions using:
   ```
   mavenCentral { metadataSources { mavenPom() } }
   ```
   --
   
   Since Gradle 5.3, when parsing a metadata file, be it Ivy or Maven, Gradle will look for a marker indicating that a matching Gradle Module Metadata files exists.
   If it is found, it will be used instead of the Ivy or Maven file.
   
   Starting with Gradle 5.6, you can disable this behavior by adding `ignoreGradleMetadataRedirection()` to the metadataSources declaration.
   
   .Maven repository that does not use gradle metadata redirection
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=maven-repo-with-ignore-gradle-metadata-redirection]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=maven-repo-with-ignore-gradle-metadata-redirection]"]
   ====
   
   == Plugin repositories vs. build repositories
   
   Gradle will use repositories at two different phases during your build.
   
   The first phase is when <<build_lifecycle.adoc#sec:build_phases,configuring your build>> and loading the plugins it applied.
   To do that Gradle will use a special set of repositories.
   
   The second phase is during dependency resolution.
   At this point Gradle will use the repositories declared in your project, as shown in the previous sections.
   
   === Plugin repositories
   
   By default Gradle will use the http://plugins.gradle.org[Gradle plugin portal] to look for plugins.
   
   However, for different reasons, there are plugins available in other, public or not, repositories.
   When a build requires one of these plugins, additional repositories need to be specified so that Gradle knows where to search.
   
   As the way to declare the repositories and what they are expected to contain depends on the way the plugin is applied, it is best to refer to <<plugins.adoc#sec:custom_plugin_repositories, Custom Plugin Repositories>>.
   
   == Centralizing repositories declaration
   
   Instead of declaring repositories in every subproject of your build or via an `allprojects` block, Gradle offers a way to declare them in a central place for all projects.
   
   NOTE: Central declaration of repositories is an incubating feature.
   
   Repositories used by convention in every subproject can be declared in the `settings.gradle(.kts)` file:
   
   .Declaring a Maven repository in settings
   ====
   include::sample[dir="snippets/artifacts/defineRepositoryInSettings/kotlin",files="settings.gradle.kts[tags=declare_repositories_settings]"]
   include::sample[dir="snippets/artifacts/defineRepositoryInSettings/groovy",files="settings.gradle[tags=declare_repositories_settings]"]
   ====
   
   The `dependencyResolutionManagement` repositories block accepts the same notations as in a project. This includes Maven or Ivy repositories, with or without credentials, etc.
   
   By default, repositories declared by a project in `build.gradle(.kts)` will *override* whatever is declared in `settings.gradle(.kts)`:
   
   .Preferring project repositories
   ====
   include::sample[dir="snippets/artifacts/defineRepositoryInSettings/kotlin",files="settings.gradle.kts[tags=prefer_projects]"]
   include::sample[dir="snippets/artifacts/defineRepositoryInSettings/groovy",files="settings.gradle[tags=prefer_projects]"]
   ====
   
   There are three modes for dependency resolution management:
   
   [cols="1,1,1,1"]
   |===
   |Mode |Description |Default? |Use-Case
   
   |`PREFER_PROJECT`
   |Any repository declared on a project will cause the project to use the repositories declared by the project, ignoring those declared in settings.
   |Yes
   |Useful when teams need to use different repositories not common among subprojects.
   
   |`PREFER_SETTINGS`
   |Any repository declared directly in a project, either directly or via a plugin, will be ignored.
   |No
   |Useful for enforcing large teams to use approved repositories only, but will not fail the build when a project or plugin declares a repository.
   
   |`FAIL_ON_PROJECT_REPOS`
   |Any repository declared directly in a project, either directly or via a plugin, will trigger a build error.
   |No
   |Useful for enforcing large teams to use approved repositories only.
   |===
   
   You can change the behavior to prefer the repositories in the `settings.gradle(.kts)` file by using `repositoriesMode`:
   
   .Preferring settings repositories
   ====
   include::sample[dir="snippets/artifacts/defineRepositoryInSettings/kotlin",files="settings.gradle.kts[tags=prefer_settings]"]
   include::sample[dir="snippets/artifacts/defineRepositoryInSettings/groovy",files="settings.gradle[tags=prefer_settings]"]
   ====
   
   
   Gradle will warn you if a project or a plugin declares a repository in a project.
   
   You can force Gradle to _fail the build_ if you want to enforce that *only* settings repositories are used:
   
   .Enforcing settings repositories
   ====
   include::sample[dir="snippets/artifacts/defineRepositoryInSettings/kotlin",files="settings.gradle.kts[tags=enforce_settings]"]
   include::sample[dir="snippets/artifacts/defineRepositoryInSettings/groovy",files="settings.gradle[tags=enforce_settings]"]
   ====
   
   == Supported repository transport protocols
   
   Maven and Ivy repositories support the use of various transport protocols. At the moment the following protocols are supported:
   
   .Repository transport protocols
   [%header%autowidth,compact]
   |===
   | Type | Credential types | Link
   
   | `file`
   | none
   |
   
   | `http`
   | username/password
   | <<#sec:authentication_schemes, Documentation>>
   
   | `https`
   | username/password
   | <<#sec:authentication_schemes, Documentation>>
   
   | `sftp`
   | username/password
   | <<#sec:authentication_schemes, Documentation>>
   
   | `s3`
   | access key/secret key/session token or Environment variables
   | <<#sec:s3-repositories,Documentation>>
   
   | `gcs`
   | https://developers.google.com/identity/protocols/application-default-credentials[default application credentials] sourced from well known files, Environment variables etc.
   | <<#sec:gcs-repositories,Documentation>>
   |===
   
   NOTE: Username and password should never be checked in plain text into version control as part of your build file.
   You can store the credentials in a local `gradle.properties` file and use one of the open source Gradle plugins for encrypting and consuming credentials e.g. the link:https://plugins.gradle.org/plugin/nu.studer.credentials[credentials plugin].
   
   The transport protocol is part of the URL definition for a repository.
   The following build script demonstrates how to create HTTP-based Maven and Ivy repositories:
   
   .Declaring a Maven and Ivy repository
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=maven-ivy-repository-no-auth]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=maven-ivy-repository-no-auth]"]
   ====
   
   The following example shows how to declare SFTP repositories:
   
   .Using the SFTP protocol for a repository
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=maven-ivy-repository-auth]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=maven-ivy-repository-auth]"]
   ====
   
   For details on HTTP related authentication, see the section <<#sec:authentication_schemes>>.
   
   When using an AWS S3 backed repository you need to authenticate using link:{groovyDslPath}#[AwsCredentials], providing access-key and a private-key. The following example shows how to declare a S3 backed repository and providing AWS credentials:
   
   .Declaring an S3 backed Maven and Ivy repository
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=maven-ivy-s3-repository]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=maven-ivy-s3-repository]"]
   ====
   
   You can also delegate all credentials to the AWS sdk by using the AwsImAuthentication. The following example shows how:
   
   .Declaring an S3 backed Maven and Ivy repository using IAM
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=maven-ivy-s3-repository-with-iam]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=maven-ivy-s3-repository-with-iam]"]
   ====
   
   For details on AWS S3 related authentication, see the section <<#sec:s3-repositories>>.
   
   When using a Google Cloud Storage backed repository default application credentials will be used with no further configuration required:
   
   .Declaring a Google Cloud Storage backed Maven and Ivy repository using default application credentials
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=maven-ivy-gcs-repository]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=maven-ivy-gcs-repository]"]
   ====
   
   For details on Google GCS related authentication, see the section <<#sec:gcs-repositories>>.
   
   == HTTP(S) authentication schemes configuration
   
   When configuring a repository using HTTP or HTTPS transport protocols, multiple authentication schemes are available. By default, Gradle will attempt to use all schemes that are supported by the Apache HttpClient library, http://hc.apache.org/httpcomponents-client-ga/[documented here]. In some cases, it may be preferable to explicitly specify which authentication schemes should be used when exchanging credentials with a remote server. When explicitly declared, only those schemes are used when authenticating to a remote repository.
   
   You can specify credentials for Maven repositories secured by basic authentication using link:{javadocPath}#[PasswordCredentials].
   
   .Accessing password-protected Maven repository
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=authenticated-maven-repo]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=authenticated-maven-repo]"]
   ====
   
   
   The following example show how to configure a repository to use only link:{javadocPath}#[DigestAuthentication]:
   
   .Configure repository to use only digest authentication
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=digest-authentication]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=digest-authentication]"]
   ====
   
   Currently supported authentication schemes are:
   
   link:{javadocPath}#[BasicAuthentication]::
   Basic access authentication over HTTP. When using this scheme, credentials are sent preemptively.
   
   link:{javadocPath}#[DigestAuthentication]::
   Digest access authentication over HTTP.
   
   link:{javadocPath}#[HttpHeaderAuthentication]::
   Authentication based on any custom HTTP header, e.g. private tokens, OAuth tokens, etc.
   
   === Using preemptive authentication
   
   Gradle's default behavior is to only submit credentials when a server responds with an authentication challenge in the form of an HTTP 401 response.
   In some cases, the server will respond with a different code (ex. for repositories hosted on GitHub a 404 is returned) causing dependency resolution to fail.
   To get around this behavior, credentials may be sent to the server preemptively.
   To enable preemptive authentication simply configure your repository to explicitly use the link:{javadocPath}#[BasicAuthentication] scheme:
   
   .Configure repository to use preemptive authentication
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=preemptive-authentication]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=preemptive-authentication]"]
   ====
   
   === Using HTTP header authentication
   
   You can specify any HTTP header for secured Maven repositories requiring token, OAuth2 or other HTTP header based authentication using link:{javadocPath}#[HttpHeaderCredentials] with link:{javadocPath}#[HttpHeaderAuthentication].
   
   .Accessing header-protected Maven repository
   ====
   include::sample[dir="snippets/artifacts/defineRepository/kotlin",files="build.gradle.kts[tags=header-authenticated-maven-repo]"]
   include::sample[dir="snippets/artifacts/defineRepository/groovy",files="build.gradle[tags=header-authenticated-maven-repo]"]
   ====
   
   
   == AWS S3 repositories configuration
   
   === S3 configuration properties
   
   The following system properties can be used to configure the interactions with s3 repositories:
   
   `org.gradle.s3.endpoint`::
   Used to override the AWS S3 endpoint when using a non AWS, S3 API compatible, storage service.
   
   `org.gradle.s3.maxErrorRetry`::
   Specifies the maximum number of times to retry a request in the event that the S3 server responds with a HTTP 5xx status code. When not specified a default value of 3 is used.
   
   === S3 URL formats
   
   S3 URL's are 'virtual-hosted-style' and must be in the following format
   
   ----
   s3://<bucketName>[.<regionSpecificEndpoint>]/<s3Key>
   ----
   
   e.g. `s3://myBucket.s3.eu-central-1.amazonaws.com/maven/release`
   
   * `myBucket` is the AWS S3 bucket name.
   * `s3.eu-central-1.amazonaws.com` is the _optional_ http://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region[region specific endpoint].
   * `/maven/release` is the AWS S3 key (unique identifier for an object within a bucket)
   
   
   === S3 proxy settings
   
   A proxy for S3 can be configured using the following system properties:
   
   * `https.proxyHost`
   * `https.proxyPort`
   * `https.proxyUser`
   * `https.proxyPassword`
   * `http.nonProxyHosts` (NOTE: this is not a typo.)
   
   If the `org.gradle.s3.endpoint` property has been specified with a HTTP (not HTTPS) URI the following system proxy settings can be used:
   
   * `http.proxyHost`
   * `http.proxyPort`
   * `http.proxyUser`
   * `http.proxyPassword`
   * `http.nonProxyHosts`
   
   === AWS S3 V4 Signatures (AWS4-HMAC-SHA256)
   
   Some of the AWS S3 regions (eu-central-1 - Frankfurt) require that all HTTP requests are signed in accordance with AWS's http://docs.aws.amazon.com/general/latest/gr/signature-version-4.html[signature version 4]. It is recommended to specify S3 URL's containing the region specific endpoint when using buckets that require V4 signatures. e.g.
   
   ----
   s3://somebucket.s3.eu-central-1.amazonaws.com/maven/release
   ----
   
   --
   When a region-specific endpoint is not specified for buckets requiring V4 Signatures, Gradle will use the default AWS region (us-east-1) and the
   following warning will appear on the console:
   
   ```
   Attempting to re-send the request to .... with AWS V4 authentication. To avoid this warning in the future, use region-specific endpoint to access buckets located in regions that require V4 signing.
   ```
   
   Failing to specify the region-specific endpoint for buckets requiring V4 signatures means:
   
   * 3 round-trips to AWS, as opposed to one, for every file upload and download.
   * Depending on location - increased network latencies and slower builds.
   * Increased likelihood of transmission failures.
   --
   
   ==== AWS S3 Cross Account Access
   
   Some organizations may have multiple AWS accounts, e.g. one for each team. The AWS account of the bucket owner is often different from the artifact publisher and consumers. The bucket owner needs to be able to grant the consumers access otherwise the artifacts will only be usable by the publisher's account. This is done by adding the `bucket-owner-full-control` link:https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl[Canned ACL] to the uploaded objects. Gradle will do this in every upload. Make sure the publisher has the required IAM permission, `PutObjectAcl` (and `PutObjectVersionAcl` if bucket versioning is enabled), either directly or via an assumed IAM Role (depending on your case). You can read more at link:https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-access-control.html[AWS S3 Access Permissions].
   
   == Google Cloud Storage repositories configuration
   
   === GCS configuration properties
   
   The following system properties can be used to configure the interactions with link:https://cloud.google.com/storage/[Google Cloud Storage] repositories:
   
   `org.gradle.gcs.endpoint`::
   Used to override the Google Cloud Storage endpoint when using a non-Google Cloud Platform, Google Cloud Storage API compatible, storage service.
   
   `org.gradle.gcs.servicePath`::
   Used to override the Google Cloud Storage root service path which the Google Cloud Storage client builds requests from, defaults to `/`.
   
   === GCS URL formats
   
   Google Cloud Storage URL's are 'virtual-hosted-style' and must be in the following format `gcs://&lt;bucketName&gt;/&lt;objectKey&gt;`
   
   e.g. `gcs://myBucket/maven/release`
   
   * `myBucket` is the Google Cloud Storage bucket name.
   * `/maven/release` is the Google Cloud Storage key (unique identifier for an object within a bucket)
   
   == Handling credentials
   
   Repository credentials should never be part of your build script but rather be kept external.
   Gradle provides link:{javadocPath}#[an API in artifact repositories]
   that allows you to declare only the type of required credentials. Credential values are looked up from the <<build_environment.adoc#sec:gradle_configuration_properties,Gradle Properties>>
   during the build that requires them.
   
   For example, given repository configuration:
   
   .Externalized repository credentials
   ====
   include::sample[dir="samples/credentials-handling/publishing-credentials/kotlin",files="build.gradle.kts[tags=repositories]"]
   include::sample[dir="samples/credentials-handling/publishing-credentials/groovy",files="build.gradle[tags=repositories]"]
   ====
   
   The username and password will be looked up from `mySecureRepositoryUsername` and `mySecureRepositoryPassword` properties.
   
   Note that the configuration property prefix - the identity - is determined from the repository name.
   Credentials can then be provided in any of supported ways for Gradle Properties -
   `gradle.properties` file, command line arguments, environment variables or a combination of those options.
   
   Also, note that credentials will only be required if the invoked build requires them. If for example a project is configured
   to publish artifacts to a secured repository, but the build does not invoke publishing task, Gradle will not require
   publishing credentials to be present. On the other hand, if the build needs to execute a task that requires credentials
   at some point, Gradle will check for credential presence first thing and will not start running any of the tasks
   if it knows that the build will fail at a later point because of missing credentials.
   
   Here is a link:#[downloadable sample] that demonstrates the concept in more detail.
   
   Lookup is only supported for credentials listed in the xref:#credentials_lookup_properties[xrefstyle=short].
   [%header%autowidth,compact]
   .Credentials that support value lookup and their corresponding properties
   |===
   | Type | Argument | Base property name | Required?
   
   
   .2+| `link:{javadocPath}#[PasswordCredentials]`
   | `username`
   | `Username`
   | required
   
   | `password`
   | `Password`
   | required
   
   .3+| `link:{javadocPath}#[AwsCredentials]`
   | `accessKey`
   | `AccessKey`
   | required
   
   | `secretKey`
   | `SecretKey`
   | required
   
   | `sessionToken`
   | `SessionToken`
   | optional
   
   .2+| `link:{javadocPath}#[HttpHeaderCredentials]`
   | `name`
   | `AuthHeaderName`
   | required
   
   | `value`
   | `AuthHeaderValue`
   | required
   
   |===

/docs/userguide/dep-man/01-core-dependency-management/declaring_dependencies.adoc
=================================================================================

.. code-block::

   = Declaring dependencies
   
   Before looking at dependency declarations themselves, the concept of _dependency configuration_ needs to be defined.
   
   == What are dependency configurations
   
   Every dependency declared for a Gradle project applies to a specific scope.
   For example some dependencies should be used for compiling source code whereas others only need to be available at runtime.
   Gradle represents the scope of a dependency with the help of a link:{groovyDslPath}#[Configuration].
   Every configuration can be identified by a unique name.
   
   Many Gradle plugins add pre-defined configurations to your project.
   The Java plugin, for example, adds configurations to represent the various classpaths it needs for source code compilation, executing tests and the like.
   See <<java_plugin.adoc#sec:java_plugin_and_dependency_management,the Java plugin chapter>> for an example.
   
   .Configurations use declared dependencies for specific purposes
   image::dependency-management-configurations.png[]
   
   For more examples on the usage of configurations to navigate, inspect and post-process metadata and artifacts of assigned dependencies, have a look at the <<dependency_resolution.adoc#sec:programmatic_api,resolution result APIs>>.
   
   === Configuration inheritance and composition
   
   A configuration can extend other configurations to form an inheritance hierarchy.
   Child configurations inherit the whole set of dependencies declared for any of its superconfigurations.
   
   Configuration inheritance is heavily used by Gradle core plugins like the <<java_plugin.adoc#sec:java_plugin_and_dependency_management,Java plugin>>.
   For example the `testImplementation` configuration extends the `implementation` configuration.
    The configuration hierarchy has a practical purpose: compiling tests requires the dependencies of the source code under test on top of the dependencies needed write the test class.
    A Java project that uses JUnit to write and execute test code also needs Guava if its classes are imported in the production source code.
   
   .Configuration inheritance provided by the Java plugin
   image::dependency-management-configuration-inheritance.png[]
   
   Under the covers the `testImplementation` and `implementation` configurations form an inheritance hierarchy by calling the method link:{groovyDslPath}#[]++)[Configuration.extendsFrom(org.gradle.api.artifacts.Configuration++[]++)].
   A configuration can extend any other configuration irrespective of its definition in the build script or a plugin.
   
   Let's say you wanted to write a suite of smoke tests.
   Each smoke test makes a HTTP call to verify a web service endpoint.
   As the underlying test framework the project already uses JUnit.
   You can define a new configuration named `smokeTest` that extends from the `testImplementation` configuration to reuse the existing test framework dependency.
   
   .Extending a configuration from another configuration
   ====
   include::sample[dir="snippets/dependencyManagement/definingUsingConfigurations-inheritance/kotlin",files="build.gradle.kts[tags=configuration-definition]"]
   include::sample[dir="snippets/dependencyManagement/definingUsingConfigurations-inheritance/groovy",files="build.gradle[tags=configuration-definition]"]
   ====
   
   == Resolvable and consumable configurations
   
   Configurations are a fundamental part of dependency resolution in Gradle.
   In the context of dependency resolution, it is useful to distinguish between a _consumer_ and a _producer_. Along these lines, configurations have at least 3 different roles:
   
   1. to declare dependencies
   2. as a _consumer_, to resolve a set of dependencies to files
   3. as a _producer_, to expose artifacts and their dependencies for consumption by other projects
      (such _consumable_ configurations usually represent the <<variant_model.adoc#understanding-variant-selection,variants>> the producer offers to its consumers)
   
   For example, to express that an application `app` _depends on_ library `lib`, _at least_ one configuration is required:
   
   .Configurations are used to declare dependencies
   ====
   include::sample[dir="snippets/dependencyManagement/attributeMatching/kotlin",files="build.gradle.kts[tags=declare-configuration]"]
   include::sample[dir="snippets/dependencyManagement/attributeMatching/groovy",files="build.gradle[tags=declare-configuration]"]
   ====
   
   Configurations can inherit dependencies from other configurations by extending from them.
   Now, notice that the code above doesn't tell us anything about the intended _consumer_ of this configuration.
   In particular, it doesn't tell us how the configuration is meant to be _used_.
   Let's say that `lib` is a Java library: it might expose different things, such as its API, implementation, or test fixtures.
   It might be necessary to change how we resolve the dependencies of `app` depending upon the task we're performing (compiling against the API of `lib`, executing the application, compiling tests, etc.).
   To address this problem, you'll often find companion configurations, which are meant to unambiguously declare the usage:
   
   .Configurations representing concrete dependency graphs
   ====
   include::sample[dir="snippets/dependencyManagement/attributeMatching/kotlin",files="build.gradle.kts[tags=concrete-classpath]"]
   include::sample[dir="snippets/dependencyManagement/attributeMatching/groovy",files="build.gradle[tags=concrete-classpath]"]
   ====
   
   At this point, we have 3 different configurations with different roles:
   
   - `someConfiguration` declares the dependencies of my application. It is simply a collection of dependencies.
   - `compileClasspath` and `runtimeClasspath` are configurations _meant to be resolved_: when resolved they should contain the compile classpath, and the runtime classpath of the application respectively.
   
   This distinction is represented by the `canBeResolved` flag in the `Configuration` type.
   A configuration that _can be resolved_ is a configuration for which we can compute a dependency graph, because it contains all the necessary information for resolution to happen.
   That is to say we're going to compute a dependency graph, resolve the components in the graph, and eventually get artifacts.
   A configuration which has `canBeResolved` set to `false` is not meant to be resolved.
   Such a configuration is there _only to declare dependencies_.
   The reason is that depending on the usage (compile classpath, runtime classpath), it _can_ resolve to different graphs.
   It is an error to try to resolve a configuration which has `canBeResolved` set to `false`.
   To some extent, this is similar to an _abstract class_ (`canBeResolved`=false) which is not supposed to be instantiated, and a concrete class extending the abstract class (`canBeResolved`=true).
   A resolvable configuration will extend at least one non-resolvable configuration (and may extend more than one).
   
   On the other end, at the library project side (the _producer_), we also use configurations to represent what can be consumed.
   For example, the library may expose an API or a runtime, and we would attach artifacts to either one, the other, or both.
   Typically, to compile against `lib`, we need the API of `lib`, but we don't need its runtime dependencies.
   So the `lib` project will expose an `apiElements` configuration, which is aimed at consumers looking for its API.
   Such a configuration is consumable, but is not meant to be resolved.
   This is expressed via the _canBeConsumed_ flag of a `Configuration`:
   
   .Setting up configurations
   ====
   include::sample[dir="snippets/dependencyManagement/attributeMatching/kotlin",files="build.gradle.kts[tags=setup-configurations]"]
   include::sample[dir="snippets/dependencyManagement/attributeMatching/groovy",files="build.gradle[tags=setup-configurations]"]
   ====
   
   In short, a configuration's role is determined by the `canBeResolved` and `canBeConsumed` flag combinations:
   
   .Configuration roles
   |===
   |Configuration role|can be resolved|can be consumed
   |Dependency Scope|false|false
   |Resolve for certain usage|true|false
   |Exposed to consumers|false|true
   |Legacy, don't use|true|true
   |===
   
   For backwards compatibility, both flags have a default value of `true`, but as a plugin author, you should always determine the right values for those flags, or you might accidentally introduce resolution errors.
   
   == Choosing the right configuration for dependencies
   
   The choice of the configuration where you declare a dependency is important.
   However there is no fixed rule into which configuration a dependency must go.
   It mostly depends on the way the configurations are organised, which is most often a property of the applied plugin(s).
   
   For example, in the `java` plugin, the created configuration are <<java_plugin.adoc#tab:configurations,documented>> and should serve as the basis for determining where to declare a dependency, based on its role for your code.
   
   As a recommendation, plugins should clearly document the way their configurations are linked together and should strive as much as possible to isolate their <<#sec:resolvable-consumable-configs,roles>>.
   
   == Deprecated configurations
   
   Configurations are intended to be used for a single role: declaring dependencies, performing resolution, or defining consumable variants.
   In the past, some configurations did not define which role they were intended to be used for.
   A deprecation warning is emitted when a configuration is used in a way that was not intended.
   To fix the deprecation, you will need to stop using the configuration in the deprecated role.
   The exact changes required depend on how the configuration is used and if there are alternative configurations that should be used instead.
   
   == Defining custom configurations
   
   You can define configurations yourself, so-called _custom configurations_.
   A custom configuration is useful for separating the scope of dependencies needed for a dedicated purpose.
   
   Let's say you wanted to declare a dependency on the link:https://tomcat.apache.org/tomcat-9.0-doc/jasper-howto.html[Jasper Ant task] for the purpose of pre-compiling JSP files that should _not_ end up in the classpath for compiling your source code.
   It's fairly simple to achieve that goal by introducing a custom configuration and using it in a task.
   
   .Declaring and using a custom configuration
   ====
   include::sample[dir="snippets/dependencyManagement/definingUsingConfigurations-custom/kotlin",files="build.gradle.kts[tags=custom-configuration]"]
   include::sample[dir="snippets/dependencyManagement/definingUsingConfigurations-custom/groovy",files="build.gradle[tags=custom-configuration]"]
   ====
   
   You can manage project configurations with a `configurations` object.
   Configurations have a name and can extend each other.
   To learn more about this API have a look at link:{groovyDslPath}#[ConfigurationContainer].
   
   == Different kinds of dependencies
   
   === Module dependencies
   
   Module dependencies are the most common dependencies. They refer to a module in a repository.
   
   .Module dependencies
   ====
   include::sample[dir="snippets/artifacts/externalDependencies/kotlin",files="build.gradle.kts[tags=module-dependencies]"]
   include::sample[dir="snippets/artifacts/externalDependencies/groovy",files="build.gradle[tags=module-dependencies]"]
   ====
   
   See the link:{groovyDslPath}#[DependencyHandler] class in the API documentation for more examples and a complete reference.
   
   Gradle provides different notations for module dependencies. There is a string notation and a map notation. A module dependency has an API which allows further configuration. Have a look at link:{javadocPath}#[ExternalModuleDependency] to learn all about the API. This API provides properties and configuration methods. Via the string notation you can define a subset of the properties. With the map notation you can define all properties. To have access to the complete API, either with the map or with the string notation, you can assign a single dependency to a configuration together with a closure.
   
   [NOTE]
   ====
   If you declare a module dependency, Gradle looks for a module metadata file (`.module`, `.pom` or `ivy.xml`) in the repositories.
   If such a module metadata file exists, it is parsed and the artifacts of this module (e.g. `hibernate-3.0.5.jar`) as well as its dependencies (e.g. `cglib`) are downloaded.
   If no such module metadata file exists, as of Gradle 6.0, you need to configure <<declaring_repositories.adoc#sec:supported_metadata_sources,metadata sources definitions>> to look for an artifact file called `hibernate-3.0.5.jar` directly.
   ====
   
   [IMPORTANT]
   ====
   In Maven, a module can have one and only one artifact.
   
   In Gradle and Ivy, a module can have multiple artifacts.
   Each artifact can have a different set of dependencies.
   ====
   
   === File dependencies
   
   Projects sometimes do not rely on a binary repository product e.g. JFrog Artifactory or Sonatype Nexus for hosting and resolving external dependencies.
   It's common practice to host those dependencies on a shared drive or check them into version control alongside the project source code.
   Those dependencies are referred to as _file dependencies_, the reason being that they represent a file without any <<dependency_management_terminology.adoc#sub:terminology_module_metadata,metadata>> (like information about transitive dependencies, the origin or its author) attached to them.
   
   .Resolving file dependencies from the local file system and a shared drive
   image::dependency-management-file-dependencies.png[]
   
   The following example resolves file dependencies from the directories `ant`, `libs` and `tools`.
   
   .Declaring multiple file dependencies
   ====
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-fileDependencies/kotlin",files="build.gradle.kts[tags=file-dependencies]"]
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-fileDependencies/groovy",files="build.gradle[tags=file-dependencies]"]
   ====
   
   As you can see in the code example, every dependency has to define its exact location in the file system.
   The most prominent methods for creating a file reference are
   link:{groovyDslPath}#[]++)[Project.files(java.lang.Object...)],
   link:{javadocPath}#[ProjectLayout.files(java.lang.Object...)]
   and link:{groovyDslPath}#[Project.fileTree(java.lang.Object)]
   Alternatively, you can also define the source directory of one or many file dependencies in the form of a <<declaring_repositories.adoc#sub:flat_dir_resolver,flat directory repository>>.
   
   [NOTE]
   ====
   The order of the files in a `FileTree` is not stable, even on a single computer.
   It means that dependency configuration seeded with such a construct may produce a resolution result which has a different ordering, possibly impacting the cacheability of tasks using the result as an input.
   Using the simpler `files` instead is recommended where possible.
   ====
   
   File dependencies allow you to directly add a set of files to a configuration, without first adding them to a repository. This can be useful if you cannot, or do not want to, place certain files in a repository. Or if you do not want to use any repositories at all for storing your dependencies.
   
   To add some files as a dependency for a configuration, you simply pass a <<working_with_files.adoc#sec:file_collections,file collection>> as a dependency:
   
   .File dependencies
   ====
   include::sample[dir="snippets/artifacts/externalDependencies/kotlin",files="build.gradle.kts[tags=file-dependencies]"]
   include::sample[dir="snippets/artifacts/externalDependencies/groovy",files="build.gradle[tags=file-dependencies]"]
   ====
   
   File dependencies are not included in the published dependency descriptor for your project.
   However, file dependencies are included in transitive project dependencies within the same build.
   This means they cannot be used outside the current build, but they can be used within the same build.
   
   You can declare which tasks produce the files for a file dependency.
   You might do this when, for example, the files are generated by the build.
   
   .Generated file dependencies
   ====
   include::sample[dir="snippets/artifacts/generatedFileDependencies/kotlin",files="build.gradle.kts[tags=generated-file-dependencies]"]
   include::sample[dir="snippets/artifacts/generatedFileDependencies/groovy",files="build.gradle[tags=generated-file-dependencies]"]
   ====
   
   ----
   $ gradle -q list
   include::{snippetsPath}/artifacts/generatedFileDependencies/tests/generatedFileDependencies.out[]
   ----
   
   ==== Versioning of file dependencies
   
   It is recommended to clearly express the intention and a concrete version for file dependencies.
   File dependencies are not considered by Gradle's <<dependency_resolution.adoc#sec:how-gradle-downloads-deps,version conflict resolution>>.
   Therefore, it is extremely important to assign a version to the file name to indicate the distinct set of changes shipped with it.
   For example `commons-beanutils-1.3.jar` lets you track the changes of the library by the release notes.
   
   As a result, the dependencies of the project are easier to maintain and organize.
   It is much easier to uncover potential API incompatibilities by the assigned version.
   
   === Project dependencies
   
   Software projects often break up software components into modules to improve maintainability and prevent strong coupling.
   Modules can define dependencies between each other to reuse code within the same project.
   
   .Dependencies between projects
   image::dependency-management-project-dependencies.png[]
   
   Gradle can model dependencies between modules.
   Those dependencies are called _project dependencies_ because each module is represented by a Gradle project.
   
   .Project dependencies
   ====
   include::sample[dir="snippets/java/multiproject/kotlin/api",files="build.gradle.kts[tags=project-dependencies]"]
   include::sample[dir="snippets/java/multiproject/groovy/api",files="build.gradle[tags=project-dependencies]"]
   ====
   
   At runtime, the build automatically ensures that project dependencies are built in the correct order and added to the classpath for compilation.
   The chapter <<multi_project_builds.adoc#multi_project_builds,Authoring Multi-Project Builds>> discusses how to set up and configure multi-project builds in more detail.
   
   For more information see the API documentation for link:{javadocPath}#[ProjectDependency].
   
   The following example declares the dependencies on the `utils` and `api` project from the `web-service` project. The method link:{groovyDslPath}#[Project.project(java.lang.String)] creates a reference to a specific subproject by path.
   
   .Declaring project dependencies
   ====
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-projectDependencies/kotlin",files="web-service/build.gradle.kts[tags=project-dependencies]"]
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-projectDependencies/groovy",files="web-service/build.gradle[tags=project-dependencies]"]
   ====
   
   ==== Type-safe project dependencies
   
   --
   Type-safe project accessors are an incubating feature which must be enabled explicitly.
   Implementation may change at any time.
   
   To add support for type-safe project accessors, add this to your `settings.gradle(.kts)` file:
   
   ```
   enableFeaturePreview("TYPESAFE_PROJECT_ACCESSORS")
   ```
   --
   
   One issue with the `project(":some:path")` notation is that you have to remember the path to every project you want to depend on.
   In addition, changing a <<intro_multi_project_builds#sec:project_path,project path>> requires you to change all places where the project dependency is used, but it is easy to miss one or more occurrences (because you have to rely on search and replace).
   
   Since Gradle 7, Gradle offers an experimental type-safe API for project dependencies.
   The same example as above can now be rewritten as:
   
   .Declaring project dependencies using the type-safe API
   ====
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-typeSafeProjectDependencies/kotlin",files="web-service/build.gradle.kts[tags=project-dependencies]"]
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-typeSafeProjectDependencies/groovy",files="web-service/build.gradle[tags=project-dependencies]"]
   ====
   
   The type-safe API has the advantage of providing IDE completion so you don't need to figure out the actual names of the projects.
   
   If you add or remove a project that uses the Kotlin DSL, build script compilation fails if you forget to update a dependency.
   
   The project accessors are mapped from the _project path_.
   For example, if a project path is `:commons:utils:some:lib` then the project accessor will be `projects.commons.utils.some.lib` (which is the short-hand notation for `projects.getCommons().getUtils().getSome().getLib()`).
   
   A project name with kebab case (`some-lib`) or snake case (`some_lib`) will be converted to camel case in accessors: `projects.someLib`.
   
   === Local forks of module dependencies
   
   A module dependency can be substituted by a dependency to a local fork of the sources of that module, if the module itself is built with Gradle.
   This can be done by utilising <<composite_builds.adoc#defining_composite_builds,composite builds>>.
   This allows you, for example, to fix an issue in a library you use in an application by using, and building, a locally patched version instead of the published binary version.
   The details of this are described in the section on <<composite_builds.adoc#defining_composite_builds,composite builds>>.
   
   === Gradle distribution-specific dependencies
   
   ==== Gradle API dependency
   
   You can declare a dependency on the API of the current version of Gradle by using the link:{groovyDslPath}#[DependencyHandler.gradleApi()] method. This is useful when you are developing custom Gradle tasks or plugins.
   
   .Gradle API dependencies
   ====
   include::sample[dir="snippets/base/customExternalTask/kotlin/task",files="build.gradle.kts[tags=gradle-api-dependencies]"]
   include::sample[dir="snippets/base/customExternalTask/groovy/task",files="build.gradle[tags=gradle-api-dependencies]"]
   ====
   
   ==== Gradle TestKit dependency
   
   You can declare a dependency on the TestKit API of the current version of Gradle by using the link:{groovyDslPath}#[DependencyHandler.gradleTestKit()] method. This is useful for writing and executing functional tests for Gradle plugins and build scripts.
   
   .Gradle TestKit dependencies
   ====
   include::sample[dir="snippets/testKit/junitQuickstart/kotlin",files="build.gradle.kts[tags=declare-gradle-testkit-dependency]"]
   include::sample[dir="snippets/testKit/junitQuickstart/groovy",files="build.gradle[tags=declare-gradle-testkit-dependency]"]
   ====
   
   <<test_kit.adoc#test_kit,The TestKit chapter>> explains the use of TestKit by example.
   
   ==== Local Groovy dependency
   
   You can declare a dependency on the Groovy that is distributed with Gradle by using the link:{groovyDslPath}#[DependencyHandler.localGroovy()] method. This is useful when you are developing custom Gradle tasks or plugins in Groovy.
   
   .Gradle's Groovy dependencies
   ====
   include::sample[dir="snippets/groovy/groovyDependency/kotlin",files="build.gradle.kts[tags=bundled-groovy-dependency]"]
   include::sample[dir="snippets/groovy/groovyDependency/groovy",files="build.gradle[tags=bundled-groovy-dependency]"]
   ====
   
   == Documenting dependencies
   
   When you declare a dependency or a <<dependency_constraints.adoc#sec:adding-constraints-transitive-deps,dependency constraint>>, you can provide a custom reason for the declaration.
   This makes the dependency declarations in your build script and the <<viewing_debugging_dependencies.adoc#sec:identifying_reason_dependency_selection,dependency insight report>> easier to interpret.
   
   .Giving a reason for choosing a certain module version in a dependency declaration
   ====
   include::sample[dir="snippets/dependencyManagement/inspectingDependencies-dependencyReason/kotlin",files="build.gradle.kts[tags=dependency-reason]"]
   include::sample[dir="snippets/dependencyManagement/inspectingDependencies-dependencyReason/groovy",files="build.gradle[tags=dependency-reason]"]
   ====
   
   === Example: Using the dependency insight report with custom reasons
   
   .Output of **`gradle -q dependencyInsight --dependency asm`**
   ----
   > gradle -q dependencyInsight --dependency asm
   include::{snippetsPath}/dependencyManagement/inspectingDependencies-dependencyReason/tests/dependencyReasonReport.out[]
   ----
   
   == Resolving specific artifacts from a module dependency
   
   Whenever Gradle tries to resolve a module from a Maven or Ivy repository, it looks for a metadata file and the default artifact file, a JAR. The build fails if none of these artifact files can be resolved. Under certain conditions, you might want to tweak the way Gradle resolves artifacts for a dependency.
   
   - The dependency only provides a non-standard artifact without any metadata e.g. a ZIP file.
   - The module metadata declares more than one artifact e.g. as part of an Ivy dependency descriptor.
   - You only want to download a specific artifact without any of the transitive dependencies declared in the metadata.
   
   Gradle is a polyglot build tool and not limited to just resolving Java libraries. Let's assume you wanted to build a web application using JavaScript as the client technology. Most projects check in external JavaScript libraries into version control. An external JavaScript library is no different than a reusable Java library so why not download it from a repository instead?
   
   link:https://developers.google.com/speed/libraries/[Google Hosted Libraries] is a distribution platform for popular, open-source JavaScript libraries. With the help of the artifact-only notation you can download a JavaScript library file e.g. JQuery. The `@` character separates the dependency's coordinates from the artifact's file extension.
   
   .Resolving a JavaScript artifact for a declared dependency
   ====
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-artifactOnly/kotlin",files="build.gradle.kts[tags=artifact-only-dependency-declaration]"]
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-artifactOnly/groovy",files="build.gradle[tags=artifact-only-dependency-declaration]"]
   ====
   
   Some modules ship different "flavors" of the same artifact or they publish multiple artifacts that belong to a specific module version but have a different purpose. It's common for a Java library to publish the artifact with the compiled class files, another one with just the source code in it and a third one containing the Javadocs.
   
   In JavaScript, a library may exist as uncompressed or minified artifact. In Gradle, a specific artifact identifier is called _classifier_, a term generally used in Maven and Ivy dependency management.
   
   Let's say we wanted to download the minified artifact of the JQuery library instead of the uncompressed file. You can provide the classifier `min` as part of the dependency declaration.
   
   .Resolving a JavaScript artifact with classifier for a declared dependency
   ====
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-artifactOnlyWithClassifier/kotlin",files="build.gradle.kts[tags=artifact-only-dependency-declaration]"]
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-artifactOnlyWithClassifier/groovy",files="build.gradle[tags=artifact-only-dependency-declaration]"]
   ====
   
   == Supported Metadata formats
   
   External module dependencies require module metadata (so that, typically, Gradle can figure out the transitive dependencies of a module).
   To do so, Gradle supports different metadata formats.
   
   You can also tweak which format will be looked up in the <<declaring_repositories.adoc#sec:supported_metadata_sources,repository definition>>.
   
   === Gradle Module Metadata files
   
   Gradle Module Metadata has been specifically designed to support all features of Gradle's dependency management model and is hence the preferred format.
   You can find its https://github.com/gradle/gradle/blob/master/platforms/documentation/docs/src/docs/design/gradle-module-metadata-latest-specification.md[specification here].
   
   === POM files
   
   Gradle natively supports https://maven.apache.org/pom.html[Maven POM files].
   It's worth noting that by default Gradle will first look for a POM file, but if this file contains a special marker, Gradle will use <<#sub:supported-md-gradle, Gradle Module Metadata>> instead.
   
   === Ivy files
   
   Similarly, Gradle supports http://ant.apache.org/ivy/[Apache Ivy metadata files].
   Again, Gradle will first look for an `ivy.xml` file, but if this file contains a special marker, Gradle will use <<#sub:supported-md-gradle, Gradle Module Metadata>> instead.

/docs/userguide/dep-man/01-core-dependency-management/library_vs_application.adoc
=================================================================================

.. code-block::

   = Understanding the difference between libraries and applications
   
   == Producers vs consumers
   
   A key concept in dependency management with Gradle is the difference between consumers and producers.
   
   When you _build_ a library, you are effectively on the _producer_ side: you are producing _artifacts_ which are going to be _consumed_ by someone else, the _consumer_.
   
   A lot of problems with traditional build systems is that they don't make the difference between a producer and a consumer.
   
   A _consumer_ needs to be understood in the large sense:
   
   - a project that depends on another project is a _consumer_
   - a _task_ that depends on an artifact is a finer grained consumer
   
   In dependency management, a lot of the decisions we make depend on the type of project we are building, that is to say, <<#sub:being-respectful-consumers,what kind of _consumer_ we are>>.
   
   == Producer variants
   
   A producer may want to generate different artifacts for different kinds of consumers: for the same source code, different _binaries_ are produced.
   Or, a project may produce artifacts which are for consumption by other projects (same repository) but not for external use.
   
   A typical example in the Java world is the Guava library which is published in different versions: one for Java projects, and one for Android projects.
   
   However, it's the consumer responsibility to tell what version to use, and it's the dependency management engine responsibility to ensure _consistency of the graph_ (for example making sure that you don't end up with both Java and Android versions of Guava on your classpath).
   This is where the <<variant_model.adoc#understanding-variant-selection,variant model>> of Gradle comes into play.
   
   In Gradle, _producer variants_ are exposed via <<declaring_dependencies.adoc#sec:resolvable-consumable-configs,consumable configurations>>.
   
   == Strong encapsulation
   
   In order for a producer to compile a library, it needs all its _implementation dependencies_ on the compile classpath.
   There are dependencies which are only required _as an implementation detail_ of the library and there are libraries which are effectively part of the API.
   
   However, a library _depending_ on this produced library only needs to "see" the public API of your library and therefore the dependencies of this API.
   It's a subset of the compile classpath of the producer: this is strong encapsulation of dependencies.
   
   The consequence is that a dependency which is assigned to the `implementation` configuration of a library _does not end up on the compile classpath of the consumer_.
   On the other hand, a dependency which is assigned to the `api` configuration of a library _would end up on the compile classpath of the consumer_.
   At _runtime_, however, all dependencies are required.
   Gradle makes the difference between different kinds of consumer even within a single project: the Java compile task, for example, is a different consumer than the Java exec task.
   
   More details on the segregation of API and runtime dependencies in the Java world <<java_library_plugin.adoc#java_library_plugin,can be found here>>.
   
   == Being respectful of consumers
   
   Whenever, as a developer, you decide to include a dependency, you must understand that there are _consequences for your consumers_.
   For example, if you add a dependency to your project, it becomes a _transitive dependency_ of your consumers, and therefore may participate in conflict resolution if the consumer needs a different version.
   
   A lot of the problems Gradle handles are about fixing the mismatch between the expectations of a consumer and a producer.
   
   However, some projects are easier than others:
   
   - if you are at the end of the consumption chain, that is to say you build an _application_, then there are effectively _no consumer_ of your project (apart from final customers): adding <<dependency_downgrade_and_exclude.adoc#sec:excluding-transitive-deps,exclusions>> will have no other consequence than fixing your problem.
   - however if you are a library, adding <<dependency_downgrade_and_exclude.adoc#sec:excluding-transitive-deps,exclusions>> may prevent consumers from working properly, because they would exercise a path of the code that you don't
   
   Always keep in mind that the solution you choose to fix a problem can "leak" to your consumers.
   This documentation aims at guiding you to find the right solution to the right problem, and more importantly, make decisions which help the resolution engine to take the right decisions in case of conflicts.

/docs/userguide/dep-man/01-core-dependency-management/viewing_debugging_dependencies.adoc
=========================================================================================

.. code-block::

   = View and Debug Dependencies
   
   Gradle provides tooling to navigate dependency graphs and mitigate link:https://en.wikipedia.org/wiki/Dependency_hell[dependency hell].
   Users can render the full graph of dependencies as well as identify the selection reason and origin for a dependency.
   Dependencies can originate through build script declared dependencies or transitive dependencies.
   You can visualize dependencies with:
   
   - the built-in Gradle CLI `dependencies` task
   - the built-in Gradle CLI `dependencyInsight` task
   - link:https://scans.gradle.com/[build scans]
   
   == List Project Dependencies
   
   Gradle provides the built-in `dependencies` task to render a dependency tree from the command line.
   By default, the dependency tree renders dependencies for all <<declaring_dependencies.adoc#sec:what-are-dependency-configurations,configurations>> within a <<command_line_interface#executing_tasks_in_multi_project_builds,single project>>.
   The dependency tree indicates the selected version of each dependency.
   It also displays information about dependency conflict resolution.
   
   The `dependencies` task can be especially helpful for issues related to transitive dependencies.
   Your build file lists direct dependencies, but the `dependencies` task can help you understand which transitive dependencies resolve during your build.
   
   NOTE: Graph of dependencies <<tutorial_using_tasks.adoc#sec:build_script_external_dependencies, declared in the `buildscript` `classpath` configuration>> can be rendered using <<command_line_interface.adoc#sec:listing_project_dependencies, task `buildEnvironment`>>.
   
   === Output Annotations
   
   The `dependencies` task marks dependency trees with the following annotations:
   
   - `(*)`: Indicates repeated occurrences of a transitive dependency subtree. Gradle expands transitive dependency subtrees only once per project; repeat occurrences only display the root of the subtree, followed by this annotation.
   - `(c)`: This element is a <<dependency_constraints.adoc#sec:direct-vs-transitive-deps,dependency constraint>>, not a dependency. Look for the matching dependency elsewhere in the tree.
   - `(n)`: A dependency or dependency configuration that <<declaring_dependencies.adoc#sec:resolvable-consumable-configs,cannot be resolved>>.
   
   === Specify a Dependency Configuration
   
   To focus on the information about one dependency configuration, provide the optional parameter `--configuration`.
   Just like <<command_line_interface#sec:name_abbreviation, project and task names>>, Gradle accepts abbreviated names to select a dependency configuration.
   For example, you can specify `tRC` instead of `testRuntimeClasspath` if the pattern matches to a single dependency configuration.
   Both of the following examples show dependencies in the `testRuntimeClasspath` dependency configuration of a Java project:
   
   ----
   > gradle -q dependencies --configuration testRuntimeClasspath
   ----
   
   ----
   > gradle -q dependencies --configuration tRC
   ----
   
   To see a list of all the configurations available in a project, including those added by any plugins, you can run a `resolvableConfigurations` report.
   
   For more info, see that plugin's documentation (for instance, the Java Plugin is documented <<java_plugin.adoc#sec:java_plugin_and_dependency_management,here>>).
   
   === Example
   
   Consider a project that uses the link:https://www.eclipse.org/jgit/[JGit library] to execute Source Control Management (SCM) operations for a release process.
   You can declare dependencies for external tooling with the help of a <<declaring_dependencies.adoc#sec:what-are-dependency-configurations,custom dependency configuration>>.
   This avoids polluting other contexts, such as the compilation classpath for your production source code.
   
   The following example declares a custom dependency configuration named "scm" that contains the JGit dependency:
   
   ====
   include::sample[dir="snippets/dependencyManagement/inspectingDependencies-dependenciesReport/kotlin",files="build.gradle.kts[tags=dependency-declaration]"]
   include::sample[dir="snippets/dependencyManagement/inspectingDependencies-dependenciesReport/groovy",files="build.gradle[tags=dependency-declaration]"]
   ====
   
   
   Use the following command to view a dependency tree for the `scm` dependency configuration:
   
   ----
   > gradle -q dependencies --configuration scm
   include::{snippetsPath}/dependencyManagement/inspectingDependencies-dependenciesReport/tests/dependencyReport.out[]
   ----
   
   == Identify the Dependency Version Selected
   
   A project may request two different versions of the same dependency either directly or transitively.
   Gradle applies <<dependency_resolution.adoc#sec:version-conflict,version conflict resolution>> to ensure that only one version of the dependency exists in the dependency graph.
   The following example introduces a conflict with `commons-codec:commons-codec`, added both as a direct dependency and a transitive dependency of JGit:
   
   ====
   include::sample[dir="snippets/dependencyManagement/inspectingDependencies-dependencyInsightReport/kotlin",files="build.gradle.kts[tags=dependency-declaration]"]
   include::sample[dir="snippets/dependencyManagement/inspectingDependencies-dependencyInsightReport/groovy",files="build.gradle[tags=dependency-declaration]"]
   ====
   
   The dependency tree in a link:https://scans.gradle.com/[build scan] shows information about conflicts.
   Click on a dependency and select the "Required By" tab to see the selection reason and origin of the dependency.
   
   image::dependency-management-dependency-insight-report-build-scan.png[]
   
   === Dependency Insights
   
   Gradle provides the built-in `dependencyInsight` task to render a  _dependency insight report_ from the command line.
   Dependency insights provide information about a single dependency within a single <<declaring_dependencies.adoc#sec:what-are-dependency-configurations,configuration>>.
   Given a dependency, you can identify the selection reason and origin.
   
   `dependencyInsight` accepts the following parameters:
   
   `--dependency <dependency>` (mandatory)::
   The dependency to investigate.
   You can supply a complete `group:name`, or part of it.
   If multiple dependencies match, Gradle generates a report covering all matching dependencies.
   `--configuration <name>` (mandatory)::
   The dependency configuration which resolves the given dependency.
   This parameter is optional for projects that use the <<java_plugin#java_plugin, Java plugin>>, since the plugin provides a default value of `compileClasspath`.
   `--single-path` (optional)::
   Render only a single path to the dependency.
   
   The following code snippet demonstrates how to run a dependency insight report for all paths to a dependency named "commons-codec" within the "scm" configuration:
   
   ----
   > gradle -q dependencyInsight --dependency commons-codec --configuration scm
   include::{snippetsPath}/dependencyManagement/inspectingDependencies-dependencyInsightReport/tests/dependencyInsightReport.out[]
   ----
   
   For more information about configurations, see the <<declaring_dependencies.adoc#sec:what-are-dependency-configurations,dependency configuration documentation>>.
   
   ==== Selection Reasons
   
   The "Selection reasons" section of the dependency insight report lists the reasons why a dependency was selected.
   Have a look at the table below to understand the meaning of the different terms used:
   
   .Terminology
   [%header%autowidth,compact]
   |===
   | Reason    | Meaning
   
   | (Absent)
   | No reason other than a reference, direct or transitive, was present.
   
   | Was requested : <text>
   | The dependency appears in the graph, and the inclusion came with a <<declaring_dependencies#sec:documenting-dependencies, `because` text>>.
   
   | Was requested : didn't match versions <versions>
   | The dependency appears with a <<dynamic_versions#sub:declaring_dependency_with_dynamic_version, dynamic version>> which did not include the listed versions.
   May be followed by a `because` text.
   
   | Was requested : reject version <versions>
   | The dependency appears with a <<rich_versions#rich-version-constraints, rich version>> containing one or more `reject`.
   May be followed by a `because` text.
   
   | By conflict resolution : between versions <version>
   | The dependency appeared multiple times, with different version requests.
   This resulted in <<dependency_resolution#sec:version-conflict, conflict resolution>> to select the most appropriate version.
   
   | By constraint
   | A <<dependency_constraints#sec:adding-constraints-transitive-deps, dependency constraint>> participated in the version selection.
   May be followed by a `because` text.
   
   | By ancestor
   | There is a <<rich_versions#rich-version-constraints, rich version>> with a `strictly` which enforces the version of this dependency.
   
   | Selected by rule
   | A <<resolution_rules#resolution_rules, dependency resolution rule>> overruled the default selection process.
   May be followed by a `because` text.
   
   | Rejection : <version> by rule because <text>
   | A `ComponentSelection.reject` link:{groovyDslPath}#[rejected the given version] of the dependency.
   
   | Rejection: version <version>: <attributes information>
   | The dependency has a dynamic version and some versions did not match the <<variant_model#sec:variant-aware-matching, requested attributes>>.
   
   | Forced
   | The build enforces the version of the dependency through an enforced platform or resolution strategy.
   |===
   
   If multiple selection reasons exist, the insight report lists all of them.
   
   == Troubleshooting
   
   === Version Conflicts
   
   If the selected version does not match your expectation, Gradle offers a series of tools to help you <<dependency_constraints.adoc#dependency-constraints,control transitive dependencies>>.
   
   === Variant Selection Errors
   
   Sometimes a selection error happens at the <<variant_model.adoc#understanding-variant-selection,variant selection level>>.
   Have a look at the <<variant_model.adoc#sec:variant-select-errors,dedicated section>> to understand these errors and how to resolve them.
   
   === Unsafe Configuration Resolution Errors
   
   Resolving a configuration can have side effects on Gradle's project model.
   As a result, Gradle must manage access to each project's configurations.
   There are a number of ways a configuration might be resolved unsafely.
   For example:
   
   * A task from one project directly resolves a configuration in another project in the task's action.
   * A task specifies a configuration from another project as an input file collection.
   * A build script for one project resolves a configuration in another project during evaluation.
   * Project configurations are resolved in the settings file.
   
   Gradle produces a deprecation warning for each unsafe access.
   Unsafe access can cause indeterminate errors.
   You should <<command_line_interface.adoc#sec:command_line_warnings,fix unsafe access warnings>> in your build.
   
   In most cases, you can resolve unsafe accesses by creating a cross-project dependency on the other project.
   See the documentation for <<cross_project_publications.adoc#cross_project_publications, sharing outputs between projects>> for more information.
   
   If you find a use case that can't be resolved using these techniques, please let us know by filing a https://github.com/gradle/gradle/issues[GitHub Issue].

/docs/userguide/dep-man/01-core-dependency-management/dependency_resolution.adoc
================================================================================

.. code-block::

   = Understanding dependency resolution
   
   This chapter covers the way dependency resolution works _inside_ Gradle.
   After covering how you can declare <<declaring_repositories.adoc#declaring-repositories,repositories>> and <<declaring_dependencies.adoc#declaring-dependencies,dependencies>>, it makes sense to explain how these declarations come together during dependency resolution.
   
   Dependency resolution is a process that consists of two phases, which are repeated until the dependency graph is complete:
   
   * When a new dependency is added to the graph, perform conflict resolution to determine which version should be added to the graph.
   * When a specific dependency, that is a module with a version, is identified as part of the graph, retrieve its metadata so that its dependencies can be added in turn.
   
   The following section will describe what Gradle identifies as conflicts and how it can resolve them automatically.
   After that, the retrieval of metadata will be covered, explaining how Gradle can <<#sec:how-gradle-downloads-deps,follow dependency links>>.
   
   == How Gradle handles conflicts?
   
   When doing dependency resolution, Gradle handles two types of conflicts:
   
   Version conflicts::
   That is when two or more dependencies require a given dependency but with different versions.
   
   Implementation conflicts::
   That is when the dependency graph contains multiple modules that provide the same implementation, or capability in Gradle terminology.
   
   The following sections will explain in detail how Gradle attempts to resolve these conflicts.
   
   The dependency resolution process is highly customizable to meet enterprise requirements.
   For more information, see the chapter on <<dependency_constraints.adoc#dependency-constraints,Controlling transitive dependencies>>.
   
   == Version conflict resolution
   
   A version conflict occurs when two components:
   
   * Depend on the same module, let's say `com.google.guava:guava`
   * But on different versions, let's say `20.0` and `25.1-android`
   ** Our project itself depends on `com.google.guava:guava:20.0`
   ** Our project also depends on `com.google.inject:guice:4.2.2` which itself depends on `com.google.guava:guava:25.1-android`
   
   === Resolution strategy
   
   Given the conflict above, there exist multiple ways to handle it, either by selecting a version or failing the resolution.
   Different tools that handle dependency management have different ways of handling these type of conflicts.
   
   --
   https://maven.apache.org/[Apache Maven] uses a nearest first strategy.
   
   Maven will take the _shortest_ path to a dependency and use that version.
   In case there are multiple paths of the same length, the first one wins.
   
   This means that in the example above, the version of `guava` will be `20.0` because the direct dependency is _closer_ than the `guice` dependency.
   
   The main drawback of this method is that it is ordering dependent.
   Keeping order in a very large graph can be a challenge.
   For example, what if the new version of a dependency ends up having its own dependency declarations in a different order than the previous version?
   
   With Maven, this could have unwanted impact on resolved versions.
   --
   
   [NOTE]
   ====
   https://ant.apache.org/ivy/[Apache Ivy] is a very flexible dependency management tool.
   It offers the possibility to customize dependency resolution, including conflict resolution.
   
   This flexibility comes with the price of making it hard to reason about.
   ====
   
   Gradle will consider _all_ requested versions, wherever they appear in the dependency graph.
   Out of these versions, it will select the _highest_ one. More information on version ordering
   <<single_versions#version_ordering,here>>.
   
   As you have seen, Gradle supports a concept of <<rich_versions.adoc#rich-version-constraints,rich version declaration>>, so what is the highest version depends on the way versions were declared:
   
   * If no ranges are involved, then the highest version that is not rejected will be selected.
   ** If a version declared as `strictly` is lower than that version, selection will fail.
   * If ranges are involved:
   ** If there is a non range version that falls within the specified ranges or is higher than their upper bound, it will be selected.
   ** If there are only ranges, the selection will depend on the intersection of ranges:
   *** If all the ranges intersect, then the highest _existing_ version of the intersection will be selected.
   *** If there is no clear intersection between all the ranges, the highest _existing_ version will be selected from the highest range. If there is no version available for the highest range, the resolution will fail.
   ** If a version declared as `strictly` is lower than that version, selection will fail.
   
   Note that in the case where ranges come into play, Gradle requires metadata to determine which versions do exist for the considered range.
   This causes an intermediate lookup for metadata, as described in <<#sec:how-gradle-downloads-deps>>.
   
   === Qualifiers
   There is a caveat to comparing versions when it comes to selecting the _highest_ one.
   All the rules of <<single_versions#version_ordering,version ordering>> still apply, but the conflict resolver
   has a bias towards versions without qualifiers.
   
   The "qualifier" of a version, if it exists, is the tail end of the version string, starting at the first non-dot separator
   found in it. The other (first) part of the version string is called the "base form" of the version. Here are some examples
   to illustrate:
   
   [cols="1,1,1"]
   |===
   |Original version | Base version | Qualifier
   
   |1.2.3
   |1.2.3
   |<none>
   
   |1.2-3
   |1.2
   |3
   
   |1_alpha
   |1
   |alpha
   
   |abc
   |abc
   |<none>
   
   |1.2b3
   |1.2
   |b3
   
   |abc.1+3
   |abc.1
   |3
   
   |b1-2-3.3
   |b
   |1-2-3.3
   |===
   
   As you can see separators are any of the `.`, `-`, `_`, `+` characters, plus the empty string when a numeric and a non-numeric part of the version are next to each-other.
   
   When resolving the conflict between competing versions, the following logic applies:
   
   * first the versions with the highest base version are selected, the rest are discarded
   * if there are still multiple competing versions left, then one is picked with a preference for not having a qualifier or having release status.
   
   == Implementation conflict resolution
   
   Gradle uses variants and capabilities to identify what a module _provides_.
   
   This is a unique feature that deserves its <<variant_model.adoc#understanding-variant-selection,own chapter>> to understand what it means and enables.
   
   A conflict occurs the moment two modules either:
   
   * Attempt to select incompatible variants,
   * Declare the same capability
   
   Learn more about handling these type of conflicts in <<dependency_capability_conflict.adoc#sub:selecting-between-candidates,Selecting between candidates>>.
   
   == How Gradle retrieves dependency metadata?
   
   Gradle requires metadata about the modules included in your dependency graph.
   That information is required for two main points:
   
   * Determine the existing versions of a module when the declared version is dynamic.
   * Determine the dependencies of the module for a given version.
   
   === Discovering versions
   
   Faced with a dynamic version, Gradle needs to identify the concrete matching versions:
   
   * Each repository is inspected, Gradle does not stop on the first one returning some metadata.
   When multiple are defined, they are inspected _in the order they were added_.
   * For Maven repositories, Gradle will use the `maven-metadata.xml` which provides information about the available versions.
   * For Ivy repositories, Gradle will resort to directory listing.
   
   This process results in a list of candidate versions that are then matched to the dynamic version expressed.
   At this point, <<#sub:resolution-strategy,version conflict resolution>> is resumed.
   
   Note that Gradle caches the version information, more information can be found in the section <<dynamic_versions.adoc#sec:controlling-dynamic-version-caching,Controlling dynamic version caching>>.
   
   === Obtaining module metadata
   
   Given a required dependency, with a version, Gradle attempts to resolve the dependency by searching for the module the dependency points at.
   
   * Each repository is inspected in order.
   ** Depending on the type of repository, Gradle looks for metadata files describing the module (`.module`, `.pom` or `ivy.xml` file) or directly for artifact files.
   ** Modules that have a module metadata file (`.module`, `.pom` or `ivy.xml` file) are preferred over modules that have an artifact file only.
   ** Once a repository returns a _metadata_ result, following repositories are ignored.
   * Metadata for the dependency is retrieved and parsed, if found
   ** If the module metadata is a POM file that has a parent POM declared, Gradle will recursively attempt to resolve each of the parent modules for the POM.
   * All of the artifacts for the module are then requested from the _same repository_ that was chosen in the process above.
   * All of that data, including the repository source and potential misses are then stored in the <<#sec:dependency_cache>>.
   
   [NOTE]
   ====
   The penultimate point above is what can make the integration with <<declaring_repositories.adoc#sec:case-for-maven-local,Maven Local>> problematic.
   As it is a cache for Maven, it will sometimes miss some artifacts of a given module.
   If Gradle is sourcing such a module from Maven Local, it will consider the missing artifacts to be missing altogether.
   ====
   
   === Repository disabling
   
   When Gradle fails to retrieve information from a repository, it will disable it for the duration of the build and fail all dependency resolution.
   
   That last point is important for reproducibility.
   If the build was allowed to continue, ignoring the faulty repository, subsequent builds could have a different result once the repository is back online.
   
   ==== HTTP Retries
   
   Gradle will make several attempts to connect to a given repository before disabling it.
   If connection fails, Gradle will retry on certain errors which have a chance of being transient, increasing the amount of time waiting between each retry.
   
   Blacklisting happens when the repository cannot be contacted, either because of a permanent error or because the maximum retries was reached.
   
   == The Dependency Cache
   
   Gradle contains a highly sophisticated dependency caching mechanism, which seeks to minimise the number of remote requests made in dependency resolution, while striving to guarantee that the results of dependency resolution are correct and reproducible.
   
   The Gradle dependency cache consists of two storage types located under `$<<directory_layout.adoc#dir:gradle_user_home,GRADLE_USER_HOME>>/caches`:
   
   * A file-based store of downloaded artifacts, including binaries like jars as well as raw downloaded meta-data like POM files and Ivy files.
   The storage path for a downloaded artifact includes the SHA1 checksum, meaning that 2 artifacts with the same name but different content can easily be cached.
   * A binary store of resolved module metadata, including the results of resolving dynamic versions, module descriptors, and artifacts.
   
   The Gradle cache does not allow the local cache to hide problems and create other mysterious and difficult to debug behavior.
   Gradle enables reliable and reproducible enterprise builds with a focus on bandwidth and storage efficiency.
   
   === Separate metadata cache
   
   Gradle keeps a record of various aspects of dependency resolution in binary format in the metadata cache.
   The information stored in the metadata cache includes:
   
   * The result of resolving a dynamic version (e.g. `1.+`) to a concrete version (e.g. `1.2`).
   * The resolved module metadata for a particular module, including module artifacts and module dependencies.
   * The resolved artifact metadata for a particular artifact, including a pointer to the downloaded artifact file.
   * The _absence_ of a particular module or artifact in a particular repository, eliminating repeated attempts to access a resource that does not exist.
   
   Every entry in the metadata cache includes a record of the repository that provided the information as well as a timestamp that can be used for cache expiry.
   
   === Repository caches are independent
   
   As described above, for each repository there is a separate metadata cache.
   A repository is identified by its URL, type and layout.
   If a module or artifact has not been previously resolved from _this repository_, Gradle will attempt to resolve the module against the repository.
   This will always involve a remote lookup on the repository, however in many cases <<#sub:cache_artifact_reuse,no download will be required>>.
   
   Dependency resolution will fail if the required artifacts are not available in any repository specified by the build, even if the local cache has a copy of this artifact which was retrieved from a different repository.
   Repository independence allows builds to be isolated from each other in an advanced way that no build tool has done before.
   This is a key feature to create builds that are reliable and reproducible in any environment.
   
   === Artifact reuse
   
   Before downloading an artifact, Gradle tries to determine the checksum of the required artifact by downloading the sha file associated with that artifact.
   If the checksum can be retrieved, an artifact is not downloaded if an artifact already exists with the same id and checksum.
   If the checksum cannot be retrieved from the remote server, the artifact will be downloaded (and ignored if it matches an existing artifact).
   
   As well as considering artifacts downloaded from a different repository, Gradle will also attempt to reuse artifacts found in the local Maven Repository.
   If a candidate artifact has been downloaded by Maven, Gradle will use this artifact if it can be verified to match the checksum declared by the remote server.
   
   === Checksum based storage
   
   It is possible for different repositories to provide a different binary artifact in response to the same artifact identifier.
   This is often the case with Maven SNAPSHOT artifacts, but can also be true for any artifact which is republished without changing its identifier.
   By caching artifacts based on their SHA1 checksum, Gradle is able to maintain multiple versions of the same artifact.
   This means that when resolving against one repository Gradle will never overwrite the cached artifact file from a different repository.
   This is done without requiring a separate artifact file store per repository.
   
   === Cache Locking
   
   The Gradle dependency cache uses file-based locking to ensure that it can safely be used by multiple Gradle processes concurrently.
   The lock is held whenever the binary metadata store is being read or written, but is released for slow operations such as downloading remote artifacts.
   
   This concurrent access is only supported if the different Gradle processes can communicate together. This is usually _not the case_ for containerized builds.
   
   ==== Cache Cleanup
   
   Gradle keeps track of which artifacts in the dependency cache are accessed.
   Using this information, the cache is periodically (at most every 24 hours) scanned for artifacts that have not been used for more than 30 days.
   Obsolete artifacts are then deleted to ensure the cache does not grow indefinitely.
   
   == Dealing with ephemeral builds
   
   It's a common practice to run builds in ephemeral containers.
   A container is typically spawned to only execute a single build before it is destroyed.
   This can become a practical problem when a build depends on a lot of dependencies which each container has to re-download.
   To help with this scenario, Gradle provides a couple of options:
   
   - <<sub:cache_copy,copying the dependency cache>> into each container
   - <<sub:shared-readonly-cache,sharing a read-only dependency cache>> between multiple containers
   
   === Copying and reusing the cache
   
   The dependency cache, both the file and metadata parts, are fully encoded using relative paths.
   This means that it is perfectly possible to copy a cache around and see Gradle benefit from it.
   
   The path that can be copied is `$GRADLE_USER_HOME/caches/modules-<version>`.
   The only constraint is placing it using the same structure at the destination, where the value of `GRADLE_USER_HOME` can be different.
   
   Do not copy the `*.lock` or `gc.properties` files if they exist.
   
   Note that creating the cache and consuming it should be done using compatible Gradle version, as shown in the table below.
   Otherwise, the build might still require some interactions with remote repositories to complete missing information, which might be available in a different version.
   If multiple incompatible Gradle versions are in play, all should be used when seeding the cache.
   
   .Dependency cache compatibility
   [%header%autowidth,compact]
   |===
   | Module cache version  | File cache version    | Metadata cache version    | Gradle version(s)
   
   | `modules-2`           | `files-2.1`           | `metadata-2.95`           | Gradle 6.1 to Gradle 6.3
   
   | `modules-2`           | `files-2.1`           | `metadata-2.96`           | Gradle 6.4 to Gradle 6.7
   
   | `modules-2`           | `files-2.1`           | `metadata-2.97`           | Gradle 6.8 to Gradle 7.4
   | `modules-2`           | `files-2.1`           | `metadata-2.99`           | Gradle 7.5 to Gradle 7.6.1
   | `modules-2`           | `files-2.1`           | `metadata-2.101`          | Gradle 7.6.2
   | `modules-2`           | `files-2.1`           | `metadata-2.100`          | Gradle 8.0
   | `modules-2`           | `files-2.1`           | `metadata-2.105`          | Gradle 8.1
   | `modules-2`           | `files-2.1`           | `metadata-2.106`          | Gradle 8.2 and above
   |===
   
   === Sharing the dependency cache with other Gradle instances
   
   Instead of <<sub:cache_copy,copying the dependency cache into each container>>, it's possible to mount a shared, read-only directory that will act as a dependency cache for all containers.
   This cache, unlike the classical dependency cache, is accessed without locking, making it possible for multiple builds to read from the cache concurrently. It's important that the read-only cache
   is not written to when other builds may be reading from it.
   
   When using the shared read-only cache, Gradle looks for dependencies (artifacts or metadata) in both the writable cache in the local Gradle User Home directory and the shared read-only cache.
   If a dependency is present in the read-only cache, it will not be downloaded.
   If a dependency is missing from the read-only cache, it will be downloaded and added to the writable cache.
   In practice, this means that the writable cache will only contain dependencies that are unavailable in the read-only cache.
   
   The read-only cache should be sourced from a Gradle dependency cache that already contains some of the required dependencies.
   The cache can be incomplete; however, an empty shared cache will only add overhead.
   
   NOTE: The shared read-only dependency cache is an incubating feature.
   
   The first step in using a shared dependency cache is to create one by copying of an existing _local_ cache.
   For this you need to follow the <<sub:cache_copy,instructions above>>.
   
   Then set the `GRADLE_RO_DEP_CACHE` environment variable to point to the directory containing the cache:
   
   ----
   $GRADLE_RO_DEP_CACHE
      |-- modules-2 : the read-only dependency cache, should be mounted with read-only privileges
   
   $GRADLE_HOME
      |-- caches
            |-- modules-2 : the container specific dependency cache, should be writable
            |-- ...
      |-- ...
   ----
   
   In a CI environment, it's a good idea to have one build which "seeds" a Gradle dependency cache, which is then _copied_ to a different directory.
   This directory can then be used as the read-only cache for other builds.
   You shouldn't use an existing Gradle installation cache as the read-only cache, because this directory may contain locks and may be modified by the seeding build.
   
   == Accessing the resolution result programmatically
   
   While most users only need access to a "flat list" of files, there are cases where it can be interesting to reason on a _graph_ and get more information about the resolution result:
   
   - for tooling integration, where a model of the dependency graph is required
   - for tasks generating a visual representation (image, `.dot` file, ...) of a dependency graph
   - for tasks providing diagnostics (similar to the `dependencyInsight` task)
   - for tasks which need to perform dependency resolution at execution time (e.g, download files on demand)
   
   For those use cases, Gradle provides lazy, thread-safe APIs, accessible by calling the link:{javadocPath}#[Configuration.getIncoming()] method:
   
   - the link:{javadocPath}#[ResolutionResult API] gives access to a resolved dependency graph, whether the resolution was successful or not.
   - the link:{javadocPath}#[artifacts API] provides a simple access to the resolved artifacts, untransformed, but with lazy download of artifacts (they would only be downloaded on demand).
   - the link:{javadocPath}#[artifact view API] provides an advanced, filtered view of artifacts, possibly <<artifact_transforms.adoc#sec:abm_artifact_transforms,transformed>>.
   
   NOTE: See the documentation on <<incremental_build.adoc#sec:task_input_using_dependency_resolution_results, using dependency resolution results>> for more details on how to consume the results in a task.

/docs/userguide/dep-man/01-core-dependency-management/dependency_verification.adoc
==================================================================================

.. code-block::

   = Verifying dependencies
   
   Working with external dependencies and plugins published on third-party repositories puts your build at risk.
   In particular, you need to be aware of what binaries are brought in transitively and if they are legit.
   To mitigate the security risks and avoid integrating compromised dependencies in your project, Gradle supports _dependency verification_.
   
   --
   Dependency verification is, by nature, an inconvenient feature to use.
   It means that whenever you're going to update a dependency, builds are likely to fail.
   It means that merging branches are going to be harder because each branch can have different dependencies.
   It means that you will be tempted to switch it off.
   
   So why should you bother?
   
   Dependency verification is about **trust** in what you get and what you ship.
   
   Without dependency verification it's easy for an attacker to compromise your supply chain.
   There are many real world examples of tools compromised by adding a malicious dependency.
   Dependency verification is meant to protect yourself from those attacks, by forcing you to ensure that the artifacts you include in your build are the ones that you expect.
   It is not meant, however, to prevent you from including _vulnerable_ dependencies.
   
   Finding the right balance between security and convenience is hard but Gradle will try to let you choose the "right level" for you.
   --
   
   Dependency verification consists of two different and complementary operations:
   
   - _checksum verification_, which allows asserting the integrity of a dependency
   - _signature verification_, which allows asserting the provenance of a dependency
   
   Gradle supports both checksum and signature verification out of the box but performs no dependency verification by default.
   This section will guide you into configuring dependency verification properly for your needs.
   
   This feature can be used for:
   
   - detecting compromised dependencies
   - detecting compromised plugins
   - detecting tampered dependencies in the local dependency caches
   
   == Enabling dependency verification
   
   === The verification metadata file
   
   NOTE: Currently the only source of dependency verification metadata is this XML configuration file.
   Future versions of Gradle may include other sources (for example via external services).
   
   Dependency verification is automatically enabled once the configuration file for dependency verification is discovered.
   This configuration file is located at `$PROJECT_ROOT/gradle/verification-metadata.xml`.
   This file minimally consists of the following:
   
   [source,xml]
   ----
   <?xml version="1.0" encoding="UTF-8"?>
   <verification-metadata xmlns="https://schema.gradle.org/dependency-verification"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="https://schema.gradle.org/dependency-verification https://schema.gradle.org/dependency-verification/dependency-verification-1.3.xsd">
      <configuration>
         <verify-metadata>true</verify-metadata>
         <verify-signatures>false</verify-signatures>
       </configuration>
   </verification-metadata>
   ----
   
   Doing so, Gradle will verify all artifacts using <<#sec:checksum-verification,checksums>>, but will not verify <<#sec:signature-verification,signatures>>.
   Gradle will verify any artifact downloaded using its dependency management engine, which includes, but is not limited to:
   
   - artifact files (e.g jar files, zips, ...) used during a build
   - metadata artifacts (POM files, Ivy descriptors, Gradle Module Metadata)
   - plugins (both project and settings plugins)
   - artifacts resolved using the advanced dependency resolution APIs
   
   Gradle will _not_ verify changing dependencies (in particular `SNAPSHOT` dependencies) nor locally produced artifacts (typically jars produced during the build itself) as by nature their checksums and signatures would always change.
   
   With such a minimal configuration file, a project using _any_ external dependency or plugin would immediately start failing because it doesn't contain any checksum to verify.
   
   === Scope of the dependency verification
   
   A dependency verification configuration is _global_: a single file is used to configure verification of the whole build.
   In particular, the same file is used for both the (sub)projects and `buildSrc`.
   
   If an included build is used:
   
   - the configuration file of the _current_ build is used for verification
   - so if the included build itself uses verification, its configuration is ignored in favor of the current one
   - which means that including a build works similarly to upgrading a dependency: it may require you to update your current verification metadata
   
   An easy way to get started is therefore to generate the minimal configuration for an existing build.
   
   === Configuring the console output
   
   By default, if dependency verification fails, Gradle will generate a small summary about the verification failure as well as an HTML report containing the full information about the failures.
   If your environment prevents you from reading this HTML report file (for example if you run a build on CI and that it's not easy to fetch the remote artifacts), Gradle provides a way to opt-in a verbose console report.
   For this, you need to add this Gradle property to your `gradle.properties` file:
   
   ----
   org.gradle.dependency.verification.console=verbose
   ----
   
   === Bootstrapping dependency verification
   
   It's worth mentioning that while Gradle can generate a dependency verification file for you, you should always check whatever Gradle generated for you because your build may _already_ contain compromised dependencies without you knowing about it.
   Please refer to the appropriate <<#sec:checksum-verification,checksum verification>> or <<#sec:signature-verification,signature verification>> section for more information.
   
   If you plan on using <<#sec:signature-verification,signature verification>>, please also read the <<sec:bootstrapping-signature-verification,corresponding section>> of the docs.
   
   Bootstrapping can either be used to create a file from the beginning, or also to _update_ an existing file with new information.
   Therefore, it's recommended to always use the same parameters once you started bootstrapping.
   
   The dependency verification file can be generated with the following CLI instructions:
   
   ----
   gradle --write-verification-metadata sha256 help
   ----
   
   The `write-verification-metadata` flag requires the list of <<#sec:checksum-verification,checksums>> that you want to generate or `pgp` for <<#sec:signature-verification,signatures>>.
   
   Executing this command line will cause Gradle to:
   
   * resolve all <<declaring_dependencies.adoc#sec:resolvable-consumable-configs,resolvable configurations>>, which includes:
   ** configurations from the root project
   ** configurations from all subprojects
   ** configurations from `buildSrc`
   ** included builds configurations
   ** configurations used by plugins
   * download all artifacts discovered during resolution
   * compute the requested checksums and possibly verify signatures depending on what you asked
   * At the end of the build, generate the configuration file which will contain the inferred _verification metadata_
   
   As a consequence, the `verification-metadata.xml` file will be used in subsequent builds to verify dependencies.
   
   --
   There are dependencies that Gradle _cannot_ discover this way.
   In particular, you will notice that the CLI above uses the `help` task.
   If you don't specify any task, Gradle will automatically run the default task and generate a configuration file at the end of the build too.
   
   The difference is that Gradle _may_ discover more dependencies and artifacts depending on the tasks you execute.
   As a matter of fact, Gradle cannot automatically discover _detached configurations_, which are basically dependency graphs resolved as an internal implementation detail of the execution of a task: they are not, in particular, declared as an input of the task because they effectively depend on the configuration of the task at execution time.
   
   A good way to start is just to use the simplest task, `help`, which will discover as much as possible, and if subsequent builds fail with a verification error, you can re-execute generation with the appropriate tasks to "discover" more dependencies.
   
   Gradle won't verify either checksums or signatures of plugins which use their own HTTP clients.
   Only plugins which use the infrastructure provided by Gradle for performing requests will see their requests verified.
   --
   
   === Using generation for incremental updates
   
   The verification file generated by Gradle has a strict ordering for all its content.
   It also uses the information from the existing state to limit changes to the strict minimum.
   
   This means that generation is actually a convenient tool for _updating_ a verification file:
   
   * Checksum entries generated by Gradle will have a clear `origin` that starts with "Generated by Gradle", which is a good indicator that an entry needs to be reviewed,
   * Entries added by hand will immediately be accounted for, and appear at the right location after writing the file,
   * The header comments of the file will be preserved, i.e. comments before the root XML node.
   This allows you to have a license header or instructions on which tasks and which parameters to use for generating that file.
   
   With the above benefits, it is really easy to account for new dependencies or dependency versions by simply generating the file again and reviewing the changes.
   
   === Using dry mode
   
   By default, bootstrapping is incremental, which means that if you run it multiple times, information is _added_ to the file and in particular you can rely on your VCS to check the diffs.
   There are situations where you would just want to _see_ what the generated verification metadata file would look like without actually changing the existing one or overwriting it.
   
   For this purpose, you can just add `--dry-run`:
   
   ----
   gradle --write-verification-metadata sha256 help --dry-run
   ----
   
   Then instead of generating the `verification-metadata.xml` file, a _new file_ will be generated, called `verification-metadata.dryrun.xml`.
   
   NOTE: Because `--dry-run` doesn't execute tasks, this would be much faster, but it will miss any resolution happening at task execution time.
   
   === Disabling metadata verification
   
   By default, Gradle will not only verify artifacts (jars, ...) but also the metadata associated with those artifacts (typically POM files).
   Verifying this ensures the maximum level of security: metadata files typically tell what transitive dependencies will be included, so a compromised metadata file may cause the introduction of undesired dependencies in the graph.
   However, because all artifacts are verified, such artifacts would in general easily be discovered by you, because they would cause a checksum verification failure (checksums would be _missing_ from verification metadata).
   Because metadata verification can significantly increase the size of your configuration file, you may therefore want to disable verification of metadata.
   If you understand the risks of doing so, set the `<verify-metadata>` flag to `false` in the configuration file:
   
   [source,xml]
   ----
   <?xml version="1.0" encoding="UTF-8"?>
   <verification-metadata xmlns="https://schema.gradle.org/dependency-verification"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="https://schema.gradle.org/dependency-verification https://schema.gradle.org/dependency-verification/dependency-verification-1.3.xsd">
      <configuration>
         <verify-metadata>false</verify-metadata>
         <verify-signatures>false</verify-signatures>
       </configuration>
       <!-- the rest of this file doesn't need to declare anything about metadata files -->
   </verification-metadata>
   ----
   
   == Verifying dependency checksums
   
   Checksum verification allows you to ensure the integrity of an artifact.
   This is the simplest thing that Gradle can do for you to make sure that the artifacts you use are un-tampered.
   
   Gradle supports MD5, SHA1, SHA-256 and SHA-512 checksums.
   However, only SHA-256 and SHA-512 checksums are considered secure nowadays.
   
   === Adding the checksum for an artifact
   
   External components are identified by GAV coordinates, then each of the artifacts by their file names.
   To declare the checksums of an artifact, you need to add the corresponding section in the verification metadata file.
   For example, to declare the checksum for https://pdfbox.apache.org[Apache PDFBox].
   The GAV coordinates are:
   
   - group `org.apache.pdfbox`
   - name `pdfbox`
   - version `2.0.17`
   
   Using this dependency will trigger the download of 2 different files:
   
   - `pdfbox-2.0.17.jar` which is the main artifact
   - `pdfbox-2.0.17.pom` which is the metadata file associated with this artifact
   
   As a consequence, you need to declare the checksums for both of them (unless you <<sec:disabling-metadata-verification,disabled metadata verification>>):
   
   [source,xml]
   ----
   <?xml version="1.0" encoding="UTF-8"?>
   <verification-metadata xmlns="https://schema.gradle.org/dependency-verification"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="https://schema.gradle.org/dependency-verification https://schema.gradle.org/dependency-verification/dependency-verification-1.3.xsd">
      <configuration>
         <verify-metadata>true</verify-metadata>
         <verify-signatures>false</verify-signatures>
      </configuration>
      <components>
         <component group="org.apache.pdfbox" name="pdfbox" version="2.0.17">
            <artifact name="pdfbox-2.0.17.jar">
               <sha512 value="7e11e54a21c395d461e59552e88b0de0ebaf1bf9d9bcacadf17b240d9bbc29bf6beb8e36896c186fe405d287f5d517b02c89381aa0fcc5e0aa5814e44f0ab331" origin="PDFBox Official site (https://pdfbox.apache.org/download.cgi)"/>
            </artifact>
            <artifact name="pdfbox-2.0.17.pom">
               <sha512 value="82de436b38faf6121d8d2e71dda06e79296fc0f7bc7aba0766728c8d306fd1b0684b5379c18808ca724bf91707277eba81eb4fe19518e99e8f2a56459b79742f" origin="Generated by Gradle"/>
            </artifact>
         </component>
      </components>
   </verification-metadata>
   ----
   
   === Where to get checksums from?
   
   In general, checksums are published alongside artifacts on public repositories.
   However, if a dependency is compromised in a repository, it's likely its checksum will be too, so it's a good practice to get the checksum from a different place, usually the website of the library itself.
   
   In fact, it's a good security practice to publish the checksums of artifacts on a _different server_ than the server where the artifacts themselves are hosted: it's harder to compromise a library both on the repository __and__ the official website.
   
   In the example above, the checksum was published on the website for the JAR, but not the POM file.
   This is why it's usually easier to <<sec:bootstrapping-verification,let Gradle generate the checksums>> and verify by reviewing the generated file carefully.
   
   // Be explicit about where origin info lives, it's not visible without scrolling right
   In this example, not only could we check that the checksum was correct, but we could also find it on the official website, which is why we changed the value of the of `origin` attribute on the `sha512` element from `Generated by Gradle` to `PDFBox Official site`.
   Changing the `origin` gives users a sense of how trustworthy your build it.
   
   Interestingly, using `pdfbox` will require _much more_ than those 2 artifacts, because it will also bring in transitive dependencies.
   If the dependency verification file only included the checksums for the main artifacts you used, the build would fail with an error like this one:
   
   ----
   Execution failed for task ':compileJava'.
   > Dependency verification failed for configuration ':compileClasspath':
       - On artifact commons-logging-1.2.jar (commons-logging:commons-logging:1.2) in repository 'MavenRepo': checksum is missing from verification metadata.
       - On artifact commons-logging-1.2.pom (commons-logging:commons-logging:1.2) in repository 'MavenRepo': checksum is missing from verification metadata.
   ----
   
   What this indicates is that your build requires `commons-logging` when executing `compileJava`, however the verification file doesn't contain enough information for Gradle to verify the integrity of the dependencies, meaning you need to add the required information to the verification metadata file.
   
   See <<sec:troubleshooting-verification,troubleshooting dependency verification>> for more insights on what to do in this situation.
   
   === What checksums are verified?
   
   If a dependency verification metadata file declares more than one checksum for a dependency, Gradle will verify _all of them_ and fail if _any of them fails_.
   For example, the following configuration would check both the `md5` and `sha1` checksums:
   
   [source,xml]
   ----
   <component group="org.apache.pdfbox" name="pdfbox" version="2.0.17">
      <artifact name="pdfbox-2.0.17.jar">
         <md5 value="c713a8e252d0add65e9282b151adf6b4" origin="official site"/>
         <sha1 value="b5c8dff799bd967c70ccae75e6972327ae640d35" origin="official site" reason="Additional check for this artifact"/>
      </artifact>
   </component>
   ----
   
   There are multiple reasons why you'd like to do so:
   
   1. an official site doesn't publish _secure_ checksums (SHA-256, SHA-512) but publishes multiple insecure ones (MD5, SHA1).
   While it's easy to fake a MD5 checksum and hard but possible to fake a SHA1 checksum, it's harder to fake both of them for the same artifact.
   2. you might want to add generated checksums to the list above
   3. when _updating_ dependency verification file with more secure checksums, you don't want to accidentally erase checksums
   
   == Verifying dependency signatures
   
   In addition to <<sec:checksum-verification,checksums>>, Gradle supports verification of signatures.
   Signatures are used to assess the _provenance_ of a dependency (it tells who signed the artifacts, which usually corresponds to who produced it).
   
   As enabling signature verification usually means a higher level of security, you might want to replace checksum verification with signature verification.
   
   [WARNING]
   ====
   Signatures _can_ also be used to assess the integrity of a dependency similarly to checksums.
   Signatures are signatures of the _hash_ of artifacts, not artifacts themselves.
   This means that if the signature is done on an _unsafe hash_ (even SHA1), then you're not correctly assessing the _integrity_ of a file.
   For this reason, if you care about both, you need to add both signatures _and_ checksums to your verification metadata.
   ====
   
   However:
   
   - Gradle only supports verification of signatures published on remote repositories as ASCII-armored PGP files
   - Not all artifacts are published with signatures
   - A good signature doesn't mean that the signatory was legit
   
   As a consequence, signature verification will often be used alongside checksum verification.
   
   .About expired keys
   --
   It's very common to find artifacts which are signed with an expired key.
   This is not a problem for _verification_: key expiry is mostly used to avoid signing with a stolen key.
   If an artifact was signed before expiry, it's still valid.
   --
   
   === Enabling signature verification
   
   Because verifying signatures is more expensive (both I/O and CPU wise) and harder to check manually, it's not enabled by default.
   
   Enabling it requires you to change the configuration option in the `verification-metadata.xml` file:
   
   [source,xml]
   ----
   <?xml version="1.0" encoding="UTF-8"?>
   <verification-metadata xmlns="https://schema.gradle.org/dependency-verification"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="https://schema.gradle.org/dependency-verification https://schema.gradle.org/dependency-verification/dependency-verification-1.3.xsd">
      <configuration>
         <verify-signatures>true</verify-signatures>
      </configuration>
   </verification-metadata>
   ----
   
   == Understanding signature verification
   
   Once signature verification is enabled, for each artifact, Gradle will:
   
   * try to download the corresponding `.asc` file
   * if it's present
   ** automatically download the keys required to perform verification of the signature
   ** verify the artifact using the downloaded public keys
   ** if signature verification passes, perform additional requested checksum verification
   * if it's absent, fallback to checksum verification
   
   That is to say that Gradle's verification mechanism is much stronger if signature verification is enabled than just with checksum verification.
   In particular:
   
   - if an artifact is signed with multiple keys, all of them must pass validation or the build will fail
   - if an artifact passes verification, any additional checksum configured for the artifact _will also be checked_
   
   However, it's not because an artifact passes signature verification that you can trust it: you need to _trust the keys_.
   
   In practice, it means you need to list the keys that you trust for each artifact, which is done by adding a `pgp` entry instead of a `sha1` for example:
   
   [source,xml]
   ----
   <component group="com.github.javaparser" name="javaparser-core" version="3.6.11">
      <artifact name="javaparser-core-3.6.11.jar">
         <pgp value="8756c4f765c9ac3cb6b85d62379ce192d401ab61"/>
      </artifact>
   </component>
   ----
   
   [WARNING]
   ====
   For the `pgp` and `trusted-key` elements, Gradle _requires_ full fingerprint IDs (e.g. `b801e2f8ef035068ec1139cc29579f18fa8fd93b` instead of a long ID `29579f18fa8fd93b`).
   This minimizes the chance of a https://en.wikipedia.org/wiki/Collision_attack[collision attack].
   
   At the time, https://www.rfc-editor.org/rfc/rfc4880#section-12.2[V4 key fingerprints] are of 160-bit (40 characters) length. We accept longer keys to be future-proof in case a longer key fingerprint is introduced.
   
   In `ignore-key` elements, either fingerprints or long (64-bit) IDs can be used. A shorter ID can only result in a bigger range of exclusion, therefore, it's safe to use.
   ====
   
   This effectively means that you trust `com.github.javaparser:javaparser-core:3.6.11` if it's signed with the key `8756c4f765c9ac3cb6b85d62379ce192d401ab61`.
   
   Without this, the build would fail with this error:
   
   ----
   > Dependency verification failed for configuration ':compileClasspath':
       - On artifact javaparser-core-3.6.11.jar (com.github.javaparser:javaparser-core:3.6.11) in repository 'MavenRepo': Artifact was signed with key '8756c4f765c9ac3cb6b85d62379ce192d401ab61' (Bintray (by JFrog) <****>) and passed verification but the key isn't in your trusted keys list.
   ----
   
   [NOTE]
   ====
   The key IDs that Gradle shows in error messages are the key IDs found in the signature file it tries to verify.
   It doesn't mean that it's necessarily the keys that you should trust.
   In particular, if the signature is correct but done by a malicious entity, Gradle wouldn't tell you.
   ====
   
   === Trusting keys globally
   
   Signature verification has the advantage that it can make the configuration of dependency verification easier by not having to explicitly list all artifacts like for checksum verification only.
   In fact, it's common that the same key can be used to sign several artifacts.
   If this is the case, you can move the trusted key from the artifact level to the global configuration block:
   
   [source,xml]
   ----
   <?xml version="1.0" encoding="UTF-8"?>
   <verification-metadata xmlns="https://schema.gradle.org/dependency-verification"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="https://schema.gradle.org/dependency-verification https://schema.gradle.org/dependency-verification/dependency-verification-1.3.xsd">
      <configuration>
         <verify-metadata>true</verify-metadata>
         <verify-signatures>true</verify-signatures>
         <trusted-keys>
            <trusted-key id="8756c4f765c9ac3cb6b85d62379ce192d401ab61" group="com.github.javaparser"/>
         </trusted-keys>
      </configuration>
      <components/>
   </verification-metadata>
   ----
   
   The configuration above means that for any artifact belonging to the group `com.github.javaparser`, we trust it if it's signed with the `8756c4f765c9ac3cb6b85d62379ce192d401ab61` fingerprint.
   
   The `trusted-key` element works similarly to the <<sec:trusting-artifacts,trusted-artifact>> element:
   
   - `group`, the group of the artifact to trust
   - `name`, the name of the artifact to trust
   - `version`, the version of the artifact to trust
   - `file`, the name of the artifact _file_ to trust
   - `regex`, a boolean saying if the `group`, `name`, `version` and `file` attributes need to be interpreted as regular expressions (defaults to `false`)
   
   --
   You should be careful when trusting a key globally.
   
   Try to limit it to the appropriate groups or artifacts:
   
   - a valid key may have been used to sign artifact `A` which you trust
   - later on, the key is stolen and used to sign artifact `B`
   
   It means you can trust the key `A` for the first artifact, probably only up to the released version before the key was stolen, but not for `B`.
   
   Remember that anybody can put an arbitrary name when generating a PGP key, so never trust the key solely based on the key name.
   Verify if the key is listed at the official site.
   For example, Apache projects typically provide a KEYS.txt file that you can trust.
   --
   
   === Specifying key servers and ignoring keys
   
   Gradle will automatically download the public keys required to verify a signature.
   For this it uses a list of well known and trusted key servers (the list may change between Gradle versions, please refer to the implementation to figure out what servers are used by default).
   
   You can explicitly set the list of key servers that you want to use by adding them to the configuration:
   
   [source,xml]
   ----
   <?xml version="1.0" encoding="UTF-8"?>
   <verification-metadata xmlns="https://schema.gradle.org/dependency-verification"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="https://schema.gradle.org/dependency-verification https://schema.gradle.org/dependency-verification/dependency-verification-1.3.xsd">
      <configuration>
         <verify-metadata>true</verify-metadata>
         <verify-signatures>true</verify-signatures>
         <key-servers>
            <key-server uri="hkp://my-key-server.org"/>
            <key-server uri="https://my-other-key-server.org"/>
         </key-servers>
      </configuration>
   </verification-metadata>
   ----
   
   Despite this, it's possible that a key is not available:
   
   - because it wasn't published to a public key server
   - because it was lost
   
   In this case, you can ignore a key in the configuration block:
   
   [source,xml]
   ----
   <?xml version="1.0" encoding="UTF-8"?>
   <verification-metadata xmlns="https://schema.gradle.org/dependency-verification"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="https://schema.gradle.org/dependency-verification https://schema.gradle.org/dependency-verification/dependency-verification-1.3.xsd">
      <configuration>
         <verify-metadata>true</verify-metadata>
         <verify-signatures>true</verify-signatures>
         <ignored-keys>
            <ignored-key id="abcdef1234567890" reason="Key is not available in any key server"/>
         </ignored-keys>
      </configuration>
   </verification-metadata>
   ----
   
   As soon as a key is ignored, it will not be used for verification, even if the signature file mentions it.
   However, if the signature cannot be verified with at least one other key, Gradle will mandate that you provide a checksum.
   
   NOTE: If Gradle cannot download a key while bootstrapping, it will mark it as ignored.
   If you can find the key but Gradle does not, you can <<#sec:add-manual-keyring,manually add it>> to the keyring file.
   
   === Exporting keys for faster verification
   
   Gradle automatically downloads the required keys but this operation can be quite slow and requires everyone to download the keys.
   To avoid this, Gradle offers the ability to use a local keyring file containing the required public keys.
   Note that only public key packets and a single userId per key are stored and used.
   All other information (user attributes, signatures, etc.) is stripped from downloaded or exported keys.
   
   Gradle supports 2 different file formats for keyrings: a binary format (`.gpg` file) and a plain text format (`.keys`), also known as ASCII-armored format.
   
   There are pros and cons for each of the formats: the binary format is more compact and can be updated directly via GPG commands, but is completely opaque (binary).
   On the opposite, the ASCII-armored format is human-readable, can be easily updated by hand and makes it easier to do code reviews thanks to readable diffs.
   
   You can configure which file type would be used by adding the `keyring-format` configuration option:
   
   [source,xml]
   ----
   <?xml version="1.0" encoding="UTF-8"?>
   <verification-metadata xmlns="https://schema.gradle.org/dependency-verification"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="https://schema.gradle.org/dependency-verification https://schema.gradle.org/dependency-verification/dependency-verification-1.3.xsd">
      <configuration>
         <verify-metadata>true</verify-metadata>
         <verify-signatures>true</verify-signatures>
         <keyring-format>armored</keyring-format>
      </configuration>
   </verification-metadata>
   ----
   
   Available options for keyring format are `armored` and `binary`.
   
   Without `keyring-format`, if the `gradle/verification-keyring.gpg` or `gradle/verification-keyring.keys` file is present, Gradle will search for keys there in priority.
   The plain text file will be ignored if there's already a `.gpg` file (the binary version takes precedence).
   
   You can _ask Gradle to export all keys it used for verification of this build to the keyring_ during bootstrapping:
   
   ----
   ./gradlew --write-verification-metadata pgp,sha256 --export-keys
   ----
   
   Unless `keyring-format` is specified, this command will generate *both* the binary version and the ASCII-armored file.
   Use this option to choose the preferred format.
   You should only pick one for your project.
   
   It's a good idea to commit this file to VCS (as long as you trust your VCS).
   If you use git and use the binary version, make sure to make it treat this file as binary, by adding this to your `.gitattributes` file:
   
   ----
   *.gpg           binary
   ----
   
   You can also ask Gradle to export all trusted keys without updating the verification metadata file:
   
   ----
   ./gradlew --export-keys
   ----
   
   NOTE: This command will not report verification errors, only export keys.
   
   === Bootstrapping and signature verification
   
   WARNING: Signature verification bootstrapping takes an _optimistic point of view_ that signature verification is _enough_.
   Therefore, if you also care about _integrity_, you **must** first bootstrap using checksum verification, _then_ with signature verification.
   
   Similarly to bootstrapping for checksums, Gradle provides a convenience for bootstrapping a configuration file with signature verification enabled.
   For this, just add the `pgp` option to the list of verifications to generate.
   However, because there might be verification failures, missing keys or missing signature files, you **must** provide a fallback checksum verification algorithm:
   
   ----
   ./gradlew --write-verification-metadata pgp,sha256
   ----
   
   this means that Gradle will verify the signatures and fallback to SHA-256 checksums when there's a problem.
   
   When bootstrapping, Gradle performs _optimistic verification_ and therefore assumes a sane build environment.
   It will therefore:
   
   - automatically add the trusted keys as soon as verification passes
   - automatically add ignored keys for keys which couldn't be downloaded from public key servers.
   See <<#sec:add-manual-keyring,here>> how to manually add keys if needed
   - automatically generate checksums for artifacts without signatures or ignored keys
   
   If, for some reason, verification fails during the generation, Gradle will automatically generate an ignored key entry but warn you that you must absolutely check what happens.
   
   This situation is common as explained for <<sec:trusting-several-checksums,this section>>: a typical case is when the POM file for a dependency differs from one repository to the other (often in a non-meaningful way).
   
   In addition, Gradle will try to group keys automatically and generate the `trusted-keys` block which reduced the configuration file size as much as possible.
   
   == Forcing use of local keyrings only
   
   The local keyring files (`.gpg` or `.keys`) can be used to avoid reaching out to key servers whenever a key is required to verify an artifact.
   However, it may be that the local keyring doesn't contain a key, in which case Gradle would use the key servers to fetch the missing key.
   If the local keyring file isn't regularly updated, using <<sec:local-keyring,key export>>, then it may be that your CI builds, for example, would reach out to key servers too often (especially if you use disposable containers for builds).
   
   To avoid this, Gradle offers the ability to disallow use of key servers altogether: only the local keyring file would be used, and if a key is missing from this file, the build will fail.
   
   To enable this mode, you need to disable key servers in the configuration file:
   
   [source,xml]
   ----
   <?xml version="1.0" encoding="UTF-8"?>
   <verification-metadata xmlns="https://schema.gradle.org/dependency-verification"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="https://schema.gradle.org/dependency-verification https://schema.gradle.org/dependency-verification/dependency-verification-1.3.xsd">
      <configuration>
         <key-servers enabled="false"/>
         ...
      </configuration>
      ...
   </verification-metadata>
   ----
   
   NOTE: If you are asking Gradle to <<sec:bootstrapping-verification,generate a verification metadata file>> and that an existing verification metadata file sets `enabled` to `false`, then this flag will be ignored, so that potentially missing keys are downloaded.
   
   == Disabling verification or making it lenient
   
   Dependency verification can be expensive, or sometimes verification could get in the way of day to day development (because of frequent dependency upgrades, for example).
   
   Alternatively, you might want to enable verification on CI servers but not on local machines.
   
   Gradle actually provides 3 different verification modes:
   
   - `strict`, which is the default.
   Verification fails _as early as possible_, in order to avoid the use of compromised dependencies during the build.
   - `lenient`, which will run the build even if there are verification failures.
   The verification errors will be displayed during the build without causing a build failure.
   - `off` when verification is totally ignored.
   
   All those modes can be activated on the CLI using the `--dependency-verification` flag, for example:
   
   ----
   ./gradlew --dependency-verification lenient build
   ----
   
   Alternatively, you can set the `org.gradle.dependency.verification` system property, either on the CLI:
   
   ----
   ./gradlew -Dorg.gradle.dependency.verification=lenient build
   ----
   
   or in a `gradle.properties` file:
   
   ----
   org.gradle.dependency.verification=lenient
   ----
   
   == Disabling dependency verification for some configurations only
   
   In order to provide the strongest security level possible, dependency verification is enabled globally.
   This will ensure, for example, that you trust all the plugins you use.
   However, the plugins themselves may need to resolve additional dependencies that it doesn't make sense to ask the user to accept.
   For this purpose, Gradle provides an API which allows _disabling dependency verification on some specific configurations_.
   
   [WARNING]
   ====
   Disabling dependency verification, if you care about security, is not a good idea.
   This API mostly exist for cases where it doesn't make sense to check dependencies.
   However, in order to be on the safe side, Gradle will systematically print a warning whenever verification has been disabled for a specific configuration.
   ====
   
   As an example, a plugin may want to check if there are _newer_ versions of a library available and list those versions.
   It doesn't make sense, in this context, to ask the user to put the checksums of the POM files of the newer releases because by definition, they don't know about them.
   So the plugin might need to run its code _independently of the dependency verification configuration_.
   
   To do this, you need to call the `ResolutionStrategy#disableDependencyVerification` method:
   
   .Disabling dependency verification
   ====
   include::sample[dir="snippets/dependencyManagement/dependencyVerification-disablingVerification/kotlin",files="build.gradle.kts[tags=disabling-one-configuration]"]
   include::sample[dir="snippets/dependencyManagement/dependencyVerification-disablingVerification/groovy",files="build.gradle[tags=disabling-one-configuration]"]
   ====
   
   It's also possible to disable verification on detached configurations like in the following example:
   
   .Disabling dependency verification
   ====
   include::sample[dir="snippets/dependencyManagement/dependencyVerification-disablingVerification/kotlin",files="build.gradle.kts[tags=disabling-detached-configuration]"]
   include::sample[dir="snippets/dependencyManagement/dependencyVerification-disablingVerification/groovy",files="build.gradle[tags=disabling-detached-configuration]"]
   ====
   
   == Trusting some particular artifacts
   
   You might want to trust some artifacts more than others.
   For example, it's legitimate to think that artifacts produced in your company and found in your internal repository only are safe, but you want to check every external component.
   
   NOTE: This is a typical _company policy_.
   In practice, **nothing** prevents your internal repository from being compromised, so it's a good idea to check your internal artifacts too!
   
   For this purpose, Gradle offers a way to automatically trust some artifacts.
   You can trust all artifacts in a group by adding this to your configuration:
   
   [source,xml]
   ----
   <?xml version="1.0" encoding="UTF-8"?>
   <verification-metadata xmlns="https://schema.gradle.org/dependency-verification"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="https://schema.gradle.org/dependency-verification https://schema.gradle.org/dependency-verification/dependency-verification-1.3.xsd">
      <configuration>
         <trusted-artifacts>
            <trust group="com.mycompany" reason="We trust mycompany artifacts"/>
         </trusted-artifacts>
      </configuration>
   </verification-metadata>
   ----
   
   This means that all components which group is `com.mycompany` will automatically be trusted.
   Trusted means that Gradle will not perform any verification whatsoever.
   
   The `trust` element accepts those attributes:
   
   - `group`, the group of the artifact to trust
   - `name`, the name of the artifact to trust
   - `version`, the version of the artifact to trust
   - `file`, the name of the artifact _file_ to trust
   - `regex`, a boolean saying if the `group`, `name`, `version` and `file` attributes need to be interpreted as regular expressions (defaults to `false`)
   - `reason`, an optional reason, why matched artifacts are trusted
   
   In the example above it means that the trusted artifacts would be artifacts in `com.mycompany` but not `com.mycompany.other`.
   To trust all artifacts in `com.mycompany` and all subgroups, you can use:
   
   [source,xml]
   ----
   <?xml version="1.0" encoding="UTF-8"?>
   <verification-metadata xmlns="https://schema.gradle.org/dependency-verification"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="https://schema.gradle.org/dependency-verification https://schema.gradle.org/dependency-verification/dependency-verification-1.3.xsd">
      <configuration>
         <trusted-artifacts>
            <trust group="^com[.]mycompany($|([.].*))" regex="true" reason="We trust all mycompany artifacts"/>
         </trusted-artifacts>
      </configuration>
   </verification-metadata>
   ----
   
   == Trusting multiple checksums for an artifact
   
   It's quite common to have _different checksums for the same artifact_ in the wild.
   How is that possible?
   Despite progress, it's often the case that developers publish, for example, to Maven Central and another repository separately, using different builds.
   In general, this is not a problem but sometimes it means that the metadata files would be different (different timestamps, additional whitespaces, ...).
   Add to this that your build may use several repositories or repository mirrors and it makes it quite likely that a single build can "see" different metadata files for the same component!
   In general, it's not malicious (but you **must** verify that the artifact is actually correct), so Gradle lets you declare the additional artifact checksums.
   For example:
   
   [source,xml]
   ----
         <component group="org.apache" name="apache" version="13">
            <artifact name="apache-13.pom">
               <sha256 value="2fafa38abefe1b40283016f506ba9e844bfcf18713497284264166a5dbf4b95e">
                  <also-trust value="ff513db0361fd41237bef4784968bc15aae478d4ec0a9496f811072ccaf3841d"/>
               </sha256>
            </artifact>
         </component>
   ----
   
   You can have as many `also-trust` entries as needed, but in general you shouldn't have more than 2.
   
   == Skipping Javadocs and sources
   
   By default Gradle will verify _all_ downloaded artifacts, which includes Javadocs and sources.
   In general this is not a problem but you might face an issue with IDEs which automatically try to download them during import: if you didn't set the checksums for those too, importing would fail.
   
   To avoid this, you can configure Gradle to trust automatically all javadocs/sources:
   
   [source,xml]
   ----
   <trusted-artifacts>
      <trust file=".*-javadoc[.]jar" regex="true"/>
      <trust file=".*-sources[.]jar" regex="true"/>
   </trusted-artifacts>
   ----
   
   == Adding keys manually to the keyring
   
   === Adding keys to the ASCII-armored keyring
   
   The added key must be ASCII-armored formatted and can be simply added at the end of the file.
   If you already downloaded the key in the right format, you can simply append it to the file.
   
   Or you can amend an existing KEYS file by issuing the following commands:
   
   [source,bash]
   ----
   $ gpg --no-default-keyring --keyring /tmp/keyring.gpg --recv-keys 8756c4f765c9ac3cb6b85d62379ce192d401ab61
   
   gpg: keybox '/tmp/keyring.gpg' created
   gpg: key 379CE192D401AB61: public key "Bintray (by JFrog) <****>" imported
   gpg: Total number processed: 1
   gpg:               imported: 1
   
   # Write its ASCII-armored version
   $ gpg --keyring /tmp/keyring.gpg --export --armor 8756c4f765c9ac3cb6b85d62379ce192d401ab61 > gradle/verification-keyring.keys
   ----
   
   Once done, make sure to run <<#sec:verification-update,the generation command again>> so that the key is processed by Gradle.
   This will do the following:
   
   * Add a standard header to the key
   * Rewrite the key using Gradle's own format, which trims the key to the bare minimum
   * Move the key to its sorted location, keeping the file reproducible
   
   === Adding keys to the binary keyring
   
   You can add keys to the binary version using GPG, for example issuing the following commands (syntax may depend on the tool you use):
   
   [source,bash]
   ----
   $ gpg --no-default-keyring --keyring gradle/verification-keyring.gpg --recv-keys 8756c4f765c9ac3cb6b85d62379ce192d401ab61
   
   gpg: keybox 'gradle/verification-keyring.gpg' created
   gpg: key 379CE192D401AB61: public key "Bintray (by JFrog) <****>" imported
   gpg: Total number processed: 1
   gpg:               imported: 1
   
   $ gpg --no-default-keyring --keyring gradle/verification-keyring.gpg --recv-keys 6f538074ccebf35f28af9b066a0975f8b1127b83
   
   gpg: key 0729A0AFF8999A87: public key "Kotlin Release <****>" imported
   gpg: Total number processed: 1
   gpg:               imported: 1
   ----
   
   == Dealing with a verification failure
   
   Dependency verification can fail in different ways, this section explains how you should deal with the various cases.
   
   === Missing verification metadata
   
   The simplest failure you can have is when verification metadata is missing from the dependency verification file.
   This is the case for example if you use <<sec:checksum-verification,checksum verification>>, then you update a dependency and new versions of the dependency (and potentially its transitive dependencies) are brought in.
   
   Gradle will tell you what metadata is missing:
   
   ----
   Execution failed for task ':compileJava'.
   > Dependency verification failed for configuration ':compileClasspath':
       - On artifact commons-logging-1.2.jar (commons-logging:commons-logging:1.2) in repository 'MavenRepo': checksum is missing from verification metadata.
   ----
   
   - the missing module group is `commons-logging`, it's artifact name is `commons-logging` and its version is `1.2`.
   The corresponding artifact is `commons-logging-1.2.jar` so you need to add the following entry to the verification file:
   
   [source,xml]
   ----
   <component group="commons-logging" name="commons-logging" version="1.2">
      <artifact name="commons-logging-1.2.jar">
         <sha256 value="daddea1ea0be0f56978ab3006b8ac92834afeefbd9b7e4e6316fca57df0fa636" origin="official distribution"/>
      </artifact>
   </component>
   ----
   
   Alternatively, you can ask Gradle to generate the missing information by using the <<#sec:bootstrapping-verification,bootstrapping mechanism>>: existing information in the metadata file will be preserved, Gradle will only add the missing verification metadata.
   
   === Incorrect checksums
   
   A more problematic issue is when the actual checksum verification fails:
   
   ----
   Execution failed for task ':compileJava'.
   > Dependency verification failed for configuration ':compileClasspath':
       - On artifact commons-logging-1.2.jar (commons-logging:commons-logging:1.2) in repository 'MavenRepo': expected a 'sha256' checksum of '91f7a33096ea69bac2cbaf6d01feb934cac002c48d8c8cfa9c240b40f1ec21df' but was 'daddea1ea0be0f56978ab3006b8ac92834afeefbd9b7e4e6316fca57df0fa636'
   ----
   
   This time, Gradle tells you what dependency is at fault, what was the expected checksum (the one you declared in the verification metadata file) and the one which was actually computed during verification.
   
   Such a failure indicates that a **dependency may have been compromised**.
   At this stage, you **must** perform manual verification and check what happens.
   Several things can happen:
   
   * a dependency was tampered in the local dependency cache of Gradle.
   This is usually harmless: erase the file from the cache and Gradle would redownload the dependency.
   * a dependency is available in multiple sources with slightly different binaries (additional whitespace, ...)
   ** please inform the maintainers of the library that they have such an issue
   ** you can use <<#sec:trusting-several-checksums,`also-trust`>> to accept the additional checksums
   * the dependency was compromised
   ** immediately inform the maintainers of the library
   ** notify the repository maintainers of the compromised library
   
   Note that a variation of a compromised library is often _name squatting_, when a hacker would use GAV coordinates which _look legit_ but are actually different by one character, or _repository shadowing_, when a dependency with the official GAV coordinates is published in a malicious repository which comes first in your build.
   
   === Untrusted signatures
   
   If you have signature verification enabled, Gradle will perform verification of the signatures but will not trust them automatically:
   
   ----
   > Dependency verification failed for configuration ':compileClasspath':
       - On artifact javaparser-core-3.6.11.jar (com.github.javaparser:javaparser-core:3.6.11) in repository 'MavenRepo': Artifact was signed with key '379ce192d401ab61' (Bintray (by JFrog) <****>) and passed verification but the key isn't in your trusted keys list.
   ----
   
   In this case it means you need to check yourself if the key that was used for verification (and therefore the signature) can be trusted, in which case refer to <<#sec:understanding-signature-verification,this section of the documentation>> to figure out how to declare trusted keys.
   
   === Failed signature verification
   
   If Gradle fails to verify a signature, you will need to take action and verify artifacts manually because this **may indicate a compromised dependency**.
   
   If such a thing happens, Gradle will fail with:
   
   ----
   > Dependency verification failed for configuration ':compileClasspath':
       - On artifact javaparser-core-3.6.11.jar (com.github.javaparser:javaparser-core:3.6.11) in repository 'MavenRepo': Artifact was signed with key '379ce192d401ab61' (Bintray (by JFrog) <****>) but signature didn't match
   ----
   
   There are several options:
   
   1. signature was wrong in the first place, which happens frequently with <<#sec:trusting-several-checksums,dependencies published on different repositories>>.
   2. the signature is correct but the artifact has been compromised (either in the local dependency cache or remotely)
   
   The right approach here is to go to the official site of the dependency and see if they publish signatures for their artifacts.
   If they do, verify that the signature that Gradle downloaded matches the one published.
   
   If you have <<#sec:manual-checking-dependency,checked that the dependency is _not_ compromised>> and that it's "only" the signature which is wrong, you should declare an _artifact level key exclusion_:
   
   [source,xml]
   ----
      <components>
          <component group="com.github.javaparser" name="javaparser-core" version="3.6.11">
             <artifact name="javaparser-core-3.6.11.pom">
                <ignored-keys>
                   <ignored-key id="379ce192d401ab61" reason="internal repo has corrupted POM"/>
                </ignored-keys>
             </artifact>
          </component>
      </components>
   ----
   
   However, if you only do so, Gradle will still fail because all keys for this artifact will be ignored and you didn't provide a checksum:
   
   [source,xml]
   ----
      <components>
          <component group="com.github.javaparser" name="javaparser-core" version="3.6.11">
             <artifact name="javaparser-core-3.6.11.pom">
                <ignored-keys>
                   <ignored-key id="379ce192d401ab61" reason="internal repo has corrupted POM"/>
                </ignored-keys>
                <sha256 value="a2023504cfd611332177f96358b6f6db26e43d96e8ef4cff59b0f5a2bee3c1e1"/>
             </artifact>
          </component>
      </components>
   ----
   
   === Manual verification of a dependency
   
   You will likely face a dependency verification failure (either checksum verification or signature verification) and will need to figure out if the dependency has been compromised or not.
   
   In this section we give _an example_ how you can manually check if a dependency was compromised.
   
   For this we will take this example failure:
   
   ----
   > Dependency verification failed for configuration ':compileClasspath':
   - On artifact j2objc-annotations-1.1.jar (com.google.j2objc:j2objc-annotations:1.1) in repository 'MyCompany Mirror': Artifact was signed with key '29579f18fa8fd93b' but signature didn't match
   ----
   
   This error message gives us the GAV coordinates of the problematic dependency, as well as an indication of where the dependency was fetched from.
   Here, the dependency comes from `MyCompany Mirror`, which is a repository declared in our build.
   
   The first thing to do is therefore to download the artifact and its signature manually from the mirror:
   
   ----
   $ curl https://my-company-mirror.com/repo/com/google/j2objc/j2objc-annotations/1.1/j2objc-annotations-1.1.jar --output j2objc-annotations-1.1.jar
   $ curl https://my-company-mirror.com/repo/com/google/j2objc/j2objc-annotations/1.1/j2objc-annotations-1.1.jar.asc --output j2objc-annotations-1.1.jar.asc
   ----
   
   Then we can use the key information provided in the error message to import the key locally:
   
   ----
   $ gpg --recv-keys B801E2F8EF035068EC1139CC29579F18FA8FD93B
   ----
   
   And perform verification:
   
   ----
   $ gpg --verify j2objc-annotations-1.1.jar.asc
   gpg: assuming signed data in 'j2objc-annotations-1.1.jar'
   gpg: Signature made Thu 19 Jan 2017 12:06:51 AM CET
   gpg:                using RSA key 29579F18FA8FD93B
   gpg: BAD signature from "Tom Ball <****>" [unknown]
   ----
   
   What this tells us is that the problem is _not_ on the local machine: the repository _already contains a bad signature_.
   
   The next step is to do the same by downloading what is actually on Maven Central:
   
   ----
   $ curl https://my-company-mirror.com/repo/com/google/j2objc/j2objc-annotations/1.1/j2objc-annotations-1.1.jar  --output central-j2objc-annotations-1.1.jar
   $ curl https://my-company-mirror.com/repo/com/google/j2objc/j2objc-annotations/1/1/j2objc-annotations-1.1.jar.asc  --output central-j2objc-annotations-1.1.jar.asc
   ----
   
   And we can now check the signature again:
   
   ----
   $ gpg --verify central-j2objc-annotations-1.1.jar.asc
   
   gpg: assuming signed data in 'central-j2objc-annotations-1.1.jar'
   gpg: Signature made Thu 19 Jan 2017 12:06:51 AM CET
   gpg:                using RSA key 29579F18FA8FD93B
   gpg: Good signature from "Tom Ball <****>" [unknown]
   gpg: WARNING: This key is not certified with a trusted signature!
   gpg:          There is no indication that the signature belongs to the owner.
   Primary key fingerprint: B801 E2F8 EF03 5068 EC11  39CC 2957 9F18 FA8F D93B
   ----
   
   This indicates that the dependency is _valid_ on Maven Central.
   At this stage, we already know that the problem lives in the mirror, it _may_ have been compromised, but we need to verify.
   
   A good idea is to compare the 2 artifacts, which you can do with a tool like https://try.diffoscope.org/[diffoscope].
   
   We then figure out that the intent wasn't malicious but that somehow a build has been overwritten with a newer version (the version in Central is newer than the one in our repository).
   
   In this case, you can decide to:
   
   - ignore the signature for this artifact and trust the different possible checksums (both for the old artifact and the new version)
   - or cleanup your mirror so that it contains the same version as in Maven Central
   
   It's worth noting that if you choose to delete the version from your repository, you will _also_ need to remove it from the local Gradle cache.
   
   This is facilitated by the fact the error message tells you were the file is located:
   
   ----
   > Dependency verification failed for configuration ':compileClasspath':
       - On artifact j2objc-annotations-1.1.jar (com.google.j2objc:j2objc-annotations:1.1) in repository 'MyCompany Mirror': Artifact was signed with key '29579f18fa8fd93b' but signature didn't match
   
     This can indicate that a dependency has been compromised. Please carefully verify the signatures and checksums.
   
     For your information here are the path to the files which failed verification:
       - $<<directory_layout.adoc#dir:gradle_user_home,GRADLE_USER_HOME>>/caches/modules-2/files-2.1/com.google.j2objc/j2objc-annotations/1.1/976d8d30bebc251db406f2bdb3eb01962b5685b3/j2objc-annotations-1.1.jar (signature: GRADLE_USER_HOME/caches/modules-2/files-2.1/com.google.j2objc/j2objc-annotations/1.1/82e922e14f57d522de465fd144ec26eb7da44501/j2objc-annotations-1.1.jar.asc)
   
     GRADLE_USER_HOME = /home/jiraya/.gradle
   ----
   
   You can safely delete the artifact file as Gradle would automatically re-download it:
   
   ----
   rm -rf ~/.gradle/caches/modules-2/files-2.1/com.google.j2objc/j2objc-annotations/1.1
   ----
   
   == Cleaning up the verification file
   
   If you do nothing, the dependency verification metadata will grow over time as you add new dependencies or change versions: Gradle will not automatically remove _unused_ entries from this file.
   The reason is that there's no way for Gradle to know upfront if a dependency will effectively be used during the build or not.
   
   As a consequence, adding dependencies or changing dependency version can easily lead to more entries in the file, while leaving unnecessary entries out there.
   
   One option to cleanup the file is to move the existing `verification-metadata.xml` file to a different location and call Gradle with the <<#sec:verification-dry-mode,`--dry-run` mode>>: while not perfect (it will not notice dependencies only resolved at configuration time), it generates _a new file_ that you can compare with the existing one.
   
   We need to move the existing file because both the bootstrapping mode and the dry-run mode are incremental: they copy information from the existing metadata verification file (in particular, trusted keys).
   
   == Refreshing missing keys
   
   Gradle caches missing keys for 24 hours, meaning it will not attempt to re-download the missing keys for 24 hours after failing.
   
   If you want to retry immediately, you can run with the `--refresh-keys` CLI flag:
   
   ----
   ./gradlew build --refresh-keys
   ----
   
   See <<#sec:add-manual-keyring,here>> how to manually add keys if Gradle keeps failing to download them.

/Section: 游릭 Declaring Versions
=================================


/docs/userguide/dep-man/02-declaring-dependency-versions/single_versions.adoc
=============================================================================

.. code-block::

   = Declaring Versions and Ranges
   
   The simplest version declaration is a _simple string_ representing the version to use.
   Gradle supports different ways of declaring a version string:
   
   * An exact version: e.g. `1.3`, `1.3.0-beta3`, `1.0-20150201.131010-1`
   * A Maven-style version range: e.g. `[1.0,)`, `[1.1, 2.0)`, `(1.2, 1.5]`
   ** The `[` and `]` symbols indicate an inclusive bound; `(` and `)` indicate an exclusive bound.
   ** When the upper or lower bound is missing, the range has no upper or lower bound.
   ** The symbol `]` can be used instead of `(` for an exclusive lower bound, and `[` instead of `)` for exclusive upper bound. e.g `]1.0, 2.0[`
   ** An upper bound exclude acts as a prefix exclude.
   This means that `[1.0, 2.0[` will also exclude all versions starting with `2.0` that are smaller than `2.0`.
   For example versions like `2.0-dev1` or `2.0-SNAPSHOT` are no longer included in the range.
   * A _prefix_ version range: e.g. `1.+`, `1.3.+`
   ** Only versions exactly matching the portion before the `+` are included.
   ** The range `+` on its own will include any version.
   * A `latest-status` version: e.g. `latest.integration`, `latest.release`
   ** Will match the highest versioned module with the specified status. See link:{javadocPath}#[ComponentMetadata.getStatus()].
   * A Maven `SNAPSHOT` version identifier: e.g. `1.0-SNAPSHOT`, `1.4.9-beta1-SNAPSHOT`
   
   == Version ordering
   
   Versions have an implicit ordering. Version ordering is used to:
   
   * Determine if a particular version is included in a range.
   * Determine which version is 'newest' when performing conflict resolution (watch out though, conflict resolution uses
   <<dependency_resolution#sec:base-version-comparison,"base versions">>).
   
   Versions are ordered based on the following rules:
   
   * Each version is split into it's constituent "parts":
   ** The characters `[. - _ +]` are used to separate the different "parts" of a version.
   ** Any part that contains both digits and letters is split into separate parts for each: `1a1 == 1.a.1`
   ** Only the parts of a version are compared. The actual separator characters are not significant: `1.a.1 == 1-a+1 == 1.a-1 == 1a1` (watch out though, in the context of conflict resolution there are <<dependency_resolution#sec:base-version-comparison,exceptions to this rule>>).
   * The equivalent parts of 2 versions are compared using the following rules:
   ** If both parts are numeric, the highest numeric value is **higher**: `1.1` < `1.2`
   ** If one part is numeric, it is considered **higher** than the non-numeric part: `1.a` < `1.1`
   ** If both are non-numeric, the parts are compared **alphabetically**, in a **case-sensitive** manner: `1.A` < `1.B` < `1.a` < `1.b`
   ** A version with an extra numeric part is considered **higher** than a version without (even when it's zero): `1.1` < `1.1.0`
   ** A version with an extra non-numeric part is considered **lower** than a version without: `1.1.a` < `1.1`
   * Certain non-numeric parts have special meaning for the purposes of ordering:
   ** `dev` is consider **lower** than any other non-numeric part: `1.0-dev` < `1.0-ALPHA` < `1.0-alpha` < `1.0-rc`.
   ** The strings `rc`, `snapshot`, `final`, `ga`, `release` and `sp` are considered **higher** than any other string part (sorted in this order): `1.0-zeta` < `1.0-rc` < `1.0-snapshot` < `1.0-final` < `1.0-ga` < `1.0-release` < `1.0-sp` < `1.0`.
   ** These special values are **NOT case sensitive**, as opposed to regular string parts and they do not depend on the separator used around them: `1.0-RC-1` == `1.0.rc.1`
   
   == Simple version declaration semantics
   
   When you declare a version using the short-hand notation, for example:
   
   .A simple declaration
   ====
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-concreteVersion/kotlin",files="build.gradle.kts[tags=required-version]"]
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-concreteVersion/groovy",files="build.gradle[tags=required-version]"]
   ====
   
   Then the version is considered a <<rich_versions.adoc#sec:required-version,required version>> which means that it should _minimally_ be `1.7.15` but can be upgraded by the engine (optimistic upgrade).
   
   There is, however, a shorthand notation for <<rich_versions.adoc#sec:strict-version,strict versions>>, using the `!!` notation:
   
   .Shorthand notation for strict dependencies
   ====
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-concreteVersion/kotlin",files="build.gradle.kts[tags=strict-shorthand]"]
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-concreteVersion/groovy",files="build.gradle[tags=strict-shorthand]"]
   ====
   
   A strict version _cannot be upgraded_ and overrides whatever transitive dependencies originating from this dependency provide.
   It is recommended to use ranges for strict versions.
   
   The notation `[1.7, 1.8[!!1.7.25` above is equivalent to:
   
   * strictly `[1.7, 1.8[`
   * prefer `1.7.25`
   
   which means that the engine **must** select a version between 1.7 (included) and 1.8 (excluded), and that if no other component in the graph needs a different version, it should _prefer_ `1.7.25`.
   
   == Declaring a dependency without version
   
   A recommended practice for larger projects is to declare dependencies without versions and use <<dependency_constraints.adoc#sec:adding-constraints-transitive-deps,dependency constraints>> for version declaration.
   The advantage is that dependency constraints allow you to manage versions of all dependencies, including transitive ones, in one place.
   
   .Declaring a dependency without version
   ====
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-withoutVersion/kotlin",files="build.gradle.kts[tags=dependencies-without-version]"]
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-withoutVersion/groovy",files="build.gradle[tags=dependencies-without-version]"]
   ====

/docs/userguide/dep-man/02-declaring-dependency-versions/rich_versions.adoc
===========================================================================

.. code-block::

   = Declaring Rich Versions
   
   Gradle supports a rich model for declaring versions, which allows to combine different level of version information.
   The terms and their meaning are explained below, from the strongest to the weakest:
   
   `strictly`::
   Any version not matched by this version notation will be excluded.
   This is the strongest version declaration.
   On a declared dependency, a `strictly` can downgrade a version.
   When on a transitive dependency, it will cause dependency resolution to fail if no version acceptable by this clause can be selected.
   See <<dependency_downgrade_and_exclude.adoc#sec:enforcing_dependency_version,overriding dependency version>> for details.
   This term supports dynamic versions.
   +
   When defined, this overrides any previous `require` declaration and clears previous `reject`.
   
   `require`::
   Implies that the selected version cannot be lower than what `require` accepts but could be higher through conflict resolution, even if higher has an exclusive higher bound.
   This is what a direct dependency translates to.
   This term supports dynamic versions.
   +
   When defined, this overrides any previous `strictly` declaration and clears previous `reject`.
   
   `prefer`::
   This is a very soft version declaration.
   It applies only if there is no stronger non dynamic opinion on a version for the module.
   This term does not support dynamic versions.
   +
   Definition can complement `strictly` or `require`.
   +
   When defined, this overrides any previous `prefer` declaration and clears previous `reject`.
   
   There is also an additional term outside of the level hierarchy:
   
   `reject`::
   Declares that specific version(s) are not accepted for the module.
   This will cause dependency resolution to fail if the only versions selectable are also rejected.
   This term supports dynamic versions.
   
   The following table illustrates a number of use cases and how to combine the different terms for rich version declaration:
   
   .Rich version use cases
   [%header%autowidth,compact]
   |===
   | Which version(s) of this dependency are acceptable? | `strictly` | `require` | `prefer` | `rejects` | Selection result
   
   | Tested with version `1.5`, believe all future versions should work.
   |
   | 1.5
   |
   |
   | Any version starting from `1.5`, equivalent of `org:foo:1.5`. An upgrade to `2.4` is accepted.
   
   | Tested with `1.5`, soft constraint upgrades according to semantic versioning.
   |
   | [1.0, 2.0[
   | 1.5
   |
   | Any version between `1.0` and `2.0`, `1.5` if nobody else cares. An upgrade to `2.4` is accepted. +
   游
   
   | Tested with `1.5`, but follows semantic versioning.
   | [1.0, 2.0[
   |
   | 1.5
   |
   | Any version between `1.0` and `2.0` (exclusive), `1.5` if nobody else cares. +
   Overwrites versions from transitive dependencies. +
   游
   
   | Same as above, with `1.4` known broken.
   | [1.0, 2.0[
   |
   | 1.5
   | 1.4
   | Any version between `1.0` and `2.0` (exclusive) except for `1.4`, `1.5` if nobody else cares. +
   Overwrites versions from transitive dependencies. +
   游
   
   | No opinion, works with `1.5`.
   |
   |
   | 1.5
   |
   | `1.5` if no other opinion, any otherwise.
   
   | No opinion, prefer latest release.
   |
   |
   | `latest.release`
   |
   | The latest release at build time. +
   游
   
   | On the edge, latest release, no downgrade.
   |
   | `latest.release`
   |
   |
   | The latest release at build time. +
   游
   
   | No other version than 1.5.
   | 1.5
   |
   |
   |
   | 1.5, or failure if another `strict` or higher `require` constraint disagrees. +
   Overwrites versions from transitive dependencies.
   
   | `1.5` or a patch version of it exclusively.
   | [1.5,1.6[
   |
   |
   |
   | Latest `1.5.x` patch release, or failure if another `strict` or higher `require` constraint disagrees. +
   Overwrites versions from transitive dependencies. +
   游
   |===
   
   Lines annotated with a lock (游) indicate that leveraging <<dependency_locking.adoc#dependency-locking,dependency locking>> makes sense in this context.
   Another concept that relates with rich version declaration is the ability to publish <<publishing_maven.adoc#publishing_maven:resolved_dependencies,resolved versions>> instead of declared ones.
   
   
   Using `strictly`, especially for a library, must be a well thought process as it has an impact on downstream consumers.
   At the same time, used correctly, it will help consumers understand what combination of libraries do not work together in their context.
   See <<dependency_downgrade_and_exclude.adoc#sec:enforcing_dependency_version,overriding dependency version>> for more information.
   
   
   [NOTE]
   ====
   Rich version information will be preserved in the Gradle Module Metadata format.
   However conversion to Ivy or Maven metadata formats will be lossy.
   The highest level will be published, that is `strictly` or `require` over `prefer`.
   In addition, any `reject` will be ignored.
   ====
   
   Rich version declaration is accessed through the `version` DSL method on a dependency or constraint declaration which gives access to link:{javadocPath}#[MutableVersionConstraint].
   
   .Rich version declaration
   ====
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-concreteVersion/kotlin",files="build.gradle.kts[tags=rich-version]"]
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-concreteVersion/groovy",files="build.gradle[tags=rich-version]"]
   ====

/docs/userguide/dep-man/02-declaring-dependency-versions/dynamic_versions.adoc
==============================================================================

.. code-block::

   = Handling versions which change over time
   
   There are many situations when you want to use the latest version of a particular module dependency, or the latest in a range of versions.
   This can be a requirement during development, or you may be developing a library that is designed to work with a range of dependency versions.
   You can easily depend on these constantly changing dependencies by using a _dynamic version_.
   A <<dynamic_versions.adoc#sub:declaring_dependency_with_dynamic_version,dynamic version>> can be either a version range (e.g. `2.+`) or it can be a placeholder for the latest version available e.g. `latest.integration`.
   
   Alternatively, the module you request can change over time even for the same version, a so-called <<dynamic_versions.adoc#sub:declaring_dependency_with_changing_version,changing version>>.
   An example of this type of _changing module_ is a Maven `SNAPSHOT` module, which always points at the latest artifact published.
   In other words, a standard Maven snapshot is a module that is continually evolving, it is a "changing module".
   
   CAUTION: Using dynamic versions and changing modules can lead to unreproducible builds. As new versions of a particular module are published, its API may become incompatible with your source code. Use this feature with caution!
   
   == Declaring a dynamic version
   
   Projects might adopt a more aggressive approach for consuming dependencies to modules.
   For example you might want to always integrate the latest version of a dependency to consume cutting edge features at any given time.
   A _dynamic version_ allows for resolving the latest version or the latest version of a version range for a given module.
   
   CAUTION: Using dynamic versions in a build bears the risk of potentially breaking it. As soon as a new version of the dependency is released that contains an incompatible API change your source code might stop compiling.
   
   .Declaring a dependency with a dynamic version
   ====
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-dynamicVersion/kotlin",files="build.gradle.kts[tags=dependencies]"]
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-dynamicVersion/groovy",files="build.gradle[tags=dependencies]"]
   ====
   
   A link:https://scans.gradle.com/[build scan] can effectively visualize dynamic dependency versions and their respective, selected versions.
   
   .Dynamic dependencies in build scan
   image::dependency-management-dynamic-dependency-build-scan.png[]
   
   By default, Gradle caches dynamic versions of dependencies for 24 hours. Within this time frame, Gradle does not try to resolve newer versions from the declared repositories.
   The <<#sec:controlling-dynamic-version-caching,threshold can be configured>> as needed for example if you want to resolve new versions earlier.
   
   == Declaring a changing version
   
   A team might decide to implement a series of features before releasing a new version of the application or library. A common strategy to allow consumers to integrate an unfinished version of their artifacts early and often is to release a module with a so-called _changing version_.
   A changing version indicates that the feature set is still under active development and hasn't released a stable version for general availability yet.
   
   In Maven repositories, changing versions are commonly referred to as link:https://maven.apache.org/guides/getting-started/index.html#what-is-a-snapshot-version[snapshot versions].
   Snapshot versions contain the suffix `-SNAPSHOT`.
   The following example demonstrates how to declare a snapshot version on the Spring dependency.
   
   .Declaring a dependency with a changing version
   ====
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-changingVersion/kotlin",files="build.gradle.kts[tags=dependencies]"]
   include::sample[dir="snippets/dependencyManagement/declaringDependencies-changingVersion/groovy",files="build.gradle[tags=dependencies]"]
   ====
   
   By default, Gradle caches changing versions of dependencies for 24 hours.
   Within this time frame, Gradle does not try to resolve newer versions from the declared repositories. The <<#sec:controlling-dynamic-version-caching,threshold can be configured>> as needed for example if you want to resolve new snapshot versions earlier.
   
   Gradle is flexible enough to treat any version as changing version e.g. if you wanted to model snapshot behavior for an Ivy module.
   All you need to do is to set the property link:{javadocPath}#[ExternalModuleDependency.setChanging(boolean)] to `true`.
   
   == Controlling dynamic version caching
   
   By default, Gradle caches dynamic versions and changing modules for 24 hours. During that time frame Gradle does not contact any of the declared, remote repositories for new versions. If you want Gradle to check the remote repository more frequently or with every execution of your build, then you will need to change the time to live (TTL) threshold.
   
   NOTE: Using a short TTL threshold for dynamic or changing versions may result in longer build times due to the increased number of HTTP(s) calls.
   
   You can override the default cache modes using <<#sec:controlling_dependency_caching_command_line,command line options>>. You can also <<#sec:controlling_dependency_caching_programmatically,change the cache expiry times in your build programmatically>> using the resolution strategy.
   
   == Controlling dependency caching programmatically
   
   You can fine-tune certain aspects of caching programmatically using the link:{javadocPath}#[ResolutionStrategy] for a configuration. The programmatic approach is useful if you would like to change the settings permanently.
   
   By default, Gradle caches dynamic versions for 24 hours. To change how long Gradle will cache the resolved version for a dynamic version, use:
   
   .Dynamic version cache control
   ====
   include::sample[dir="snippets/dependencyManagement/troubleshooting-cache-dynamic/kotlin",files="build.gradle.kts[tags=dynamic-version-cache-control]"]
   include::sample[dir="snippets/dependencyManagement/troubleshooting-cache-dynamic/groovy",files="build.gradle[tags=dynamic-version-cache-control]"]
   ====
   
   By default, Gradle caches changing modules for 24 hours. To change how long Gradle will cache the meta-data and artifacts for a changing module, use:
   
   .Changing module cache control
   ====
   include::sample[dir="snippets/dependencyManagement/troubleshooting-cache-changing/kotlin",files="build.gradle.kts[tags=changing-module-cache-control]"]
   include::sample[dir="snippets/dependencyManagement/troubleshooting-cache-changing/groovy",files="build.gradle[tags=changing-module-cache-control]"]
   ====
   
   == Controlling dependency caching from the command line
   
   === Avoiding network access with offline mode
   
   The `--offline` command line switch tells Gradle to always use dependency modules from the cache, regardless if they are due to be checked again. When running with offline, Gradle will never attempt to access the network to perform dependency resolution. If required modules are not present in the dependency cache, build execution will fail.
   
   === Refreshing dependencies
   
   You can control the behavior of dependency caching for a distinct build invocation from the command line.
   Command line options are helpful for making a selective, ad-hoc choice for a single execution of the build.
   
   
   At times, the Gradle Dependency Cache can become out of sync with the actual state of the configured repositories.
   Perhaps a repository was initially misconfigured, or perhaps a "non-changing" module was published incorrectly.
   To refresh all dependencies in the dependency cache, use the `--refresh-dependencies` option on the command line.
   
   The `--refresh-dependencies` option tells Gradle to ignore all cached entries for resolved modules and artifacts.
   A fresh resolve will be performed against all configured repositories, with dynamic versions recalculated, modules refreshed, and artifacts downloaded.
   However, where possible Gradle will check if the previously downloaded artifacts are valid before downloading again.
   This is done by comparing published SHA1 values in the repository with the SHA1 values for existing downloaded artifacts.
   
   - new versions of dynamic dependencies
   - new versions of changing modules (modules which use the same version string but can have different contents)
   
   --
   Refreshing dependencies will cause Gradle to invalidate its listing caches.
   However:
   
   - it will perform HTTP HEAD requests on metadata files but _will not re-download them_ if they are identical
   - it will perform HTTP HEAD requests on artifact files but _will not re-download them_ if they are identical
   
   In other words, refreshing dependencies _only_ has an impact if you actually use dynamic dependencies _or_ that you have changing dependencies that you were not aware of (in which case it is your responsibility to declare them correctly to Gradle as changing dependencies).
   
   It's a common misconception to think that using `--refresh-dependencies` will force download of dependencies.
   This is **not** the case: Gradle will only perform what is strictly required to refresh the dynamic dependencies.
   This _may_ involve downloading new listing or metadata files, or even artifacts, but if nothing changed, the impact is minimal.
   --
   
   == Using component selection rules
   
   Component selection rules may influence which component instance should be selected when multiple versions are available that match a version selector.
   Rules are applied against every available version and allow the version to be explicitly rejected by rule.
   This allows Gradle to ignore any component instance that does not satisfy conditions set by the rule.
   Examples include:
   
   * For a dynamic version like `1.+` certain versions may be explicitly rejected from selection.
   * For a static version like `1.4` an instance may be rejected based on extra component metadata such as the Ivy branch attribute, allowing an instance from a subsequent repository to be used.
   
   Rules are configured via the link:{groovyDslPath}#[ComponentSelectionRules] object.
   Each rule configured will be called with a link:{groovyDslPath}#[ComponentSelection] object as an argument which contains information about the candidate version being considered.
   Calling link:{groovyDslPath}#[ComponentSelection.reject(java.lang.String)] causes the given candidate version to be explicitly rejected, in which case the candidate will not be considered for the selector.
   
   The following example shows a rule that disallows a particular version of a module but allows the dynamic version to choose the next best candidate.
   
   .Component selection rule
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-selectionRule/kotlin",files="build.gradle.kts[tags=reject-version-1-1]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-selectionRule/groovy",files="build.gradle[tags=reject-version-1-1]"]
   ====
   
   Note that version selection is applied starting with the highest version first.
   The version selected will be the first version found that all component selection rules accept.
   A version is considered accepted if no rule explicitly rejects it.
   
   Similarly, rules can be targeted at specific modules.
   Modules must be specified in the form of `group:module`.
   
   .Component selection rule with module target
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-selectionRule/kotlin",files="build.gradle.kts[tags=targeted-component-selection]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-selectionRule/groovy",files="build.gradle[tags=targeted-component-selection]"]
   ====
   
   Component selection rules can also consider component metadata when selecting a version.
   Possible additional metadata that can be considered are link:{javadocPath}#[ComponentMetadata] and link:{javadocPath}#[IvyModuleDescriptor].
   Note that this extra information may not always be available and thus should be checked for `null` values.
   
   .Component selection rule with metadata
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-selectionRule/kotlin",files="build.gradle.kts[tags=component-selection-with-metadata]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-selectionRule/groovy",files="build.gradle[tags=component-selection-with-metadata]"]
   ====
   
   Note that a link:{groovyDslPath}#[ComponentSelection] argument is _always_ required as parameter when declaring a component selection rule.

/docs/userguide/dep-man/02-declaring-dependency-versions/dependency_locking.adoc
================================================================================

.. code-block::

   = Locking dependency versions
   
   Use of dynamic dependency versions (e.g. `1.+` or `[1.0,2.0)`) makes builds non-deterministic.
   This causes builds to break without any obvious change, and worse, can be caused by a transitive dependency that the build author has no control over.
   
   To achieve https://reproducible-builds.org/[reproducible builds], it is necessary to _lock_ versions of dependencies and transitive dependencies such that a build with the same inputs will always resolve the same module versions.
   This is called _dependency locking_.
   
   It enables, amongst others, the following scenarios:
   
   * Companies dealing with multi repositories no longer need to rely on `-SNAPSHOT` or changing dependencies,
   which sometimes result in cascading failures when a dependency introduces a bug or incompatibility.
   Now dependencies can be declared against major or minor version range, enabling to test with the latest versions on CI while leveraging locking for stable developer builds.
   * Teams that want to always use the latest of their dependencies can use dynamic versions, locking their dependencies only for releases.
   The release tag will contain the lock states, allowing that build to be fully reproducible when bug fixes need to be developed.
   
   Combined with <<publishing_maven.adoc#publishing_maven:resolved_dependencies,publishing resolved versions>>, you can also replace the declared dynamic version part at publication time.
   Consumers will instead see the versions that your release resolved.
   
   Locking is enabled per <<declaring_dependencies.adoc#sec:what-are-dependency-configurations,dependency configuration>>.
   Once enabled, you must create an initial lock state.
   It will cause Gradle to verify that resolution results do not change, resulting in the same selected dependencies even if newer versions are produced.
   Modifications to your build that would impact the resolved set of dependencies will cause it to fail.
   This makes sure that changes, either in published dependencies or build definitions, do not alter resolution without adapting the lock state.
   
   [NOTE]
   ====
   Dependency locking makes sense only with <<dynamic_versions.adoc#sub:declaring_dependency_with_dynamic_version,dynamic versions>>.
   It will have no impact on <<dynamic_versions.adoc#sub:declaring_dependency_with_changing_version,changing versions>> (like `-SNAPSHOT`) whose coordinates remain the same, though the content may change.
   Gradle will even emit a warning when persisting lock state and changing dependencies are present in the resolution result.
   ====
   
   == Enabling locking on configurations
   
   Locking of a configuration happens through the link:{groovyDslPath}#[ResolutionStrategy]:
   
   .Locking a specific configuration
   ====
   include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingSingleFilePerProject/kotlin",files="build.gradle.kts[tags=locking-single]"]
   include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingSingleFilePerProject/groovy",files="build.gradle[tags=locking-single]"]
   ====
   
   NOTE: Only configurations that can be resolved will have lock state attached to them.
   Applying locking on non resolvable-configurations is simply a no-op.
   
   Or the following, as a way to lock all configurations:
   
   .Locking all configurations
   ====
   include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingAllConfigurations/kotlin",files="build.gradle.kts[tags=locking-all]"]
   include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingAllConfigurations/groovy",files="build.gradle[tags=locking-all]"]
   ====
   
   NOTE: The above will lock all _project_ configurations, but not the _buildscript_ ones.
   
   You can also disable locking on a specific configuration.
   This can be useful if a plugin configured locking on all configurations but you happen to add one that should not be locked.
   
   .Unlocking a specific configuration
   ====
   include::sample[dir="snippets/dependencyManagement/dependencyLocking-unlockingSingleConfiguration/kotlin",files="build.gradle.kts[tags=locking-one]"]
   include::sample[dir="snippets/dependencyManagement/dependencyLocking-unlockingSingleConfiguration/groovy",files="build.gradle[tags=locking-one]"]
   ====
   
   === Locking buildscript classpath configuration
   
   If you apply plugins to your build, you may want to leverage dependency locking there as well.
   In order to lock the <<plugins.adoc#sec:applying_plugins_buildscript,`classpath` configuration>> used for script plugins, do the following:
   
   .Locking buildscript classpath configuration
   ====
   include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingClasspathConfiguration/kotlin",files="build.gradle.kts[tags=locking-classpath]"]
   include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingClasspathConfiguration/groovy",files="build.gradle[tags=locking-classpath]"]
   ====
   
   == Generating and updating dependency locks
   
   In order to generate or update lock state, you specify the `--write-locks` command line argument in addition to the normal tasks that would trigger configurations to be resolved.
   This will cause the creation of lock state for each resolved configuration in that build execution.
   Note that if lock state existed previously, it is overwritten.
   
   NOTE: Gradle will not write lock state to disk if the build fails.
   This prevents persisting possibly invalid state.
   
   === Lock all configurations in one build execution
   
   When locking multiple configurations, you may want to lock them all at once, during a single build execution.
   
   For this, you have two options:
   
   * Run `gradle dependencies --write-locks`.
   This will effectively lock all resolvable configurations that have locking enabled.
   Note that in a multi project setup, `dependencies` only is executed on _one_ project, the root one in this case.
   * Declare a custom task that resolves all configurations. This does not work for Android projects.
   
   .Resolving all configurations
   ====
   include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingAllConfigurations/kotlin",files="build.gradle.kts[tags=resolve-all]"]
   include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingAllConfigurations/groovy",files="build.gradle[tags=resolve-all]"]
   ====
   
   That second option, with proper selection of configurations, can be the only option in the native world, where not all configurations can be resolved on a single platform.
   
   == Lock state location and format
   
   Lock state will be preserved in a file located at the root of the project or subproject directory.
   Each file is named `gradle.lockfile`.
   The one exception to this rule is for the lock file for the <<plugins.adoc#sec:applying_plugins_buildscript,buildscript itself>>.
   In that case the file will be named `buildscript-gradle.lockfile`.
   
   The lockfile will have the following content:
   
   [listing]
   .gradle.lockfile
   ----
   include::{snippetsPath}/dependencyManagement/dependencyLocking-lockingSingleFilePerProject/groovy/gradle.lockfile[]
   ----
   
   * Each line still represents a single dependency in the `group:artifact:version` notation
   * It then lists all configurations that contain the given dependency
   * Module and configurations are ordered alphabetically, to ease diffs
   * The last line of the file lists all empty configurations, that is configurations known to have no dependencies
   
   which matches the following dependency declaration:
   
   .Dynamic dependency declaration
   ====
   include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingSingleFilePerProject/kotlin",files="build.gradle.kts[tags=locking-explicit]"]
   include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingSingleFilePerProject/groovy",files="build.gradle[tags=locking-explicit]"]
   ====
   
   === Migrating from the lockfile per configuration format
   
   If your project uses the legacy lock file format of a file per locked configuration, follow these instructions to migrate to the new format:
   
   * Follow the documentation for <<#lock_all_configurations_in_one_build_execution, writing>> or <<#selectively_updating_lock_state_entries, updating>> dependency lock state.
   * Upon writing the single lock file per project, Gradle will also delete all lock files per configuration for which the state was transferred.
   
   NOTE: Migration can be done one configuration at a time.
   Gradle will keep sourcing the lock state from the per configuration files as long as there is no information for that configuration in the single lock file.
   
   === Configuring the per project lock file name and location
   
   When using the single lock file per project, you can configure its name and location.
   The main reason for providing this is to enable having a file name that is determined by some project properties, effectively allowing a single project to store different lock state for different execution contexts.
   One trivial example in the JVM ecosystem is the Scala version that is often found in artifact coordinates.
   
   .Changing the lock file name
   ====
   include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingSingleFilePerProject/kotlin",files="build.gradle.kts[tags=locking-file-name]"]
   include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingSingleFilePerProject/groovy",files="build.gradle[tags=locking-file-name]"]
   ====
   
   == Running a build with lock state present
   
   The moment a build needs to resolve a configuration that has locking enabled and it finds a matching lock state,
   it will use it to verify that the given configuration still resolves the same versions.
   
   A successful build indicates that the same dependencies are used as stored in the lock state, regardless if new versions matching the dynamic selector have been produced.
   
   The complete validation is as follows:
   
   * Existing entries in the lock state must be matched in the build
   ** A version mismatch or missing resolved module causes a build failure
   * Resolution result must not contain extra dependencies compared to the lock state
   
   === Fine tuning dependency locking behaviour with lock mode
   
   While the default lock mode behaves as described above, two other modes are available:
   
   Strict mode::
   In this mode, in addition to the validations above, dependency locking will fail if a configuration marked as _locked_ does not have lock state associated with it.
   
   Lenient mode::
   In this mode, dependency locking will still pin dynamic versions but otherwise changes to the dependency resolution are no longer errors.
   
   The lock mode can be controlled from the `dependencyLocking` block as shown below:
   
   .Setting the lock mode
   ====
   include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockModeSelection/kotlin",files="build.gradle.kts[tags=lock-mode]"]
   include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockModeSelection/groovy",files="build.gradle[tags=lock-mode]"]
   ====
   
   == Selectively updating lock state entries
   
   In order to update only specific modules of a configuration, you can use the `--update-locks` command line flag.
   It takes a comma (`,`) separated list of module notations.
   In this mode, the existing lock state is still used as input to resolution, filtering out the modules targeted by the update.
   
   ----
   仇 gradle classes --update-locks org.apache.commons:commons-lang3,org.slf4j:slf4j-api
   ----
   
   Wildcards, indicated with `*`, can be used in the group or module name. They can be the only character or appear at the end of the group or module respectively.
   The following wildcard notation examples are valid:
   
   * `org.apache.commons:*`: will let all modules belonging to group `org.apache.commons` update
   * `*:guava`: will let all modules named `guava`, whatever their group, update
   * `org.springframework.spring*:spring*`: will let all modules having their group starting with `org.springframework.spring` and name starting with `spring` update
   
   NOTE: The resolution may cause other module versions to update, as dictated by the Gradle resolution rules.
   
   == Disabling dependency locking
   
   . Make sure that the configuration for which you no longer want locking is not configured with locking.
   . Next time you update the save lock state, Gradle will automatically clean up all stale lock state from it.
   
   Gradle needs to resolve a configuration, no longer marked as locked, to detect that associated lock state can be dropped.
   
   == Ignoring specific dependencies from the lock state
   
   Dependency locking can be used in cases where reproducibility is not the main goal.
   As a build author, you may want to have different frequency of dependency version updates, based on their origin for example.
   In that case, it might be convenient to ignore some dependencies because you always want to use the latest version for those.
   An example is the internal dependencies in an organization which should always use the latest version as opposed to third party dependencies which have a different upgrade cycle.
   
   WARNING: This feature can break reproducibility and should be used with caution.
   There are scenarios that are better served with leveraging  <<#fine_tuning_dependency_locking_behaviour_with_lock_mode,different lock modes>> or <<#configuring_the_per_project_lock_file_name_and_location,using different names for lock files>>.
   
   You can configure ignored dependencies in the `dependencyLocking` project extension:
   
   .Ignoring dependencies for the lock state
   ====
   include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingSingleFilePerProject/kotlin",files="build.gradle.kts[tags=ignore-dependencies]"]
   include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingSingleFilePerProject/groovy",files="build.gradle[tags=ignore-dependencies]"]
   ====
   
   The notation is a `<group>:<name>` dependency notation, where `\*` can be used as a trailing wildcard.
   See <<#selectively_updating_lock_state_entries,the description>> on updating lock files for more details.
   Note that the value `*:*` is not accepted as it is equivalent to disabling locking.
   
   Ignoring dependencies will have the following effects:
   
   * An ignored dependency applies to all locked configurations. The setting is project scoped.
   * Ignoring a dependency does not mean lock state ignores its transitive dependencies.
   * There is no validation that an ignored dependency is present in any configuration resolution.
   * If the dependency is present in lock state, loading it will filter out the dependency.
   * If the dependency is present in the resolution result, it will be ignored when validating that resolution matches the lock state.
   * Finally, if the dependency is present in the resolution result and the lock state is persisted, it will be absent from the written lock state.
   
   == Locking limitations
   
   * Locking cannot yet be applied to source dependencies.
   
   == Nebula locking plugin
   
   This feature is inspired by the https://github.com/nebula-plugins/gradle-dependency-lock-plugin[Nebula Gradle dependency lock plugin].
   

/Section: 游릭 Controlling Transitives
======================================


/docs/userguide/dep-man/03-controlling-transitive-dependencies/dependency_constraints.adoc
==========================================================================================

.. code-block::

   = Upgrading versions of transitive dependencies
   
   == Direct dependencies vs dependency constraints
   
   A component may have two different kinds of dependencies:
   
   - direct dependencies are _directly required by the component_.
   A direct dependency is also referred to as a _first level dependency_.
   For example, if your project source code requires Guava, Guava should be declared as _direct dependency_.
   - transitive dependencies are dependencies that your component needs, but only because another dependency needs them.
   
   It's quite common that issues with dependency management are about _transitive dependencies_.
   Often developers incorrectly fix transitive dependency issues by adding _direct dependencies_.
   To avoid this, Gradle provides the concept of _dependency constraints_.
   
   == Adding constraints on transitive dependencies
   
   Dependency constraints allow you to define the version or the version range of both dependencies declared in the build script and transitive dependencies.
   It is the preferred method to express constraints that should be applied to all dependencies of a configuration.
   When Gradle attempts to resolve a dependency to a module version, all <<rich_versions.adoc#rich-version-constraints,dependency declarations with version>>, all transitive dependencies and all dependency constraints for that module are taken into consideration.
   The highest version that matches all conditions is selected.
   If no such version is found, Gradle fails with an error showing the conflicting declarations.
   If this happens you can adjust your dependencies or dependency constraints declarations, or make other adjustments to the transitive dependencies if needed.
   Similar to dependency declarations, dependency constraint declarations are <<declaring_dependencies.adoc#sec:what-are-dependency-configurations,scoped by configurations>> and can therefore be selectively defined for parts of a build.
   If a dependency constraint influenced the resolution result, any type of <<resolution_rules.adoc#sec:dependency_resolve_rules,dependency resolve rules>> may still be applied afterwards.
   
   .Define dependency constraints
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-versionsWithConstraints/kotlin",files="build.gradle.kts[tags=dependency-constraints]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-versionsWithConstraints/groovy",files="build.gradle[tags=dependency-constraints]"]
   ====
   
   In the example, all versions are omitted from the dependency declaration.
   Instead, the versions are defined in the constraints block.
   The version definition for `commons-codec:1.11` is only taken into account if `commons-codec` is brought in as transitive dependency, since `commons-codec` is not defined as dependency in the project.
   Otherwise, the constraint has no effect.
   Dependency constraints can also define a <<rich_versions.adoc#rich-version-constraints,rich version constraint>> and support <<rich_versions.adoc#sec:strict-version,strict versions>> to enforce a version even if it contradicts with the version defined by a transitive dependency (e.g. if the version needs to be downgraded).
   
   NOTE: Dependency constraints are only published when using <<publishing_gradle_module_metadata.adoc#sec:understanding-gradle-module-md,Gradle Module Metadata>>.
   This means that currently they are only fully supported if Gradle is used for publishing and consuming (i.e. they are 'lost' when consuming modules with Maven or Ivy).
   
   Dependency constraints themselves can also be added transitively.

/docs/userguide/dep-man/03-controlling-transitive-dependencies/dependency_downgrade_and_exclude.adoc
====================================================================================================

.. code-block::

   = Downgrading versions and excluding dependencies
   
   == Overriding transitive dependency versions
   
   Gradle resolves any dependency version conflicts by selecting the latest version found in the dependency graph.
   Some projects might need to divert from the default behavior and enforce an earlier version of a dependency e.g. if the source code of the project depends on an older API of a dependency than some of the external libraries.
   
   [WARNING]
   ====
   Forcing a version of a dependency requires a conscious decision.
   Changing the version of a transitive dependency might lead to runtime errors if external libraries do not properly function without them.
   Consider upgrading your source code to use a newer version of the library as an alternative approach.
   ====
   
   In general, forcing dependencies is done to downgrade a dependency.
   There might be different use cases for downgrading:
   
   - a bug was discovered in the latest release
   - your code depends on a lower version which is not binary compatible
   - your code doesn't depend on the code paths which need a higher version of a dependency
   
   In all situations, this is best expressed saying that your code _strictly depends on_ a version of a transitive.
   Using <<rich_versions.adoc#sec:strict-version,strict versions>>, you will effectively depend on the version you declare, even if a transitive dependency says otherwise.
   
   [NOTE]
   ====
   Strict dependencies are to some extent similar to Maven's _nearest first_ strategy, but there are subtle differences:
   
   - _strict dependencies_ don't suffer an ordering problem: they are applied transitively to the subgraph, and it doesn't matter in which order dependencies are declared.
   - conflicting strict dependencies will trigger a build failure that you have to resolve
   - strict dependencies can be used with rich versions, meaning that <<#sec:strict-version-consequences,it's better to express the requirement in terms of a _strict range_ combined with a single _preferred version_>>.
   ====
   
   Let's say a project uses the link:https://hc.apache.org/httpcomponents-client-ga/[HttpClient library] for performing HTTP calls. HttpClient pulls in link:https://commons.apache.org/proper/commons-codec/[Commons Codec] as transitive dependency with version 1.10.
   However, the production source code of the project requires an API from Commons Codec 1.9 which is not available in 1.10 anymore.
   A dependency version can be enforced by declaring it as strict it in the build script:
   
   .Setting a strict version
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-forceForDependency/kotlin",files="build.gradle.kts[tags=force-using-strictly]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-forceForDependency/groovy",files="build.gradle[tags=force-using-strictly]"]
   ====
   
   === Consequences of using strict versions
   
   Using a strict version must be carefully considered, in particular by library authors.
   As the _producer_, a strict version will effectively behave like a _force_: the version declaration takes precedence over whatever is found in the transitive dependency graph.
   In particular, a _strict version_ will override any other _strict version_ on the same module found transitively.
   
   However, for consumers, strict versions are still considered globally during graph resolution and _may trigger an error_ if the consumer disagrees.
   
   For example, imagine that your project `B` _strictly_ depends on `C:1.0`.
   Now, a consumer, `A`, depends on both `B` and `C:1.1`.
   
   Then this would trigger a resolution error because `A` says it needs `C:1.1` but `B`, _within its subgraph_, strictly needs `1.0`.
   This means that if you choose a _single version_ in a strict constraint, then the version can _no longer be upgraded_, unless the consumer also sets a strict version constraint on the same module.
   
   In the example above, `A` would have to say it _strictly depends on 1.1_.
   
   For this reason, a good practice is that if you use _strict versions_, you should express them in terms of ranges and a preferred version within this range.
   For example, `B` might say, instead of `strictly 1.0`, that it _strictly depends_ on the `[1.0, 2.0[` range, but _prefers_ `1.0`.
   Then if a consumer chooses 1.1 (or any other version in the range), the build will _no longer fail_ (constraints are resolved).
   
   === Forced dependencies vs strict dependencies
   
   If the project requires a specific version of a dependency at the configuration-level this can be achieved by calling the method link:{groovyDslPath}#[]++)[ResolutionStrategy.force(java.lang.Object++[]++)].
   
   .Enforcing a dependency version on the configuration-level
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-forceForConfiguration/kotlin",files="build.gradle.kts[tags=force-per-configuration]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-forceForConfiguration/groovy",files="build.gradle[tags=force-per-configuration]"]
   ====
   
   == Excluding transitive dependencies
   
   While the previous section showed how you can enforce a certain version of a transitive dependency, this section covers _excludes_ as a way to remove a transitive dependency completely.
   
   [WARNING]
   ====
   Similar to forcing a version of a dependency, excluding a dependency completely requires a conscious decision.
   Excluding a transitive dependency might lead to runtime errors if external libraries do not properly function without them.
   If you use excludes, make sure that you do not utilise any code path requiring the excluded dependency by sufficient test coverage.
   ====
   
   Transitive dependencies can be excluded on the level of a declared dependency.
   Exclusions are spelled out as a key/value pair via the attributes `group` and/or `module` as shown in the example below.
   For more information, refer to link:{javadocPath}#[ModuleDependency.exclude(java.util.Map)].
   
   .Excluding a transitive dependency for a particular dependency declaration
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-excludeForDependency/kotlin",files="build.gradle.kts[tags=exclude-transitive-dependencies-1]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-excludeForDependency/groovy",files="build.gradle[tags=exclude-transitive-dependencies-1]"]
   ====
   
   In this example, we add a dependency to `commons-beanutils` but exclude the transitive dependency `commons-collections`.
   In our code, shown below, we only use one method from the beanutils library, `PropertyUtils.setSimpleProperty()`.
   Using this method for existing setters does not require any functionality from `commons-collections` as we verified through test coverage.
   
   .Using a utility from the beanutils library
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-excludeForDependency/groovy",files="src/main/java/Main.java"]
   ====
   
   Effectively, we are expressing that we only use a _subset_ of the library, which does not require the `commons-collection` library.
   This can be seen as implicitly defining a <<feature_variants.adoc#feature_variants,feature variant>> that has not been explicitly declared by `commons-beanutils` itself.
   However, the risk of breaking an untested code path increased by doing this.
   
   For example, here we use the `setSimpleProperty()` method to modify properties defined by setters in the `Person` class, which works fine.
   If we would attempt to set a property not existing on the class, we _should_ get an error like `Unknown property on class Person`.
   However, because the error handling path uses a class from `commons-collections`, the error we now get is `NoClassDefFoundError: org/apache/commons/collections/FastHashMap`.
   So if our code would be more dynamic, and we would forget to cover the error case sufficiently, consumers of our library might be confronted with unexpected errors.
   
   This is only an example to illustrate potential pitfalls.
   In practice, larger libraries or frameworks can bring in a huge set of dependencies.
   If those libraries fail to declare features separately and can only be consumed in a "all or nothing" fashion, excludes can be a valid method to reduce the library to the feature set actually required.
   
   On the upside, Gradle's exclude handling is, in contrast to Maven, taking the whole dependency graph into account.
   So if there are multiple dependencies on a library, excludes are only exercised if all dependencies agree on them.
   For example, if we add `opencsv` as another dependency to our project above, which also depends on `commons-beanutils`, `commons-collection` is no longer excluded as `opencsv` itself does *not* exclude it.
   
   
   .Excludes only apply if all dependency declarations agree on an exclude
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-excludeForDependency/kotlin",files="build.gradle.kts[tags=exclude-transitive-dependencies-2]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-excludeForDependency/groovy",files="build.gradle[tags=exclude-transitive-dependencies-2]"]
   ====
   
   If we still want to have `commons-collections` excluded, because our combined usage of `commons-beanutils` and `opencsv` does not need it, we need to exclude it from the transitive dependencies of `opencsv` as well.
   
   .Excluding a transitive dependency for multiple dependency declaration
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-excludeForDependency/kotlin",files="build.gradle.kts[tags=exclude-transitive-dependencies-3]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-excludeForDependency/groovy",files="build.gradle[tags=exclude-transitive-dependencies-3]"]
   ====
   
   Historically, excludes were also used as a band aid to fix other issues not supported by some dependency management systems.
   Gradle however, offers a variety of features that might be better suited to solve a certain use case.
   You may consider to look into the following features:
   
   - <<#sec:enforcing_dependency_version,Update>> or <<#sec:enforcing_dependency_version,downgrade>> dependency versions:
     If versions of dependencies clash, it is usually better to adjust the version through a dependency constraint, instead of attempting to exclude the dependency with the undesired version.
   - <<component_metadata_rules.adoc#sec:component_metadata_rules,Component Metadata Rules>>:
     If a library's metadata is clearly wrong, for example if it includes a compile time dependency which is never needed at compile time, a possible solution is to remove the dependency in a component metadata rule.
     By this, you tell Gradle that a dependency between two modules is never needed  i.e. the metadata was wrong  and therefore should *never* be considered.
     If you are developing a library, you have to be aware that this information is not published, and so sometimes an _exclude_ can be the better alternative.
   - <<dependency_capability_conflict.adoc#sec:handling-mutually-exclusive-deps,Resolving mutually exclusive dependency conflicts>>:
     Another situation that you often see solved by excludes is that two dependencies cannot be used together because they represent two implementations of the same thing (the same <<dependency_capability_conflict.adoc#sub:capabilities,capability>>).
     Some popular examples are clashing logging API implementations (like `log4j` and `log4j-over-slf4j`) or modules that have different coordinates in different versions (like `com.google.collections` and `guava`).
     In these cases, if this information is not known to Gradle, it is recommended to add the missing capability information via component metadata rules as described in the <<dependency_capability_conflict.adoc#sub:declaring-component-capabilities,declaring component capabilities>> section.
     Even if you are developing a library, and your consumers will have to deal with resolving the conflict again, it is often the right solution to leave the decision to the final consumers of libraries.
     I.e. you as a library author should not have to decide which logging implementation your consumers use in the end.

/docs/userguide/dep-man/03-controlling-transitive-dependencies/platforms.adoc
=============================================================================

.. code-block::

   = Sharing dependency versions between projects
   
   == Central declaration of dependencies
   
   === Using a version catalog
   
   A _version catalog_ is a list of dependencies, represented as dependency coordinates, that a user can pick from when declaring dependencies in a build script.
   
   For example, instead of declaring a dependency using a string notation, the dependency coordinates can be picked from a _version catalog_:
   
   .Using a library declared in a version catalog
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/kotlin",files="build.gradle.kts[tags=simple_dependency_use]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/groovy",files="build.gradle[tags=simple_dependency_use]"]
   ====
   
   In this context, `libs` is a catalog and `groovy` represents a dependency available in this catalog. A version catalog provides a number of advantages over declaring the dependencies directly in build scripts:
   
   - For each catalog, Gradle generates _type-safe accessors_ so that you can easily add dependencies with autocompletion in the IDE.
   - Each catalog is visible to all projects of a build. It is a central place to declare a version of a dependency and to make sure that a change to that version applies to every subproject.
   - Catalogs can declare <<platforms.adoc#sec:dependency-bundles, dependency bundles>>, which are "groups of dependencies" that are commonly used together.
   - Catalogs can separate the group and name of a dependency from its actual version and use <<platforms.adoc#sec:common-version-numbers, version references>> instead, making it possible to share a version declaration between multiple dependencies.
   
   Adding a dependency using the `libs.someLib` notation works exactly like if you had hardcoded the group, artifact and version directly in the build script.
   
   WARNING: A dependency catalog doesn't enforce the version of a dependency: like a regular dependency notation, it declares the requested version or a <<rich_versions.adoc#rich-version-constraints,rich version>>.
   That version is not necessarily the version that is selected during <<dependency_resolution#understanding_dependency_resolution,conflict resolution>>.
   
   === Declaring a version catalog
   
   Version catalogs can be declared in the `settings.gradle(.kts)` file.
   In the example above, in order to make `groovy` available via the `libs` catalog, we need to associate an alias with GAV (group, artifact, version) coordinates:
   
   .Declaring a version catalog
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/kotlin",files="settings.gradle.kts[tags=simple_catalog]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/groovy",files="settings.gradle[tags=simple_catalog]"]
   ====
   
   ==== Aliases and their mapping to type safe accessors
   
   Aliases must consist of a series of identifiers separated by a dash (`-`, recommended), an underscore (`_`) or a dot (`.`).
   Identifiers themselves must consist of ascii characters, preferably lowercase, eventually followed by numbers.
   
   For example:
   
   - `guava` is a valid alias
   - `groovy-core` is a valid alias
   - `commons-lang3` is a valid alias
   - `androidx.awesome.lib` is also a valid alias
   - but `this.#is.not!`
   
   Then type safe accessors are generated for _each subgroup_.
   For example, given the following aliases in a version catalog named `libs`:
   
   `guava`, `groovy-core`, `groovy-xml`, `groovy-json`, `androidx.awesome.lib`
   
   We would generate the following type-safe accessors:
   
   - `libs.guava`
   - `libs.groovy.core`
   - `libs.groovy.xml`
   - `libs.groovy.json`
   - `libs.androidx.awesome.lib`
   
   Where the `libs` prefix comes from the version catalog name.
   
   In case you want to avoid the generation of a subgroup accessor, we recommend relying on case to differentiate.
   For example the aliases `groovyCore`, `groovyJson` and `groovyXml` would be mapped to the `libs.groovyCore`, `libs.groovyJson` and `libs.groovyXml` accessors respectively.
   
   When declaring aliases, it's worth noting that any of the `-`, `_` and `.` characters can be used as separators, but the generated catalog will have all normalized to `.`:
   for example `foo-bar` as an alias is converted to `foo.bar` automatically.
   
   --
   Some keywords are reserved, so they cannot be used as an alias. Next words cannot be used as an alias:
   
   - extensions
   - class
   - convention
   
   Additional to that next words cannot be used as a first subgroup of an alias for dependencies (for bundles, versions and plugins this restriction doesn't apply):
   
   - bundles
   - versions
   - plugins
   
   So for example for dependencies an alias `versions-dependency` is not valid, but `versionsDependency` or `dependency-versions` are valid.
   --
   
   ==== Dependencies with same version numbers
   
   In the first example in <<platforms.adoc#sub:version-catalog-declaration, declaring a version catalog>>, we can see that we declare 3 aliases for various components of the `groovy` library and that all of them share the same version number.
   
   Instead of repeating the same version number, we can declare a version and reference it:
   
   .Declaring versions separately from libraries
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/kotlin",files="settings.gradle.kts[tags=catalog_with_versions]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/groovy",files="settings.gradle[tags=catalog_with_versions]"]
   ====
   
   Versions declared separately are _also_ available via type-safe accessors, making them usable for more use cases than dependency versions, in particular for tooling:
   
   .Using a version declared in a version catalog
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/kotlin",files="build.gradle.kts[tags=use_version]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/groovy",files="build.gradle[tags=use_version]"]
   ====
   
   If the alias of a declared version is also a prefix of some more specific alias, as in `libs.versions.zinc` and `libs.versions.zinc.apiinfo`, then
   the value of the more generic version is available via link:{javadocPath}#[`asProvider()`] on the type-safe accessor:
   
   .Using a version from a version catalog when there are more specific aliases
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-asprovider/kotlin",files="build.gradle.kts[tags=use_version_asprovider]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-asprovider/groovy",files="build.gradle[tags=use_version_asprovider]"]
   ====
   
   Dependencies declared in a catalog are exposed to build scripts via an extension corresponding to their name.
   In the example above, because the catalog declared in settings is named `libs`, the extension is available via the name `libs` in all build scripts of the current build.
   Declaring dependencies using the following notation...
   
   .Dependency notation correspondance
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/kotlin",files="build.gradle.kts[tags=use_catalog]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/groovy",files="build.gradle[tags=use_catalog]"]
   ====
   
   ...has **exactly the same** effect as writing:
   
   .Dependency notation correspondance
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/kotlin",files="build.gradle.kts[tags=use_catalog_equiv]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/groovy",files="build.gradle[tags=use_catalog_equiv]"]
   ====
   
   Versions declared in the catalog are <<rich_versions.adoc#rich-version-constraints,rich versions>>.
   Please refer to the link:{javadocPath}#[version catalog builder API] for the full version declaration support documentation.
   
   ==== Dependency bundles
   
   Because it's frequent that some dependencies are systematically used together in different projects, a version catalog offers the concept of a "dependency bundle".
   A bundle is basically an alias for several dependencies.
   For example, instead of declaring 3 individual dependencies like above, you could write:
   
   .Using a dependency bundle
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/kotlin",files="build.gradle.kts[tags=use_dependency_bundle]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/groovy",files="build.gradle[tags=use_dependency_bundle]"]
   ====
   
   The bundle named `groovy` needs to be declared in the catalog:
   
   .Declaring a dependency bundle
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/kotlin",files="settings.gradle.kts[tags=catalog_with_bundle]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/groovy",files="settings.gradle[tags=catalog_with_bundle]"]
   ====
   
   The semantics are again equivalent: adding a single bundle is equivalent to adding all dependencies which are part of the bundle individually.
   
   ==== Plugins
   
   In addition to libraries, version catalog supports declaring plugin versions.
   While libraries are represented by their group, artifact and version coordinates, Gradle plugins are identified by their id and version only.
   Therefore, they need to be declared separately:
   
   WARNING: You cannot use a plugin declared in a version catalog in your settings file or settings plugin (because catalogs are defined in settings themselves, it would be a chicken and egg problem).
   
   .Declaring a plugin version
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/kotlin",files="settings.gradle.kts[tags=catalog_with_plugin]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/groovy",files="settings.gradle[tags=catalog_with_plugin]"]
   ====
   
   Then the plugin is accessible in the `plugins` block and can be consumed in any project of the build using:
   
   .Using a plugin declared in a catalog
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/kotlin",files="build.gradle.kts[tags=use_plugin]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/groovy",files="build.gradle[tags=use_plugin]"]
   ====
   
   ==== Using multiple catalogs
   
   Aside from the conventional `libs` catalog, you can declare any number of catalogs through the `Settings` API.
   This allows you to separate dependency declarations in multiple sources in a way that makes sense for your projects.
   
   .Using a custom catalog
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/kotlin",files="settings.gradle.kts[tags=extra_catalog]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/groovy",files="settings.gradle[tags=extra_catalog]"]
   ====
   
   [NOTE]
   ====
   Each catalog will generate an extension applied to all projects for accessing its content.
   As such it makes sense to reduce the chance of collisions by picking a name that reduces the potential conflicts.
   As an example, one option is to pick a name that ends with `Libs`.
   ====
   
   === The libs.versions.toml file
   
   In addition to the settings API above, Gradle offers a conventional file to declare a catalog.
   If a `libs.versions.toml` file is found in the `gradle` subdirectory of the root build, then a catalog will be automatically declared with the contents of this file.
   
   --
   Declaring a `libs.versions.toml` file doesn't make it the single source of truth for dependencies: it's a conventional location where dependencies can be declared.
   As soon as you start using catalogs, it's strongly recommended to declare all your dependencies in a catalog and not hardcode group/artifact/version strings in build scripts.
   Be aware that it may happen that plugins add dependencies, which are dependencies defined outside of this file.
   
   Just like `src/main/java` is a convention to find the Java sources, which doesn't prevent additional source directories to be declared (either in a build script or a plugin), the presence of the `libs.versions.toml` file doesn't prevent the declaration of dependencies elsewhere.
   
   The presence of this file does, however, suggest that most dependencies, if not all, will be declared in this file.
   Therefore, updating a dependency version, for most users, should only consists of changing a line in this file.
   --
   
   By default, the `libs.versions.toml` file will be an input to the `libs` catalog.
   It is possible to change the name of the default catalog, for example if you already have an extension with the same name:
   
   .Changing the default extension name
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-toml/kotlin",files="settings.gradle.kts[tags=change_default_extension_name]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-toml/groovy",files="settings.gradle[tags=change_default_extension_name]"]
   ====
   
   ==== The version catalog TOML file format
   
   The https://toml.io/[TOML] file consists of 4 major sections:
   
   - the `[versions]` section is used to declare versions which can be referenced by dependencies
   - the `[libraries]` section is used to declare the aliases to coordinates
   - the `[bundles]` section is used to declare dependency bundles
   - the `[plugins]` section is used to declare plugins
   
   For example:
   
   .The libs.versions.toml file
   ----
   include::{snippetsPath}/dependencyManagement/catalogs-toml/groovy/gradle/libs.versions.toml[]
   ----
   
   Versions can be declared either as a single string, in which case they are interpreted as a _required_ version, or as a <<rich_versions.adoc#rich-version-constraints,rich versions>>:
   
   ```
   [versions]
   my-lib = { strictly = "[1.0, 2.0[", prefer = "1.2" }
   ```
   
   Supported members of a version declaration are:
   
   - `require`: the <<rich_versions.adoc#sec:required-version,required version>>
   - `strictly`: the <<rich_versions.adoc#sec:strict-version,strict version>>
   - `prefer`: the <<rich_versions.adoc#sec:preferred-version,preferred version>>
   - `reject`: the list of <<rich_versions.adoc#sec:rejected-version,rejected versions>>
   - `rejectAll`: a boolean to reject all <<rich_versions.adoc#sec:rejected-version,versions>>
   
   Dependency declaration can either be declared as a simple string, in which case they are interpreted as `group:artifact:version` coordinates, or separating the version declaration from the group and name:
   
   NOTE: For aliases, the rules described in the section <<platforms.adoc#sub:mapping-aliases-to-accessors, aliases and their mapping to type safe accessors>> apply as well.
   
   .Different dependency notations
   ----
   include::{snippetsPath}/dependencyManagement/catalogs-toml/groovy/gradle/test-libs.versions.toml[]
   ----
   
   In case you want to reference a version declared in the `[versions]` section, you should use the `version.ref` property:
   
   ```
   [versions]
   some = "1.4"
   
   [libraries]
   my-lib = { group = "com.mycompany", name="mylib", version.ref="some" }
   ```
   
   --
   The TOML file format is very lenient and lets you write "dotted" properties as shortcuts to full object declarations.
   For example, this:
   
   ```
   a.b.c="d"
   ```
   
   is equivalent to:
   
   ```
   a.b = { c = "d" }
   ```
   
   or
   
   ```
   a = { b = { c = "d" } }
   ```
   
   See the https://toml.io[TOML specification] for details.
   --
   
   === Type unsafe API
   
   Version catalogs can be accessed through a type unsafe API. This API is available in situations where generated accessors are not. It is accessed through the version catalog extension:
   
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/kotlin",files="build.gradle.kts[tags=type_unsafe_access]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-settings/groovy",files="build.gradle[tags=type_unsafe_access]"]
   ====
   
   Check the link:{javadocPath}#[version catalog API] for all supported methods.
   
   == Sharing catalogs
   
   Version catalogs are used in a single build (possibly multi-project build) but may also be shared between builds.
   For example, an organization may want to create a catalog of dependencies that different projects, from different teams, may use.
   
   === Importing a catalog from a TOML file
   
   The link:{javadocPath}#[version catalog builder API] supports including a model from an external file.
   This makes it possible to reuse the catalog of the main build for `buildSrc`, if needed.
   For example, the `buildSrc/settings.gradle(.kts)` file can include this file using:
   
   .Sharing the dependency catalog with buildSrc
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-toml/kotlin/buildSrc",files="settings.gradle.kts[tags=import_main_catalog]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-toml/groovy/buildSrc",files="settings.gradle[tags=import_main_catalog]"]
   ====
   
   [WARNING]
   ====
   Only a single file will be accepted when using the link:{javadocPath}#[VersionCatalogBuilder.from(Object dependencyNotation)] method.
   This means that notations like link:{groovyDslPath}#[]++)[Project.files(java.lang.Object...)] must refer to a single file, otherwise the build will fail.
   
   If a more complicated structure is required (version catalogs imported from multiple files), it's advisable to use a code-based approach, instead of TOML file.
   ====
   
   This technique can therefore be used to declare multiple catalogs from different files:
   
   .Declaring additional catalogs
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-toml/kotlin",files="settings.gradle.kts[tags=additional_catalog]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-toml/groovy",files="settings.gradle[tags=additional_catalog]"]
   ====
   
   === The version catalog plugin
   
   While importing catalogs from local files is convenient, it doesn't solve the problem of sharing a catalog in an organization or for external consumers.
   One option to share a catalog is to write a settings plugin, publish it on the Gradle plugin portal or an internal repository, and let the consumers apply the plugin on their settings file.
   
   Alternatively, Gradle offers a _version catalog_ plugin, which offers the ability to declare, then publish a catalog.
   
   To do this, you need to apply the `version-catalog` plugin:
   
   .Applying the version catalog plugin
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-versionCatalogPlugin/kotlin",files="build.gradle.kts[tags=apply_plugin]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-versionCatalogPlugin/groovy",files="build.gradle[tags=apply_plugin]"]
   ====
   
   This plugin will then expose the link:{javadocPath}#[catalog extension] that you can use to declare a catalog:
   
   .Definition of a catalog
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-versionCatalogPlugin/kotlin",files="build.gradle.kts[tags=catalog_spec]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-versionCatalogPlugin/groovy",files="build.gradle[tags=catalog_spec]"]
   ====
   
   Such a catalog can then be published by applying either the `maven-publish` or `ivy-publish` plugin and configuring the publication to use the `versionCatalog` component:
   
   .Publishing a catalog
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-versionCatalogPlugin/kotlin",files="build.gradle.kts[tags=catalog_publish]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-versionCatalogPlugin/groovy",files="build.gradle[tags=catalog_publish]"]
   ====
   
   When publishing such a project, a `libs.versions.toml` file will automatically be generated (and uploaded), which can then be <<platforms.adoc#sec:importing-published-catalog,consumed from other Gradle builds>>.
   
   === Importing a published catalog
   
   A catalog produced by the <<platforms.adoc#sec:version-catalog-plugin, version catalog plugin>> can be imported via the settings API:
   
   .Using a published catalog
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-javaPlatformCatalog/kotlin/consumer",files="settings.gradle.kts[tags=consume_catalog]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-javaPlatformCatalog/groovy/consumer",files="settings.gradle[tags=consume_catalog]"]
   ====
   
   ==== Overwriting catalog versions
   
   In case a catalog declares a version, you can overwrite the version when importing the catalog:
   
   .Overwriting versions declared in a published catalog
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-javaPlatformCatalog/kotlin/consumer",files="settings.gradle.kts[tags=overwrite_version]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-javaPlatformCatalog/groovy/consumer",files="settings.gradle[tags=overwrite_version]"]
   ====
   
   In the example above, any dependency which was using the `groovy` version as reference will be automatically updated to use `3.0.6`.
   
   NOTE: Again, overwriting a version doesn't mean that the actual _resolved_ dependency version will be the same: this only changes what is _imported_, that is to say what is used when declaring a dependency.
   The actual version will be subject to traditional conflict resolution, if any.
   
   == Using a platform to control transitive versions
   
   A <<dependency_management_terminology.adoc#sub::terminology_platform,platform>> is a special software component which can be used to control transitive dependency versions.
   In most cases it's exclusively composed of <<dependency_constraints.adoc#sec:adding-constraints-transitive-deps,dependency constraints>> which will either _suggest_ dependency versions or _enforce_ some versions.
   As such, this is a perfect tool whenever you need to _share dependency versions between projects_.
   In this case, a project will typically be organized this way:
   
   - a `platform` project which defines constraints for the various dependencies found in the different sub-projects
   - a number of sub-projects which _depend on_ the platform and declare dependencies _without version_
   
   In the Java ecosystem, Gradle provides a <<java_platform_plugin.adoc#java_platform_plugin,plugin>> for this purpose.
   
   It's also common to find platforms published as Maven BOMs which <<#sub:bom_import,Gradle supports natively>>.
   
   A dependency on a platform is created using the `platform` keyword:
   
   .Getting versions declared in a platform
   ====
   include::sample[dir="snippets/java-platform/recommender/kotlin/consumer",files="build.gradle.kts[tags=get-recommendations]"]
   include::sample[dir="snippets/java-platform/recommender/groovy/consumer",files="build.gradle[tags=get-recommendations]"]
   ====
   
   --
   This `platform` notation is a short-hand notation which actually performs several operations under the hood:
   
   * it sets the link:{javadocPath}#[org.gradle.category attribute] to `platform`, which means that Gradle will select the _platform_ component of the dependency.
   * it sets the link:{javadocPath}#[endorseStrictVersions] behavior by default, meaning that if the platform declares strict dependencies, they will be enforced.
   
   This means that by default, a dependency to a platform triggers the inheritance of all <<rich_versions.adoc#sec:strict-version,strict versions>> defined in that platform, which can be useful for platform authors to make sure that all consumers respect their decisions in terms of versions of dependencies.
   This can be turned off by explicitly calling the `doNotEndorseStrictVersions` method.
   --
   
   == Importing Maven BOMs
   
   Gradle provides support for importing https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Importing_Dependencies[bill of materials (BOM) files], which are effectively `.pom` files that use `<dependencyManagement>` to control the dependency versions of direct and transitive dependencies.
   The BOM support in Gradle works similar to using `<scope>import</scope>` when depending on a BOM in Maven.
   In Gradle however, it is done via a regular dependency declaration on the BOM:
   
   .Depending on a BOM to import its dependency constraints
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-constraintsFromBOM/kotlin",files="build.gradle.kts[tags=dependency-on-bom]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-constraintsFromBOM/groovy",files="build.gradle[tags=dependency-on-bom]"]
   ====
   
   In the example, the versions of `gson` and `dom4j` are provided by the Spring Boot BOM.
   This way, if you are developing for a platform like Spring Boot, you do not have to declare any versions yourself but can rely on the versions the platform provides.
   
   Gradle treats all entries in the `<dependencyManagement>` block of a BOM similar to <<dependency_constraints.adoc#sec:adding-constraints-transitive-deps,Gradle's dependency constraints>>.
   This means that any version defined in the `<dependencyManagement>` block can impact the dependency resolution result.
   In order to qualify as a BOM, a `.pom` file needs to have `<packaging>pom</packaging>` set.
   
   However often BOMs are not only providing versions as recommendations, but also a way to override any other version found in the graph.
   You can enable this behavior by using the `enforcedPlatform` keyword, instead of `platform`, when importing the BOM:
   
   .Importing a BOM, making sure the versions it defines override any other version found
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-enforcedConstraintsFromBOM/kotlin",files="build.gradle.kts[tags=dependency-on-bom]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-enforcedConstraintsFromBOM/groovy",files="build.gradle[tags=dependency-on-bom]"]
   ====
   
   [WARNING]
   ====
   Using `enforcedPlatform` needs to be considered with care if your software component can be consumed by others.
   This declaration is effectively transitive and so will apply to the dependency graph of your consumers.
   Unfortunately they will have to use `exclude` if they happen to disagree with one of the forced versions.
   Instead, if your reusable software component has a strong opinion on some third party dependency versions, consider using a <<rich_versions.adoc#sec:strict-version,rich version declaration>> with a `strictly`.
   ====
   
   == Should I use a platform or a catalog?
   
   Because platforms and catalogs both talk about dependency versions and can both be used to share dependency versions in a project, there might be a confusion regarding what to use and if one is preferable to the other.
   
   In short, you should:
   
   - use catalogs to only define dependencies and their versions for projects and to generate type-safe accessors
   - use platform to apply versions to dependency graph and to affect dependency resolution
   
   A catalog helps with centralizing the dependency versions and is only, as it name implies, a catalog of dependencies you can pick from.
   We recommend using it to declare the coordinates of your dependencies, in all cases.
   It will be used by Gradle to generate type-safe accessors, present short-hand notations for external dependencies and it allows sharing those coordinates between different projects easily.
   Using a catalog will not have any kind of consequence on downstream consumers: it's transparent to them.
   
   A platform is a more heavyweight construct: it's a component of a dependency graph, like any other library.
   If you depend on a platform, that platform is itself a component in the graph.
   It means, in particular, that:
   
   - <<dependency_constraints.adoc#dependency-constraints,Constraints>> defined in a platform can influence _transitive_ dependencies, not only the direct dependencies of your project.
   - A platform is versioned, and a transitive dependency in the graph can depend on a different version of the platform, causing various dependency upgrades.
   - A platform can tie components together, and in particular can be used as a construct for <<dependency_version_alignment.adoc#version_alignment, aligning versions>>.
   - A dependency on a platform is "inherited" by the consumers of your dependency: it means that a dependency on a platform can influence what versions of libraries would be used by your consumers even if you don't directly, or transitively, depend on components the platform references.
   
   In summary, using a catalog is always a good engineering practice as it centralizes common definitions, allows sharing of dependency versions or plugin versions, but it is an "implementation detail" of the build: it will not be visible to consumers and unused elements of a catalog are just ignored.
   
   A platform is meant to influence the dependency resolution graph, for example by adding constraints on transitive dependencies: it's a solution for structuring a dependency graph and influencing the resolution result.
   
   In practice, your project can both use a catalog _and_ declare a platform which itself uses the catalog:
   
   .Using a catalog within a platform definition
   ====
   include::sample[dir="snippets/dependencyManagement/catalogs-javaPlatformUsage/kotlin",files="build.gradle.kts[tags=platform_uses_catalog]"]
   include::sample[dir="snippets/dependencyManagement/catalogs-javaPlatformUsage/groovy",files="build.gradle[tags=platform_uses_catalog]"]
   ====

/docs/userguide/dep-man/03-controlling-transitive-dependencies/dependency_version_alignment.adoc
================================================================================================

.. code-block::

   = Aligning dependency versions
   
   Dependency version alignment allows different modules belonging to the same logical group (a _platform_) to have identical versions in a dependency graph.
   
   == Handling inconsistent module versions
   
   Gradle supports aligning versions of modules which belong to the same "platform".
   It is often preferable, for example, that the API and implementation modules of a component are using the same version.
   However, because of the game of transitive dependency resolution, it is possible that different modules belonging to the same platform end up using different versions.
   For example, your project may depend on the `jackson-databind` and `vert.x` libraries, as illustrated below:
   
   .Declaring dependencies
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-dependencyAlignment/kotlin",files="build.gradle.kts[tags=dependencies]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-dependencyAlignment/groovy",files="build.gradle[tags=dependencies]"]
   ====
   
   Because `vert.x` depends on `jackson-core`, we would actually resolve the following dependency versions:
   
   - `jackson-core` version `2.9.5` (brought by `vertx-core`)
   - `jackson-databind` version `2.9.5` (by conflict resolution)
   - `jackson-annotation` version `2.9.0` (dependency of `jackson-databind:2.9.5`)
   
   It's easy to end up with a set of versions which do not work well together.
   To fix this, Gradle supports dependency version alignment, which is supported by the concept of platforms.
   A platform represents a set of modules which "work well together".
   Either because they are actually published as a whole (when one of the members of the platform is published, all other modules are also published with the same version), or because someone tested the modules and indicates that they work well together (typically, the Spring Platform).
   
   == Aligning versions natively with Gradle
   
   Gradle natively supports alignment of modules produced by Gradle.
   This is a direct consequence of the transitivity of <<dependency_constraints.adoc#sec:adding-constraints-transitive-deps, dependency constraints>>.
   So if you have a multi-project build, and you wish that consumers get the same version of all your modules, Gradle provides a simple way to do this using the <<java_platform_plugin.adoc#java_platform_plugin,Java Platform Plugin>>.
   
   For example, if you have a project that consists of 3 modules:
   
   - `lib`
   - `utils`
   - `core`, depending on `lib` and `utils`
   
   And a consumer that declares the following dependencies:
   
   - `core` version 1.0
   - `lib` version 1.1
   
   Then by default resolution would select `core:1.0` and `lib:1.1`, because `lib` has no dependency on `core`.
   We can fix this by adding a new module in our project, a _platform_, that will add constraints on all the modules of your project:
   
   .The platform module
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-dependencyAlignmentWithPlatform/kotlin/platform",files="build.gradle.kts[tags=platform]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-dependencyAlignmentWithPlatform/groovy/platform",files="build.gradle[tags=platform]"]
   ====
   
   Once this is done, we need to make sure that all modules now _depend on the platform_, like this:
   
   .Declaring a dependency on the platform
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-dependencyAlignmentWithPlatform/kotlin/core",files="build.gradle.kts[tags=dependencies]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-dependencyAlignmentWithPlatform/groovy/core",files="build.gradle[tags=dependencies]"]
   ====
   
   It is important that the platform contains a constraint on all the components, but also that each component has a dependency on the platform.
   By doing this, whenever Gradle will add a dependency to a module of the platform on the graph, it will _also_ include constraints on the other modules of the platform.
   This means that if we see another module belonging to the same platform, we will automatically upgrade to the same version.
   
   In our example, it means that we first see `core:1.0`, which brings a platform `1.0` with constraints on `lib:1.0` and `lib:1.0`.
   Then we add `lib:1.1` which has a dependency on `platform:1.1`.
   By conflict resolution, we select the `1.1` platform, which has a constraint on `core:1.1`.
   Then we conflict resolve between `core:1.0` and `core:1.1`, which means that `core` and `lib` are now aligned properly.
   
   NOTE: This behavior is enforced for published components only if you use Gradle Module Metadata.
   
   == Aligning versions of modules not published with Gradle
   
   Whenever the publisher doesn't use Gradle, like in our Jackson example, we can explain to Gradle that all Jackson modules "belong to" the same platform and benefit from the same behavior as with native alignment.
   There are two options to express that a set of modules belong to a platform:
   
   1. A platform is **published** as a <<platforms.adoc#sub:bom_import,BOM>> and can be used:
      For example, `com.fasterxml.jackson:jackson-bom` can be used as platform.
      The information missing to Gradle in that case is that the platform should be added to the dependencies if one of its members is used.
   2. No existing platform can be used. Instead, a **virtual platform** should be created by Gradle:
      In this case, Gradle builds up the platform itself based on all the members that are used.
   
   To provide the missing information to Gradle, you can define <<component_metadata_rules.adoc#sec:component_metadata_rules,component metadata rules>> as explained in the following.
   
   === Align versions of modules using a published BOM
   
   .A dependency version alignment rule
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-dependencyAlignment/kotlin",files="build.gradle.kts[tags=bom-alignment-rule]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-dependencyAlignment/groovy",files="build.gradle[tags=bom-alignment-rule]"]
   ====
   
   By using the `belongsTo` with `false` (**not** virtual), we declare that all modules belong to the same _published platform_.
   In this case, the platform is `com.fasterxml.jackson:jackson-bom` and Gradle will look for it, as for any other module, in the declared repositories.
   
   .Making use of a dependency version alignment rule
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-dependencyAlignment/kotlin",files="build.gradle.kts[tags=use_bom_rule]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-dependencyAlignment/groovy",files="build.gradle[tags=use_bom_rule]"]
   ====
   
   Using the rule, the versions in the example above align to whatever the selected version of `com.fasterxml.jackson:jackson-bom` defines.
   In this case, `com.fasterxml.jackson:jackson-bom:2.9.5` will be selected as `2.9.5` is the highest version of a module selected.
   In that BOM, the following versions are defined and will be used:
   `jackson-core:2.9.5`,
   `jackson-databind:2.9.5` and
   `jackson-annotation:2.9.0`.
   The lower versions of `jackson-annotation` here might be the desired result as it is what the BOM recommends.
   
   NOTE: This behavior is working reliable since Gradle 6.1. Effectively, it is similar to a <<component_metadata_rules.adoc#sec:component_metadata_rules,component metadata rule>> that adds a platform dependency to all members of the platform using `withDependencies`.
   
   === Align versions of modules without a published platform
   
   .A dependency version alignment rule
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-dependencyAlignment/kotlin",files="build.gradle.kts[tags=alignment-rule]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-dependencyAlignment/groovy",files="build.gradle[tags=alignment-rule]"]
   ====
   
   By using the `belongsTo` keyword without further parameter (platform **is** virtual), we declare that all modules belong to the same _virtual platform_, which is treated specially by the engine.
   A virtual platform will not be retrieved from a repository.
   The identifier, in this case `com.fasterxml.jackson:jackson-virtual-platform`, is something you as the build author define yourself.
   The "content" of the platform is then created by Gradle on the fly by collecting all `belongsTo` statements pointing at the same virtual platform.
   
   .Making use of a dependency version alignment rule
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-dependencyAlignment/kotlin",files="build.gradle.kts[tags=use_rule]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-dependencyAlignment/groovy",files="build.gradle[tags=use_rule]"]
   ====
   
   Using the rule, all versions in the example above would align to `2.9.5`.
   In this case, also `jackson-annotation:2.9.5` will be taken, as that is how we defined our local virtual platform.
   
   For both published and virtual platforms, Gradle lets you override the version choice of the platform itself by specifying an _enforced_ dependency on the platform:
   
   .Forceful platform downgrade
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-dependencyAlignment/kotlin",files="build.gradle.kts[tags=enforced_platform]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-dependencyAlignment/groovy",files="build.gradle[tags=enforced_platform]"]
   ====
   

/docs/userguide/dep-man/03-controlling-transitive-dependencies/dependency_capability_conflict.adoc
==================================================================================================

.. code-block::

   = Handling mutually exclusive dependencies
   
   == Introduction to component capabilities
   
   Often a dependency graph would accidentally contain multiple implementations of the same API.
   This is particularly common with logging frameworks, where multiple bindings are available, and that one library chooses a binding when another transitive dependency chooses another.
   Because those implementations live at different GAV coordinates, the build tool has usually no way to find out that there's a conflict between those libraries.
   To solve this, Gradle provides the concept of _capability_.
   
   It's illegal to find two components providing the same _capability_ in a single dependency graph.
   Intuitively, it means that if Gradle finds two components that provide the same thing on classpath, it's going to fail with an error indicating what modules are in conflict.
   In our example, it means that different bindings of a logging framework provide the same capability.
   
   == Capability coordinates
   
   A _capability_ is defined by a `(group, module, version)` triplet.
   Each component defines an implicit capability corresponding to its GAV coordinates (group, artifact, version).
   For example, the `org.apache.commons:commons-lang3:3.8` module has an implicit capability with group `org.apache.commons`, name `commons-lang3` and version `3.8`.
   It is important to realize that capabilities are _versioned_.
   
   == Declaring component capabilities
   
   By default, Gradle will fail if two components in the dependency graph provide the same capability.
   Because most modules are currently published without Gradle Module Metadata, capabilities are not always automatically discovered by Gradle.
   It is however interesting to use _rules_ to declare component capabilities in order to discover conflicts as soon as possible, during the build instead of runtime.
   
   A typical example is whenever a component is relocated at different coordinates in a new release.
   For example, the ASM library lived at `asm:asm` coordinates until version `3.3.1`, then changed to `org.ow2.asm:asm` since `4.0`.
   It is illegal to have both ASM \<= 3.3.1 and 4.0+ on the classpath, because they provide the same feature, it's just that the component has been relocated.
   Because each component has an implicit capability corresponding to its GAV coordinates, we can "fix" this by having a rule that will declare that the `asm:asm` module provides the `org.ow2.asm:asm` capability:
   
   .Conflict resolution by capability
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-declaringCapabilities/kotlin",files="build.gradle.kts[tags=fix_asm]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-declaringCapabilities/groovy",files="build.gradle[tags=fix_asm]"]
   ====
   
   Now the build is going to _fail_ whenever the two components are found in the same dependency graph.
   
   [NOTE]
   ====
   At this stage, Gradle will _only_ make more builds fail.
   It will **not** automatically fix the problem for you, but it helps you realize that you have a problem.
   It is recommended to write such rules in _plugins_ which are then applied to your builds.
   Then, users _have to_ express their preferences, if possible, or fix the problem of having incompatible things on the classpath, as explained in the following section.
   ====
   
   == Selecting between candidates
   
   At some point, a dependency graph is going to include either _incompatible modules_, or modules which are _mutually exclusive_.
   For example, you may have different logger implementations and you need to choose one binding.
   <<#sub:capabilities,Capabilities>> help _realizing_ that you have a conflict, but Gradle also provides tools to express how to solve the conflicts.
   
   === Selecting between different capability candidates
   
   In the relocation example above, Gradle was able to tell you that you have two versions of the same API on classpath: an "old" module and a "relocated" one.
   Now we can solve the conflict by automatically choosing the component which has the highest capability version:
   
   .Conflict resolution by capability versioning
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-declaringCapabilities/kotlin",files="build.gradle.kts[tags=use_highest_asm]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-declaringCapabilities/groovy",files="build.gradle[tags=use_highest_asm]"]
   ====
   
   However, fixing by choosing the highest capability version conflict resolution is not always suitable.
   For a logging framework, for example, it doesn't matter what version of the logging frameworks we use, we should always select Slf4j.
   
   In this case, we can fix it by explicitly selecting slf4j as the winner:
   
   .Substitute log4j with slf4j
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-declaringCapabilities/kotlin",files="build.gradle.kts[tags=use_slf4j]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-declaringCapabilities/groovy",files="build.gradle[tags=use_slf4j]"]
   ====
   
   Note that this approach works also well if you have multiple _Slf4j bindings_ on the classpath:
   bindings are basically different logger implementations and you need only one.
   However, the selected implementation may depend on the configuration being resolved.
   For example, for tests, `slf4j-simple` may be enough but for production, `slf4-over-log4j` may be better.
   
   --
   Resolution can only be made in favor of a module _found_ in the graph.
   
   The `select` method only accepts a module found in the _current_ candidates.
   If the module you want to select is not part of the conflict, you can abstain from performing a selection, effectively not resolving _this_ conflict.
   It might be that another conflict exists in the graph for the same capability and will have the module you want to select.
   
   If no resolution is given for all conflicts on a given capability, the build will fail given the module chosen for resolution was not part of the graph at all.
   
   In addition `select(null)` will result in an error and so should be avoided.
   --
   
   For more information, check out the link:{javadocPath}#[the capabilities resolution API].

/docs/userguide/dep-man/03-controlling-transitive-dependencies/component_metadata_rules.adoc
============================================================================================

.. code-block::

   = Fixing metadata with component metadata rules
   
   Each module that is pulled from a repository has metadata associated with it, such as its group, name, version as well as the different variants it provides with their artifacts and dependencies.
   Sometimes, this metadata is incomplete or incorrect.
   To manipulate such incomplete metadata from within the build script, Gradle offers an API to write _component metadata rules_.
   These rules take effect after a module's metadata has been downloaded, but before it is used in dependency resolution.
   
   == Basics of writing a component metadata rule
   
   Component metadata rules are applied in the components (link:{groovyDslPath}#[ComponentMetadataHandler]) section of the dependencies block (link:{groovyDslPath}#[DependencyHandler]) of a build script or in the settings script.
   The rules can be defined in two different ways:
   
   1. As an action directly when they are applied in the _components_ section
   2. As an isolated class implementing the link:{javadocPath}#[ComponentMetadataRule] interface
   
   While defining rules inline as action can be convenient for experimentation, it is generally recommended to define rules as separate classes.
   Rules that are written as isolated classes can be annotated with `@CacheableRule` to cache the results of their application such that they do not need to be re-executed each time dependencies are resolved.
   
   .Example of a configurable component metadata rule
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/kotlin",files="build.gradle.kts[tags=config-component-metadata-rule]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/groovy",files="build.gradle[tags=config-component-metadata-rule]"]
   ====
   
   As can be seen in the examples above, component metadata rules are defined by implementing link:{javadocPath}#[ComponentMetadataRule] which has a single `execute` method receiving an instance of link:{javadocPath}#[ComponentMetadataContext] as parameter.
   In this example, the rule is also further configured through an link:{javadocPath}#[ActionConfiguration].
   This is supported by having a constructor in your implementation of `ComponentMetadataRule` accepting the parameters that were configured and the services that need injecting.
   
   Gradle enforces isolation of instances of `ComponentMetadataRule`.
   This means that all parameters must be `Serializable` or known Gradle types that can be isolated.
   
   In addition, Gradle services can be injected into your `ComponentMetadataRule`.
   Because of this, the moment you have a constructor, it must be annotated with `@javax.inject.Inject`.
   A commonly required service is link:{javadocPath}#[ObjectFactory] to create instances of strongly typed value objects like a value for setting an link:{javadocPath}#[Attribute].
   A service which is helpful for advanced usage of component metadata rules with custom metadata is the link:{javadocPath}#[RepositoryResourceAccessor].
   
   A component metadata rule can be applied to all modules  `all(rule)`  or to a selected module  `withModule(groupAndName, rule)`.
   Usually, a rule is specifically written to enrich metadata of one specific module and hence the `withModule` API should be preferred.
   
   === Declaring rules in a central place
   
   NOTE: Declaring component metadata rules in settings is an incubating feature
   
   Instead of declaring rules for each subproject individually, it is possible to declare rules in the `settings.gradle(.kts)` file for the whole build.
   Rules declared in settings are the _conventional_ rules applied to each project: if the project doesn't declare any rules, the rules from the settings script will be used.
   
   .Declaring a rule in settings
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/kotlin",files="settings.gradle.kts[tags=rule-in-settings]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/groovy",files="settings.gradle[tags=rule-in-settings]"]
   ====
   
   By default, rules declared in a project will *override* whatever is declared in settings.
   It is possible to change this default, for example to always prefer the settings rules:
   
   .Preferring rules declared in settings
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/kotlin",files="settings.gradle.kts[tags=prefer-settings]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/groovy",files="settings.gradle[tags=prefer-settings]"]
   ====
   
   If this method is called and that a project or plugin declares rules, a warning will be issued.
   You can make this a failure instead by using this alternative:
   
   .Enforcing rules declared in settings
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/kotlin",files="settings.gradle.kts[tags=enforce-settings]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/groovy",files="settings.gradle[tags=enforce-settings]"]
   ====
   
   The default behavior is equivalent to calling this method:
   
   .Preferring rules declared in projects
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/kotlin",files="settings.gradle.kts[tags=prefer-projects]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/groovy",files="settings.gradle[tags=prefer-projects]"]
   ====
   
   
   == Which parts of metadata can be modified?
   
   The component metadata rules API is oriented at the features supported by link:https://github.com/gradle/gradle/blob/master/platforms/documentation/docs/src/docs/design/gradle-module-metadata-latest-specification.md[Gradle Module Metadata] and the _dependencies_ API in build scripts.
   The main difference between writing rules and defining dependencies and artifacts in the build script is that component metadata rules, following the structure of Gradle Module Metadata, operate on <<variant_model.adoc#understanding-variant-selection,variants>> directly.
   On the contrary, in build scripts you often influence the shape of multiple variants at once (e.g. an _api_ dependency is added to the _api_ and _runtime_ variant of a Java library, the artifact produced by the _jar_ task is also added to these two variants).
   
   Variants can be addressed for modification through the following methods:
   
   - `allVariants`: modify all variants of a component
   - `withVariant(name)`: modify a single variant identified by its name
   - `addVariant(name)` or `addVariant(name, base)`: add a new variant to the component either _from scratch_ or by _copying_ the details of an existing variant (base)
   
   The following details of each variant can be adjusted:
   
   - The <<variant_model.adoc#sec:abm_configuration_attributes,attributes>> that identify the variant  `attributes {}` block
   - The <<component_capabilities.adoc#declaring-component-capabilities,capabilities>> the variant provides  `withCapabilities { }` block
   - The <<declaring_dependencies.adoc#declaring-dependencies,dependencies>> of the variant, including <<rich_versions.adoc#rich-version-constraints,rich versions>>  `withDependencies {}` block
   - The <<dependency_constraints.adoc#sec:adding-constraints-transitive-deps,dependency constraints>> of the variant, including <<rich_versions.adoc#rich-version-constraints,rich versions>>  `withDependencyConstraints {}` block
   - The location of the published files that make up the actual content of the variant  `withFiles { }` block
   
   There are also a few properties of the whole component that can be changed:
   
   - The _component level attributes_, currently the only meaningful attribute there is `org.gradle.status`
   - The _status scheme_ to influence interpretation of the `org.gradle.status` attribute during version selection
   - The _belongsTo_ property for <<component_capabilities.adoc#sec:declaring-capabilities-external-modules,version alignment through virtual platforms>>
   
   Depending on the format of the metadata of a module, it is mapped differently to the variant-centric representation of the metadata:
   
   - If the module has Gradle Module Metadata, the data structure the rule operates on is very similar to what you find in the module's `.module` file.
   - If the module was published only with `.pom` metadata, a number of fixed variants is derived as explained in the <<variant_model.adoc#sub:maven-mapping-to-variants,mapping of POM files to variants>> section.
   - If the module was published only with an `ivy.xml` file, the _Ivy configurations_ defined in the file can be accessed instead of variants.
     Their dependencies, dependency constraints and files can be modified.
     Additionally, the `addVariant(name, baseVariantOrConfiguration) { }` API can be used to derive variants from _Ivy configurations_ if desired (for example, <<variant_model.adoc#sub:ivy-mapping-to-variants,_compile_ and _runtime_ variants for the Java library plugin>> can be defined with this).
   
   == When to use Component Metadata Rules? ==
   
   In general, if you consider using component metadata rules to adjust the metadata of a certain module, you should check first if that module was published with Gradle Module Metadata (`.module` file) or traditional metadata only (`.pom` or `ivy.xml`).
   
   If a module was published with Gradle Module Metadata, the metadata is likely complete although there can still be cases where something is just plainly wrong.
   For these modules you should only use component metadata rules if you have clearly identified a problem with the metadata itself.
   If you have an issue with the dependency resolution result, you should first check if you can solve the issue by declaring <<rich_versions.adoc#rich-version-constraints,dependency constraints with rich versions>>.
   In particular, if you are developing a library that you publish, you should remember that dependency constraints, in contrast to component metadata rules, are published as part of the metadata of your own library.
   So with dependency constraints, you automatically share the solution of dependency resolution issues with your consumers, while component metadata rules are only applied to your own build.
   
   If a module was published with traditional metadata (`.pom` or `ivy.xml` only, no `.module` file) it is more likely that the metadata is incomplete as features such as variants or dependency constraints are not supported in these formats.
   Still, conceptually such modules can contain different variants or might have dependency constraints they just omitted (or wrongly defined as dependencies).
   In the next sections, we explore a number existing oss modules with such incomplete metadata and the rules for adding the missing metadata information.
   
   As a rule of thumb, you should contemplate if the rule you are writing also works out of context of your build.
   That is, does the rule still produce a correct and useful result if applied in any other build that uses the module(s) it affects?
   
   == Fixing wrong dependency details ==
   
   Let's consider as an example the publication of the Jaxen XPath Engine on link:https://repo1.maven.org/maven2/jaxen/jaxen[Maven central].
   The pom of version 1.1.3 declares a number of dependencies in the compile scope which are not actually needed for compilation.
   These have been removed in the 1.1.4 pom.
   Assuming that we need to work with 1.1.3 for some reason, we can fix the metadata with the following rule:
   
   .Rule to remove unused dependencies of Jaxen metadata
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/kotlin",files="build.gradle.kts[tags=jaxen-rule-1]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/groovy",files="build.gradle[tags=jaxen-rule-1]"]
   ====
   
   Within the `withDependencies` block you have access to the full list of dependencies and can use all methods available on the Java collection interface to inspect and modify that list.
   In addition, there are `add(notation, configureAction)` methods accepting the usual notations similar to <<declaring_dependencies.adoc#declaring-dependencies,declaring dependencies>> in the build script.
   Dependency constraints can be inspected and modified the same way in the `withDependencyConstraints` block.
   
   If we take a closer look at the Jaxen 1.1.4 pom, we observe that the _dom4j_, _jdom_ and _xerces_ dependencies are still there but marked as _optional_.
   Optional dependencies in poms are not automatically processed by Gradle nor Maven.
   The reason is that they indicate that there are <<feature_variants.adoc#feature_variants,optional feature variants>> provided by the Jaxen library which require one or more of these dependencies, but the information what these features are and which dependency belongs to which is missing.
   Such information cannot be represented in pom files, but in Gradle Module Metadata through variants and <<component_capabilities.adoc#declaring-component-capabilities,capabilities>>.
   Hence, we can add this information in a rule as well.
   
   .Rule to add optional feature to Jaxen metadata
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/kotlin",files="build.gradle.kts[tags=jaxen-rule-2]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/groovy",files="build.gradle[tags=jaxen-rule-2]"]
   ====
   
   Here, we first use the `addVariant(name, baseVariant)` method to create an additional variant, which we identify as _feature variant_ by defining a new capability _jaxen-dom4j_ to represent the optional dom4j integration feature of Jaxen.
   This works similar to <<feature_variants.adoc#sec::declare_feature_variants,defining optional feature variants>> in build scripts.
   We then use one of the `add` methods for adding dependencies to define which dependencies this optional feature needs.
   
   In the build script, we can then add a <<feature_variants.adoc#sec::consuming_feature_variants, dependency to the optional feature>> and Gradle will use the enriched metadata to discover the correct transitive dependencies.
   
   .Applying and utilising rules for Jaxen metadata
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/kotlin",files="build.gradle.kts[tags=jaxen-dependencies]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/groovy",files="build.gradle[tags=jaxen-dependencies]"]
   ====
   
   == Making variants published as classified jars explicit ==
   
   While in the previous example, all variants, "main variants" and optional features, were packaged in one jar file, it is common to publish certain variants as separate files.
   In particular, when the variants are mutual exclusive  i.e. they are *not* feature variants, but different variants offering alternative choices.
   One example *all* pom-based libraries already have are the _runtime_ and _compile_ variants, where Gradle can choose only one depending on the task at hand.
   Another of such alternatives discovered often in the Java ecosystems are jars targeting different Java versions.
   
   As example, we look at version 0.7.9 of the asynchronous programming library Quasar published on link:https://repo1.maven.org/maven2/co/paralleluniverse/quasar-core/0.7.9[Maven central].
   If we inspect the directory listing, we discover that a `quasar-core-0.7.9-jdk8.jar` was published, in addition to `quasar-core-0.7.9.jar`.
   Publishing additional jars with a _classifier_ (here _jdk8_) is common practice in maven repositories.
   And while both Maven and Gradle allow you to reference such jars by classifier, they are not mentioned at all in the metadata.
   Thus, there is no information that these jars exist and if there are any other differences, like different dependencies, between the variants represented by such jars.
   
   In Gradle Module Metadata, this variant information would be present and for the already published Quasar library, we can add it using the following rule:
   
   .Rule to add JDK 8 variants to Quasar metadata
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/kotlin",files="build.gradle.kts[tags=quasar-rule]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/groovy",files="build.gradle[tags=quasar-rule]"]
   ====
   
   In this case, it is pretty clear that the classifier stands for a target Java version, which is a <<variant_model.adoc#sec:variant-aware-matching,known Java ecosystem attribute>>.
   Because we also need both a _compile_ and _runtime_ for Java 8, we create two new variants but use the existing _compile_ and _runtime_ variants as _base_.
   This way, all other Java ecosystem attributes are already set correctly and all dependencies are carried over.
   Then we set the `TARGET_JVM_VERSION_ATTRIBUTE` to `8` for both variants, remove any existing file from the new variants with `removeAllFiles()`, and add the jdk8 jar file with `addFile()`.
   The `removeAllFiles()` is needed, because the reference to the main jar `quasar-core-0.7.5.jar` is copied from the corresponding base variant.
   
   We also enrich the existing _compile_ and _runtime_ variants with the information that they target Java 7  `attribute(TARGET_JVM_VERSION_ATTRIBUTE, 7)`.
   
   Now, we can request a Java 8 versions for all of our dependencies on the compile classpath in the build script and Gradle will automatically select the best fitting variant for each library.
   In the case of Quasar this will now be the _jdk8Compile_ variant exposing the `quasar-core-0.7.9-jdk8.jar`.
   
   .Applying and utilising rule for Quasar metadata
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/kotlin",files="build.gradle.kts[tags=quasar-dependencies]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/groovy",files="build.gradle[tags=quasar-dependencies]"]
   ====
   
   == Making variants encoded in versions explicit  ==
   
   Another solution to publish multiple alternatives for the same library is the usage of a versioning pattern as done by the popular Guava library.
   Here, each new version is published twice by appending the classifier to the version instead of the jar artifact.
   In the case of Guava 28 for example, we can find a _28.0-jre_ (Java 8) and _28.0-android_ (Java 6) version on link:https://repo1.maven.org/maven2/com/google/guava/guava[Maven central].
   The advantage of using this pattern when working only with pom metadata is that both variants are discoverable through the version.
   The disadvantage is that there is no information what the different version suffixes mean semantically.
   So in the case of conflict, Gradle would just pick the highest version when comparing the version strings.
   
   Turning this into proper variants is a bit more tricky, as Gradle first selects a version of a module and then selects the best fitting variant.
   So the concept that variants are encoded as versions is not supported directly.
   However, since both variants are always published together we can assume that the files are physically located in the same repository.
   And since they are published with Maven repository conventions, we know the location of each file if we know module name and version.
   We can write the following rule:
   
   .Rule to add JDK 6 and JDK 8 variants to Guava metadata
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/kotlin",files="build.gradle.kts[tags=guava-rule]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/groovy",files="build.gradle[tags=guava-rule]"]
   ====
   
   Similar to the previous example, we add runtime and compile variants for both Java versions.
   In the `withFiles` block however, we now also specify a relative path for the corresponding jar file which allows Gradle to find the file no matter if it has selected a _-jre_ or _-android_ version.
   The path is always relative to the location of the metadata (in this case `pom`) file of the selection module version.
   So with this rules, both Guava 28 "versions" carry both the _jdk6_ and _jdk8_ variants.
   So it does not matter to which one Gradle resolves.
   The variant, and with it the correct jar file, is determined based on the requested `TARGET_JVM_VERSION_ATTRIBUTE` value.
   
   .Applying and utilising rule for Guava metadata
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/kotlin",files="build.gradle.kts[tags=guava-dependencies]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/groovy",files="build.gradle[tags=guava-dependencies]"]
   ====
   
   == Adding variants for native jars
   
   Jars with classifiers are also used to separate parts of a library for which multiple alternatives exists, for example native code, from the main artifact.
   This is for example done by the Lightweight Java Game Library (LWGJ), which publishes several platform specific jars to link:https://repo1.maven.org/maven2/org/lwjgl/lwjgl/3.2.3[Maven central] from which always one is needed, in addition to the main jar, at runtime.
   It is not possible to convey this information in pom metadata as there is no concept of putting multiple artifacts in relation through the metadata.
   In Gradle Module Metadata, each variant can have arbitrary many files and we can leverage that by writing the following rule:
   
   .Rule to add native runtime variants to LWGJ metadata
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/kotlin",files="build.gradle.kts[tags=lwgj-rule]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/groovy",files="build.gradle[tags=lwgj-rule]"]
   ====
   
   This rule is quite similar to the Quasar library example above.
   Only this time we have five different runtime variants we add and nothing we need to change for the compile variant.
   The runtime variants are all based on the existing _runtime_ variant and we do not change any existing information.
   All Java ecosystem attributes, the dependencies and the main jar file stay part of each of the runtime variants.
   We only set the additional attributes `OPERATING_SYSTEM_ATTRIBUTE` and `ARCHITECTURE_ATTRIBUTE` which are defined as part of Gradle's <<building_cpp_projects.adoc#building_cpp_projects,native support>>.
   And we add the corresponding native jar file so that each runtime variant now carries two files: the main jar and the native jar.
   
   In the build script, we can now request a specific variant and Gradle will fail with a selection error if more information is needed to make a decision.
   
   .Applying and utilising rule for LWGJ metadata
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/kotlin",files="build.gradle.kts[tags=lwgj-dependencies]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/groovy",files="build.gradle[tags=lwgj-dependencies]"]
   ====
   
   .Gradle fails to select a variant because a machine architecture needs to be chosen
   ----
   > Could not resolve all files for configuration ':runtimeClasspath'.
      > Could not resolve org.lwjgl:lwjgl:3.2.3.
        Required by:
            project :
         > Cannot choose between the following variants of org.lwjgl:lwjgl:3.2.3:
             - natives-windows-runtime
             - natives-windows-x86-runtime
   ----
   
   == Making different flavors of a library available through capabilities
   
   Because it is difficult to model <<feature_variants.adoc#feature_variants,optional feature variants>> as separate jars with pom metadata, libraries sometimes compose different jars with a different feature set.
   That is, instead of composing your flavor of the library from different feature variants, you select one of the pre-composed variants (offering everything in one jar).
   One such library is the well-known dependency injection framework Guice, published on link:https://repo1.maven.org/maven2/com/google/inject/guice/4.2.2[Maven central], which offers a complete flavor (the main jar) and a reduced variant without aspect-oriented programming support (`guice-4.2.2-no_aop.jar`).
   That second variant with a classifier is not mentioned in the pom metadata.
   With the following rule, we create compile and runtime variants based on that file and make it selectable through a capability named `com.google.inject:guice-no_aop`.
   
   .Rule to add no_aop feature variant to Guice metadata
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/kotlin",files="build.gradle.kts[tags=guice-rule]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/groovy",files="build.gradle[tags=guice-rule]"]
   ====
   
   The new variants also have the dependency on the standardized aop interfaces library `aopalliance:aopalliance` removed, as this is clearly not needed by these variants.
   Again, this is information that cannot be expressed in pom metadata.
   We can now select a `guice-no_aop` variant and will get the correct jar file *and* the correct dependencies.
   
   .Applying and utilising rule for Guice metadata
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/kotlin",files="build.gradle.kts[tags=guice-dependencies]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/groovy",files="build.gradle[tags=guice-dependencies]"]
   ====
   
   == Adding missing capabilities to detect conflicts
   
   Another usage of capabilities is to express that two different modules, for example `log4j` and `log4j-over-slf4j`, provide alternative implementations of the same thing.
   By declaring that both provide the same capability, Gradle only accepts one of them in a dependency graph.
   This example, and how it can be tackled with a component metadata rule, is described in detail in the  <<component_capabilities.adoc#sec:declaring-capabilities-external-modules,feature modelling>> section.
   
   == Making Ivy modules variant-aware ==
   
   Modules with Ivy metadata, do not have variants by default.
   However, _Ivy configurations_ can be mapped to variants as the `addVariant(name, baseVariantOrConfiguration)` accepts any Ivy configuration that was published as base.
   This can be used, for example, to define runtime and compile variants.
   An example of a corresponding rule can be found <<variant_model.adoc#sub:ivy-mapping-to-variants,here>>.
   Ivy details of Ivy configurations (e.g. dependencies and files) can also be modified using the `withVariant(configurationName)` API.
   However, modifying attributes or capabilities on Ivy configurations has no effect.
   
   For very Ivy specific use cases, the component metadata rules API also offers access to other details only found in Ivy metadata.
   These are available through the link:{javadocPath}#[IvyModuleDescriptor] interface and can be accessed using `getDescriptor(IvyModuleDescriptor)` on the link:{javadocPath}#[ComponentMetadataContext].
   
   .Ivy component metadata rule
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/kotlin",files="build.gradle.kts[tags=ivy-component-metadata-rule]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/groovy",files="build.gradle[tags=ivy-component-metadata-rule]"]
   ====
   
   == Filter using Maven metadata  ==
   
   For Maven specific use cases, the component metadata rules API also offers access to other details only found in POM metadata.
   These are available through the link:{javadocPath}#[PomModuleDescriptor] interface and can be accessed using `getDescriptor(PomModuleDescriptor)` on the link:{javadocPath}#[ComponentMetadataContext].
   
   .Access pom packaging type in component metadata rule
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/kotlin",files="build.gradle.kts[tags=maven-packaging-component-metadata-rule]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/groovy",files="build.gradle[tags=maven-packaging-component-metadata-rule]"]
   ====
   
   == Modifying metadata on the component level for alignment
   
   While all the examples above made modifications to variants of a component, there is also a limited set of modifications that can be done to the metadata of the component itself.
   This information can influence the <<dependency_resolution.adoc#understanding_dependency_resolution,version selection>> process for a module during dependency resolution, which is performed _before_ one or multiple variants of a component are selected.
   
   The first API available on the component is `belongsTo()` to create virtual platforms for aligning versions of multiple modules without Gradle Module Metadata.
   It is explained in detail in the section on <<dependency_version_alignment.adoc#sec:align-versions-unpublished,aligning versions of modules not published with Gradle>>.
   
   == Modifying metadata on the component level for version selection based on status
   
   Gradle and Gradle Module Metadata also allow attributes to be set on the whole component instead of a single variant.
   Each of these attributes carries special semantics as they influence version selection which is done _before_ variant selection.
   While variant selection can handle <<variant_attributes.adoc#sec:declaring_attributes,any custom attribute>>, version selection only considers attributes for which specific semantics are implemented.
   At the moment, the only attribute with meaning here is `org.gradle.status`.
   It is therefore recommended to only modify this attribute, if any, on the component level.
   A dedicated API `setStatus(value)` is available for this.
   To modify another attribute for all variants of a component `withAllVariants { attributes {} }` should be utilised instead.
   
   A module's status is taken into consideration when a <<single_versions.adoc#single-version-declarations,_latest_ version selector>> is resolved.
   Specifically, `latest.someStatus` will resolve to the highest module version that has status `someStatus` or a more mature status.
   For example, `latest.integration` will select the highest module version regardless of its status (because `integration` is the least mature status as explained below), whereas `latest.release` will select the highest module version with status `release`.
   
   The interpretation of the status can be influenced by changing a module's _status scheme_ through the `setStatusScheme(valueList)` API.
   This concept models the different levels of maturity that a module transitions through over time with different publications.
   The default status scheme, ordered from least to most mature status, is `integration`, `milestone`, `release`.
   The `org.gradle.status` attribute must be set, to one of the values in the components status scheme.
   Thus each component always has a status which is determined from the metadata as follows:
   
   - Gradle Module Metadata: the value that was published for the `org.gradle.status` attribute on the component
   - Ivy metadata: `status` defined in the ivy.xml, defaults to `integration` if missing
   - Pom metadata: `integration` for modules with a SNAPSHOT version, `release` for all others
   
   The following example demonstrates `latest` selectors based on a custom status scheme declared in a component metadata rule that applies to all modules:
   
   .Custom status scheme
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/kotlin",files="build.gradle.kts[tags=custom-status-scheme]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-metadataRule/groovy",files="build.gradle[tags=custom-status-scheme]"]
   ====
   
   Compared to the default scheme, the rule inserts a new status `rc` and replaces `integration` with `nightly`.
   Existing modules with the state `integration` are mapped to `nightly`.
   

/docs/userguide/dep-man/03-controlling-transitive-dependencies/resolution_rules.adoc
====================================================================================

.. code-block::

   = Customizing resolution of a dependency directly
   
   This section covers mechanisms Gradle offers to directly influence the behavior of the dependency resolution engine.
   In contrast to the other concepts covered in this chapter, like <<dependency_constraints.adoc#dependency-constraints,dependency constraints>> or <<component_metadata_rules.adoc#sec:component_metadata_rules,component metadata rules>>, which are all *inputs* to resolution, the following mechanisms allow you to write rules which are directly injected into the resolution engine.
   Because of this, they can be seen as _brute force_ solutions, that may hide future problems (e.g. if new dependencies are added).
   Therefore, the general advice is to only use the following mechanisms if other means are not sufficient.
   If you are authoring a <<library_vs_application.adoc#sec:understanding-diff-libraries-and-apps,library>>, you should always prefer <<dependency_constraints.adoc#dependency-constraints,dependency constraints>> as they are published for your consumers.
   
   == Using dependency resolve rules
   
   A dependency resolve rule is executed for each resolved dependency, and offers a powerful api for manipulating a requested dependency prior to that dependency being resolved.
   The feature currently offers the ability to change the group, name and/or version of a requested dependency, allowing a dependency to be substituted with a completely different module during resolution.
   
   Dependency resolve rules provide a very powerful way to control the dependency resolution process, and can be used to implement all sorts of advanced patterns in dependency management.
   Some of these patterns are outlined below.
   For more information and code samples see the link:{groovyDslPath}#[ResolutionStrategy] class in the API documentation.
   
   === Implementing a custom versioning scheme
   
   In some corporate environments, the list of module versions that can be declared in Gradle builds is maintained and audited externally.
   Dependency resolve rules provide a neat implementation of this pattern:
   
   * In the build script, the developer declares dependencies with the module group and name, but uses a placeholder version, for example: `default`.
   * The `default` version is resolved to a specific version via a dependency resolve rule, which looks up the version in a corporate catalog of approved modules.
   
   This rule implementation can be neatly encapsulated in a corporate plugin, and shared across all builds within the organisation.
   
   .Using a custom versioning scheme
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-resolutionStrategy/kotlin",files="build.gradle.kts[tags=custom-versioning-scheme]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-resolutionStrategy/groovy",files="build.gradle[tags=custom-versioning-scheme]"]
   ====
   
   === Denying a particular version with a replacement
   
   Dependency resolve rules provide a mechanism for denying a particular version of a dependency and providing a replacement version.
   This can be useful if a certain dependency version is broken and should not be used, where a dependency resolve rule causes this version to be replaced with a known good version.
   One example of a broken module is one that declares a dependency on a library that cannot be found in any of the public repositories, but there are many other reasons why a particular module version is unwanted and a different version is preferred.
   
   In example below, imagine that version `1.2.1` contains important fixes and should always be used in preference to `1.2`.
   The rule provided will enforce just this: any time version `1.2` is encountered it will be replaced with `1.2.1`.
   Note that this is different from a forced version as described above, in that any other versions of this module would not be affected.
   This means that the 'newest' conflict resolution strategy would still select version `1.3` if this version was also pulled transitively.
   
   .Example: Blacklisting a version with a replacement
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-resolutionStrategy/kotlin",files="build.gradle.kts[tags=denying_version]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-resolutionStrategy/groovy",files="build.gradle[tags=denying_version]"]
   ====
   
   [NOTE]
   ====
   There's a difference with using the _reject_ directive of <<rich_versions.adoc#rich-version-constraints,rich version constraints>>: rich versions will cause the build to fail if a rejected version is found in the graph, or select a non rejected version when using dynamic dependencies.
   Here, we _manipulate the requested versions_ in order to select a different version when we find a rejected one.
   In other words, this is a _solution_ to rejected versions, while rich version constraints allow declaring the _intent_ (you should not use this version).
   ====
   
   == Using module replacement rules
   
   It is preferable to express module conflicts in terms of <<dependency_capability_conflict.adoc#sub:capabilities, capabilities conflicts>>.
   However, if there's no such rule declared or that you are working on versions of Gradle which do not support capabilities, Gradle provides tooling to work around those issues.
   
   Module replacement rules allow a build to declare that a legacy library has been replaced by a new one.
   A good example when a new library replaced a legacy one is the `google-collections` -&gt; `guava` migration.
   The team that created google-collections decided to change the module name from `com.google.collections:google-collections` into `com.google.guava:guava`.
   This is a legal scenario in the industry: teams need to be able to change the names of products they maintain, including the module coordinates. Renaming of the module coordinates has impact on conflict resolution.
   
   To explain the impact on conflict resolution, let's consider the `google-collections` -&gt; `guava` scenario.
   It may happen that both libraries are pulled into the same dependency graph.
   For example, _our project_ depends on `guava` but some of _our dependencies_ pull in a legacy version of `google-collections`.
   This can cause runtime errors, for example during test or application execution.
   Gradle does not automatically resolve the `google-collections` -&gt; `guava` conflict because it is not considered as a _version conflict_.
   It's because the module coordinates for both libraries are completely different and conflict resolution is activated when `group` and `module` coordinates are the same but there are different versions available in the dependency graph (for more info, refer to the section on conflict resolution).
   Traditional remedies to this problem are:
   
   * Declare exclusion rule to avoid pulling in `google-collections` to graph. It is probably the most popular approach.
   * Avoid dependencies that pull in legacy libraries.
   * Upgrade the dependency version if the new version no longer pulls in a legacy library.
   * Downgrade to `google-collections`. It's not recommended, just mentioned for completeness.
   
   Traditional approaches work but they are not general enough.
   For example, an organisation wants to resolve the `google-collections` -&gt; `guava` conflict resolution problem in all projects.
   It is possible to declare that certain module was replaced by other.
   This enables organisations to include the information about module replacement in the corporate plugin suite and resolve the problem holistically for all Gradle-powered projects in the enterprise.
   
   .Declaring a module replacement
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-replacementRule/kotlin",files="build.gradle.kts[tags=module_replacement_declaration]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-replacementRule/groovy",files="build.gradle[tags=module_replacement_declaration]"]
   ====
   
   For more examples and detailed API, refer to the DSL reference for link:{javadocPath}#[ComponentMetadataHandler].
   
   What happens when we declare that `google-collections` is replaced by `guava`?
   Gradle can use this information for conflict resolution. Gradle will consider every version of `guava` newer/better than any version of `google-collections`.
   Also, Gradle will ensure that only guava jar is present in the classpath / resolved file list.
   Note that if only `google-collections` appears in the dependency graph (e.g. no `guava`) Gradle will not eagerly replace it with `guava`.
   Module replacement is an information that Gradle uses for resolving conflicts.
   If there is no conflict (e.g. only `google-collections` or only `guava` in the graph) the replacement information is not used.
   
   Currently it is not possible to declare that a given module is replaced by a set of modules.
   However, it is possible to declare that multiple modules are replaced by a single module.
   
   == Using dependency substitution rules
   
   Dependency substitution rules work similarly to dependency resolve rules.
   In fact, many capabilities of dependency resolve rules can be implemented with dependency substitution rules.
    They allow project and module dependencies to be transparently substituted with specified replacements.
    Unlike dependency resolve rules, dependency substitution rules allow project and module dependencies to be substituted interchangeably.
   
   _Adding a dependency substitution rule to a configuration changes the timing of when that configuration is resolved._
   Instead of being resolved on first use, the configuration is instead resolved when the task graph is being constructed.
   This can have unexpected consequences if the configuration is being further modified during task execution, or if the configuration relies on modules that are published during execution of another task.
   
   To explain:
   
   * A `Configuration` can be declared as an input to any Task, and that configuration can include project dependencies when it is resolved.
   * If a project dependency is an input to a Task (via a configuration), then tasks to build the project artifacts must be added to the task dependencies.
   * In order to determine the project dependencies that are inputs to a task, Gradle needs to resolve the `Configuration` inputs.
   * Because the Gradle task graph is fixed once task execution has commenced, Gradle needs to perform this resolution prior to executing any tasks.
   
   In the absence of dependency substitution rules, Gradle knows that an external module dependency will never transitively reference a project dependency.
   This makes it easy to determine the full set of project dependencies for a configuration through simple graph traversal.
   With this functionality, Gradle can no longer make this assumption, and must perform a full resolve in order to determine the project dependencies.
   
   === Substituting an external module dependency with a project dependency
   
   One use case for dependency substitution is to use a locally developed version of a module in place of one that is downloaded from an external repository.
   This could be useful for testing a local, patched version of a dependency.
   
   The module to be replaced can be declared with or without a version specified.
   
   .Substituting a module with a project
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-substitutionRule/kotlin",files="build.gradle.kts[tags=module_to_project_substitution]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-substitutionRule/groovy",files="build.gradle[tags=module_to_project_substitution]"]
   ====
   
   Note that a project that is substituted must be included in the multi-project build (via `settings.gradle`).
   Dependency substitution rules take care of replacing the module dependency with the project dependency and wiring up any task dependencies, but do not implicitly include the project in the build.
   
   === Substituting a project dependency with a module replacement
   
   Another way to use substitution rules is to replace a project dependency with a module in a multi-project build.
   This can be useful to speed up development with a large multi-project build, by allowing a subset of the project dependencies to be downloaded from a repository rather than being built.
   
   The module to be used as a replacement must be declared with a version specified.
   
   .Substituting a project with a module
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-substitutionRule/kotlin",files="build.gradle.kts[tags=project_to_module_substitution]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-substitutionRule/groovy",files="build.gradle[tags=project_to_module_substitution]"]
   ====
   
   When a project dependency has been replaced with a module dependency, that project is still included in the overall multi-project build.
   However, tasks to build the replaced dependency will not be executed in order to resolve the depending `Configuration`.
   
   === Conditionally substituting a dependency
   
   A common use case for dependency substitution is to allow more flexible assembly of sub-projects within a multi-project build.
   This can be useful for developing a local, patched version of an external dependency or for building a subset of the modules within a large multi-project build.
   
   The following example uses a dependency substitution rule to replace any module dependency with the group `org.example`, but only if a local project matching the dependency name can be located.
   
   .Conditionally substituting a dependency
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-conditionalSubstitutionRule/kotlin/consumer",files="build.gradle.kts[tags=project_substitution]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-conditionalSubstitutionRule/groovy/consumer",files="build.gradle[tags=project_substitution]"]
   ====
   
   Note that a project that is substituted must be included in the multi-project build (via `settings.gradle`).
   Dependency substitution rules take care of replacing the module dependency with the project dependency, but do not implicitly include the project in the build.
   
   === Substituting a dependency with another variant
   
   Gradle's dependency management engine is <<variant_model.adoc#understanding-variant-selection,variant-aware>> meaning that for a single component, the engine may select different artifacts and transitive dependencies.
   
   What to select is determined by the attributes of the consumer configuration and the attributes of the variants found on the producer side.
   It is, however, possible that some specific dependencies override attributes from the configuration itself.
   This is typically the case when using the <<java_platform_plugin.adoc#java_platform_plugin,Java Platform plugin>>: this plugin builds a special kind of component which is called a "platform" and can be addressed by setting the component category attribute to `platform`, in opposition to typical dependencies which are targetting libraries.
   
   Therefore, you may face situations where you want to substitute a platform dependency with a regular dependency, or the other way around.
   
   ==== Substituting a dependency with attributes
   
   Let's imagine that you want to substitute a platform dependency with a regular dependency.
   This means that the library you are consuming declared something like this:
   
   .An incorrect dependency on a platform
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-attributeSubstitutionRule/kotlin",files="lib/build.gradle.kts[tags=dependencies]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-attributeSubstitutionRule/groovy",files="lib/build.gradle[tags=dependencies]"]
   ====
   
   The `platform` keyword is actually a short-hand notation for a _dependency with attributes_.
   If we want to substitute this dependency with a regular dependency, then we need to select precisely the dependencies which have the `platform` attribute.
   
   This can be done by using a substitution rule:
   
   .Substitute a platform dependency with a regular dependency
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-attributeSubstitutionRule/kotlin",files="consumer/build.gradle.kts[tags=substitution_rule]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-attributeSubstitutionRule/groovy",files="consumer/build.gradle[tags=substitution_rule]"]
   ====
   
   The same rule _without_ the `platform` keyword would try to substitute _regular dependencies_ with a regular dependency, which is not what you want, so it's important to understand that the substitution rules apply on a _dependency specification_: it matches the requested dependency (`substitute XXX`) with a substitute (`using YYY`).
   
   You can have attributes on both the requested dependency _or_ the substitute and the substitution is not limited to `platform`: you can actually specify the whole set of dependency attributes using the `variant` notation.
   The following rule is _strictly equivalent_ to the rule above:
   
   .Substitute a platform dependency with a regular dependency using the variant notation
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-attributeSubstitutionRule/kotlin",files="consumer/build.gradle.kts[tags=substitution_rule_alternative]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-attributeSubstitutionRule/groovy",files="consumer/build.gradle[tags=substitution_rule_alternative]"]
   ====
   
   Please refer to the link:{javadocPath}#[Substitution DSL API docs] for a complete reference of the variant substitution API.
   
   WARNING: In <<composite_builds.adoc#composite_build_intro,composite builds>>, the rule that you have to match the exact requested dependency attributes is not applied: when using composites, Gradle will automatically match the requested attributes.
   In other words, it is implicit that if you include another build, you are substituting _all variants_ of the substituted module with an equivalent variant in the included build.
   
   ==== Substituting a dependency with a dependency with capabilities
   
   Similarly to <<resolution_rules.adoc#sec:substitution_with_attributes,attributes substitution>>, Gradle lets you substitute a dependency with or without capabilities with another dependency with or without capabilities.
   
   For example, let's imagine that you need to substitute a regular dependency with its <<java_testing.adoc#sec:java_test_fixtures,test fixtures>> instead.
   You can achieve this by using the following dependency substitution rule:
   
   .Substitute a dependency with its test fixtures
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-capabilitySubstitutionRule/kotlin",files="build.gradle.kts[tags=substitution_rule]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-capabilitySubstitutionRule/groovy",files="build.gradle[tags=substitution_rule]"]
   ====
   
   Capabilities which are declared in a substitution rule on the requested dependency constitute part of the dependency match specification, and therefore dependencies which do _not_ require the capabilities will not be matched.
   
   Please refer to the link:{javadocPath}#[Substitution DSL API docs] for a complete reference of the variant substitution API.
   
   === Substituting a dependency with a classifier or artifact
   
   While external modules are in general addressed via their group/artifact/version coordinates, it is common that such modules are published with additional artifacts that you may want to use in place of the main artifact.
   This is typically the case for _classified_ artifacts, but you may also need to select an artifact with a different file type or extension.
   Gradle discourages use of classifiers in dependencies and prefers to model such artifacts as <<variant_model.adoc#understanding-variant-selection,additional variants of a module>>.
   There are lots of advantages of using variants instead of classified artifacts, including, but not only, a different set of dependencies for those artifacts.
   
   However, in order to help bridging the two models, Gradle provides means to change or remove a classifier in a substitution rule.
   
   .Dependencies which will lead to a resolution error
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-classifierSubstitutionRule/kotlin",files="consumer/build.gradle.kts[tags=dependencies]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-classifierSubstitutionRule/groovy",files="consumer/build.gradle[tags=dependencies]"]
   ====
   
   In the example above, the first level dependency on `quasar` makes us think that Gradle would resolve `quasar-core-0.8.0.jar` but it's not the case: the build would fail with this message:
   
   [source,text]
   ----
   Execution failed for task ':resolve'.
   > Could not resolve all files for configuration ':runtimeClasspath'.
      > Could not find quasar-core-0.8.0-jdk8.jar (co.paralleluniverse:quasar-core:0.8.0).
        Searched in the following locations:
            https://repo1.maven.org/maven2/co/paralleluniverse/quasar-core/0.8.0/quasar-core-0.8.0-jdk8.jar
   ----
   
   That's because there's a dependency on another project, `lib`, which itself depends on a different version of `quasar-core`:
   
   .A "classified" dependency
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-classifierSubstitutionRule/kotlin",files="lib/build.gradle.kts[tags=dependencies]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-classifierSubstitutionRule/groovy",files="lib/build.gradle[tags=dependencies]"]
   ====
   
   What happens is that Gradle would perform conflict resolution between `quasar-core` 0.8.0 and `quasar-core` 0.7.10.
   Because 0.8.0 is higher, we select this version, but the dependency in `lib` has a classifier, `jdk8` and this classifier _doesn't exist anymore_ in release 0.8.0.
   
   To fix this problem, you can ask Gradle to resolve both dependencies _without classifier_:
   
   .A resolution rule to disable selection of a classifier
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-classifierSubstitutionRule/kotlin",files="consumer/build.gradle.kts[tags=substitution_rule]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-classifierSubstitutionRule/groovy",files="consumer/build.gradle[tags=substitution_rule]"]
   ====
   
   This rule effectively replaces any dependency on `quasar-core` found in the graph with a dependency without classifier.
   
   Alternatively, it's possible to select a dependency _with_ a specific classifier or, for more specific use cases, substitute with a very specific artifact (type, extension and classifier).
   
   For more information, please refer to the following API documentation:
   
   - artifact selection via the link:{javadocPath}#[Substitution DSL]
   - artifact selection via the link:{javadocPath}#[DependencySubstitution API]
   - artifact selection via the link:{javadocPath}#[ResolutionStrategy API]
   
   == Disabling transitive resolution
   
   By default Gradle resolves all transitive dependencies specified by the dependency metadata.
   Sometimes this behavior may not be desirable e.g. if the metadata is incorrect or defines a large graph of transitive dependencies.
   You can tell Gradle to disable transitive dependency management for a dependency by setting link:{javadocPath}#[ModuleDependency.setTransitive(boolean)] to `false`.
   As a result only the main artifact will be resolved for the declared dependency.
   
   .Disabling transitive dependency resolution for a declared dependency
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-disableForDependency/kotlin",files="build.gradle.kts[tags=transitive-per-dependency]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-disableForDependency/groovy",files="build.gradle[tags=transitive-per-dependency]"]
   ====
   
   NOTE: Disabling transitive dependency resolution will likely require you to declare the necessary runtime dependencies in your build script which otherwise would have been resolved automatically. Not doing so might lead to runtime classpath issues.
   
   A project can decide to disable transitive dependency resolution completely.
   You either don't want to rely on the metadata published to the consumed repositories or you want to gain full control over the dependencies in your graph.
   For more information, see link:{javadocPath}#[Configuration.setTransitive(boolean)].
   
   .Disabling transitive dependency resolution on the configuration-level
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-disableForConfiguration/kotlin",files="build.gradle.kts[tags=transitive-per-configuration]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-disableForConfiguration/groovy",files="build.gradle[tags=transitive-per-configuration]"]
   ====
   
   == Changing configuration dependencies prior to resolution
   
   At times, a plugin may want to modify the dependencies of a configuration before it is resolved.
   The `withDependencies` method permits dependencies to be added, removed or modified programmatically.
   
   .Modifying dependencies on a configuration
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-withDependencies/kotlin",files="build.gradle.kts[tags=configuration-with-dependencies]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-withDependencies/groovy",files="build.gradle[tags=configuration-with-dependencies]"]
   ====
   
   == Setting default configuration dependencies
   
   A configuration can be configured with default dependencies to be used if no dependencies are explicitly set for the configuration.
   A primary use case of this functionality is for developing plugins that make use of versioned tools that the user might override.
   By specifying default dependencies, the plugin can use a default version of the tool only if the user has not specified a particular version to use.
   
   .Specifying default dependencies on a configuration
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-defaultDependency/kotlin",files="build.gradle.kts[tags=configuration-default-dependencies]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-defaultDependency/groovy",files="build.gradle[tags=configuration-default-dependencies]"]
   ====
   
   == Excluding a dependency from a configuration completely
   
   Similar to <<dependency_downgrade_and_exclude.adoc#sec:excluding-transitive-deps,excluding a dependency in a dependency declaration>>, you can exclude a transitive dependency for a particular configuration completely by using link:{groovyDslPath}#[Configuration.exclude(java.util.Map)].
   This will automatically exclude the transitive dependency for all dependencies declared on the configuration.
   
   .Excluding transitive dependency for a particular configuration
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-excludeForConfiguration/kotlin",files="build.gradle.kts[tags=exclude-transitive-dependencies]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-excludeForConfiguration/groovy",files="build.gradle[tags=exclude-transitive-dependencies]"]
   ====
   
   == Matching dependencies to repositories
   
   Gradle exposes an API to declare what a repository may or may not contain.
   This feature offers a fine grained control on which repository serve which artifacts, which can be one way of controlling the source of dependencies.
   
   Head over to <<declaring_repositories.adoc#sec:repository-content-filtering,the section on repository content filtering>> to know more about this feature.
   
   == Enabling Ivy dynamic resolve mode
   
   Gradle's Ivy repository implementations support the equivalent to Ivy's dynamic resolve mode.
   Normally, Gradle will use the `rev` attribute for each dependency definition included in an `ivy.xml` file.
   In dynamic resolve mode, Gradle will instead prefer the `revConstraint` attribute over the `rev` attribute for a given dependency definition.
   If the `revConstraint` attribute is not present, the `rev` attribute is used instead.
   
   To enable dynamic resolve mode, you need to set the appropriate option on the repository definition.
   A couple of examples are shown below.
   Note that dynamic resolve mode is only available for Gradle's Ivy repositories.
   It is not available for Maven repositories, or custom Ivy `DependencyResolver` implementations.
   
   .Enabling dynamic resolve mode
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-ivyDynamicMode/kotlin",files="build.gradle.kts[tags=ivy-repo-dynamic-mode]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-ivyDynamicMode/groovy",files="build.gradle[tags=ivy-repo-dynamic-mode]"]
   ====

/docs/userguide/dep-man/03-controlling-transitive-dependencies/resolution_strategy_tuning.adoc
==============================================================================================

.. code-block::

   = Preventing accidental dependency upgrades
   
   In some situations, you might want to be in total control of the dependency graph.
   In particular, you may want to make sure that:
   
   - the versions declared in a build script actually correspond to the ones being resolved
   - or make sure that dependency resolution is reproducible over time
   
   Gradle provides ways to perform this by configuring the resolution strategy.
   
   == Failing on version conflict
   
   There's a version conflict whenever Gradle finds the same module in two different versions in a dependency graph.
   By default, Gradle performs _optimistic upgrades_, meaning that if version `1.1` and `1.3` are found in the graph, we resolve to the highest version, `1.3`.
   However, it is easy to miss that some dependencies are upgraded because of a transitive dependency.
   In the example above, if `1.1` was a version used in your build script and `1.3` a version brought transitively, you could use `1.3` without actually noticing.
   
   To make sure that you are aware of such upgrades, Gradle provides a mode that can be activated in the resolution strategy of a configuration.
   Imagine the following dependencies declaration:
   
   .Direct dependency version not matching a transitive version
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-resolutionStrategy/kotlin",files="build.gradle.kts[tags=dependencies]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-resolutionStrategy/groovy",files="build.gradle[tags=dependencies]"]
   ====
   
   Then by default Gradle would upgrade `commons-lang3`, but it is possible to _fail_ the build:
   
   .Fail on version conflict
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-resolutionStrategy/kotlin",files="build.gradle.kts[tags=fail-on-version-conflict]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-resolutionStrategy/groovy",files="build.gradle[tags=fail-on-version-conflict]"]
   ====
   
   == Making sure resolution is reproducible
   
   There are cases where dependency resolution can be _unstable_ over time.
   That is to say that if you build at date D, building at date D+x may give a different resolution result.
   
   This is possible in the following cases:
   
   - dynamic dependency versions are used (version ranges, `latest.release`, `1.+`, ...)
   - or _changing_ versions are used (SNAPSHOTs, fixed version with changing contents, ...)
   
   The recommended way to deal with dynamic versions is to use <<dependency_locking.adoc#dependency-locking,dependency locking>>.
   However, it is possible to prevent the use of dynamic versions altogether, which is an alternate strategy:
   
   .Failing on dynamic versions
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-resolutionStrategy/kotlin",files="build.gradle.kts[tags=fail-on-dynamic]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-resolutionStrategy/groovy",files="build.gradle[tags=fail-on-dynamic]"]
   ====
   
   Likewise, it's possible to prevent the use of changing versions by activating this flag:
   
   .Failing on changing versions
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-resolutionStrategy/kotlin",files="build.gradle.kts[tags=fail-on-changing]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-resolutionStrategy/groovy",files="build.gradle[tags=fail-on-changing]"]
   ====
   
   It's a good practice to fail on changing versions at release time.
   
   Eventually, it's possible to combine both failing on dynamic versions and changing versions using a single call:
   
   .Failing on non-reproducible resolution
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-resolutionStrategy/kotlin",files="build.gradle.kts[tags=fail-on-unstable]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-resolutionStrategy/groovy",files="build.gradle[tags=fail-on-unstable]"]
   ====
   
   == Getting consistent dependency resolution results
   
   NOTE: Dependency resolution consistency is an incubating feature
   
   It's a common misconception that there's a single dependency graph for an application.
   In fact Gradle will, during a build, resolve a number of distinct dependency graphs, even within a single project.
   For example, the graph of dependencies to use at compile time is different from the graph of dependencies to use at runtime.
   In general, the graph of dependencies at runtime is a superset of the compile dependencies (there are exceptions to the rule, for example in case some dependencies are repackaged within the runtime binary).
   
   Gradle resolves those dependency graphs independently.
   This means, in the Java ecosystem for example, that the resolution of the "compile classpath" doesn't influence the resolution of the "runtime classpath".
   Similarly, test dependencies could end up bumping the version of production dependencies, causing some surprising results when executing tests.
   
   These surprising behaviors can be mitigated by enabling dependency resolution consistency.
   
   === Enabling project-local dependency resolution consistency
   
   For example, imagine that your Java library depends on the following libraries:
   
   .First-level dependencies
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-consistentResolution/kotlin",files="build.gradle.kts[tags=dependencies]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-consistentResolution/groovy",files="build.gradle[tags=dependencies]"]
   ====
   
   Then resolving the `compileClasspath` configuration would resolve the `groovy` library to version `3.0.1` as expected.
   However, resolving the `runtimeClasspath` configuration would instead return `groovy 3.0.2`.
   
   The reason for this is that a transitive dependency of `vertx`, which is a `runtimeOnly` dependency, brings a higher version of `groovy`.
   In general, this isn't a problem, but it also means that the version of the Groovy library that you are going to use at runtime is going to be different from the one that you used for compilation.
   
   In order to avoid this situation, Gradle offers an API to explain that configurations should be resolved consistently.
   
   === Declaring resolution consistency between configurations
   
   In the example above, we can declare that we want, at runtime, the same versions of the common dependencies as compile time, by declaring that the "runtime classpath" _should be consistent with_ the "compile classpath":
   
   .Declaring consistency between configurations
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-consistentResolution/kotlin",files="build.gradle.kts[tags=explicit-configuration]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-consistentResolution/groovy",files="build.gradle[tags=explicit-configuration]"]
   ====
   
   As a result, both the `runtimeClasspath` and `compileClasspath` will resolve Groovy 3.0.1.
   
   The relationship is _directed_, which means that if the `runtimeClasspath` configuration has to be resolved, Gradle will _first_ resolve the `compileClasspath` and then "inject" the result of resolution as <<rich_versions.adoc#sec:strict-version,strict constraints>> into the `runtimeClasspath`.
   
   If, for some reason, the versions of the two graphs cannot be "aligned", then resolution will fail with a call to action.
   
   === Declaring consistent resolution in the Java ecosystem
   
   The `runtimeClasspath` and `compileClasspath` example above are common in the Java ecosystem.
   However, it's often not enough to declare consistency between those two configurations only.
   For example, you most likely want the _test runtime classpath_ to be consistent with the
   _runtime classpath_.
   
   To make this easier, Gradle provides a way to configure consistent resolution for the Java ecosystem using the `java` extension:
   
   .Declaring consistency in the Java ecosystem
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-consistentResolution/kotlin",files="build.gradle.kts[tags=java-convention]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-consistentResolution/groovy",files="build.gradle[tags=java-convention]"]
   ====
   
   Please refer to the link:{javadocPath}#[Java Plugin Extension docs] for more configuration options.

/Section: 游릭 Producing And Consuming Variants Of Libraries
============================================================


/docs/userguide/dep-man/04-modeling-features/component_capabilities.adoc
========================================================================

.. code-block::

   = Declaring Capabilities of a Library
   
   == Capabilities as first-level concept
   
   Components provide a number of features which are often orthogonal to the software architecture used to provide those features.
   For example, a library may include several features in a single artifact.
   However, such a library would be published at single GAV (group, artifact and version) coordinates.
   This means that, at single coordinates, potentially co-exist different "features" of a component.
   
   With Gradle it becomes interesting to explicitly declare what features a component provides.
   For this, Gradle provides the concept of <<dependency_constraints.adoc#sec:adding-constraints-transitive-deps,capability>>.
   
   A feature is often built by combining different _capabilities_.
   
   In an ideal world, components shouldn't declare dependencies on explicit GAVs, but rather express their requirements in terms of capabilities:
   
   - "give me a component which provides logging"
   - "give me a scripting engine"
   - "give me a scripting engine that supports Groovy"
   
   By modeling _capabilities_, the dependency management engine can be smarter and tell you whenever you have _incompatible capabilities_ in a dependency graph, or ask you to choose whenever different modules in a graph provide the same _capability_.
   
   == Declaring capabilities for external modules
   
   It's worth noting that Gradle supports declaring capabilities for components you build, but also for external components in case they didn't.
   
   For example, if your build file contains the following dependencies:
   
   .A build file with an implicit conflict of logging frameworks
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-declaringCapabilities/kotlin",files="build.gradle.kts[tags=dependencies]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-declaringCapabilities/groovy",files="build.gradle[tags=dependencies]"]
   ====
   
   As is, it's pretty hard to figure out that you will end up with two logging frameworks on the classpath.
   In fact, `zookeeper` will bring in `log4j`, where what we want to use is `log4j-over-slf4j`.
   We can preemptively detect the conflict by adding a rule which will declare that both logging frameworks provide the same capability:
   
   .A build file with an implicit conflict of logging frameworks
   ====
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-declaringCapabilities/kotlin",files="build.gradle.kts[tags=declare_capability]"]
   include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-declaringCapabilities/groovy",files="build.gradle[tags=declare_capability]"]
   ====
   
   By adding this rule, we will make sure that Gradle _will_ detect conflicts and properly fail:
   
   
   ----
   > Could not resolve all files for configuration ':compileClasspath'.
      > Could not resolve org.slf4j:log4j-over-slf4j:1.7.10.
        Required by:
            project :
         > Module 'org.slf4j:log4j-over-slf4j' has been rejected:
              Cannot select module with conflict on capability 'log4j:log4j:1.7.10' also provided by [log4j:log4j:1.2.16(compile)]
      > Could not resolve log4j:log4j:1.2.16.
        Required by:
            project : > org.apache.zookeeper:zookeeper:3.4.9
         > Module 'log4j:log4j' has been rejected:
              Cannot select module with conflict on capability 'log4j:log4j:1.2.16' also provided by [org.slf4j:log4j-over-slf4j:1.7.10(compile)]
   ----
   
   See the <<dependency_capability_conflict.adoc#sub:selecting-between-candidates, capabilities section of the documentation>> to figure out how to fix capability conflicts.
   
   == Declaring additional capabilities for a local component
   
   All components have an _implicit capability_ corresponding to the same GAV coordinates as the component.
   However, it is also possible to declare additional _explicit capabilities_ for a component.
   This is convenient whenever a library published at different GAV coordinates is an _alternate implementation_ of the same API:
   
   .Declaring capabilities of a component
   ====
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-outgoingCapabilities/kotlin",files="build.gradle.kts[tags=declare-outgoing-capabilities]"]
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-outgoingCapabilities/groovy",files="build.gradle[tags=declare-outgoing-capabilities]"]
   ====
   
   Capabilities must be attached to _outgoing configurations_, which are <<declaring_dependencies.adoc#sec:resolvable-consumable-configs,consumable configurations>> of a component.
   
   This example shows that we declare two capabilities:
   
   1. `com.acme:my-library:1.0`, which corresponds to the _implicit capability_ of the library
   2. `com.other:module:1.1`, which corresponds to another capability of this library
   
   It's worth noting we need to do 1. because as soon as you start declaring _explicit_ capabilities, then _all_ capabilities need to be declared, including the _implicit_ one.
   
   The second capability can be specific to this library, or it can correspond to a capability provided by an external component.
   In that case, if `com.other:module` appears in the same dependency graph, the build will fail and consumers <<dependency_capability_conflict.adoc#sub:selecting-between-candidates,will have to choose what module to use>>.
   
   Capabilities are published to Gradle Module Metadata.
   However, they have _no equivalent_ in POM or Ivy metadata files.
   As a consequence, when publishing such a component, Gradle will warn you that this feature is only for Gradle consumers:
   
   ----
   Maven publication 'maven' contains dependencies that cannot be represented in a published pom file.
     - Declares capability com.acme:my-library:1.0
     - Declares capability com.other:module:1.1
   ----

/docs/userguide/dep-man/04-modeling-features/feature_variants.adoc
==================================================================

.. code-block::

   :maven-optional-deps: https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html[Maven optional dependencies]
   :metadata-file-spec: https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md
   
   = Modeling library features
   
   Gradle supports the concept of _features_: it's often the case that a single library can be split up into multiple related yet distinct libraries, where each _feature_ can be used alongside the _main_ library.
   
   Features allow a component to expose multiple related libraries, each of which can declare its own dependencies.
   These libraries are exposed as variants, similar to how the _main_ library exposes variants for its API and runtime.
   
   This allows for a number of different scenarios (list is non-exhaustive):
   
   - a (better) substitute for {maven-optional-deps}
   - a _main_ library is built with support for different mutually-exclusive implementations of runtime features; the <<sec::incompatible_variants,user must choose one, and only one, implementation of each such feature>>
   - a _main_ library is built with support for optional runtime features, each of which requires a different set of dependencies
   - a _main_ library comes with supplementary features like _test fixtures_
   - a _main_ library comes with a main artifact, and enabling an additional feature requires additional artifacts
   
   == Selection of features via capabilities
   
   Declaring a dependency on a component is usually done by providing a set of coordinates (group, artifact, version also known as GAV coordinates).
   This allows the engine to determine the _component_ we're looking for, but such a component may provide different _variants_.
   A _variant_ is typically chosen based on the usage. For example, we might choose a different variant for compiling against a component (in which case we need the API of the component) or when executing code (in which case we need the runtime of the component).
   All variants of a component provide a number of <<dependency_capability_conflict.adoc#sub:capabilities, capabilities>>, which are denoted similarly using GAV coordinates.
   
   --
   A capability is denoted by GAV coordinates, but you must think of it as feature description:
   
   - "I provide an SLF4J binding"
   - "I provide runtime support for MySQL"
   - "I provide a Groovy runtime"
   
   And in general, having two components that provide the _same thing_ in the graph is a problem (they conflict).
   --
   
   This is an important concept because:
   
   - By default, a variant provides a capability corresponding to the GAV coordinates of its component
   - No two variants in a dependency graph can provide the same capability
   - Multiple variants of a single component may be selected as long as they provide _different capabilities_
   
   A typical component will *only* provide variants with the default capability.
   A Java library, for example, exposes two variants (API and runtime) which provide the _same capability_.
   As a consequence, it is an error to have both the _API_ and _runtime_ of a single component in a dependency graph.
   
   However, imagine that you need the _runtime_ and the _test fixtures runtime_ of a component.
   Then it is allowed as long as the _runtime_ and _test fixtures runtime_ variant of the library declare different capabilities.
   
   If we do so, a consumer would then have to declare two dependencies:
   
   - one on the "main" feature, the library
   - one on the "test fixtures" feature, by _requiring its capability_
   
   NOTE: While the resolution engine supports multi-variant components independently of the ecosystem, _features_ are currently only available using the Java plugins.
   
   == Registering features
   
   Features can be declared by applying the `java-library` plugin.
   The following code illustrates how to declare a feature named `mongodbSupport`:
   
   .Registering a feature
   ====
   include::sample[dir="snippets/java-feature-variant/producer-separate-sourceset/kotlin",files="build.gradle.kts[tags=register_variant,register_variant2]"]
   include::sample[dir="snippets/java-feature-variant/producer-separate-sourceset/groovy",files="build.gradle[tags=register_variant,register_variant2]"]
   ====
   
   Gradle will automatically set up a number of things for you, in a very similar way to how the <<java_library_plugin#java_library_plugin,Java Library Plugin>> sets up configurations.
   
   Dependency scope configurations are created in the same manner as for the main feature:
   
   - the configuration `mongodbSupportApi`, used to _declare API dependencies_ for this feature
   - the configuration `mongodbSupportImplementation`, used to _declare implementation dependencies_ for this feature
   - the configuration `mongodbSupportRuntimeOnly`, used to _declare runtime-only dependencies_ for this feature
   - the configuration `mongodbSupportCompileOnly`, used to _declare compile-only dependencies_ for this feature
   - the configuration `mongodbSupportCompileOnlyApi`, used to _declare compile-only API dependencies_ for this feature
   
   Furthermore, consumable configurations are created in the same manner as for the main feature:
   
   - the configuration `mongodbSupportApiElements`, used by consumers to fetch the artifacts and API dependencies of this feature
   - the configuration `mongodbSupportRuntimeElements`, used by consumers to fetch the artifacts and runtime dependencies of this feature
   
   A feature should have a _source set_ with the same name.
   Gradle will create a `Jar` task to bundle the classes built from the feature source set, using a classifier corresponding to the kebab-case name of the feature.
   
   WARNING: Do not use the _main_ source set when registering a feature. This behavior will be deprecated in a future version of Gradle.
   
   Most users will only need to care about the dependency scope configurations, to declare the specific dependencies of this feature:
   
   .Declaring dependencies of a feature
   ====
   include::sample[dir="snippets/java-feature-variant/producer-separate-sourceset/kotlin",files="build.gradle.kts[tags=variant_dependencies]"]
   include::sample[dir="snippets/java-feature-variant/producer-separate-sourceset/groovy",files="build.gradle[tags=variant_dependencies]"]
   ====
   
   --
   By convention, Gradle maps the feature name to a capability whose group and version are the same as the group and version of the main component, respectively, but whose name is the main component name followed by a `-` followed by the kebab-cased feature name.
   
   For example, if the component's group is `org.gradle.demo`, its name is `provider`, its version is `1.0`, and the feature is named `mongodbSupport`, the feature's variants will have the `org.gradle.demo:provider-mongodb-support:1.0` capability.
   
   If you choose the capability name yourself or add more capabilities to a variant, it is recommended to follow the same convention.
   --
   
   == Publishing features
   
   --
   Depending on the metadata file format, publishing features may be lossy:
   
   - using {metadata-file-spec}[Gradle Module Metadata], everything is published and consumers will get the full benefit of features
   - using POM metadata (Maven), features are published as **optional dependencies** and artifacts of features are published with different _classifiers_
   - using Ivy metadata, features are published as extra configurations, which are _not_ extended by the `default` configuration
   --
   
   Publishing features is supported using the `maven-publish` and `ivy-publish` plugins only.
   The Java Library Plugin will take care of registering the additional variants for you, so there's no additional configuration required, only the regular publications:
   
   .Publishing a component with features
   ====
   include::sample[dir="snippets/java-feature-variant/producer-separate-sourceset/kotlin",files="build.gradle.kts[tags=plugins,publishing]"]
   include::sample[dir="snippets/java-feature-variant/producer-separate-sourceset/groovy",files="build.gradle[tags=plugins,publishing]"]
   ====
   
   === Adding javadoc and sources JARs
   
   Similar to the <<building_java_projects.adoc#sec:java_packaging,main Javadoc and sources JARs>>, you can configure the added feature so that it produces JARs for the Javadoc and sources.
   
   .Producing javadoc and sources JARs for features
   ====
   include::sample[dir="snippets/java-feature-variant/producer-separate-sourceset/kotlin",files="build.gradle.kts[tags=register_variant_extra_jars]"]
   include::sample[dir="snippets/java-feature-variant/producer-separate-sourceset/groovy",files="build.gradle[tags=register_variant_extra_jars]"]
   ====
   
   == Dependencies on features
   
   --
   As mentioned earlier, features can be lossy when published.
   As a consequence, a consumer can depend on a feature only in these cases:
   
   - with a project dependency (in a multi-project build)
   - with Gradle Module Metadata available, that is the publisher MUST have published it
   - within the Ivy world, by declaring a dependency on the configuration matching the feature
   --
   
   A consumer can specify that it needs a specific feature of a producer by declaring required capabilities.
   For example, if a producer declares a "MySQL support" feature like this:
   
   .A library declaring a feature to support MySQL
   ====
   include::sample[dir="snippets/java-feature-variant/requiring-features/kotlin/producer",files="build.gradle.kts[tags=producer]"]
   include::sample[dir="snippets/java-feature-variant/requiring-features/groovy/producer",files="build.gradle[tags=producer]"]
   ====
   
   Then the consumer can declare a dependency on the MySQL support feature by doing this:
   
   .Consuming specific features in a multi-project build
   ====
   include::sample[dir="snippets/java-feature-variant/requiring-features/kotlin/consumer",files="build.gradle.kts[tags=consumer]"]
   include::sample[dir="snippets/java-feature-variant/requiring-features/groovy/consumer",files="build.gradle[tags=consumer]"]
   ====
   
   This will automatically bring the `mysql-connector-java` dependency on the runtime classpath.
   If there were more than one dependency, all of them would be brought, meaning that a feature can be used to group dependencies which contribute to a feature together.
   
   Similarly, if an external library with features was published with {metadata-file-spec}[Gradle Module Metadata], it is possible to depend on a feature provided by that library:
   
   .Consuming specific features from an external repository
   ====
   include::sample[dir="snippets/java-feature-variant/requiring-features-external/kotlin/project",files="build.gradle.kts[tags=consumer]"]
   include::sample[dir="snippets/java-feature-variant/requiring-features-external/groovy/project",files="build.gradle[tags=consumer]"]
   ====
   
   == Handling mutually exclusive variants
   
   The main advantage of using _capabilities_ as a way to handle features is that you can precisely handle compatibility of variants.
   The rule is simple:
   
   > No two variants in a dependency graph can provide the same capability
   
   We can leverage this to ensure that Gradle fails whenever the user mis-configures dependencies.
   Consider a situation where your library supports MySQL, Postgres and MongoDB, but that it's only allowed to choose _one_ of those at the same time.
   We can model this restriction by ensuring each feature also provides the same capability, thus making it impossible for these features to be used together in the same graph.
   
   .A producer of multiple features that are mutually exclusive
   ====
   include::sample[dir="snippets/java-feature-variant/incompatible-variants/kotlin/producer",files="build.gradle.kts[tags=producer]"]
   include::sample[dir="snippets/java-feature-variant/incompatible-variants/groovy/producer",files="build.gradle[tags=producer]"]
   ====
   
   Here, the producer declares 3 features, one for each database runtime support:
   
   - `mysql-support` provides both the `db-support` and `mysql-support` capabilities
   - `postgres-support` provides both the `db-support` and `postgres-support` capabilities
   - `mongo-support` provides both the `db-support` and `mongo-support` capabilities
   
   Then if the consumer tries to get both the `postgres-support` and `mysql-support` features (this also works transitively):
   
   .A consumer trying to use 2 incompatible variants at the same time
   ====
   include::sample[dir="snippets/java-feature-variant/incompatible-variants/kotlin/consumer",files="build.gradle.kts[tags=consumer]"]
   include::sample[dir="snippets/java-feature-variant/incompatible-variants/groovy/consumer",files="build.gradle[tags=consumer]"]
   ====
   
   Dependency resolution would fail with the following error:
   
   ----
   Cannot choose between
      org.gradle.demo:producer:1.0 variant mysqlSupportRuntimeElements and
      org.gradle.demo:producer:1.0 variant postgresSupportRuntimeElements
      because they provide the same capability: org.gradle.demo:producer-db-support:1.0
   ----

/docs/userguide/dep-man/04-modeling-features/variant_model.adoc
===============================================================

.. code-block::

   :metadata-file-spec: https://github.com/gradle/gradle/blob/master/platforms/documentation/docs/src/docs/design/gradle-module-metadata-latest-specification.md
   
   = Understanding variant selection
   
   In other dependency management engines, like Apache Maven, dependencies and artifacts are bound to a component that is published at a particular GAV (group-artifact-version) coordinates.
   The set of dependencies for this component are always the same, regardless of which artifact may be used from the component.
   
   If the component does have multiple artifacts, each one is identified by a cumbersome _classifier_.
   There are no common semantics associated with classifiers and that makes it difficult to guarantee a globally consistent dependency graph.
   This means that nothing prevents multiple artifacts for a single component (e.g., `jdk7` and `jdk8` classifiers) from appearing in a classpath and causing hard to diagnose problems.
   
   == Maven component model
   
   .The Maven component model
   image::component-model-maven.png[]
   
   == Gradle component model
   
   .The Gradle component model
   image::component-model-gradle.png[]
   
   Gradle's dependency management engine is _variant aware_.
   
   In addition to a component, Gradle has the concept of _variants_ of a component.
   Variants correspond to the different ways a component can be used, such as for Java compilation or native linking or documentation.
   Artifacts are attached to a _variant_ and each variant can have a different set of dependencies.
   
   How does Gradle know which variant to choose when there's more than one?
   Variants are matched by use of <<variant_attributes.adoc#variant_attributes,attributes>>, which provide semantics to the variants and help the engine to produce a _consistent_ resolution result.
   
   Gradle differentiates between two kind of components:
   
   - local components (like projects), built from sources
   - external components, published to repositories
   
   For local components, <<#sec:abm_configuration_attributes, variants are mapped to consumable configurations>>.
   For external components, variants are defined by published Gradle Module Metadata or <<#sec:mapping-maven-ivy-to-variants,are derived from Ivy/Maven metadata>>.
   
   .Variants vs configurations
   --
   Variants and configurations are sometimes used interchangeably in the documentation, DSL or API for historical reasons.
   
   All components provide _variants_ and those variants may be backed by a consumable configuration.
   Not all configurations are variants because they may be used for declaring or resolving dependencies.
   --
   
   == Variant attributes
   
   <<variant_attributes.adoc#variant_attributes,Attributes>> are type-safe key-value pairs that are defined by the consumer (for a resolvable configuration) and the producer (for each variant).
   
   The consumer can define any number of attributes.
   Each attribute helps narrow the possible variants that can be selected.
   Attribute values do not need to be exact matches.
   
   The variant can also define any number of attributes.
   The attributes should describe how the variant is intended to be used.
   For example, Gradle uses an attribute named `org.gradle.usage` to describe with how a component is used by the consumer (for compilation, for runtime execution, etc).
   It is not unusual for a variant to have more attributes than the consumer needs to provide to select it.
   
   == Variant attribute matching
   
   .About producer variants
   --
   The variant _name_ is mostly for debugging purposes and error messages.
   The name does not participate variant matching--only its attributes do.
   --
   
   There are no restrictions on the number of variants a component can define.
   Usually, a component has at least an implementation variant, but it could also expose test fixtures, documentation or source code.
   A component may also expose _different variants_ for different consumers for the same usage. For example, when compiling, a component could have different headers for Linux vs Windows vs macOS.
   
   Gradle performs _variant aware selection_ by matching the attributes requested by the consumer against attributes defined by the producer. The <<variant_attributes.adoc#sec:abm_algorithm, selection algorithm>> is detailed in another section.
   
   [NOTE]
   ====
   There are two exceptions to this rule that bypass variant aware resolution:
   
   - when a producer has no variants, a default artifact is chosen.
   - when a consumer _explicitly selects a configuration by name_, the artifacts of the configuration are chosen.
   ====
   
   == A simple example
   
   Let's consider an example where a consumer is trying to use a library for compilation.
   
   First, the consumer needs to explain how it's going to use the result of dependency resolution. This is done by setting _attributes_ on the resolvable configuration of the consumer.
   
   The consumer wants to resolve a variant that matches: `org.gradle.usage=java-api`
   
   Second, the producer needs to expose the different variants of the component.
   
   The producer component exposes 2 variants:
   
   - its API (named `apiElements`) with attribute `org.gradle.usage=java-api`
   - its runtime (named `runtimeElements`) with attribute `org.gradle.usage=java-runtime`
   
   Finally, Gradle selects the appropriate variant by looking at the variant attributes:
   
   - the consumer wants a variant with attributes `org.gradle.usage=java-api`
   - the producer has a matching variant (`apiElements`)
   - the producer has a non-matching variant (`runtimeElements`)
   
   Gradle provides the artifacts and dependencies from the `apiElements` variant to the consumer.
   
   == A more complicated example
   
   In the real world, consumers and producers have more than one attribute.
   
   A Java Library project in Gradle will involve several different attributes:
   
   - `org.gradle.usage` that describes how the variant is used
   - `org.gradle.dependency.bundling` that describes how the variant handles dependencies (shadow jar vs fat jar vs regular jar)
   - `org.gradle.libraryelements`, that describes the packaging of the variant (classes or jar)
   - `org.gradle.jvm.version` that describes the _minimal version_ of Java this variant targets
   - `org.gradle.jvm.environment` that describes the type of JVM this variant targets
   
   Let's consider an example where the consumer wants to run tests with a library on Java 8 and the producer supports two different Java versions (Java 8 and Java 11).
   
   First, the consumer needs to explain which version of the Java it needs.
   
   The consumer wants to resolve a variant that:
   
   - can be used at runtime (has `org.gradle.usage=java-runtime`)
   - can be run on _at least_ Java 8 (`org.gradle.jvm.version=8`)
   
   Second, the producer needs to expose the different variants of the component.
   
   Like in the simple example, there is both a API (compilation) and runtime variant. These exist for both the Java 8 and Java 11 version of the component.
   
   - its API for Java 8 consumers (named `apiJava8Elements`) with attribute `org.gradle.usage=java-api` and `org.gradle.jvm.version=8`
   - its runtime for Java 8 consumers (named `runtime8Elements`) with attribute `org.gradle.usage=java-runtime` and `org.gradle.jvm.version=8`
   - its API for Java 11 consumers (named `apiJava11Elements`) with attribute `org.gradle.usage=java-api` and `org.gradle.jvm.version=11`
   - its runtime for Java 11 consumers (named `runtime11Elements`) with attribute `org.gradle.usage=java-runtime` and `org.gradle.jvm.version=11`
   
   Finally, Gradle selects the best matching variant by looking at all of the attributes:
   
   - the consumer wants a variant with compatible attributes to `org.gradle.usage=java-runtime` and `org.gradle.jvm.version=8`
   - the variants `runtime8Elements` and `runtime11Elements` have `org.gradle.usage=java-runtime
   - the variants `apiJava8Elements` and `apiJava11Elements` are incompatible
   - the variant `runtime8Elements` is compatible because it can run on Java 8
   - the variant `runtime11Elements` is incompatible because it cannot run on Java 8
   
   Gradle provides the artifacts and dependencies from the `runtime8Elements` variant to the consumer.
   
   .Compatibility of variants
   --
   What if the consumer sets `org.gradle.jvm.version` to 7?
   
   Dependency resolution would _fail_ with an error message explaining that there's no suitable variant.
   Gradle recognizes that the consumer wants a Java 7 compatible library and the _minimal_ version of Java available on the producer is 8.
   
   If the consumer requested `org.gradle.jvm.version=15`, then Gradle knows either the Java 8 or Java 11 variants could work. Gradle select the highest compatible Java version (11).
   --
   
   == Variant selection errors
   
   When selecting the most compatible variant of a component, resolution may fail:
   
   * when more than one variant from the producer matches the consumer attributes (ambiguity error)
   * when no variants from the producer match the consumer attributes (incompatibility error)
   
   === Dealing with ambiguity errors
   
   An ambiguous variant selection looks like the following:
   
   [listing]
   ----
   > Could not resolve all files for configuration ':compileClasspath'.
      > Could not resolve project :lib.
        Required by:
            project :ui
         > Cannot choose between the following variants of project :lib:
             - feature1ApiElements
             - feature2ApiElements
           All of them match the consumer attributes:
             - Variant 'feature1ApiElements' capability org.test:test-capability:1.0:
                 - Unmatched attribute:
                     - Found org.gradle.category 'library' but wasn't required.
                 - Compatible attributes:
                     - Provides org.gradle.dependency.bundling 'external'
                     - Provides org.gradle.jvm.version '11'
                     - Required org.gradle.libraryelements 'classes' and found value 'jar'.
                     - Provides org.gradle.usage 'java-api'
             - Variant 'feature2ApiElements' capability org.test:test-capability:1.0:
                 - Unmatched attribute:
                     - Found org.gradle.category 'library' but wasn't required.
                 - Compatible attributes:
                     - Provides org.gradle.dependency.bundling 'external'
                     - Provides org.gradle.jvm.version '11'
                     - Required org.gradle.libraryelements 'classes' and found value 'jar'.
                     - Provides org.gradle.usage 'java-api'
   ----
   
   All _compatible_ candidate variants are displayed with their attributes.
   
   * Unmatched attributes are presented first, as they might be the missing piece in selecting the proper variant.
   * Compatible attributes are presented second as they indicate what the consumer wanted and how these variants do match that request.
   * There will not be any incompatible attributes as the variant would not be considered a candidate.
   
   In the example above, the fix does not lie in attribute matching but in <<dependency_capability_conflict.adoc#sub:selecting-between-candidates,capability matching>>, which are shown next to the variant name.
   Because these two variants effectively provide the same attributes and capabilities, they cannot be disambiguated.
   So in this case, the fix is most likely to provide different capabilities on the producer side (`project :lib`) and express a capability choice on the consumer side (`project :ui`).
   
   === Dealing with no matching variant errors
   
   A no matching variant error looks like the following:
   
   [listing]
   ----
   > No variants of project :lib match the consumer attributes:
     - Configuration ':lib:compile':
         - Incompatible attribute:
             - Required artifactType 'dll' and found incompatible value 'jar'.
         - Other compatible attribute:
             - Provides usage 'api'
     - Configuration ':lib:compile' variant debug:
         - Incompatible attribute:
             - Required artifactType 'dll' and found incompatible value 'jar'.
         - Other compatible attributes:
             - Found buildType 'debug' but wasn't required.
             - Provides usage 'api'
     - Configuration ':lib:compile' variant release:
         - Incompatible attribute:
             - Required artifactType 'dll' and found incompatible value 'jar'.
         - Other compatible attributes:
             - Found buildType 'release' but wasn't required.
             - Provides usage 'api'
   ----
   
   or like:
   
   [listing]
   ----
   > No variants of project : match the consumer attributes:
      - Configuration ':myElements' declares attribute 'color' with value 'blue':
          - Incompatible because this component declares attribute 'artifactType' with value 'jar' and the consumer needed attribute 'artifactType' with value 'dll'
      - Configuration ':myElements' variant secondary declares attribute 'color' with value 'blue':
          - Incompatible because this component declares attribute 'artifactType' with value 'jar' and the consumer needed attribute 'artifactType' with value 'dll'
   ----
   
   depending upon the stage in the variant selection algorithm where the error occurs.
   
   All _potentially compatible_ candidate variants are displayed with their attributes.
   
   * Incompatible attributes are presented first, as they usually are the key in understanding why a variant could not be selected.
   * Other attributes are presented second, this includes _requested_ and _compatible_ ones as well as all extra _producer_ attributes that are not requested by the consumer.
   
   Similar to the ambiguous variant error, the goal is to understand which variant should be selected. In some cases, there may not be any compatible variants from the producer (e.g., trying to run on Java 8 with a library built for Java 11).
   
   === Dealing with incompatible variant errors
   
   An incompatible variant error looks like the following example, where a consumer wants to select a variant with `color=green`, but the only variant available has `color=blue`:
   
   [listing]
   ----
   > Could not resolve all task dependencies for configuration ':resolveMe'.
      > Could not resolve project :.
        Required by:
            project :
         > Configuration 'mismatch' in project : does not match the consumer attributes
           Configuration 'mismatch':
             - Incompatible because this component declares attribute 'color' with value 'blue' and the consumer needed attribute 'color' with value 'green'
   ----
   
   It occurs when Gradle cannot select a single variant of a dependency because an explicitly requested attribute value does not match (and is not compatible with) the value of that attribute on any of the variants of the dependency.
   
   A sub-type of this failure occurs when Gradle *successfully* selects multiple variants of the same component, but the selected variants are incompatible with *each other*.
   
   This looks like the following, where a consumer wants to select two different variants of a component, each supplying different capabilities, which is acceptable.
   Unfortunately one variant has `color=blue` and the other has `color=green`:
   
   [listing]
   ----
   > Could not resolve all task dependencies for configuration ':resolveMe'.
      > Could not resolve project :.
        Required by:
            project :
         > Multiple incompatible variants of org.example:nyvu:1.0 were selected:
              - Variant org.example:nyvu:1.0 variant blueElementsCapability1 has attributes {color=blue}
              - Variant org.example:nyvu:1.0 variant greenElementsCapability2 has attributes {color=green}
   
      > Could not resolve project :.
        Required by:
            project :
         > Multiple incompatible variants of org.example:pi2e5:1.0 were selected:
              - Variant org.example:pi2e5:1.0 variant blueElementsCapability1 has attributes {color=blue}
              - Variant org.example:pi2e5:1.0 variant greenElementsCapability2 has attributes {color=green}
   ----
   
   === Dealing with ambiguous transformation errors
   
   ArtifactTransforms can be used to transform artifacts from one type to another, changing their attributes.
   Variant selection can use the attributes available as the result of an artifact transform as a candidate variant.
   
   If a project registers multiple artifact transforms, needs to use an artifact transform to produce a matching variant for a consumer's request, and multiple artifact transforms could each be used to accomplish this, then Gradle will fail with an ambiguous transformation error like the following:
   
   [listing]
   ----
   > Could not resolve all task dependencies for configuration ':resolveMe'.
      > Found multiple transforms that can produce a variant of project : with requested attributes:
          - color 'red'
          - shape 'round'
        Found the following transforms:
          - From 'configuration ':roundBlueLiquidElements'':
              - With source attributes:
                  - color 'blue'
                  - shape 'round'
                  - state 'liquid'
              - Candidate transform(s):
                  - Transform 'BrokenTransform' producing attributes:
                      - color 'red'
                      - shape 'round'
                      - state 'gas'
                  - Transform 'BrokenTransform' producing attributes:
                      - color 'red'
                      - shape 'round'
                      - state 'solid'
   ----
   
   == Visualizing variant information
   
   === Outgoing variants report
   
   The report task `outgoingVariants` shows the list of variants available for selection by consumers of the project. It displays the capabilities, attributes and artifacts for each variant.
   
   This task is similar to the `dependencyInsight` <<viewing_debugging_dependencies.adoc#sec:identifying_reason_dependency_selection,reporting task>>.
   
   By default, `outgoingVariants` prints information about all variants.
   It offers the optional parameter `--variant <variantName>` to select a single variant to display.
   It also accepts the `--all` flag to include information about legacy and deprecated configurations, or `--no-all` to exclude this information.
   
   Here is the output of the `outgoingVariants` task on a freshly generated `java-library` project:
   
   [listing]
   ----
   > Task :outgoingVariants
   --------------------------------------------------
   Variant apiElements
   --------------------------------------------------
   API elements for the 'main' feature.
   
   Capabilities
       - new-java-library:lib:unspecified (default capability)
   Attributes
       - org.gradle.category            = library
       - org.gradle.dependency.bundling = external
       - org.gradle.jvm.version         = 11
       - org.gradle.libraryelements     = jar
       - org.gradle.usage               = java-api
   Artifacts
       - build/libs/lib.jar (artifactType = jar)
   
   Secondary Variants (*)
   
       --------------------------------------------------
       Secondary Variant classes
       --------------------------------------------------
           Description = Directories containing compiled class files for main.
   
           Attributes
               - org.gradle.category            = library
               - org.gradle.dependency.bundling = external
               - org.gradle.jvm.version         = 11
               - org.gradle.libraryelements     = classes
               - org.gradle.usage               = java-api
           Artifacts
               - build/classes/java/main (artifactType = java-classes-directory)
   
   --------------------------------------------------
   Variant mainSourceElements (i)
   --------------------------------------------------
   Description = List of source directories contained in the Main SourceSet.
   
   Capabilities
       - new-java-library:lib:unspecified (default capability)
   Attributes
       - org.gradle.category            = verification
       - org.gradle.dependency.bundling = external
       - org.gradle.verificationtype    = main-sources
   Artifacts
       - src/main/java (artifactType = directory)
       - src/main/resources (artifactType = directory)
   
   --------------------------------------------------
   Variant runtimeElements
   --------------------------------------------------
   Runtime elements for the 'main' feature.
   
   Capabilities
       - new-java-library:lib:unspecified (default capability)
   Attributes
       - org.gradle.category            = library
       - org.gradle.dependency.bundling = external
       - org.gradle.jvm.version         = 11
       - org.gradle.libraryelements     = jar
       - org.gradle.usage               = java-runtime
   Artifacts
       - build/libs/lib.jar (artifactType = jar)
   
   Secondary Variants (*)
   
       --------------------------------------------------
       Secondary Variant classes
       --------------------------------------------------
           Description = Directories containing compiled class files for main.
   
           Attributes
               - org.gradle.category            = library
               - org.gradle.dependency.bundling = external
               - org.gradle.jvm.version         = 11
               - org.gradle.libraryelements     = classes
               - org.gradle.usage               = java-runtime
           Artifacts
               - build/classes/java/main (artifactType = java-classes-directory)
   
       --------------------------------------------------
       Secondary Variant resources
       --------------------------------------------------
           Description = Directories containing the project's assembled resource files for use at runtime.
   
           Attributes
               - org.gradle.category            = library
               - org.gradle.dependency.bundling = external
               - org.gradle.jvm.version         = 11
               - org.gradle.libraryelements     = resources
               - org.gradle.usage               = java-runtime
           Artifacts
               - build/resources/main (artifactType = java-resources-directory)
   
   --------------------------------------------------
   Variant testResultsElementsForTest (i)
   --------------------------------------------------
   Description = Directory containing binary results of running tests for the test Test Suite's test target.
   
   Capabilities
       - new-java-library:lib:unspecified (default capability)
   Attributes
       - org.gradle.category              = verification
       - org.gradle.testsuite.name        = test
       - org.gradle.testsuite.target.name = test
       - org.gradle.testsuite.type        = unit-test
       - org.gradle.verificationtype      = test-results
   Artifacts
       - build/test-results/test/binary (artifactType = directory)
   
   (i) Configuration uses incubating attributes such as Category.VERIFICATION.
   (*) Secondary variants are variants created via the Configuration#getOutgoing(): ConfigurationPublications API which also participate in selection, in addition to the configuration itself.
   ----
   
   From this you can see the two main variants that are exposed by a java library, `apiElements` and `runtimeElements`.
   Notice that the main difference is on the `org.gradle.usage` attribute, with values `java-api` and `java-runtime`.
   As they indicate, this is where the difference is made between what needs to be on the _compile_ classpath of consumers, versus what's needed on the _runtime_ classpath.
   
   It also shows _secondary_ variants, which are exclusive to Gradle projects and not published.
   For example, the secondary variant `classes` from `apiElements` is what allows Gradle to skip the JAR creation when compiling against a <<java_library_plugin.adoc#sec:java_library_classes_usage,`java-library` project>>.
   
   ==== Information about invalid consumable configurations
   
   A project cannot have multiple configurations with the same attributes and capabilities.
   In that case, the project will fail to build.
   
   In order to be able to visualize such issues, the outgoing variant reports handle those errors in a lenient fashion.
   This allows the report to display information about the issue.
   
   === Resolvable configurations report
   
   Gradle also offers a complimentary report task called `resolvableConfigurations` that displays the _resolvable_ configurations of a project, which are those which can have dependencies added and be resolved.  The report will list their attributes and any configurations that they extend.  It will also list a summary of any attributes which will be affected by <<variant_attributes.adoc#sec:abm_compatibility_rules, Compatibility Rules>> or <<variant_attributes.adoc#sec:abm_disambiguation_rules, Disambiguation Rules>> during resolution.
   
   By default, `resolvableConfigurations` prints information about all purely resolvable configurations.
   These are configurations that are marked resolvable but *not* marked consumable.
   Though some resolvable configurations are also marked consumable, these are legacy configurations that should *not* have dependencies added in build scripts.
   This report offers the optional parameter `--configuration <configurationName>` to select a single configuration to display.
   It also accepts the `--all` flag to include information about legacy and deprecated configurations, or `--no-all` to exclude this information.
   Finally, it accepts the `--recursive` flag to list in the extended configurations section those configurations which are extended _transitively_ rather than directly.
   Alternatively, `--no-recursive` can be used to exclude this information.
   
   Here is the output of the `resolvableConfigurations` task on a freshly generated `java-library` project:
   
   [listing]
   ----
   > Task :resolvableConfigurations
   --------------------------------------------------
   Configuration annotationProcessor
   --------------------------------------------------
   Description = Annotation processors and their dependencies for source set 'main'.
   
   Attributes
       - org.gradle.category            = library
       - org.gradle.dependency.bundling = external
       - org.gradle.jvm.environment     = standard-jvm
       - org.gradle.libraryelements     = jar
       - org.gradle.usage               = java-runtime
   
   --------------------------------------------------
   Configuration compileClasspath
   --------------------------------------------------
   Description = Compile classpath for source set 'main'.
   
   Attributes
       - org.gradle.category            = library
       - org.gradle.dependency.bundling = external
       - org.gradle.jvm.environment     = standard-jvm
       - org.gradle.jvm.version         = 11
       - org.gradle.libraryelements     = classes
       - org.gradle.usage               = java-api
   Extended Configurations
       - compileOnly
       - implementation
   
   --------------------------------------------------
   Configuration runtimeClasspath
   --------------------------------------------------
   Description = Runtime classpath of source set 'main'.
   
   Attributes
       - org.gradle.category            = library
       - org.gradle.dependency.bundling = external
       - org.gradle.jvm.environment     = standard-jvm
       - org.gradle.jvm.version         = 11
       - org.gradle.libraryelements     = jar
       - org.gradle.usage               = java-runtime
   Extended Configurations
       - implementation
       - runtimeOnly
   
   --------------------------------------------------
   Configuration testAnnotationProcessor
   --------------------------------------------------
   Description = Annotation processors and their dependencies for source set 'test'.
   
   Attributes
       - org.gradle.category            = library
       - org.gradle.dependency.bundling = external
       - org.gradle.jvm.environment     = standard-jvm
       - org.gradle.libraryelements     = jar
       - org.gradle.usage               = java-runtime
   
   --------------------------------------------------
   Configuration testCompileClasspath
   --------------------------------------------------
   Description = Compile classpath for source set 'test'.
   
   Attributes
       - org.gradle.category            = library
       - org.gradle.dependency.bundling = external
       - org.gradle.jvm.environment     = standard-jvm
       - org.gradle.jvm.version         = 11
       - org.gradle.libraryelements     = classes
       - org.gradle.usage               = java-api
   Extended Configurations
       - testCompileOnly
       - testImplementation
   
   --------------------------------------------------
   Configuration testRuntimeClasspath
   --------------------------------------------------
   Description = Runtime classpath of source set 'test'.
   
   Attributes
       - org.gradle.category            = library
       - org.gradle.dependency.bundling = external
       - org.gradle.jvm.environment     = standard-jvm
       - org.gradle.jvm.version         = 11
       - org.gradle.libraryelements     = jar
       - org.gradle.usage               = java-runtime
   Extended Configurations
       - testImplementation
       - testRuntimeOnly
   
   --------------------------------------------------
   Compatibility Rules
   --------------------------------------------------
   Description = The following Attributes have compatibility rules defined.
   
       - org.gradle.dependency.bundling
       - org.gradle.jvm.environment
       - org.gradle.jvm.version
       - org.gradle.libraryelements
       - org.gradle.plugin.api-version
       - org.gradle.usage
   
   --------------------------------------------------
   Disambiguation Rules
   --------------------------------------------------
   Description = The following Attributes have disambiguation rules defined.
   
       - org.gradle.category
       - org.gradle.dependency.bundling
       - org.gradle.jvm.environment
       - org.gradle.jvm.version
       - org.gradle.libraryelements
       - org.gradle.plugin.api-version
       - org.gradle.usage
   ----
   
   From this you can see the two main configurations used to resolve dependencies, `compileClasspath` and `runtimeClasspath`, as well as their corresponding test configurations.
   
   == Mapping from Maven/Ivy to Gradle variants
   
   Neither Maven nor Ivy have the concept of _variants_, which are only natively supported by Gradle Module Metadata.
   Gradle can still work with Maven and Ivy by using different variant derivation strategies.
   
   .Relationship with Gradle Module Metadata
   --
   Gradle Module Metadata is a metadata format for modules published on Maven, Ivy and other kinds of repositories.
   It is similar to the `pom.xml` or `ivy.xml` metadata file, but this format contains details about variants.
   
   See the {metadata-file-spec}[Gradle Module Metadata specification] for more information.
   --
   
   === Mapping of Maven POM metadata to variants
   
   Modules published on a Maven repository are automatically converted into variant-aware modules.
   
   There is no way for Gradle to know which kind of component was published:
   
   - a BOM that represents a Gradle platform
   - a BOM used as a super-POM
   - a POM that is both a platform _and_ a library
   
   The default strategy used by Java projects in Gradle is to derive 8 different variants:
   
   * two "library" variants (attribute `org.gradle.category` = `library`)
   ** the `compile` variant maps the `<scope>compile</scope>` dependencies.
   This variant is equivalent to the `apiElements` variant of the <<java_library_plugin.adoc#java_library_plugin,Java Library plugin>>.
   All dependencies of this scope are considered _API dependencies_.
   ** the `runtime` variant maps both the `<scope>compile</scope>` and `<scope>runtime</scope>` dependencies.
   This variant is equivalent to the `runtimeElements` variant of the <<java_library_plugin.adoc#java_library_plugin,Java Library plugin>>.
   All dependencies of those scopes are considered _runtime dependencies_.
   - in both cases, the `<dependencyManagement>` dependencies are _not converted to constraints_
   * a "sources" variant that represents the sources jar for the component
   * a "javadoc" variant that represents the javadoc jar for the component
   * four "platform" variants derived from the `<dependencyManagement>` block (attribute `org.gradle.category` = `platform`):
   ** the `platform-compile` variant maps the  `<scope>compile</scope>` dependency management dependencies as _dependency constraints_.
   ** the `platform-runtime` variant maps both the `<scope>compile</scope>` and `<scope>runtime</scope>` dependency management dependencies as _dependency constraints_.
   ** the `enforced-platform-compile` is similar to `platform-compile` but all the constraints are _forced_
   ** the `enforced-platform-runtime` is similar to `platform-runtime` but all the constraints are _forced_
   
   You can understand more about the use of platform and enforced platforms variants by looking at the <<platforms.adoc#sub:bom_import, importing BOMs>> section of the manual.
   By default, whenever you declare a dependency on a Maven module, Gradle is going to look for the `library` variants.
   However, using the `platform` or `enforcedPlatform` keyword, Gradle is now looking for one of the "platform" variants, which allows you to import the constraints from the POM files, instead of the dependencies.
   
   === Mapping of Ivy files to variants
   
   Gradle has no built-in derivation strategy implemented for Ivy files.
   Ivy is a flexible format that allows you to publish arbitrary files and can be heavily customized.
   
   If you want to implement a derivation strategy for _compile_ and _runtime_ variants for Ivy, you can do so with <<component_metadata_rules.adoc#sec:component_metadata_rules,component metadata rule>>.
   The component metadata rules API allows you to <<component_metadata_rules.adoc#sec:component_metadata_rules_details,access Ivy configurations>> and create variants based on them.
   If you know that all the Ivy modules your are consuming have been published with Gradle without further customizations of the `ivy.xml` file, you can add the following rule to your build:
   
   .Deriving compile and runtime variants for Ivy metadata
   ====
   include::sample[dir="snippets/dependencyManagement/customizingResolution-ivyMetadataRule/kotlin",files="build.gradle.kts[tags=ivy-component-metadata-rule]"]
   include::sample[dir="snippets/dependencyManagement/customizingResolution-ivyMetadataRule/groovy",files="build.gradle[tags=ivy-component-metadata-rule]"]
   ====
   
   The rule creates an `apiElements` variant based on the `compile` configuration and a `runtimeElements` variant based on the `default` configuration of each ivy module.
   For each variant, it sets the corresponding <<#sec:variant-aware-matching,Java ecosystem attributes>>.
   Dependencies and artifacts of the variants are taken from the underlying configurations.
   If not all consumed Ivy modules follow this pattern, the rule can be adjusted or only applied to a selected set of modules.
   
   For all Ivy modules without variants, Gradle has a fallback selection method. Gradle does _not_ perform variant aware resolution and instead selects either the `default` configuration or an explicitly named configuration.

/docs/userguide/dep-man/04-modeling-features/variant_attributes.adoc
====================================================================

.. code-block::

   = Working with Variant Attributes
   
   As explained in the section on <<variant_model.adoc#sec:variant-aware-matching,variant aware matching>>, attributes give semantics to variants and are used by Gradle's dependency management engine to select the best matching variant.
   
   As a user of Gradle, attributes are often hidden as implementation details.
   But it might be useful to understand the _standard attributes_ defined by Gradle and its core plugins.
   
   As a plugin author, these attributes, and the way they are defined, can serve as a basis for <<#sec:declaring_attributes,building your own set of attributes>> in your eco system plugin.
   
   == Standard attributes defined by Gradle
   
   Gradle defines a list of standard attributes used by Gradle's core plugins.
   
   === Ecosystem-independent standard attributes
   
   .Ecosystem-independent standard variant attributes
   [%header%autowidth,compact]
   |===
   | Attribute name | Description | Values | compatibility and disambiguation rules
   
   | link:{javadocPath}#[`org.gradle.usage`]
   | Indicates main purpose of variant
   | `Usage` values built from constants defined in link:{javadocPath}#[Usage]
   | Following ecosystem semantics (e.g. `java-runtime` can be used in place of `java-api` but not the opposite)
   
   | link:{javadocPath}#[`org.gradle.category`]
   | Indicates the category of this software component
   | `Category` values built from constants defined in link:{javadocPath}#[Category]
   | Following ecosystem semantics (e.g. `library` is default on the JVM, no compatibility otherwise)
   
   | link:{javadocPath}#[`org.gradle.libraryelements`]
   | Indicates the contents of a `org.gradle.category=library` variant
   | `LibraryElements` values built from constants defined in link:{javadocPath}#[LibraryElements]
   | Following ecosystem semantics(e.g. in the JVM world, `jar` is the default and is compatible with `classes`)
   
   | link:{javadocPath}#[`org.gradle.docstype`]
   | Indicates the contents of a `org.gradle.category=documentation` variant
   | `DocsType` values built from constants defined in link:{javadocPath}#[DocsType]
   | No default, no compatibility
   
   | link:{javadocPath}#[`org.gradle.dependency.bundling`]
   | Indicates how dependencies of a variant are accessed.
   | `Bundling` values built from constants defined in link:{javadocPath}#[Bundling]
   | Following ecosystem semantics (e.g. in the JVM world, `embedded` is compatible with `external`)
   
   | link:{javadocPath}#[`org.gradle.verificationtype`]
   | Indicates what kind of verification task produced this output.
   | `VerificationType` values built from constants defined in link:{javadocPath}#[VerificationType]
   | No default, no compatibility
   |===
   
   
   [WARNING]
   ====
   When the `Category` attribute is present with the incubating value `org.gradle.category=verification` on a variant, that variant is considered to be a verification-time only variant.
   
   These variants are meant to contain only the results of running verification tasks, such as test results or code coverage reports.
   They are *not publishable*, and will produce an error if added to a component which is published.
   ====
   
   .Ecosystem-independent standard component attributes
   [%header%autowidth,compact]
   |===
   | Attribute name | Description | Values | compatibility and disambiguation rules
   
   | `org.gradle.status`
   | Component level attribute, derived
   | Based on <<component_metadata_rules.adoc#sec:custom_status_scheme,a status scheme>>, with a default one existing based on the source repository.
   | Based on the scheme in use
   |===
   
   === JVM ecosystem specific attributes
   
   In addition to the ecosystem independent attributes defined above, the JVM ecosystem adds the following attribute:
   
   .JVM ecosystem standard component attributes
   [%header%autowidth,compact]
   |===
   | Attribute name | Description | Values | compatibility and disambiguation rules
   
   | link:{javadocPath}#[`org.gradle.jvm.version`]
   | Indicates the JVM version compatibility.
   | Integer using the version after the `1.` for Java 1.4 and before, the major version for Java 5 and beyond.
   | Defaults to the JVM version used by Gradle, lower is compatible with higher, prefers highest compatible.
   
   | link:{javadocPath}#[`org.gradle.jvm.environment`]
   | Indicates that a variant is optimized for a certain JVM environment.
   | Common values are `standard-jvm` and `android`. Other values are allowed.
   | The attribute is used to prefer one variant over another if multiple are available, but in general all values are compatible. The default is `standard-jvm`.
   
   | link:{javadocPath}#[`org.gradle.testsuite.name`]
   | Indicates the name of the link:{javadocPath}#[TestSuite] that produced this output.
   | Value is the name of the Suite.
   | No default, no compatibility
   
   | link:{javadocPath}#[`org.gradle.testsuite.target.name`]
   | Indicates the name of the link:{javadocPath}#[TestSuiteTarget] that produced this output.
   | Value is the name of the Target.
   | No default, no compatibility
   
   | link:{javadocPath}#[`org.gradle.testsuite.type`]
   | Indicates the type of test suite (unit test, integration test, performance test, etc.)
   | `TestSuiteType` values built from constants defined in link:{javadocPath}#[TestSuiteType] or other custom values for user-defined test suite types.
   | No default, no compatibility
   |===
   
   The JVM ecosystem also contains a number of compatibility and disambiguation rules over the different attributes.
   The reader willing to know more can take a look at the code for `org.gradle.api.internal.artifacts.JavaEcosystemSupport`.
   
   === Native ecosystem specific attributes
   
   In addition to the ecosystem independent attributes defined above, the native ecosystem adds the following attributes:
   
   .Native ecosystem standard component attributes
   [%header%autowidth,compact]
   |===
   | Attribute name | Description | Values | compatibility and disambiguation rules
   
   | link:{javadocPath}#[`org.gradle.native.debuggable`]
   | Indicates if the binary was built with debugging symbols
   | Boolean
   | N/A
   
   | link:{javadocPath}#[`org.gradle.native.optimized`]
   | Indicates if the binary was built with optimization flags
   | Boolean
   | N/A
   
   | link:{javadocPath}#[`org.gradle.native.architecture`]
   | Indicates the target architecture of the binary
   | `MachineArchitecture` values built from constants defined in link:{javadocPath}#[MachineArchitecture]
   | None
   
   | link:{javadocPath}#[`org.gradle.native.operatingSystem`]
   | Indicates the target operating system of the binary
   | `OperatingSystemFamily` values built from constants defined in link:{javadocPath}#[OperatingSystemFamily]
   | None
   |===
   
   === Gradle plugin ecosystem specific attributes
   
   For Gradle plugin development, the following attribute is supported since Gradle 7.0.
   A Gradle plugin variant can specify compatibility with a Gradle API version through this attribute.
   
   .Gradle plugin ecosystem standard component attributes
   [%header%autowidth,compact]
   |===
   | Attribute name | Description | Values | compatibility and disambiguation rules
   
   | link:{javadocPath}#[`org.gradle.plugin.api&#8209;version`]
   | Indicates the Gradle API version compatibility.
   | Valid Gradle version strings.
   | Defaults to the currently running Gradle, lower is compatible with higher, prefers highest compatible.
   |===
   
   == Declaring custom attributes
   
   If you are extending Gradle, e.g. by writing a plugin for another ecosystem, declaring custom attributes could be an option if you want to support variant-aware dependency management features in your plugin.
   However, you should be cautious if you also attempt to publish libraries.
   Semantics of new attributes are usually defined through a plugin, which can carry <<#sec:abm_compatibility_rules,compatibility>> and <<sec:abm_disambiguation_rules,disambiguation>> rules.
   Consequently, builds that consume libraries published for a certain ecosystem, also need to apply the corresponding plugin to interpret attributes correctly.
   If your plugin is intended for a larger audience, i.e. if it is openly available and libraries are published to public repositories, defining new attributes effectively extends the semantics of Gradle Module Metadata and comes with responsibilities.
   E.g., support for attributes that are already published should not be removed again, or should be handled in some kind of compatibility layer in future versions of the plugin.
   
   == Creating attributes in a build script or plugin
   
   Attributes are _typed_. An attribute can be created via the `Attribute<T>.of` method:
   
   .Define attributes
   ====
   include::sample[dir="snippets/dependencyManagement/attributeMatching/kotlin",files="build.gradle.kts[tags=define_attribute]"]
   include::sample[dir="snippets/dependencyManagement/attributeMatching/groovy",files="build.gradle[tags=define_attribute]"]
   ====
   
   Attribute types support most Java primitive classes; such as `String` and `Integer`; Or anything extending `org.gradle.api.Named`.
   Attributes must be declared in the _attribute schema_ found on the `dependencies` handler:
   
   .Registering attributes on the attributes schema
   ====
   include::sample[dir="snippets/dependencyManagement/attributeMatching/kotlin",files="build.gradle.kts[tags=register-attributes]"]
   include::sample[dir="snippets/dependencyManagement/attributeMatching/groovy",files="build.gradle[tags=register-attributes]"]
   ====
   
   Then configurations can be configured to set values for attributes:
   
   .Setting attributes on configurations
   ====
   include::sample[dir="snippets/dependencyManagement/attributeMatching/kotlin",files="build.gradle.kts[tags=attributes-on-configurations]"]
   include::sample[dir="snippets/dependencyManagement/attributeMatching/groovy",files="build.gradle[tags=attributes-on-configurations]"]
   ====
   
   For attributes which type extends `Named`, the value of the attribute **must** be created via the _object factory_:
   
   .Named attributes
   ====
   include::sample[dir="snippets/dependencyManagement/attributeMatching/kotlin",files="build.gradle.kts[tags=named-attributes]"]
   include::sample[dir="snippets/dependencyManagement/attributeMatching/groovy",files="build.gradle[tags=named-attributes]"]
   ====
   
   == Attribute matching
   
   === Attribute compatibility rules
   
   Attributes let the engine select _compatible variants_.
   There are cases where a producer may not have _exactly_ what the consumer requests but has a variant that can be used.
   
   For example, if the consumer is asking for the API of a library and the producer doesn't have an exactly matching variant, the _runtime_ variant could be considered compatible.
   This is typical of libraries published to external repositories.
   In this case, we know that even if we don't have an exact match (API), we can still compile against the runtime variant (it contains _more_ than what we need to compile but it's still ok to use).
   
   Gradle provides link:{javadocPath}#[attribute compatibility rules] that can be defined for each attribute.
   The role of a compatibility rule is to explain which attribute values are _compatible_ based on what the consumer asked for.
   
   Attribute compatibility rules have to be registered via the link:{javadocPath}#[attribute matching strategy] that you can obtain from the link:{javadocPath}#[attributes schema].
   
   === Attribute disambiguation rules
   
   Since multiple values for an attribute can be _compatible_, Gradle needs to choose the "best" candidate between all compatible candidates. This is called "disambiguation".
   
   This is done by implementing an link:{javadocPath}#[attribute disambiguation rule].
   
   Attribute disambiguation rules have to be registered via the link:{javadocPath}#[attribute matching strategy] that you can obtain from the link:{javadocPath}#[attributes schema], which is a member of link:{javadocPath}#[DependencyHandler].
   === Variant attribute matching algorithm
   
   Finding the best variant can get complicated when there are many different variants available for a component and many different attributes. Gradle's dependency resolution engine performs the following algorithm when finding the best result (or failing):
   
   1. Each candidate's attribute value is compared to the consumer's requested attribute value. A candidate is considered compatible if its value matches the consumer's value exactly, passes the attribute's compatibility rule or is not provided.
   2. If only one candidate is considered compatible, that candidate wins.
   3. If several candidates are compatible, but one of the candidates matches all of the same attributes as the other candidates, Gradle chooses that candidate. This is the candidate with the "longest" match.
   4. If several candidates are compatible and are compatible with an equal number of attributes, Gradle needs to disambiguate the candidates.
       a. For each requested attribute, if a candidate does not have a value matching the disambiguation rule, it's eliminated from consideration.
       b. If the attribute has a known precedence, Gradle will stop as soon as there is a single candidate remaining.
       c. If the attribute does not have a known precedence, Gradle must consider all attributes.
   5. If several candidates still remain, Gradle will start to consider "extra" attributes to disambiguate between multiple candidates. Extra attributes are attributes that were not requested by the consumer but are present on at least one candidate. These extra attributes are considered in precedence order.
       a. If the attribute has a known precedence, Gradle will stop as soon as there is a single candidate remaining.
       b. After all extra attributes with precedence are considered, the remaining candidates can be chosen if they are compatible with all of the non-ordered disambiguation rules.
   6. If several candidates still remain, Gradle will consider extra attributes again. A candidate can be chosen if it has the fewest number of extra attributes.
   
   If at any step no candidates remain compatible, resolution fails.
   Additionally, Gradle outputs a list of all compatible candidates from step 1 to help with debugging variant matching failures.
   
   Plugins and ecosystems can influence the selection algorithm by implementing compatibility rules, disambiguation rules and telling Gradle the precedence of attributes. Attributes with a higher precedence are used to eliminate compatible matches in order.
   
   For example, in the Java ecosystem, the `org.gradle.usage` attribute has a higher precedence than `org.gradle.libraryelements`. This means that if two candidates were available with compatible values for both `org.gradle.usage` and `org.gradle.libraryelements`, Gradle will choose the candidate that passes the disambiguation rule for `org.gradle.usage`.

/docs/userguide/dep-man/04-modeling-features/cross_project_publications.adoc
============================================================================

.. code-block::

   = Sharing outputs between projects
   
   A common pattern, in multi-project builds, is that one project consumes the artifacts of another project.
   In general, the simplest consumption form in the Java ecosystem is that when `A` depends on `B`, then `A` would depend on the `jar` produced by project `B`.
   As previously described in this chapter, this is modeled by `A` depending on a _variant of_ `B`, where the variant is selected based on the needs of `A`.
   For compilation, we need the API dependencies of `B`, provided by the `apiElements` variant.
   For runtime, we need the runtime dependencies of `B`, provided by the `runtimeElements` variant.
   
   However, what if you need a _different_ artifact than the main one?
   Gradle provides, for example, built-in support for depending on the <<java_testing.adoc#sec:java_test_fixtures,test fixtures>> of another project, but sometimes the artifact you need to depend on simply isn't exposed as a variant.
   
   In order to be _safe to share_ between projects and allow maximum performance (parallelism), such artifacts must be exposed via _outgoing configurations_.
   
   .Don't reference other project tasks directly
   --
   A frequent anti-pattern to declare cross-project dependencies is:
   
   [source,groovy]
   ----
   dependencies {
      // this is unsafe!
      implementation project(":other").tasks.someOtherJar
   }
   ----
   
   This publication model is _unsafe_ and can lead to non-reproducible and hard to parallelize builds.
   This section explains how to _properly create cross-project boundaries_ by defining "exchanges" between projects by using _variants_.
   --
   
   There are two, complementary, options to share artifacts between projects.
   The <<#sec:simple-sharing-artifacts-between-projects,simplified version>> is only suitable if what you need to share is a simple artifact that doesn't depend on the consumer.
   The simple solution is also limited to cases where this artifact is not published to a repository.
   This also implies that the consumer does not publish a dependency to this artifact.
   In cases where the consumer resolves to different artifacts in different contexts (e.g., different target platforms) or that publication is required, you need to use the <<#sec:variant-aware-sharing,advanced version>>.
   
   == Simple sharing of artifacts between projects
   
   First, a producer needs to declare a configuration which is going to be _exposed_ to consumers.
   As explained in the <<declaring_dependencies.adoc#sec:resolvable-consumable-configs, configurations chapter>>, this corresponds to a _consumable configuration_.
   
   Let's imagine that the consumer requires _instrumented classes_ from the producer, but that this artifact is _not_ the main one.
   The producer can expose its instrumented classes by creating a configuration that will "carry" this artifact:
   
   .Declaring an outgoing variant
   ====
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-simple/kotlin",files="producer/build.gradle.kts[tags=declare-outgoing-configuration]"]
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-simple/groovy",files="producer/build.gradle[tags=declare-outgoing-configuration]"]
   ====
   
   This configuration is _consumable_, which means it's an "exchange" meant for consumers.
   We're now going to add artifacts to this configuration, that consumers would get when they consume it:
   
   .Attaching an artifact to an outgoing configuration
   ====
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-simple/kotlin",files="producer/build.gradle.kts[tags=attach-outgoing-artifact]"]
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-simple/groovy",files="producer/build.gradle[tags=attach-outgoing-artifact]"]
   ====
   
   Here the "artifact" we're attaching is a _task_ that actually generates a Jar.
   Doing so, Gradle can automatically track dependencies of this task and build them as needed.
   This is possible because the `Jar` task extends `AbstractArchiveTask`.
   If it's not the case, you will need to explicitly declare how the artifact is generated.
   
   .Explicitly declaring the task dependency of an artifact
   ====
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-simple/kotlin",files="producer/build.gradle.kts[tags=attach-outgoing-artifact-explicit]"]
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-simple/groovy",files="producer/build.gradle[tags=attach-outgoing-artifact-explicit]"]
   ====
   
   Now the _consumer_ needs to depend on this configuration in order to get the right artifact:
   
   .An explicit configuration dependency
   ====
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-simple/kotlin",files="consumer/build.gradle.kts[tags=explicit-configuration-dependency]"]
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-simple/groovy",files="consumer/build.gradle[tags=explicit-configuration-dependency]"]
   ====
   
   WARNING: Declaring a dependency on an explicit target configuration is _not recommended_.
   If you plan to publish the component which has this dependency, this will likely lead to broken metadata.
   If you need to publish the component on a remote repository, follow the instructions of the <<#sec:variant-aware-sharing,variant-aware cross publication documentation>>.
   
   In this case, we're adding the dependency to the _instrumentedClasspath_ configuration, which is a _consumer specific configuration_.
   In Gradle terminology, this is called a <<declaring_dependencies.adoc#sec:resolvable-consumable-configs,resolvable configuration>>, which is defined this way:
   
   .Declaring a resolvable configuration on the consumer
   ====
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-simple/kotlin",files="consumer/build.gradle.kts[tags=resolvable-configuration]"]
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-simple/groovy",files="consumer/build.gradle[tags=resolvable-configuration]"]
   ====
   
   == Variant-aware sharing of artifacts between projects
   
   In the <<#sec:simple-sharing-artifacts-between-projects, simple sharing solution>>, we defined a configuration on the producer side which serves as an exchange of artifacts between the producer and the consumer.
   However, the consumer has to explicitly tell which configuration it depends on, which is something we want to avoid in _variant aware resolution_.
   In fact, we also <<variant_model.adoc#understanding-variant-selection, have explained>> that it is possible for a consumer to express requirements using _attributes_ and that the producer should provide the appropriate outgoing variants using attributes too.
   This allows for smarter selection, because using a single dependency declaration, without any explicit target configuration, the consumer may resolve different things.
   The typical example is that using a single dependency declaration `project(":myLib")`, we would either choose the `arm64` or `i386` version of `myLib` depending on the architecture.
   
   To do this, we will add attributes to both the consumer and the producer.
   
   --
   It is important to understand that once configurations have attributes, they participate in _variant aware resolution_, which means that they are candidates considered whenever _any_ notation like `project(":myLib")` is used.
   In other words, the attributes set on the producer _must be consistent with the other variants produced on the same project_.
   They must not, in particular, introduce ambiguity for the existing selection.
   
   In practice, it means that the attribute set used on the configuration you create are likely to be dependent on the _ecosystem_ in use (Java, C++, ...) because the relevant plugins for those ecosystems often use different attributes.
   --
   
   Let's enhance our previous example which happens to be a Java Library project.
   Java libraries expose a couple of variants to their consumers, `apiElements` and `runtimeElements`. Now, we're adding a 3rd one, `instrumentedJars`.
   
   Therefore, we need to understand what our new variant is used for in order to set the proper attributes on it.
   Let's look at the attributes we find on the `runtimeElements` configuration on the producer:
   
   .gradle outgoingVariants --variant runtimeElements
   ----
   Attributes
       - org.gradle.category            = library
       - org.gradle.dependency.bundling = external
       - org.gradle.jvm.version         = 11
       - org.gradle.libraryelements     = jar
       - org.gradle.usage               = java-runtime
   ----
   
   What it tells us is that the Java Library plugin produces variants with 5 attributes:
   
   - `org.gradle.category` tells us that this variant represents a _library_
   - `org.gradle.dependency.bundling` tells us that the dependencies of this variant are found as jars (they are not, for example, repackaged inside the jar)
   - `org.gradle.jvm.version` tells us that the minimum Java version this library supports is Java 11
   - `org.gradle.libraryelements` tells us this variant contains all elements found in a jar (classes and resources)
   - `org.gradle.usage` says that this variant is a Java runtime, therefore suitable for a Java compiler but also at runtime
   
   As a consequence, if we want our instrumented classes to be used in place of this variant when executing tests, we need to attach similar attributes to our variant.
   In fact, the attribute we care about is `org.gradle.libraryelements` which explains _what the variant contains_, so we can setup the variant this way:
   
   .Declaring the variant attributes
   ====
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-advanced/kotlin",files="producer/build.gradle.kts[tags=declare-outgoing-configuration]"]
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-advanced/groovy",files="producer/build.gradle[tags=declare-outgoing-configuration]"]
   ====
   
   [NOTE]
   ====
   Choosing the right attributes to set is the hardest thing in this process, because they carry the semantics of the variant.
   Therefore, before adding _new attributes_, you should always ask yourself if there isn't an attribute which carries the semantics you need.
   If there isn't, then you may add a new attribute.
   When adding new attributes, you must also be careful because it's possible that it creates ambiguity during selection.
   Often adding an attribute means adding it to _all_ existing variants.
   ====
   
   What we have done here is that we have added a _new_ variant, which can be used _at runtime_, but contains instrumented classes instead of the normal classes.
   However, it now means that for runtime, the consumer has to choose between two variants:
   
   - `runtimeElements`, the regular variant offered by the `java-library` plugin
   - `instrumentedJars`, the variant we have created
   
   In particular, say we want the instrumented classes on the test runtime classpath.
   We can now, on the consumer, declare our dependency as a regular project dependency:
   
   .Declaring the project dependency
   ====
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-advanced/kotlin",files="consumer/build.gradle.kts[tags=test_dependency]"]
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-advanced/groovy",files="consumer/build.gradle[tags=test_dependency]"]
   ====
   
   If we stop here, Gradle will still select the `runtimeElements` variant in place of our `instrumentedJars` variant.
   This is because the `testRuntimeClasspath` configuration asks for a configuration which `libraryelements` attribute is `jar`, and our new `instrumented-jars` value is _not compatible_.
   
   So we need to change the requested attributes so that we now look for instrumented jars:
   
   .Changing the consumer attributes
   ====
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-advanced/kotlin",files="consumer/build.gradle.kts[tags=ask-for-instrumented-classes]"]
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-advanced/groovy",files="consumer/build.gradle[tags=ask-for-instrumented-classes]"]
   ====
   
   We can look at another report _on the consumer side_ to view exactly what attributes of each dependency will be requested:
   
   .gradle resolvableConfigurations --configuration testRuntimeClasspath
   ----
   Attributes
       - org.gradle.category            = library
       - org.gradle.dependency.bundling = external
       - org.gradle.jvm.version         = 11
       - org.gradle.libraryelements     = instrumented-jar
       - org.gradle.usage               = java-runtime
   ----
   
   The `resolvableConfigurations` report is the complement of the `outgoingVariants` report.
   By running both of these reports on the consumer and producer sides of a relationship, respectively, you can see exactly what attributes are involved in matching during dependency resolution and better predict the outcome when configurations are resolved.
   
   Now, we're saying that whenever we're going to resolve the test runtime classpath, what we are looking for is _instrumented classes_.
   There is a problem though: in our dependencies list, we have JUnit, which, obviously, is _not_ instrumented.
   So if we stop here, Gradle is going to fail, explaining that there's no variant of JUnit which provide instrumented classes.
   This is because we didn't explain that it's fine to use the regular jar, if no instrumented version is available.
   To do this, we need to write a _compatibility rule_:
   
   .A compatibility rule
   ====
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-advanced/kotlin",files="consumer/build.gradle.kts[tags=compatibility-rule]"]
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-advanced/groovy",files="consumer/build.gradle[tags=compatibility-rule]"]
   ====
   
   which we need to declare on the attributes schema:
   
   .Making use of the compatibility rule
   ====
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-advanced/kotlin",files="consumer/build.gradle.kts[tags=compatibility-rule-use]"]
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-advanced/groovy",files="consumer/build.gradle[tags=compatibility-rule-use]"]
   ====
   
   And that's it! Now we have:
   
   - added a variant which provides instrumented jars
   - explained that this variant is a substitute for the runtime
   - explained that the consumer needs this variant _only for test runtime_
   
   Gradle therefore offers a powerful mechanism to select the right variants based on preferences and compatibility.
   More details can be found in the <<variant_attributes.adoc#variant_attributes, variant aware plugins section of the documentation>>.
   
   [WARNING]
   ====
   By adding a value to an existing attribute like we have done, or by defining new attributes, we are extending the model.
   This means that _all consumers_ have to know about this extended model.
   
   For local consumers, this is usually not a problem because all projects understand and share the same schema, but if you had to publish this new variant to an external repository, it means that external consumers would have to add the same rules to their builds for them to pass.
   This is in general not a problem for _ecosystem plugins_ (e.g: the Kotlin plugin) where consumption is in any case not possible without applying the plugin, but it is a problem if you add custom values or attributes.
   
   So, **avoid publishing custom variants** if they are for internal use only.
   ====
   
   == Targeting different platforms
   
   It is common for a library to target different platforms.
   In the Java ecosystem, we often see different artifacts for the same library, distinguished by a different _classifier_.
   A typical example is Guava, which is published as this:
   
   - `guava-jre` for JDK 8 and above
   - `guava-android` for JDK 7
   
   The problem with this approach is that there's no semantics associated with the classifier.
   The dependency resolution engine, in particular, cannot determine automatically which version to use based on the consumer requirements.
   For example, it would be better to express that you have a dependency on Guava, and let the engine choose between `jre` and `android` based on what is compatible.
   
   Gradle provides an improved model for this, which doesn't have the weakness of classifiers: attributes.
   
   In particular, in the Java ecosystem, Gradle provides a built-in attribute that library authors can use to express compatibility with the Java ecosystem: `org.gradle.jvm.version`.
   This attribute expresses the _minimal version that a consumer must have in order to work properly_.
   
   When you apply the `java` or `java-library` plugins, Gradle will automatically associate this attribute to the outgoing variants.
   This means that all libraries published with Gradle automatically tell which target platform they use.
   
   By default, the `org.gradle.jvm.version` is set to the value of the <<building_java_projects#sec:java_cross_compilation,`release` property>> (or as fallback to the `targetCompatibility` value) of the main compilation task of the source set.
   
   While this attribute is automatically set, Gradle _will not_, by default, let you build a project for different JVMs.
   If you need to do this, then you will need to create additional variants following the <<#sec:variant-aware-sharing,instructions on variant-aware matching>>.
   
   NOTE: Future versions of Gradle will provide ways to automatically build for different Java platforms.

/docs/userguide/dep-man/04-modeling-features/artifact_transforms.adoc
=====================================================================

.. code-block::

   = Transforming dependency artifacts on resolution
   
   As described in <<declaring_dependencies.adoc#sec:resolvable-consumable-configs,different kinds of configurations>>, there may be different variants for the same dependency.
   For example, an external Maven dependency has a variant which should be used when compiling against the dependency (`java-api`), and a variant for running an application which uses the dependency (`java-runtime`).
   A project dependency has even more variants, for example the classes of the project which are used for compilation are available as classes directories (`org.gradle.usage=java-api, org.gradle.libraryelements=classes`) or as JARs (`org.gradle.usage=java-api, org.gradle.libraryelements=jar`).
   
   The variants of a dependency may differ in its transitive dependencies or in the artifact itself.
   For example, the `java-api` and `java-runtime` variants of a Maven dependency only differ in the transitive dependencies and both use the same artifact  the JAR file.
   For a project dependency, the `java-api,classes` and the `java-api,jars` variants have the same transitive dependencies and different artifacts  the classes directories and the JAR files respectively.
   
   Gradle identifies a variant of a dependency uniquely by its set of <<variant_model.adoc#sec:abm_configuration_attributes,attributes>>.
   The `java-api` variant of a dependency is the variant identified by the `org.gradle.usage` attribute with value `java-api`.
   
   When Gradle resolves a configuration, the <<variant_model.adoc#sec:abm_configuration_attributes,attributes>> on the resolved configuration determine the _requested attributes_.
   For all dependencies in the configuration, the variant with the requested attributes is selected when resolving the configuration.
   For example, when the configuration requests `org.gradle.usage=java-api, org.gradle.libraryelements=classes` on a project dependency, then the classes directory is selected as the artifact.
   
   When the dependency does not have a variant with the requested attributes, resolving the configuration fails.
   Sometimes it is possible to transform the artifact of the dependency into the requested variant without changing the transitive dependencies.
   For example, unzipping a JAR transforms the artifact of the `java-api,jars` variant into the `java-api,classes` variant.
   Such a transformation is called _Artifact Transform_.
   Gradle allows registering artifact transforms, and when the dependency does not have the requested variant, then Gradle will try to find a chain of artifact transforms for creating the variant.
   
   == Artifact transform selection and execution
   
   As described above, when Gradle resolves a configuration and a dependency in the configuration does not have a variant with the requested attributes, Gradle tries to find a chain of artifact transforms to create the variant.
   The process of finding a matching chain of artifact transforms is called _artifact transform selection_.
   Each registered transform converts from a set of attributes to a set of attributes.
   For example, the unzip transform can convert from `org.gradle.usage=java-api, org.gradle.libraryelements=jars` to `org.gradle.usage=java-api, org.gradle.libraryelements=classes`.
   
   In order to find a chain, Gradle starts with the requested attributes and then considers all transforms which modify some of the requested attributes as possible paths leading there.
   Going backwards, Gradle tries to obtain a path to some existing variant using transforms.
   
   For example, consider a `minified` attribute with two values: `true` and `false`.
   The minified attribute represents a variant of a dependency with unnecessary class files removed.
   There is an artifact transform registered, which can transform `minified` from `false` to `true`.
   When `minified=true` is requested for a dependency, and there are only variants with `minified=false`, then Gradle selects the registered minify transform.
   The minify transform is able to transform the artifact of the dependency with `minified=false` to the artifact with `minified=true`.
   
   Of all the found transform chains, Gradle tries to select the best one:
   
   - If there is only one transform chain, it is selected.
   - If there are two transform chains, and one is a suffix of the other one, it is selected.
   - If there is a shortest transform chain, then it is selected.
   - In all other cases, the selection fails and an error is reported.
   
   IMPORTANT: Gradle does not try to select artifact transforms when there is already a variant of the dependency matching the requested attributes.
   
   [NOTE]
   ====
   The `artifactType` attribute is special, since it is only present on resolved artifacts and not on dependencies.
   As a consequence, any transform which is only mutating `artifactType` will never be selected when resolving a configuration with only the `artifactType` as requested attribute.
   It will only be considered when using an link:{javadocPath}#[ArtifactView].
   ====
   
   After selecting the required artifact transforms, Gradle resolves the variants of the dependencies which are necessary for the initial transform in the chain.
   As soon as Gradle finishes resolving the artifacts for the variant, either by downloading an external dependency or executing a task producing the artifact, Gradle starts transforming the artifacts of the variant with the selected chain of artifact transforms.
   Gradle executes the transform chains in parallel when possible.
   
   Picking up the minify example above, consider a configuration with two dependencies, the external `guava` dependency and a project dependency on the `producer` project.
   The configuration has the attributes `org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=true`.
   The external `guava` dependency has two variants:
   
   - `org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=false` and
   - `org.gradle.usage=java-api,org.gradle.libraryelements=jar,minified=false`.
   
   Using the minify transform, Gradle can convert the variant `org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=false` of `guava` to `org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=true`, which are the requested attributes.
   The project dependency also has variants:
   
   - `org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=false`,
   - `org.gradle.usage=java-runtime,org.gradle.libraryelements=classes,minified=false`,
   - `org.gradle.usage=java-api,org.gradle.libraryelements=jar,minified=false`,
   - `org.gradle.usage=java-api,org.gradle.libraryelements=classes,minified=false`
   - and a few more.
   
   Again, using the minify transform, Gradle can convert the variant `org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=false` of the project `producer` to `org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=true`, which are the requested attributes.
   
   When the configuration is resolved, Gradle needs to download the `guava` JAR and minify it.
   Gradle also needs to execute the `producer:jar` task to generate the JAR artifact of the project and then minify it.
   The downloading and the minification of the `guava.jar` happens in parallel to the execution of the `producer:jar` task and the minification of the resulting JAR.
   
   Here is how to setup the `minified` attribute so that the above works.
   You need to register the new attribute in the schema, add it to all JAR artifacts and request it on all resolvable configurations.
   
   .Artifact transform attribute setup
   ====
   include::sample[dir="snippets/dependencyManagement/artifactTransforms-minify/kotlin",files="build.gradle.kts[tags=artifact-transform-attribute-setup]"]
   include::sample[dir="snippets/dependencyManagement/artifactTransforms-minify/groovy",files="build.gradle[tags=artifact-transform-attribute-setup]"]
   ====
   <1> Add the attribute to the schema
   <2> All JAR files are not minified
   <3> Request `minified=true` on all resolvable configurations
   <4> Add the dependencies which will be transformed
   <5> Add task that requires the transformed artifacts
   
   You can now see what happens when we run the `resolveRuntimeClasspath` task which resolves the `runtimeClasspath` configuration.
   Observe that Gradle transforms the project dependency before the `resolveRuntimeClasspath` task starts.
   Gradle transforms the binary dependencies when it executes the `resolveRuntimeClasspath` task.
   
   .Output when resolving the runtimeClasspath configuration
   ----
   > gradle resolveRuntimeClasspath
   
   include::{snippetsPath}/dependencyManagement/artifactTransforms-minify/tests/artifactTransformMinify.out[]
   ----
   
   == Implementing artifact transforms
   
   Similar to task types, an artifact transform consists of an action and some parameters.
   The major difference to custom task types is that the action and the parameters are implemented as two separate classes.
   
   The implementation of the artifact transform action is a class implementing link:{groovyDslPath}#[TransformAction].
   You need to implement the `transform()` method on the action, which converts an input artifact into zero, one or multiple of output artifacts.
   Most artifact transforms will be one-to-one, so the transform method will transform the input artifact to exactly one output artifact.
   
   The implementation of the artifact transform action needs to register each output artifact by calling
    link:{groovyDslPath}#[TransformOutputs.dir()] or link:{groovyDslPath}#[TransformOutputs.file()].
   
   You can only supply two types of paths to the `dir` or `file` methods:
   
   - An absolute path to the input artifact or in the input artifact (for an input directory).
   - A relative path.
   
   Gradle uses the absolute path as the location of the output artifact.
   For example, if the input artifact is an exploded WAR, then the transform action can call `TransformOutputs.file()` for all jar files in the `WEB-INF/lib` directory.
   The output of the transform would then be the library JARs of the web application.
   
   For a relative path, the `dir()` or `file()` method returns a workspace to the transform action.
   The implementation of the transform action needs to create the transformed artifact at the location of the provided workspace.
   
   The output artifacts replace the input artifact in the transformed variant in the order they were registered.
   For example, if the configuration consists of the artifacts `lib1.jar`, `lib2.jar`, `lib3.jar`, and the transform action registers a minified output artifact `<artifact-name>-min.jar` for the input artifact, then the transformed configuration consists of the artifacts `lib1-min.jar`, `lib2-min.jar` and `lib3-min.jar`.
   
   Here is the implementation of an `Unzip` transform which transforms a JAR file into a classes directory by unzipping it.
   The `Unzip` transform does not require any parameters.
   Note how the implementation uses `@InputArtifact` to inject the artifact to transform into the action.
   It requests a directory for the unzipped classes by using `TransformOutputs.dir()` and then unzips the JAR file into this directory.
   
   .Artifact transform without parameters
   ====
   include::sample[dir="snippets/dependencyManagement/artifactTransforms-unzip/kotlin",files="build.gradle.kts[tags=artifact-transform-unzip]"]
   include::sample[dir="snippets/dependencyManagement/artifactTransforms-unzip/groovy",files="build.gradle[tags=artifact-transform-unzip]"]
   ====
   <1> Use `TransformParameters.None` if the transform does not use parameters
   <2> Inject the input artifact
   <3> Request an output location for the unzipped files
   <4> Do the actual work of the transform
   
   An artifact transform may require parameters, like a `String` determining some filter, or some file collection which is used for supporting the transformation of the input artifact.
   In order to pass those parameters to the transform action, you need to define a new type with the desired parameters.
   The type needs to implement the marker interface link:{javadocPath}#[TransformParameters].
   The parameters must be represented using <<custom_gradle_types.adoc#managed_properties,managed properties>> and the parameters type must be a <<custom_gradle_types.adoc#managed_types,managed type>>.
   You can use an interface or abstract class declaring the getters and Gradle will generate the implementation.
   All getters need to have proper input annotations, see <<incremental_build.adoc#table:incremental_build_annotations,incremental build annotations>> table.
   
   You can find out more about implementing artifact transform parameters in <<custom_gradle_types.adoc#custom_gradle_types,Developing Custom Gradle Types>>.
   
   Here is the implementation of a `Minify` transform that makes JARs smaller by only keeping certain classes in them.
   The `Minify` transform requires the classes to keep as parameters.
   Observe how you can obtain the parameters by `TransformAction.getParameters()` in the `transform()` method.
   The implementation of the `transform()` method requests a location for the minified JAR by using `TransformOutputs.file()` and then creates the minified JAR at this location.
   
   .Minify transform implementation
   ====
   include::sample[dir="snippets/dependencyManagement/artifactTransforms-minify/kotlin",files="build.gradle.kts[tags=artifact-transform-minify]"]
   include::sample[dir="snippets/dependencyManagement/artifactTransforms-minify/groovy",files="build.gradle[tags=artifact-transform-minify]"]
   ====
   <1> Declare the parameter type
   <2> Interface for the transform parameters
   <3> Use the parameters
   <4> Use the unchanged input artifact when no minification is required
   
   Remember that the input artifact is a dependency, which may have its own dependencies.
   If your artifact transform needs access to those transitive dependencies, it can declare an abstract getter returning a `FileCollection` and annotate it with link:{javadocPath}#[@InputArtifactDependencies].
   When your transform runs, Gradle will inject the transitive dependencies into that `FileCollection` property by implementing the getter.
   Note that using input artifact dependencies in a transform has performance implications, only inject them when you really need them.
   
   Moreover, artifact transforms can make use of the <<build_cache.adoc#build_cache,build cache>> for their outputs.
   To enable the build cache for an artifact transform, add the `@link:{javadocPath}#[CacheableTransform]` annotation on the action class.
   For cacheable transforms, you must annotate its link:{javadocPath}#[@InputArtifact] property  and any property marked with link:{javadocPath}#[@InputArtifactDependencies]  with normalization annotations such as link:{javadocPath}#[@PathSensitive].
   
   The following example shows a more complicated transform.
   It moves some selected classes of a JAR to a different package, rewriting the byte code of the moved classes and all classes using the moved classes (class relocation).
   In order to determine the classes to relocate, it looks at the packages of the input artifact and the dependencies of the input artifact.
   It also does not relocate packages contained in JAR files in an external classpath.
   
   .Artifact transform for class relocation
   ====
   include::sample[dir="snippets/dependencyManagement/artifactTransforms-relocate/kotlin",files="build.gradle.kts[tags=artifact-transform-relocate]"]
   include::sample[dir="snippets/dependencyManagement/artifactTransforms-relocate/groovy",files="build.gradle[tags=artifact-transform-relocate]"]
   ====
   <1> Declare the transform cacheable
   <2> Interface for the transform parameters
   <3> Declare input type for each parameter
   <4> Declare a normalization for the input artifact
   <5> Inject the input artifact dependencies
   <6> Use the parameters
   
   == Registering artifact transforms
   
   You need to register the artifact transform actions, providing parameters if necessary, so that they can be selected when resolving dependencies.
   
   In order to register an artifact transform, you must use link:{groovyDslPath}#[registerTransform()] within the `dependencies {}` block.
   
   There are a few points to consider when using `registerTransform()`:
   
   - The `from` and `to` attributes are required.
   - The transform action itself can have configuration options. You can configure them with the `parameters {}` block.
   - You must register the transform on the project that has the configuration that will be resolved.
   - You can supply any type implementing link:{groovyDslPath}#[TransformAction] to the `registerTransform()` method.
   
   For example, imagine you want to unpack some dependencies and put the unpacked directories and files on the classpath.
   You can do so by registering an artifact transform action of type `Unzip`, as shown here:
   
   .Artifact transform registration without parameters
   ====
   include::sample[dir="snippets/dependencyManagement/artifactTransforms-unzip/kotlin",files="build.gradle.kts[tags=artifact-transform-registration]"]
   include::sample[dir="snippets/dependencyManagement/artifactTransforms-unzip/groovy",files="build.gradle[tags=artifact-transform-registration]"]
   ====
   
   Another example is that you want to minify JARs by only keeping some `class` files from them.
   Note the use of the `parameters {}` block to provide the classes to keep in the minified JARs to the `Minify` transform.
   
   .Artifact transform registration with parameters
   ====
   include::sample[dir="snippets/dependencyManagement/artifactTransforms-minify/kotlin",files="build.gradle.kts[tags=artifact-transform-registration]"]
   include::sample[dir="snippets/dependencyManagement/artifactTransforms-minify/groovy",files="build.gradle[tags=artifact-transform-registration]"]
   ====
   
   == Implementing incremental artifact transforms
   
   Similar to <<custom_tasks#incremental_tasks,incremental tasks>>, artifact transforms can avoid work by only processing changed files from the last execution.
   This is done by using the link:{groovyDslPath}#[InputChanges] interface.
   For artifact transforms, only the input artifact is an incremental input, and therefore the transform can only query for changes there.
   In order to use link:{groovyDslPath}#[InputChanges] in the transform action, inject it into the action.
   For more information on how to use link:{groovyDslPath}#[InputChanges], see the corresponding documentation for <<custom_tasks#incremental_tasks,incremental tasks>>.
   
   Here is an example of an incremental transform that counts the lines of code in Java source files:
   
   .Artifact transform for lines of code counting
   ====
   include::sample[dir="snippets/dependencyManagement/artifactTransforms-incremental/kotlin",files="build.gradle.kts[tags=artifact-transform-countloc]"]
   include::sample[dir="snippets/dependencyManagement/artifactTransforms-incremental/groovy",files="build.gradle[tags=artifact-transform-countloc]"]
   ====
   <1> Inject `InputChanges`
   <2> Query for changes in the input artifact
   
   // TODO: https://github.com/gradle/gradle/issues/10867
   // == Artifact resolution queries

/Section: 游릭 Publishing Libraries
===================================


/docs/userguide/dep-man/06-publishing/publishing_setup.adoc
===========================================================

.. code-block::

   = Publishing a project as module
   
   The vast majority of software projects build something that aims to be consumed in some way.
   It could be a library that other software projects use or it could be an application for end users.
   _Publishing_ is the process by which the thing being built is made available to consumers.
   
   In Gradle, that process looks like this:
   
   1. Define <<#publishing_overview:what,what>> to publish
   2. Define <<#publishing_overview:where,where>> to publish it to
   3. <<#publishing_overview:how,Do>> the publishing
   
   Each of the these steps is dependent on the type of repository to which you want to publish artifacts.
   The two most common types are Maven-compatible and Ivy-compatible repositories, or Maven and Ivy repositories for short.
   
   As of Gradle 6.0, the <<publishing_gradle_module_metadata.adoc#sec:understanding-gradle-module-md,Gradle Module Metadata>> will always be published alongside the Ivy XML or Maven POM metadata file.
   
   Gradle makes it easy to publish to these types of repository by providing some prepackaged infrastructure in the form of the <<publishing_maven.adoc#publishing_maven,Maven Publish Plugin>> and the <<publishing_ivy.adoc#publishing_ivy,Ivy Publish Plugin>>.
   These plugins allow you to configure what to publish and perform the publishing with a minimum of effort.
   
   .The publishing process
   image::publishing-process.png[]
   
   Let's take a look at those steps in more detail:
   
   What to publish::
   Gradle needs to know what files and information to publish so that consumers can use your project.
   This is typically a combination of <<dependency_management_terminology.adoc#sub:terminology_artifact,artifacts>> and metadata that Gradle calls a <<dependency_management_terminology.adoc#sub:terminology_publication,publication>>.
   Exactly what a publication contains depends on the type of repository it's being published to.
   +
   For example, a publication destined for a Maven repository includes:
   +
   * One or more artifacts  typically built by the project,
   * The Gradle Module Metadata file which will describe the variants of the published component,
   * The Maven POM file will identify the primary artifact and its dependencies.
   The primary artifact is typically the project's production JAR and secondary artifacts might consist of "-sources" and "-javadoc" JARs.
   
   +
   In addition, Gradle will publish checksums for all of the above, and <<publishing_signing.adoc#publishing_maven:signing,signatures>> when configured to do so.
   From Gradle 6.0 onwards, this includes `SHA256` and `SHA512` checksums.
   
   Where to publish::
   Gradle needs to know where to publish artifacts so that consumers can get hold of them. This is done via <<dependency_management_terminology.adoc#sub:terminology_repository,repositories>>, which store and make available all sorts of artifact.
   Gradle also needs to interact with the repository, which is why you must provide the type of the repository and its location.
   
   How to publish::
   Gradle automatically generates publishing tasks for all possible combinations of publication and repository, allowing you to publish any artifact to any repository. If you're publishing to a Maven repository, the tasks are of type link:{groovyDslPath}#[PublishToMavenRepository], while for Ivy repositories the tasks are of type link:{groovyDslPath}#[PublishToIvyRepository].
   
   What follows is a practical example that demonstrates the entire publishing process.
   
   == Setting up basic publishing
   
   The first step in publishing, irrespective of your project type, is to apply the appropriate publishing plugin. As mentioned in the introduction, Gradle supports both Maven and Ivy repositories via the following plugins:
   
   * <<publishing_maven.adoc#publishing_maven,Maven Publish Plugin>>
   * <<publishing_ivy.adoc#publishing_ivy,Ivy Publish Plugin>>
   
   These provide the specific publication and repository classes needed to configure publishing for the corresponding repository type. Since Maven repositories are the most commonly used ones, they will be the basis for this example and for the other samples in the chapter. Don't worry, we will explain how to adjust individual samples for Ivy repositories.
   
   Let's assume we're working with a simple Java library project, so only the following plugins are applied:
   
   .Applying the necessary plugins
   ====
   include::sample[dir="snippets/publishing/javaLibrary/kotlin",files="build.gradle.kts[tags=apply-plugins]"]
   include::sample[dir="snippets/publishing/javaLibrary/groovy",files="build.gradle[tags=apply-plugins]"]
   ====
   
   Once the appropriate plugin has been applied, you can configure the publications and repositories. For this example, we want to publish the project's production JAR file 댹맚he one produced by the `jar` task  to a custom Maven repository. We do that with the following `publishing {}` block, which is backed by link:{groovyDslPath}#[PublishingExtension]:
   
   .Configuring a Java library for publishing
   ====
   include::sample[dir="snippets/publishing/javaLibrary/kotlin",files="build.gradle.kts[tags=configure-publishing]"]
   include::sample[dir="snippets/publishing/javaLibrary/groovy",files="build.gradle[tags=configure-publishing]"]
   ====
   
   This defines a publication called "myLibrary" that can be published to a Maven repository막y virtue of its type: link:{groovyDslPath}#[MavenPublication].
   This publication consists of just the production JAR artifact and its metadata, which combined are represented by the `java` <<dependency_management_terminology.adoc#sub:terminology_component,component>> of the project.
   
   NOTE: Components are the standard way of defining a publication. They are provided by plugins, usually of the language or platform variety. For example, the Java Plugin defines the `components.java` link:{javadocPath}#[SoftwareComponent], while the War Plugin defines `components.web`.
   
   The example also defines a file-based Maven repository with the name "myRepo". Such a file-based repository is convenient for a sample, but real-world builds typically work with HTTPS-based repository servers, such as Maven Central or an internal company server.
   
   NOTE: You may define one, and only one, repository without a name. This translates to an implicit name of "Maven" for Maven repositories and "Ivy" for Ivy repositories. All other repository definitions must be given an explicit name.
   
   In combination with the project's `group` and `version`, the publication and repository definitions provide everything that Gradle needs to publish the project's production JAR. Gradle will then create a dedicated `publishMyLibraryPublicationToMyRepoRepository` task that does just that. Its name is based on the template `publish__PubName__PublicationTo__RepoName__Repository`. See the appropriate publishing plugin's documentation for more details on the nature of this task and any other tasks that may be available to you.
   
   You can either execute the individual publishing tasks directly, or you can execute `publish`, which will run all the available publishing tasks. In this example, `publish` will just run `publishMyLibraryPublicationToMavenRepository`.
   
   [NOTE]
   ====
   Basic publishing to an Ivy repository is very similar: you simply use the Ivy Publish Plugin, replace  `MavenPublication` with link:{groovyDslPath}#[IvyPublication], and use `ivy` instead of `maven` in the repository definition.
   
   There are differences between the two types of repository, particularly around the extra metadata that each support 댹맍or example, Maven repositories require a POM file while Ivy ones have their own metadata format  so see the plugin chapters for comprehensive information on how to configure both publications and repositories for whichever repository type you're working with.
   ====
   
   That's everything for the basic use case. However, many projects need more control over what gets published, so we look at several common scenarios in the following sections.
   
   == Suppressing validation errors
   
   Gradle performs validation of generated module metadata.
   In some cases, validation can fail, indicating that you most likely have an error to fix, but you may have done something intentionally.
   If this is the case, Gradle will indicate the name of the validation error you can disable on the `GenerateModuleMetadata` tasks:
   
   .Disabling some validation errors
   ====
   include::sample[dir="snippets/publishing/javaLibrary/kotlin",files="build.gradle.kts[tags=disable_validation]"]
   include::sample[dir="snippets/publishing/javaLibrary/groovy",files="build.gradle[tags=disable_validation]"]
   ====

/docs/userguide/dep-man/06-publishing/publishing_gradle_module_metadata.adoc
============================================================================

.. code-block::

   :metadata-file-spec: https://github.com/gradle/gradle/blob/master/platforms/documentation/docs/src/docs/design/gradle-module-metadata-latest-specification.md
   
   = Understanding Gradle Module Metadata
   
   Gradle Module Metadata is a format used to serialize the Gradle component model.
   It is similar to https://maven.apache.org/pom.html[Apache Maven's POM file] or https://ant.apache.org/ivy/[Apache Ivy ivy.xml] files.
   The goal of metadata files is to provide _to consumers_ a reasonable model of what is published on a repository.
   
   Gradle Module Metadata is a unique format aimed at improving dependency resolution by making it multi-platform and variant-aware.
   
   In particular, Gradle Module Metadata supports:
   
   - <<rich_versions.adoc#rich-version-constraints,rich version constraints>>
   - <<dependency_constraints.adoc#sec:adding-constraints-transitive-deps,dependency constraints>>
   - <<component_capabilities.adoc#declaring-component-capabilities,component capabilities>>
   - <<variant_model.adoc#understanding-variant-selection,variant-aware resolution>>
   
   Publication of Gradle Module Metadata will enable better dependency management for your consumers:
   
   - early discovery of problems by detecting <<component_capabilities.adoc#declaring-component-capabilities,incompatible modules>>
   - consistent selection of <<cross_project_publications.adoc#targeting-different-platforms,platform-specific dependencies>>
   - native <<dependency_version_alignment.adoc#version_alignment, dependency version alignment>>
   - automatically getting dependencies for specific <<feature_variants.adoc#feature_variants,features of your library>>
   
   Gradle Module Metadata is automatically published when using the <<publishing_maven.adoc#publishing_maven,Maven Publish plugin>> or the <<publishing_ivy.adoc#publishing_ivy,Ivy Publish plugin>>.
   
   The specification for Gradle Module Metadata can be found {metadata-file-spec}[here].
   
   == Mapping with other formats
   
   Gradle Module Metadata is automatically published on Maven or Ivy repositories.
   However, it doesn't replace the _pom.xml_ or _ivy.xml_ files: it is published alongside those files.
   This is done to maximize compatibility with third-party build tools.
   
   Gradle does its best to map Gradle-specific concepts to Maven or Ivy.
   When a build file uses features that can only be represented in Gradle Module Metadata, Gradle will warn you at publication time.
   The table below summarizes how some Gradle specific features are mapped to Maven and Ivy:
   
   .Mapping of Gradle specific concepts to Maven and Ivy
   |===
   |Gradle|Maven|Ivy|Description
   
   |<<dependency_constraints.adoc#sec:adding-constraints-transitive-deps,dependency constraints>>
   |`<dependencyManagement>` dependencies
   |Not published
   |Gradle dependency constraints are _transitive_, while Maven's dependency management block _isn't_
   
   |<<rich_versions.adoc#rich-version-constraints,rich version constraints>>
   |Publishes the _requires_ version
   |Published the _requires_ version
   |
   
   |<<component_capabilities.adoc#declaring-component-capabilities,component capabilities>>
   |Not published
   |Not published
   |Component capabilities are unique to Gradle
   
   |<<feature_variants.adoc#feature_variants,Feature variants>>
   |Variant artifacts are uploaded, dependencies are published as _optional_ dependencies
   |Variant artifacts are uploaded, dependencies are not published
   |Feature variants are a good replacement for optional dependencies
   
   |<<publishing_customization.adoc#sec:publishing-custom-components,Custom component types>>
   |Artifacts are uploaded, dependencies are those described by the mapping
   |Artifacts are uploaded, dependencies are ignored
   |Custom component types are probably not consumable from Maven or Ivy in any case. They usually exist in the context of a custom ecosystem.
   
   |===
   
   === Disabling metadata compatibility publication warnings
   
   If you want to suppress warnings, you can use the following APIs to do so:
   
   * For Maven, see the `suppress*` methods in link:{groovyDslPath}#[MavenPublication]
   * For Ivy, see the `suppress*` methods in link:{groovyDslPath}#[IvyPublication]
   
   
   .Disabling publication warnings
   ====
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-outgoingCapabilities/kotlin",files="build.gradle.kts[tags=ignore-pom-warnings]"]
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-outgoingCapabilities/groovy",files="build.gradle[tags=ignore-pom-warnings]"]
   ====
   
   == Interactions with other build tools
   
   Because Gradle Module Metadata is not widely spread and because it aims at <<#sub:mapping-with-other-formats,maximizing compatibility with other tools>>, Gradle does a couple of things:
   
   - Gradle Module Metadata is systematically published alongside the normal descriptor for a given repository (Maven or Ivy)
   - the `pom.xml` or `ivy.xml` file will contain a _marker comment_ which tells Gradle that Gradle Module Metadata exists for this module
   
   The goal of the marker is _not_ for other tools to parse module metadata: it's for Gradle users only.
   It explains to Gradle that a _better_ module metadata file exists and that it should use it instead.
   It doesn't mean that consumption from Maven or Ivy would be broken either, only that it works in <<#sub:mapping-with-other-formats,degraded mode>>.
   
   NOTE: This must be seen as a _performance optimization_: instead of having to do 2 network requests, one to get Gradle Module Metadata, then one to get the POM/Ivy file in case of a miss, Gradle will first look at the file which is most likely to be present, then only perform a 2nd request if the module was actually published with Gradle Module Metadata.
   
   If you know that the modules you depend on are always published with Gradle Module Metadata, you can optimize the network calls by configuring the metadata sources for a repository:
   
   .Resolving Gradle Module Metadata only
   ====
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-advanced-published/kotlin/producer",files="build.gradle.kts[tags=gradle_metadata_source]"]
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-advanced-published/groovy/producer",files="build.gradle[tags=gradle_metadata_source]"]
   ====
   
   == Gradle Module Metadata validation
   
   Gradle Module Metadata is validated before being published.
   
   The following rules are enforced:
   
   * Variant names must be unique,
   * Each variant must have at least <<variant_attributes.adoc#variant_attributes,one attribute>>,
   * Two variants cannot have the <<variant_model.adoc#understanding-variant-selection,exact same attributes and capabilities>>,
   * If there are dependencies, at least one, across all variants, must carry <<rich_versions.adoc#rich-version-constraints,version information>>.
   
   These rules ensure the quality of the metadata produced, and help confirm that consumption will not be problematic.
   
   == Gradle Module Metadata reproducibility
   
   The task generating the module metadata files is currently never marked `UP-TO-DATE` by Gradle due to the way it is implemented.
   However, if neither build inputs nor build scripts changed, the task result is effectively up-to-date: it always produces the same output.
   
   If users desire to have a unique `module` file per build invocation, it is possible to link an identifier in the produced metadata to the build that created it.
   Users can choose to enable this unique identifier in their `publication`:
   
   .Configuring the build identifier of a publication
   ====
   include::sample[dir="snippets/publishing/javaLibrary/kotlin",files="build.gradle.kts[tags=enable-build-id]"]
   include::sample[dir="snippets/publishing/javaLibrary/groovy",files="build.gradle[tags=enable-build-id]"]
   ====
   
   With the changes above, the generated Gradle Module Metadata file will always be different, forcing downstream tasks to consider it out-of-date.
   
   == Disabling Gradle Module Metadata publication
   
   There are situations where you might want to disable publication of Gradle Module Metadata:
   
   - the repository you are uploading to rejects the metadata file (unknown format)
   - you are using Maven or Ivy specific concepts which are not properly mapped to Gradle Module Metadata
   
   In this case, disabling the publication of Gradle Module Metadata is done simply by disabling the task which generates the metadata file:
   
   .Disabling publication of Gradle Module Metadata
   ====
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-advanced-published/kotlin/producer",files="build.gradle.kts[tags=disable_gradle_metadata_publication]"]
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-advanced-published/groovy/producer",files="build.gradle[tags=disable_gradle_metadata_publication]"]
   ====

/docs/userguide/dep-man/06-publishing/publishing_signing.adoc
=============================================================

.. code-block::

   = Signing artifacts
   
   The <<signing_plugin.adoc#signing_plugin, Signing Plugin>> can be used to sign all artifacts and metadata files that make up a publication, including Maven POM files and Ivy module descriptors. In order to use it:
   
   1. Apply the Signing Plugin
   2. Configure the <<signing_plugin.adoc#sec:signatory_credentials,signatory credentials>>  follow the link to see how
   3. Specify the publications you want signed
   
   Here's an example that configures the plugin to sign the `mavenJava` publication:
   
   .Signing a publication
   ====
   include::sample[dir="snippets/signing/maven-publish/kotlin",files="build.gradle.kts[tags=sign-publication]"]
   include::sample[dir="snippets/signing/maven-publish/groovy",files="build.gradle[tags=sign-publication]"]
   ====
   
   This will create a `Sign` task for each publication you specify and wire all `publish__PubName__PublicationTo__RepoName__Repository` tasks to depend on it. Thus, publishing any publication will automatically create and publish the signatures for its artifacts and metadata, as you can see from this output:
   
   == Example: Sign and publish a project
   
   .Output of `gradle publish`
   ----
   > gradle publish
   include::{snippetsPath}/signing/maven-publish/tests/publishingMavenSignAndPublish.out[]
   ----

/docs/userguide/dep-man/06-publishing/publishing_customization.adoc
===================================================================

.. code-block::

   = Customizing publishing
   
   == Modifying and adding variants to existing components for publishing
   
   Gradle's publication model is based on the notion of _components_, which are defined by plugins.
   For example, the Java Library plugin defines a `java` component which corresponds to a library, but the Java Platform plugin defines another kind of component, named `javaPlatform`, which is effectively a different kind of software component (a _platform_).
   
   Sometimes we want to add _more variants_ to or modify _existing variants_ of an existing component.
   For example, if you <<cross_project_publications.adoc#targeting-different-platforms, added a variant of a Java library for a different platform>>, you may just want to declare this additional variant on the `java` component itself.
   In general, declaring additional variants is often the best solution to publish _additional artifacts_.
   
   To perform such additions or modifications, the `AdhocComponentWithVariants` interface declares two methods called `addVariantsFromConfiguration` and `withVariantsFromConfiguration` which accept two parameters:
   
   - the <<declaring_dependencies.adoc#sec:resolvable-consumable-configs,outgoing configuration>> that is used as a variant source
   - a customization action which allows you to _filter_ which variants are going to be published
   
   To utilise these methods, you must make sure that the `SoftwareComponent` you work with is itself an `AdhocComponentWithVariants`, which is the case for the components created by the Java plugins (Java, Java Library, Java Platform).
   Adding a variant is then very simple:
   
   .Adding a variant to an existing software component
   ====
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-advanced-published/kotlin/buildSrc/src/main/kotlin/com/acme",files="InstrumentedJarsPlugin.kt[tags=add_variant_to_existing_component]"]
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-advanced-published/groovy/buildSrc/src/main/groovy/com/acme",files="InstrumentedJarsPlugin.groovy[tags=add_variant_to_existing_component]"]
   ====
   
   In other cases, you might want to modify a variant that was added by one of the Java plugins already.
   For example, if you activate publishing of Javadoc and sources, these become additional variants of the `java` component.
   If you only want to publish one of them, e.g. only Javadoc but no sources, you can modify the `sources` variant to not being published:
   
   .Publish a java library with Javadoc but without sources
   ====
   include::sample[dir="snippets/maven-publish/javaProject/kotlin",files="build.gradle.kts[tags=publish-modify-component]"]
   include::sample[dir="snippets/maven-publish/javaProject/groovy",files="build.gradle[tags=publish-modify-component]"]
   ====
   
   == Creating and publishing custom components
   
   In the <<sec:adding-variants-to-existing-components, previous example>>, we have demonstrated how to extend or modify an existing component, like the components provided by the Java plugins.
   But Gradle also allows you to build a custom component (not a Java Library, not a Java Platform, not something supported natively by Gradle).
   
   To create a custom component, you first need to create an empty _adhoc_ component.
   At the moment, this is only possible via a plugin because you need to get a handle on the link:{javadocPath}#[SoftwareComponentFactory] :
   
   .Injecting the software component factory
   ====
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-advanced-published/kotlin/buildSrc/src/main/kotlin/com/acme",files="InstrumentedJarsPlugin.kt[tags=inject_software_component_factory]"]
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-advanced-published/groovy/buildSrc/src/main/groovy/com/acme",files="InstrumentedJarsPlugin.groovy[tags=inject_software_component_factory]"]
   ====
   
   Declaring _what_ a custom component publishes is still done via the link:{javadocPath}#[AdhocComponentWithVariants] API.
   For a custom component, the first step is to create custom outgoing variants, following the instructions in <<cross_project_publications.adoc#sec:variant-aware-sharing, this chapter>>.
   At this stage, what you should have is variants which can be used in cross-project dependencies, but that we are now going to publish to external repositories.
   
   .Creating a custom, adhoc component
   ====
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-advanced-published/kotlin/buildSrc/src/main/kotlin/com/acme",files="InstrumentedJarsPlugin.kt[tags=create_adhoc_component]"]
   include::sample[dir="snippets/dependencyManagement/modelingFeatures-crossProjectPublications-advanced-published/groovy/buildSrc/src/main/groovy/com/acme",files="InstrumentedJarsPlugin.groovy[tags=create_adhoc_component]"]
   ====
   
   First we use the factory to create a new adhoc component.
   Then we add a variant through the `addVariantsFromConfiguration` method, which is described in more detail in the <<sec:adding-variants-to-existing-components,previous section>>.
   
   In simple cases, there's a one-to-one mapping between a `Configuration` and a variant, in which case you can publish all variants issued from a single `Configuration` because they are effectively the same thing.
   However, there are cases where a `Configuration` is associated with additional link:{javadocPath}#[configuration publications] that we also call _secondary variants_.
   Such configurations make sense in the <<cross_project_publications.adoc#cross_project_publications,cross-project publications>> use case, but not when publishing externally.
   This is for example the case when between projects you share a _directory of files_, but there's no way you can publish a _directory_ directly on a Maven repository (only packaged things like jars or zips).
   Look at the link:{javadocPath}#[ConfigurationVariantDetails] class for details about how to skip publication of a particular variant.
   If `addVariantsFromConfiguration` has already been called for a configuration, further modification of the resulting variants can be performed using `withVariantsFromConfiguration`.
   
   When publishing an adhoc component like this:
   
   - Gradle Module Metadata will _exactly_ represent the published variants. In particular, all outgoing variants will inherit dependencies, artifacts and attributes of the published configuration.
   - Maven and Ivy metadata files will be generated, but you need to declare how the dependencies are mapped to Maven scopes via the link:{javadocPath}#[ConfigurationVariantDetails] class.
   
   In practice, it means that components created this way can be consumed by Gradle the same way as if they were "local components".
   
   == Adding custom artifacts to a publication
   
   --
   Instead of thinking in terms of artifacts, you should embrace the variant aware model of Gradle.
   It is expected that a single module may need multiple artifacts.
   However this rarely stops there, if the additional artifacts represent an <<feature_variants.adoc#feature_variants,optional feature>>, they might also have different dependencies and more.
   
   Gradle, via _Gradle Module Metadata_, supports the publication of _additional variants_ which make those artifacts known to the dependency resolution engine.
   Please refer to the <<cross_project_publications.adoc#sec:variant-aware-sharing, variant-aware sharing>> section of the documentation to see how to declare such variants and <<#sec:publishing-custom-components, check out how to publish custom components>>.
   
   If you attach extra artifacts to a publication directly, they are published "out of context".
   That means, they are not referenced in the metadata at all and can then only be addressed directly through a classifier on a dependency.
   In contrast to Gradle Module Metadata, Maven pom metadata will not contain information on additional artifacts regardless of whether they are added through a variant or directly, as variants cannot be represented in the pom format.
   --
   
   The following section describes how you publish artifacts directly if you are sure that metadata, for example Gradle or POM metadata, is irrelevant for your use case.
   For example, if your project doesn't need to be consumed by other projects and the only thing required as result of the publishing are the artifacts themselves.
   
   In general, there are two options:
   
   - Create a publication only with artifacts
   - Add artifacts to a publication based on a component with metadata (not recommended, instead <<sec:adding-variants-to-existing-components,adjust a component>> or use a <<#sec:publishing-custom-components,adhoc component publication>> which will both also produce metadata fitting your artifacts)
   
   To create a publication based on artifacts, start by defining a custom artifact and attaching it to a Gradle <<dependency_management_terminology.adoc#sub:terminology_configuration,configuration>> of your choice.
   The following sample defines an RPM artifact that is produced by an `rpm` task (not shown) and attaches that artifact to the `conf` configuration:
   
   .Defining a custom artifact for a configuration
   ====
   include::sample[dir="snippets/maven-publish/publish-artifact/kotlin",files="build.gradle.kts[tags=custom-artifact]"]
   include::sample[dir="snippets/maven-publish/publish-artifact/groovy",files="build.gradle[tags=custom-artifact]"]
   ====
   
   The `artifacts.add()` method 댹맍rom link:{groovyDslPath}#[ArtifactHandler]  returns an artifact object of type link:{javadocPath}#[PublishArtifact] that can then be used in defining a publication, as shown in the following sample:
   
   .Attaching a custom PublishArtifact to a publication
   ====
   include::sample[dir="snippets/maven-publish/publish-artifact/kotlin",files="build.gradle.kts[tags=custom-artifact-publication]"]
   include::sample[dir="snippets/maven-publish/publish-artifact/groovy",files="build.gradle[tags=custom-artifact-publication]"]
   ====
   
   * The `artifact()` method accepts _publish artifacts_ as argument  like `rpmArtifact` in the sample  as well as any type of argument accepted by link:{groovyDslPath}#[Project.file(java.lang.Object)], such as a `File` instance, a string file path or a archive task.
   * Publishing plugins support different artifact configuration properties, so always check the plugin documentation for more details. The `classifier` and `extension` properties are supported by both the <<publishing_maven.adoc#publishing_maven,Maven Publish Plugin>> and the <<publishing_ivy.adoc#publishing_ivy,Ivy Publish Plugin>>.
   * Custom artifacts need to be distinct within a publication, typically via a unique combination of `classifier` and `extension`. See the documentation for the plugin you're using for the precise requirements.
   * If you use `artifact()` with an archive task, Gradle automatically populates the artifact's metadata with the `classifier` and `extension` properties from that task.
   
   Now you can publish the RPM.
   
   If you really want to add an artifact to a publication based on a component, instead of <<#sec:adding-variants-to-existing-components,adjusting the component>> itself, you can combine the `from components.someComponent` and `artifact someArtifact` notations.
   
   == Restricting publications to specific repositories
   
   When you have defined multiple publications or repositories, you often want to control which publications are published to which repositories. For instance, consider the following sample that defines two publications 댹맖ne that consists of just a binary and another that contains the binary and associated sources 댹마nd two repositories  one for internal use and one for external consumers:
   
   .Adding multiple publications and repositories
   ====
   include::sample[dir="snippets/maven-publish/conditional-publishing/kotlin",files="build.gradle.kts[tags=publishing]"]
   include::sample[dir="snippets/maven-publish/conditional-publishing/groovy",files="build.gradle[tags=publishing]"]
   ====
   
   The publishing plugins will create tasks that allow you to publish either of the publications to either repository. They also attach those tasks to the `publish` aggregate task. But let's say you want to restrict the binary-only publication to the external repository and the binary-with-sources publication to the internal one. To do that, you need to make the publishing _conditional_.
   
   Gradle allows you to skip any task you want based on a condition via the link:{groovyDslPath}#[Task.onlyIf(String, org.gradle.api.specs.Spec)] method. The following sample demonstrates how to implement the constraints we just mentioned:
   
   .Configuring which artifacts should be published to which repositories
   ====
   include::sample[dir="snippets/maven-publish/conditional-publishing/kotlin",files="build.gradle.kts[tags=task-config]"]
   include::sample[dir="snippets/maven-publish/conditional-publishing/groovy",files="build.gradle[tags=task-config]"]
   ====
   
   .Output of `gradle publish`
   ----
   > gradle publish
   include::{snippetsPath}/maven-publish/conditional-publishing/tests/publishingMavenConditionally.out[]
   ----
   
   You may also want to define your own aggregate tasks to help with your workflow. For example, imagine that you have several publications that should be published to the external repository. It could be very useful to publish all of them in one go without publishing the internal ones.
   
   The following sample demonstrates how you can do this by defining an aggregate task 댹`publishToExternalRepository` 댹맚hat depends on all the relevant publish tasks:
   
   .Defining your own shorthand tasks for publishing
   ====
   include::sample[dir="snippets/maven-publish/conditional-publishing/kotlin",files="build.gradle.kts[tags=shorthand-tasks]"]
   include::sample[dir="snippets/maven-publish/conditional-publishing/groovy",files="build.gradle[tags=shorthand-tasks]"]
   ====
   
   This particular sample automatically handles the introduction or removal of the relevant publishing tasks by using link:{javadocPath}#[TaskCollection.withType(java.lang.Class)] with the link:{groovyDslPath}#[PublishToMavenRepository] task type. You can do the same with link:{groovyDslPath}#[PublishToIvyRepository] if you're publishing to Ivy-compatible repositories.
   
   == Configuring publishing tasks
   
   The publishing plugins create their non-aggregate tasks after the project has been evaluated, which means you cannot directly reference them from your build script. If you would like to configure any of these tasks, you should use deferred task configuration. This can be done in a number of ways via the project's `tasks` collection.
   
   For example, imagine you want to change where the `generatePomFileFor__PubName__Publication` tasks write their POM files. You can do this by using the link:{javadocPath}#[TaskCollection.withType(java.lang.Class)] method, as demonstrated by this sample:
   
   .Configuring a dynamically named task created by the publishing plugins
   ====
   include::sample[dir="snippets/publishing/javaLibrary/kotlin",files="build.gradle.kts[tags=configure-generate-task]"]
   include::sample[dir="snippets/publishing/javaLibrary/groovy",files="build.gradle[tags=configure-generate-task]"]
   ====
   
   The above sample uses a regular expression to extract the name of the publication from the name of the task. This is so that there is no conflict between the file paths of all the POM files that might be generated. If you only have one publication, then you don't have to worry about such conflicts since there will only be one POM file.

/Topic: 游댯 Optimizing Build Performance
=========================================


/docs/userguide/optimizing-performance/performance.adoc
=======================================================

.. code-block::

   = Improve the Performance of Gradle Builds
   
   Build performance is critical to productivity.
   The longer builds take to complete, the more likely they'll disrupt your development flow.
   Builds run many times a day, so even small waiting periods add up.
   The same is true for Continuous Integration (CI) builds: the less time they take, the faster you can react to new issues
   and the more often you can experiment.
   
   All this means that it뗩 worth investing some time and effort into making your build as fast as possible.
   This section offers several ways to make a build faster. Additionally, you'll find details about what leads to
   build performance degradation, and how you can avoid it.
   
   TIP: Want faster Gradle Builds? https://gradle.org/training/#build-cache-deep-dive[Register here] for our Build Cache training session to learn how Develocity can speed up builds by up to 90%.
   
   == Inspect your build
   
   Before you make any changes, <<inspect.adoc#inspecting_build_scans,inspect your build>> with a build scan or profile report. A proper build inspection helps
   you understand:
   
   * how long it takes to build your project
   * which parts of your build are slow
   
   Inspecting provides a comparison point to better understand the impact of the changes recommended on this page.
   
   To best make use of this page:
   
   . Inspect your build.
   . Make a change.
   . Inspect your build again.
   
   If the change improved build times, make it permanent. If you don't see an improvement, remove the change and try another.
   
   == Update versions
   
   === Gradle
   
   The Gradle team continuously improves the performance of Gradle builds.
   If youre using an old version of Gradle, youre missing out on the benefits of that work.
   Keeping up with Gradle version upgrades is low risk because the Gradle team ensures backwards compatibility between minor versions of Gradle.
   Staying up-to-date also makes transitioning to the next major version easier, since you'll get early deprecation warnings.
   
   === Java
   
   Gradle runs on the Java Virtual Machine (JVM). Java performance improvements often benefit Gradle.
   For the best Gradle performance, use the latest version of Java.
   
   === Plugins
   
   Plugin writers continuously improve the performance of their plugins.
   If you're using an old version of a plugin, you're missing out on the benefits of that work.
   The Android, Java, and Kotlin plugins in particular can significantly impact build performance.
   Update to the latest version of these plugins for performance improvements.
   
   == Enable parallel execution
   
   Most projects consist of more than one subproject. Usually, some of those subprojects are independent of one another;
   that is, they do not share state. Yet by default, Gradle only runs one task at a time.
   To execute tasks belonging to different subprojects in parallel, use the `parallel` flag:
   
   ====
   [listing.terminal]
   ----
   $ gradle <task> --parallel
   ----
   ====
   
   To execute project tasks in parallel by default, add the following setting to the `gradle.properties` file in the project root or your Gradle home:
   
   ====
   .gradle.properties
   [source,properties]
   ----
   org.gradle.parallel=true
   ----
   ====
   
   Parallel builds can significantly improve build times; how much depends on your project structure and
   how many dependencies you have between subprojects.
   A build whose execution time is dominated by a single subproject won't benefit much at all.
   Neither will a project with lots of inter-subproject dependencies.
   But most multi-subproject builds see a reduction in build times.
   
   === Visualize parallelism with build scans
   
   Build scans give you a visual timeline of task execution. In the following
   example build, you can see long-running tasks at the beginning and end of the build:
   
   image::performance/parallel-task-slow.png[title="Bottleneck in parallel execution"]
   
   Tweaking the build configuration to run the two slow tasks early on and in parallel
   reduces the overall build time from 8 seconds to 5 seconds:
   
   image::performance/parallel-task-fast.png[title="Optimized parallel execution"]
   
   == Re-enable the Gradle Daemon
   
   The Gradle Daemon reduces build times by:
   
   * caching project information across builds
   * running in the background so every Gradle build doesn't have to wait for JVM startup
   * benefiting from continuous runtime optimization in the JVM
   * watching the file system to calculate exactly what needs to be rebuilt before you run a build
   
   Gradle enables the Daemon by default, but some builds override this preference.
   If your build disables the Daemon, you could see a significant performance improvement
   from enabling the daemon.
   
   You can enable the Daemon at build time with the `daemon` flag:
   
   ====
   [listing.terminal]
   ----
   $ gradle <task> --daemon
   ----
   ====
   
   To enable the Daemon by default in older Gradle versions, add the following setting to the
   `gradle.properties` file in the project root or your Gradle home:
   
   ====
   .gradle.properties
   [source,properties]
   ----
   org.gradle.daemon=true
   ----
   ====
   
   On developer machines, you should see a significant performance improvement.
   On CI machines, long-lived agents benefit from the Daemon. But short-lived machines don't benefit much.
   Daemons automatically shut down on memory pressure in Gradle 3.0 and above, so it's always safe to leave the Daemon enabled.
   
   == Enable the configuration cache
   
   [IMPORTANT]
   ====
   This feature has the following limitations:
   
   * The configuration cache does not support all <<configuration_cache#config_cache:plugins:core, core Gradle plugins>> and <<configuration_cache#config_cache:not_yet_implemented, features>>. Full support is a work in progress. +
   * Your build and the plugins you depend on might require changes to fulfill the <<configuration_cache#config_cache:requirements, requirements>>. +
   * IDE imports and syncs do not use the configuration cache.
   ====
   
   You can cache the result of the configuration phase by enabling the configuration cache.
   When build configuration inputs remain the same across builds, the configuration cache
   allows Gradle to skip the configuration phase entirely.
   
   Build configuration inputs include:
   
   * Init scripts
   * Settings scripts
   * Build scripts
   * System properties used during the configuration phase
   * Gradle properties used during the configuration phase
   * Environment variables used during the configuration phase
   * Configuration files accessed using value suppliers such as providers
   * `buildSrc` inputs, including build configuration inputs and source files
   
   By default, Gradle does not use the configuration cache.
   To enable the configuration cache at build time, use the `configuration-cache` flag:
   
   ====
   [listing.terminal]
   ----
   $ gradle <task> --configuration-cache
   ----
   ====
   
   To enable the configuration cache by default, add the following setting to the `gradle.properties` file in the project root or your Gradle home:
   ====
   .gradle.properties
   [source,properties]
   ----
   org.gradle.configuration-cache=true
   ----
   ====
   
   For more information about the configuration cache, check out the
   <<configuration_cache.adoc#config_cache,configuration cache documentation>>.
   
   === Additional configuration cache benefits
   
   The configuration cache enables additional benefits as well. When enabled, Gradle:
   
   * Executes all tasks in parallel, even those in the same subproject.
   * Caches dependency resolution results.
   
   == Enable incremental build for custom tasks
   
   Incremental build is a Gradle optimization that skips running tasks that have previously executed with the same inputs.
   If a task뗩 inputs and its outputs have not changed since the last execution, Gradle skips that task.
   
   Most built-in tasks provided by Gradle work with incremental build.
   To make a custom task compatible with incremental build, specify the inputs and outputs:
   
   ====
   include::sample[dir="snippets/tasks/incrementalBuild-customTaskClass/kotlin",files="build.gradle.kts[tags=ad-hoc-task]"]
   include::sample[dir="snippets/tasks/incrementalBuild-customTaskClass/groovy",files="build.gradle[tags=ad-hoc-task]"]
   ====
   
   For more information about incremental builds, check out the
   <<incremental_build.adoc#incremental_build,incremental build documentation>>.
   
   === Visualize incremental builds with build scan timelines
   
   Look at the build scan timeline view to identify tasks that could benefit from incremental builds.
   This can also help you understand why tasks execute when you expect Gradle to skip them.
   
   image::performance/timeline.png[title="The timeline view can help with incremental build inspection"]
   
   As you can see in the build scan above, the task was not up-to-date because one of its inputs
   (_"timestamp"_) changed, forcing the task to re-run.
   
   Sort tasks by duration to find the slowest tasks in your project.
   
   == Enable the build cache
   
   The build cache is a Gradle optimization that stores task outputs for specific input.
   When you later run that same task with the same input, Gradle retrieves the output from the build cache instead of running the task again.
   By default, Gradle does not use the build cache.
   To enable the build cache at build time, use the `build-cache` flag:
   
   ====
   [listing.terminal]
   ----
   $ gradle <task> --build-cache
   ----
   ====
   
   To enable the build cache by default, add the following setting to the `gradle.properties` file in the project root or your Gradle home:
   
   ====
   .gradle.properties
   [source,properties]
   ----
   org.gradle.caching=true
   ----
   ====
   
   You can use a local build cache to speed up repeated builds on a single machine.
   You can also use a shared build cache to speed up repeated builds across multiple machines.
   Develocity https://gradle.com/build-cache/[provides one].
   Shared build caches can decrease build times for both CI and developer builds.
   
   For more information about the build cache, check out the
   <<build_cache_use_cases.adoc#use_cases_cache,build cache documentation>>.
   
   === Visualize the build cache with build scans
   
   Build scans can help you investigate build cache effectiveness.
   In the performance screen, the _"Build cache"_ tab shows you statistics about:
   
   * how many tasks interacted with a cache
   * which cache was used
   * transfer and pack/unpack rates for these cache entries
   
   image::performance/cache-performance.png[title="Inspecting the performance of the build cache for a build"]
   
   The _"Task execution"_ tab shows details about task cacheability.
   Click on a category to see a timeline screen that highlights tasks of that category.
   
   image::performance/task-execution-cacheable.png[title="A task oriented view of performance"]
   
   image::performance/timeline-not-cacheable.png[title="Timeline screen with 'not cacheable' tasks only"]
   
   Sort by task duration on the timeline screen to highlight tasks with great time saving potential.
   The build scan above shows that `:task1` and `:task3` could be improved and made cacheable
   and shows why Gradle didn't cache them.
   
   == Create builds for specific developer workflows
   
   The fastest task is one that doesn뗪 execute.
   If you can find ways to skip tasks you don뗪 need to run, you뗣l end up with a faster build overall.
   
   If your build includes multiple subprojects, create tasks to build those subprojects
   independently. This helps you get the most out of caching, since a change to one
   subproject won't force a rebuild for unrelated subprojects. And this helps reduce
   build times for teams that work on unrelated subprojects: there's no need for
   front-end developers to build the back-end subprojects every time they change the
   front-end. Documentation writers don't need to build front-end or back-end code
   even if the documentation lives in the same project as that code.
   
   Instead, create tasks that match the needs of developers. You'll still have a single
   task graph for the whole project. Each group of users suggests a restricted view of
   the task graph: turn that view into a Gradle workflow that excludes unnecessary tasks.
   
   Gradle provides several features to create these workflows:
   
   * Assign tasks to appropriate link:{groovyDslPath}#[groups]
   * Create _aggregate tasks_: tasks with no action that only depend on other tasks, such as `assemble`
   * Defer configuration via `gradle.taskGraph.whenReady()` and others, so you can perform verification only when it's necessary
   
   == Increase the heap size
   
   By default, Gradle reserves 512MB of heap space for your build. This is plenty for most projects.
   However, some very large builds might need more memory to hold Gradle's model and caches.
   If this is the case for you, you can specify a larger memory requirement.
   Specify the following property in the `gradle.properties` file in your project root or your Gradle home:
   
   ====
   .gradle.properties
   [source,java]
   ----
   org.gradle.jvmargs=-Xmx2048M
   ----
   ====
   
   To learn more, check out the <<config_gradle.adoc#sec:configuring_jvm_memory,JVM memory configuration documentation>>.
   
   == Optimize Configuration
   
   As described in <<build_lifecycle.adoc#build_lifecycle,the build lifecycle chapter>>, a
   Gradle build goes through 3 phases: initialization, configuration, and execution.
   Configuration code always executes regardless of the tasks that run.
   As a result, any expensive work performed during configuration slows down every invocation.
   Even simple commands like `gradle help` and `gradle tasks`.
   
   The next few subsections introduce techniques that can reduce time spent in the configuration phase.
   
   NOTE: You can also <<enable_configuration_cache,enable the configuration cache>> to reduce the impact of a slow configuration phase. But even machines that use the cache still occasionally execute your configuration phase. As a result, you should make the configuration phase as fast as possible with these techniques.
   
   === Avoid expensive or blocking work
   
   You should avoid time-intensive work in the configuration phase.
   But sometimes it can sneak into your build in non-obvious places.
   It뗩 usually clear when youre encrypting data or calling remote services during configuration if that code is in a build file.
   But logic like this is more often found in plugins and occasionally custom task classes.
   Any expensive work in a plugin's `apply()` method or a tasks's constructor is a red flag.
   
   === Only apply plugins where they're needed
   
   Every plugin and script that you apply to a project adds to the overall configuration time.
   Some plugins have a greater impact than others.
   That doesn뗪 mean you should avoid using plugins, but you should take care to only apply them where theyre needed.
   For example, it뗩 easy to apply plugins to all subprojects via `allprojects {}` or `subprojects {}` even if not every project needs them.
   
   In the above build scan example, you can see that the root build script applies the `script-a.gradle`
   script to 3 subprojects inside the build:
   
   image::performance/script-a-application.png[title="Showing the application of script-a.gradle to the build"]
   
   This script takes 1 second to run. Since it applies to 3 subprojects,
   this script cumulatively delays the configuration phase by 3 seconds.
   In this situation, there are several ways to reduce the delay:
   
   * If only one subproject uses the script, you could remove the script
     application from the other subprojects. This reduces the configuration delay
     by two seconds in each Gradle invocation.
   
   * If multiple subprojects, but not all, use the script, you could refactor the script and
     all surrounding logic into a custom plugin located in <<sharing_build_logic_between_subprojects.adoc#sec:using_buildsrc,`buildSrc`>>.
     Apply the custom plugin to only the relevant subprojects, reducing configuration delay and avoiding code duplication.
   
   === Statically compile tasks and plugins
   
   Plugin and task authors often write Groovy for its concise syntax, API extensions to the JDK, and functional methods using closures.
   But Groovy syntax comes with the cost of dynamic interpretation. As a result, method calls in Groovy take more time and use
   more CPU than method calls in Java or Kotlin.
   
   You can reduce this cost with static Groovy compilation: add the `@CompileStatic` annotation to your Groovy classes when you don't
   explicitly require dynamic features. If you need dynamic Groovy in a method, add the `@CompileDynamic` annotation to that method.
   
   Alternatively, you can write plugins and tasks in a statically compiled language such as Java or Kotlin.
   
   *Warning:* Gradle's Groovy DSL relies heavily on Groovy뗩 dynamic features. To use static compilation in your plugins, switch to Java-like syntax.
   
   The following example defines a task that copies files without dynamic features:
   
   ====
   .src/main/groovy/MyPlugin.groovy
   [source,groovy]
   ----
   project.tasks.register('copyFiles', Copy) { Task t ->
       t.into(project.layout.buildDirectory.dir('output'))
       t.from(project.configurations.getByName('compile'))
   }
   ----
   ====
   
   This example uses the `register()` and `getByName()` methods available on all Gradle 띿omain object containers.
   Domain object containers include tasks, configurations, dependencies, extensions, and more.
   Some collections, such as `TaskContainer`, have dedicated types with extra methods like link:{groovyDslPath}#[create],
   which accepts a task type.
   
   When you use static compilation, an IDE can:
   
   * quickly show errors related to unrecognised types, properties, and methods
   * auto-complete method names
   
   == Optimize Dependency resolution
   
   Dependency resolution simplifies integrating third-party libraries and other dependencies into your projects.
   Gradle contacts remote servers to discover and download dependencies. You can optimize the way you reference
   dependencies to cut down on these remote server calls.
   
   === Avoid unnecessary and unused dependencies
   
   Managing third-party libraries and their transitive dependencies adds a significant
   cost to project maintenance and build times.
   
   Watch out for unused dependencies: when a third-party library stops being
   used by isn't removed from the dependency list. This happens frequently during refactors.
   You can use the https://github.com/nebula-plugins/gradle-lint-plugin[Gradle Lint plugin]
   to identify unused dependencies.
   
   If you only use a small number of methods or classes in a third-party library, consider:
   
   * implementing the required code yourself in your project
   * copying the required code from the library (with attribution!) if it is open source
   
   === Optimize repository order
   
   When Gradle resolves dependencies, it searches through each repository in the declared order.
   To reduce the time spent searching for dependencies, declare the repository hosting
   the largest number of your dependencies first. This minimizes the number of network requests
   required to resolve all dependencies.
   
   === Minimize repository count
   
   Limit the number of declared repositories to the minimum possible for your build to work.
   
   If you're using a custom repository server, create a virtual repository that aggregates
   several repositories together. Then, add only that repository to your build file.
   
   === Minimize dynamic and snapshot versions
   
   Dynamic versions (e.g. 2.+), and changing versions (snapshots) force Gradle to contact remote
   repositories to find new releases. By default, Gradle only checks once every 24 hours.
   But you can change this programmatically with the following settings:
   
   * `cacheDynamicVersionsFor`
   * `cacheChangingModulesFor`
   
   If a build file or initialization script lowers these values, Gradle queries repositories more often.
   When you don't need the absolute latest release of a dependency every time you build, consider
   removing the custom values for these settings.
   
   ==== Find dynamic and changing versions with build scans
   
   You can find all dependencies with dynamic versions via build scans:
   
   image::performance/dependency-dynamic-versions.png[title="Find dependencies with dynamic versions"]
   
   You may be able to use fixed versions like "1.2" and "3.0.3.GA" that allow Gradle to cache versions.
   If you must use dynamic and changing versions, tune the cache settings to best meet your needs.
   
   === Avoid dependency resolution during configuration
   
   Dependency resolution is an expensive process, both in terms of I/O and computation.
   Gradle reduces the required network traffic through caching. But there is still a cost.
   Gradle runs the configuration phase on every build. If you trigger dependency resolution
   during the configuration phase, every build pays that cost.
   
   ==== Switch to declarative syntax
   
   If you evaluate a configuration file, your project pays the cost of dependency resolution during configuration.
   Normally tasks evaluate these files, since you don뗪 need the files until youre ready to do something with them in a task action.
   Imagine youre doing some debugging and want to display the files that make up a configuration.
   To implement this, you might inject a print statement:
   
   ====
   include::sample[dir="snippets/performance/resolveAtConfigurationTime/kotlin",files="build.gradle.kts[tags=copy]"]
   include::sample[dir="snippets/performance/resolveAtConfigurationTime/groovy",files="build.gradle[tags=copy]"]
   ====
   
   The `files` property forces Gradle to resolve the dependencies. In this example, that happens during the configuration phase.
   Because the configuration phase runs on every build, all builds now pay the performance cost of dependency resolution.
   You can avoid this cost with a `doFirst()` action:
   
   ====
   include::sample[dir="snippets/performance/resolveAtBuildTime/kotlin",files="build.gradle.kts[tags=copy]"]
   include::sample[dir="snippets/performance/resolveAtBuildTime/groovy",files="build.gradle[tags=copy]"]
   ====
   
   Note that the `from()` declaration doesn뗪 resolve the dependencies because youre using the <<declaring_dependencies.adoc#sec:what-are-dependency-configurations,dependency configuration>> itself as an argument, not the files.
   The `Copy` task resolves the configuration itself during task execution.
   
   ==== Visualize dependency resolution with build scans
   
   The "Dependency resolution" tab on the performance page of a build scan shows dependency
   resolution time during the configuration and execution phases:
   
   image::performance/bad-dependency-resolution.png[title="Dependency resolution at configuration time"]
   
   Build scans provide another means of identifying this issue.
   Your build should spend 0 seconds resolving dependencies during _"project configuration"_.
   This example shows the build resolves dependencies too early in the lifecycle.
   You can also find a "Settings and suggestions" tab on the "Performance" page.
   This shows dependencies resolved during the configuration phase.
   
   === Remove or improve custom dependency resolution logic
   
   Gradle allows users to model dependency resolution in the way that best suits them.
   Simple customizations, such as forcing specific versions of a dependency or substituting
   one dependency for another, don't have a big impact on dependency resolution times.
   More complex customizations, such as custom logic that downloads and parses POMs,
   can slow down dependency resolution signficantly.
   
   Use build scans or profile reports to check that custom dependency resolution logic
   doesn't adversely affect dependency resolution times.
   This could be custom logic you have written yourself, or it could be part of a plugin.
   
   === Remove slow or unexpected dependency downloads
   
   Slow dependency downloads can impact your overall build performance.
   Several things could cause this, including a slow internet connection or an overloaded repository server.
   On the "Performance" page of a build scan, you'll find a "Network Activity" tab.
   This tab lists information including:
   
   * the time spent downloading dependencies
   * the transfer rate of dependency downloads
   * a list of downloads sorted by download time
   
   In the following example, two slow dependency downloads took 20 and 40 seconds and slowed down the overall
   performance of a build:
   
   image::performance/slow-dependency-downloads.png[title="Identify slow dependency downloads"]
   
   Check the download list for unexpected dependency downloads.
   For example, you might see a download caused by a dependency using a dynamic version.
   
   Eliminate these slow or unexpected downloads by switching to a different repository or dependency.
   
   == Optimize Java projects
   
   The following sections apply only to projects that use the `java` plugin or another JVM language.
   
   === Optimize tests
   
   Projects often spend much of their build time testing.
   These could be a mixture of unit and integration tests. Integration tests usually take longer.
   Build scans can help you identify the slowest tests. You can then focus on speeding up those tests.
   
   image::performance/tests-longest.png[title="Tests screen, with tests by project, sorted by duration"]
   
   The above build scan shows an interactive test report for all projects in which tests ran.
   
   Gradle has several ways to speed up tests:
   
   * Execute tests in parallel
   * Fork tests into multiple processes
   * Disable reports
   
   Let뗩 look at each of these in turn.
   
   ==== Execute tests in parallel
   
   Gradle can run multiple test cases in parallel.
   To enable this feature, override the value of `maxParallelForks` on the relevant `Test` task.
   For the best performance, use some number less than or equal to the number of available CPU cores:
   
   ====
   include::sample[dir="snippets/performance/parallelTestExecution/kotlin",files="build.gradle.kts[tags=parallel-calculated]"]
   include::sample[dir="snippets/performance/parallelTestExecution/groovy",files="build.gradle[tags=parallel-calculated]"]
   ====
   
   Tests in parallel must be independent. They should not share resources such as files or databases.
   If your tests do share resources, they could interfere with each other in random and unpredictable ways.
   
   ==== Fork tests into multiple processes
   
   By default, Gradle runs all tests in a single forked VM.
   If there are a lot of tests, or some tests that consume lots of memory,
   your tests may take longer than you expect to run. You can increase the
   heap size, but garbage collection may slow down your tests.
   
   Alternatively, you can fork a new test VM after a certain number of tests have run with the `forkEvery` setting:
   
   ====
   include::sample[dir="snippets/performance/parallelTestExecution/kotlin",files="build.gradle.kts[tags=fork-every]"]
   include::sample[dir="snippets/performance/parallelTestExecution/groovy",files="build.gradle[tags=fork-every]"]
   ====
   
   WARNING: Forking a VM is an expensive operation. Setting too small a value here slows down testing.
   
   ==== Disable reports
   
   Gradle automatically creates test reports regardless of whether you want to look at them.
   That report generation slows down the overall build. You may not need reports if:
   
   * you only care if the tests succeeded (rather than why)
   * you use build scans, which provide more information than a local report
   
   To disable test reports, set `reports.html.required` and `reports.junitXml.required` to `false` in the `Test` task:
   
   ====
   include::sample[dir="snippets/performance/parallelTestExecution/kotlin",files="build.gradle.kts[tags=disable-reports]"]
   include::sample[dir="snippets/performance/parallelTestExecution/groovy",files="build.gradle[tags=disable-reports]"]
   ====
   
   ===== Conditionally enable reports
   
   You might want to conditionally enable reports so you don't have to edit the build file to see them.
   To enable the reports based on a project property, check for the presence of a property before disabling reports:
   
   ====
   .build.gradle.kts
   [source.multi-language-sample,kotlin]
   ----
   tasks.withType<Test>().configureEach {
       if (!project.hasProperty("createReports")) {
           reports.html.required = false
           reports.junitXml.required = false
       }
   }
   ----
   .build.gradle
   [source.multi-language-sample,groovy]
   ----
   tasks.withType(Test).configureEach {
       if (!project.hasProperty("createReports")) {
           reports.html.required = false
           reports.junitXml.required = false
       }
   }
   ----
   ====
   
   Then, pass the property with `-PcreateReports` on the command line to generate the reports.
   
   ====
   [listing.terminal]
   ----
   $ gradle <task> -PcreateReports
   ----
   ====
   
   Or configure the property in the `gradle.properties` file in the project root or your Gradle home:
   
   ====
   .gradle.properties
   [source,properties]
   ----
   createReports=true
   ----
   ====
   
   === Optimize the compiler
   
   The Java compiler is fast. But if youre compiling hundreds of Java classes, even a short compilation time adds up.
   Gradle offers a several optimizations for Java compilation:
   
   * Run the compiler as a separate process
   * Switch internal-only dependencies to implementation visibility
   
   ==== Run the compiler as a separate process
   
   You can run the compiler as a separate process with the following configuration for any `JavaCompile` task:
   
   ====
   .build.gradle.kts
   [source.multi-language-sample,kotlin]
   ----
   <task>.options.isFork = true
   ----
   .build.gradle
   [source.multi-language-sample,groovy]
   ----
   <task>.options.fork = true
   ----
   ====
   
   To apply the configuration to _all_ Java compilation tasks, you can `configureEach` java compilation task:
   
   ====
   include::sample[dir="snippets/performance/parallelTestExecution/kotlin",files="build.gradle.kts[tags=fork-java]"]
   include::sample[dir="snippets/performance/parallelTestExecution/groovy",files="build.gradle[tags=fork-java]"]
   ====
   
   Gradle reuses this process within the duration the build, so the forking overhead is minimal.
   By forking memory-intensive compilation into a separate process, we minimize garbage collection in the main Gradle process.
   Less garbage collection means that Gradle's infrastructure can run faster, especially when you also use <<parallel_execution, parallel builds>>.
   
   Forking compilation rarely impacts the performance of small projects.
   But you should consider it if a single task compiles more than a thousand source files together.
   
   ==== Switch internal-only dependencies to implementation visibility
   
   NOTE: Only libraries can define `api` dependencies. Use the
   <<java_library_plugin.adoc#java_library_plugin,`java-library`>> plugin to define API dependencies in your libraries. Projects that use the `java` plugin cannot declare `api` dependencies.
   
   Before Gradle 3.4, projects declared dependencies using the `compile` configuration.
   This exposed all of those dependencies to downstream projects. In Gradle 3.4 and above,
   you can separate downstream-facing `api` dependencies from internal-only `implementation` details.
   Implementation dependencies don't leak into the compile classpath of downstream projects.
   When implementation details change, Gradle only recompiles `api` dependencies.
   
   ====
   .build.gradle.kts
   [source.multi-language-sample,kotlin]
   ----
   dependencies {
      api(project("my-utils"))
      implementation("com.google.guava:guava:21.0")
   }
   ----
   .build.gradle
   [source.multi-language-sample,groovy]
   ----
   dependencies {
      api project('my-utils')
      implementation 'com.google.guava:guava:21.0'
   }
   ----
   ====
   
   This can significantly reduce the "ripple" of recompilations caused by a single change in
   large multi-project builds.
   
   == Improve the performance of older Gradle releases
   
   Some projects cannot easily upgrade to a current Gradle version. While you should
   always upgrade Gradle to a recent version when possible, we recognize that it isn't always
   feasible for certain niche situations. In those select cases, check out these recommendations
   to optimize older versions of Gradle.
   
   === Enable the Daemon
   
   Gradle 3.0 and above enable the Daemon by default. If you are using an older version,
   you should <<update_gradle,update to the latest version of Gradle>>.
   If you cannot update your Gradle version, you can <<enable_daemon,enable the Daemon manually>>.
   
   === Use incremental compilation
   
   Gradle can analyze dependencies down to the individual class level
   to recompile only the classes affected by a change.
   Gradle 4.10 and above enable incremental compilation by default.
   To enable incremental compilation by default in older Gradle versions, add the following setting to your
   `build.gradle` file:
   
   ====
   .build.gradle.kts
   [source.multi-language-sample,kotlin]
   ----
   tasks.withType<JavaCompile>().configureEach {
       options.isIncremental = true
   }
   ----
   .build.gradle
   [source.multi-language-sample,groovy]
   ----
   tasks.withType(JavaCompile).configureEach {
       options.incremental = true
   }
   ----
   ====
   
   === Use compile avoidance
   
   Often, updates only change internal implementation details of your code, like the body of a method.
   These updates are known as _ABI-compatible_ changes: they have no impact on the binary interface of your project.
   In Gradle 3.4 and above, ABI-compatible changes no longer trigger recompiles of downstream projects.
   This especially improves build times in large multi-project builds with deep dependency chains.
   
   Upgrade to a Gradle version above 3.4 to benefit from compile avoidance.
   
   NOTE: If you use annotation processors, you need to explicitly declare them in order for compilation avoidance to work.
   To learn more, check out the <<java_plugin.adoc#sec:java_compile_avoidance,compile avoidance documentation>>.
   
   == Optimize Android projects
   
   Everything on this page applies to Android builds, since Android builds use Gradle.
   Yet Android introduces unique opportunities for optimization.
   For more information, check out the
   https://developer.android.com/studio/build/optimize-your-build.html[Android team performance guide].
   You can also https://www.youtube.com/watch?v=7ll-rkLCtyk[watch the accompanying talk]
   from Google IO 2017.

/docs/userguide/optimizing-performance/gradle_daemon.adoc
=========================================================

.. code-block::

   = Gradle Daemon
   
   A daemon is a computer program that runs as a background process rather than being under the direct control of an interactive user.
   
   Gradle runs on the Java Virtual Machine (JVM) and uses several supporting libraries with non-trivial initialization time.
   Startups can be slow.
   The **Gradle Daemon** solves this problem.
   
   The Gradle Daemon is a long-lived background process that reduces the time it takes to run a build.
   
   The Gradle Daemon reduces build times by:
   
   * Caching project information across builds
   * Running in the background so every Gradle build doesn't have to wait for JVM startup
   * Benefiting from continuous runtime optimization in the JVM
   * <<file_system_watching.adoc#sec:daemon_watch_fs,Watching the file system>> to calculate exactly what needs to be rebuilt before you run a build
   
   == Understanding the Daemon
   
   The Gradle JVM client sends the Daemon build information such as command line arguments, project directories, and environment variables so that it can run the build.
   The Wrapper is responsible for resolving dependencies, executing build scripts, creating and running tasks; when it is done, it sends the client the output.
   Communication between the client and the Daemon happens via a local socket connection.
   
   Daemons use the JVM's default minimum heap size.
   
   If the requested build environment does not specify a maximum heap size, the Daemon uses up to 512MB of heap.
   512MB is adequate for most builds.
   Larger builds with hundreds of subprojects, configuration, and source code may benefit from a larger heap size.
   
   == Check Daemon status
   
   To get a list of running Daemons and their statuses, use the `--status` command:
   
   ----
   $ gradle --status
   ----
   
   ----
      PID STATUS   INFO
    28486 IDLE     7.5
    34247 BUSY     7.5
   ----
   
   Currently, a given Gradle version can only connect to Daemons of the same version.
   This means the status output only shows Daemons spawned running the same version of Gradle as the current project.
   
   == Find Daemons
   
   If you have installed the Java Development Kit (JDK), you can view live daemons with the `jps` command.
   
   ----
   $ jps
   ----
   ----
   33920 Jps
   27171 GradleDaemon
   22792
   ----
   
   Live Daemons appear under the name `GradleDaemon`.
   Because this command uses the JDK, you can view Daemons running any version of Gradle.
   
   == Enable Daemon
   
   Gradle enables the Daemon by default since Gradle 3.0.
   If your project doesn't use the Daemon, you can enable it for a single build with the `--daemon` flag when you run a build:
   
   ----
   $ gradle <task> --daemon
   ----
   
   This flag overrides any settings that disable the Daemon in your project or user `gradle.properties` files.
   
   To enable the Daemon by default in older Gradle versions, add the following setting to the `gradle.properties` file in the project root or your Gradle User Home (`GRADLE_USER_HOME`:
   
   ====
   .gradle.properties
   [source,properties]
   ----
   org.gradle.daemon=true
   ----
   ====
   
   == Disable Daemon
   
   You can disable the Daemon in multiple ways but there are important considerations:
   
   Single-use Daemon :: If the JVM args of the client process don't match what the build requires, a single-used Daemon (disposable JVM) is created.
   This means the Daemon is required for the build, so it is created, used, and then stopped at the end of the build.
   
   No Daemon :: If the `JAVA_OPTS` and `GRADLE_OPTS` match `org.gradle.jvmargs`, the Daemon will not be used at all since the build happens in the client JVM.
   
   === Disable for a build
   
   To disable the Daemon for a single build, pass the `--no-daemon` flag when you run a build:
   
   ----
   $ gradle <task> --no-daemon
   ----
   
   This flag overrides any settings that enable the Daemon in your project including the `gradle.properties` files.
   
   === Disable for a project
   
   To disable the Daemon for all builds of a project, add `org.gradle.daemon=false` to the `gradle.properties` file in the project root.
   
   === Disable for a user
   
   On Windows, this command disables the Daemon for the current user:
   
   [source,text]
   ----
   (if not exist "%USERPROFILE%/.gradle" mkdir "%USERPROFILE%/.gradle") && (echo. >> "%USERPROFILE%/.gradle/gradle.properties" && echo org.gradle.daemon=false >> "%USERPROFILE%/.gradle/gradle.properties")
   ----
   
   On UNIX-like operating systems, the following Bash shell command disables the Daemon for the current user:
   
   [source,bash]
   ----
   mkdir -p ~/.gradle && echo "org.gradle.daemon=false" >> ~/.gradle/gradle.properties
   ----
   
   === Disable globally
   
   There are two recommended ways to disable the Daemon globally across an environment:
   
   * add `org.gradle.daemon=false` to the `$<<directory_layout.adoc#dir:gradle_user_home,GRADLE_USER_HOME>>`/gradle.properties` file
   * add the flag `-Dorg.gradle.daemon=false` to the `GRADLE_OPTS` environment variable
   
   Don't forget to make sure your JVM arguments and `GRADLE_OPTS` / `JAVA_OPTS` match if you want to completely disable the Daemon and not simply invoke a single-use one.
   
   == Stop Daemon
   
   It can be helpful to stop the Daemon when troubleshooting or debugging a failure.
   
   Daemons automatically stop given any of the following conditions:
   
   * Available system memory is low
   * Daemon has been idle for 3 hours
   
   To stop running Daemon processes, use the following command:
   
   ----
   $ gradle --stop
   ----
   
   This terminates all Daemon processes started with the same version of Gradle used to execute the command.
   
   You can also kill Daemons manually with your operating system.
   To find the PIDs for all Daemons regardless of Gradle version, see <<gradle_daemon.adoc#find_all_daemons,Find Daemons>>.
   
   == Tools & IDEs
   
   The <<third_party_integration.adoc#embedding,Gradle Tooling API>> used by IDEs and other tools to integrate with Gradle _always_ uses the Gradle Daemon to execute builds.
   If you execute Gradle builds from within your IDE, you already use the Gradle Daemon.
   There is no need to enable it for your environment.
   
   == Continuous Integration
   
   We recommend using the Daemon for developer machines and Continuous Integration (CI) servers.
   
   == Compatibility
   
   Gradle starts a new Daemon if no idle or compatible Daemons exist.
   
   The following values determine compatibility:
   
   * *Requested build environment*, including the following:
   ** Java version
   ** JVM attributes
   ** JVM properties
   * Gradle version
   
   Compatibility is based on exact matches of these values.
   For example:
   
   * If a Daemon is available with a Java 8 runtime, but the requested build environment calls for Java 10,
   then the Daemon is not compatible.
   
   * If a Daemon is available running Gradle 7.0, but the current build uses Gradle 7.4, then the
   Daemon is not compatible.
   
   Certain properties of a Java runtime are _immutable_: they cannot be changed once the JVM has started.
   The following JVM system properties are immutable:
   
   * `file.encoding`
   * `user.language`
   * `user.country`
   * `user.variant`
   * `java.io.tmpdir`
   * `javax.net.ssl.keyStore`
   * `javax.net.ssl.keyStorePassword`
   * `javax.net.ssl.keyStoreType`
   * `javax.net.ssl.trustStore`
   * `javax.net.ssl.trustStorePassword`
   * `javax.net.ssl.trustStoreType`
   * `com.sun.management.jmxremote`
   
   The following JVM attributes controlled by startup arguments are also immutable:
   
   * The maximum heap size (the `-Xmx` JVM argument)
   * The minimum heap size (the `-Xms` JVM argument)
   * The boot classpath (the `-Xbootclasspath` argument)
   * The "assertion" status (the `-ea` argument)
   
   If the requested build environment requirements for any of these properties and attributes
   differ from the Daemon's JVM requirements, the Daemon is not compatible.
   
   NOTE: For more information about build environments, see <<build_environment.adoc#build_environment,the build environment documentation>>.
   
   == Performance Impact
   
   The Daemon can reduce build times by 15-75% when you build the same project repeatedly.
   
   TIP: To understand the Daemon's impact on your builds, you can profile your build with `--profile`.
   
   In between builds, the Daemon waits idly for the next build.
   As a result, your machine only loads Gradle into memory once for multiple builds instead of once per build.
   This is a significant performance optimization.
   
   === Runtime Code Optimizations
   
   The JVM gains significant performance from **runtime code optimization**: optimizations applied to code while it runs.
   
   JVM implementations like OpenJDK's Hotspot progressively optimize code during execution.
   Consequently, subsequent builds can be faster purely due to this optimization process.
   
   With the Daemon, perceived build times can drop dramatically between a project's 1^st^ and 10^th^ builds.
   
   === Memory Caching
   
   The Daemon enables in-memory caching across builds.
   This includes classes for plugins and build scripts.
   
   Similarly, the Daemon maintains in-memory caches of build data, such as the hashes of task inputs and outputs for incremental builds.
   
   == Performance Monitoring
   
   Gradle actively monitors heap usage to detect memory leaks in the Daemon.
   
   When a memory leak exhausts available heap space, the Daemon:
   
   . Finishes the currently running build.
   . Restarts before running the next build.
   
   Gradle enables this monitoring by default.
   
   To disable this monitoring, set the `org.gradle.daemon.performance.enable-monitoring` Daemon option to `false`.
   
   You can do this on the command line with the following command:
   
   ----
   $ gradle <task> -Dorg.gradle.daemon.performance.enable-monitoring=false
   ----
   
   Or you can configure the property in the `gradle.properties` file in the project root or your GRADLE_USER_HOME (Gradle User Home):
   
   ====
   .gradle.properties
   [source,properties]
   ----
   org.gradle.daemon.performance.enable-monitoring=false
   ----
   ====

/docs/userguide/optimizing-performance/file_system_watching.adoc
================================================================

.. code-block::

   = File System Watching
   
   Gradle maintains a Virtual File System (VFS) to calculate what needs to be rebuilt on repeat builds of a project.
   By watching the file system, Gradle keeps the VFS current between builds.
   
   == Enable
   
   Gradle enables file system watching by default for supported operating systems since Gradle 7.
   
   Run the build with the '--watch-fs' flag to force file system watching for a build.
   
   To force file system watching for all builds (unless disabled with `--no-watch-fs`), add the following value to `gradle.properties`:
   
   ====
   .gradle.properties
   [source,properties]
   ----
   org.gradle.vfs.watch=true
   ----
   ====
   
   == Disable
   
   To disable file system watching:
   
   * use the `--no-watch-fs` flag
   * set `org.gradle.vfs.watch=false` in `gradle.properties`
   
   == Supported Operating Systems
   
   Gradle uses native operating system features to watch the file system.
   Gradle supports file system watching on the following operating systems:
   
   * Windows 10, version 1709 and later
   * Linux, tested on the following distributions:
   ** Ubuntu 16.04 or later
   ** CentOS Stream 8 or later
   ** Red Hat Enterprise Linux (RHEL) 8 or later
   ** Amazon Linux 2 or later
   * macOS 10.14 (Mojave) or later on Intel and ARM architectures
   
   == Supported File Systems
   
   File system watching supports the following file system types:
   
   * APFS
   * btrfs
   * ext3
   * ext4
   * XFS
   * HFS+
   * NTFS
   
   Gradle also supports VirtualBox's shared folders.
   
   Network file systems like Samba and NFS are not supported.
   
   .Symlinks
   --
   File system watching is not compatible with symlinks.
   If your project files include symlinks, symlinked files do not benefit from file system-watching optimizations.
   --
   
   == Unsupported File Systems
   
   When enabled by default, file system watching acts conservatively when it encounters content on unsupported file systems.
   This can happen if you mount a project directory or subdirectory from a network drive.
   Gradle doesn't retain information about unsupported file systems between builds when enabled by default.
   If you explicitly enable file system watching, Gradle retains information about unsupported file systems between builds.
   
   == Logging
   
   To view information about Virtual File System (VFS) changes at the beginning and end of a build, enable verbose VFS logging.
   
   Set the `org.gradle.vfs.verbose` Daemon option to `true` to enable verbose logging.
   
   You can do this on the command line with the following command:
   
   ----
   $ gradle <task> -Dorg.gradle.vfs.verbose=true
   ----
   
   Or configure the property in the `gradle.properties` file in the project root or your Gradle User Home:
   
   ====
   .gradle.properties
   [source,properties]
   ----
   org.gradle.vfs.verbose=true
   ----
   ====
   
   This produces the following output at the start and end of the build:
   
   ----
   $ gradle assemble --watch-fs -Dorg.gradle.vfs.verbose=true
   ----
   ----
   Received 3 file system events since last build while watching 1 locations
   Virtual file system retained information about 2 files, 2 directories and 0 missing files since last build
   > Task :compileJava NO-SOURCE
   > Task :processResources NO-SOURCE
   > Task :classes UP-TO-DATE
   > Task :jar UP-TO-DATE
   > Task :assemble UP-TO-DATE
   
   BUILD SUCCESSFUL in 58ms
   1 actionable task: 1 up-to-date
   Received 5 file system events during the current build while watching 1 locations
   Virtual file system retains information about 3 files, 2 directories and 2 missing files until next build
   ----
   
   On Windows and macOS, Gradle might report changes received since the last build, even if you haven't changed anything.
   These are harmless notifications about changes to Gradle's caches and can be safely ignored.
   
   == Troubleshooting
   
   Gradle does not detect some changes::
   _Please https://gradle-community.slack.com/app_redirect?channel=file-system-watching[let us know on the Gradle community Slack]._
   If a build declares its inputs and outputs correctly, this should not happen.
   So it's either a bug we must fix or your build lacks declaration for some inputs or outputs.
   
   VFS state dropped due to lost state::
   Did you receive a message that reads `Dropped VFS state due to lost state` during a build?
   _Please https://gradle-community.slack.com/app_redirect?channel=file-system-watching[let us know on the Gradle community Slack]._
   This means that your build cannot benefit from file system watching for one of the following reasons:
   
   * the Daemon received an unknown file system event
   * too many changes happened, and the watching API couldn't handle it
   
   Too many open files on macOS::
   If you receive the `java.io.IOException: Too many open files` error on macOS, raise your open files limit.
   See https://superuser.com/a/443168/8117[this post] for more details.
   
   ===  Adjust inotify Limits on Linux
   
   File system watching uses http://en.wikipedia.org/wiki/Inotify[inotify] on Linux.
   Depending on the size of your build, it may be necessary to increase inotify limits.
   If you are using an IDE, then you probably already had to increase the limits in the past.
   
   File system watching uses one inotify watch per watched directory.
   You can see the current limit of inotify watches per user by running:
   
   [source,bash]
   ----
   cat /proc/sys/fs/inotify/max_user_watches
   ----
   
   To increase the limit to e.g. 512K watches run the following:
   
   [source,bash]
   ----
   echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf
   ----
   [source,bash]
   ----
   sudo sysctl -p --system
   ----
   
   Each used inotify watch takes up to 1KB of memory.
   Assuming inotify uses all the 512K watches then file system watching could use up to 500MB.
   In a memory-constrained environment, you may want to disable file system watching.

/docs/userguide/optimizing-performance/incremental_build.adoc
=============================================================

.. code-block::

   = Incremental build
   
   An important part of any build tool is the ability to avoid doing work that has already been done.
   Consider the process of compilation.
   Once your source files have been compiled, there should be no need to recompile them unless something has changed that affects the output, such as the modification of a source file or the removal of an output file.
   And compilation can take a significant amount of time, so skipping the step when it뗩 not needed saves a lot of time.
   
   Gradle supports this behavior out of the box through a feature called *incremental build*.
   You have almost certainly already seen it in action.
   When you run a task and the task is marked with `UP-TO-DATE` in the console output, this means incremental build is at work.
   
   How does an incremental build work? How can you make sure your tasks support running incrementally? Let뗩 take a look.
   
   == Task inputs and outputs
   
   In the most common case, a task takes some inputs and generates some outputs.
   We can consider the process of Java compilation as an example of a task.
   The Java source files act as inputs of the task, while the generated class files, i.e. the result of the compilation, are the outputs of the task.
   
   .Example task inputs and outputs
   image::taskInputsOutputs.png[]
   
   An important characteristic of an input is that it affects one or more outputs, as you can see from the previous figure. Different bytecode is generated depending on the content of the source files and the minimum version of the Java runtime you want to run the code on. That makes them task inputs. But whether compilation has 500MB or 600MB of maximum memory available, determined by the `memoryMaximumSize` property, has no impact on what bytecode gets generated. In Gradle terminology, `memoryMaximumSize` is just an internal task property.
   
   As part of incremental build, Gradle tests whether any of the task inputs or outputs has changed since the last build. If they haven뗪, Gradle can consider the task up to date and therefore skip executing its actions. Also note that incremental build won뗪 work unless a task has at least one task output, although tasks usually have at least one input as well.
   
   What this means for build authors is simple: you need to tell Gradle which task properties are inputs and which are outputs. If a task property affects the output, be sure to register it as an input, otherwise the task will be considered up to date when it뗩 not. Conversely, don뗪 register properties as inputs if they don뗪 affect the output, otherwise the task will potentially execute when it doesn뗪 need to. Also be careful of non-deterministic tasks that may generate different output for exactly the same inputs: these should not be configured for incremental build as the up-to-date checks won뗪 work.
   
   Let뗩 now look at how you can register task properties as inputs and outputs.
   
   == Declaring inputs and outputs via annotations
   
   If youre implementing a custom task as a class, then it takes just two steps to make it work with incremental build:
   
   . Create typed properties (via getter methods) for each of your task inputs and outputs
   . Add the appropriate annotation to each of those properties
   
   NOTE: Annotations must be placed on getters or on Groovy properties. Annotations placed on setters, or on a Java field without a corresponding annotated getter, are ignored.
   
   Gradle supports four main categories of inputs and outputs:
   
   * Simple values
   +
   Things like strings and numbers. More generally, a simple value can have any type that implements `Serializable`.
   
   * Filesystem types
   +
   These consist of `RegularFile`, `Directory` and the standard `File` class but also derivatives of Gradle뗩 link:{javadocPath}#[FileCollection] type and anything else that can be passed to either the link:{groovyDslPath}#[Project.file(java.lang.Object)] method  for single file/directory properties  or the link:{groovyDslPath}#[]++)[Project.files(java.lang.Object++...++)] method.
   
   * Dependency resolution results
   +
   This includes the link:{javadocPath}#[ResolvedArtifactResult] type for artifact metadata and the link:{javadocPath}#[ResolvedComponentResult] type for dependency graphs.
   Note that they are only supported wrapped in a `Provider`.
   
   * Nested values
   +
   Custom types that don뗪 conform to the other two categories but have their own properties that are inputs or outputs. In effect, the task inputs or outputs are nested inside these custom types.
   
   As an example, imagine you have a task that processes templates of varying types, such as FreeMarker, Velocity, Moustache, etc. It takes template source files and combines them with some model data to generate populated versions of the template files.
   
   This task will have three inputs and one output:
   
   * Template source files
   * Model data
   * Template engine
   * Where the output files are written
   
   When youre writing a custom task class, it뗩 easy to register properties as inputs or outputs via annotations. To demonstrate, here is a skeleton task implementation with some suitable inputs and outputs, along with their annotations:
   
   .Custom task class
   ====
   [source,java]
   .buildSrc/src/main/java/org/example/ProcessTemplates.java
   ----
   include::{snippetsPath}/tasks/incrementalBuild-customTaskClass/groovy/buildSrc/src/main/java/org/example/ProcessTemplates.java[tag=custom-task-class]
   ----
   
   [source,java]
   .buildSrc/src/main/java/org/example/TemplateData.java
   ----
   include::{snippetsPath}/tasks/incrementalBuild-customTaskClass/groovy/buildSrc/src/main/java/org/example/TemplateData.java[]
   ----
   
   .Output of `gradle processTemplates`
   ----
   > gradle processTemplates
   include::{snippetsPath}/tasks/incrementalBuild-customTaskClass/tests/customTaskClassWithInputOutputAnnotations.out[]
   ----
   
   .Output of `gradle processTemplates` (run again)
   ----
   > gradle processTemplates
   include::{snippetsPath}/tasks/incrementalBuild-customTaskClass/tests/customTaskClassWithInputOutputAnnotationsUpToDateWithoutCC.out[]
   ----
   ====
   
   There뗩 plenty to talk about in this example, so let뗩 work through each of the input and output properties in turn:
   
   * `templateEngine`
   +
   Represents which engine to use when processing the source templates, e.g. FreeMarker, Velocity, etc. You could implement this as a string, but in this case we have gone for a custom enum as it provides greater type information and safety. Since enums implement `Serializable` automatically, we can treat this as a simple value and use the `@Input` annotation, just as we would with a `String` property.
   
   * `sourceFiles`
   +
   The source templates that the task will be processing. Single files and collections of files need their own special annotations. In this case, were dealing with a collection of input files and so we use the `@InputFiles` annotation. You뗣l see more file-oriented annotations in a table later.
   
   * `templateData`
   +
   For this example, were using a custom class to represent the model data. However, it does not implement `Serializable`, so we can뗪 use the `@Input` annotation. That뗩 not a problem as the properties within `TemplateData`  a string and a hash map with serializable type parameters  are serializable and can be annotated with `@Input`. We use `@Nested` on `templateData` to let Gradle know that this is a value with nested input properties.
   
   * `outputDir`
   +
   The directory where the generated files go. As with input files, there are several annotations for output files and directories. A property representing a single directory requires `@OutputDirectory`. You뗣l learn about the others soon.
   
   These annotated properties mean that Gradle will skip the task if none of the source files, template engine, model data or generated files has changed since the previous time Gradle executed the task. This will often save a significant amount of time. You can learn how Gradle detects <<#sec:how_does_it_work,changes later>>.
   
   This example is particularly interesting because it works with collections of source files. What happens if only one source file changes? Does the task process all the source files again or just the modified one? That depends on the task implementation. If the latter, then the task itself is incremental, but that뗩 a different feature to the one were discussing here. Gradle does help task implementers with this via its <<custom_tasks.adoc#incremental_tasks,incremental task inputs>> feature.
   
   Now that you have seen some of the input and output annotations in practice, let뗩 take a look at all the annotations available to you and when you should use them. The table below lists the available annotations and the corresponding property type you can use with each one.
   
   .Incremental build property type annotations
   [cols="a,a,a", options="header"]
   |===
   | Annotation
   | Expected property type
   | Description
   
   | `@link:{javadocPath}#[Input]`
   | Any `Serializable` type or dependency resolution result types
   | A simple input value or dependency resolution results
   
   | `@link:{javadocPath}#[InputFile]`
   | `File`*
   | A single input file (not directory)
   
   | `@link:{javadocPath}#[InputDirectory]`
   | `File`*
   | A single input directory (not file)
   
   | `@link:{javadocPath}#[InputFiles]`
   | `Iterable&lt;File&gt;`*
   | An iterable of input files and directories
   
   | `@link:{javadocPath}#[Classpath]`
   | `Iterable&lt;File&gt;`*
   | An iterable of input files and directories that represent a Java classpath. This allows the task to ignore irrelevant changes to the property, such as different names for the same files. It is similar to annotating the property `@PathSensitive(RELATIVE)` but it will ignore the names of JAR files directly added to the classpath, and it will consider changes in the order of the files as a change in the classpath. Gradle will inspect the contents of jar files on the classpath and ignore changes that do not affect the semantics of the classpath (such as file dates and entry order). See also <<#sec:task_input_using_classpath_annotations,Using the classpath annotations>>.
   
   **Note:** The `@Classpath` annotation was introduced in Gradle 3.2. To stay compatible with earlier Gradle versions, classpath properties should also be annotated with `@InputFiles`.
   
   | `@link:{javadocPath}#[CompileClasspath]`
   | `Iterable&lt;File&gt;`*
   | An iterable of input files and directories that represent a Java compile classpath. This allows the task to ignore irrelevant changes that do not affect the API of the classes in classpath. See also <<#sec:task_input_using_classpath_annotations,Using the classpath annotations>>.
   
   The following kinds of changes to the classpath will be ignored:
   
   * Changes to the path of jar or top level directories.
   * Changes to timestamps and the order of entries in Jars.
   * Changes to resources and Jar manifests, including adding or removing resources.
   * Changes to private class elements, such as private fields, methods and inner classes.
   * Changes to code, such as method bodies, static initializers and field initializers (except for constants).
   * Changes to debug information, for example when a change to a comment affects the line numbers in class debug information.
   * Changes to directories, including directory entries in Jars.
   
   *NOTE* - The `@CompileClasspath` annotation was introduced in Gradle 3.4. To stay compatible with Gradle 3.3 and 3.2, compile classpath properties should also be annotated with `@Classpath`. For compatibility with Gradle versions before 3.2 the property should also be annotated with `@InputFiles`.
   
   | `@link:{javadocPath}#[OutputFile]`
   | `File`*
   | A single output file (not directory)
   
   | `@link:{javadocPath}#[OutputDirectory]`
   | `File`*
   | A single output directory (not file)
   
   | `@link:{javadocPath}#[OutputFiles]`
   | `Map&lt;String, File&gt;`+++**+++ or `Iterable&lt;File&gt;`+++*+++
   | An iterable or map of output files.
   Using a file tree turns <<build_cache.adoc#sec:task_output_caching, caching>> off for the task.
   
   | `@link:{javadocPath}#[OutputDirectories]`
   | `Map&lt;String, File&gt;`+++**+++ or `Iterable&lt;File&gt;`+++*+++
   | An iterable of output directories.
   Using a file tree turns <<build_cache.adoc#sec:task_output_caching, caching>> off for the task.
   
   | `@link:{javadocPath}#[Destroys]`
   | `File` or `Iterable&lt;File&gt;`+++*+++
   | Specifies one or more files that are removed by this task.  Note that a task can define either inputs/outputs or destroyables, but not both.
   
   | `@link:{javadocPath}#[LocalState]`
   | `File` or `Iterable&lt;File&gt;`+++*+++
   | Specifies one or more files that represent the <<custom_tasks.adoc#sec:storing_incremental_task_state,local state of the task>>. These files are removed when the task is loaded from cache.
   
   | `@link:{javadocPath}#[Nested]`
   | Any custom type
   | A custom type that may not implement `Serializable` but does have at least one field or property marked with one of the annotations in this table. It could even be another `@Nested`.
   
   | `@link:{javadocPath}#[Console]`
   | Any type
   | Indicates that the property is neither an input nor an output. It simply affects the console output of the task in some way, such as increasing or decreasing the verbosity of the task.
   
   | `@link:{javadocPath}#[Internal]`
   | Any type
   | Indicates that the property is used internally but is neither an input nor an output.
   
   | `@link:{javadocPath}#[ReplacedBy]`
   | Any type
   | Indicates that the property has been replaced by another and should be ignored as an input or output.
   
   | [[skip-when-empty]]`@link:{javadocPath}#[SkipWhenEmpty]`
   | `File` or `Iterable&lt;File&gt;`+++*+++
   | Used with `@InputFiles` or `@InputDirectory` to tell Gradle to skip the task if the corresponding files or directory are empty, along with all other input files declared with this annotation. Tasks that have been skipped due to all of their input files that were declared with this annotation being empty will result in a distinct 랉o source outcome. For example, `NO-SOURCE` will be emitted in the console output.
   
   Implies `<<#incremental,@Incremental>>`.
   
   | [[incremental]]`@link:{javadocPath}#[Incremental]`
   | `Provider<FileSystemLocation>` or `FileCollection`
   | Used with `@InputFiles` or `@InputDirectory` to instruct Gradle to track changes to the annotated file property, so the changes can be queried via `@link:{groovyDslPath}#[InputChanges.getFileChanges()]`. Required for <<custom_tasks.adoc#incremental_tasks,incremental tasks>>.
   
   | `@link:{javadocPath}#[Optional]`
   | Any type
   | Used with any of the property type annotations listed in the link:{javadocPath}#[Optional] API documentation. This annotation disables validation checks on the corresponding property. See <<#sec:task_input_output_validation,the section on validation>> for more details.
   
   | `@link:{javadocPath}#[PathSensitive]`
   | `File` or `Iterable&lt;File&gt;`+++*+++
   | [[inputs_path_sensitivity]]Used with any input file property to tell Gradle to only consider the given part of the file paths as important. For example, if a property is annotated with `@PathSensitive(PathSensitivity.NAME_ONLY)`, then moving the files around without changing their contents will not make the task out-of-date.
   
   | `@link:{javadocPath}#[IgnoreEmptyDirectories]`
   | `File` or `Iterable&lt;File&gt;`+++*+++
   | Used with `@InputFiles` or `@InputDirectory` to instruct Gradle to track only changes to the contents of directories and not differences in the directories themselves. For example, removing, renaming or adding an empty directory somewhere in the directory structure will not make the task out-of-date.
   
   | `@link:{javadocPath}#[NormalizeLineEndings]`
   | `File` or `Iterable&lt;File&gt;`+++*+++
   | Used with `@InputFiles`, `@InputDirectory` or `@Classpath` to instruct Gradle to normalize line endings when calculating up-to-date checks or build cache keys. For example, switching a file between Unix line endings and Windows line endings (or vice-versa) will not make the task out-of-date.
   |===
   
   [NOTE]
   ====
   `File` can be any type accepted by link:{groovyDslPath}#[Project.file(java.lang.Object)] and `Iterable&lt;File&gt;` can be any type accepted by link:{groovyDslPath}#[]++)[Project.files(java.lang.Object...)].
   This includes instances of `Callable`, such as closures, allowing for lazy evaluation of the property values.
   Be aware that the types `FileCollection` and `FileTree` are ``Iterable&lt;File&gt;``s.
   
   Similar to the above, `File` can be any type accepted by link:{groovyDslPath}#[Project.file(java.lang.Object)]. The `Map` itself can be wrapped in ``Callable``s, such as closures.
   ====
   
   Annotations are inherited from all parent types including implemented interfaces. Property type annotations override any other property type annotation declared in a parent type. This way an `@InputFile` property can be turned into an `@InputDirectory` property in a child task type.
   
   Annotations on a property declared in a type override similar annotations declared by the superclass and in any implemented interfaces. Superclass annotations take precedence over annotations declared in implemented interfaces.
   
   The link:{javadocPath}#[Console] and link:{javadocPath}#[Internal] annotations in the table are special cases as they don뗪 declare either task inputs or task outputs. So why use them? It's so that you can take advantage of the <<java_gradle_plugin.adoc#java_gradle_plugin,Java Gradle Plugin Development plugin>> to help you develop and publish your own plugins. This plugin checks whether any properties of your custom task classes lack an incremental build annotation. This protects you from forgetting to add an appropriate annotation during development.
   
   === Using dependency resolution results
   
   Dependency resolution results can be consumed as task inputs in two ways.
   First by consuming the graph of the resolved metadata using link:{javadocPath}#[ResolvedComponentResult].
   Second by consuming the flat set of the resolved artifacts using link:{javadocPath}#[ResolvedArtifactResult].
   
   A resolved graph can be obtained lazily from the incoming resolution result of a `Configuration` and wired to an `@Input` property:
   
   .Resolved graph as task input
   ====
   .Task declaration
   [source,java]
   ----
   include::{samplesPath}/writing-tasks/tasks-with-dependency-resolution-result-inputs/common/dependency-reports/src/main/java/com/example/GraphResolvedComponents.java[tag=inputs]
   ----
   .Task configuration
   [source,java]
   ----
   include::{samplesPath}/writing-tasks/tasks-with-dependency-resolution-result-inputs/common/dependency-reports/src/main/java/com/example/DependencyReportsPlugin.java[tag=graphResolvedComponents]
   ----
   ====
   
   The resolved set of artifacts can be obtained lazily from the incoming artifacts of a `Configuration`.
   Given the `ResolvedArtifactResult` type contains both metadata and file information, instances need to be transformed to metadata only before being wired to an `@Input` property:
   
   .Resolved artifacts as task input
   ====
   .Task declaration
   [source,java]
   ----
   include::{samplesPath}/writing-tasks/tasks-with-dependency-resolution-result-inputs/common/dependency-reports/src/main/java/com/example/ListResolvedArtifacts.java[tag=inputs]
   ----
   .Task configuration
   [source,java]
   ----
   include::{samplesPath}/writing-tasks/tasks-with-dependency-resolution-result-inputs/common/dependency-reports/src/main/java/com/example/DependencyReportsPlugin.java[tag=listResolvedArtifacts]
   ----
   ====
   
   Both graph and flat results can be combined and augmented with resolved file information.
   This is all demonstrated in the link:#[Tasks with dependency resolution result inputs] sample.
   
   === Using the classpath annotations
   
   Besides `@InputFiles`, for JVM-related tasks Gradle understands the concept of classpath inputs. Both runtime and compile classpaths are treated differently when Gradle is looking for changes.
   
   As opposed to input properties annotated with `@link:{javadocPath}#[InputFiles]`, for classpath properties the order of the entries in the file collection matter.
   On the other hand, the names and paths of the directories and jar files on the classpath itself are ignored.
   Timestamps and the order of class files and resources inside jar files on a classpath are ignored, too, thus recreating a jar file with different file dates will not make the task out of date.
   
   Runtime classpaths are marked with `@link:{javadocPath}#[Classpath]`, and they offer further customization via <<#sec:configure_input_normalization,classpath normalization>>.
   
   Input properties annotated with `@link:{javadocPath}#[CompileClasspath]` are considered Java compile classpaths.
   Additionally to the aforementioned general classpath rules, compile classpaths ignore changes to everything but class files. Gradle uses the same class analysis described in <<java_plugin.adoc#sec:java_compile_avoidance,Java compile avoidance>> to further filter changes that don't affect the class' ABIs.
   This means that changes which only touch the implementation of classes do not make the task out of date.
   
   === Nested inputs
   
   When analyzing `@link:{javadocPath}#[Nested]` task properties for declared input and output sub-properties Gradle uses the type of the actual value.
   Hence it can discover all sub-properties declared by a runtime sub-type.
   
   When adding `@link:{javadocPath}#[Nested]` to a `link:{javadocPath}#[Provider]`, the value of the `Provider` is treated as a nested input.
   
   When adding `@link:{javadocPath}#[Nested]` to an iterable, each element is treated as a separate nested input.
   Each nested input in the iterable is assigned a name, which by default is the dollar sign followed by the index in the iterable, e.g. `$2`.
   If an element of the iterable implements `link:{javadocPath}#[Named]`, then the name is used as property name.
   The ordering of the elements in the iterable is crucial for reliable up-to-date checks and caching if not all of the elements implement `link:{javadocPath}#[Named]`.
   Multiple elements which have the same name are not allowed.
   
   When adding `@link:{javadocPath}#[Nested]` to a map, then for each value a nested input is added, using the key as name.
   
   The type and classpath of nested inputs is tracked, too.
   This ensures that changes to the implementation of a nested input causes the build to be out of date.
   By this it is also possible to add user provided code as an input, e.g. by annotating an `@link:{javadocPath}#[Action]` property with `@link:{javadocPath}#[Nested]`.
   Note that any inputs to such actions should be tracked, either by annotated properties on the action or by manually registering them with the task.
   
   Using nested inputs allows richer modeling and extensibility for tasks, as e.g. shown by link:{groovyDslPath}#[Test.getJvmArgumentProviders()].
   
   This allows us to model the JaCoCo Java agent, thus declaring the necessary JVM arguments and providing the inputs and outputs to Gradle:
   
   ====
   [source,java]
   .JacocoAgent.java
   ----
   class JacocoAgent implements CommandLineArgumentProvider {
       private final JacocoTaskExtension jacoco;
   
       public JacocoAgent(JacocoTaskExtension jacoco) {
           this.jacoco = jacoco;
       }
   
       @Nested
       @Optional
       public JacocoTaskExtension getJacoco() {
           return jacoco.isEnabled() ? jacoco : null;
       }
   
       @Override
       public Iterable<String> asArguments() {
           return jacoco.isEnabled() ? ImmutableList.of(jacoco.getAsJvmArg()) : Collections.<String>emptyList();
       }
   }
   
   test.getJvmArgumentProviders().add(new JacocoAgent(extension));
   ----
   ====
   
   For this to work, `link:{groovyDslPath}#[JacocoTaskExtension]` needs to have the correct input and output annotations.
   
   The approach works for Test JVM arguments, since `link:{groovyDslPath}#[Test.getJvmArgumentProviders()]` is an `Iterable` annotated with `@link:{javadocPath}#[Nested]`.
   
   There are other task types where this kind of nested inputs are available:
   
   * link:{groovyDslPath}#[JavaExec.getArgumentProviders()] - model e.g. custom tools
   * link:{groovyDslPath}#[JavaExec.getJvmArgumentProviders()] - used for Jacoco Java agent
   * link:{groovyDslPath}#[CompileOptions.getCompilerArgumentProviders()] - model e.g. annotation processors
   * link:{groovyDslPath}#[Exec.getArgumentProviders()] - model e.g. custom tools
   * link:{groovyDslPath}#[JavaCompile.getOptions().getForkOptions().getJvmArgumentProviders()] - model Java compiler daemon command line arguments
   * link:{groovyDslPath}#[GroovyCompile.getGroovyOptions().getForkOptions().getJvmArgumentProviders()] - model Groovy compiler daemon command line arguments
   * link:{groovyDslPath}#[ScalaCompile.getScalaOptions().getForkOptions().getJvmArgumentProviders()] - model Scala compiler daemon command line arguments
   
   In the same way, this kind of modelling is available to custom tasks.
   
   === Validation at runtime
   
   When executing the build Gradle checks if task types are declared with the proper annotations.
   It tries to identify problems where e.g. annotations are used on incompatible types, or on setters etc.
   Any getter not annotated with an input/output annotation is also flagged.
   These problems then fail the build or are turned into deprecation warnings when the task is executed.
   
   Tasks that have a validation warning are executed *without any optimizations*.
   Specifically, they never can be:
   
   * up-to-date,
   * loaded from or stored in the <<build_cache.adoc#build_cache,build cache>>,
   * executed in parallel with other tasks, even if <<performance.adoc#parallel_execution,parallel execution>> is enabled,
   * executed incrementally.
   
   The in-memory representation of the file system state (_<<file_system_watching.adoc#sec:daemon_watch_fs,Virtual File System>>)_ is also invalidated before an invalid task is executed.
   
   == Declaring inputs and outputs via the runtime API
   
   Custom task classes are an easy way to bring your own build logic into the arena of incremental build, but you don뗪 always have that option. That's why Gradle also provides an alternative API that can be used with any tasks, which we look at next.
   
   When you don뗪 have access to the source for a custom task class, there is no way to add any of the annotations we covered in the previous section. Fortunately, Gradle provides a runtime API for scenarios just like that. It can also be used for ad-hoc tasks, as you'll see next.
   
   === Declaring inputs and outputs of ad-hoc tasks
   
   This runtime API is provided through a couple of aptly named properties that are available on every Gradle task:
   
   * link:{groovyDslPath}#[Task.getInputs()] of type link:{javadocPath}#[TaskInputs]
   * link:{groovyDslPath}#[Task.getOutputs()] of type link:{javadocPath}#[TaskOutputs]
   * link:{groovyDslPath}#[Task.getDestroyables()] of type link:{javadocPath}#[TaskDestroyables]
   
   These objects have methods that allow you to specify files, directories and values which constitute the task뗩 inputs and outputs.
   In fact, the runtime API has almost feature parity with the annotations.
   
   It lacks equivalents for
   
   * `@link:{javadocPath}#[Nested]`
   * `@link:{javadocPath}#[Classpath]`
   * `@link:{javadocPath}#[CompileClasspath]`
   * `@link:{javadocPath}#[LocalState]`
   * `@link:{javadocPath}#[ReplacedBy]`
   * `@link:{javadocPath}#[Internal]`
   
   Let뗩 take the template processing example from before and see how it would look as an ad-hoc task that uses the runtime API:
   
   .Ad-hoc task
   ====
   include::sample[dir="snippets/tasks/incrementalBuild-customTaskClass/kotlin",files="build.gradle.kts[tags=ad-hoc-task]"]
   include::sample[dir="snippets/tasks/incrementalBuild-customTaskClass/groovy",files="build.gradle[tags=ad-hoc-task]"]
   
   .Output of **`gradle processTemplatesAdHoc`**
   ----
   > gradle processTemplatesAdHoc
   include::{snippetsPath}/tasks/incrementalBuild-customTaskClass/tests/incrementalAdHocTask.out[]
   ----
   ====
   
   As before, there뗩 much to talk about. To begin with, you should really write a custom task class for this as it뗩 a non-trivial implementation that has several configuration options. In this case, there are no task properties to store the root source folder, the location of the output directory or any of the other settings. That뗩 deliberate to highlight the fact that the runtime API doesn뗪 require the task to have any state. In terms of incremental build, the above ad-hoc task will behave the same as the custom task class.
   
   All the input and output definitions are done through the methods on `inputs` and `outputs`, such as `property()`, `files()`, and `dir()`.
   Gradle performs up-to-date checks on the argument values to determine whether the task needs to run again or not.
   Each method corresponds to one of the incremental build annotations, for example `inputs.property()` maps to `@Input` and `outputs.dir()` maps to `@OutputDirectory`.
   
   The files that a task removes can be specified through `destroyables.register()`.
   
   .Ad-hoc task declaring a destroyable
   ====
   include::sample[dir="snippets/tasks/incrementalBuild-customTaskClass/kotlin",files="build.gradle.kts[tags=adhoc-destroyable-task]"]
   include::sample[dir="snippets/tasks/incrementalBuild-customTaskClass/groovy",files="build.gradle[tags=adhoc-destroyable-task]"]
   ====
   
   One notable difference between the runtime API and the annotations is the lack of a method that corresponds directly to `@Nested`. That뗩 why the example uses two `property()` declarations for the template data, one for each `TemplateData` property. You should utilize the same technique when using the runtime API with nested values.  Any given task can either declare destroyables or inputs/outputs, but cannot declare both.
   
   === Fine-grained configuration
   
   The runtime API methods only allow you to declare your inputs and outputs in themselves. However, the file-oriented ones return a builder  of type link:{javadocPath}#[TaskInputFilePropertyBuilder]  that lets you provide additional information about those inputs and outputs.
   
   You can learn about all the options provided by the builder in its API documentation, but we뗣l show you a simple example here to give you an idea of what you can do.
   
   Let뗩 say we don뗪 want to run the `processTemplates` task if there are no source files, regardless of whether it뗩 a clean build or not. After all, if there are no source files, there뗩 nothing for the task to do. The builder allows us to configure this like so:
   
   .Using skipWhenEmpty() via the runtime API
   ====
   include::sample[dir="snippets/tasks/incrementalBuild-customTaskClass/kotlin",files="build.gradle.kts[tags=ad-hoc-task-skip-when-empty]"]
   include::sample[dir="snippets/tasks/incrementalBuild-customTaskClass/groovy",files="build.gradle[tags=ad-hoc-task-skip-when-empty]"]
   
   .Output of **`gradle clean processTemplatesAdHocSkipWhenEmpty`**
   ----
   > gradle clean processTemplatesAdHocSkipWhenEmpty
   include::{snippetsPath}/tasks/incrementalBuild-customTaskClass/tests/incrementalAdHocTaskNoSource.out[]
   ----
   ====
   
   The `TaskInputs.files()` method returns a builder that has a `skipWhenEmpty()` method. Invoking this method is equivalent to annotating to the property with <<#skip-when-empty,`@SkipWhenEmpty`>>.
   
   Now that you have seen both the annotations and the runtime API, you may be wondering which API you should be using. Our recommendation is to use the annotations wherever possible, and it뗩 sometimes worth creating a custom task class just so that you can make use of them. The runtime API is more for situations in which you can뗪 use the annotations.
   
   === Declaring inputs and outputs for custom task types
   
   Another type of example involves registering additional inputs and outputs for instances of a custom task class.
   For example, imagine that the `ProcessTemplates` task also needs to read `src/headers/headers.txt` (e.g. because it is included from one of the sources).
   You'd want Gradle to know about this input file, so that it can re-execute the task whenever the contents of this file change.
   With the runtime API you can do just that:
   
   .Using runtime API with custom task type
   ====
   include::sample[dir="snippets/tasks/incrementalBuild-customTaskClass/kotlin",files="build.gradle.kts[tags=custom-class-runtime-api]"]
   include::sample[dir="snippets/tasks/incrementalBuild-customTaskClass/groovy",files="build.gradle[tags=custom-class-runtime-api]"]
   ====
   
   Using the runtime API like this is a little like using `doLast()` and `doFirst()` to attach extra actions to a task, except in this case were attaching information about inputs and outputs.
   
   WARNING: If the task type is already using the incremental build annotations, registering inputs or outputs with the same property names will result in an error.
   
   == Benefits of declaring task inputs and outputs
   
   Once you declare a task뗩 formal inputs and outputs, Gradle can then infer things about those properties. For example, if an input of one task is set to the output of another, that means the first task depends on the second, right? Gradle knows this and can act upon it.
   
   We뗣l look at this feature next and also some other features that come from Gradle knowing things about inputs and outputs.
   
   
   === Inferred task dependencies
   
   Consider an archive task that packages the output of the `processTemplates` task. A build author will see that the archive task obviously requires `processTemplates` to run first and so may add an explicit `dependsOn`. However, if you define the archive task like so:
   
   .Inferred task dependency via task outputs
   ====
   include::sample[dir="snippets/tasks/incrementalBuild-customTaskClass/kotlin",files="build.gradle.kts[tags=inferred-task-dep-via-outputs]"]
   include::sample[dir="snippets/tasks/incrementalBuild-customTaskClass/groovy",files="build.gradle[tags=inferred-task-dep-via-outputs]"]
   
   .Output of **`gradle clean packageFiles`**
   ----
   > gradle clean packageFiles
   include::{snippetsPath}/tasks/incrementalBuild-customTaskClass/tests/inferredTaskDep.out[]
   ----
   ====
   
   Gradle will automatically make `packageFiles` depend on `processTemplates`. It can do this because it뗩 aware that one of the inputs of packageFiles requires the output of the processTemplates task. We call this an inferred task dependency.
   
   The above example can also be written as
   
   .Inferred task dependency via a task argument
   ====
   include::sample[dir="snippets/tasks/incrementalBuild-customTaskClass/kotlin",files="build.gradle.kts[tags=inferred-task-dep-via-task]"]
   include::sample[dir="snippets/tasks/incrementalBuild-customTaskClass/groovy",files="build.gradle[tags=inferred-task-dep-via-task]"]
   
   .Output of **`gradle clean packageFiles2`**
   ----
   > gradle clean packageFiles2
   include::{snippetsPath}/tasks/incrementalBuild-customTaskClass/tests/inferredTaskDep2.out[]
   ----
   ====
   
   This is because the `from()` method can accept a task object as an argument. Behind the scenes, `from()` uses the `project.files()` method to wrap the argument, which in turn exposes the task뗩 formal outputs as a file collection. In other words, it뗩 a special case!
   
   === Input and output validation
   
   The incremental build annotations provide enough information for Gradle to perform some basic validation on the annotated properties. In particular, it does the following for each property before the task executes:
   
   * `@InputFile` - verifies that the property has a value and that the path corresponds to a file (not a directory) that exists.
   * `@InputDirectory` - same as for `@InputFile`, except the path must correspond to a directory.
   * `@OutputDirectory` - verifies that the path doesn뗪 match a file and also creates the directory if it doesn뗪 already exist.
   
   If one task produces an output in a location and another task consumes that location by referring to it as an input, then Gradle checks that the consumer task depends on the producer task.
   When the producer and the consumer tasks are executing at the same time, the build fails to avoid capturing an incorrect state.
   
   Such validation improves the robustness of the build, allowing you to identify issues related to inputs and outputs quickly.
   
   You will occasionally want to disable some of this validation, specifically when an input file may validly not exist. That뗩 why Gradle provides the `@Optional` annotation: you use it to tell Gradle that a particular input is optional and therefore the build should not fail if the corresponding file or directory doesn뗪 exist.
   
   === Continuous build
   
   Another benefit of defining task inputs and outputs is continuous build. Since Gradle knows what files a task depends on, it can automatically run a task again if any of its inputs change. By activating continuous build when you run Gradle  through the `--continuous` or `-t` options  you will put Gradle into a state in which it continually checks for changes and executes the requested tasks when it encounters such changes.
   
   You can find out more about this feature in <<command_line_interface.adoc#sec:continuous_build,Continuous build>>.
   
   === Task parallelism
   
   One last benefit of defining task inputs and outputs is that Gradle can use this information to make decisions about how to run tasks when the "--parallel" option is used.  For instance, Gradle will inspect the outputs of tasks when selecting the  next task to run and will avoid concurrent execution of tasks that write to the same output directory.  Similarly, Gradle will use the information about what files a task destroys (e.g. specified by the `Destroys` annotation) and avoid running a task that removes a set of files while another task is running that consumes or creates those same files (and vice versa).  It can also determine that a task that creates a set of files has already run and that a task that consumes those files has yet to run and will avoid running a task that removes those files in between.  By providing task input and output information in this way, Gradle can infer creation/consumption/destruction relationships between tasks and can ensure that task execution does not violate those relationships.
   
   == How does it work?
   
   Before a task is executed for the first time, Gradle takes a fingerprint of the inputs.
   This fingerprint contains the paths of input files and a hash of the contents of each file.
   Gradle then executes the task.
   If the task completes successfully, Gradle takes a fingerprint of the outputs.
   This fingerprint contains the set of output files and a hash of the contents of each file.
   Gradle persists both fingerprints for the next time the task is executed.
   
   Each time after that, before the task is executed, Gradle takes a new fingerprint of the inputs and outputs.
   If the new fingerprints are the same as the previous fingerprints, Gradle assumes that the outputs are up to date and skips the task.
   If they are not the same, Gradle executes the task.
   Gradle persists both fingerprints for the next time the task is executed.
   
   If the stats of a file (i.e. `lastModified` and `size`) did not change, Gradle will reuse the file's fingerprint from the previous run.
   That means that Gradle does not detect changes when the stats of a file did not change.
   
   Gradle also considers the _code_ of the task as part of the inputs to the task. When a task, its actions, or its dependencies change between executions, Gradle considers the task as out-of-date.
   
   Gradle understands if a file property (e.g. one holding a Java classpath) is order-sensitive. When comparing the fingerprint of such a property, even a change in the order of the files will result in the task becoming out-of-date.
   
   Note that if a task has an output directory specified, any files added to that directory since the last time it was executed are ignored and will NOT cause the task to be out of date. This is so unrelated tasks may share an output directory without interfering with each other. If this is not the behaviour you want for some reason, consider using link:{javadocPath}#[TaskOutputs.upToDateWhen(groovy.lang.Closure)]
   
   Note also that changing the availability of an unavailable file (e.g. modifying the target of a broken symlink to a valid file, or vice versa), will be detected and handled by up-to-date check.
   
   The inputs for the task are also used to calculate the <<build_cache.adoc#build_cache,build cache>> key used to load task outputs when enabled. For more details see <<build_cache.adoc#sec:task_output_caching,Task output caching>>.
   
   --
   For tracking the implementation of tasks, task actions and nested inputs, Gradle uses the class name and an identifier for the classpath which contains the implementation.
   There are some situations when Gradle is not able to track the implementation precisely:
   
   Unknown classloader::
   When the classloader which loaded the implementation has not been created by Gradle, the classpath cannot be determined.
   
   Java lambda::
   Java lambda classes are created at runtime with a non-deterministic classname.
   Therefore, the class name does not identify the implementation of the lambda and changes between different Gradle runs.
   
   When the implementation of a task, task action or a nested input cannot be tracked precisely, Gradle disables any caching for the task.
   That means that the task will never be up-to-date or loaded from the <<build_cache.adoc#sec:task_output_caching,build cache>>.
   --
   
   == Advanced techniques
   
   Everything you뗬e seen so far in this section will cover most of the use cases you뗣l encounter, but there are some scenarios that need special treatment. We뗣l present a few of those next with the appropriate solutions.
   
   
   === Adding your own cached input/output methods
   
   Have you ever wondered how the `from()` method of the `Copy` task works? It뗩 not annotated with `@InputFiles` and yet any files passed to it are treated as formal inputs of the task. What뗩 happening?
   
   The implementation is quite simple and you can use the same technique for your own tasks to improve their APIs. Write your methods so that they add files directly to the appropriate annotated property. As an example, here뗩 how to add a `sources()` method to the custom `ProcessTemplates` class we introduced earlier:
   
   .Declaring a method to add task inputs
   ====
   include::sample[dir="snippets/tasks/incrementalBuild-incrementalBuildAdvanced/kotlin",files="build.gradle.kts[tags=custom-task-class]"]
   include::sample[dir="snippets/tasks/incrementalBuild-incrementalBuildAdvanced/groovy",files="build.gradle[tags=custom-task-class]"]
   
   .ProcessTemplates.java
   [source,java]
   ----
   include::{snippetsPath}/tasks/incrementalBuild-incrementalBuildAdvanced/groovy/buildSrc/src/main/java/org/example/ProcessTemplates.java[tag=custom-task-class]
   ----
   
   .Output of `gradle processTemplates`
   ----
   > gradle processTemplates
   include::{snippetsPath}/tasks/incrementalBuild-incrementalBuildAdvanced/tests/incrementalBuildCustomMethods.out[]
   ----
   ====
   
   In other words, as long as you add values and files to formal task inputs and outputs during the configuration phase, they will be treated as such regardless from where in the build you add them.
   
   If we want to support tasks as arguments as well and treat their outputs as the inputs, we can use the `TaskProvider` directly like so:
   
   .Declaring a method to add a task as an input
   ====
   include::sample[dir="snippets/tasks/incrementalBuild-incrementalBuildAdvanced/kotlin",files="build.gradle.kts[tags=task-arg-method]"]
   include::sample[dir="snippets/tasks/incrementalBuild-incrementalBuildAdvanced/groovy",files="build.gradle[tags=task-arg-method]"]
   
   .ProcessTemplates.java
   [source,java]
   ----
   include::{snippetsPath}/tasks/incrementalBuild-incrementalBuildAdvanced/groovy/buildSrc/src/main/java/org/example/ProcessTemplates.java[tag=task-arg-method]
   ----
   
   .Output of `gradle processTemplates2`
   ----
   > gradle processTemplates2
   include::{snippetsPath}/tasks/incrementalBuild-incrementalBuildAdvanced/tests/incrementalBuildCustomMethodsWithTaskArg.out[]
   ----
   ====
   
   This technique can make your custom task easier to use and result in cleaner build files.
   As an added benefit, our use of `TaskProvider` means that our custom method can set up an inferred task dependency.
   
   One last thing to note: if you are developing a task that takes collections of source files as inputs, like this example, consider using the built-in link:{groovyDslPath}#[SourceTask]. It will save you having to implement some of the plumbing that we put into `ProcessTemplates`.
   
   === Linking an `@OutputDirectory` to an `@InputFiles`
   
   When you want to link the output of one task to the input of another, the types often match and a simple property assignment will provide that link. For example, a `File` output property can be assigned to a `File` input.
   
   Unfortunately, this approach breaks down when you want the files in a task뗩 `@OutputDirectory` (of type `File`) to become the source for another task뗩 `@InputFiles` property (of type `FileCollection`). Since the two have different types, property assignment won뗪 work.
   
   As an example, imagine you want to use the output of a Java compilation task  via the `destinationDir` property  as the input of a custom task that instruments a set of files containing Java bytecode. This custom task, which we뗣l call `Instrument`, has a `classFiles` property annotated with `@InputFiles`. You might initially try to configure the task like so:
   
   .Failed attempt at setting up an inferred task dependency
   ====
   include::sample[dir="snippets/tasks/incrementalBuild-incrementalBuildAdvanced/kotlin",files="build.gradle.kts[tags=failed-inferred-task-dep]"]
   include::sample[dir="snippets/tasks/incrementalBuild-incrementalBuildAdvanced/groovy",files="build.gradle[tags=failed-inferred-task-dep]"]
   
   .Output of **`gradle clean badInstrumentClasses`**
   ----
   > gradle clean badInstrumentClasses
   include::{snippetsPath}/tasks/incrementalBuild-incrementalBuildAdvanced/tests/incrementalBuildBadInputFilesConfig.out[]
   ----
   ====
   
   There뗩 nothing obviously wrong with this code, but you can see from the console output that the compilation task is missing. In this case you would need to add an explicit task dependency between `instrumentClasses` and `compileJava` via `dependsOn`. The use of `fileTree()` means that Gradle can뗪 infer the task dependency itself.
   
   One solution is to use the `TaskOutputs.files` property, as demonstrated by the following example:
   
   .Setting up an inferred task dependency between output dir and input files
   ====
   include::sample[dir="snippets/tasks/incrementalBuild-incrementalBuildAdvanced/kotlin",files="build.gradle.kts[tags=inferred-task-dep]"]
   include::sample[dir="snippets/tasks/incrementalBuild-incrementalBuildAdvanced/groovy",files="build.gradle[tags=inferred-task-dep]"]
   
   .Output of **`gradle clean instrumentClasses`**
   ----
   > gradle clean instrumentClasses
   include::{snippetsPath}/tasks/incrementalBuild-incrementalBuildAdvanced/tests/incrementalBuildInputFilesConfig.out[]
   ----
   ====
   
   Alternatively, you can get Gradle to access the appropriate property itself by using one of `project.files()`, `project.layout.files()` or `project.objects.fileCollection()` in place of `project.fileTree()`:
   
   .Setting up an inferred task dependency with `layout.files()`
   ====
   include::sample[dir="snippets/tasks/incrementalBuild-incrementalBuildAdvanced/kotlin",files="build.gradle.kts[tags=inferred-task-dep-with-files]"]
   include::sample[dir="snippets/tasks/incrementalBuild-incrementalBuildAdvanced/groovy",files="build.gradle[tags=inferred-task-dep-with-files]"]
   
   .Output of **`gradle clean instrumentClasses2`**
   ----
   > gradle clean instrumentClasses2
   include::{snippetsPath}/tasks/incrementalBuild-incrementalBuildAdvanced/tests/incrementalBuildInputFilesConfigUsingTask.out[]
   ----
   ====
   
   Remember that `files()`, `layout.files()` and `objects.fileCollection()` can take tasks as arguments, whereas `fileTree()` cannot.
   
   The downside of this approach is that all file outputs of the source task become the input files of the target  `instrumentClasses` in this case. That뗩 fine as long as the source task only has a single file-based output, like the `JavaCompile` task. But if you have to link just one output property among several, then you need to explicitly tell Gradle which task generates the input files using the `builtBy` method:
   
   .Setting up an inferred task dependency with builtBy()
   ====
   include::sample[dir="snippets/tasks/incrementalBuild-incrementalBuildAdvanced/kotlin",files="build.gradle.kts[tags=inferred-task-dep-with-builtby]"]
   include::sample[dir="snippets/tasks/incrementalBuild-incrementalBuildAdvanced/groovy",files="build.gradle[tags=inferred-task-dep-with-builtby]"]
   
   .Output of **`gradle clean instrumentClassesBuiltBy`**
   ----
   > gradle clean instrumentClassesBuiltBy
   include::{snippetsPath}/tasks/incrementalBuild-incrementalBuildAdvanced/tests/inferredTaskDependencyWithBuiltBy.out[]
   ----
   ====
   
   You can of course just add an explicit task dependency via `dependsOn`, but the above approach provides more semantic meaning, explaining why `compileJava` has to run beforehand.
   
   === Disabling up-to-date checks
   
   Gradle automatically handles up-to-date checks for output files and directories, but what if the task output is something else entirely?
   Perhaps it뗩 an update to a web service or a database table.
   Or sometimes you have a task which should always run.
   
   That뗩 where the `doNotTrackState()` method on `Task` comes in.
   One can use this to disable up-to-date checks completely for a task, like so:
   
   .Ignoring up-to-date checks
   ====
   include::sample[dir="snippets/tasks/incrementalBuild-incrementalBuildAdvanced/kotlin",files="build.gradle.kts[tags=disable-up-to-date-checks]"]
   include::sample[dir="snippets/tasks/incrementalBuild-incrementalBuildAdvanced/groovy",files="build.gradle[tags=disable-up-to-date-checks]"]
   
   .Output of `gradle clean alwaysInstrumentClasses`
   ----
   > gradle clean alwaysInstrumentClasses
   include::{snippetsPath}/tasks/incrementalBuild-incrementalBuildAdvanced/tests/incrementalBuildUpToDateWhen.out[]
   ----
   
   .Output of `gradle alwaysInstrumentClasses`
   ----
   > gradle alwaysInstrumentClasses
   include::{snippetsPath}/tasks/incrementalBuild-incrementalBuildAdvanced/tests/incrementalBuildUpToDateWhenAgain.out[]
   ----
   ====
   
   If you are writing your own task that always should run, then you can also use the `@link:{javadocPath}#[UntrackedTask]` annotation on the task class instead of calling `Task.doNotTrackState()`.
   
   === Integrate an external tool which does its own up-to-date checking
   
   Sometimes you want to integrate an external tool like Git or Npm, both of which do their own up-to-date checking.
   In that case it doesn't make much sense for Gradle to also do up-to-date checks.
   You can disable Gradle's up-to-date checks by using the `@link:{javadocPath}#[UntrackedTask]` annotation on the task wrapping the tool.
   Alternatively, you can use the runtime API method `link:{groovyDslPath}#[Task.doNotTrackState()]`.
   
   For example, let's say you want to implement a task which clones a Git repository.
   
   .Task for Git clone
   ====
   [source,java]
   .buildSrc/src/main/java/org/example/GitClone.java
   ----
   include::{snippetsPath}/tasks/incrementalBuild-incrementalBuildAdvanced/groovy/buildSrc/src/main/java/org/example/GitClone.java[tag=git-clone]
   ----
   
   include::sample[dir="snippets/tasks/incrementalBuild-incrementalBuildAdvanced/kotlin",files="build.gradle.kts[tags=git-clone]"]
   include::sample[dir="snippets/tasks/incrementalBuild-incrementalBuildAdvanced/groovy",files="build.gradle[tags=git-clone]"]
   ====
   <1> Declare the task as untracked.
   <2> Use the output directory to run the external tool.
   <3> Add the task and configure the output directory in your build.
   
   === Configure input normalization
   
   For up to date checks and the <<build_cache.adoc#build_cache,build cache>> Gradle needs to determine if two task input properties have the same value.
   In order to do so, Gradle first normalizes both inputs and then compares the result.
   For example, for a compile classpath, Gradle extracts the ABI signature from the classes on the classpath and then compares signatures between the last Gradle run and the current Gradle run as described in <<java_plugin.adoc#sec:java_compile_avoidance,Java compile avoidance>>.
   
   Normalization applies to all zip files on the classpath (e.g. jars, wars, aars, apks, etc).  This allows Gradle to recognize when two zip files are functionally the same, even though the zip files themselves might be slightly different due to metadata (such as timestamps or file order).  Normalization applies not only to zip files directly on the classpath, but also to zip files nested inside directories or inside other zip files on the classpath.
   
   It is possible to customize Gradle's built-in strategy for runtime classpath normalization.
   All inputs annotated with `@link:{javadocPath}#[Classpath]` are considered to be runtime classpaths.
   
   Let's say you want to add a file `build-info.properties` to all your produced jar files which contains information about the build, e.g. the timestamp when the build started or some ID to identify the CI job that published the artifact.
   This file is only for auditing purposes, and has no effect on the outcome of running tests.
   Nonetheless, this file is part of the runtime classpath for the `test` task and changes on every build invocation.
   Therefore, the `test` would be never up-to-date or pulled from the build cache.
   In order to benefit from incremental builds again, you are able tell Gradle to ignore this file on the runtime classpath at the project level by using link:{groovyDslPath}#[Project.normalization(org.gradle.api.Action)] (in the _consuming_ project):
   
   .Runtime classpath normalization
   ====
   include::sample[dir="snippets/tasks/inputNormalization/kotlin",files="build.gradle.kts[tags=ignore-build-info-properties]"]
   include::sample[dir="snippets/tasks/inputNormalization/groovy",files="build.gradle[tags=ignore-build-info-properties]"]
   ====
   
   If adding such a file to your jar files is something you do for all of the projects in your build, and you want to filter this file for all consumers,
   you should consider configuring such normalization in a <<sharing_build_logic_between_subprojects#sec:convention_plugins,convention plugin>> to share it between subprojects.
   
   The effect of this configuration would be that changes to `build-info.properties` would be ignored for up-to-date checks and <<build_cache.adoc#build_cache,build cache>> key calculations.
   Note that this will not change the runtime behavior of the `test` task  i.e. any test is still able to load `build-info.properties` and the runtime classpath is still the same as before.
   
   ==== Properties file normalization
   
   By default, properties files (i.e. files that end in a `.properties` extension) will be normalized to ignore differences in comments, whitespace and the order of properties.
   Gradle does this by loading the properties files and only considering the individual properties during up-to-date checks or build cache key calculations.
   
   It is sometimes the case, though, that certain properties have a runtime impact, while others do not.
   If a property is changing that does not have an impact on the runtime classpath, it may be desirable to exclude it from up-to-date checks and <<build_cache.adoc#build_cache,build cache>> key calculations.
   However, excluding the entire file would also exclude the properties that do have a runtime impact.
   In this case, properties can be excluded selectively from any or all properties files on the runtime classpath.
   
   A rule for ignoring properties can be applied to a specific set of files using the patterns described in link:{groovyDslPath}#[RuntimeClasspathNormalization].
   In the event that a file matches a rule, but cannot be loaded as a properties file (e.g. because it is not formatted properly or uses a non-standard encoding), it will be incorporated into the up-to-date or build cache key calculation as a normal file.
   In other words, if the file cannot be loaded as a properties file, any changes to whitespace, property order, or comments may cause the task to become out-of-date or cause a cache miss.
   
   .Ignore a property in selected properties files
   ====
   include::sample[dir="snippets/tasks/inputNormalizationPropertiesFiles/kotlin",files="build.gradle.kts[tags=ignore-property-selected]"]
   include::sample[dir="snippets/tasks/inputNormalizationPropertiesFiles/groovy",files="build.gradle[tags=ignore-property-selected]"]
   ====
   
   .Ignore a property in all properties files
   ====
   include::sample[dir="snippets/tasks/inputNormalizationPropertiesFiles/kotlin",files="build.gradle.kts[tags=ignore-property-all]"]
   include::sample[dir="snippets/tasks/inputNormalizationPropertiesFiles/groovy",files="build.gradle[tags=ignore-property-all]"]
   ====
   
   ==== Java `META-INF` normalization
   
   For files in the `META-INF` directory of jar archives it's not always possible to ignore files completely due to their runtime impact.
   
   Manifest files within `META-INF` are normalized to ignore comments, whitespace and order differences.
   Manifest attribute names are compared case-and-order insensitively.
   Manifest properties files are normalized according to <<#sec:property_file_normalization,Properties File Normalization>>.
   
   .Ignore `META-INF` manifest attributes
   ====
   include::sample[dir="snippets/tasks/inputNormalizationMetaInf/kotlin",files="build.gradle.kts[tags=ignore-metainf-attribute]"]
   include::sample[dir="snippets/tasks/inputNormalizationMetaInf/groovy",files="build.gradle[tags=ignore-metainf-attribute]"]
   ====
   
   .Ignore `META-INF` property keys
   ====
   include::sample[dir="snippets/tasks/inputNormalizationMetaInf/kotlin",files="build.gradle.kts[tags=ignore-metainf-properties]"]
   include::sample[dir="snippets/tasks/inputNormalizationMetaInf/groovy",files="build.gradle[tags=ignore-metainf-properties]"]
   ====
   
   .Ignore `META-INF/MANIFEST.MF`
   ====
   include::sample[dir="snippets/tasks/inputNormalizationMetaInf/kotlin",files="build.gradle.kts[tags=ignore-metainf-manifest]"]
   include::sample[dir="snippets/tasks/inputNormalizationMetaInf/groovy",files="build.gradle[tags=ignore-metainf-manifest]"]
   ====
   
   .Ignore all files and directories inside `META-INF`
   ====
   include::sample[dir="snippets/tasks/inputNormalizationMetaInf/kotlin",files="build.gradle.kts[tags=ignore-metainf-completely]"]
   include::sample[dir="snippets/tasks/inputNormalizationMetaInf/groovy",files="build.gradle[tags=ignore-metainf-completely]"]
   ====
   
   === Providing custom up-to-date logic
   
   Gradle automatically handles up-to-date checks for output files and directories, but what if the task output is something else entirely?
   Perhaps it뗩 an update to a web service or a database table.
   Gradle has no way of knowing how to check whether the task is up to date in such cases.
   
   That뗩 where the `upToDateWhen()` method on `TaskOutputs` comes in.
   This takes a predicate function that is used to determine whether a task is up to date or not.
   For example, you could read the version number of your database schema from the database.
   Or, you could check whether a particular record in a database table exists or has changed for example.
   
   Just be aware that up-to-date checks should _save_ you time.
   Don뗪 add checks that cost as much or more time than the standard execution of the task.
   In fact, if a task ends up running frequently anyway, because it뗩 rarely up to date, then it may not be worth having no up-to-date checks at all as described in <<sec:disable-state-tracking>>.
   Remember that your checks will always run if the task is in the execution task graph.
   
   One common mistake is to use `upToDateWhen()` instead of `Task.onlyIf()`.
   If you want to skip a task on the basis of some condition unrelated to the task inputs and outputs, then you should use `onlyIf()`.
   For example, in cases where you want to skip a task when a particular property is set or not set.
   
   == Stale task outputs
   
   When the Gradle version changes, Gradle detects that outputs from tasks that ran with older versions of Gradle need to be removed to ensure that the newest version of the tasks are starting from a known clean state.
   
   NOTE: Automatic clean-up of stale output directories has only been implemented for the output of source sets (Java/Groovy/Scala compilation).

/docs/userguide/optimizing-performance/configuration_cache.adoc
===============================================================

.. code-block::

   :gradle-issues: https://github.com/gradle/gradle/issues/
   
   = Configuration cache
   
   // Run tests for snippets included in this chapter with:
   // ./gradlew :docs:docsTest --tests="ExemplarExternalSamplesFunctionalTest.snippet-configuration-cache-*"
   // ./gradlew :docs:docsTest --tests="ExemplarExternalSamplesFunctionalTest.snippet-value-providers-*"
   
   == Introduction
   
   The configuration cache is a feature that significantly improves build performance by caching the result of the <<build_lifecycle#build_lifecycle,configuration phase>> and reusing this for subsequent builds.
   Using the configuration cache, Gradle can skip the configuration phase entirely when nothing that affects the build configuration, such as build scripts, has changed.
   Gradle also applies performance improvements to task execution as well.
   
   The configuration cache is conceptually similar to the <<build_cache#build_cache,build cache>>, but caches different information.
   The build cache takes care of caching the outputs and intermediate files of the build, such as task outputs or artifact transform outputs.
   The configuration cache takes care of caching the build configuration for a particular set of tasks.
   In other words, the configuration cache saves the output of the configuration phase, and the build cache saves the outputs of the execution phase.
   
   [IMPORTANT]
   ====
   This feature is currently not enabled by default. This feature has the following limitations:
   
   - The configuration cache does not support all <<configuration_cache#config_cache:plugins:core, core Gradle plugins>> and <<configuration_cache#config_cache:not_yet_implemented, features>>. Full support is a work in progress.
   - Your build and the plugins you depend on might require changes to fulfil the <<configuration_cache#config_cache:requirements, requirements>>.
   - IDE imports and syncs do not yet use the configuration cache.
   ====
   
   === How does it work?
   
   When the configuration cache is enabled and you run Gradle for a particular set of tasks, for example by running `gradlew check`, Gradle checks whether a configuration cache entry is available for the requested set of tasks.
   If available, Gradle uses this entry instead of running the configuration phase.
   The cache entry contains information about the set of tasks to run, along with their configuration and dependency information.
   
   The first time you run a particular set of tasks, there will be no entry in the configuration cache for these tasks and so Gradle will run the configuration phase as normal:
   
   1. Run init scripts.
   2. Run the settings script for the build, applying any requested settings plugins.
   3. Configure and build the `buildSrc` project, if present.
   4. Run the builds scripts for the build, applying any requested project plugins.
   5. Calculate the task graph for the requested tasks, running any deferred configuration actions.
   
   Following the configuration phase, Gradle writes a snapshot of the task graph to a new configuration cache entry, for later Gradle invocations.
   Gradle then loads the task graph from the configuration cache, so that it can apply optimizations to the tasks, and then runs the execution phase as normal.
   Configuration time will still be spent the first time you run a particular set of tasks.
   However, you should see build performance improvement immediately because <<#config_cache:intro:performance_improvements,tasks will run in parallel>>.
   
   When you subsequently run Gradle with this same set of tasks, for example by running `gradlew check` again, Gradle will load the tasks and their configuration directly from the configuration cache and skip the configuration phase entirely.
   Before using a configuration cache entry, Gradle checks that none of the "build configuration inputs", such as build scripts, for the entry have changed.
   If a build configuration input has changed, Gradle will not use the entry and will run the configuration phase again as above, saving the result for later reuse.
   
   Build configuration inputs include:
   
   - Init scripts
   - Settings scripts
   - Build scripts
   - System properties used during the configuration phase
   - Gradle properties used during the configuration phase
   - Environment variables used during the configuration phase
   - Configuration files accessed using value suppliers such as providers
   - `buildSrc` and plugin included build inputs, including build configuration inputs and source files.
   
   Gradle uses its own optimized serialization mechanism and format to store the configuration cache entries.
   It automatically serializes the state of arbitrary object graphs.
   If your tasks hold references to objects with simple state or of supported types you don't have anything to do to support the serialization.
   
   As a fallback and to provide some aid in migrating existing tasks, some semantics of <<configuration_cache#config_cache:not_yet_implemented:java_serialization, Java Serialization>> are supported. But it is not recommended relying on it, mostly for performance reasons.
   
   === Performance improvements
   
   Apart from skipping the configuration phase, the configuration cache provides some additional performance improvements:
   
   - All tasks run in parallel by default, subject to dependency constraints.
   - Dependency resolution is cached.
   - Configuration state and dependency resolution state is discarded from heap after writing the task graph. This reduces the peak heap usage required for a given set of tasks.
   
   === Configuration caching in action
   
   // TODO-RC redo demo so it no longer shows as incubating
   image::configuration-cache/running-help.gif[]
   
   == Using the configuration cache
   
   It is recommended to get started with the simplest task invocation possible.
   Running `help` with the configuration cache enabled is a good first step:
   
   ----
   仇 gradle --configuration-cache help
   include::{snippetsPath}/configurationCache/noProblem/tests/store.out[]
   ...
   BUILD SUCCESSFUL in 4s
   1 actionable task: 1 executed
   Configuration cache entry stored.
   ----
   
   Running this for the first time, the configuration phase executes, calculating the task graph.
   
   Then, run the same command again.
   This reuses the cached configuration:
   
   ----
   仇 gradle --configuration-cache help
   include::{snippetsPath}/configurationCache/noProblem/tests/load.out[]
   ...
   BUILD SUCCESSFUL in 500ms
   1 actionable task: 1 executed
   Configuration cache entry reused.
   ----
   
   If it succeeds on your build, congratulations, you can now try with more useful tasks.
   You should target your development loop.
   A good example is running tests after making incremental changes.
   
   If any problem is found caching or reusing the configuration, an HTML report is generated to help you diagnose and fix the issues. The report also shows detected build configuration inputs like
   system properties, environment variables and value suppliers read during the configuration phase.
   See the <<configuration_cache#config_cache:troubleshooting>> section below for more information.
   
   Keep reading to learn how to tweak the configuration cache, manually invalidate the state if something goes wrong and use the configuration cache from an IDE.
   
   === Enabling the configuration cache
   
   By default, Gradle does not use the configuration cache.
   To enable the cache at build time, use the `configuration-cache` flag:
   
   ----
   仇 gradle --configuration-cache
   ----
   
   You can also enable the cache persistently in a `gradle.properties` file using the `org.gradle.configuration-cache` property:
   
   [source,properties]
   ----
   org.gradle.configuration-cache=true
   ----
   
   If enabled in a `gradle.properties` file, you can override that setting and disable the cache at build time with the `no-configuration-cache` flag:
   
   ----
   仇 gradle --no-configuration-cache
   ----
   
   === Ignoring problems
   
   By default, Gradle will fail the build if any configuration cache problems are encountered.
   When gradually improving your plugin or build logic to support the configuration cache it can be useful to temporarily turn problems into warnings, with no guarantee that the build will work.
   
   This can be done from the command line:
   
   ----
   仇 gradle --configuration-cache-problems=warn
   ----
   
   or in a `gradle.properties` file:
   
   [source,properties]
   ----
   org.gradle.configuration-cache.problems=warn
   ----
   
   === Allowing a maximum number of problems
   
   When configuration cache problems are turned into warnings, Gradle will fail the build if `512` problems are found by default.
   
   This can be adjusted by specifying an allowed maximum number of problems on the command line:
   
   ----
   仇 gradle -Dorg.gradle.configuration-cache.max-problems=5
   ----
   
   or in a `gradle.properties` file:
   
   [source,properties]
   ----
   org.gradle.configuration-cache.max-problems=5
   ----
   
   === Invalidating the cache
   
   The configuration cache is automatically invalidated when inputs to the configuration phase change.
   However, certain inputs are not tracked yet, so you may have to manually invalidate the configuration cache when untracked inputs to the configuration phase change.
   This can happen if you <<configuration_cache#config_cache:usage:ignore_problems,ignored problems>>.
   See the <<configuration_cache#config_cache:requirements>> and <<configuration_cache#config_cache:not_yet_implemented>> sections below for more information.
   
   The configuration cache state is stored on disk in a directory named `.gradle/configuration-cache` in the root directory of the Gradle build in use.
   If you need to invalidate the cache, simply delete that directory:
   
   ----
   仇 rm -rf .gradle/configuration-cache
   ----
   
   Configuration cache entries are checked periodically (at most every 24 hours) for whether they are still in use.
   They are deleted if they haven't been used for 7 days.
   
   == Stable configuration cache
   
   Working towards the stabilization of configuration caching we implemented some strictness behind a feature flag when it was considered too disruptive for early adopters.
   
   You can enable that feature flag as follows:
   
   ====
   include::sample[dir="snippets/configurationCache/stableFeatureFlag/kotlin",files="settings.gradle.kts[]"]
   include::sample[dir="snippets/configurationCache/stableFeatureFlag/groovy",files="settings.gradle[]"]
   ====
   
   The `STABLE_CONFIGURATION_CACHE` feature flag enables the following:
   
   Undeclared shared build service usage::
   When enabled, tasks using a <<build_services#build_services, shared build service>> without declaring the requirement via the `Task.usesService` method will emit a deprecation warning.
   
   In addition, when the configuration cache is not enabled but the feature flag is present, deprecations for the following <<config_cache:requirements, configuration cache requirements>> are also enabled:
   
   * <<config_cache:requirements:build_listeners, Registering build listeners>>
   * <<config_cache:requirements:use_project_during_execution, Using the `Project` object at execution time>>
   * <<config_cache:requirements:task_extensions, Using task extensions and conventions at execution time>>
   
   It is recommended to enable it as soon as possible in order to be ready for when we remove the flag and make the linked features the default.
   
   == IDE support
   
   If you enable and configure the configuration cache from your `gradle.properties` file, then the configuration cache will be enabled when your IDE delegates to Gradle.
   There's nothing more to do.
   
   `gradle.properties` is usually checked in to source control.
   If you don't want to enable the configuration cache for your whole team yet you can also enable the configuration cache from your IDE only as explained below.
   
   Note that syncing a build from an IDE doesn't benefit from the configuration cache, only running tasks does.
   
   === IntelliJ based IDEs
   
   In IntelliJ IDEA or Android Studio this can be done in two ways, either globally or per run configuration.
   
   To enable it for the whole build, go to `Run > Edit configurations...`.
   This will open the IntelliJ IDEA or Android Studio dialog to configure Run/Debug configurations.
   Select `Templates > Gradle` and add the necessary system properties to the `VM options` field.
   
   For example to enable the configuration cache, turning problems into warnings, add the following:
   
   ----
   -Dorg.gradle.configuration-cache=true -Dorg.gradle.configuration-cache.problems=warn
   ----
   
   You can also choose to only enable it for a given run configuration.
   In this case, leave the `Templates > Gradle` configuration untouched and edit each run configuration as you see fit.
   
   Combining these two ways you can enable globally and disable for certain run configurations, or the opposite.
   
   [TIP]
   ====
   You can use the link:https://github.com/JetBrains/gradle-idea-ext-plugin[gradle-idea-ext-plugin] to configure IntelliJ run configurations from your build.
   This is a good way to enable the configuration cache only for the IDE.
   ====
   
   === Eclipse IDEs
   
   In Eclipse IDEs you can enable and configure the configuration cache through Buildship in two ways, either globally or per run configuration.
   
   To enable it globally, go to `Preferences > Gradle`.
   You can use the properties described above as system properties.
   For example to enable the configuration cache, turning problems into warnings, add the following JVM arguments:
   
   * `-Dorg.gradle.configuration-cache=true`
   * `-Dorg.gradle.configuration-cache.problems=warn`
   
   To enable it for a given run configuration, go to `Run configurations...`, find the one you want to change, go to `Project Settings`, tick the `Override project settings` checkbox and add the same system properties as a `JVM argument`.
   
   Combining these two ways you can enable globally and disable for certain run configurations, or the opposite.
   
   == Supported plugins
   
   The configuration cache is brand new and introduces new requirements for plugin implementations.
   As a result, both core Gradle plugins, and community plugins need to be adjusted.
   This section provides information about the current support in <<configuration_cache#config_cache:plugins:core, core Gradle plugins>> and <<configuration_cache#config_cache:plugins:community, community plugins>>.
   
   === Core Gradle plugins
   
   Not all <<plugin_reference#plugin_reference, core Gradle plugins>> support configuration caching yet.
   
   [cols=3*]
   |===
   h| JVM languages and frameworks
   h| Native languages
   h| Packaging and distribution
   
   a|
   [horizontal]
   link:{gradle-issues}13457[[.green]#九#]:: <<java_plugin.adoc#java_plugin,Java>>
   link:{gradle-issues}13458[[.green]#九#]:: <<java_library_plugin.adoc#java_library_plugin,Java Library>>
   link:{gradle-issues}13459[[.green]#九#]:: <<java_platform_plugin.adoc#java_platform_plugin,Java Platform>>
   link:{gradle-issues}13460[[.green]#九#]:: <<groovy_plugin.adoc#groovy_plugin,Groovy>>
   link:{gradle-issues}13461[[.green]#九#]:: <<scala_plugin.adoc#scala_plugin,Scala>>
   link:{gradle-issues}13462[[.green]#九#]:: <<antlr_plugin.adoc#antlr_plugin,ANTLR>>
   
   a|
   [horizontal]
   link:{gradle-issues}13484[[.red]#九#]:: <<cpp_application_plugin.adoc#cpp_application_plugin,C++ Application>>
   link:{gradle-issues}13485[[.red]#九#]:: <<cpp_library_plugin.adoc#cpp_library_plugin,C++ Library>>
   link:{gradle-issues}13514[[.red]#九#]:: <<cpp_unit_test_plugin.adoc#cpp_unit_test_plugin,C++ Unit Test>>
   link:{gradle-issues}13515[[.red]#九#]:: <<swift_application_plugin.adoc#swift_application_plugin,Swift Application>>
   link:{gradle-issues}13487[[.red]#九#]:: <<swift_library_plugin.adoc#swift_library_plugin,Swift Library>>
   link:{gradle-issues}13488[[.red]#九#]:: <<xctest_plugin.adoc#xctest_plugin,XCTest>>
   
   a|
   [horizontal]
   link:{gradle-issues}13463[[.green]#九#]:: <<application_plugin.adoc#application_plugin,Application>>
   link:{gradle-issues}13466[[.green]#九#]:: <<war_plugin.adoc#war_plugin,WAR>>
   link:{gradle-issues}13467[[.green]#九#]:: <<ear_plugin.adoc#ear_plugin,EAR>>
   link:{gradle-issues}24329[[.yellow]#丘#]:: <<publishing_maven.adoc#publishing_maven,Maven Publish>>
   link:{gradle-issues}24328[[.yellow]#丘#]:: <<publishing_ivy.adoc#publishing_ivy,Ivy Publish>>
   link:{gradle-issues}13464[[.green]#九#]:: <<distribution_plugin.adoc#distribution_plugin,Distribution>>
   link:{gradle-issues}13465[[.green]#九#]:: <<java_library_distribution_plugin.adoc#java_library_distribution_plugin,Java Library Distribution>>
   
   h|Code analysis
   h|IDE project files generation
   h| Utility
   
   a|
   [horizontal]
   link:{gradle-issues}13475[[.green]#九#]:: <<checkstyle_plugin.adoc#checkstyle_plugin,Checkstyle>>
   link:{gradle-issues}13478[[.green]#九#]:: <<codenarc_plugin.adoc#codenarc_plugin,CodeNarc>>
   link:{gradle-issues}13477[[.green]#九#]:: <<jacoco_plugin.adoc#jacoco_plugin,JaCoCo>>
   [.green]#九#:: <<jacoco_report_aggregation_plugin#jacoco_report_aggregation_plugin,JaCoCo Report Aggregation>>
   link:{gradle-issues}13476[[.green]#九#]:: <<pmd_plugin.adoc#pmd_plugin,PMD>>
   [.green]#九#:: <<test_report_aggregation_plugin#test_report_aggregation_plugin,Test Report Aggregation>>
   
   a|
   [horizontal]
   link:{gradle-issues}13479[[.red]#九#]:: <<eclipse_plugin.adoc#eclipse_plugin,Eclipse>>
   link:{gradle-issues}13480[[.red]#九#]:: <<idea_plugin.adoc#idea_plugin,IntelliJ IDEA>>
   link:{gradle-issues}13482[[.red]#九#]:: <<visual_studio_plugin.adoc#visual_studio_plugin,Visual Studio>>
   link:{gradle-issues}13483[[.red]#九#]:: <<xcode_plugin.adoc#xcode_plugin,Xcode>>
   
   a|
   [horizontal]
   link:{gradle-issues}13455[[.green]#九#]:: <<base_plugin.adoc#base_plugin,Base>>
   link:{gradle-issues}13456[[.green]#九#]:: <<build_init_plugin.adoc#build_init_plugin,Build Init>>
   link:{gradle-issues}13470[[.green]#九#]:: <<signing_plugin.adoc#signing_plugin,Signing>>
   link:{gradle-issues}24537[[.green]#九#]:: <<java_gradle_plugin.adoc#java_gradle_plugin,Java Plugin Development>>
   link:{gradle-issues}23029[[.green]#九#]:: <<implementing_gradle_plugins_precompiled.adoc#implemention_precompiled_plugins,Groovy DSL Plugin Development>>
   link:{gradle-issues}13472[[.green]#九#]:: <<kotlin_dsl.adoc#sec:kotlin-dsl_plugin,Kotlin DSL Plugin Development>>
   link:{gradle-issues}13473[[.green]#九#]:: <<project_report_plugin.adoc#project_report_plugin,Project Report Plugin>>
   
   |===
   
   [horizontal]
   [.green]#九#:: Supported plugin
   [.yellow]#丘#:: Partially supported plugin
   [.red]#九#:: Unsupported plugin
   
   === Community plugins
   
   Please refer to issue link:{gradle-issues}13490[gradle/gradle#13490] to learn about the status of community plugins.
   
   == Troubleshooting
   
   The following sections will go through some general guidelines on dealing with problems with the configuration cache.
   This applies to both your build logic and to your Gradle plugins.
   
   Upon failure to serialize the state required to run the tasks, an HTML report of detected problems is generated.
   The Gradle failure output includes a clickable link to the report.
   This report is useful and allows you to drill down into problems, understand what is causing them.
   
   Let's look at a simple example build script that contains a couple problems:
   
   ====
   include::sample[dir="snippets/configurationCache/problemsKotlin/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/configurationCache/problemsGroovy/groovy",files="build.gradle[]"]
   ====
   <1> <<config_cache:requirements:reading_sys_props_and_env_vars, A system property read at configuration time>>
   <2> <<config_cache:requirements:use_project_during_execution, Using the `Project` object at execution time>>
   
   Running that task fails and print the following in the console:
   
   ----
   仇 gradle --configuration-cache someTask -DsomeDestination=dest
   ...
   include::{snippetsPath}/configurationCache/problemsGroovy/tests/fail.out[]
   Configuration cache entry discarded with 1 problem.
   ----
   
   The configuration cache entry was discarded because of the found problem failing the build.
   
   Details can be found in the linked HTML report:
   
   image::configuration-cache/problems-report.png[]
   
   The report displays the set of problems twice.
   First grouped by problem message, then grouped by task.
   The former allows you to quickly see what classes of problems your build is facing.
   The latter allows you to quickly see which tasks are problematic.
   In both cases you can expand the tree in order to discover where the culprit is in the object graph.
   
   The report also includes a list of detected build configuration inputs, such as environment variables, system properties and value suppliers that were read at configuration phase:
   
   image::configuration-cache/inputs-report.png[]
   
   [TIP]
   ====
   Problems displayed in the report have links to the corresponding <<configuration_cache#config_cache:requirements,requirement>> where you can find guidance on how to fix the problem or to the corresponding <<configuration_cache#config_cache:not_yet_implemented,not yet implemented>> feature.
   
   When changing your build or plugin to fix the problems you should consider <<configuration_cache#config_cache:testing, testing your build logic with TestKit>>.
   ====
   
   At this stage, you can decide to either <<configuration_cache#config_cache:usage:ignore_problems, turn the problems into warnings>> and continue exploring how your build reacts to the configuration cache, or fix the problems at hand.
   
   Let's ignore the reported problem, and run the same build again twice to see what happens when reusing the cached problematic configuration:
   
   ----
   仇 gradle --configuration-cache --configuration-cache-problems=warn someTask -DsomeDestination=dest
   include::{snippetsPath}/configurationCache/problemsGroovy/tests/store.out[]
   Configuration cache entry stored with 1 problem.
   仇 gradle --configuration-cache --configuration-cache-problems=warn someTask -DsomeDestination=dest
   include::{snippetsPath}/configurationCache/problemsGroovy/tests/load.out[]
   Configuration cache entry reused with 1 problem.
   ----
   
   The two builds succeed reporting the observed problem, storing then reusing the configuration cache.
   
   With the help of the links present in the console problem summary and in the HTML report we can fix our problems.
   Here's a fixed version of the build script:
   
   ====
   include::sample[dir="snippets/configurationCache/problemsFixed/kotlin",files="build.gradle.kts[tags=fixed]"]
   include::sample[dir="snippets/configurationCache/problemsFixed/groovy",files="build.gradle[tags=fixed]"]
   ====
   <1> We turned our ad-hoc task into a proper task class,
   <2> with inputs and outputs declaration,
   <3> and injected with the `FileSystemOperations` service, a supported replacement for <<configuration_cache#config_cache:requirements:use_project_during_execution, `project.copy {}`>>.
   
   Running the task twice now succeeds without reporting any problem and reuses the configuration cache on the second run:
   
   ----
   仇 gradle --configuration-cache someTask -DsomeDestination=dest
   include::{snippetsPath}/configurationCache/problemsFixed/tests/store.out[]
   Configuration cache entry stored.
   仇 gradle --configuration-cache someTask -DsomeDestination=dest
   include::{snippetsPath}/configurationCache/problemsFixed/tests/load.out[]
   Configuration cache entry reused.
   ----
   
   But, what if we change the value of the system property?
   
   ----
   仇 gradle --configuration-cache someTask -DsomeDestination=another
   include::{snippetsPath}/configurationCache/problemsFixed/tests/store-another.out[]
   Configuration cache entry stored.
   ----
   
   The previous configuration cache entry could not be reused, and the task graph had to be calculated and stored again.
   This is because we read the system property at configuration time, hence requiring Gradle to run the configuration phase again when the value of that property changes.
   Fixing that is as simple as obtaining the provider of the system property and wiring it to the task input, without reading it at configuration time.
   
   ====
   include::sample[dir="snippets/configurationCache/problemsFixedReuse/kotlin",files="build.gradle.kts[tags=fixed-reuse]"]
   include::sample[dir="snippets/configurationCache/problemsFixedReuse/groovy",files="build.gradle[tags=fixed-reuse]"]
   ====
   <1> We wired the system property provider directly, without reading it at configuration time.
   
   With this simple change in place we can run the task any number of times, change the system property value, and reuse the configuration cache:
   
   ----
   仇 gradle --configuration-cache someTask -DsomeDestination=dest
   include::{snippetsPath}/configurationCache/problemsFixedReuse/tests/store.out[]
   Configuration cache entry stored.
   仇 gradle --configuration-cache someTask -DsomeDestination=another
   include::{snippetsPath}/configurationCache/problemsFixedReuse/tests/load-another.out[]
   Configuration cache entry reused.
   ----
   
   We're now done with fixing the problems with this simple task.
   
   Keep reading to learn how to adopt the configuration cache for your build or your plugins.
   
   === Declare a task incompatible with the configuration cache
   
   It is possible to declare that a particular task is not compatible with the configuration cache
   via the link:{javadocPath}#[Task.notCompatibleWithConfigurationCache()] method.
   
   Configuration cache problems found in tasks marked incompatible will no longer cause the build to fail.
   
   And, when an incompatible task is scheduled to run, Gradle discards the configuration state at the end of the build. You can use this to help with migration, by temporarily opting out certain tasks that are difficult to change to work with the configuration cache.
   
   Check the method documentation for more details.
   
   == Adoption steps
   
   An important prerequisite is to keep your Gradle and plugins versions up to date.
   The following explores the recommended steps for a successful adoption.
   It applies both to builds and plugins.
   While going through these steps, keep in mind the HTML report and the solutions explained in the <<configuration_cache#config_cache:requirements, requirements>> chapter below.
   
   Start with `:help`::
   Always start by trying your build or plugin with the simplest task `:help`.
   This will exercise the minimal configuration phase of your build or plugin.
   
   Progressively target useful tasks::
   Don't go with running `build` right away.
   You can also use `--dry-run` to discover more configuration time problems first.
   +
   When working on a build, progressively target your development feedback loop.
   For example, running tests after making some changes to the source code.
   +
   When working on a plugin, progressively target the contributed or configured tasks.
   
   Explore by turning problems into warnings::
   Don't stop at the first build failure and <<configuration_cache#config_cache:usage:ignore_problems, turn problems into warnings>> to discover how your build and plugins behave.
   If a build fails, use the HTML report to reason about the reported problems related to the failure.
   Continue running more useful tasks.
   +
   This will give you a good overview of the nature of the problems your build and plugins are facing.
   Remember that when turning problems into warnings you might need to <<configuration_cache#config_cache:usage:invalidate, manually invalidate the cache>> in case of troubles.
   
   Step back and fix problems iteratively::
   When you feel you know enough about what needs to be fixed, take a step back and start iteratively fixing the most important problems.
   Use the HTML report and this documentation to help you in this journey.
   +
   Start with problems reported when _storing_ the configuration cache.
   Once fixed, you can rely on a valid cached configuration phase and move on to fixing problems reported when _loading_ the configuration cache if any.
   
   Report encountered issues::
   If you face a problem with a <<configuration_cache#config_cache:not_yet_implemented, Gradle feature>> or with a <<configuration_cache#config_cache:plugins:core, Gradle core plugin>> that is not covered by this documentation, please report an issue on link:https://github.com/gradle/gradle/issues/new/choose[`gradle/gradle`].
   +
   If you face a problem with a community Gradle plugin, see if it is already listed at link:{gradle-issues}13490[gradle/gradle#13490] and consider reporting the issue to the plugin's issue tracker.
   +
   A good way to report such issues is by providing information such as:
   +
   * a link to this very documentation,
   * the plugin version you tried,
   * the custom configuration of the plugin if any, or ideally a reproducer build,
   * a description of what fails, for example problems with a given task
   * a copy of the build failure,
   * the self-contained `configuration-cache-report.html` file.
   
   Test, test, test::
   Consider adding tests for your build logic.
   See the below section on <<configuration_cache#config_cache:testing, testing your build logic>> for the configuration cache.
   This will help you while iterating on the required changes and prevent future regressions.
   
   Roll it out to your team::
   Once you have your developer workflow working, for example running tests from the IDE, you can consider enabling it for your team.
   A faster turnaround when changing code and running tests could be worth it.
   You'll probably want to do this as an opt-in first.
   +
   If needed, turn problems into warnings and set the maximum number of allowed problems in your build `gradle.properties` file.
   Keep the configuration cache disabled by default.
   Let your team know they can opt-in by, for example, enabling the configuration cache on their IDE run configurations for the supported workflow.
   +
   Later on, when more workflows are working, you can flip this around.
   Enable the configuration cache by default, configure CI to disable it, and if required communicate the unsupported workflow(s) for which the configuration cache needs to be disabled.
   
   === Reacting to the configuration cache in the build
   
   Build logic or plugin implementations can detect if the configuration cache is enabled for a given build, and react to it accordingly.
   The link:{javadocPath}#[active] status of the configuration cache is provided in the corresponding link:{javadocPath}#[build feature].
   You can access it by <<custom_gradle_types#service_injection, injecting>> the link:{javadocPath}#[`BuildFeatures`] service into your code.
   
   You can use this information to configure features of your plugin differently or to disable an optional feature that is not yet compatible.
   Another example involves providing additional guidance for your users, should they need to adjust their setup or be informed of temporary limitations.
   
   === Adopting changes in the configuration cache behavior
   
   Gradle releases bring enhancements to the configuration cache, making it detect more cases of configuration logic interacting with the environment.
   Those changes improve the correctness of the cache by eliminating potential false cache hits.
   On the other hand, they impose stricter rules that plugins and build logic need to follow to be cached as often as possible.
   
   Some of those configuration inputs may be considered "benign" if their results do not affect the configured tasks.
   Having new configuration misses because of them may be undesirable for the build users, and the suggested strategy for eliminating them is:
   
   * Identify the configuration inputs causing the invalidation of the configuration cache with the help of the <<configuration_cache#config_cache:troubleshooting, configuration cache report>>.
   ** Fix undeclared configuration inputs accessed by the build logic of the project.
   ** Report issues caused by third-party plugins to the plugin maintainers, and update the plugins once they get fixed.
   
   * For some kinds of configuration inputs, it is possible to use the opt-out options that make Gradle fall back to the earlier behavior, omitting the inputs from detection.
   This temporary workaround is aimed to mitigate performance issues coming from out-of-date plugins.
   
   It is possible to temporarily opt out of configuration input detection in the following cases:
   
   * Since Gradle 8.1, using many APIs related to the file system is correctly tracked as configuration inputs, including the file system checks, such as `File.exists()` or `File.isFile()`.
   +
   For the input tracking to ignore these file system checks on the specific paths, the Gradle property `org.gradle.configuration-cache.inputs.unsafe.ignore.file-system-checks`, with the list of the paths, relative to the root project directory and separated by `;`, can be used.
   To ignore multiple paths, use `*` to match arbitrary strings within one segment, or `pass:[**]` across segments.
   Paths starting with `~/` are based on the user home directory.
   For example:
   +
   [source,properties]
   .gradle.properties
   ----
   org.gradle.configuration-cache.inputs.unsafe.ignore.file-system-checks=\
       ~/.third-party-plugin/*.lock;\
       ../../externalOutputDirectory/**;\
       build/analytics.json
   ----
   
   * Before Gradle 8.4, some undeclared configuration inputs that were never used in the configuration logic could still be read when the task graph was serialized by the configuration cache.
   However, their changes would not invalidate the configuration cache afterward.
   Starting with Gradle 8.4, such undeclared configuration inputs are correctly tracked.
   +
   To temporarily revert to the earlier behavior, set the Gradle property `org.gradle.configuration-cache.inputs.unsafe.ignore.in-serialization` to `true`.
   
   Ignore configuration inputs sparingly, and only if they do not affect the tasks produced by the configuration logic.
   The support for these options will be removed in future releases.
   
   
   == Testing your build logic
   
   The Gradle TestKit (a.k.a. just TestKit) is a library that aids in testing Gradle plugins and build logic generally.
   For general guidance on how to use TestKit, see the <<test_kit.adoc#test_kit,dedicated chapter>>.
   
   To enable configuration caching in your tests, you can pass the `--configuration-cache` argument to link:{javadocPath}#[GradleRunner] or use one of the other methods described in <<configuration_cache.adoc#config_cache:usage:enable,Enabling the configuration cache>>.
   
   You need to run your tasks twice.
   Once to prime the configuration cache.
   Once to reuse the configuration cache.
   
   .Testing the configuration cache
   ====
   include::sample[dir="snippets/configurationCache/testKit/kotlin",files="src/test/kotlin/org/example/BuildLogicFunctionalTest.kt[tags=functional-test-configuration-cache]"]
   include::sample[dir="snippets/configurationCache/testKit/groovy",files="src/test/groovy/org/example/BuildLogicFunctionalTest.groovy[tags=functional-test-configuration-cache]"]
   ====
   <1> First run primes the configuration cache.
   <2> Second run reuses the configuration cache.
   <3> Assert that the configuration cache gets reused.
   
   If problems with the configuration cache are found then Gradle will fail the build reporting the problems, and the test will fail.
   
   [TIP]
   ====
   A good testing strategy for a Gradle plugin is to run its whole test suite with the configuration cache enabled.
   This requires testing the plugin with a supported Gradle version.
   
   If the plugin already supports a range of Gradle versions it might already have tests for multiple Gradle versions.
   In that case we recommend enabling the configuration cache starting with the Gradle version that supports it.
   
   If this can뗪 be done right away, using tests that run all tasks contributed by the plugin several times, for e.g. asserting the `UP_TO_DATE` and `FROM_CACHE` behavior, is also a good strategy.
   ====
   
   == Requirements
   
   In order to capture the state of the task graph to the configuration cache and reload it again in a later build, Gradle applies certain requirements to tasks and other build logic.
   Each of these requirements is treated as a configuration cache "problem" and fails the build if violations are present.
   
   For the most part these requirements are actually surfacing some undeclared inputs.
   In other words, using the configuration cache is an opt-in to more strictness, correctness and reliability for all builds.
   
   The following sections describe each of the requirements and how to change your build to fix the problems.
   
   === Certain types must not be referenced by tasks
   
   There are a number of types that task instances must not reference from their fields.
   The same applies to task actions as closures such as `doFirst {}` or `doLast {}`.
   
   These types fall into some categories as follows:
   
   * Live JVM state types
   * Gradle model types
   * Dependency management types
   
   In all cases the reason these types are disallowed is that their state cannot easily be stored or recreated by the configuration cache.
   
   Live JVM state types (e.g. `ClassLoader`, `Thread`, `OutputStream`, `Socket` etc...) are simply disallowed.
   These types almost never represent a task input or output.
   The only exceptions are the standard streams: `System.in`, `System.out`, and `System.err`.
   These streams can be used, for example, as parameters to link:{groovyDslPath}#[`Exec`] and link:{groovyDslPath}#[`JavaExec`] tasks.
   
   Gradle model types (e.g. `Gradle`, `Settings`, `Project`, `SourceSet`, `Configuration` etc...) are usually used to carry some task input that should be explicitly and precisely declared instead.
   
   For example, if you reference a `Project` in order to get the `project.version` at execution time, you should instead directly declare the _project version_ as an input to your task using a `Property<String>`.
   Another example would be to reference a `SourceSet` to later get the source files, the compilation classpath or the outputs of the source set.
   You should instead declare these as a `FileCollection` input and reference just that.
   
   The same requirement applies to dependency management types with some nuances.
   
   Some types, such as `Configuration` or `SourceDirectorySet`, don't make good task input parameters, as they hold a lot of irrelevant state, and it is better to model these inputs as something more precise.
   We don't intend to make these types serializable at all.
   For example, if you reference a `Configuration` to later get the resolved files, you should instead declare a `FileCollection` as an input to your task.
   In the same vein, if you reference a `SourceDirectorySet` you should instead declare a `FileTree` as an input to your task.
   
   Referencing dependency resolution results is also disallowed (e.g. `ArtifactResolutionQuery`, `ResolvedArtifact`, `ArtifactResult` etc...).
   For example, if you reference some `ResolvedComponentResult` instances, you should instead declare a `Provider<ResolvedComponentResult>` as an input to your task.
   Such a provider can be obtained by invoking `ResolutionResult.getRootComponent()`.
   In the same vein, if you reference some `ResolvedArtifactResult` instances, you should instead use `ArtifactCollection.getResolvedArtifacts()` that returns a `Provider<Set<ResolvedArtifactResult>>` that can be mapped as an input to your task.
   The rule of thumb is that tasks must not reference _resolved_ results, but lazy specifications instead, in order to do the dependency resolution at execution time.
   
   Some types, such as `Publication` or `Dependency` are not serializable, but could be.
   We may, if necessary, allow these to be used as task inputs directly.
   
   Here's an example of a problematic task type referencing a `SourceSet`:
   
   ====
   include::sample[dir="snippets/configurationCache/disallowedTypes/kotlin",files="build.gradle.kts[tags=task-type]"]
   include::sample[dir="snippets/configurationCache/disallowedTypes/groovy",files="build.gradle[tags=task-type]"]
   ====
   <1> this will be reported as a problem because referencing `SourceSet` is not allowed
   
   The following is how it should be done instead:
   
   ====
   include::sample[dir="snippets/configurationCache/disallowedTypesFixed/kotlin",files="build.gradle.kts[tags=task-type]"]
   include::sample[dir="snippets/configurationCache/disallowedTypesFixed/groovy",files="build.gradle[tags=task-type]"]
   ====
   <1> no more problems reported, we now reference the supported type `FileCollection`
   
   In the same vein, if you encounter the same problem with an ad-hoc task declared in a script as follows:
   
   ====
   include::sample[dir="snippets/configurationCache/disallowedTypes/kotlin",files="build.gradle.kts[tags=ad-hoc-task]"]
   include::sample[dir="snippets/configurationCache/disallowedTypes/groovy",files="build.gradle[tags=ad-hoc-task]"]
   ====
   <1> this will be reported as a problem because the `doLast {}` closure is capturing a reference to the `SourceSet`
   
   You still need to fulfil the same requirement, that is not referencing a disallowed type.
   Here's how the task declaration above can be fixed:
   
   ====
   include::sample[dir="snippets/configurationCache/disallowedTypesFixed/kotlin",files="build.gradle.kts[tags=ad-hoc-task]"]
   include::sample[dir="snippets/configurationCache/disallowedTypesFixed/groovy",files="build.gradle[tags=ad-hoc-task]"]
   ====
   <1> no more problems reported, the `doLast {}` closure now only captures `classpath` which is of the supported `FileCollection` type
   
   Note that sometimes the disallowed type is indirectly referenced.
   For example, you could have a task reference some type from a plugin that is allowed.
   That type could reference another allowed type that in turn references a disallowed type.
   The hierarchical view of the object graph provided in the HTML reports for problems should help you pinpoint the offender.
   
   === Using the `Project` object
   
   A task must not use any `Project` objects at execution time.
   This includes calling `Task.getProject()` while the task is running.
   
   Some cases can be fixed in the same way as for <<configuration_cache#config_cache:requirements:disallowed_types, disallowed types>>.
   
   Often, similar things are available on both `Project` and `Task`.
   For example if you need a `Logger` in your task actions you should use `Task.logger` instead of `Project.logger`.
   
   Otherwise, you can use <<custom_gradle_types#service_injection,injected services>> instead of the methods of `Project`.
   
   Here's an example of a problematic task type using the `Project` object at execution time:
   
   ====
   include::sample[dir="snippets/configurationCache/projectAtExecution/kotlin",files="build.gradle.kts[tags=task-type]"]
   include::sample[dir="snippets/configurationCache/projectAtExecution/groovy",files="build.gradle[tags=task-type]"]
   ====
   <1> this will be reported as a problem because the task action is using the `Project` object at execution time
   
   The following is how it should be done instead:
   
   ====
   include::sample[dir="snippets/configurationCache/projectAtExecutionFixed/kotlin",files="build.gradle.kts[tags=task-type]"]
   include::sample[dir="snippets/configurationCache/projectAtExecutionFixed/groovy",files="build.gradle[tags=task-type]"]
   ====
   <1> no more problem reported, the injected `FileSystemOperations` service is supported as a replacement for `project.copy {}`
   
   In the same vein, if you encounter the same problem with an ad-hoc task declared in a script as follows:
   
   ====
   include::sample[dir="snippets/configurationCache/projectAtExecution/kotlin",files="build.gradle.kts[tags=ad-hoc-task]"]
   include::sample[dir="snippets/configurationCache/projectAtExecution/groovy",files="build.gradle[tags=ad-hoc-task]"]
   ====
   <1> this will be reported as a problem because the task action is using the `Project` object at execution time
   
   Here's how the task declaration above can be fixed:
   
   ====
   include::sample[dir="snippets/configurationCache/projectAtExecutionFixed/kotlin",files="build.gradle.kts[tags=ad-hoc-task]"]
   include::sample[dir="snippets/configurationCache/projectAtExecutionFixed/groovy",files="build.gradle[tags=ad-hoc-task]"]
   ====
   <1> services can't be injected directly in scripts, we need an extra type to convey the injection point
   <2> create an instance of the extra type using `project.object` outside the task action
   <3> no more problem reported, the task action references `injected` that provides the `FileSystemOperations` service, supported as a replacement for `project.copy {}`
   
   As you can see above, fixing ad-hoc tasks declared in scripts requires quite a bit of ceremony.
   It is a good time to think about extracting your task declaration as a proper task class as shown previously.
   
   The following table shows what APIs or injected service should be used as a replacement for each of the `Project` methods.
   
   [cols="a,a",options="header"]
   |===
   | Instead of:
   | Use:
   
   | `project.rootDir`
   | A task input or output property or a script variable to capture the result of using `project.rootDir` to calculate the actual parameter.
   
   | `project.projectDir`
   | A task input or output property or a script variable to capture the result of using `project.projectDir` to calculate the actual parameter.
   
   | `project.buildDir`
   | A task input or output property or a script variable to capture the result of using `project.buildDir` to calculate the actual parameter.
   
   | `project.name`
   | A task input or output property or a script variable to capture the result of using `project.name` to calculate the actual parameter.
   
   | `project.description`
   | A task input or output property or a script variable to capture the result of using `project.description` to calculate the actual parameter.
   
   | `project.group`
   | A task input or output property or a script variable to capture the result of using `project.group` to calculate the actual parameter.
   
   | `project.version`
   | A task input or output property or a script variable to capture the result of using `project.version` to calculate the actual parameter.
   
   | `project.properties`, `project.property(name)`, `project.hasProperty(name)`, `project.getProperty(name)` or `project.findProperty(name)`
   | link:{groovyDslPath}#[Value providers for Gradle properties].
   
   | `project.logger`
   | link:{javadocPath}#[Task.logger]
   
   | `project.provider {}`
   | link:{groovyDslPath}#[ProviderFactory.provider {}]
   
   | `project.file(path)`
   | A task input or output property or a script variable to capture the result of using `project.file(file)` to calculate the actual parameter.
   
   | `project.uri(path)`
   | A task input or output property or a script variable to capture the result of using `project.uri(path)` to calculate the actual parameter. Otherwise, `File.toURI()` or some other JVM API can be used.
   
   | `project.relativePath(path)`
   | link:{javadocPath}#[ProjectLayout.projectDirectory].link:{javadocPath}#[file(path)]
   
   | `project.files(paths)`
   | link:{javadocPath}#[ObjectFactory.fileCollection()].link:{javadocPath}#[from(paths)]
   
   | `project.fileTree(paths)`
   | link:{javadocPath}#[ObjectFactory.fileTree()].link:{javadocPath}#[from(dir)]
   
   | `project.zipTree(path)`
   | link:{javadocPath}#[ArchiveOperations.zipTree(path)]
   
   | `project.tarTree(path)`
   | link:{javadocPath}#[ArchiveOperations.tarTree(path)]
   
   | `project.resources`
   | A task input or output property or a script variable to capture the result of using `project.resource` to calculate the actual parameter.
   
   | `project.copySpec {}`
   | link:{javadocPath}#[FileSystemOperations.copySpec {}]
   
   | `project.copy {}`
   | link:{javadocPath}#[FileSystemOperations.copy {}]
   
   | `project.sync {}`
   | link:{javadocPath}#[FileSystemOperations.sync {}]
   
   | `project.delete {}`
   | link:{javadocPath}#[FileSystemOperations.delete {}]
   
   | `project.mkdir(path)`
   | The Kotlin, Groovy or Java API available to your build logic.
   
   | `project.exec {}`
   | link:{javadocPath}#[ExecOperations.exec {}]
   
   | `project.javaexec {}`
   | link:{javadocPath}#[ExecOperations.javaexec {}]
   
   | `project.ant {}`
   | link:{javadocPath}#[Task.ant]
   
   | `project.createAntBuilder()`
   | link:{javadocPath}#[Task.ant]
   
   |===
   
   === Accessing a task instance from another instance
   
   Tasks should not directly access the state of another task instance.
   Instead, tasks should be connected using <<lazy_configuration#working_with_task_dependencies_in_lazy_properties, inputs and outputs relationships>>.
   
   Note that this requirement makes it unsupported to write tasks that configure other tasks at execution time.
   
   === Sharing mutable objects
   When storing a task to the configuration cache, all objects directly or indirectly referenced through the task's fields are serialized.
   In most cases, deserialization preserves reference equality: if two fields `a` and `b` reference the same instance at configuration time, then upon deserialization they will reference the same instance again, so `a == b` (or `a === b` in Groovy and Kotlin syntax) still holds.
   However, for performance reasons, some classes, in particular `java.lang.String`, `java.io.File`, and many implementations of `java.util.Collection` interface, are serialized without preserving the reference equality.
   Upon deserialization, fields that referred to the object of such a class can refer to different but equal objects.
   
   Let's look at a task that stores a user-defined object and an `ArrayList` in task fields.
   ====
   include::sample[dir="snippets/configurationCache/sharedObjects/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/configurationCache/sharedObjects/groovy",files="build.gradle[]"]
   ====
   <1> `doLast` action captures the references from the enclosing scope. These captured references are also serialized to the configuration cache.
   <2> Compare the reference to an object of user-defined class stored in the task field and the reference captured in the `doLast` action.
   <3> Compare the reference to `ArrayList` instance stored in the task field and the reference captured in the `doLast` action.
   <4> Check the equality of stored and captured lists.
   
   Running the build without the configuration cache shows that reference equality is preserved in both cases.
   ----
   仇 gradle --no-configuration-cache checkEquality
   include::{snippetsPath}/configurationCache/sharedObjects/tests/sharingObjectsWithoutConfigurationCache.out[]
   ----
   
   However, with the configuration cache enabled, only the user-defined object references are the same.
   List references are different, though the referenced lists are equal.
   ----
   仇 gradle --configuration-cache checkEquality
   include::{snippetsPath}/configurationCache/sharedObjects/tests/sharingObjectsWithConfigurationCache.out[]
   ----
   
   In general, it isn't recommended to share mutable objects between configuration and execution phases.
   If you need to do this, you should always wrap the state in a class you define.
   There is no guarantee that the reference equality is preserved for standard Java, Groovy, and Kotlin types, or for Gradle-defined types.
   
   Note that no reference equality is preserved between tasks: each task is its own "realm", so it is not possible to share objects between tasks.
   Instead, you can use a <<build_services#build_services,build service>> to wrap the shared state.
   
   === Accessing task extensions or conventions
   
   Tasks should not access conventions and extensions, including extra properties, at execution time.
   Instead, any value that's relevant for the execution of the task should be modeled as a task property.
   
   === Using build listeners
   
   Plugins and build scripts must not register any build listeners.
   That is listeners registered at configuration time that get notified at execution time.
   For example a `BuildListener` or a `TaskExecutionListener`.
   
   These should be replaced by <<build_services#build_services,build services>>, registered to receive information about <<build_services#operation_listener, task execution>> if needed.
   Use <<dataflow_actions.adoc#dataflow_action,dataflow actions>> to handle the build result instead of `buildFinished` listeners.
   
   === Running external processes
   
   Plugin and build scripts should avoid running external processes at configuration time.
   In general, it is preferred to run external processes in tasks with properly declared inputs and outputs to avoid unnecessary work when the task is up-to-date.
   If necessary, only configuration-cache-compatible APIs should be used instead of Java and Groovy standard APIs or existing `ExecOperations`,
   `Project.exec`, `Project.javaexec`, and their likes in settings and init scripts.
   For simpler cases, when grabbing the output of the process is enough,
   link:{groovyDslPath}#[providers.exec()] and
   link:{groovyDslPath}#[providers.javaexec()] can be used:
   
   ====
   include::sample[dir="snippets/valueProviders/externalProcessProvider/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/valueProviders/externalProcessProvider/groovy",files="build.gradle[]"]
   ====
   
   For more complex cases a custom link:{javadocPath}#[ValueSource] implementation with injected `ExecOperations` can be used.
   This `ExecOperations` instance can be used at configuration time without restrictions.
   
   ====
   include::sample[dir="snippets/valueProviders/externalProcessValueSource/kotlin",files="build.gradle.kts[tags=value-source]"]
   include::sample[dir="snippets/valueProviders/externalProcessValueSource/groovy",files="build.gradle[tags=value-source]"]
   ====
   
   The `ValueSource` implementation can then be used to create a provider with link:{groovyDslPath}#[providers.of]:
   
   ====
   include::sample[dir="snippets/valueProviders/externalProcessValueSource/kotlin",files="build.gradle.kts[tags=create-provider]"]
   include::sample[dir="snippets/valueProviders/externalProcessValueSource/groovy",files="build.gradle[tags=create-provider]"]
   ====
   
   In both approaches, if the value of the provider is used at configuration time then it will become a build configuration input.
   The external process will be executed for every build to determine if the configuration cache is up-to-date, so it is recommended to only call fast-running processes at configuration time.
   If the value changes then the cache is invalidated and the process will be run again during this build as part of the configuration phase.
   
   === Reading system properties and environment variables
   
   Plugins and build scripts may read system properties and environment variables directly at configuration time with standard Java, Groovy, or Kotlin APIs or with the value supplier APIs.
   Doing so makes such variable or property a build configuration input, so changing the value invalidates the configuration cache.
   The configuration cache report includes a list of these build configuration inputs to help track them.
   
   In general, you should avoid reading the value of system properties and environment variables at configuration time, to avoid cache misses when value changes.
   Instead, you can connect the `Provider` returned by link:{groovyDslPath}#[providers.systemProperty()] or
   link:{groovyDslPath}#[providers.environmentVariable()] to task properties.
   
   Some access patterns that potentially enumerate all environment variables or system properties (for example, calling `System.getenv().forEach()` or using the iterator of its `keySet()`) are
   discouraged.
   In this case, Gradle cannot find out what properties are actual build configuration inputs, so every available property becomes one.
   Even adding a new property will invalidate the cache if this pattern is used.
   
   Using a custom predicate to filter environment variables is an example of this discouraged pattern:
   
   ====
   include::sample[dir="snippets/valueProviders/envVarsSysPropsDont/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/valueProviders/envVarsSysPropsDont/groovy",files="build.gradle[]"]
   ====
   
   The logic in the predicate is opaque to the configuration cache, so all environment variables are considered inputs.
   One way to reduce the number of inputs is to always use methods that query a concrete variable name, such as `getenv(String)`, or `getenv().get()`:
   
   ====
   include::sample[dir="snippets/valueProviders/envVarsSysPropsDo/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/valueProviders/envVarsSysPropsDo/groovy",files="build.gradle[]"]
   ====
   
   The fixed code above, however, is not exactly equivalent to the original as only an explicit list of variables is supported.
   Prefix-based filtering is a common scenario, so there are provider-based APIs to access
   link:{groovyDslPath}#[system properties] and
   link:{groovyDslPath}#[environment variables]:
   
   ====
   include::sample[dir="snippets/valueProviders/envVarsSysPropsDoPrefix/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/valueProviders/envVarsSysPropsDoPrefix/groovy",files="build.gradle[]"]
   ====
   Note that the configuration cache would be invalidated not only when the value of the variable changes or the variable is removed but also
   when another variable with the matching prefix is added to the environment.
   
   For more complex use cases a custom link:{javadocPath}#[ValueSource] implementation can be used.
   System properties and environment variables referenced in the code of the `ValueSource` do not become build configuration inputs, so any processing can be applied.
   Instead, the value of the `ValueSource` is recomputed each time the build runs and only if the value changes the configuration cache is invalidated.
   For example, a `ValueSource` can be used to get all environment variables with names containing the substring `JDK`:
   
   ====
   include::sample[dir="snippets/valueProviders/envVarsSysPropsDoValueSource/kotlin",files="build.gradle.kts[tags=value-source,create-provider]"]
   include::sample[dir="snippets/valueProviders/envVarsSysPropsDoValueSource/groovy",files="build.gradle[tags=value-source,create-provider]"]
   ====
   
   === Undeclared reading of files
   
   Plugins and build scripts should not read files directly using the Java, Groovy or Kotlin APIs at configuration time.
   Instead, declare files as potential build configuration inputs using the value supplier APIs.
   
   This problem is caused by build logic similar to this:
   
   ====
   include::sample[dir="snippets/valueProviders/fileContentsDont/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/valueProviders/fileContentsDont/groovy",files="build.gradle[]"]
   ====
   
   To fix this problem, read files using link:{groovyDslPath}#[providers.fileContents()] instead:
   
   ====
   include::sample[dir="snippets/valueProviders/fileContentsDo/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/valueProviders/fileContentsDo/groovy",files="build.gradle[]"]
   ====
   
   In general, you should avoid reading files at configuration time, to avoid invalidating configuration cache entries when the file content changes.
   Instead, you can connect the `Provider` returned by link:{groovyDslPath}#[providers.fileContents()] to task properties.
   
   === Bytecode modifications and Java agent
   
   To detect the configuration inputs, Gradle modifies the bytecode of classes on the build script classpath, like plugins and their dependencies.
   Gradle uses a Java agent to modify the bytecode.
   Integrity self-checks of some libraries may fail because of the changed bytecode or the agent's presence.
   
   To work around this, you can use the <<worker_api.adoc#tasks_parallel_worker, Worker API>> with classloader or process isolation to encapsulate the library code.
   The bytecode of the worker's classpath is not modified, so the self-checks should pass.
   When process isolation is used, the worker action is executed in a separate worker process that doesn't have the Gradle Java agent installed.
   
   In simple cases, when the libraries also provide command-line entry points (`public static void main()` method), you can also use the link:{javadocPath}#[JavaExec] task to isolate the library.
   
   == Handling of credentials and secrets
   
   The configuration cache has currently no option to prevent storing secrets that are used as inputs, and so they might end up in the serialized configuration cache entry which, by default, is stored under `.gradle/configuration-cache` in your project directory.
   
   To mitigate the risk of accidental exposure, Gradle encrypts the configuration cache.
   Gradle transparently generates a machine-specific secret key as required, caches it under the
   `<<directory_layout.adoc#dir:gradle_user_home,GRADLE_USER_HOME>>` directory and uses it to encrypt the data in the project specific caches.
   
   To enhance security further, make sure to:
   
   * secure access to configuration cache entries;
   * leverage `<<directory_layout.adoc#dir:gradle_user_home,GRADLE_USER_HOME>>/gradle.properties` for storing secrets.
   The content of that file is not part of the configuration cache, only its fingerprint.
   If you store secrets in that file, care must be taken to protect access to the file content.
   
   See link:{gradle-issues}22618[gradle/gradle#22618].
   
   === Providing an encryption key via `GRADLE_ENCRYPTION_KEY` environment variable
   
   By default, Gradle automatically generates and manages the encryption key as a Java keystore stored under the `<<directory_layout.adoc#dir:gradle_user_home,GRADLE_USER_HOME>>` directory.
   
   For environments where this is undesirable (for instance, when the `<<directory_layout.adoc#dir:gradle_user_home,GRADLE_USER_HOME>>` directory is shared across machines),
   you may provide Gradle with the exact encryption key to use when
   reading or writing the cached configuration data via the `GRADLE_ENCRYPTION_KEY` environment variable.
   
   [IMPORTANT]
   ====
   You must ensure that the same encryption key is consistently provided across multiple Gradle runs,
   or else Gradle will not be able to reuse existing cached configurations.
   ====
   
   === Generating an encryption key that is compatible with GRADLE_ENCRYPTION_KEY
   
   For Gradle to encrypt the configuration cache using a user-specified encryption key,
   you must run Gradle while having the GRADLE_ENCRYPTION_KEY environment variable set with a valid AES key, encoded as a Base64 string.
   
   One way of generating a Base64-encoded AES-compatible key is by using a command like this:
   
   ```
   仇 openssl rand -base64 16
   ```
   
   This command should work on Linux, Mac OS, or on Windows, if using a tool like Cygwin.
   
   You can then use the Base64-encoded key produced by that command and set it as the value of the
   `GRADLE_ENCRYPTION_KEY` environment variable.
   
   
   == Not yet implemented
   
   Support for using configuration caching with certain Gradle features is not yet implemented.
   Support for these features will be added in later Gradle releases.
   
   === Sharing the configuration cache
   
   The configuration cache is currently stored locally only.
   It can be reused by hot or cold local Gradle daemons.
   But it can't be shared between developers or CI machines.
   
   See link:{gradle-issues}13510[gradle/gradle#13510].
   
   === Source dependencies
   
   Support for link:https://blog.gradle.org/introducing-source-dependencies[source dependencies] is not yet implemented.
   With the configuration cache enabled, no problem will be reported and the build will fail.
   
   See link:{gradle-issues}13506[gradle/gradle#13506].
   
   === Using a Java agent with builds run using TestKit
   
   When running builds using <<test_kit#test_kit, TestKit>>, the configuration cache can interfere with Java agents, such as the Jacoco agent, that are applied to these builds.
   
   See link:{gradle-issues}25979[gradle/gradle#25979].
   
   === Fine-grained tracking of Gradle properties as build configuration inputs
   
   Currently, all external sources of Gradle properties (`gradle.properties` in project directories and in the `<<directory_layout.adoc#dir:gradle_user_home,GRADLE_USER_HOME>>`, environment variables and system properties that set properties, and properties specified with
   command-line flags) are considered build configuration inputs regardless of what properties are actually used at configuration time. These sources, however, are not included in the configuration cache report.
   
   See link:{gradle-issues}20969[gradle/gradle#20969].
   
   === Java Object Serialization
   
   Gradle allows objects that support the link:https://docs.oracle.com/javase/8/docs/platform/serialization/spec/serialTOC.html[Java Object Serialization] protocol to be stored in the configuration cache.
   
   The implementation is currently limited to serializable classes that implement the `java.io.Serializable` interface and define one of the following combination of methods:
   
   - a `writeObject` method combined with a `readObject` method to control exactly which information to store;
   - a `writeObject` method with no corresponding `readObject`; `writeObject` must eventually call `ObjectOutputStream.defaultWriteObject`;
   - a `readObject` method with no corresponding `writeObject`; `readObject` must eventually call `ObjectInputStream.defaultReadObject`;
   - a `writeReplace` method to allow the class to nominate a replacement to be written;
   - a `readResolve` method to allow the class to nominate a replacement for the object just read;
   
   The following _Java Object Serialization_ features are **not** supported:
   
   - serializable classes implementing the `java.io.Externalizable` interface; objects of such classes are discarded by the configuration cache during serialization and reported as problems;
   - the `serialPersistentFields` member to explicitly declare which fields are serializable; the member, if present, is ignored; the configuration cache considers all but `transient` fields serializable;
   - the following methods of `ObjectOutputStream` are not supported and will throw `UnsupportedOperationException`:
   ** `reset()`, `writeFields()`, `putFields()`, `writeChars(String)`, `writeBytes(String)` and `writeUnshared(Any?)`.
   
   - the following methods of `ObjectInputStream` are not supported and will throw `UnsupportedOperationException`:
   ** `readLine()`, `readFully(ByteArray)`, `readFully(ByteArray, Int, Int)`, `readUnshared()`, `readFields()`, `transferTo(OutputStream)` and `readAllBytes()`.
   - validations registered via `ObjectInputStream.registerValidation` are simply ignored;
   - the `readObjectNoData` method, if present, is never invoked;
   
   See link:{gradle-issues}13588[gradle/gradle#13588].
   
   === Accessing top-level methods and variables of a build script at execution time
   
   A common approach to reuse logic and data in a build script is to extract repeating bits into top-level methods and variables.
   However, calling such methods at execution time is not currently supported if the configuration cache is enabled.
   
   For builds scripts written in Groovy, the task fails because the method cannot be found.
   The following snippet uses a top-level method in the `listFiles` task:
   ====
   include::sample[dir="snippets/configurationCache/topLevel/groovy",files="build.gradle[tags=not-supported]"]
   ====
   
   Running the task with the configuration cache enabled produces the following error:
   ----
   include::{snippetsPath}/configurationCache/topLevel/tests-groovy/notSupported.out[]
   ----
   
   To prevent the task from failing, convert the referenced top-level method to a static method within a class:
   ====
   include::sample[dir="snippets/configurationCache/topLevel/groovy",files="build.gradle[tags=workaround]"]
   ====
   
   Build scripts written in Kotlin cannot store tasks that reference top-level methods or variables at execution time in the configuration cache at all.
   This limitation exists because the captured script object references cannot be serialized.
   The first run of the Kotlin version of the `listFiles` task fails with the configuration cache problem.
   
   ====
   include::sample[dir="snippets/configurationCache/topLevel/kotlin",files="build.gradle.kts[tags=not-supported]"]
   ====
   
   To make the Kotlin version of this task compatible with the configuration cache, make the following changes:
   ====
   include::sample[dir="snippets/configurationCache/topLevel/kotlin",files="build.gradle.kts[tags=workaround]"]
   ====
   <1> Define the method inside an object.
   <2> Define the variable in a smaller scope.
   
   See link:{gradle-issues}22879[gradle/gradle#22879].
   
   === Using build services to invalidate the configuration cache
   
   Currently, it is impossible to use a `BuildServiceProvider` or provider derived from it with `map` or `flatMap` as a parameter for the `ValueSource`, if the value of the `ValueSource` is accessed at configuration time.
   The same applies when such a `ValueSource` is obtained in a task that executes as part of the configuration phase, for example tasks of the `buildSrc` build or included builds contributing plugins.
   Note that using a `@ServiceReference` or storing `BuildServiceProvider` in an `@Internal`-annotated property of a task is safe.
   Generally speaking, this limitation makes it impossible to use a `BuildService` to invalidate the configuration cache.
   
   See link:{gradle-issues}24085[gradle/gradle#24085].

/docs/userguide/optimizing-performance/inspect.adoc
===================================================

.. code-block::

   = Inspecting Gradle Builds
   
   Gradle provides multiple ways to inspect your build:
   
   - Profile with build scans
   - Local profile reports
   - Low level profiling
   
   == What is a build scan?
   
   https://scans.gradle.com/[Build scans] are a persistent, shareable record of what happened when running a build.
   Build scans provide insights into your build that you can use to identify and fix performance bottlenecks.
   
   In Gradle 4.3 and above, you can create a build scan using the `--scan` command line option:
   
   [listing.terminal]
   ----
   $ gradle build --scan
   ----
   
   For older Gradle versions, the
   https://docs.gradle.com/build-scan-plugin/#getting_set_up[Build Scan Plugin User Manual]
   explains how to enable build scans.
   
   At the end of your build, Gradle displays a URL where you can find your build scan:
   
   ----
   BUILD SUCCESSFUL in 2s
   4 actionable tasks: 4 executed
   
   Publishing build scan...
   https://gradle.com/s/e6ircx2wjbf7e
   ----
   
   This section explains how to profile your build with build scans.
   
   == Profile with build scans
   
   The performance page can help use build scans to profile a build.
   To get there, click _"Performance"_ in the left hand navigation menu
   or follow the "Explore performance" link on the build scan home page:
   
   image::performance/build-scan-home.png[title="Performance page link on build scan home page"]
   
   The performance page shows how long it took to complete different stages of a build.
   This page shows how long it took to:
   
   - start up
   - configure the build's projects
   - resolve dependencies
   - execute tasks
   
   You also get details about environmental properties, such as whether a daemon was used or not.
   
   image::performance/build-scan-performance-page.png[title="Build scan performance page"]
   
   In the above build scan, configuration takes over 13 seconds.
   Click on the _"Configuration"_ tab to break this stage into component parts,
   exposing the cause of the slowness.
   
   image::performance/build-scan-configuration-breakdown.png[title="Build scan configuration breakdown"]
   
   Here you can see the scripts and plugins applied to the project in descending order of how long they took to apply.
   The slowest plugin and script applications are good candidates for optimization.
   For example, the script `script-b.gradle` was applied once but took 3 seconds.
   Expand that row to see where the build applied this script.
   
   image::performance/script-b-application.png[title="Showing the application of script-b.gradle to the build"]
   
   You can see that subproject `:app1` applied the script once, from inside of that subproject's `build.gradle` file.
   
   == Profile report
   
   If you prefer not to use build scans, you can generate an HTML report in the
   `build/reports/profile` directory of your root project. To generate this report,
   use the `--profile` command-line option:
   
   [listing.terminal]
   ----
   $ gradle --profile <tasks>
   ----
   
   Each profile report has a timestamp in its name to avoid overwriting existing ones.
   
   The report displays a breakdown of the time taken to run the build.
   However, this breakdown is not as detailed as a build scan.
   The following profile report shows the different categories available:
   
   image::performance/gradle-profile-report.png[title="An example profile report", alt="Sample Gradle profile report"]
   
   == Low level profiling
   
   Sometimes your build can be slow even though your build scripts do everything right.
   This often comes down to inefficiencies in plugins and custom tasks or constrained resources.
   Use the https://github.com/gradle/gradle-profiler[Gradle Profiler] to find these kinds of bottlenecks.
   With the Gradle Profiler, you can define scenarios like "Running 'assemble' after making an ABI-breaking change"
   and run your build several times to collect profiling data.
   Use the Profiler to produce build scans. Or combine it with method profilers like JProfiler and YourKit.
   These profilers can help you find inefficient algorithms in custom plugins.
   If you find that something in Gradle itself slows down your build, don't hesitate to send a profiler snapshot to performance@gradle.com.
   
   == Performance categories
   
   Both build scans and local profile reports break down build execution into the same categories.
   The following sections explain those categories.
   
   === Startup
   
   This reflects Gradle뗩 initialization time, which consists mostly of:
   
   - JVM initialization and class loading
   - Downloading the Gradle distribution if youre using the wrapper
   - Starting the daemon if a suitable one isn뗪 already running
   - Executing Gradle initialization scripts
   
   Even when a build execution has a long startup time, subsequent runs
   usually see a dramatic drop off in startup time.
   Persistently slow build startup times are usually the result of problems in your init scripts.
   Double check that the work youre doing there is necessary and performant.
   
   === Settings and _buildSrc_
   
   After startup, Gradle initializes your project. Usually, Gradle only processes your settings file.
   If you have custom build logic in a `buildSrc` directory, Gradle also processes that logic.
   After building `buildSrc` once, Gradle considers it up to date. The up-to-date checks take significantly less time than logic processing.
   If your `buildSrc` phase takes too much time, consider breaking it out into a separate project.
   You can then add that project's JAR artifact as a dependency.
   
   The settings file rarely contains code with significant I/O or computation.
   If you find that Gradle takes a long time to process it, use more traditional profiling methods,
   like the https://github.com/gradle/gradle-profiler[the Gradle Profiler], to determine the cause.
   
   === Loading projects
   
   It normally doesn뗪 take a significant amount of time to load projects, nor do you have any control over it.
   The time spent here is basically a function of the number of projects you have in your build.

/docs/userguide/optimizing-performance/config_gradle.adoc
=========================================================

.. code-block::

   == Configuring Gradle
   
   == Configuring JVM memory
   
   The `org.gradle.jvmargs` Gradle property controls the VM running the build.
   It defaults to `-Xmx512m "-XX:MaxMetaspaceSize=384m"`
   
   You can adjust JVM options for Gradle in the following ways.
   
   *Option 1:* Changing JVM settings for the build VM:
   ====
   ----
   org.gradle.jvmargs=-Xmx2g -XX:MaxMetaspaceSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
   ----
   ====
   
   The `JAVA_OPTS` environment variable controls the command line client, which is only used to display console output. It defaults to `-Xmx64m`
   
   *Option 2:* Changing JVM settings for the client VM:
   ====
   ----
   JAVA_OPTS="-Xmx64m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8"
   ----
   ====
   
   [NOTE]
   ====
   There is one case where the client VM can also serve as the build VM:
   
   If you deactivate the <<gradle_daemon.adoc#gradle_daemon, Gradle Daemon>> and the client VM has the same settings as required for the build VM, the client VM will run the build directly.
   
   Otherwise, the client VM will fork a new VM to run the actual build in order to honor the different settings.
   ====
   
   Certain tasks, like the `test` task, also fork additional JVM processes.
   You can configure these through the tasks themselves.
   They use `-Xmx512m` by default.
   
   *Example 1:* Set compile options for Java compilation tasks:
   ====
   include::sample[dir="snippets/buildEnvironment/javaCompileOptions/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/buildEnvironment/javaCompileOptions/groovy",files="build.gradle[]"]
   ====
   
   See other examples in the link:{groovyDslPath}#[Test] API documentation and <<java_testing.adoc#sec:test_execution, test execution in the Java plugin reference>>.
   
   link:https://scans.gradle.com[Build scans] will tell you information about the JVM that executed the build when you use the `--scan` option:
   
   [caption= "Build Environment in build scans",link=https://scans.gradle.com/s/sample/cpp-parallel/infrastructure]
   image::build-scan-infrastructure.png[Build Environment in Build Scan]
   
   == Configuring a task using project properties
   
   It is possible to change the behavior of a task based on project properties specified at invocation time.
   
   Suppose you would like to ensure release builds are only triggered by CI.
   A simple way to do this is using the `isCI` project property.
   
   *Example 1:* Prevent releasing outside of CI:
   ====
   include::sample[dir="snippets/tutorial/configureTaskUsingProjectProperty/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/tutorial/configureTaskUsingProjectProperty/groovy",files="build.gradle[]"]
   ----
   $ gradle performRelease -PisCI=true --quiet
   include::{snippetsPath}/tutorial/configureTaskUsingProjectProperty/tests/configureTaskUsingProjectProperty.out[]
   ----
   ====

/docs/userguide/optimizing-performance/project_properties.adoc
==============================================================

.. code-block::

   == Project properties
   
   Project properties are available on the link:{groovyDslPath}#[Project] object.
   They can be set from the command line using the `-P` / `--project-prop` <<command_line_interface.adoc#sec:environment_options, environment option>>.
   
   The following examples demonstrate how to set project properties in different ways.
   
   *Example 1:* Setting a project property via the *command line*:
   ====
   ----
   $ gradle -PgradlePropertiesProp=commandLineValue
   ----
   ====
   
   Gradle can also set project properties when it sees specially-named system properties or environment variables.
   If the environment variable name looks like `ORG_GRADLE_PROJECT___prop__=somevalue`, then Gradle will set a `prop` property on your project object, with the value of `somevalue`.
   Gradle also supports this for system properties, but with a different naming pattern, which looks like `org.gradle.project.__prop__`.
   Both of the following will set the `foo' property on your Project object to `"bar"`.
   
   *Example 2:* Setting a project property via a *system property*:
   ====
   ----
   org.gradle.project.foo=bar
   ----
   ====
   
   *Example 3:* Setting a project property via an *environment variable*:
   ====
   ----
   ORG_GRADLE_PROJECT_foo=bar
   ----
   ====
   
   This feature is useful when you don't have admin rights to a continuous integration server and you need to set property values that should not be easily visible.
   Since you cannot use the `-P` option in that scenario nor change the system-level configuration files, the correct strategy is to change the configuration of your continuous integration build job, adding an environment variable setting that matches an expected pattern.
   This won't be visible to normal users on the system.
   
   The following examples demonstrate how to use project properties.
   
   *Example 1:* Reading project properties at configuration time:
   ====
   include::sample[dir="snippets/tutorial/projectProperties/kotlin",files="build.gradle.kts[tags=configuration]"]
   include::sample[dir="snippets/tutorial/projectProperties/groovy",files="build.gradle[tags=configuration]"]
   ====
   
   [.multi-language-text.lang-kotlin]
   The link:https://kotlinlang.org/docs/delegated-properties.html[Kotlin delegated properties] are part of the Gradle Kotlin DSL.
   You need to explicitly specify the type as `String`.
   If you need to branch depending on the presence of the property, you can also use `String?` and check for `null`.
   
   [.multi-language-text.lang-groovy]
   Note that if a Project property has a dot in its name, using the dynamic Groovy names is not possible.
   You have to use the API or the dynamic array notation instead.
   
   *Example 2:* Reading project properties for consumption at execution time:
   ====
   include::sample[dir="snippets/tutorial/projectProperties/kotlin",files="build.gradle.kts[tags=execution]"]
   include::sample[dir="snippets/tutorial/projectProperties/groovy",files="build.gradle[tags=execution]"]
   ====
   
   NOTE: If a project property is referenced but does not exist, an exception will be thrown, and the build will fail.
   You should check for the existence of optional project properties before you access them using the link:{groovyDslPath}#[Project.hasProperty(java.lang.String)] method.

/docs/userguide/optimizing-performance/networking.adoc
======================================================

.. code-block::

   == Networking with Gradle
   
   == Accessing the web through a proxy
   
   Configuring a proxy (for downloading dependencies, for example) is done via standard JVM system properties.
   
   These properties can be set directly in the build script.
   For example, setting the HTTP proxy host would be done with `System.setProperty('http.proxyHost', 'www.somehost.org')`.
   
   Alternatively, the properties can be <<build_environment.adoc#sec:gradle_configuration_properties,specified in `gradle.properties`>>.
   
   *Example 1:* Configuring an HTTP proxy using `gradle.properties`:
   ====
   ----
   systemProp.http.proxyHost=www.somehost.org
   systemProp.http.proxyPort=8080
   systemProp.http.proxyUser=userid
   systemProp.http.proxyPassword=password
   systemProp.http.nonProxyHosts=*.nonproxyrepos.com|localhost
   ----
   ====
   
   There are separate settings for HTTPS.
   
   *Example 2:* Configuring an HTTPS proxy using `gradle.properties`:
   ====
   ----
   systemProp.https.proxyHost=www.somehost.org
   systemProp.https.proxyPort=8080
   systemProp.https.proxyUser=userid
   systemProp.https.proxyPassword=password
   # NOTE: this is not a typo.
   systemProp.http.nonProxyHosts=*.nonproxyrepos.com|localhost
   ----
   ====
   
   There are separate settings for SOCKS.
   
   *Example 3:* Configuring a SOCKS proxy using `gradle.properties`:
   ====
   ----
   systemProp.socksProxyHost=www.somehost.org
   systemProp.socksProxyPort=1080
   systemProp.java.net.socks.username=userid
   systemProp.java.net.socks.password=password
   ----
   ====
   
   You may need to set other properties to access other networks.
   
   Helpful references:
   
   * link:https://github.com/apache/ant/blob/master/src/main/org/apache/tools/ant/util/ProxySetup.java[ProxySetup.java in the Ant codebase^]
   * link:https://docs.oracle.com/javase/8/docs/technotes/guides/net/proxies.html[JDK 8 Proxies^]
   
   === NTLM Authentication
   
   If your proxy requires NTLM authentication, you may need to provide the authentication domain as well as the username and password.
   
   There are 2 ways that you can provide the domain for authenticating to a NTLM proxy:
   
   * Set the `http.proxyUser` system property to a value like `__domain__/__username__`.
   * Provide the authentication domain via the `http.auth.ntlm.domain` system property.

/Section: 游릭 Using The Build Cache
====================================


/docs/userguide/optimizing-performance/build-cache/build_cache.adoc
===================================================================

.. code-block::

   = Build Cache
   
   TIP: Want to learn the tips and tricks top engineering teams use to keep builds fast and performant? https://gradle.org/training/#build-cache-deep-dive[Register here] for our Build Cache Training.
   
   == Overview
   
   The Gradle _build cache_ is a cache mechanism that aims to save time by reusing outputs produced by other builds.
   The build cache works by storing (locally or remotely) build outputs and allowing builds to fetch these outputs from the cache when it is determined that inputs have not changed, avoiding the expensive work of regenerating them.
   
   A first feature using the build cache is _task output caching_.
   Essentially, task output caching leverages the same intelligence as <<incremental_build#incremental_build,up-to-date checks>> that Gradle uses to avoid work when a previous local build has already produced a set of task outputs.
   But instead of being limited to the previous build in the same workspace, task output caching allows Gradle to reuse task outputs from any earlier build in any location on the local machine.
   When using a shared build cache for task output caching this even works across developer machines and build agents.
   
   Apart from tasks, <<artifact_transforms.adoc#sec:abm_artifact_transforms,artifact transforms>> can also leverage the build cache and re-use their outputs similarly to task output caching.
   
   TIP: For a hands-on approach to learning how to use the build cache, start with reading through the <<build_cache_use_cases.adoc#use_cases_cache,use cases for the build cache>> and the follow up sections.
   It covers the different scenarios that caching can improve and has detailed discussions of the different caveats you need to be aware of when enabling caching for a build.
   
   == Enable the Build Cache
   
   By default, the build cache is not enabled. You can enable the build cache in a couple of ways:
   
   Run with `--build-cache` on the command-line::
   Gradle will use the build cache for this build only.
   Put `org.gradle.caching=true` in your `gradle.properties`::
   Gradle will try to reuse outputs from previous builds for all builds, unless explicitly disabled with `--no-build-cache`.
   
   When the build cache is enabled, it will store build outputs in the Gradle User Home.
   For configuring this directory or different kinds of build caches see <<#sec:build_cache_configure,Configure the Build Cache>>.
   
   == Task Output Caching
   
   Beyond incremental builds described in <<incremental_build#incremental_build,up-to-date checks>>, Gradle can save time by reusing outputs from previous executions of a task by matching inputs to the task.
   Task outputs can be reused between builds on one computer or even between builds running on different computers via a build cache.
   
   We have focused on the use case where users have an organization-wide remote build cache that is populated regularly by continuous integration builds.
   Developers and other continuous integration agents should load cache entries from the remote build cache.
   We expect that developers will not be allowed to populate the remote build cache, and all continuous integration builds populate the build cache after running the `clean` task.
   
   For your build to play well with task output caching it must work well with the <<incremental_build#incremental_build,incremental build>> feature.
   For example, when running your build twice in a row all tasks with outputs should be `UP-TO-DATE`.
   You cannot expect faster builds or correct builds when enabling task output caching when this prerequisite is not met.
   
   Task output caching is automatically enabled when you enable the build cache, see <<#sec:build_cache_enable,Enable the Build Cache>>.
   
   === What does it look like
   
   Let us start with a project using the Java plugin which has a few Java source files. We run the build the first time.
   
   ----
   > gradle --build-cache compileJava
   :compileJava
   :processResources
   :classes
   :jar
   :assemble
   
   BUILD SUCCESSFUL
   ----
   
   We see the directory used by the local build cache in the output. Apart from that the build was the same as without the build cache.
   Let's clean and run the build again.
   
   ----
   > gradle clean
   :clean
   
   BUILD SUCCESSFUL
   ----
   
   ----
   > gradle --build-cache assemble
   :compileJava FROM-CACHE
   :processResources
   :classes
   :jar
   :assemble
   
   BUILD SUCCESSFUL
   ----
   
   Now we see that, instead of executing the `:compileJava` task, the outputs of the task have been loaded from the build cache.
   The other tasks have not been loaded from the build cache since they are not cacheable. This is due to
   `:classes` and `:assemble` being <<lifecycle_tasks.adoc#sec:lifecycle_tasks,lifecycle tasks>> and `:processResources`
   and `:jar` being Copy-like tasks which are not cacheable since it is generally faster to execute them.
   
   == Cacheable tasks
   
   Since a task describes all of its inputs and outputs, Gradle can compute a _build cache key_ that uniquely defines the task's outputs based on its inputs.
   That build cache key is used to request previous outputs from a build cache or store new outputs in the build cache.
   If the previous build outputs have been already stored in the cache by someone else, e.g. your continuous integration server or other developers, you can avoid executing most tasks locally.
   
   The following inputs contribute to the build cache key for a task in the same way that they do for <<incremental_build.adoc#sec:how_does_it_work,up-to-date checks>>:
   
   * The task type and its classpath
   * The names of the output properties
   * The names and values of properties annotated as described in <<incremental_build.adoc#sec:task_input_output_annotations,the section called "Custom task types">>
   * The names and values of properties added by the DSL via link:{javadocPath}#[TaskInputs]
   * The classpath of the Gradle distribution, buildSrc and plugins
   * The content of the build script when it affects execution of the task
   
   Task types need to opt-in to task output caching using the link:{javadocPath}#[@CacheableTask] annotation.
   Note that link:{javadocPath}#[@CacheableTask] is not inherited by subclasses.
   Custom task types are _not_ cacheable by default.
   
   === Built-in cacheable tasks
   
   Currently, the following built-in Gradle tasks are cacheable:
   
   * Java toolchain:
       link:{groovyDslPath}#[JavaCompile],
       link:{groovyDslPath}#[Javadoc]
   * Groovy toolchain:
       link:{groovyDslPath}#[GroovyCompile],
       link:{groovyDslPath}#[Groovydoc]
   * Scala toolchain:
       link:{groovyDslPath}#[ScalaCompile],
       `org.gradle.language.scala.tasks.PlatformScalaCompile` (removed),
       link:{groovyDslPath}#[ScalaDoc]
   * Native toolchain:
       link:{javadocPath}#[CppCompile],
       link:{javadocPath}#[CCompile],
       link:{javadocPath}#[SwiftCompile]
   * Testing:
       link:{groovyDslPath}#[Test]
   * Code quality tasks:
       link:{groovyDslPath}#[Checkstyle],
       link:{groovyDslPath}#[CodeNarc],
       link:{groovyDslPath}#[Pmd]
   * JaCoCo:
       link:{groovyDslPath}#[JacocoReport]
   * Other tasks:
       link:{groovyDslPath}#[AntlrTask],
       link:{javadocPath}#[ValidatePlugins],
       link:{groovyDslPath}#[WriteProperties]
   
   All other built-in tasks are currently not cacheable.
   
   Some tasks, like link:{groovyDslPath}#[Copy] or link:{groovyDslPath}#[Jar], usually do not make sense to make cacheable because Gradle is only copying files from one location to another.
   It also doesn't make sense to make tasks cacheable that do not produce outputs or have no task actions.
   
   === Third party plugins
   
   There are third party plugins that work well with the build cache.
   The most prominent examples are the https://developer.android.com/studio/releases/gradle-plugin.html[Android plugin 3.1+] and the https://blog.gradle.org/kotlin-build-cache-use[Kotlin plugin 1.2.21+].
   For other third party plugins, check their documentation to find out whether they support the build cache.
   
   === Declaring task inputs and outputs
   
   It is very important that a cacheable task has a complete picture of its inputs and outputs, so that the results from one build can be safely re-used somewhere else.
   
   Missing task inputs can cause incorrect cache hits, where different results are treated as identical because the same cache key is used by both executions.
   Missing task outputs can cause build failures if Gradle does not completely capture all outputs for a given task.
   Wrongly declared task inputs can lead to cache misses especially when containing volatile data or absolute paths.
   (See <<incremental_build.adoc#sec:task_inputs_outputs,the section called "Task inputs and outputs">> on what should be declared as inputs and outputs.)
   
   NOTE: The task path is _not_ an input to the build cache key.
   This means that tasks with different task paths can re-use each other's outputs as long as Gradle determines that executing them yields the same result.
   
   In order to ensure that the inputs and outputs are properly declared use integration tests (for example using TestKit) to check that a task produces the same outputs for identical inputs and captures all output files for the task.
   We suggest adding tests to ensure that the task inputs are relocatable, i.e. that the task can be loaded from the cache into a different build directory (see link:{javadocPath}#[@PathSensitive]).
   
   In order to handle volatile inputs for your tasks consider <<incremental_build.adoc#sec:configure_input_normalization,configuring input normalization>>.
   
   === Marking tasks as non-cacheable by default
   
   There are certain tasks that don't benefit from using the build cache.
   One example is a task that only moves data around the file system, like a `Copy` task.
   You can signify that a task is not to be cached by adding the `@DisableCachingByDefault` annotation to it.
   You can also give a human-readable reason for not caching the task by default.
   The annotation can be used on its own, or together with `@CacheableTask`.
   
   NOTE: This annotation is only for documenting the reason behind not caching the task by default.
   Build logic can override this decision via the runtime API (see below).
   
   == Enable caching of non-cacheable tasks
   
   As we have seen, built-in tasks, or tasks provided by plugins, are cacheable if their class is annotated with the `Cacheable` annotation.
   But what if you want to make cacheable a task whose class is not cacheable?
   Let's take a concrete example: your build script uses a generic `NpmTask` task to create a JavaScript bundle by delegating to NPM (and running `npm run bundle`).
   This process is similar to a complex compilation task, but `NpmTask` is too generic to be cacheable by default: it just takes arguments and runs npm with those arguments.
   
   The inputs and outputs of this task are simple to figure out.
   The inputs are the directory containing the JavaScript files, and the NPM configuration files.
   The output is the bundle file generated by this task.
   
   === Using annotations
   
   We create a subclass of the `NpmTask` and use <<incremental_build.adoc#sec:task_input_output_annotations,annotations to declare the inputs and outputs>>.
   
   When possible, it is better to use delegation instead of creating a subclass.
   That is the case for the built in `JavaExec`, `Exec`, `Copy` and `Sync` tasks, which have a method on `Project` to do the actual work.
   
   If you're a modern JavaScript developer, you know that bundling can be quite long, and is worth caching.
   To achieve that, we need to tell Gradle that it's allowed to cache the output of that task, using the link:{javadocPath}#[@CacheableTask] annotation.
   
   This is sufficient to make the task cacheable on your own machine.
   However, input files are identified by default by their absolute path.
   So if the cache needs to be shared between several developers or machines using different paths, that won't work as expected.
   So we also need to set the <<build_cache_concepts.adoc#relocatability,path sensitivity>>.
   In this case, the relative path of the input files can be used to identify them.
   
   Note that it is possible to override property annotations from the base class by overriding the getter of the base class and annotating that method.
   
   .Custom cacheable BundleTask
   ====
   include::sample[dir="snippets/buildCache/cacheable-bundle-task/kotlin",files="build.gradle.kts[tags=bundle-task]"]
   include::sample[dir="snippets/buildCache/cacheable-bundle-task/groovy",files="build.gradle[tags=bundle-task]"]
   ====
   - (1) Add `@CacheableTask` to enable caching for the task.
   - (2) Override the getter of a property of the base class to change the input annotation to `@Internal`.
   - (3) (4) Declare the path sensitivity.
   
   === Using the runtime API
   
   If for some reason you cannot create a new custom task class, it is also possible to make a task cacheable using the <<incremental_build.adoc#sec:task_input_output_runtime_api,runtime API>> to declare the inputs and outputs.
   
   For enabling caching for the task you need to use the link:{javadocPath}#[TaskOutputs.cacheIf()] method.
   
   The declarations via the runtime API have the same effect as the annotations described above.
   Note that you cannot override file inputs and outputs via the runtime API.
   Input properties can be overridden by specifying the same property name.
   
   .Make the bundle task cacheable
   ====
   include::sample[dir="snippets/buildCache/cacheable-bundle/kotlin",files="build.gradle.kts[tags=bundle-task]"]
   include::sample[dir="snippets/buildCache/cacheable-bundle/groovy",files="build.gradle[tags=bundle-task]"]
   ====
   
   == Configure the Build Cache
   
   You can configure the build cache by using the link:{groovyDslPath}#[Settings.buildCache(org.gradle.api.Action)] block in `settings.gradle`.
   
   Gradle supports a `local` and a `remote` build cache that can be configured separately.
   When both build caches are enabled, Gradle tries to load build outputs from the local build cache first, and then tries the remote build cache if no build outputs are found.
   If outputs are found in the remote cache, they are also stored in the local cache, so next time they will be found locally.
   Gradle stores ("pushes") build outputs in any build cache that is enabled and has link:{javadocPath}#[BuildCache.isPush()] set to `true`.
   
   By default, the local build cache has push enabled, and the remote build cache has push disabled.
   
   The local build cache is pre-configured to be a link:{groovyDslPath}#[DirectoryBuildCache] and enabled by default.
   The remote build cache can be configured by specifying the type of build cache to connect to (link:{groovyDslPath}#[BuildCacheConfiguration.remote(java.lang.Class)]).
   
   === Built-in local build cache
   
   The built-in local build cache, link:{groovyDslPath}#[DirectoryBuildCache], uses a directory to store build cache artifacts.
   By default, this directory resides in the Gradle User Home, but its location is configurable.
   
   Gradle will periodically clean-up the local cache directory by removing entries that have not been used recently to conserve disk space.
   How often Gradle will perform this clean-up is configurable as shown in the example below.
   Note that cache entries are cleaned-up regardless of the project they were produced by.
   If different projects configure this clean-up to run at different periods, the shortest period will clean-up cache entries for all projects.
   Therefore it is recommended to configure this setting globally in the <<init_scripts.adoc#sec:using_an_init_script,init script>>.
   The <<sec:build_cache_configure_use_cases, Configuration use-cases>> section has an example of putting cache configuration in the init script.
   
   For more details on the configuration options refer to the DSL documentation of link:{groovyDslPath}#[DirectoryBuildCache].
   Here is an example of the configuration.
   
   .Configure the local cache
   ====
   include::sample[dir="snippets/buildCache/configure-built-in-caches/kotlin",files="settings.gradle.kts[tags=configure-directory-build-cache]"]
   include::sample[dir="snippets/buildCache/configure-built-in-caches/groovy",files="settings.gradle[tags=configure-directory-build-cache]"]
   ====
   
   === Remote HTTP build cache
   
   link:{groovyDslPath}#[HttpBuildCache] provides the ability read to and write from a remote cache via HTTP.
   
   With the following configuration, the local build cache will be used for storing build outputs while the local and the remote build cache will be used for retrieving build outputs.
   
   .Load from HttpBuildCache
   ====
   include::sample[dir="snippets/buildCache/http-build-cache/kotlin",files="settings.gradle.kts[tags=http-build-cache]"]
   include::sample[dir="snippets/buildCache/http-build-cache/groovy",files="settings.gradle[tags=http-build-cache]"]
   ====
   
   When attempting to load an entry, a `GET` request is made to `\https://example.com:8123/cache/춺cache-key췉`.
   The response must have a `2xx` status and the cache entry as the body, or a `404 Not Found` status if the entry does not exist.
   
   When attempting to store an entry, a `PUT` request is made to `\https://example.com:8123/cache/춺cache-key췉`.
   Any `2xx` response status is interpreted as success.
   A `413 Payload Too Large` response may be returned to indicate that the payload is larger than the server will accept, which will not be treated as an error.
   
   ==== Specifying access credentials
   
   https://en.wikipedia.org/wiki/Basic_access_authentication[HTTP Basic Authentication] is supported, with credentials being sent preemptively.
   
   .Specifying access credentials
   ====
   include::sample[dir="snippets/buildCache/configure-built-in-caches/kotlin",files="settings.gradle.kts[tags=configure-http-build-cache]"]
   include::sample[dir="snippets/buildCache/configure-built-in-caches/groovy",files="settings.gradle[tags=configure-http-build-cache]"]
   ====
   
   ==== Redirects
   
   `3xx` redirecting responses will be followed automatically.
   
   Servers must take care when redirecting `PUT` requests as only `307` and `308` redirect responses will be followed with a `PUT` request.
   All other redirect responses will be followed with a `GET` request, as per https://datatracker.ietf.org/doc/html/rfc7231#page-54[RFC 7231],
   without the entry payload as the body.
   
   ==== Network error handling
   
   Requests that fail during request transmission, after having established a TCP connection, will be retried automatically.
   
   This prevents temporary problems, such as connection drops, read or write timeouts, and low level network failures such as a connection resets, causing cache operations to fail and disabling the remote cache for the remainder of the build.
   
   Requests will be retried up to 3 times.
   If the problem persists, the cache operation will fail and the remote cache will be disabled for the remainder of the build.
   
   ==== Using SSL
   
   By default, use of HTTPS requires the server to present a certificate that is trusted by the build's Java runtime.
   If your server's certificate is not trusted, you can:
   
   1. Update the trust store of your Java runtime to allow it to be trusted
   2. Change the <<build_environment.adoc#build_environment,build environment>> to use an alternative trust store for the build runtime
   3. Disable the requirement for a trusted certificate
   
   The trust requirement can be disabled by setting link:{groovyDslPath}#[HttpBuildCache.isAllowUntrustedServer()] to `true`.
   Enabling this option is a security risk, as it allows any cache server to impersonate the intended server.
   It should only be used as a temporary measure or in very tightly controlled network environments.
   
   .Allow untrusted cache server
   ====
   include::sample[dir="snippets/buildCache/http-build-cache/kotlin",files="settings.gradle.kts[tags=allow-untrusted-server]"]
   include::sample[dir="snippets/buildCache/http-build-cache/groovy",files="settings.gradle[tags=allow-untrusted-server]"]
   ====
   
   ==== HTTP expect-continue
   
   Use of https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.2.3[HTTP Expect-Continue] can be enabled.
   This causes upload requests to happen in two parts: first a check whether a body would be accepted, then transmission of the body if the server indicates it will accept it.
   
   This is useful when uploading to cache servers that routinely redirect or reject upload requests,
   as it avoids uploading the cache entry just to have it rejected (e.g. the cache entry is larger than the cache will allow) or redirected.
   This additional check incurs extra latency when the server accepts the request, but reduces latency when the request is rejected or redirected.
   
   Not all HTTP servers and proxies reliably implement Expect-Continue.
   Be sure to check that your cache server does support it before enabling.
   
   To enable, set link:{groovyDslPath}#[HttpBuildCache.isUseExpectContinue()] to `true`.
   
   .Use Expect-Continue
   ====
   include::sample[dir="snippets/buildCache/http-build-cache/kotlin",files="settings.gradle.kts[tags=use-expect-continue]"]
   include::sample[dir="snippets/buildCache/http-build-cache/groovy",files="settings.gradle[tags=use-expect-continue]"]
   ====
   
   === Configuration use cases
   
   The recommended use case for the remote build cache is that your continuous integration server populates it from clean builds while developers only load from it.
   The configuration would then look as follows.
   
   .Recommended setup for CI push use case
   ====
   include::sample[dir="snippets/buildCache/developer-ci-setup/kotlin",files="settings.gradle.kts[tags=developer-ci-setup]"]
   include::sample[dir="snippets/buildCache/developer-ci-setup/groovy",files="settings.gradle[tags=developer-ci-setup]"]
   ====
   
   It is also possible to configure the build cache from an <<init_scripts.adoc#sec:using_an_init_script,init script>>, which can be used from the command line, added to your Gradle User Home or be a part of your custom Gradle distribution.
   
   .Init script to configure the build cache
   ====
   include::sample[dir="snippets/buildCache/configure-by-init-script/kotlin",files="init.gradle.kts[]"]
   include::sample[dir="snippets/buildCache/configure-by-init-script/groovy",files="init.gradle[]"]
   ====
   
   === Build cache, composite builds and `buildSrc`
   
   Gradle's <<composite_builds.adoc#composite_builds,composite build feature>> allows including other complete Gradle builds into another.
   Such included builds will inherit the build cache configuration from the top level build, regardless of whether the included builds define build cache configuration themselves or not.
   
   The build cache configuration present for any included build is effectively ignored, in favour of the top level build's configuration.
   This also applies to any `buildSrc` projects of any included builds.
   
   The <<sharing_build_logic_between_subprojects.adoc#sec:using_buildsrc,`buildSrc` directory>> is treated as an <<composite_builds.adoc#composite_build_intro,included build>>, and as such it inherits the build cache configuration from the top-level build.
   
   NOTE: This configuration precedence does not apply to <<composite_builds.adoc#included_plugin_builds,plugin builds>> included through `pluginManagement` as these are loaded _before_ the cache configuration itself.
   
   == How to set up an HTTP build cache backend
   
   Gradle provides a Docker image for a link:https://hub.docker.com/r/gradle/build-cache-node/[build cache node], which can connect with Develocity for centralized management.
   The cache node can also be used without a Develocity installation with restricted functionality.
   
   == Implement your own Build Cache
   
   Using a different build cache backend to store build outputs (which is not covered by the built-in support for connecting to an HTTP backend) requires implementing
   your own logic for connecting to your custom build cache backend.
   To this end, custom build cache types can be registered via link:{javadocPath}#[BuildCacheConfiguration.registerBuildCacheService(java.lang.Class, java.lang.Class)].
   
   link:https://gradle.com/gradle-enterprise-solutions/build-cache/[Develocity] includes a high-performance, easy to install and operate, shared build cache backend.

/docs/userguide/optimizing-performance/build-cache/build_cache_use_cases.adoc
=============================================================================

.. code-block::

   = Use cases for the build cache
   
   This section covers the different use cases for Gradle뗩 build cache, from local-only development to caching task outputs across large teams.
   
   == Speed up developer builds with the local cache
   
   Even when used by a single developer only, the build cache can be very useful.
   Gradle's _incremental build_ feature helps to avoid work that is already done, but once you re-execute a task, any previous results are forgotten.
   When you are switching branches back and forth, the local results get rebuilt over and over again, even if you are building something that has already been built before.
   The build cache remembers the earlier build results, and greatly reduces the need to rebuild things when they have already been built locally.
   This can also extend to rebuilding different commits, like when running `git bisect`.
   
   The local cache can also be useful when working with a project that has multiple variants, as in the case of Android projects. Each variant has a number of tasks associated with it, and some of those task variant dimensions, despite having different names, can end up producing the same output. With the local cache enabled, reuse between task variants will happen automatically when applicable.
   
   == Share results between CI builds
   
   The build cache can do more than go back-and-forth in time: it can also bridge physical distance between computers, allowing results generated on one machine to be re-used by another.
   A typical first step when introducing the build cache within a team is to enable it for builds running as part of _continuous integration_ only. Using a shared HTTP build cache backend (such as https://gradle.com/build-cache/[the one provided by Develocity]) can significantly reduce the work CI agents need to do.
   This translates into faster feedback for developers, and less money spent on the CI resources.
   Faster builds also mean fewer commits being part of each build, which makes debugging issues more efficient.
   
   Beginning with the build cache on CI is a good first step as the environment on CI agents is usually more stable and predictable than developer machines.
   This helps to identify any possible issues with the build that may affect cacheability.
   
   If you are subject to audit requirements regarding the artifacts you ship to your customers you may need to disable the build cache for certain builds.
   Develocity may help you with fulfilling these requirements while still using the build cache for all your builds.
   It allows you to easily find out which build produced an artifact coming from the build cache via build scans.
   
   [.screenshot]
   image::build-cache/from-cache-origin.png[]
   
   == Accelerate developer builds by reusing CI results
   
   When multiple developers work on the same project, they don't just need to build their own changes: whenever they pull from version control, they end up having to build each other's changes as well.
   Whenever a developer is working on something independent of the pulled changes, they can safely reuse outputs already generated on CI.
   Say, you're working on module "A", and you pull in some changes to module "B" (which does not depend on your module).
   If those changes were already built in CI, you can download the task outputs for module "B" from the cache instead of generating them locally.
   A typical use case for this is when developers start their day, pull all changes from version control and then run their first build.
   
   The changes don't need to be completely independent, either; we'll take a look at the strategies to reuse results when dependencies are involved in the section about the <<build_cache_concepts.adoc#normalization,different forms of normalization>>.
   
   == Combine remote results with local caching
   
   You can utilize both a local and a remote cache for a compound effect.
   While loading results from a CI-filled remote cache helps to avoid work needed because of changes by other developers, the local cache can speed up switching branches and doing `git bisect`.
   On CI machines the local cache can act as a mirror of the remote cache, significantly reducing network usage.
   
   == Share results between developers
   
   Allowing developers to upload their results to a shared cache is possible, but not recommended.
   Developers can make changes to task inputs or outputs while the task is executing.
   They can do this unintentionally and without noticing, for example by making changes in their IDEs while a build is running.
   Currently, Gradle has no good way to defend against these changes, and will simply cache whatever is in the output directory once the task is finished.
   This again can lead to corrupted results being uploaded to the shared cache.
   This recommendation might change when Gradle has added the necessary safeguards against unintentional modification of task inputs and outputs.
   
   [WARNING]
   ====
   If you want to share task output from incremental builds, i.e. non-clean builds, you have to make sure that all cacheable tasks are properly configured and implemented to deal with stale output.
   There are for example annotation processors that do not clean up stale files in the corresponding classes/resources directories.
   The cache is a great forcing function to fix these problems, which will also make your incremental builds much more reliable.
   At the same time, until you have confidence that the incremental build behavior is flawless, only use clean builds to upload content to the cache.
   ====

/docs/userguide/optimizing-performance/build-cache/build_cache_performance.adoc
===============================================================================

.. code-block::

   = Build cache performance
   
   The sole reason to use any build cache is to make builds faster.
   But how much faster can you go when using the cache?
   Measuring the impact is both important and complicated, as cache performance is determined by many factors.
   Performing measurements of the cache's impact can validate the extra effort (work, infrastructure) that is required to start using the cache.
   These measurements can later serve as baselines for future improvements, and to watch for signs of regressions.
   
   NOTE: Proper configuration and maintenance of a build can improve caching performance in a big way.
   
   == Fully cached builds
   
   The most straightforward way to get a feel for what the cache can do for you is to measure the difference between a non-cached build and a _fully cached_ build. This will give you the theoretical limit of how fast builds with the cache can get, if everything you're trying to build has already been built. The easiest way to measure this is using the local cache:
   
   1. Clean the cache directory to avoid any hits from previous builds (`rm -rf $GRADLE_USER_HOME/caches/build-cache-*`)
   2. Run the build (e.g. `./gradlew --build-cache clean assemble`), so that all the results from cacheable tasks get stored in the cache.
   3. Run the build again (e.g. `./gradlew --build-cache clean assemble`); depending on your build, you should see many of the tasks being retrieved from the cache.
   4. Compare the execution time for the two builds
   
   NOTE: You may encounter a few cached tasks even in the first of the two builds, where no previously cached results should be available.
   This can happen if you have tasks in your build that are configured to produce the same results from the same inputs; in such a case once one of these tasks has finished, Gradle will simply reuse its output for the rest of the tasks.
   
   Normally, your _fully cached_ build should be significantly faster than the `clean` build: this is the theoretical limit of how much time using the build cache can save on your particular build.
   You usually don't get the achievable performance gains on the first try, see <<build_cache_debugging.adoc#finding_problems,finding problems with task output caching>>.
   As your build logic is evolving and changing it is also important to make sure that the cache effectiveness is not regressing.
   Build scans provide a detailed performance breakdown which show you how effectively your build is using the build cache:
   
   [.screenshot]
   image::build-cache/performance-task-execution.png[]
   
   Fully cached builds occur in situations when developers check out the latest from version control and then build, for example to generate the latest sources they need in their IDE.
   The purpose of running most builds though is to process some new changes.
   The structure of the software being built (how many modules are there, how independent are its parts etc.), and the nature of the changes themselves ("big refactor in the core of the system" vs. "small change to a unit test" etc.) strongly influence the performance gains delivered by the build cache.
   As developers tend to submit different kinds of changes over time, caching performance is expected to vary with each change.
   As with any cache, the impact should therefore be measured over time.
   
   In a setup where a team uses a shared cache backend, there are two locations worth measuring cache impact at: on CI and on developer machines.
   
   == Cache impact on CI builds
   
   The best way to learn about the impact of caching on CI is to set up the same builds with the cache enabled and disabled, and compare the results over time. If you have a single Gradle build step that you want to enable caching for, it's easy to compare the results using your CI system's built-in statistical tools.
   
   Measuring complex pipelines may require more work or external tools to collect and process measurements.
   It's important to distinguish those parts of the pipeline that caching has no effect on, for example, the time builds spend waiting in the CI system's queue, or time taken by checking out source code from version control.
   
   When using Develocity, you can use the https://docs.gradle.com/enterprise/export-api/[Export API] to access the necessary data and run your analytics.
   Develocity provides much richer data compared to what can be obtained from CI servers.
   For example, you can get insights into the execution of single tasks, how many tasks were retrieved from the cache, how long it took to download from the cache, the properties that were used to calculate the cache key and more.
   When using your CI servers built in functions, you can use https://confluence.jetbrains.com/display/TCD10/Statistic+Charts[statistic charts] if you use Teamcity for your CI builds.
   Most of time you will end up extracting data from your CI server via the corresponding REST API (see https://wiki.jenkins-ci.org/display/JENKINS/Remote+access+API[Jenkins remote access API] and https://confluence.jetbrains.com/display/TCD10/REST+API[Teamcity REST API]).
   
   Typically, CI builds above a certain size include parallel sections to utilize multiple agents. With parallel pipelines you can measure the wall-clock time it takes for a set of changes to go from having been pushed to version control to being built, verified and deployed. The build cache's effect in this case can be measured in the reduction of the time developers have to wait for feedback from CI.
   
   You can also measure the cumulative time your build agents spent building a changeset, which will give you a sense of the amount of work the CI infrastructure has to exert. The cache's effect here is less money spent on CI resources, as you don't need as many CI agents to maintain the same number of changes built.
   
   If you want to look at the measurement for the Gradle build itself you can have a look at the blog post https://blog.gradle.org/introducing-gradle-build-cache["Introducing the build cache"].
   
   == Measuring developer builds
   
   Gradle's build cache can be very useful in reducing CI infrastructure cost and feedback time, but it usually has the biggest impact when developers can reuse cached results in their local builds. This is also the hardest to quantify for a number of reasons:
   
   * developers run different builds
   * developers can have different hardware, or have different settings
   * developers run all kinds of other things on their machines that can slow them down
   
   When using Develocity you can use the https://docs.gradle.com/enterprise/export-api/[Export API] to extract data about developer builds, too.
   You can then create statistics on how many tasks were cached per developer or build.
   You can even compare the times it took to execute the task vs loading it from the cache and then estimate the time saved per developer.
   
   When using the https://gradle.com/build-cache[Develocity build cache backend] you should pay close attention to the hit rate in the admin UI.
   A rise in the hit rate there probably indicates better usage by developers:
   
   [.screenshot]
   image::build-cache/cache-admin-hit-rate.png[build cache hit rate]
   
   == Analyzing performance in build scans
   
   Build scans provide a summary of all cache operations for a build via the _"Build cache"_ section of the _"Performance"_ page.
   
   [.screenshot]
   image::build-cache/build-cache-performance.png[build cache performance]
   
   This page details which tasks were able to be avoided by cache hits, and which missed.
   It also indicates the hits and misses for the local and remote caches individually.
   For remote cache operations, the time taken to transfer artifacts to and from the cache is given, along with the transfer rate.
   This is particularly important for assessing the impact of network link quality on performance, as transfer times contribute to build time.
   
   == Remote cache performance
   
   Improving the network link between the build and the remote cache can significantly improve build cache performance.
   How to do this depends on the remote cache in use and your network environment.
   
   The multi-node remote build cache provided by Develocity is a fast and efficient, purpose built, remote build cache.
   In particular, if your development team is geographically distributed, its replication features can significantly improve performance by allowing developers to use a cache that they have a good network link to.
   See the https://docs.gradle.com/enterprise/admin/current/#replication[Build Cache Replication section of the Develocity Admin Manual] for more information.

/docs/userguide/optimizing-performance/build-cache/build_cache_concepts.adoc
============================================================================

.. code-block::

   = Important concepts
   
   How much of your build gets loaded from the cache depends on many factors.
   In this section you will see some of the tools that are essential for well-cached builds.
   https://gradle.com/build-scans[Build scans] are part of that toolchain and will be used throughout this guide.
   
   == Build cache key
   
   Artifacts in the build cache are uniquely identified by a <<build_cache.adoc#sec:task_output_caching_details,build cache key>>.
   A build cache key is assigned to each cacheable task when running with the build cache enabled and is used for both loading and storing task outputs to the build cache.
   The following inputs contribute to the build cache key for a task:
   
   * The task implementation
   * The task action implementations
   * The names of the output properties
   * The names and values of task inputs
   
   Two tasks can reuse their outputs by using the build cache if their associated build cache keys are the same.
   
   == Repeatable task outputs
   
   Assume that you have a code generator task as part of your build.
   When you have a fully up to date build and you clean and re-run the code generator task on the same code base it should generate _exactly the same output_, so anything that depends on that output will stay up-to-date.
   
   It might also be that your code generator adds some extra information to its output that doesn't depend on its declared inputs, like a timestamp.
   In such a case re-executing the task _will_ result in different code being generated (because the timestamp will be updated).
   Tasks that depend on the code generator's output will need to be re-executed.
   
   When a task is cacheable, then the very nature of task output caching makes sure that the task will have the same outputs for a given set of inputs.
   Therefore, cacheable tasks should have repeatable task outputs.
   If they don't, then the result of executing the task and loading the task from the cache may be different, which can lead to hard-to-diagnose cache misses.
   
   In some cases even well-trusted tools can produce non-repeatable outputs, and lead to cascading effects.
   One example is Oracle's Java compiler, which, https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8067422[due to a bug], was producing different bytecode depending on the order source files to be compiled were presented to it.
   If you were using Oracle JDK 8u31 or earlier to compile code in the `buildSrc` subproject, this could lead to all of your custom tasks producing occasional cache misses, because of the difference in their classpaths (which include `buildSrc`).
   
   The key here is that cacheable tasks should not use non-repeatable task outputs as an input.
   
   == Stable task inputs
   
   Having a task repeatably produce the same output is not enough if its inputs keep changing all the time.
   Such unstable inputs can be supplied directly to the task. Consider a version number that includes a timestamp being added to the jar file's manifest:
   
   ====
   include::sample[dir="snippets/buildCache/timestamp-in-manifest/kotlin",files="build.gradle.kts[tags=timestamp]"]
   include::sample[dir="snippets/buildCache/timestamp-in-manifest/groovy",files="build.gradle[tags=timestamp]"]
   ====
   
   In the above example the inputs for the `jar` task will be different for each build execution since this timestamp will continually change.
   
   Another example for unstable inputs is the commit ID from version control.
   Maybe your version number is generated via `git describe` (and you include it in the jar manifest as shown above).
   Or maybe you include the commit hash directly in `version.properties` or a jar manifest attribute.
   Either way, the outputs produced by any tasks depending on such data will only be re-usable by builds running against the exact same commit.
   
   Another common, but less obvious source of unstable inputs is when a task consumes the output of another task which produces non-repeatable results, such as the example before of a code generator that embeds timestamps in its output.
   
   A task can only be loaded from the cache if it has stable task inputs.
   Unstable task inputs result in the task having a unique set of inputs for every build, which will always result in a cache miss.
   
   == Better reuse via input normalization
   
   Having stable inputs is crucial for cacheable tasks.
   However, achieving byte for byte identical inputs for each task can be challenging.
   In some cases sanitizing the output of a task to remove unnecessary information can be a good approach, but this also means that a task's output can only be normalized for a single purpose.
   
   This is where <<incremental_build.adoc#sec:configure_input_normalization,input normalization>> comes into play.
   Input normalization is used by Gradle to determine if two task inputs are _essentially_ the same.
   Gradle uses normalized inputs when doing up-to-date checks and when determining if a cached result can be re-used instead of executing the task.
   As input normalization is declared by the task _consuming_ the data as input, different tasks can define different ways to normalize the same data.
   
   When it comes to file inputs, Gradle can normalize the path of the files as well as their contents.
   
   === Path sensitivity and relocatability
   
   When sharing cached results between computers, it's rare that everyone runs the build from the exact same location on their computers.
   To allow cached results to be shared even when builds are executed from different root directories, Gradle needs to understand which inputs can be relocated and which cannot.
   
   Tasks having files as inputs can declare the parts of a file's path what are essential to them: this is called the link:{javadocPath}#[_path sensitivity_] of the input.
   Task properties declared with `ABSOLUTE` path sensitivity are considered non-relocatable.
   This is the default for properties not declaring path sensitivity, too.
   
   For example, the class files produced by the Java compiler are dependent on the file names of the Java source files: renaming the source files with public classes in them would fail the build.
   Though moving the files around wouldn't have an effect on the result of the compilation, for incremental compilation the `JavaCompile` task relies on the relative path to find other classes in the same package.
   Therefore, the path sensitivity for the sources of the `JavaCompile` task is `RELATIVE`.
   Because of this only the normalized (relative) paths of the Java source files are considered as inputs to the `JavaCompile` task.
   
   NOTE: The Java compiler only respects the package declaration in the Java source files, not the relative path of the sources.
   As a consequence, path sensitivity for Java sources is `NAME_ONLY` and not `RELATIVE`.
   
   === Content normalization
   
   ==== Compile avoidance for Java
   
   When it comes to the dependencies of a `JavaCompile` task (i.e. its _compile classpath),_ only changes to the Application Binary Interface (ABI) of these dependencies require compilation to be executed.
   Gradle has a deep understanding of what a compile classpath is and uses a sophisticated normalization strategy for it.
   Task outputs can be re-used as long as the ABI of the classes on the compile classpath stays the same.
   This enables Gradle to avoid Java compilation by using incremental builds, or load results from the cache that were produced by different (but ABI-compatible) versions of dependencies.
   For more information on compile avoidance see the <<java_plugin.adoc#sec:java_compile_avoidance,corresponding section>>.
   
   ==== Runtime classpath normalization
   
   Similar to compile avoidance, Gradle also understands the concept of a runtime classpath, and uses tailored input normalization to avoid running e.g. tests.
   For runtime classpaths Gradle inspects the contents of jar files and ignores the timestamps and order of the entries in the jar file.
   This means that a rebuilt jar file would be considered the same runtime classpath input.
   For details on what level of understanding Gradle has for detecting changes to classpaths and what is considered as a classpath see <<incremental_build.adoc#sec:task_input_using_classpath_annotations,this section>>.
   
   ===== Filtering runtime classpaths
   
   For a runtime classpath it is possible to provide better insights to Gradle which files are essential to the input by <<incremental_build.adoc#sec:configure_input_normalization,configuring input normalization>>.
   
   Given that you want to add a file `build-info.properties` to all your produced jar files which contains volatile information about the build, e.g. the timestamp when the build started or some ID to identify the CI job that published the artifact.
   This file is only used for auditing purposes, and has no effect on the outcome of running tests.
   Nonetheless, this file is part of the runtime classpath for the `test` task. Since the file changes on every build invocation, tests cannot be cached effectively.
   To fix this you can ignore `build-info.properties` on any runtime classpath by adding the following configuration to the build script in the _consuming_ project:
   
   ====
   include::sample[dir="snippets/buildCache/normalization/kotlin",files="build.gradle.kts[tags=normalization]"]
   include::sample[dir="snippets/buildCache/normalization/groovy",files="build.gradle[tags=normalization]"]
   ====
   
   If adding such a file to your jar files is something you do for all of the projects in your build, and you want to filter this file for all consumers, you may wrap the configurations described above in an `allprojects {}` or `subprojects {}` block in the root build script.
   
   The effect of this configuration would be that changes to `build-info.properties` would be ignored for both up-to-date checks and task output caching.
   All runtime classpath inputs for all tasks in the project where this configuration has been made will be affected.
   This will not change the runtime behavior of the `test` task -- i.e. any test is still able to load `build-info.properties`, and the runtime classpath stays the same as before.
   
   == The case against overlapping outputs
   
   When two tasks write to the same output directory or output file, it is difficult for Gradle to determine which output belongs to which task.
   There are many edge cases, and executing the tasks in parallel cannot be done safely.
   For the same reason, Gradle cannot remove <<incremental_build.adoc#sec:stale_task_outputs,stale output files>> for these tasks.
   Tasks that have discrete, non-overlapping outputs can always be handled in a safe fashion by Gradle.
   For the aforementioned reasons, task output caching is automatically disabled for tasks whose output directories overlap with another task.
   
   Build scans show tasks where caching was disabled due to overlapping outputs in the timeline:
   
   [.screenshot]
   image::build-cache/overlapping-outputs-timeline.png[]
   
   == Reuse of outputs between different tasks
   
   Some builds exhibit a surprising characteristic: even when executed against an empty cache, they produce tasks loaded from cache. How is this possible? Rest assured that this is completely normal.
   
   When considering task outputs, Gradle only cares about the inputs to the task: the task type itself, input files and parameters etc., but it doesn't care about the task's name or which project it can be found in.
   Running `javac` will produce the same output regardless of the name of the `JavaCompile` task that invoked it.
   If your build includes two tasks that share every input, the one executing later will be able to reuse the output produced by the first.
   
   Having two tasks in the same build that do the same might sound like a problem to fix, but it is not necessarily something bad.
   For example, the Android plugin creates several tasks for each variant of the project; some of those tasks will potentially do the same thing.
   These tasks can safely reuse each other's outputs.
   
   As <<build_cache_use_cases.adoc#share_results_between_ci_builds,discussed previously>>, you can use Develocity to diagnose the source build of these unexpected cache-hits.
   
   == Non-cacheable tasks
   
   You've seen quite a bit about cacheable tasks, which implies there are non-cacheable ones, too. If caching task outputs is as awesome as it sounds, why not cache every task?
   
   There are tasks that are definitely worth caching: tasks that do complex, repeatable processing and produce moderate amounts of output. Compilation tasks are usually ideal candidates for caching.
   At the other end of the spectrum lie I/O-heavy tasks, like `Copy` and `Sync`. Moving files around locally typically cannot be sped up by copying them from a cache.
   Caching those tasks would even waste good resources by storing all those redundant results in the cache.
   
   Most tasks are either obviously worth caching, or obviously not. For those in-between a good rule of thumb is to see if downloading results would be significantly faster than producing them locally.

/docs/userguide/optimizing-performance/build-cache/caching_java_projects.adoc
=============================================================================

.. code-block::

   = Caching Java projects
   
   As of Gradle 4.0, the build tool fully supports caching plain Java projects.
   Built-in tasks for compiling, testing, documenting and checking the quality of Java code support the build cache out of the box.
   
   == Java compilation
   
   Caching Java compilation makes use of Gradle's deep understanding of compile classpaths.
   The mechanism <<build_cache_concepts.adoc#compile_avoidance,avoids recompilation>> when dependencies change in a way that doesn't affect their application binary interfaces (ABI).
   Since the cache key is only influenced by the ABI of dependencies (and not by their implementation details like private types and method bodies), task output caching can also reuse compiled classes if they were produced by the same sources and ABI-equivalent dependencies.
   
   For example, take a project with two modules: an application depending on a library.
   Suppose the latest version is already built by CI and uploaded to the shared cache.
   If a developer now modifies a method's body in the library, the library will need to be rebuilt on their computer. But they will be able to load the compiled classes for the application from the shared cache. Gradle can do this because the library used to compile the application on CI, and the modified library available locally share the same ABI.
   
   === Annotation processors
   
   Compile avoidance works out of the box.
   There is one caveat though: when using annotation processors, Gradle uses the annotation processor classpath as an input.
   Unlike most compile dependencies, in which only the ABI influences compilation, the _implementation_ of annotation processors must be considered as an input to the compiler. For this reason Gradle will treat annotation processors as a _runtime_ classpath, meaning less <<build_cache_concepts.adoc#runtime_classpath,input normalization>> is taking place there.
   If Gradle detects an annotation processor on the compile classpath, the annotation processor classpath defaults to the compile classpath when not explicitly set, which in turn means the entire compile classpath is treated as a runtime classpath input.
   
   For the example above this would mean the ABI extracted from the compile classpath would be unchanged, but the annotation processor classpath (because it's not treated with compile avoidance) would be different. Ultimately, the developer would end up having to recompile the application.
   
   The easiest way to avoid this performance penalty is to not use annotation processors.
   However, if you need to use them, make sure you set the annotation processor classpath explicitly to include only the libraries needed for annotation processing.
   The <<java_plugin.adoc#sec:java_compile_avoidance,section on Java compile avoidance>> describes how to do this.
   
   [NOTE]
   ====
   Some common Java dependencies (such as Log4j 2.x) come bundled with annotation processors.
   If you use these dependencies, but do not leverage the features of the bundled annotation processors, it's best to disable annotation processing entirely.
   This can be done by setting the annotation processor classpath to an empty set.
   ====
   
   == Unit test execution
   
   The `Test` task used for test execution for JVM languages employs <<build_cache_concepts.adoc#runtime_classpath,runtime classpath normalization>> for its classpath.
   This means that changes to order and timestamps in jars on the test classpath will not cause the task to be out-of-date or change the build cache key.
   For achieving <<build_cache_concepts.adoc#stable_task_inputs,stable task inputs>> you can also wield the power of <<build_cache_concepts.adoc#filter_runtime_classpath,filtering the runtime classpath>>.
   
   == Integration test execution
   
   Unit tests are easy to cache as they normally have no external dependencies.
   For integration tests the situation can be quite different, as they can depend on a variety of inputs outside of the test and production code.
   These external factors can be for example:
   
     * operating system type and version,
     * external tools being installed for the tests,
     * environment variables and Java system properties,
     * other services being up and running,
     * a distribution of the software under test.
   
   You need to be careful to declare these additional inputs for your integration test in order to avoid incorrect cache hits.
   For example, declaring the operating system in use by Gradle as an input to a `Test` task called `integTest` would work as follows:
   
   ====
   include::sample[dir="snippets/buildCache/integration-tests/kotlin",files="build.gradle.kts[tags=integTest]"]
   include::sample[dir="snippets/buildCache/integration-tests/groovy",files="build.gradle[tags=integTest]"]
   ====
   
   === Archives as inputs
   
   It is common for the integration tests to depend on your packaged application.
   If this happens to be a zip or tar archive, then adding it as an input to the integration test task may lead to cache misses.
   This is because, as described in <<build_cache_concepts.adoc#concepts_repeatable_task_outputs,repeatable task outputs>>, rebuilding an archive often changes the metadata in the archive.
   You can depend on the exploded contents of the archive instead.
   See also the section on dealing with <<common_caching_problems.adoc#volatile_outputs,non-repeatable outputs>>.
   
   === Dealing with file paths
   
   You will probably pass some information from the build environment to your integration test tasks by using system properties.
   Passing absolute paths will break <<build_cache_concepts.adoc#relocatability,relocatability>> of the integration test task.
   
   ====
   include::sample[dir="snippets/buildCache/integration-tests/kotlin",files="build.gradle.kts[tags=distributionPathInput]"]
   include::sample[dir="snippets/buildCache/integration-tests/groovy",files="build.gradle[tags=distributionPathInput]"]
   ====
   
   Instead of adding the absolute path directly as a system property, it is possible to add an
   annotated link:{javadocPath}#[CommandLineArgumentProvider] to the `integTest` task:
   
   ====
   include::sample[dir="snippets/buildCache/integration-tests/kotlin",files="build.gradle.kts[tags=distributionDirInput]"]
   include::sample[dir="snippets/buildCache/integration-tests/groovy",files="build.gradle[tags=distributionDirInput]"]
   ====
   <1> Create a class implementing link:{javadocPath}#[`CommandLineArgumentProvider`].
   <2> Declare the inputs and outputs with the corresponding path sensitivity.
   <3> `asArguments` needs to return the JVM arguments passing the desired system properties to the test JVM.
   <4> Add an instance of the newly created class as JVM argument provider to the integration test task.footnote:managedTypes[The `CommandLineArgumentProvider` in this example is implemented as a <<custom_gradle_types.adoc#custom_gradle_types,managed type>>.]
   
   === Ignoring system properties
   
   It may be necessary to ignore some system properties as inputs as they do not influence the outcome of the integration tests.
   In order to do so, add a link:{javadocPath}#[CommandLineArgumentProvider] to the `integTest` task:
   
   ====
   include::sample[dir="snippets/buildCache/integration-tests/kotlin",files="build.gradle.kts[tags=ignoreSystemProperties]"]
   include::sample[dir="snippets/buildCache/integration-tests/groovy",files="build.gradle[tags=ignoreSystemProperties]"]
   ====
   <1> `@Internal` means that this property does not influence the output of the integration tests.
   <2> The system properties for the actual test execution.
   <3> Add an instance of the newly created class as JVM argument provider to the integration test task.footnote:managedTypes[]

/docs/userguide/optimizing-performance/build-cache/caching_android_projects.adoc
================================================================================

.. code-block::

   = Caching Android projects
   
   While it is true that Android uses the Java toolchain as its foundation, there are nevertheless some significant differences from pure Java projects; these differences impact task cacheability.
   This is even more true for Android projects that include Kotlin source code (and therefore use the `kotlin-android` plugin).
   
   == Disambiguation
   
   This guide is about Gradle뗩 build cache, but you may have also heard about the https://developer.android.com/studio/build/build-cache[Android build cache].
   These are different things.
   The Android cache is internal to certain tasks in the Android plugin, and will eventually be removed in favor of native Gradle support.
   
   == Why use the build cache?
   
   The build cache can _significantly_ improve build performance for Android projects, in many cases by 30-40%.
   Many of the compilation and assembly tasks provided by the Android Gradle Plugin are cacheable, and more are made so with each new iteration.
   
   === Faster CI builds
   
   CI builds benefit particularly from the build cache.
   A typical CI build starts with a `clean`, which means that pre-existing build outputs are deleted and none of the tasks that make up the build will be `UP-TO-DATE`.
   However, it is likely that many of those tasks will have been run with exactly the same inputs in a prior CI build, populating the build cache; the outputs from those prior runs can safely be reused, resulting in dramatic build performance improvements.
   
   === Reusing CI builds for local development
   
   When you sign into work at the start of your day, it뗩 not unusual for your first task to be pulling the main branch and then running a build (Android Studio will probably do the latter, whether you ask it to or not).
   Assuming all merges to main are built on CI (a best practice!), you can expect this first local build of the day to enjoy a larger-than-typical benefit with Gradle뗩 _remote cache_.
   CI already built this commit -- why should you re-do that work?
   
   === Switching branches
   
   During local development, it is not uncommon to switch branches several times per day.
   This defeats <<incremental_build.adoc#incremental_build,incremental build>> (i.e., `UP-TO-DATE` checks), but this issue is mitigated via use of the local build cache.
   You might run a build on Branch A, which will populate the local cache.
   You then switch to Branch B to conduct a code review, help a colleague, or address feedback on an open PR.
   You then switch back to Branch A to continue your original work.
   When you next build, all of the outputs previously built while working on Branch A can be reused from the cache, saving potentially a lot of time.
   
   == The Android Gradle Plugin and the Gradle Build Tool
   
   The first thing you should always do when working to optimize your build is ensure youre on the latest stable, supported versions of the Android Gradle Plugin and the Gradle Build Tool.
   At the time of writing, they are 3.3.0 and 5.0, respectively.
   Each new version of these tools includes many performance improvements, not least of which is to the build cache.
   
   == Java and Kotlin compilation
   
   The <<caching_java_projects.adoc#java_compilation,discussion>> above in Caching Java projects is equally relevant here, with the caveat that, for projects that include Kotlin source code, the Kotlin compiler does not currently support <<java_plugin.adoc#sec:java_compile_avoidance,compile avoidance>> in the way that the Java compiler does.
   
   == Annotation processors and Kotlin
   
   The <<caching_java_projects.adoc#annotation_processors,advice above>> for pure Java projects also applies to Android projects.
   However, if you are using annotation processors (such as Dagger2 or Butterknife) in conjunction with Kotlin and the kotlin-kapt plugin, you should know that before Kotlin 1.3.30 kapt https://youtrack.jetbrains.com/issue/KT-27675[was not cached by default].
   
   https://blog.jetbrains.com/kotlin/2018/01/kotlin-1-2-20-is-out/[You can opt into it] (which is recommended) by adding the following to build scripts:
   
   ====
   include::sample[dir="snippets/buildCache/caching-android-projects/kotlin",files="build.gradle.kts[tags=cacheKapt]"]
   include::sample[dir="snippets/buildCache/caching-android-projects/groovy",files="build.gradle[tags=cacheKapt]"]
   ====
   
   == Unit test execution
   
   Unlike with unit tests in a pure Java project, the equivalent test task in an Android project (`AndroidUnitTest`) is not cacheable.
   The Google Team is working to make these tests cacheable.
   Please see https://issuetracker.google.com/issues/79122161[this issue].
   
   == Instrumented test execution (i.e., Espresso tests)
   
   Android instrumented tests (`DeviceProviderInstrumentTestTask`), often referred to as Espresso tests, are also not cacheable.
   The Google Android team is also working to make such tests cacheable.
   Please see https://issuetracker.google.com/issues/115873051[this issue].
   
   == Lint
   
   Users of Android뗩 `Lint` task are well aware of the heavy performance penalty they pay for using it, but also know that it is indispensable for finding common issues in Android projects.
   Currently, this task is not cacheable.
   This task is planned to be cacheable with the release of Android Gradle Plugin 3.5.
   This is another reason to always use the latest version of the Android plugin!
   
   == The Fabric Plugin and Crashlytics
   
   The https://docs.fabric.io/android/fabric/overview.html[Fabric] plugin, which is used to integrate the Crashlytics crash-reporting tool (among others), is very popular, yet imposes some hefty performance penalties during the build process.
   This is due to the need for each version of your app to have a unique identifier so that it can be identified in the Crashlytics dashboard.
   In practice, the default behavior of Crashlytics is to treat 란ach version as synonymous with 란ach build.
   This defeats <<incremental_build.adoc#incremental_build,incremental build>>, because each build will be unique.
   It also breaks the cacheability of certain tasks in the build, and for the same reason.
   This can be fixed by simply disabling Crashlytics in 띿ebug builds.
   You may find instructions for that in the https://docs.fabric.io/android/crashlytics/build-tools.html[Crashlytics documentation].
   
   NOTE: The fix described in the referenced documentation does not work directly if you are using the Kotlin DSL; see below for the workaround.
   
   === Kotlin DSL
   
   The fix described in the referenced documentation does not work directly if you are using the Kotlin DSL; this is due to incompatibilities between that Kotlin DSL and the Fabric plugin.
   There is a simple workaround for this, based on <<kotlin_dsl.adoc#using_a_groovy_script,this advice>> from the Kotlin DSL primer.
   
   Create a file, `fabric.gradle`, in the module where you apply the `io.fabric` plugin. This file (known as a script plugin), should have the following contents:
   
   .fabric.gradle
   ----
   include::{snippetsPath}/buildCache/caching-android-projects/groovy/build.gradle[tags=fabricGroovy]
   ----
   
   And then, in the module뗩 `build.gradle.kts` file, apply this script plugin:
   
   .build.gradle.kts
   ----
   include::{snippetsPath}/buildCache/caching-android-projects/kotlin/build.gradle.kts[tags=fabricKotlin]
   ----

/docs/userguide/optimizing-performance/build-cache/build_cache_debugging.adoc
=============================================================================

.. code-block::

   = Debugging and diagnosing cache misses
   
   To make the most of task output caching, it is important that any necessary inputs to your tasks are specified correctly, while at the same time avoiding unneeded inputs.
   Failing to specify an input that affects the task's outputs can result in incorrect builds, while needlessly specifying inputs that do not affect the task's output can cause cache misses.
   
   This chapter is about finding out why a cache miss happened.
   If you have a cache hit which you didn't expect we suggest to declare whatever change you expected to trigger the cache miss as an input to the task.
   
   == Finding problems with task output caching
   
   Below we describe a step-by-step process that should help shake out any problems with caching in your build.
   
   === Ensure incremental build works
   
   First, make sure your build does the right thing without the cache.
   Run a build twice without enabling the Gradle build cache.
   The expected outcome is that all actionable tasks that produce file outputs are up-to-date.
   You should see something like this on the command-line:
   
   [listing]
   ----
   $ ./gradlew clean --quiet <1>
   $ ./gradlew assemble <2>
   
   BUILD SUCCESSFUL
   4 actionable tasks: 4 executed
   
   $ ./gradlew assemble <3>
   
   BUILD SUCCESSFUL
   4 actionable tasks: 4 up-to-date
   ----
   <1> Make sure we start without any leftover results by running `clean` first.
   <2> We are assuming your build is represented by running the `assemble` task in these examples, but you can substitute whatever tasks make sense for your build.
   <3> Run the build again without running `clean`.
   
   NOTE: Tasks that have no outputs or no inputs will always be executed, but that shouldn't be a problem.
   
   Use the methods as described below to <<#diagnosing_cache_miss,diagnose>> and <<common_caching_problems.adoc#common-problems,fix>> tasks that should be up-to-date but aren't.
   If you find a task which is out of date, but no cacheable tasks depends on its outcome, then you don't have to do anything about it.
   The goal is to achieve <<build_cache_concepts.adoc#stable_task_inputs,stable task inputs>> for cacheable tasks.
   
   === In-place caching with the local cache
   
   When you are happy with the up-to-date performance then you can repeat the experiment above, but this time with a clean build, and the build cache turned on.
   The goal with clean builds and the build cache turned on is to retrieve all cacheable tasks from the cache.
   
   WARNING: When running this test make sure that you have no `remote` cache configured, and storing in the `local` cache is enabled.
   These are the default settings.
   
   This would look something like this on the command-line:
   
   [listing]
   ----
   $ rm -rf ~/.gradle/caches/build-cache-1 <1>
   $ ./gradlew clean --quiet <2>
   $ ./gradlew assemble --build-cache <3>
   
   BUILD SUCCESSFUL
   4 actionable tasks: 4 executed
   
   $ ./gradlew clean --quiet <4>
   $ ./gradlew assemble --build-cache <5>
   
   BUILD SUCCESSFUL
   4 actionable tasks: 1 executed, 3 from cache
   ----
   <1> We want to start with an empty local cache.
   <2> Clean the project to remove any unwanted leftovers from previous builds.
   <3> Build it once to let it populate the cache.
   <4> Clean the project again.
   <5> Build it again: this time everything cacheable should load from the just populated cache.
   
   You should see all cacheable tasks loaded from cache, while non-cacheable tasks should be executed.
   
   [.screenshot]
   image::build-cache/fully-cached-task-execution.png[]
   
   Again, use the below methods to <<#diagnosing_cache_miss,diagnose>> and <<common_caching_problems.adoc#common-problems,fix>> cacheability issues.
   
   === Testing cache relocatability
   
   Once everything loads properly while building the same checkout with the local cache enabled, it's time to see if there are any _relocation problems._
   A task is considered _relocatable_ if its output can be reused when the task is executed in a different location.
   (More on this in <<build_cache_concepts.adoc#relocatability,path sensitivity and relocatability>>.)
   
   NOTE: Tasks that should be relocatable but aren't are usually a result of absolute paths being present among the task's inputs.
   
   To discover these problems, first check out the same commit of your project in two different directories on your machine.
   For the following example let's assume we have a checkout in `\~/checkout-1` and `\~/checkout-2`.
   
   WARNING: Like with the previous test, you should have no `remote` cache configured, and storing in the `local` cache should be enabled.
   
   [listing]
   ----
   $ rm -rf ~/.gradle/caches/build-cache-1 <1>
   $ cd ~/checkout-1 <2>
   $ ./gradlew clean --quiet <3>
   $ ./gradlew assemble --build-cache <4>
   
   BUILD SUCCESSFUL
   4 actionable tasks: 4 executed
   
   $ cd ~/checkout-2 <5>
   $ ./gradlew clean --quiet <6>
   $ ./gradlew clean assemble --build-cache <7>
   
   BUILD SUCCESSFUL
   4 actionable tasks: 1 executed, 3 from cache
   ----
   <1> Remove all entries in the local cache first.
   <2> Go to the first checkout directory.
   <3> Clean the project to remove any unwanted leftovers from previous builds.
   <4> Run a build to populate the cache.
   <5> Go to the other checkout directory.
   <6> Clean the project again.
   <7> Run a build again.
   
   You should see the exact same results as you saw with the previous <<#in-place_caching_test,in place caching test>> step.
   
   === Cross-platform tests
   
   If your build passes the <<#caching_relocation_test,relocation test>>, it is in good shape already.
   If your build requires support for multiple platforms, it is best to see if the required tasks get reused between platforms, too.
   A typical example of cross-platform builds is when CI runs on Linux VMs, while developers use macOS or Windows, or a different variety or version of Linux.
   
   To test cross-platform cache reuse, set up a `remote` cache (see <<build_cache_use_cases.adoc#share_results_between_ci_builds,share results between CI builds>>) and populate it from one platform and consume it from the other.
   
   === Incremental cache usage
   
   After these experiments with fully cached builds, you can go on and try to make typical changes to your project and see if enough tasks are still cached.
   If the results are not satisfactory, you can think about restructuring your project to reduce dependencies between different tasks.
   
   === Evaluating cache performance over time
   
   Consider recording execution times of your builds, generating graphs, and analyzing the results.
   Keep an eye out for certain patterns, like a build recompiling everything even though you expected compilation to be cached.
   
   You can also make changes to your code base manually or automatically and check that the expected set of tasks is cached.
   
   If you have tasks that are re-executing instead of loading their outputs from the cache, then it may point to a problem in your build.
   Techniques for debugging a cache miss are explained in the following section.
   
   == Helpful data for diagnosing a cache miss
   
   A cache miss happens when Gradle calculates a build cache key for a task which is different from any existing build cache key in the cache.
   Only comparing the build cache key on its own does not give much information, so we need to look at some finer grained data to be able to diagnose the cache miss.
   A list of all inputs to the computed build cache key can be found in the <<build_cache.adoc#sec:task_output_caching_details,section on cacheable tasks>>.
   
   From most coarse grained to most fine grained, the items we will use to compare two tasks are:
   
   * Build cache keys
   * Task and Task action implementations
   ** classloader hash
   ** class name
   * Task output property names
   * Individual task property input hashes
   * Hashes of files which are part of task input properties
   
   If you want information about the build cache key and individual input property hashes, use <<build_environment.adoc#sec:gradle_configuration_properties,`-Dorg.gradle.caching.debug=true`>>:
   
   [listing]
   ----
   $ ./gradlew :compileJava --build-cache -Dorg.gradle.caching.debug=true
   
   .
   .
   .
   Appending implementation to build cache key: org.gradle.api.tasks.compile.JavaCompile_Decorated@470c67ec713775576db4e818e7a4c75d
   Appending additional implementation to build cache key: org.gradle.api.tasks.compile.JavaCompile_Decorated@470c67ec713775576db4e818e7a4c75d
   Appending input value fingerprint for 'options' to build cache key: e4eaee32137a6a587e57eea660d7f85d
   Appending input value fingerprint for 'options.compilerArgs' to build cache key: 8222d82255460164427051d7537fa305
   Appending input value fingerprint for 'options.debug' to build cache key: f6d7ed39fe24031e22d54f3fe65b901c
   Appending input value fingerprint for 'options.debugOptions' to build cache key: a91a8430ae47b11a17f6318b53f5ce9c
   Appending input value fingerprint for 'options.debugOptions.debugLevel' to build cache key: f6bd6b3389b872033d462029172c8612
   Appending input value fingerprint for 'options.encoding' to build cache key: f6bd6b3389b872033d462029172c8612
   .
   .
   .
   Appending input file fingerprints for 'options.sourcepath' to build cache key: 5fd1e7396e8de4cb5c23dc6aadd7787a - RELATIVE_PATH{EMPTY}
   Appending input file fingerprints for 'stableSources' to build cache key: f305ada95aeae858c233f46fc1ec4d01 - RELATIVE_PATH{.../src/main/java=IGNORED / DIR, .../src/main/java/Hello.java='Hello.java' / 9c306ba203d618dfbe1be83354ec211d}
   Appending output property name to build cache key: destinationDir
   Appending output property name to build cache key: options.annotationProcessorGeneratedSourcesDirectory
   Build cache key for task ':compileJava' is 8ebf682168823f662b9be34d27afdf77
   ----
   
   The log shows e.g. which source files constitute the `stableSources` for the `compileJava` task.
   To find the actual differences between two builds you need to resort to matching up and comparing those hashes yourself.
   
   TIP: link:https://docs.gradle.com/enterprise/tutorials/task-inputs-comparison/[Develocity] already takes care of this for you; it lets you quickly diagnose a cache miss with the Build Scan(TM) Comparison tool.
   
   == Diagnosing the reasons for a cache miss
   
   Having the data from the last section at hand, you should be able to diagnose why the outputs of a certain task were not found in the build cache.
   Since you were expecting more tasks to be cached, you should be able to pinpoint a build which would have produced the artifact under question.
   
   Before diving into how to find out why one task has not been loaded from the cache we should first look into which task caused the cache misses.
   There is a cascade effect which causes dependent tasks to be executed if one of the tasks earlier in the build is not loaded from the cache and has different outputs.
   Therefore, you should locate the first cacheable task which was executed and continue investigating from there.
   This can be done from the timeline view in a Build Scan(TM):
   
   [.screenshot]
   image::build-cache/first-non-cached-task.png[]
   
   At first, you should check if the implementation of the task changed. This would mean checking the class names and classloader hashes
   for the task class itself and for each of its actions. If there is a change, this means that the build script, `buildSrc` or the Gradle version has changed.
   
   [NOTE]
   ====
   A change in the output of `buildSrc` also marks all the logic added by your build as changed.
   Especially, custom actions added to cacheable tasks will be marked as changed.
   This can be problematic, see <<common_caching_problems.adoc#custom_actions, section about `doFirst` and `doLast`>>.
   ====
   
   If the implementation is the same, then you need to start comparing inputs between the two builds.
   There should be at least one different input hash. If it is a simple value property, then the configuration of the task changed.
   This can happen for example by
   
    * changing the build script,
    * conditionally configuring the task differently for CI or the developer builds,
    * depending on a system property or an environment variable for the task configuration,
    * or having an absolute path which is part of the input.
   
   If the changed property is a file property, then the reasons can be the same as for the change of a value property.
   Most probably though a file on the filesystem changed in a way that Gradle detects a difference for this input.
   The most common case will be that the source code was changed by a check in.
   It is also possible that a file generated by a task changed, e.g. since it includes a timestamp.
   As described in <<common_caching_problems.adoc#java_version_tracking,Java version tracking>>, the Java version can also influence the output of the Java compiler.
   If you did not expect the file to be an input to the task, then it is possible that you should alter the configuration of the task to not include it.
   For example, having your integration test configuration including all the unit test classes as a dependency has the effect that all integration tests
   are re-executed when a unit test changes.
   Another option is that the task tracks absolute paths instead of relative paths and the location of the project directory changed on disk.
   
   == Example
   
   We will walk you through the process of diagnosing a cache miss.
   Let's say we have build `A` and build `B` and we expected all the test tasks for a sub-project `sub1` to be cached in build `B` since only a unit test for another sub-project `sub2` changed.
   Instead, all the tests for the sub-project have been executed.
   Since we have the cascading effect when we have cache misses, we need to find the task which caused the caching chain to fail.
   This can easily be done by filtering for all cacheable tasks which have been executed and then select the first one.
   In our case, it turns out that the tests for the sub-project `internal-testing` were executed even though there was no code change to this project.
   This means that the property `classpath` changed and some file on the runtime classpath actually did change.
   Looking deeper into this, we actually see that the inputs for the task `processResources` changed in that project, too.
   Finally, we find this in our build file:
   
   ====
   include::sample[dir="snippets/buildCache/normalization/kotlin",files="build.gradle.kts[tags=versionInfo]"]
   include::sample[dir="snippets/buildCache/normalization/groovy",files="build.gradle[tags=versionInfo]"]
   ====
   
   Since properties files stored by Java's `Properties.store` method contain a timestamp, this will cause a change to the runtime classpath every time the build runs.
   In order to solve this problem see <<common_caching_problems.adoc#volatile_outputs,non-repeatable task outputs>> or use <<build_cache_concepts.adoc#normalization,input normalization>>.
   
   NOTE: The compile classpath is not affected since compile avoidance ignores non-class files on the classpath.

/docs/userguide/optimizing-performance/build-cache/common_caching_problems.adoc
===============================================================================

.. code-block::

   = Solving common problems
   
   Small problems in a build, like forgetting to declare a configuration file as an input to your task, can be easily overlooked.
   The configuration file might change infrequently, or only change when some other (correctly tracked) input changes as well.
   The worst that could happen is that your task doesn't execute when it should.
   Developers can always re-run the build with `clean`, and "fix" their builds for the price of a slow rebuild.
   In the end nobody gets blocked in their work, and the incident is chalked up to "Gradle acting up again."
   
   With cacheable tasks incorrect results are stored permanently, and can come back to haunt you later; re-running with `clean` won't help in this situation either. When using a shared cache, these problems even cross machine boundaries. In the example above, Gradle might end up loading a result for your task that was produced with a different configuration. Resolving these problems with the build therefore becomes even more important when task output caching is enabled.
   
   Other issues with the build won't cause it to produce incorrect results, but will lead to unnecessary cache misses.
   In this chapter you will learn about some typical problems and ways to avoid them.
   Fixing these issues will have the added benefit that your build will stop "acting up," and developers can forget about running builds with `clean` altogether.
   
   == System file encoding
   
   Most Java tools use the system file encoding when no specific encoding is specified.
   This means that running the same build on machines with different file encoding can yield different outputs.
   Currently Gradle only tracks on a per-task basis that no file encoding has been specified, but it does not track the system encoding of the JVM in use.
   This can cause incorrect builds. You should always set the file system encoding to avoid these kind of problems.
   
   NOTE: Build scripts are compiled with the file encoding of the Gradle daemon.
   By default, the daemon uses the system file encoding, too.
   
   Setting the file encoding for the Gradle daemon mitigates both above problems by making sure that the encoding is the same across builds.
   You can do so in your `gradle.properties`:
   
   [source,properties]
   .gradle.properties
   ----
   org.gradle.jvmargs=-Dfile.encoding=UTF-8
   ----
   
   == Environment variable tracking
   
   Gradle does not track changes in environment variables for tasks.
   For example for `Test` tasks it is completely possible that the outcome depends on a few environment variables.
   To ensure that only the right artifacts are re-used between builds, you need to add environment variables as inputs to tasks depending on them.
   
   Absolute paths are often passed as environment variables, too.
   You need to pay attention what you add as an input to the task in this case.
   You would need to ensure that the absolute path is the same between machines. Most times it makes sense to track the file or the contents of the directory the absolute path points to.
   If the absolute path represents a tool being used it probably makes sense to track the tool version as an input instead.
   
   For example, if you are using tools in your `Test` task called `integTest` which depend on the contents of the `LANG` variable you should do this:
   
   ====
   include::sample[dir="snippets/buildCache/integration-tests/kotlin",files="build.gradle.kts[tags=environment]"]
   include::sample[dir="snippets/buildCache/integration-tests/groovy",files="build.gradle[tags=environment]"]
   ====
   
   If you add conditional logic to distinguish CI builds from local development builds, you have to ensure that this does not break the loading of task outputs from CI onto developer machines.
   For example, the following setup would break caching of `Test` tasks, since Gradle always detects the differences in custom task actions.
   
   ====
   include::sample[dir="snippets/buildCache/conditional-action/kotlin",files="build.gradle.kts[tags=conditionalAction]"]
   include::sample[dir="snippets/buildCache/conditional-action/groovy",files="build.gradle[tags=conditionalAction]"]
   ====
   
   You should always add the action unconditionally:
   
   ====
   include::sample[dir="snippets/buildCache/conditional-action/kotlin",files="build.gradle.kts[tags=unconditionalAction]"]
   include::sample[dir="snippets/buildCache/conditional-action/groovy",files="build.gradle[tags=unconditionalAction]"]
   ====
   
   This way, the task has the same custom action on CI and on developer builds and its outputs can be re-used if the remaining inputs are the same.
   
   == Line endings
   
   If you are building on different operating systems be aware that some version control systems convert line endings on check-out.
   For example, Git on Windows uses `autocrlf=true` by default which converts all line endings to `\r\n`.
   As a consequence, compilation outputs can't be re-used on Windows since the input sources are different.
   If sharing the build cache across multiple operating systems is important in your environment, then setting `autocrlf=false` across your build machines is crucial for optimal build cache usage.
   
   == Symbolic links
   
   When using symbolic links, Gradle does not store the link in the build cache but the actual file contents of the destination of the link.
   As a consequence you might have a hard time when trying to reuse outputs which heavily use symbolic links.
   There currently is no workaround for this behavior.
   
   For operating systems supporting symbolic links, the content of the destination of the symbolic link will be added as an input.
   If the operating system does not support symbolic links, the actual symbolic link file is added as an input.
   Therefore, tasks which have symbolic links as input files, e.g. `Test` tasks having symbolic link as part of its runtime classpath, will not be cached between Windows and Linux.
   If caching between operating systems is desired, symbolic links should not be checked into version control.
   
   == Java version tracking
   
   Gradle tracks only the major version of Java as an input for compilation and test execution.
   Currently, it does _not_ track the vendor nor the minor version.
   Still, the vendor and the minor version may influence the bytecode produced by compilation.
   
   NOTE: If you're using <<toolchains.adoc#toolchains,Java Toolchains>>, the Java major version, the vendor (if specified) and implementation (if specified) will be tracked automatically as an input for compilation and test execution.
   
   If you use different JVM vendors for compiling or running Java we strongly suggest that you add the vendor as an input to the corresponding tasks.
   This can be achieved by using the <<incremental_build.adoc#sec:task_input_output_runtime_api,runtime API>> as shown in the following snippet.
   
   ====
   include::sample[dir="snippets/buildCache/java-version-tracking/kotlin",files="build.gradle.kts[tags=trackVendor]"]
   include::sample[dir="snippets/buildCache/java-version-tracking/groovy",files="build.gradle[tags=trackVendor]"]
   ====
   
   With respect to tracking the Java minor version there are different competing aspects: developers having cache hits and "perfect" results on CI.
   There are basically two situations when you may want to track the minor version of Java: for compilation and for runtime.
   In the case of compilation, there can sometimes be differences in the produced bytecode for different minor versions.
   However, the bytecode should still result in the same runtime behavior.
   
   NOTE: <<java_plugin.adoc#sec:java_compile_avoidance,Java compile avoidance>> will treat this bytecode the same since it extracts the ABI.
   
   Treating the minor number as an input can decrease the likelihood of a cache hit for developer builds.
   Depending on how standard development environments are across your team, it's common for many different Java minor version to be in use.
   
   Even without tracking the Java minor version you may have cache misses for developers due to some locally compiled class files which constitute an input to test execution.
   If these outputs made it into the local build cache on this developers machine even a clean will not solve the situation.
   Therefore, the choice for tracking the Java minor version is between sometimes or never re-using outputs between different Java minor versions for test execution.
   
   NOTE: The compiler infrastructure provided by the JVM used to run Gradle is also used by the Groovy compiler.
   Therefore, you can expect differences in the bytecode of compiled Groovy classes for the same reasons as above and the same suggestions apply.
   
   == Avoid changing inputs external to your build
   
   If your build is dependent on external dependencies like binary artifacts or dynamic data from a web page you need to make sure that these inputs are consistent throughout your infrastructure.
   Any variations across machines will result in cache misses.
   
   Never re-release a non-changing binary dependency with the same version number but different contents: if this happens with a plugin dependency, you will never be able to explain why you don뗪 see cache reuse between machines (it뗩 because they have different versions of that artifact).
   
   Using ``SNAPSHOT``s or other changing dependencies in your build by design violates the <<build_cache_concepts.adoc#stable_task_inputs,stable task inputs>> principle.
   To use the build cache effectively, you should depend on fixed dependencies.
   You may want to look into <<dependency_locking.adoc#dependency-locking,dependency locking>> or switch to using <<composite_builds.adoc#composite_builds,composite builds>> instead.
   
   The same is true for depending on volatile external resources, for example a list of released versions.
   One way of locking the changes would be to check the volatile resource into source control whenever it changes so that the builds only depend on the state in source control and not on the volatile resource itself.
   
   == Suggestions for authoring your build
   
   === Review usages of `doFirst` and `doLast`
   
   Using `doFirst` and `doLast` from a build script on a cacheable task ties you to build script changes since the implementation of the closure comes from the build script.
   If possible, you should use separate tasks instead.
   
   Modifying input or output properties via the runtime API in `doFirst` is discouraged since these changes will not be detected for up-to-date checks and the build cache.
   Even worse, when the task does not execute, then the configuration of the task is actually different from when it executes.
   Instead of using `doFirst` for modifying the inputs consider using a separate task to configure the task under question - a so called configure task.
   E.g., instead of doing
   
   ====
   include::sample[dir="snippets/buildCache/custom-action/kotlin",files="build.gradle.kts[tags=customAction]"]
   include::sample[dir="snippets/buildCache/custom-action/groovy",files="build.gradle[tags=customAction]"]
   ====
   
   do
   
   ====
   include::sample[dir="snippets/buildCache/configure-task/kotlin",files="build.gradle.kts[tags=configureTask]"]
   include::sample[dir="snippets/buildCache/configure-task/groovy",files="build.gradle[tags=configureTask]"]
   ====
   
   WARNING: Note that configuring a task from other task is not supported when using the <<configuration_cache.adoc#config_cache:requirements:task_access,configuration cache>>.
   
   === Build logic based on the outcome of a task
   
   Do not base build logic on whether a task has been _executed_.
   In particular you should not assume that the output of a task can only change if it actually executed.
   Actually, loading the outputs from the build cache would also change them.
   Instead of relying on custom logic to deal with changes to input or output files you should leverage Gradle's built-in support by declaring the correct inputs and outputs for your tasks and leave it to Gradle to decide if the task actions should be executed.
   For the very same reason using `outputs.upToDateWhen` is discouraged and should be replaced by properly declaring the task's inputs.
   
   === Overlapping outputs
   
   You already saw that <<build_cache_concepts.adoc#concepts_overlapping_outputs,overlapping outputs are a problem for task output caching>>.
   When you add new tasks to your build or re-configure built-in tasks make sure you do not create overlapping outputs for cacheable tasks.
   If you must you can add a `Sync` task which then would sync the merged outputs into the target directory while the original tasks remain cacheable.
   
   Develocity will show tasks where caching was disabled for overlapping outputs in the timeline and in the task input comparison:
   
   [.screenshot]
   image::build-cache/overlapping-outputs-input-comparison.png[]
   
   == Achieving stable task inputs
   
   It is crucial to have <<build_cache_concepts.adoc#stable_task_inputs,stable task inputs>> for every cacheable task.
   In the following section you will learn about different situations which violate stable task inputs and look at possible solutions.
   
   === Volatile task inputs
   
   If you use a volatile input like a timestamp as an input property for a task, then there is nothing Gradle can do to make the task cacheable.
   You should really think hard if the volatile data is really essential to the output or if it is only there for e.g. auditing purposes.
   
   If the volatile input is essential to the output then you can try to make the task using the volatile input cheaper to execute.
   You can do this by splitting the task into two tasks - the first task doing the expensive work which is cacheable and the second task adding the volatile data to the output.
   In this way the output stays the same and the build cache can be used to avoid doing the expensive work.
   For example, for building a jar file the expensive part - Java compilation - is already a different task while the jar task itself, which is not cacheable, is cheap.
   
   If it is not an essential part of the output, then you should not declare it as an input.
   As long as the volatile input does not influence the output then there is nothing else to do.
   Most times though, the input will be part of the output.
   
   === Non-repeatable task outputs
   
   Having tasks which generate different outputs for the same inputs can pose a challenge for the effective use of task output caching as seen in <<build_cache_concepts.adoc#concepts_repeatable_task_outputs,repeatable task outputs>>.
   If the non-repeatable task output is not used by any other task then the effect is very limited.
   It basically means that loading the task from the cache might produce a different result than executing the same task locally.
   If the only difference between the outputs is a timestamp, then you can either accept the effect of the build cache or decide that the task is not cacheable after all.
   
   Non-repeatable task outputs lead to non-stable task inputs as soon as another task depends on the non-repeatable output.
   For example, re-creating a jar file from the files with the same contents but different modification times yields a different jar file.
   Any other task depending on this jar file as an input file cannot be loaded from the cache when the jar file is rebuilt locally.
   This can lead to hard-to-diagnose cache misses when the consuming build is not a clean build or when a cacheable task depends on the output of a non-cacheable task.
   For example, when doing incremental builds it is possible that the artifact on disk which is considered up-to-date and the artifact in the build cache are different even though they are essentially the same.
   A task depending on this task output would then not be able to load outputs from the build cache since the inputs are not exactly the same.
   
   As described in the <<build_cache_concepts.adoc#stable_task_inputs,stable task inputs section>>, you can either make the task outputs repeatable or use input normalization.
   You already learned about the possibilities with <<build_cache_concepts.adoc#filter_runtime_classpath,configurable input normalization>>.
   
   Gradle includes some support for creating repeatable output for archive tasks.
   For tar and zip files Gradle can be configured to create <<working_with_files.adoc#sec:reproducible_archives,reproducible archives>>.
   This is done by configuring e.g. the `Zip` task via the following snippet.
   
   ====
   include::sample[dir="snippets/buildCache/reproducible-archives/kotlin",files="build.gradle.kts[]"]
   include::sample[dir="snippets/buildCache/reproducible-archives/groovy",files="build.gradle[]"]
   ====
   
   Another way to make the outputs repeatable is to activate caching for a task with non-repeatable outputs.
   If you can make sure that the same build cache is used for all builds then the task will always have the same outputs for the same inputs by design of the build cache.
   Going down this road can lead to different problems with cache misses for incremental builds as described above.
   Moreover, race conditions between different builds trying to store the same outputs in the build cache in parallel can lead to hard-to-diagnose cache misses.
   If possible, you should avoid going down that route.
   
   === Limit the effect of volatile data
   
   If none of the described solutions for dealing with volatile data work for you, you should still be able to limit the effect of volatile data on effective use of the build cache.
   This can be done by adding the volatile data later to the outputs as described in the <<volatile_inputs,volatile task inputs section>>.
   Another option would be to move the volatile data so it affects fewer tasks.
   For example moving the dependency from the `compile` to the `runtime` configuration may already have quite an impact.
   
   Sometimes it is also possible to build two artifacts, one containing the volatile data and another one containing a constant representation of the volatile data.
   The non-volatile output would be used e.g. for testing while the volatile one would be published to an external repository.
   While this conflicts with the Continuous Delivery "build artifacts once" principle it can sometimes be the only option.
   
   == Custom and third party tasks
   
   If your build contains custom or third party tasks, you should take special care that these don't influence the effectiveness of the build cache.
   Special care should also be taken for code generation tasks which may not have <<build_cache_concepts.adoc#concepts_repeatable_task_outputs,repeatable task outputs>>.
   This can happen if the code generator includes e.g. a timestamp in the generated files or depends on the order of the input files.
   Other pitfalls can be the use of ``HashMap``s or other data structures without order guarantees in the task's code.
   
   [WARNING]
   ====
   Some third party plugins can even influence cacheability of Gradle's built-in tasks.
   This can happen if they add inputs like absolute paths or volatile data to tasks via the runtime API.
   In the worst case this can lead to incorrect builds when the plugins try to depend on the <<logic_based_on_task_outcome,outcome of a task>> and do not take `FROM-CACHE` into account.
   ====

/Topic: 游댯 Authoring C++/Swift Builds
=======================================


/docs/userguide/native/native_software.adoc
===========================================

.. code-block::

   = Building native software
   
   
   CAUTION: The https://blog.gradle.org/state-and-future-of-the-gradle-software-model[software model] is being retired and the plugins mentioned in this chapter will eventually be deprecated and removed.
   We recommend new projects looking to build C++ applications and libraries use the newer <<building_cpp_projects.adoc#building_cpp_projects,replacement plugins>>.
   
   WARNING: The native plugins described in this chapter are not compatible with the <<configuration_cache.adoc#config_cache:plugins:core,configuration cache>>.
   
   The native software plugins add support for building native software components, such as executables or shared libraries, from code written in C++, C and other languages. While many excellent build tools exist for this space of software development, Gradle offers developers its trademark power and flexibility together with dependency management practices more traditionally found in the JVM development space.
   
   The native software plugins make use of the Gradle software model.
   
   
   == Features
   
   The native software plugins provide:
   
   * Support for building native libraries and applications on Windows, Linux, macOS and other platforms.
   * Support for several source languages.
   * Support for building different variants of the same software, for different architectures, operating systems, or for any purpose.
   * Incremental parallel compilation, precompiled headers.
   * Dependency management between native software components.
   * Unit test execution.
   * Generate Visual studio solution and project files.
   * Deep integration with various tool chain, including discovery of installed tool chains.
   
   
   == Supported languages
   
   The following source languages are currently supported:
   
   * C
   * C++
   * Objective-C
   * Objective-C++
   * Assembly
   * Windows resources
   
   
   == Tool chain support
   
   Gradle offers the ability to execute the same build using different tool chains. When you build a native binary, Gradle will attempt to locate a tool chain installed on your machine that can build the binary. You can fine tune exactly how this works, see <<#native_binaries:tool_chain,Tool chain support>> for details.
   
   The following tool chains are supported:
   
   [%header%autowidth,compact]
   |===
   | Operating System | Tool Chain | Notes
   
   | Linux
   | http://gcc.gnu.org/[GCC]
   |
   
   | Linux
   | http://clang.llvm.org[Clang]
   |
   
   | macOS
   | XCode
   | Uses the Clang tool chain bundled with XCode.
   
   | Windows
   | https://visualstudio.microsoft.com/[Visual C++]
   | Windows XP and later, Visual C++ 2010/2012/2013/2015/2017/2019.
   
   | Windows
   | http://gcc.gnu.org/[GCC] with http://cygwin.com[Cygwin 32 and Cygwin 64]
   | Windows XP and later.
   
   | Windows
   | http://gcc.gnu.org/[GCC] with http://www.mingw.org/[MinGW] and https://mingw-w64.org/doku.php[MinGW64]
   | Windows XP and later.
   |===
   
   The following tool chains are unofficially supported. They generally work fine, but are not tested continuously:
   
   [%header%autowidth,compact]
   |===
   | Operating System | Tool Chain | Notes
   
   | macOS
   | http://gcc.gnu.org/[GCC] from Macports
   |
   
   | macOS
   | http://clang.llvm.org[Clang] from Macports
   |
   
   | UNIX-like
   | http://gcc.gnu.org/[GCC]
   |
   
   | UNIX-like
   | http://clang.llvm.org[Clang]
   |
   |===
   
   
   == Tool chain installation
   
   NOTE: Note that if you are using GCC then you currently need to install support for C+\+, even if you are not building from C++ source.
   This restriction will be removed in a future Gradle version.
   
   To build native software, you will need to have a compatible tool chain installed:
   
   
   === Windows
   
   To build on Windows, install a compatible version of Visual Studio. The native plugins will discover the Visual Studio installations and select the latest version. There is no need to mess around with environment variables or batch scripts. This works fine from a Cygwin shell or the Windows command-line.
   
   Alternatively, you can install Cygwin with GCC or MinGW. Clang is currently not supported.
   
   === macOS
   
   To build on macOS, you should install XCode. The native plugins will discover the XCode installation using the system PATH.
   
   The native plugins also work with GCC and Clang bundled with Macports. To use one of the Macports tool chains, you will need to make the tool chain the default using the `port select` command and add Macports to the system PATH.
   
   === Linux
   
   To build on Linux, install a compatible version of GCC or Clang. The native plugins will discover GCC or Clang using the system PATH.
   
   == Native software model
   
   The native software model builds on the base Gradle software model.
   
   To build native software using Gradle, your project should define one or more _native components_. Each component represents either an executable or a library that Gradle should build. A project can define any number of components. Gradle does not define any components by default.
   
   For each component, Gradle defines a _source set_ for each language that the component can be built from. A source set is essentially just a set of source directories containing source files. For example, when you apply the `c` plugin and define a library called `helloworld`, Gradle will define, by default, a source set containing the C source files in the `src/helloworld/c` directory. It will use these source files to build the `helloworld` library. This is described in more detail below.
   
   For each component, Gradle defines one or more _binaries_ as output. To build a binary, Gradle will take the source files defined for the component, compile them as appropriate for the source language, and link the result into a binary file. For an executable component, Gradle can produce executable binary files. For a library component, Gradle can produce both static and shared library binary files. For example, when you define a library called `helloworld` and build on Linux, Gradle will, by default, produce `libhelloworld.so` and `libhelloworld.a` binaries.
   
   In many cases, more than one binary can be produced for a component. These binaries may vary based on the tool chain used to build, the compiler/linker flags supplied, the dependencies provided, or additional source files provided. Each native binary produced for a component is referred to as a _variant_. Binary variants are discussed in detail below.
   
   == Parallel Compilation
   
   Gradle uses the single build worker pool to concurrently compile and link native components, by default. No special configuration is required to enable concurrent building.
   
   By default, the worker pool size is determined by the number of available processors on the build machine (as reported to the build JVM). To explicitly set the number of workers use the `--max-workers` command-line option or `org.gradle.workers.max` system property. There is generally no need to change this setting from its default.
   
   The build worker pool is shared across all build tasks. This means that when using <<performance.adoc#parallel_execution,parallel project execution>>, the maximum number of concurrent individual compilation operations does not increase. For example, if the build machine has 4 processing cores and 10 projects are compiling in parallel, Gradle will only use 4 total workers, not 40.
   
   == Building a library
   
   To build either a static or shared native library, you define a library component in the `components` container. The following sample defines a library called `hello`:
   
   === Example: Defining a library component
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/c/groovy/build.gradle[tag=libraries]
   ----
   
   A library component is represented using link:{javadocPath}#[NativeLibrarySpec]. Each library component can produce at least one shared library binary (link:{javadocPath}#[SharedLibraryBinarySpec]) and at least one static library binary (link:{javadocPath}#[StaticLibraryBinarySpec]).
   
   == Building an executable
   
   To build a native executable, you define an executable component in the `components` container. The following sample defines an executable called `main`:
   
   === Example: Defining executable components
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/c/groovy/build.gradle[tag=executables]
   ----
   
   An executable component is represented using link:{javadocPath}#[NativeExecutableSpec]. Each executable component can produce at least one executable binary (link:{javadocPath}#[NativeExecutableBinarySpec]).
   
   For each component defined, Gradle adds a link:{javadocPath}#[FunctionalSourceSet] with the same name. Each of these functional source sets will contain a language-specific source set for each of the languages supported by the project.
   
   == Assembling or building dependents
   
   Sometimes, you may need to _assemble_ (compile and link) or _build_ (compile, link and test) a component or binary and its _dependents_ (things that depend upon the component or binary). The native software model provides tasks that enable this capability. First, the _dependent components_ report gives insight about the relationships between each component. Second, the _build and assemble dependents_ tasks allow you to assemble or build a component and its dependents in one step.
   
   In the following example, the build file defines `OpenSSL` as a dependency of `libUtil` and `libUtil` as a dependency of `LinuxApp` and `WindowsApp`. Test suites are treated similarly. Dependents can be thought of as reverse dependencies.
   
   .Dependent Components Example
   image::nativeDependents.png[]
   
   NOTE: By following the dependencies backwards, you can see `LinuxApp` and `WindowsApp` are _dependents_ of `libUtil`.
   When `libUtil` is changed, Gradle will need to recompile or relink `LinuxApp` and `WindowsApp`.
   
   When you _assemble_ dependents of a component, the component and all of its dependents are compiled and linked, including any test suite binaries. Gradle's up-to-date checks are used to only compile or link if something has changed. For instance, if you have changed source files in a way that do not affect the headers of your project, Gradle will be able to skip compilation for dependent components and only need to re-link with the new library. Tests are not run when assembling a component.
   
   When you _build_ dependents of a component, the component and all of its dependent binaries are compiled, linked _and checked_. Checking components means running any <<#sec:check_tasks,check task>> including executing any test suites, so tests _are_ run when building a component.
   
   In the following sections, we will demonstrate the usage of the `assembleDependents\*`, `buildDependents*` and `dependentComponents` tasks with a sample build that contains a CUnit test suite. The build script for the sample is the following:
   
   === Example: Sample build
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/cunit/groovy/build.gradle[tag=terse-example]
   ----
   
   
   
   === Dependent components report
   
   Gradle provides a report that you can run from the command-line that shows a graph of components in your project and components that depend upon them. The following is an example of running `gradle dependentComponents` on the sample project:
   
   === Example: Dependent components report
   
   .Output of **`gradle dependentComponents`**
   ----
   > gradle dependentComponents
   include::{snippetsPath}/native-binaries/cunit/tests/dependentComponentsReport.out[]
   ----
   
   NOTE: See link:{groovyDslPath}#[DependentComponentsReport] API documentation for more details.
   
   By default, non-buildable binaries and test suites are hidden from the report. The `dependentComponents` task provides options that allow you to see all dependents by using the `--all` option:
   
   === Example: Dependent components report
   
   .Output of **`gradle dependentComponents --all`**
   ----
   > gradle dependentComponents --all
   include::{snippetsPath}/native-binaries/cunit/tests/dependentComponentsReportAll.out[]
   ----
   
   Here is the corresponding report for the `operators` component, showing dependents of all its binaries:
   
   === Example: Report of components that depends on the operators component
   
   .Output of **`gradle dependentComponents --component operators`**
   ----
   > gradle dependentComponents --component operators
   include::{snippetsPath}/native-binaries/cunit/tests/assembleDependentComponentsReport.out[]
   ----
   
   Here is the corresponding report for the `operators` component, showing dependents of all its binaries, including test suites:
   
   === Example: Report of components that depends on the operators component, including test suites
   
   .Output of **`gradle dependentComponents --test-suites --component operators`**
   ----
   > gradle dependentComponents --test-suites --component operators
   include::{snippetsPath}/native-binaries/cunit/tests/buildDependentComponentsReport.out[]
   ----
   
   Furthermore, the `--non-binaries` option shows non-buildable binaries in the report, `--no-non-buildable` hides them.
   Similarly, the `--test-suites` option shows test suites and `--no-test-suites` hides them.
   The option `--no-all` hides both non-buildable binaries and test suites from the report.
   
   === Assembling dependents
   
   For each link:{javadocPath}#[NativeBinarySpec], Gradle will create a task named `assembleDependents__${component.name}${binary.variant}__` that _assembles_ (compile and link) the binary and all of its dependent binaries.
   
   For each link:{javadocPath}#[NativeComponentSpec], Gradle will create a task named `assembleDependents__${component.name}__` that _assembles_ all the binaries of the component and all of their dependent binaries.
   
   For example, to assemble the dependents of the "passing" flavor of the "static" library binary of the "operators" component, you would run the `assembleDependentsOperatorsPassingStaticLibrary` task:
   
   === Example: Assemble components that depends on the passing/static binary of the operators component
   
   .Output of **`gradle assembleDependentsOperatorsPassingStaticLibrary --max-workers=1`**
   ----
   > gradle assembleDependentsOperatorsPassingStaticLibrary --max-workers=1
   include::{snippetsPath}/native-binaries/cunit/tests/assembleDependentComponents.out[]
   ----
   
   In the output above, the targeted binary gets assembled as well as the test suite binary that depends on it.
   
   You can also assemble _all_ of the dependents of a component (i.e. of all its binaries/variants) using the corresponding component task, e.g. `assembleDependentsOperators`. This is useful if you have many combinations of build types, flavors and platforms and want to assemble all of them.
   
   === Building dependents
   
   For each link:{javadocPath}#[NativeBinarySpec], Gradle will create a task named `buildDependents__${component.name}${binary.variant}__` that _builds_ (compile, link and check) the binary and all of its dependent binaries.
   
   For each link:{javadocPath}#[NativeComponentSpec], Gradle will create a task named `buildDependents__${component.name}__` that _builds_ all the binaries of the component and all of their dependent binaries.
   
   For example, to build the dependents of the "passing" flavor of the "static" library binary of the "operators" component, you would run the `buildDependentsOperatorsPassingStaticLibrary` task:
   
   === Example: Build components that depends on the passing/static binary of the operators component
   
   .Output of **`gradle buildDependentsOperatorsPassingStaticLibrary --max-workers=1`**
   ----
   > gradle buildDependentsOperatorsPassingStaticLibrary --max-workers=1
   include::{snippetsPath}/native-binaries/cunit/tests/buildDependentComponents.out[]
   ----
   
   In the output above, the targeted binary as well as the test suite binary that depends on it are built and the test suite has run.
   
   You can also build _all_ of the dependents of a component (i.e. of all its binaries/variants) using the corresponding component task, e.g. `buildDependentsOperators`.
   
   == Tasks
   
   For each link:{javadocPath}#[NativeBinarySpec] that can be produced by a build, a single _lifecycle task_ is constructed that can be used to create that binary, together with a set of other tasks that do the actual work of compiling, linking or assembling the binary.
   
   
   `__${component.name}__Executable`::
     Component Type;;
       link:{javadocPath}#[NativeExecutableSpec]
     Native Binary Type;;
       link:{javadocPath}#[NativeExecutableBinarySpec]
     Location of created binary;;
       `__${project.layout.buildDirectory}__/exe/__${component.name}__/__${component.name}__`
   
   `__${component.name}__SharedLibrary`::
     Component Type;;
       link:{javadocPath}#[NativeLibrarySpec]
     Native Binary Type;;
       link:{javadocPath}#[SharedLibraryBinarySpec]
     Location of created binary;;
       `__${project.layout.buildDirectory}__/libs/__${component.name}__/shared/lib__${component.name}__.so`
   
   `__${component.name}__StaticLibrary`::
     Component Type;;
       link:{javadocPath}#[NativeLibrarySpec]
     Native Binary Type;;
       link:{javadocPath}#[StaticLibraryBinarySpec]
     Location of created binary;;
       `__${project.layout.buildDirectory}__/libs/__${component.name}__/static/__${component.name}__.a`
   
   
   === Check tasks
   
   For each link:{javadocPath}#[NativeBinarySpec] that can be produced by a build, a single _check task_ is constructed that can be used to assemble and check that binary.
   
   `check__${component.name}__Executable`::
     Component Type;;
       link:{javadocPath}#[NativeExecutableSpec]
     Native Binary Type;;
       link:{javadocPath}#[NativeExecutableBinarySpec]
   
   `check__${component.name}__SharedLibrary`::
     Component Type;;
       link:{javadocPath}#[NativeLibrarySpec]
     Native Binary Type;;
       link:{javadocPath}#[SharedLibraryBinarySpec]
   
   `check__${component.name}__StaticLibrary`::
     Component Type;;
       link:{javadocPath}#[NativeLibrarySpec]
     Native Binary Type;;
       link:{javadocPath}#[SharedLibraryBinarySpec]
   
   The built-in `check` task depends on all the _check tasks_ for binaries in the project. Without either <<#native_binaries:cunit,CUnit>> or <<#native_binaries:google_test,GoogleTest>> plugins, the binary check task only depends on the _lifecycle task_ that assembles the binary, see <<#sec:native_tasks,Native tasks>>.
   
   When the <<#native_binaries:cunit,CUnit>> or <<#native_binaries:google_test,GoogleTest>> plugins are applied, the task that executes the test suites for a component are automatically wired to the appropriate _check task_.
   
   You can also add custom check tasks as follows:
   
   === Example: Adding a custom check task
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/custom-check/groovy/build.gradle[tag=custom-check]
   ----
   
   
   
   Now, running `check` or any of the _check tasks_ for the `hello` binaries will run the custom check task:
   
   === Example: Running checks for a given binary
   
   .Output of **`gradle checkHelloSharedLibrary`**
   ----
   > gradle checkHelloSharedLibrary
   include::{snippetsPath}/native-binaries/custom-check/tests/nativeComponentCustomCheckOutput.out[]
   ----
   
   
   === Working with shared libraries
   
   For each executable binary produced, the `cpp` plugin provides an `install${binary.name}` task, which creates a development install of the executable, along with the shared libraries it requires. This allows you to run the executable without needing to install the shared libraries in their final locations.
   
   == Finding out more about your project
   
   Gradle provides a report that you can run from the command-line that shows some details about the components and binaries that your project produces. To use this report, just run `gradle components`. Below is an example of running this report for one of the sample projects:
   
   === Example: The components report
   
   .Output of **`gradle components`**
   ----
   > gradle components
   include::{snippetsPath}/native-binaries/cpp/tests/nativeComponentReport.out[]
   ----
   
   
   == Language support
   
   Presently, Gradle supports building native software from any combination of source languages listed below. A native binary project will contain one or more named `FunctionalSourceSet` instances (e.g. 'main', 'test', etc), each of which can contain ``LanguageSourceSet``s containing source files, one for each language.
   
   * C
   * C++
   * Objective-C
   * Objective-C++
   * Assembly
   * Windows resources
   
   
   === C++ sources
   
   C++ language support is provided by means of the `'cpp'` plugin.
   
   === Example: The 'cpp' plugin
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/cpp/groovy/build.gradle[tag=apply-plugin]
   ----
   
   $$C++$$ sources to be included in a native binary are provided via a link:{groovyDslPath}#[CppSourceSet], which defines a set of C++ source files and optionally a set of exported header files (for a library). By default, for any named component the link:{groovyDslPath}#[CppSourceSet] contains `.cpp` source files in `src/${name}/cpp`, and header files in `src/${name}/headers`.
   
   While the `cpp` plugin defines these default locations for each link:{groovyDslPath}#[CppSourceSet], it is possible to extend or override these defaults to allow for a different project layout.
   
   === Example: C++ source set
   
   [source.multi-language-sample,groovy,indent=0]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/custom-layout/groovy/build.gradle[tag=cpp-sources]
   ----
   
   For a library named 'main', header files in `src/main/headers` are considered the "public" or "exported" headers. Header files that should not be exported should be placed inside the `src/main/cpp` directory (though be aware that such header files should always be referenced in a manner relative to the file including them).
   
   === C sources
   
   C language support is provided by means of the `'c'` plugin.
   
   === Example: The 'c' plugin
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/c/groovy/build.gradle[tag=apply-plugin]
   ----
   
   C sources to be included in a native binary are provided via a link:{groovyDslPath}#[CSourceSet], which defines a set of C source files and optionally a set of exported header files (for a library). By default, for any named component the link:{groovyDslPath}#[CSourceSet] contains `.c` source files in `src/${name}/c`, and header files in `src/${name}/headers`.
   
   While the `c` plugin defines these default locations for each link:{groovyDslPath}#[CSourceSet], it is possible to extend or override these defaults to allow for a different project layout.
   
   === Example: C source set
   
   [source.multi-language-sample,groovy,indent=0]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/custom-layout/groovy/build.gradle[tag=c-sources]
   ----
   
   For a library named 'main', header files in `src/main/headers` are considered the "public" or "exported" headers. Header files that should not be exported should be placed inside the `src/main/c` directory (though be aware that such header files should always be referenced in a manner relative to the file including them).
   
   === Assembler sources
   
   Assembly language support is provided by means of the `'assembler'` plugin.
   
   === Example: The 'assembler' plugin
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/assembler/groovy/build.gradle[tag=apply-plugin]
   ----
   
   Assembler sources to be included in a native binary are provided via a link:{groovyDslPath}#[AssemblerSourceSet], which defines a set of Assembler source files. By default, for any named component the link:{groovyDslPath}#[AssemblerSourceSet] contains `.s` source files under `src/${name}/asm`.
   
   === Objective-C sources
   
   Objective-C language support is provided by means of the `'objective-c'` plugin.
   
   === Example: The 'objective-c' plugin
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/objective-c/groovy/build.gradle[tag=apply-plugin]
   ----
   
   Objective-C sources to be included in a native binary are provided via a link:{groovyDslPath}#[ObjectiveCSourceSet], which defines a set of Objective-C source files. By default, for any named component the link:{groovyDslPath}#[ObjectiveCSourceSet] contains `.m` source files under `src/${name}/objectiveC`.
   
   === Objective-C++ sources
   
   Objective-C++ language support is provided by means of the `'objective-cpp'` plugin.
   
   === Example: The 'objective-cpp' plugin
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/objective-cpp/groovy/build.gradle[tag=apply-plugin]
   ----
   
   Objective-C$$++$$ sources to be included in a native binary are provided via a link:{groovyDslPath}#[ObjectiveCppSourceSet], which defines a set of Objective-C++ source files. By default, for any named component the link:{groovyDslPath}#[ObjectiveCppSourceSet] contains `.mm` source files under `src/${name}/objectiveCpp`.
   
   == Configuring the compiler, assembler and linker
   
   Each binary to be produced is associated with a set of compiler and linker settings, which include command-line arguments as well as macro definitions. These settings can be applied to all binaries, an individual binary, or selectively to a group of binaries based on some criteria.
   
   === Example: Settings that apply to all binaries
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/cpp/groovy/build.gradle[tag=all-binaries]
   ----
   
   Each binary is associated with a particular link:{javadocPath}#[NativeToolChain], allowing settings to be targeted based on this value.
   
   It is easy to apply settings to all binaries of a particular type:
   
   === Example: Settings that apply to all shared libraries
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/c/groovy/build.gradle[tag=all-shared-libraries]
   ----
   
   Furthermore, it is possible to specify settings that apply to all binaries produced for a particular `executable` or `library` component:
   
   === Example: Settings that apply to all binaries produced for the 'main' executable component
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/assembler/groovy/build.gradle[tag=assembler-args]
   ----
   
   The example above will apply the supplied configuration to all `executable` binaries built.
   
   Similarly, settings can be specified to target binaries for a component that are of a particular type: e.g. all shared libraries for the main library component.
   
   === Example: Settings that apply only to shared libraries produced for the 'main' library component
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/cpp-lib/groovy/build.gradle[tag=args]
   ----
   
   
   == Windows Resources
   
   When using the link:{groovyDslPath}#[VisualCpp] tool chain, Gradle is able to compile Window Resource (`rc`) files and link them into a native binary. This functionality is provided by the `'windows-resources'` plugin.
   
   === Example: The 'windows-resources' plugin
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/windows-resources/groovy/build.gradle[tag=apply-plugin]
   ----
   
   Windows resources to be included in a native binary are provided via a link:{groovyDslPath}#[WindowsResourceSet], which defines a set of Windows Resource source files. By default, for any named component the link:{groovyDslPath}#[WindowsResourceSet] contains `.rc` source files under `src/${name}/rc`.
   
   As with other source types, you can configure the location of the windows resources that should be included in the binary.
   
   === Example: Configuring the location of Windows resource sources
   
   [source.multi-language-sample,groovy,indent=0]
   .build-resource-only-dll.gradle
   ----
   include::{snippetsPath}/native-binaries/windows-resources/groovy/build-resource-only-dll.gradle[tag=windows-resource-set]
   ----
   
   You are able to construct a resource-only library by providing Windows Resource sources with no other language sources, and configure the linker as appropriate:
   
   === Example: Building a resource-only dll
   
   [source.multi-language-sample,groovy]
   .build-resource-only-dll.gradle
   ----
   include::{snippetsPath}/native-binaries/windows-resources/groovy/build-resource-only-dll.gradle[tag=resource-only-library]
   ----
   
   The example above also demonstrates the mechanism of passing extra command-line arguments to the resource compiler. The `rcCompiler` extension is of type link:{javadocPath}#[PreprocessingTool].
   
   == Library Dependencies
   
   Dependencies for native components are binary libraries that export header files. The header files are used during compilation, with the compiled binary dependency being used during linking and execution. Header files should be organized into subdirectories to prevent clashes of commonly named headers. For instance, if your `mylib` project has a `logging.h` header, it will make it less likely the wrong header is used if you include it as `"mylib/logging.h"` instead of `"logging.h"`.
   
   
   === Dependencies within the same project
   
   A set of sources may depend on header files provided by another binary component within the same project. A common example is a native executable component that uses functions provided by a separate native library component.
   
   Such a library dependency can be added to a source set associated with the `executable` component:
   
   === Example: Providing a library dependency to the source set
   
   [source.multi-language-sample,groovy,indent=0]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/cpp/groovy/build.gradle[tag=source-library]
   ----
   
   Alternatively, a library dependency can be provided directly to the `NativeExecutableBinarySpec` for the `executable`.
   
   === Example: Providing a library dependency to the binary
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/custom-layout/groovy/build.gradle[tag=binary-library]
   ----
   
   
   === Project Dependencies
   
   For a component produced in a different Gradle project, the notation is similar.
   
   === Example: Declaring project dependencies
   
   [source.multi-language-sample,groovy]
   .lib/build.gradle
   ----
   include::{snippetsPath}/native-binaries/multi-project/groovy/lib/build.gradle[]
   ----
   [source.multi-language-sample,groovy]
   .exe/build.gradle
   ----
   include::{snippetsPath}/native-binaries/multi-project/groovy/exe/build.gradle[]
   ----
   
   
   == Precompiled Headers
   
   Precompiled headers are a performance optimization that reduces the cost of compiling widely used headers multiple times. This feature _precompiles_ a header such that the compiled object file can be reused when compiling each source file rather than recompiling the header each time. This support is available for C, C+\+, Objective-C, and Objective-C++ builds.
   
   To configure a precompiled header, first a header file needs to be defined that includes all of the headers that should be precompiled. It must be specified as the first included header in every source file where the precompiled header should be used. It is assumed that this header file, and any headers it contains, make use of header guards so that they can be included in an idempotent manner. If header guards are not used in a header file, it is possible the header could be compiled more than once and could potentially lead to a broken build.
   
   === Example: Creating a precompiled header file
   
   [source.multi-language-sample,c]
   .src/hello/headers/pch.h
   ----
   include::{snippetsPath}/native-binaries/pre-compiled-headers/groovy/src/hello/headers/pch.h[]
   ----
   
   === Example: Including a precompiled header file in a source file
   
   [source.multi-language-sample,cpp]
   .src/hello/cpp/hello.cpp
   ----
   include::{snippetsPath}/native-binaries/pre-compiled-headers/groovy/src/hello/cpp/hello.cpp[]
   ----
   
   Precompiled headers are specified on a source set. Only one precompiled header file can be specified on a given source set and will be applied to all source files that declare it as the first include. If a source files does not include this header file as the first header, the file will be compiled in the normal manner (without making use of the precompiled header object file). The string provided should be the same as that which is used in the "#include" directive in the source files.
   
   === Example: Configuring a precompiled header
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/pre-compiled-headers/groovy/build.gradle[tag=libraries]
   ----
   
   A precompiled header must be included in the same way for all files that use it. Usually, this means the header file should exist in the source set "headers" directory or in a directory included on the compiler include path.
   
   == Native Binary Variants
   
   For each executable or library defined, Gradle is able to build a number of different native binary variants. Examples of different variants include debug vs release binaries, 32-bit vs 64-bit binaries, and binaries produced with different custom preprocessor flags.
   
   Binaries produced by Gradle can be differentiated on <<#native_binaries:build_type,build type>>, <<#native_binaries:platform,platform>>, and <<#native_binaries:flavor,flavor>>. For each of these 'variant dimensions', it is possible to specify a set of available values as well as target each component at one, some or all of these. For example, a plugin may define a range of support platforms, but you may choose to only target Windows-x86 for a particular component.
   
   
   === Build types
   
   A `build type` determines various non-functional aspects of a binary, such as whether debug information is included, or what optimisation level the binary is compiled with. Typical build types are 'debug' and 'release', but a project is free to define any set of build types.
   
   === Example: Defining build types
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/variants/groovy/build.gradle[tag=build-types]
   ----
   
   If no build types are defined in a project, then a single, default build type called 'debug' is added.
   
   For a build type, a Gradle project will typically define a set of compiler/linker flags per tool chain.
   
   === Example: Configuring debug binaries
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/variants/groovy/build.gradle[tag=build-type-config]
   ----
   
   NOTE: At this stage, it is completely up to the build script to configure the relevant compiler/linker flags for each build type.
   Future versions of Gradle will automatically include the appropriate debug flags for any 'debug' build type, and may be aware of various levels of optimisation as well.
   
   === Platform
   
   An executable or library can be built to run on different operating systems and cpu architectures, with a variant being produced for each platform. Gradle defines each OS/architecture combination as a link:{groovyDslPath}#[NativePlatform], and a project may define any number of platforms. If no platforms are defined in a project, then a single, default platform 'current' is added.
   
   [NOTE]
   ====
   Presently, a `Platform` consists of a defined operating system and architecture.
   As we continue to develop the native binary support in Gradle, the concept of Platform will be extended to include things like C-runtime version, Windows SDK, ABI, etc.
   Sophisticated builds may use the extensibility of Gradle to apply additional attributes to each platform, which can then be queried to specify particular includes, preprocessor macros or compiler arguments for a native binary.
   ====
   
   === Example: Defining platforms
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/variants/groovy/build.gradle[tag=platforms]
   ----
   
   For a given variant, Gradle will attempt to find a link:{javadocPath}#[NativeToolChain] that is able to build for the target platform. Available tool chains are searched in the order defined. See the <<#native_binaries:tool_chain,tool chains>> section below for more details.
   
   === Flavor
   
   Each component can have a set of named `flavors`, and a separate binary variant can be produced for each flavor. While the `build type` and `target platform` variant dimensions have a defined meaning in Gradle, each project is free to define any number of flavors and apply meaning to them in any way.
   
   An example of component flavors might differentiate between 'demo', 'paid' and 'enterprise' editions of the component, where the same set of sources is used to produce binaries with different functions.
   
   === Example: Defining flavors
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/flavors/groovy/build.gradle[tag=flavors]
   ----
   
   In the example above, a library is defined with a 'english' and 'french' flavor. When compiling the 'french' variant, a separate macro is defined which leads to a different binary being produced.
   
   If no flavor is defined for a component, then a single default flavor named 'default' is used.
   
   === Selecting the build types, platforms and flavors for a component
   
   For a default component, Gradle will attempt to create a native binary variant for each and every combination of `buildType` and `flavor` defined for the project. It is possible to override this on a per-component basis, by specifying the set of `targetBuildTypes` and/or `targetFlavors`. By default, Gradle will build for the default platform, see <<#native_binaries:platform,above>>, unless specified explicitly on a per-component basis by specifying a set of `targetPlatforms`.
   
   === Example: Targeting a component at particular platforms
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/variants/groovy/build.gradle[tag=target-platforms]
   ----
   
   Here you can see that the link:{groovyDslPath}#[TargetedNativeComponent.targetPlatform(java.lang.String)] method is used to specify a platform that the `NativeExecutableSpec` named `main` should be built for.
   
   A similar mechanism exists for selecting link:{groovyDslPath}#[]++)[TargetedNativeComponent.targetBuildTypes(java.lang.String...)] and link:{groovyDslPath}#[]++)[TargetedNativeComponent.targetFlavors(java.lang.String...)].
   
   === Building all possible variants
   
   When a set of build types, target platforms, and flavors is defined for a component, a link:{javadocPath}#[NativeBinarySpec] model element is created for every possible combination of these. However, in many cases it is not possible to build a particular variant, perhaps because no tool chain is available to build for a particular platform.
   
   If a binary variant cannot be built for any reason, then the link:{javadocPath}#[NativeBinarySpec] associated with that variant will not be `buildable`. It is possible to use this property to create a task to generate all possible variants on a particular machine.
   
   === Example: Building all possible variants
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/tool-chains/groovy/build.gradle[tag=buildable]
   ----
   
   
   == Tool chains
   
   A single build may utilize different tool chains to build variants for different platforms. To this end, the core 'native-binary' plugins will attempt to locate and make available supported tool chains. However, the set of tool chains for a project may also be explicitly defined, allowing additional cross-compilers to be configured as well as allowing the install directories to be specified.
   
   
   === Defining tool chains
   
   The supported tool chain types are:
   
   * link:{groovyDslPath}#[Gcc]
   * link:{groovyDslPath}#[Clang]
   * link:{groovyDslPath}#[VisualCpp]
   
   === Example: Defining tool chains
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/tool-chains/groovy/build.gradle[tag=toolChains]
   ----
   
   Each tool chain implementation allows for a certain degree of configuration (see the API documentation for more details).
   
   === Using tool chains
   
   It is not necessary or possible to specify the tool chain that should be used to build. For a given variant, Gradle will attempt to locate a link:{javadocPath}#[NativeToolChain] that is able to build for the target platform. Available tool chains are searched in the order defined.
   
   NOTE: When a platform does not define an architecture or operating system, the default target of the tool chain is assumed.
   So if a platform does not define a value for `operatingSystem`, Gradle will find the first available tool chain that can build for the specified `architecture`.
   
   The core Gradle tool chains are able to target the following architectures out of the box. In each case, the tool chain will target the current operating system. See the next section for information on cross-compiling for other operating systems.
   
   [cols="a,a", options="header"]
   |===
   | Tool Chain
   | Architectures
   
   | GCC
   | x86, x86_64, arm64 (macOS Only)
   
   | Clang
   | x86, x86_64, arm64 (macOS only)
   
   | Visual C++
   | x86, x86_64, ia-64
   |===
   
   So for GCC running on linux, the supported target platforms are 'linux/x86' and 'linux/x86_64'. For GCC running on Windows via Cygwin, platforms 'windows/x86' and 'windows/x86_64' are supported. (The Cygwin POSIX runtime is not yet modelled as part of the platform, but will be in the future.)
   
   If no target platforms are defined for a project, then all binaries are built to target a default platform named 'current'. This default platform does not specify any `architecture` or `operatingSystem` value, hence using the default values of the first available tool chain.
   
   Gradle provides a _hook_ that allows the build author to control the exact set of arguments passed to a tool chain executable. This enables the build author to work around any limitations in Gradle, or assumptions that Gradle makes. The arguments hook should be seen as a 'last-resort' mechanism, with preference given to truly modelling the underlying domain.
   
   === Example: Reconfigure tool arguments
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/tool-chains/groovy/build.gradle[tag=withArguments]
   ----
   
   
   === Cross-compiling with GCC
   
   Cross-compiling is possible with the link:{groovyDslPath}#[Gcc] and link:{groovyDslPath}#[Clang] tool chains, by adding support for additional target platforms. This is done by specifying a target platform for a toolchain. For each target platform a custom configuration can be specified.
   
   === Example: Defining target platforms
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/target-platforms/groovy/build.gradle[tag=targetplatforms]
   ----
   
   
   == Visual Studio IDE integration
   
   Gradle has the ability to generate Visual Studio project and solution files for the native components defined in your build. This ability is added by the `visual-studio` plugin. For a multi-project build, all projects with native components (and the root project) should have this plugin applied.
   
   When the `visual-studio` plugin is applied to the root project, a task named `visualStudio` is created, which will generate a Visual Studio solution file containing all components in the build. This solution will include a Visual Studio project for each component, as well as configuring each component to build using Gradle.
   
   A task named `openVisualStudio` is also created by the `visual-studio` plugin when the project is the root project. This task generates the Visual Studio solution and then opens the solution in Visual Studio. This means you can simply run `gradlew openVisualStudio` from the root project to generate and open the Visual Studio solution in one convenient step.
   
   The content of the generated visual studio files can be modified via API hooks, provided by the `visualStudio` extension. Take a look at the 'visual-studio' sample, or see link:{groovyDslPath}#[VisualStudioExtension.getProjects()] and link:{groovyDslPath}#[VisualStudioRootExtension.getSolution()] in the API documentation for more details.
   
   == CUnit support
   
   The Gradle `cunit` plugin provides support for compiling and executing CUnit tests in your native-binary project. For each link:{javadocPath}#[NativeExecutableSpec] and link:{javadocPath}#[NativeLibrarySpec] defined in your project, Gradle will create a matching link:{groovyDslPath}#[CUnitTestSuiteSpec] component, named `${component.name}Test`.
   
   
   === CUnit sources
   
   Gradle will create a link:{groovyDslPath}#[CSourceSet] named 'cunit' for each link:{groovyDslPath}#[CUnitTestSuiteSpec] component in the project. This source set should contain the cunit test files for the component under test. Source files can be located in the conventional location (`src/${component.name}Test/cunit`) or can be configured like any other source set.
   
   Gradle initialises the CUnit test registry and executes the tests, utilising some generated CUnit launcher sources. Gradle will expect and call a function with the signature `void gradle_cunit_register()` that you can use to configure the actual CUnit suites and tests to execute.
   
   === Example: Registering CUnit tests
   
   [source.multi-language-sample,c]
   .suite_operators.c
   ----
   include::{snippetsPath}/native-binaries/cunit/groovy/src/operatorsTest/c/suite_operators.c[]
   ----
   
   NOTE: Due to this mechanism, your CUnit sources may not contain a `main` method since this will clash with the method provided by Gradle.
   
   === Building CUnit executables
   
   A link:{groovyDslPath}#[CUnitTestSuiteSpec] component has an associated link:{javadocPath}#[NativeExecutableSpec] or link:{javadocPath}#[NativeLibrarySpec] component. For each link:{javadocPath}#[NativeBinarySpec] configured for the main component, a matching link:{groovyDslPath}#[CUnitTestSuiteBinarySpec] will be configured on the test suite component. These test suite binaries can be configured in a similar way to any other binary instance:
   
   === Example: Configuring CUnit tests
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/cunit/groovy/build.gradle[tag=configure-test-binary]
   ----
   
   NOTE: Both the CUnit sources provided by your project and the generated launcher require the core CUnit headers and libraries.
   Presently, this library dependency must be provided by your project for each link:{groovyDslPath}#[CUnitTestSuiteBinarySpec].
   
   === Running CUnit tests
   
   For each link:{groovyDslPath}#[CUnitTestSuiteBinarySpec], Gradle will create a task to execute this binary, which will run all of the registered CUnit tests. Test results will be found in the `__${build.dir}__/test-results` directory.
   
   === Example: Running CUnit tests
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/cunit/groovy/build.gradle[tag=complete-example]
   ----
   
   .Output of `gradle -q runOperatorsTestFailingCUnitExe`
   ----
   > gradle -q runOperatorsTestFailingCUnitExe
   include::{snippetsPath}/native-binaries/cunit/tests/completeCUnitExample.out[]
   ----
   
   [NOTE]
   ====
   The current support for CUnit is quite rudimentary. Plans for future integration include:
   
   * Allow tests to be declared with Javadoc-style annotations.
   * Improved HTML reporting, similar to that available for JUnit.
   * Real-time feedback for test execution.
   * Support for additional test frameworks.
   ====
   
   == GoogleTest support
   
   The Gradle `google-test` plugin provides support for compiling and executing GoogleTest tests in your native-binary project. For each link:{javadocPath}#[NativeExecutableSpec] and link:{javadocPath}#[NativeLibrarySpec] defined in your project, Gradle will create a matching link:{groovyDslPath}#[GoogleTestTestSuiteSpec] component, named `${component.name}Test`.
   
   
   === GoogleTest sources
   
   Gradle will create a link:{groovyDslPath}#[CppSourceSet] named 'cpp' for each link:{groovyDslPath}#[GoogleTestTestSuiteSpec] component in the project. This source set should contain the GoogleTest test files for the component under test. Source files can be located in the conventional location (`src/${component.name}Test/cpp`) or can be configured like any other source set.
   
   === Building GoogleTest executables
   
   A link:{groovyDslPath}#[GoogleTestTestSuiteSpec] component has an associated link:{javadocPath}#[NativeExecutableSpec] or link:{javadocPath}#[NativeLibrarySpec] component. For each link:{javadocPath}#[NativeBinarySpec] configured for the main component, a matching link:{groovyDslPath}#[GoogleTestTestSuiteBinarySpec] will be configured on the test suite component. These test suite binaries can be configured in a similar way to any other binary instance:
   
   === Example: Registering GoogleTest tests
   
   [source.multi-language-sample,groovy]
   .build.gradle
   ----
   include::{snippetsPath}/native-binaries/google-test/groovy/build.gradle[tag=configure-test-binary]
   ----
   
   NOTE: The GoogleTest sources provided by your project require the core GoogleTest headers and libraries.
   Presently, this library dependency must be provided by your project for each link:{groovyDslPath}#[GoogleTestTestSuiteBinarySpec].
   
   === Running GoogleTest tests
   
   For each link:{groovyDslPath}#[GoogleTestTestSuiteBinarySpec], Gradle will create a task to execute this binary, which will run all of the registered GoogleTest tests. Test results will be found in the `__${build.dir}__/test-results` directory.
   
   [NOTE]
   ====
   The current support for GoogleTest is quite rudimentary. Plans for future integration include:
   
   * Improved HTML reporting, similar to that available for JUnit.
   * Real-time feedback for test execution.
   * Support for additional test frameworks.
   ====

/docs/userguide/native/building_cpp_projects.adoc
=================================================

.. code-block::

   = Building {cpp} projects
   
   WARNING: The plugins described in this chapter are not compatible with the <<configuration_cache.adoc#config_cache:plugins:core,configuration cache>>.
   
   Gradle uses a convention-over-configuration approach to building native projects.
   If you are coming from another native build system, these concepts may be unfamiliar at first, but they serve a purpose to simplify build script authoring.
   
   We will look at {cpp} projects in detail in this chapter, but most of the topics will apply to other supported native languages as well.
   If you don뗪 have much experience with building native projects with Gradle, take a look at the {cpp} tutorials for step-by-step instructions on how to build various types of basic {cpp} projects as well as some common use cases.
   
   The {cpp} plugins covered in this chapter were https://blog.gradle.org/introducing-the-new-cpp-plugins[introduced in 2018] and we recommend users to use those plugins over <<native_software.adoc#native_software,the older Native plugins>> that you may find references to.
   
   == Introduction
   
   The simplest build script for a {cpp} project applies the {cpp} application plugin or the {cpp} library plugin and optionally sets the project version:
   
   .Applying the {cpp} Plugin
   ====
   include::sample[dir="snippets/cpp/basic/kotlin",files="build.gradle.kts[tags=apply-cpp-plugin]"]
   include::sample[dir="snippets/cpp/basic/groovy",files="build.gradle[tags=apply-cpp-plugin]"]
   ====
   
   By applying either of the {cpp} plugins, you get a whole host of features:
   
    * `compileDebugCpp` and `compileReleaseCpp` tasks that compiles the {cpp} source files under _src/main/cpp_ for the well-known debug and release build types, respectively.
    * `linkDebug` and `linkRelease` tasks that link the compiled {cpp} object files into an executable for applications or shared library for libraries with shared linkage for the debug and release build types.
    * `createDebug` and `createRelease` tasks that assemble the compiled {cpp} object files into a static library for libraries with static linkage for the debug and release build types.
   
   For any non-trivial {cpp} project, you뗣l probably have some file dependencies and additional configuration specific to _your_ project.
   
   The {cpp} plugins also integrates the above tasks into the standard <<base_plugin#sec:base_tasks,lifecycle tasks>>. The task that produces the development binary is attached to `assemble`.  By default, the development binary is the debug variant.
   
   The rest of the chapter explains the different ways to customize the build to your requirements when building libraries and applications.
   
   == Introducing build variants
   
   Native projects can typically produce several different binaries, such as debug or release ones, or ones that target particular platforms and processor architectures.
   Gradle manages this through the concepts of _dimensions_ and _variants_.
   
   A dimension is simply a category, where each category is orthogonal to the rest.
   For example, the "build type" dimension is a category that includes debug and release.
   The "architecture" dimension covers processor architectures like x86-64 and PowerPC.
   
   A variant is a combination of values for these dimensions, consisting of exactly one value for each dimension.
   You might have a "debug x86-64" or a "release PowerPC" variant.
   
   Gradle has built-in support for several dimensions and several values within each dimension.
   You can find a list of them in the <<plugin_reference.adoc#native_languages,native plugin reference chapter>>.
   
   == Declaring your source files
   
   Gradle뗩 {cpp} support uses a `ConfigurableFileCollection` directly from the link:{groovyDslPath}#[application] or link:{groovyDslPath}#[library] script block to configure the set of sources to compile.
   
   Libraries make a distinction between private (implementation details) and public (exported to consumer) headers.
   
   You can also configure sources for each binary build for those cases where sources are compiled only on certain target machines.
   
   .Sources and {cpp} compilation
   image::cpp-sourcesets-compilation.png[]
   
   Test sources are configured on each test suite script block. See <<cpp_testing.adoc#cpp_testing,Testing {cpp} projects>> chapter.
   
   == Managing your dependencies
   
   The vast majority of projects rely on other projects, so managing your project's dependencies is an important part of building any project.
   Dependency management is a big topic, so we will only focus on the basics for {cpp} projects here.
   If you뗛 like to dive into the details, check out the <<core_dependency_management.adoc#dependency_management_in_gradle,introduction to dependency management>>.
   
   Gradle provides support for consuming pre-built binaries from Maven repositories published by Gradle footnote:[Unfortunately, Conan and Nuget repositories aren뗪 yet supported as core features].
   
   We will cover how to add dependencies between projects within a multi-build project.
   
   Specifying dependencies for your {cpp} project requires two pieces of information:
   
    * Identifying information for the dependency (project path, Maven GAV)
    * What it뗩 needed for, e.g. compilation, linking, runtime or all of the above.
   
   This information is specified in a `dependencies {}` block of the {cpp} `application` or `library` script block.
   For example, to tell Gradle that your project requires library `common` to compile and link your production code, you can use the following fragment:
   
   .Declaring dependencies
   ====
   include::sample[dir="snippets/cpp/basic/kotlin",files="build.gradle.kts[tags=cpp-dependency-mgmt]"]
   include::sample[dir="snippets/cpp/basic/groovy",files="build.gradle[tags=cpp-dependency-mgmt]"]
   ====
   
   The Gradle terminology for the three elements is as follows:
   
    * _Configuration_ (ex: `implementation`) - a named collection of dependencies, grouped together for a specific goal such as compiling or linking a module
    * _Project reference_ (ex: `project(':common')`) - the project referenced by the specified path
   
   You can find a more comprehensive glossary of dependency management terms <<dependency_management_terminology.adoc#dependency_management_terminology,here>>.
   
   As far as configurations go, the main ones of interest are:
   
    * `implementation` - used for compilation, linking and runtime
    * `cppCompile__Variant__` - for dependencies that are necessary to compile your production code but shouldn뗪 be part of the linking or runtime process
    * `nativeLink__Variant__` - for dependencies that are necessary to link your code but shouldn뗪 be part of the compilation or runtime process
    * `nativeRuntime__Variant__` - for dependencies that are necessary to run your component but shouldn뗪 be part of the compilation or linking process
   
   You can learn more about these and how they relate to one another in the <<plugin_reference.adoc#native_languages,native plugin reference chapter>>.
   
   Be aware that the <<cpp_library_plugin.adoc#cpp_library_plugin,{cpp} Library Plugin>> creates an additional configuration  `api`  for dependencies that are required for compiling and linking both the module and any modules that depend on it.
   
   We have only scratched the surface here, so we recommend that you read the <<core_dependency_management.adoc#dependency_management_in_gradle,dedicated dependency management chapters>> once youre comfortable with the basics of building {cpp} projects with Gradle.
   
   Some common scenarios that require further reading include:
   
    * Defining a custom <<declaring_repositories.adoc#sec:maven_repo,Maven-compatible>> repository
    * Declaring dependencies with <<dynamic_versions.adoc#sub:declaring_dependency_with_changing_version,changing>> (e.g. SNAPSHOT) and <<dynamic_versions.adoc#sub:declaring_dependency_with_dynamic_version,dynamic>> (range) versions
    * Declaring a sibling <<declaring_dependencies.adoc#sub:project_dependencies,project as a dependency>>
    * <<dependency_constraints.adoc#dependency-constraints,Controlling transitive dependencies and their versions>>
    * Testing your fixes to 3rd-party dependency via <<composite_builds.adoc#composite_builds,composite builds>> (a better alternative to publishing to and consuming from <<declaring_repositories.adoc#sub:maven_local,Maven Local>>)
   
   You뗣l discover that Gradle has a rich API for working with dependencies  one that takes time to master, but is straightforward to use for common scenarios.
   
   == Compiling and linking your code
   Compiling both your code can be trivially easy if you follow the conventions:
   
   1. Put your source code under the _src/main/cpp_ directory
   2. Declare your compile dependencies in the `implementation` configurations (see the previous section)
   3. Run the `assemble` task
   
   We recommend that you follow these conventions wherever possible, but you don뗪 have to.
   
   There are several options for customization, as you뗣l see next.
   
   NOTE: All link:{groovyDslPath}#[CppCompile] tasks are incremental and cacheable.
   
   === Supported tool chain
   
   Gradle offers the ability to execute the same build using different tool chains.
   When you build a native binary, Gradle will attempt to locate a tool chain installed on your machine that can build the binary.
   Gradle select the first tool chain that can build for the target operating system and architecture.
   In the future, Gradle will consider source and ABI compatibility when selecting a tool chain.
   
   Gradle has general support for the three major tool chains on major operating system: Clang footnote:[Installed with Xcode on macOS], GCC footnote:[Installed through Cygwin and MinGW for 32- and 64-bits architecture on Windows] and Visual {cpp} footnote:[Installed with Visual Studio 2010 to 2019] (Windows-only).
   GCC and Clang installed using Macports and Homebrew have been reported to work fine, but this isn뗪 tested continuously.
   
   ==== Windows
   
   To build on Windows, install a compatible version of Visual Studio.
   The {cpp} plugins will discover the Visual Studio installations and select the latest version.
   There is no need to mess around with environment variables or batch scripts.
   This works fine from a Cygwin shell or the Windows command-line.
   
   Alternatively, you can install Cygwin or MinGW with GCC.
   Clang is currently not supported.
   
   ==== macOS
   
   To build on macOS, you should install Xcode.
   The {cpp} plugins will discover the Xcode installation using the system PATH.
   
   The {cpp} plugins also work with GCC and Clang installed with Macports or Homebrew footnote:[Macports and Homebrew installation of GCC and Clang is not officially supported].
   To use one of the Macports or Homebrew, you will need to add Macports/Homebrew to the system PATH.
   
   ==== Linux
   
   To build on Linux, install a compatible version of GCC or Clang.
   The {cpp} plugins will discover GCC or Clang using the system PATH.
   
   === Customizing file and directory locations
   
   Imagine you have a legacy library project that uses an _src_ directory for the production code and private headers and _include_ directory for exported headers.
   The conventional directory structure won뗪 work, so you need to tell Gradle where to find the source and header files.
   You do that via the `application` or `library` script block.
   
   Each component script block, as well as each binary, defines where it뗩 source code resides.
   You can override the convention values by using the following syntax:
   
   .Setting {cpp} source set
   ====
   include::sample[dir="snippets/cpp/basic/kotlin/common",files="build.gradle.kts[tags=cpp-source-set]"]
   include::sample[dir="snippets/cpp/basic/groovy/common",files="build.gradle[tags=cpp-source-set]"]
   ====
   
   Now Gradle will only search directly in _src_ for the source and private headers and in _include_ for public headers.
   
   === Changing compiler and linker options
   
   Most of the compiler and linker options are accessible through the corresponding task, such as `compile__Variant__Cpp`, `link__Variant__` and `create__Variant__`.
   These tasks are of type link:{groovyDslPath}#[CppCompile], link:{groovyDslPath}#[LinkSharedLibrary] and link:{groovyDslPath}#[CreateStaticLibrary] respectively.
   Read the task reference for an up-to-date and comprehensive list of the options.
   
   For example, if you want to change the warning level generated by the compiler for all variants, you can use this configuration:
   
   .Setting {cpp} compiler options for all variants
   ====
   include::sample[dir="snippets/cpp/basic/kotlin",files="build.gradle.kts[tags=cpp-compiler-options-all-variants]"]
   include::sample[dir="snippets/cpp/basic/groovy",files="build.gradle[tags=cpp-compiler-options-all-variants]"]
   ====
   
   It뗩 also possible to find the instance for a specific variant through the `BinaryCollection` on the `application` or `library` script block:
   
   .Setting {cpp} compiler options per variant
   ====
   include::sample[dir="snippets/cpp/basic/kotlin",files="build.gradle.kts[tags=cpp-compiler-options-per-variants]"]
   include::sample[dir="snippets/cpp/basic/groovy",files="build.gradle[tags=cpp-compiler-options-per-variants]"]
   ====
   
   === Selecting target machines
   
   By default, Gradle will attempt to create a {cpp} binary variant for the host operating system and architecture.
   It is possible to override this by specifying the set of `TargetMachine` on the `application` or `library` script block:
   
   .Setting target machines
   ====
   include::sample[dir="snippets/cpp/basic/kotlin",files="build.gradle.kts[tags=cpp-select-target-machines]"]
   include::sample[dir="snippets/cpp/basic/groovy",files="build.gradle[tags=cpp-select-target-machines]"]
   ====
   
   == Packaging and publishing
   
   How you package and potentially publish your {cpp} project varies greatly in the native world.
   Gradle comes with defaults, but custom packaging can be implemented without any issues.
   
    * Executable files are published directly to Maven repositories.
    * Shared and static library files are published directly to Maven repositories along with a zip of the public headers.
    * For applications, Gradle also supports installing and running the executable with all of its shared library dependencies in a known location.
   
   == Cleaning the build
   
   The {cpp} Application and Library Plugins add a `clean` task to you project by using the <<base_plugin.adoc#base_plugin,base plugin>>.
   This task simply deletes everything in the `layout.buildDirectory` directory, hence why you should always put files generated by the build in there.
   The task is an instance of Delete and you can change what directory it deletes by setting its `dir` property.
   
   == Building {cpp} libraries
   
   The unique aspect of library projects is that they are used (or "consumed") by other {cpp} projects.
   That means the dependency metadata published with the binaries and headers  in the form of Gradle Module Metadata  is crucial.
   In particular, consumers of your library should be able to distinguish between two different types of dependencies: those that are only required to compile your library and those that are also required to compile the consumer.
   
   Gradle manages this distinction via the <<cpp_library_plugin.adoc#cpp_library_plugin,{cpp} Library Plugin>>, which introduces an _api_ configuration in addition to the _implementation_ once covered in this chapter.
   If the types from a dependency appear as unresolved symbols of the static library or within the public headers then that dependency is exposed via your library뗩 public API and should, therefore, be added to the _api_ configuration.
   Otherwise, the dependency is an internal implementation detail and should be added to _implementation_.
   
   If youre unsure of the difference between an API and implementation dependency, the <<cpp_library_plugin.adoc#sec:cpp_library_api_vs_implementation,{cpp} Library Plugin>> chapter has a detailed explanation.
   In addition, you can see a basic, practical example of building a {cpp} library in the corresponding link:#[sample].
   
   == Building {cpp} applications
   
   See the <<cpp_application_plugin.adoc#cpp_application_plugin,{cpp} Application Plugin>> chapter for more details, but here뗩 a quick summary of what you get:
   
    * `install` create a directory containing everything needed to run it
    * Shell and Windows Batch scripts to start the application
   
   You can see a basic example of building a {cpp} application in the corresponding link:#[sample].

/docs/userguide/native/cpp_testing.adoc
=======================================

.. code-block::

   = Testing in C++ projects
   
   WARNING: The {cpp} testing support is not compatible with the <<configuration_cache.adoc#config_cache:plugins:core,configuration cache>>.
   
   Testing in the native ecosystem takes many forms.
   
   There are different testing libraries and frameworks, as well as many different types of test.
   All need to be part of the build, whether they are executed frequently or infrequently.
   This chapter is dedicated to explaining how Gradle handles differing requirements between and within builds, with significant coverage of how it integrates with the executable-based testing frameworks, such as https://github.com/google/googletest[Google Test].
   
   Testing C++ projects in Gradle is fairly limited when compared to <<java_testing.adoc#java_testing,Testing in Java & JVM projects>>. In this chapter, we explain the ways to control how tests are run (<<#sec:cpp_test_execution,Test execution>>).
   
   But first, we look at the basics of native testing in Gradle.
   
   == The basics
   
   All C++ testing revolves around a single task type: link:{groovyDslPath}#[RunTestExecutable].
   This runs a single test executable built with any testing framework and asserts the execution was successful using the exit code of the executable.
   The test case results aren뗪 collected and no reports are generated.
   
   In order to operate, the link:{groovyDslPath}#[RunTestExecutable] task type requires just one piece of information:
   
    * Where to find the built test executable (property: link:{groovyDslPath}#[RunTestExecutable.getExecutable()])
   
   When youre using the <<cpp_unit_test_plugin.adoc#cpp_unit_test_plugin,{cpp} Unit Test Plugin>> you will automatically get the following:
   
    * A dedicated link:{groovyDslPath}#[unitTest] extension for configuring test component and its variants
    * A `run` task of type link:{groovyDslPath}#[RunTestExecutable] that runs the test executable
   
   The test plugins configure the required pieces of information appropriately.
   In addition, they attach the `run` task to the `check` lifecycle task.
   It also create the `testImplementation` dependency configuration.
   Dependencies that are only needed for test compilation, linking and runtime may be added to this configuration.
   The `unitTest` script block behave similarly to a `application` or `library` script block.
   
   The link:{groovyDslPath}#[RunTestExecutable] task has many configuration options.
   We cover a number of them in the rest of the chapter.
   
   == Test execution
   
   Gradle executes tests in a separate (딵orked) process.
   
   You can control how the test process is launched via several properties on the link:{groovyDslPath}#[RunTestExecutable] task, including the following:
   
   `ignoreFailures` - default: false::
   If this property is `true`, Gradle will continue with the project뗩 build once the tests have completed, even if some of them have failed.
   Note that, by default, link:{groovyDslPath}#[RunTestExecutable] task type always executes every test that it detects, irrespective of this setting.
   
   See link:{groovyDslPath}#[RunTestExecutable] for details on all the available configuration options.

/docs/userguide/native/building_swift_projects.adoc
===================================================

.. code-block::

   = Building Swift projects
   
   WARNING: The plugins described in this chapter are not compatible with the <<configuration_cache.adoc#config_cache:plugins:core,configuration cache>>.
   
   Gradle uses a convention-over-configuration approach to building native projects.
   If you are coming from another native build system, these concepts may be unfamiliar at first, but they serve a purpose to simplify build script authoring.
   
   We will look at Swift projects in detail in this chapter, but most of the topics will apply to other supported native languages as well.
   // TODO: Uncomment when Swift tutorial are released
   //If you don뗪 have much experience with building native projects with Gradle, take a look at the Swift tutorials for step-by-step instructions on how to build various types of basic Swift projects as well as some common use cases.
   
   == Introduction
   
   The simplest build script for a Swift project applies the Swift application plugin or the Swift library plugin and optionally sets the project version:
   
   .Applying the Swift Plugin
   ====
   include::sample[dir="snippets/swift/basic/kotlin",files="build.gradle.kts[tags=apply-swift-plugin]"]
   include::sample[dir="snippets/swift/basic/groovy",files="build.gradle[tags=apply-swift-plugin]"]
   ====
   
   By applying either of the Swift plugins, you get a whole host of features:
   
    * `compileDebugSwift` and `compileReleaseSwift` tasks that compiles the Swift source files under _src/main/swift_ for the well-known debug and release build types, respectively.
    * `linkDebug` and `linkRelease` tasks that link the compiled Swift object files into an executable for applications or shared library for libraries with shared linkage for the debug and release build types.
    * `createDebug` and `createRelease` tasks that assemble the compiled Swift object files into a static library for libraries with static linkage for the debug and release build types.
   
   For any non-trivial Swift project, you뗣l probably have some file dependencies and additional configuration specific to _your_ project.
   
   The Swift plugins also integrates the above tasks into the standard <<base_plugin#sec:base_tasks,lifecycle tasks>>.
   The task that produces the development binary is attached to `assemble`.
   By default, the development binary is the debug variant.
   
   The rest of the chapter explains the different ways to customize the build to your requirements when building libraries and applications.
   
   // TODO Split this to put in common with the C++
   == Introducing build variants
   
   Native projects can typically produce several different binaries, such as debug or release ones, or ones that target particular platforms and processor architectures.
   Gradle manages this through the concepts of _dimensions_ and _variants_.
   
   A dimension is simply a category, where each category is orthogonal to the rest.
   For example, the "build type" dimension is a category that includes debug and release.
   The "architecture" dimension covers processor architectures like x86-64 and x86.
   
   A variant is a combination of values for these dimensions, consisting of exactly one value for each dimension.
   You might have a "debug x86-64" or a "release x86" variant.
   
   Gradle has built-in support for several dimensions and several values within each dimension.
   You can find a list of them in the <<plugin_reference.adoc#native_languages,native plugin reference chapter>>.
   
   == Declaring your source files
   
   Gradle뗩 Swift support uses a `ConfigurableFileCollection` directly from the link:{groovyDslPath}#[application] or link:{groovyDslPath}#[library] script block to configure the set of sources to compile.
   
   // TODO figure this out
   Libraries make a distinction between private (implementation details) and public (exported to consumer) headers.
   
   You can also configure sources for each binary build for those cases where sources are compiled only on certain target machines.
   
   .Sources and Swift compilation
   image::swift-sourcesets-compilation.png[]
   
   // TODO once we have the testing chapter
   //Test sources are configured on each test suite script block. See <<swift_testing.adoc#swift_testing,Testing Swift projects>> chapter.
   
   == Managing your dependencies
   
   The vast majority of projects rely on other projects, so managing your project's dependencies is an important part of building any project.
   Dependency management is a big topic, so we will only focus on the basics for Swift projects here.
   If you뗛 like to dive into the details, check out the <<core_dependency_management.adoc#dependency_management_in_gradle,introduction to dependency management>>.
   
   Gradle provides support for consuming pre-built binaries from Maven repositories published by Gradle footnote:[Unfortunately, Cocoapods repositories aren뗪 yet supported as core features].
   
   We will cover how to add dependencies between projects within a multi-build project.
   
   Specifying dependencies for your Swift project requires two pieces of information:
   
    * Identifying information for the dependency (project path, Maven GAV)
    * What it뗩 needed for, e.g. compilation, linking, runtime or all of the above.
   
   This information is specified in a `dependencies {}` block of the Swift `application` or `library` script block.
   For example, to tell Gradle that your project requires library `common` to compile and link your production code, you can use the following fragment:
   
   .Declaring dependencies
   ====
   include::sample[dir="snippets/swift/basic/kotlin",files="build.gradle.kts[tags=swift-dependency-mgmt]"]
   include::sample[dir="snippets/swift/basic/groovy",files="build.gradle[tags=swift-dependency-mgmt]"]
   ====
   
   The Gradle terminology for the three elements is as follows:
   
    * _Configuration_ (ex: `implementation`) - a named collection of dependencies, grouped together for a specific goal such as compiling or linking a module
    * _Project reference_ (ex: `project(':common')`) - the project referenced by the specified path
   
   You can find a more comprehensive glossary of dependency management terms <<dependency_management_terminology.adoc#dependency_management_terminology,here>>.
   
   As far as configurations go, the main ones of interest are:
   
    * `implementation` - used for compilation, linking and runtime
    * `swiftCompile__Variant__` - for dependencies that are necessary to compile your production code but shouldn뗪 be part of the linking or runtime process
    * `nativeLink__Variant__` - for dependencies that are necessary to link your code but shouldn뗪 be part of the compilation or runtime process
    * `nativeRuntime__Variant__` - for dependencies that are necessary to run your component but shouldn뗪 be part of the compilation or linking process
   
   You can learn more about these and how they relate to one another in the <<plugin_reference.adoc#native_languages,native plugin reference chapter>>.
   
   Be aware that the <<swift_library_plugin.adoc#swift_library_plugin,Swift Library Plugin>> creates an additional configuration  `api`  for dependencies that are required for compiling and linking both the module and any modules that depend on it.
   
   We have only scratched the surface here, so we recommend that you read the <<core_dependency_management.adoc#dependency_management_in_gradle,dedicated dependency management chapters>> once youre comfortable with the basics of building Swift projects with Gradle.
   
   Some common scenarios that require further reading include:
   
    * Defining a custom <<declaring_repositories.adoc#sec:repository-types,Maven-compatible>> repository
    * Declaring dependencies with <<dynamic_versions.adoc#sub:declaring_dependency_with_changing_version,changing>> (e.g. SNAPSHOT) and <<dynamic_versions.adoc#sub:declaring_dependency_with_dynamic_version,dynamic>> (range) versions
    * Declaring a sibling <<declaring_dependencies.adoc#sub:project_dependencies,project as a dependency>>
    * <<dependency_constraints.adoc#dependency-constraints,Controlling transitive dependencies and their versions>>
    * Testing your fixes to 3rd-party dependency via <<composite_builds.adoc#composite_builds,composite builds>> (a better alternative to publishing to and consuming from <<declaring_repositories.adoc#sub:maven_local,Maven Local>>)
   
   You뗣l discover that Gradle has a rich API for working with dependencies  one that takes time to master, but is straightforward to use for common scenarios.
   
   == Compiling and linking your code
   Compiling both your code can be trivially easy if you follow the conventions:
   
   1. Put your source code under the _src/main/swift_ directory
   2. Declare your compile dependencies in the `implementation` configurations (see the previous section)
   3. Run the `assemble` task
   
   We recommend that you follow these conventions wherever possible, but you don뗪 have to.
   
   There are several options for customization, as you뗣l see next.
   
   NOTE: All link:{groovyDslPath}#[SwiftCompile] tasks are incremental and cacheable.
   
   === Supported tool chain
   
   Gradle support the https://swift.org/download/[official Swift tool chain for macOS and Linux].
   When you build a native binary, Gradle will attempt to locate a tool chain installed on your machine that can build the binary.
   Gradle select the first tool chain that can build for the target operating system, architecture and Swift language support.
   
   NOTE: For Linux users, Gradle will discover the tool chain using the system PATH.
   
   === Customizing file and directory locations
   
   Imagine you are migrating a library project that follows the Swift Package Manager layout (e.g. `Sources/__ModuleName___` directory for the production code).
   The conventional directory structure won뗪 work, so you need to tell Gradle where to find the source files.
   You do that via the `application` or `library` script block.
   
   Each component script block, as well as each binary, defines where it뗩 source code resides.
   You can override the convention values by using the following syntax:
   
   .Setting Swift source set
   ====
   include::sample[dir="snippets/swift/basic/kotlin/common",files="build.gradle.kts[tags=swift-source-set]"]
   include::sample[dir="snippets/swift/basic/groovy/common",files="build.gradle[tags=swift-source-set]"]
   ====
   
   Now Gradle will only search directly in _Sources/Common_ for the source.
   
   === Changing compiler and linker options
   
   Most of the compiler and linker options are accessible through the corresponding task, such as `compile__Variant__Swift`, `link__Variant__` and `create__Variant__`.
   These tasks are of type link:{groovyDslPath}#[SwiftCompile], link:{groovyDslPath}#[LinkSharedLibrary] and link:{groovyDslPath}#[CreateStaticLibrary] respectively.
   Read the task reference for an up-to-date and comprehensive list of the options.
   
   For example, if you want to change the warning level generated by the compiler for all variants, you can use this configuration:
   
   .Setting Swift compiler options for all variants
   ====
   include::sample[dir="snippets/swift/basic/kotlin",files="build.gradle.kts[tags=swift-compiler-options-all-variants]"]
   include::sample[dir="snippets/swift/basic/groovy",files="build.gradle[tags=swift-compiler-options-all-variants]"]
   ====
   
   It뗩 also possible to find the instance for a specific variant through the `BinaryCollection` on the `application` or `library` script block:
   
   .Setting Swift compiler options per variant
   ====
   include::sample[dir="snippets/swift/basic/kotlin",files="build.gradle.kts[tags=swift-compiler-options-per-variants]"]
   include::sample[dir="snippets/swift/basic/groovy",files="build.gradle[tags=swift-compiler-options-per-variants]"]
   ====
   
   === Selecting target machines
   
   By default, Gradle will attempt to create a Swift binary variant for the host operating system and architecture.
   It is possible to override this by specifying the set of `TargetMachine` on the `application` or `library` script block:
   
   .Setting target machines
   ====
   include::sample[dir="snippets/swift/basic/kotlin",files="build.gradle.kts[tags=swift-select-target-machines]"]
   include::sample[dir="snippets/swift/basic/groovy",files="build.gradle[tags=swift-select-target-machines]"]
   ====
   
   == Packaging and publishing
   
   How you package and potentially publish your Swift project varies greatly in the native world.
   Gradle comes with defaults, but custom packaging can be implemented without any issues.
   
    * Executable files are published directly to Maven repositories.
    * Shared and static library files are published directly to Maven repositories along with a zip of the public headers.
    * For applications, Gradle also supports installing and running the executable with all of its shared library dependencies in a known location.
   
   == Cleaning the build
   
   The Swift Application and Library Plugins add a `clean` task to you project by using the <<base_plugin.adoc#base_plugin,base plugin>>.
   This task simply deletes everything in the `layout.buildDirectory` directory, hence why you should always put files generated by the build in there.
   The task is an instance of Delete and you can change what directory it deletes by setting its `dir` property.
   
   == Building Swift libraries
   
   The unique aspect of library projects is that they are used (or "consumed") by other Swift projects.
   That means the dependency metadata published with the binaries and headers  in the form of Gradle Module Metadata  is crucial.
   In particular, consumers of your library should be able to distinguish between two different types of dependencies: those that are only required to compile your library and those that are also required to compile the consumer.
   
   Gradle manages this distinction via the <<swift_library_plugin.adoc#swift_library_plugin,Swift Library Plugin>>, which introduces an _api_ configuration in addition to the _implementation_ once covered in this chapter.
   If the types from a dependency appear as unresolved symbols of the static library or within the public headers then that dependency is exposed via your library뗩 public API and should, therefore, be added to the _api_ configuration.
   Otherwise, the dependency is an internal implementation detail and should be added to _implementation_.
   
   If youre unsure of the difference between an API and implementation dependency, the <<swift_library_plugin.adoc#sec:swift_library_api_vs_implementation,Swift Library Plugin>> chapter has a detailed explanation.
   In addition, you can see a basic, practical example of building a Swift library in the corresponding link:#[sample].
   
   == Building Swift applications
   
   See the <<swift_application_plugin.adoc#swift_application_plugin,Swift Application Plugin>> chapter for more details, but here뗩 a quick summary of what you get:
   
    * `install` create a directory containing everything needed to run it
    * Shell and Windows Batch scripts to start the application
   
   You can see a basic example of building a Swift application in the corresponding link:#[sample].

/docs/userguide/native/swift_testing.adoc
=========================================

.. code-block::

   = Testing in Swift projects
   
   WARNING: The Swift testing support is not compatible with the <<configuration_cache.adoc#config_cache:plugins:core,configuration cache>>.
   
   Testing in the native ecosystem is a rich subject matter.
   There are many different testing libraries and frameworks, as well as many different types of test.
   All need to be part of the build, whether they are executed frequently or infrequently.
   This chapter is dedicated to explaining how Gradle handles differing requirements between and within builds, with significant coverage of how it integrates with XCTest on both macOS and Linux.
   
   It explains:
   - Ways to control how the tests are run (Test execution)
   - How to select specific tests to run (Test filtering)
   - What test reports are generated and how to influence the process (Test reporting)
   - How Gradle finds tests to run (Test detection)
   
   But first, we look at the basics of native testing in Gradle.
   
   == The basics
   
   Gradle supports deep integration with XCTest testing framework for the Swift language and revolves around the link:{groovyDslPath}#[XCTest] task type.
   This runs a collection of test cases using the https://developer.apple.com/documentation/xctest[Xcode XCTest] on macOS or the https://github.com/apple/swift-corelibs-xctest[open source Swift core library alternative] on Linux and collates the results.
   You can then turn those results into a report via an instance of the link:{groovyDslPath}#[TestReport] task type.
   
   In order to operate, the link:{groovyDslPath}#[XCTest] task type requires three pieces of information:
   - Where to find the built testable bundle (on macOS) or executable (on Linux) (property: link:{groovyDslPath}#[XCTest.getTestInstalledDirectory()])
   - The run script for executing the bundle or executable (property: link:{groovyDslPath}#[XCTest.getRunScriptFile()])
   - The working directory to execution the bundle or executable (property: link:{groovyDslPath}#[XCTest.getWorkingDirectory()])
   
   When youre using the <<xctest_plugin.adoc#xctest_plugin,XCTest Plugin>> you will automatically get the following:
   - A dedicated `xctest` extension of type link:{groovyDslPath}#[SwiftXCTestSuite] for configuring test component and its variants
   - A `xcTest` task of type link:{groovyDslPath}#[XCTest] that runs those unit tests
   - A testable bundle or executable linked with the main component뗩 object files
   
   The test plugins configure the required pieces of information appropriately.
   In addition, they attach the `xcTest` or `run` task to the `check` lifecycle task.
   It also create the `testImplementation` dependency configuration.
   Dependencies that are only needed for test compilation, linking and runtime may be added to this configuration.
   The `xctest` script block behave similarly to a `application` or `library` script block.
   
   The link:{groovyDslPath}#[XCTest] task has many configuration options.
   We cover a significant number of them in the rest of the chapter.
   
   == Test execution
   
   Gradle executes tests in a separate (딵orked) process.
   
   You can control how the test process is launched via several properties on the link:{groovyDslPath}#[XCTest] task, including the following:
   
   `ignoreFailures` - default: false::
   If this property is `true`, Gradle will continue with the project뗩 build once the tests have completed, even if some of them have failed.
   Note that, by default, both task type always executes every test that it detects, irrespective of this setting.
   
   `testLogging` - default: not set::
   This property represents a set of options that control which test events are logged and at what level.
   You can also configure other logging behavior via this property.
   Set link:{javadocPath}#[TestLoggingContainer] for more detail.
   
   See link:{groovyDslPath}#[XCTest] for details on all the available configuration options.
   
   == Test filtering
   It뗩 a common requirement to run subsets of a test suite, such as when youre fixing a bug or developing a new test case.
   Gradle provides filtering to do this.
   You can select tests to run based on:
   
   - A simple class name or method name, e.g. `SomeTest`, `SomeTest.someMethod`
   - * wildcard matching
   
   You can enable filtering either in the build script or via the `--tests` command-line option.
   Here뗩 an example of some filters that are applied every time the build runs:
   
   .Filter tests on every build
   ====
   include::sample[dir="snippets/swift/testFiltering/kotlin",files="build.gradle.kts[tags=test-filtering]"]
   include::sample[dir="snippets/swift/testFiltering/groovy",files="build.gradle[tags=test-filtering]"]
   ====
   
   For more details and examples of declaring filters in the build script, please see the TestFilter reference.
   
   The command-line option is especially useful to execute a single test method.
   It is also possible to supply multiple `--tests` options, all of whose patterns will take effect.
   The following sections have several examples of using command-line option.
   
   NOTE: The test filtering only support XCTest compatible filters at the moment.
   It means the same filter will differ between macOS and Linux.
   On macOS, the bundle base name needs to be prepended to the filter, e.g. `TestBundle.SomeTest`, `TestBundle.SomeTest.someMethod`
   See the <<#sec:swift_test_filtering_simple_name_pattern,Simple name pattern>> section below for more information about valid filtering pattern.
   
   The following section looks at the specific cases of simple class/method names.
   
   === Simple name pattern
   
   Gradle support simple class name, or a class name + method name test filtering.
   For example, the following command lines run either all or exactly one of the tests in the `SomeTestClass` test case:
   
   ```
   # Executes all tests in SomeTestClass
   gradle xcTest --tests SomeTestClass
   # or `gradle xcTest --tests TestBundle.SomeTestClass` on macOS
   
   # Executes a single specified test in SomeTestClass
   gradle xcTest --tests TestBundle.SomeTestClass.someSpecificMethod
   # or `gradle xcTest --tests TestBundle.SomeTestClass.someSpecificMethod` on macOS
   ```
   
   You can also combine filters defined at the command line with <<command_line_interface.adoc#sec:continuous_build,continuous build>> to re-execute a subset of tests immediately after every change to a production or test source file.
   The following executes all tests in the SomeTestClass test class whenever a change triggers the tests to run:
   
   ```
   gradle test --continuous --tests SomeTestClass
   ```
   
   == Test reporting
   The link:{groovyDslPath}#[XCTest] task generates the following results by default:
   
   - An HTML test report
   - XML test results in a format compatible with the Ant JUnit report task - one that is supported by many other tools, such as CI servers
   - An efficient binary format of the results used by the `XCTest` task to generate the other formats
   
   In most cases, you뗣l work with the standard HTML report, which automatically includes the result from your `XCTest` tasks.
   
   There is also a standalone link:{groovyDslPath}#[TestReport] task type that you can use to generate a custom HTML test report.
   All it requires are a value for `destinationDir` and the test results you want included in the report.
   Here is a sample which generates a combined report for the unit tests from all subprojects:
   
   .Combine test reports from all subprojects
   ====
   include::sample[dir="snippets/swift/testReport/kotlin",files="buildSrc/src/main/kotlin/myproject.xctest-conventions.gradle.kts[tags=test-report];build.gradle.kts[tags=test-report]"]
   include::sample[dir="snippets/swift/testReport/groovy",files="buildSrc/src/main/groovy/myproject.xctest-conventions.gradle[tags=test-report];build.gradle[tags=test-report]"]
   ====
   
   In this example, we use a convention plugin `myproject.xctest-conventions` to expose the test results from a project to Gradle's <<variant_model.adoc#understanding-variant-selection,variant aware dependency management engine>>.
   
   The plugin declares a consumable `binaryTestResultsElements` configuration that represents the binary test results of the `test` task.
   In the aggregation project's build file, we declare the `testReportData` configuration and depend on all of the projects that we want to aggregate the results from. Gradle will automatically select the binary test result variant from each of the subprojects instead of the project's jar file.
   Lastly, we add a `testReport` task that aggregates the test results from the `testResultsDirs` property, which contains all of the binary test results resolved from the `testReportData` configuration.
   
   You should note that the link:{groovyDslPath}#[TestReport] type combines the results from multiple test tasks and needs to aggregate the results of individual test classes.
   This means that it a given test class is executed by multiple test tasks, then the test report will include executions of that class, but it can be hard to distinguish individual executions of that class and their output.

/Topic: 游댯 Gradle On CI
=========================


/docs/userguide/reference/ci-systems/jenkins.adoc
=================================================

.. code-block::

   = Executing Gradle builds on Jenkins
   
   TIP: Top engineering teams using Jenkins have been able to reduce CI build time by up to 90% by using the Gradle Build Cache. https://gradle.org/training/#build-cache-deep-dive[Register here] for our Build Cache training session to learn how your team can achieve similar results.
   
   Building Gradle projects doesn't stop with the developer's machine.
   https://en.wikipedia.org/wiki/Continuous_integration[Continuous Integration] (CI) has been a long-established practice for running a build for every single change committed to version control to tighten the feedback loop.
   
   In this guide, we'll discuss how to configure link:https://jenkins.io/[Jenkins] for a typical Gradle project.
   
   == What you'll need
   
   * A text editor
   * A command prompt
   * The Java Development Kit (JDK), version 1.7 or higher
   * A Jenkins installation (setup steps explained in this post)
   
   == Setup a typical project
   
   As example, this guide is going to focus on a Java-based project.
   More specifically, a Gradle plugin written in Java and tested with https://www.spekframework.org/[Spek].
   First, we'll get the project set up on your local machine before covering the same steps on CI.
   
   Just follow these steps:
   
   === Clone the https://github.com/gradle/gradle-site-plugin[Gradle Site Plugin] repository
   
   [listing.terminal.sample-command]
   ----
   $ git clone https://github.com/gradle/gradle-site-plugin.git
   Cloning into 'gradle-site-plugin'...
   $ cd gradle-site-plugin
   ----
   
   === Build the project
   
   As a developer of a Java project, you'll typical want to compile the source code, run the tests and assemble the JAR artifact. That's no different for Gradle plugins. The following command achieves exactly that:
   
   [listing.terminal.sample-command]
   ----
   $ ./gradlew build
   
   BUILD SUCCESSFUL
   14 actionable tasks: 14 executed
   ----
   
   The project provides the <<gradle_wrapper.adoc#gradle_wrapper_reference,Gradle Wrapper>> as part of the repository.
   It is a recommended practice for any Gradle project as it enables your project to built on CI without having to install the Gradle runtime.
   
   === Build scan integration
   
   The sample project is equipped with support for generating https://scans.gradle.com/[build scans].
   Running the build with the command line option `--scan` renders a link in the console.
   
   [listing.terminal.sample-command]
   ----
   $ ./gradlew build --scan
   
   Publishing build scan...
   https://gradle.com/s/7mtynxxmesdio
   ----
   
   The following section will describe how to build the project with the help of Jenkins.
   
   == Setup Jenkins
   
   Jenkins is one of the most prominent players in the field.
   In the course of this section, you'll learn how to set up Jenkins, configure a job to pull the source code from GitHub and run the Gradle build.
   
   === Install and start Jenkins
   
   On the https://jenkins.io/download/[Jenkins website] you can pick from a variety of distributions.
   This post uses the runnable WAR file.
   A simple Java command brings up the Jenkins server.
   
   // TODO: this block will start a background process not handled by the content testing
   [listing.terminal]
   ----
   $ wget https://mirrors.jenkins.io/war-stable/latest/jenkins.war
   $ java -jar jenkins.war
   ----
   
   In the browser, navigate to `localhost` with port `8080` to render the Jenkins dashboard.
   You will be asked to set up an new administration user and which plugins to install.
   
   === Installation of plugins
   
   Confirm to install the recommended plugins when starting Jenkins for the first time.
   Under "Manage Jenkins > Manage Plugins" ensure that you have the following two plugins installed.
   
   * https://plugins.jenkins.io/git[Git plugin]
   * https://plugins.jenkins.io/gradle[Gradle plugin]
   
   Next, we can set up the job for building the project.
   
   == Create a Jenkins job
   
   Setting up a new Gradle job can be achieved with just a couple of clicks.
   From the left navigation bar select "New Item > Freestyle project".
   Enter a new name for the project. We'll pick "gradle-site-plugin" for the project.
   
   Select the radio button "Git" in the section "Source Code Management".
   Enter the URL of the GitHub repository: `https://github.com/gradle/gradle-site-plugin.git`.
   
   image::ci-systems/jenkins-scm.png[]
   
   Furthermore, create a "Build step" in the section "Build" by selecting "Invoke Gradle script".
   As mentioned before, we'll want to use the Wrapper to execute the build. In the "Tasks" input box enter the `build` and use the "Switches" `--scan -s` to generate a build scan and render a stack trace in case of a build failure.
   
   image::ci-systems/jenkins-build-step.png[]
   
   === Execute the job
   
   Save the configuration of job and execute an initial build by triggering the "Build Now" button.
   The build should finish successfully and render a "Gradle Build Scan" icon that brings you directly to the link:https://scans.gradle.com[build scan] for the given build.
   
   image::ci-systems/jenkins-build-scan.png[align=center]
   
   There are various options to trigger Jenkins builds continuously: from polling the repository periodically, to building on a set schedule, or via callback URL.
   
   == Further reading
   
   You can learn more about advanced Jenkins usage through these resources:
   
   * https://jenkins.io/doc/book/using/using-credentials/[Using credentials with Jenkins]
   * https://jenkins.io/solutions/pipeline/[Pipeline as code with Jenkins]
   * https://bmuschko.com/blog/jenkins-build-pipeline/[Modelling a Continuous Deployment pipeline for a Spring Boot application]
   
   == Summary
   
   Executing Gradle builds on CI can be set up and configured with just a handful of steps.
   The benefit of receiving fast feedback clearly speaks for itself.
   If you are not using Jenkins, no problem, many CI products tightly integrate with Gradle as a first-class citizen.
   

/docs/userguide/reference/ci-systems/teamcity.adoc
==================================================

.. code-block::

   = Executing Gradle builds on TeamCity
   
   TIP: Top engineering teams using TeamCity have been able to reduce CI build time by up to 90% by using the Gradle Build Cache. https://gradle.org/training/#build-cache-deep-dive[Register here] for our Build Cache training session to learn how your team can achieve similar results.
   
   Building Gradle projects doesn't stop with the developer's machine.
   https://en.wikipedia.org/wiki/Continuous_integration[Continuous Integration] (CI) has been a long-established practice for running a build for every single change committed to version control to tighten the feedback loop.
   
   In this guide, we'll discuss how to configure link:https://www.jetbrains.com/teamcity/[TeamCity] for a typical Gradle project.
   
   
   == What you'll need
   
   * A command prompt
   * The Java Development Kit (JDK), version 1.8 or higher
   * A TeamCity installation (setup steps explained in this guide)
   
   
   == Setup a typical project
   
   For demonstration purposes, this guide is going to focus on building a Java-based project; however, this setup will work with any Gradle-compatible project.
   More specifically, a Gradle plugin written in Java and tested with https://www.spekframework.org/[Spek].
   First, we'll get the project set up on your local machine before covering the same steps on CI.
   
   Just follow these steps:
   
   === Clone the https://github.com/gradle/gradle-site-plugin[Gradle Site Plugin] repository
   
   [listing.terminal.sample-command]
   ----
   $ git clone https://github.com/gradle/gradle-site-plugin.git
   Cloning into 'gradle-site-plugin'...
   $ cd gradle-site-plugin
   ----
   
   === Build the project
   
   As a developer of a Java project, you'll typical want to compile the source code, run the tests and assemble the JAR artifact. That's no different for Gradle plugins. The following command achieves exactly that:
   
   [listing.terminal.sample-command]
   ----
   $ ./gradlew build
   
   BUILD SUCCESSFUL
   14 actionable tasks: 14 executed
   ----
   
   The project provides the <<gradle_wrapper.adoc#gradle_wrapper_reference,Gradle Wrapper>> as part of the repository.
   It is a recommended practice for any Gradle project as it enables your project to built on CI without having to install the Gradle runtime.
   
   === Build scan integration
   
   The sample project is equipped with support for generating https://scans.gradle.com/[build scans].
   Running the build with the command line option `--scan` renders a link in the console.
   
   [listing.terminal.sample-command]
   ----
   $ ./gradlew build --scan
   Publishing build scan...
   https://gradle.com/s/7mtynxxmesdio
   ----
   
   
   == Setup TeamCity
   
   JetBrains TeamCity is a powerful and user-friendly Continuous Integration and Deployment server that works out of the box.
   JetBrains offers several licensing options that allow you to scale TeamCity to your needs.
   In this setup, we'll use TeamCity Professional, a free fully functional edition suitable for average projects.
   In the course of this section, you'll learn how to set up TeamCity, create a build configuration to pull the source code from GitHub and run the Gradle build.
   
   === Install and start TeamCity
   
   On the https://www.jetbrains.com/teamcity/download/[TeamCity website] you can pick from a variety of distributions.
   This post uses TeamCity bundled with Tomcat servlet container and covers the evaluation setup of a TeamCity server and a default build agent running on the same machine.
   
   [start=1]
   . Make sure you have JRE or JDK installed and the JAVA_HOME environment variable is pointing to the Java installation directory. Oracle Java 1.8 JDK is required.
   . Download TeamCity .tar.gz distribution.
   Unpack the `TeamCity<version number>.tar.gz` archive, for example, using the WinZip, WinRar or a similar utility under Windows, or the following command under Linux or macOS:
   
   [listing]
   ----
   tar xfz TeamCity<version number>.tar.gz
   ----
   
   [start=3]
   . Start the TeamCity server and one default agent at the same time, using the runAll script provided in the <TeamCity home>/bin directory, e.g.
   
   [listing]
   ----
   runAll.sh start
   ----
   
   [start=4]
   . To access the TeamCity Web UI, navigate to `\http://localhost:8111/`. Follow the defaults of the TeamCity setup. You will be asked to set up a new administration user.
   
   Next, we can set up the project and run a build in TeamCity.
   
   
   == Create a TeamCity build
   
   Setting up a new Gradle build in TeamCity requires just a few clicks:
   TeamCity comes bundled with a Gradle plugin, so you do not need to install plugins additionally. However, it is recommended that you install the https://plugins.jetbrains.com/plugin/9326-gradle-build-scan-integration[TeamCity Build Scan plugin].
   
   On the *Administration | Projects* page click _Create project_,
   use the option _From the repository URL_ and enter the URL of the GitHub repository: `https://github.com/gradle/gradle-site-plugin.git`.
   
   image::ci-systems/teamcity-create-project.png[]
   
   
   Follow the _Create Project_ wizard,
   it will prompt for the project and build configuration name and automatically detect build steps.
   Select the automatically Gradle build step and click _Use selected_:
   
   image::ci-systems/teamcity-build-step.png[]
   
   The build step is added to the build configuration:
   
   image::ci-systems/teamcity-step-added.png[]
   
   Click _Edit_, on the page that opens click _Advanced options_.
   Using the Wrapper to execute the build is considered good practice with Gradle,
   and on automatic detection this option is selected by default.
   We뗣l want to generate a build scan,
   so we뗣l enter the `--scan` option in _Additional Gradle command line parameters_ field.
   
   image::ci-systems/teamcity-scan.png[]
   
   Save the settings and were ready to run the build.
   
   === Run the build in TeamCity
   Click the _Run_ button in the right top corner:
   
   image::ci-systems/teamcity-step-upd.png[]
   
   TeamCity will start the build and you뗣l be able to view the build progress
   by clicking _Build Configuration Home_.
   When the build is finished, you can review the build results by clicking the build number link:
   
   image::ci-systems/teamcity-results.png[]
   
   You can view the tests right here in TeamCity:
   
   image::ci-systems/teamcity-tests.png[]
   
   The information on parameters and environment of the build is available
   on the _Parameters_ tab of the build results.
   
   If you installed the https://plugins.jetbrains.com/plugin/9326-gradle-build-scan-integration[TeamCity Build Scan plugin], you will see a link to the build scan in the Build Results view:
   
   image::ci-systems/teamcity-build-scan-plugin.png[]
   
   Otherwise, the link to the link:https://scans.gradle.com[build scan] for the given build is available in the build log:
   
   image::ci-systems/teamcity-log-link.png[]
   
   There are various options to trigger TeamCity builds continuously:
   from link:https://www.jetbrains.com/help/teamcity/configuring-build-triggers.html[polling the repository] periodically,
   to link:https://www.jetbrains.com/help/teamcity/configuring-schedule-triggers.html[building on a set schedule],
   or via link:https://www.jetbrains.com/help/teamcity/configuring-vcs-post-commit-hooks-for-teamcity.html[post-commit hook].
   
   
   == Further reading
   
   You can learn more about advanced TeamCity usage through these resources:
   
   * https://www.jetbrains.com/help/teamcity/build-dependencies-setup.html[Build chains and dependencies]
   * https://www.jetbrains.com/help/teamcity/pre-tested-delayed-commit.html[Remote run and pre-tested commit]
   
   More information is available in https://www.jetbrains.com/help/teamcity/teamcity-documentation.html[TeamCity documentation].
   Follow the https://blog.jetbrains.com/teamcity/[TeamCity blog] for the latest news.
   
   
   == Summary
   
   Executing Gradle builds on CI can be set up and configured with just a handful of steps.
   The benefit of receiving fast feedback clearly speaks for itself.
   If you are not using TeamCity, no problem, many CI products tightly integrate with Gradle as a first-class citizen.
   

/docs/userguide/reference/ci-systems/github-actions.adoc
========================================================

.. code-block::

   = Executing Gradle builds on GitHub Actions
   
   TIP: Top engineering teams using GitHub Actions have been able to reduce CI build time by up to 90% by using the Gradle Build Cache. https://gradle.org/training/#build-cache-deep-dive[Register here] for our Build Cache training session to learn how your team can achieve similar results.
   
   Building Gradle projects doesn't stop with the developer's machine.
   https://en.wikipedia.org/wiki/Continuous_integration[Continuous Integration] (CI) has been a long-established practice for running a build for every single change committed to version control to tighten the feedback loop.
   
   In this guide, we'll discuss how to configure link:https://github.com/features/actions/[GitHub Actions] for a Gradle project hosted on GitHub.
   
   == Introduction
   
   GitHub Actions is a cloud-based CI solution provider built directly into GitHub, making it an excellent choice for projects hosted on GitHub.
   
   Using the link:https://github.com/gradle/gradle-build-action[Gradle Build Action] makes it simple to integrate any Gradle project into a GitHub Actions workflow.
   
   == What you'll need
   
   * A text editor
   * A command prompt
   * The Java Development Kit (JDK), version 1.8 or higher
   * A local Gradle installation, to initialize a new Gradle project
   * A GitHub account
   
   == Setup a Gradle project on GitHub
   
   If you have an existing Gradle project hosted on GitHub, then you can skip this step and move directly to <<#sec:configure_github_actions,Configure GitHub Actions>>.
   
   If not, follow these step to initialize a new Gradle project on GitHub.
   
   === Create a new GitHub repository for your project
   
   Via the GitHub user interface, create a new repository named `github-actions-gradle-sample`.
   
   image::ci-systems/github-actions-create-repository.png[Create new GitHub repository]
   
   === Clone the repository locally
   
   [listing.terminal.sample-command]
   ----
   $ git clone git@github.com:<YOUR-GITHUB-USER>/github-actions-gradle-sample.git
   Cloning into 'github-actions-gradle-sample'...
   $ cd github-actions-gradle-sample
   ----
   
   === Initialize the Gradle project and commit to the repository
   
   Use `gradle init` to create a fresh Gradle project. You can choose any of the available options during `init`, but we recommend choosing "library" as the project type.
   
   Once the project is generated, commit the changes and push to the repository.
   
   [listing.terminal.sample-command]
   ----
   $ gradle init
   $ git add .
   $ git commit -m "Initial commit"
   $ git push
   ----
   
   === Enable Build Scan publishing
   
   https://scans.gradle.com[Gradle Build Scans] are a great way to view your build results, and provide valuable insights into your build.
   In order to publish Build Scans from GitHub Actions, you'll need to pre-approve the Terms & Conditions.
   
   To do so, add the following content to the top of your `settings.gradle[.kts]` file. The "CI" environment variable is set by GitHub Actions:
   ```
   plugins {
       id("com.gradle.enterprise") version("3.16.2")
   }
   
   gradleEnterprise {
       if (System.getenv("CI") != null) {
           buildScan {
               publishAlways()
               termsOfServiceUrl = "https://gradle.com/terms-of-service"
               termsOfServiceAgree = "yes"
           }
       }
   }
   ```
   
   === Test building the project
   
   The project uses the <<gradle_wrapper.adoc#gradle_wrapper_reference,Gradle Wrapper>> for building the project.
   It is a recommended practice for any Gradle project as it enables your project to built on CI without having to install the Gradle runtime.
   
   Before asking GitHub Actions to build your project, it's useful to ensure that it builds locally.
   Adding the "CI" environment variable will emulate running the build on GitHub Actions.
   
   The following command achieves that:
   
   [listing.terminal.sample-command]
   ----
   $ CI=true ./gradlew build
   
   BUILD SUCCESSFUL
   
   Publishing build scan...
   https://gradle.com/s/7mtynxxmesdio
   ----
   
   If the build works as expected, commit the changes and push to the repository.
   
   
   [listing.terminal.sample-command]
   ----
   $ git commit -a -m "Publish Build Scans from GitHub Actions"
   $ git push
   ----
   
   == Configure GitHub Actions
   
   You can create a GitHub Actions workflow by adding a `.github/workflows/<workflow-name>.yml` file to your repository.
   This workflow definition file contains all relevant instructions for building the project on GitHub Actions.
   
   The following workflow file instructs GitHub Actions to build your Gradle project using the Gradle Wrapper, executed by the default Java distribution for GitHub Actions.
   Create a new file named `.github/workflows/build-gradle-project.yml` with the following content, and push it to the GitHub repository.
   
   [listing]
   ----
   name: Build Gradle project
   
   on:
     push:
   
   jobs:
     build-gradle-project:
       runs-on: ubuntu-latest
       steps:
       - name: Checkout project sources
         uses: actions/checkout@v4
       - name: Setup Gradle
         uses: gradle/gradle-build-action@v2
       - name: Run build with Gradle Wrapper
         run: ./gradlew build
   ----
   
   Commit the changes and push to the repository:
   
   [listing.terminal.sample-command]
   ----
   $ git add .
   $ git commit -m "Add GitHub Actions workflow"
   $ git push
   ----
   
   == View the GitHub Actions results
   
   Once this workflow file is pushed, you should immediately see the workflow execution in the GitHub Actions page for your repository (eg https://github.com/gradle/gradle/actions).
   Any subsequent push to the repository will trigger the workflow to run.
   
   === List all runs of the GitHub Actions workflow
   
   The main actions page can be filtered to list all runs for a GitHub Actions workflow.
   
   image::ci-systems/github-actions-workflows.png[View workflow executions]
   
   === See the results for GitHub Actions workflow run
   
   Clicking on the link for a workflow run will show the details of the workflow run, including a link to the build scan produced for the build.
   
   NOTE: Configuring link:https://scans.gradle.com/[build scans] is especially helpful on cloud CI systems like GitHub Actions because it has additional environment and test results information that are difficult to obtain otherwise.
   
   image::ci-systems/github-actions-workflow.png[View workflow execution details]
   
   === View the details for Jobs and Steps in the workflow
   
   Finally, you can view the details for the individual workflow Jobs and each Step defined for a Job:
   
   image::ci-systems/github-actions-job-details.png[View workflow job details]
   
   == Enable caching of downloaded artifacts
   
   The https://github.com/gradle/gradle-build-action[gradle-build-action] used by this workflow will enable saving and restoring of the Gradle User Home
   directory in the built-in GitHub Actions cache.
   This will speed up your GitHub Actions build by avoiding the need to re-download Gradle versions and project dependencies,
   as well as re-using state from the previous workflow execution.
   
   Details about what entries are saved/restored from the cache can be viewed in the `Post Setup Gradle` step:
   
   image::ci-systems/github-actions-cache-details.png[View cache entry details]
   
   == Further reading
   
   Learn more about building Gradle projects with GitHub Actions:
   
   * https://docs.github.com/en/actions/[GitHub Actions documentation]
   * https://github.com/gradle/gradle-build-action#readme[Use and configuration of the gradle-build-action]
   
   == Summary
   
   Executing Gradle builds on CI can be set up and configured with just a handful of steps.
   The benefit of receiving fast feedback clearly speaks for itself.
   GitHub Actions provides a simple, convenient mechanism to setup CI for any Gradle project hosted on GitHub.

/docs/userguide/reference/ci-systems/travis-ci.adoc
===================================================

.. code-block::

   = Executing Gradle builds on Travis CI
   
   TIP: Top engineering teams using Travis CI have been able to reduce CI build time by up to 90% by using the Gradle Build Cache. https://gradle.org/training/#build-cache-deep-dive[Register here] for our Build Cache training session to learn how your team can achieve similar results.
   
   Building Gradle projects doesn't stop with the developer's machine.
   https://en.wikipedia.org/wiki/Continuous_integration[Continuous Integration] (CI) has been a long-established practice for running a build for every single change committed to version control to tighten the feedback loop.
   
   In this guide, we'll discuss how to configure link:https://travis-ci.org/[Travis CI] for a typical Gradle project.
   
   == What you'll need
   
   * A text editor
   * A command prompt
   * The Java Development Kit (JDK), version 1.8 or higher
   
   == Setup a typical project
   
   As example, this guide is going to focus on a Java-based project.
   More specifically, a Gradle plugin written in Java and tested with https://www.spekframework.org/[Spek].
   First, we'll get the project set up on your local machine before covering the same steps on CI.
   
   Just follow these steps:
   
   === Clone the https://github.com/gradle/gradle-site-plugin[Gradle Site Plugin] repository
   
   [listing.terminal.sample-command]
   ----
   $ git clone https://github.com/gradle/gradle-site-plugin.git
   Cloning into 'gradle-site-plugin'...
   $ cd gradle-site-plugin
   ----
   
   === Build the project
   
   As a developer of a Java project, you'll typical want to compile the source code, run the tests and assemble the JAR artifact. That's no different for Gradle plugins. The following command achieves exactly that:
   
   [listing.terminal.sample-command]
   ----
   $ ./gradlew build
   
   BUILD SUCCESSFUL
   14 actionable tasks: 14 executed
   ----
   
   The project provides the <<gradle_wrapper.adoc#gradle_wrapper_reference,Gradle Wrapper>> as part of the repository.
   It is a recommended practice for any Gradle project as it enables your project to built on CI without having to install the Gradle runtime.
   
   === Build scan integration
   
   The sample project is equipped with support for generating link:https://scans.gradle.com/[build scans].
   Running the build with the command line option `--scan` renders a link in the console.
   
   [listing.terminal.sample-command]
   ----
   $ ./gradlew build --scan
   Publishing build scan...
   https://gradle.com/s/7mtynxxmesdio
   ----
   
   The following section will describe how to build the project with the help of Travis CI.
   
   == Configure Travis CI
   
   Travis CI is a free, cloud-based CI solution provider making it an excellent choice for open source projects.
   You can build any project as long as it is hosted on GitHub as a public repository.
   Travis CI doesn't not provide built-in options to post-process produced artifacts of the build e.g. host the JAR file or the HTML test reports.
   You will have to use external services (like S3) to https://docs.travis-ci.com/user/uploading-artifacts/[transfer the files].
   
   === Create the configuration file
   
   Travis CI requires you to check in a https://docs.travis-ci.com/user/customizing-the-build/[configuration file] with your source code named `.travis.yml`.
   This file contains all relevant instructions for building the project.
   
   The following configuration file tells Travis CI to build a Java project with JDK 8, skip the usual https://docs.travis-ci.com/user/customizing-the-build/#Skipping-the-Installation-Step[default execution step], and run the Gradle build with the Wrapper.
   
   [listing]
   ----
   language: java
   install: skip
   
   os: linux
   dist: trusty
   jdk: oraclejdk8
   
   script:
     - ./gradlew build --scan -s
   ----
   
   Select the project from the Travis CI profile.
   After activating the repository from the dashboard, the project is ready to be built with every single commit.
   
   image::ci-systems/travis-enable-project.png[Enabling a project]
   
   NOTE: Configuring link:https://scans.gradle.com/[build scans] is especially helpful on cloud CI systems like Travis CI because it has additional environment and test results information that are difficult to obtain otherwise.
   
   === Enable caching of downloaded artifacts
   
   Gradle's dependency management mechanism resolves declared modules and their corresponding artifacts from a binary repository.
   Once downloaded, the files will be re-used from the cache.
   You need to tell Travis CI explicitly that you want to https://docs.travis-ci.com/user/languages/java/#Caching[store and use the Gradle cache and Wrapper] for successive invocations of the build.
   
   [listing]
   ----
   before_cache:
     - rm -f  $HOME/.gradle/caches/modules-2/modules-2.lock
     - rm -fr $HOME/.gradle/caches/*/plugin-resolution/
   
   cache:
     directories:
       - $HOME/.gradle/caches/
       - $HOME/.gradle/wrapper/
   ----
   
   === Further reading
   
   You can learn more about advanced Travis CI usage through these resources:
   
   * https://docs.travis-ci.com/user/encryption-keys/[Encrypting sensitive data]
   * https://docs.travis-ci.com/user/build-stages/[Modelling a pipeline with build stages]
   
   == Summary
   
   Executing Gradle builds on CI can be set up and configured with just a handful of steps.
   The benefit of receiving fast feedback clearly speaks for itself.
   If you are not using Travis CI, no problem, many CI products tightly integrate with Gradle as a first-class citizen.

/Topic: 游댯 Reference
======================


/docs/userguide/reference/command_line_interface.adoc
=====================================================

.. code-block::

   = Command-Line Interface Reference
   
   The command-line interface is the **primary method of interacting with Gradle**.
   
   The following is a reference for executing and customizing the Gradle command-line.
   It also serves as a reference when writing scripts or configuring continuous integration.
   
   **Use of the <<gradle_wrapper.adoc#gradle_wrapper_reference, Gradle Wrapper>> is highly encouraged**.
   Substitute `./gradlew` (in macOS / Linux) or `gradlew.bat` (in Windows) for `gradle` in the following examples.
   
   Executing Gradle on the command-line conforms to the following structure:
   
   ----
   gradle [taskName...] [--option-name...]
   ----
   
   Options are allowed _before_ and _after_ task names.
   
   ----
   gradle [--option-name...] [taskName...]
   ----
   
   If multiple tasks are specified, you should separate them with a space.
   
   ----
   gradle [taskName1 taskName2...] [--option-name...]
   ----
   
   Options that accept values can be specified with or without `=` between the option and argument. The use of `=` is recommended.
   
   ----
   gradle [...] --console=plain
   ----
   
   Options that enable behavior have long-form options with inverses specified with `--no-`. The following are opposites.
   
   ----
   gradle [...] --build-cache
   gradle [...] --no-build-cache
   ----
   
   Many long-form options have short-option equivalents. The following are equivalent:
   
   ----
   gradle --help
   gradle -h
   ----
   
   NOTE: Many command-line flags can be specified in `gradle.properties` to avoid needing to be typed.
   See the <<build_environment.adoc#sec:gradle_configuration_properties, Configuring build environment guide>> for details.
   
   == Command-line usage
   
   The following sections describe the use of the Gradle command-line interface.
   
   Some plugins also add their own command line options.
   For example, `--tests`, which is added by <<java_testing.adoc#test_filtering,Java test filtering>>.
   For more information on exposing command line options for your own tasks, see <<custom_tasks.adoc#sec:declaring_and_using_command_line_options,Declaring command-line options>>.
   
   === Executing tasks
   You can learn about what projects and tasks are available in the <<#sec:command_line_project_reporting, project reporting section>>.
   
   Most builds support a common set of tasks known as <<lifecycle_tasks.adoc#sec:lifecycle_tasks,_lifecycle tasks_>>. These include the `build`, `assemble`, and `check` tasks.
   
   To execute a task called `myTask` on the root project, type:
   
   ----
   $ gradle :myTask
   ----
   
   This will run the single `myTask` and all of its <<tutorial_using_tasks.adoc#sec:task_dependencies,dependencies>>.
   
   === Specify options for tasks
   To pass an option to a task, prefix the option name with `--` after the task name:
   
   ----
   $ gradle exampleTask --exampleOption=exampleValue
   ----
   
   ==== Disambiguate task options from built-in options
   Gradle does not prevent tasks from registering options that conflict with Gradle's built-in options, like `--profile` or `--help`.
   
   You can fix conflicting task options from Gradle's built-in options with a `--` delimiter before the task name in the command:
   
   ----
   $ gradle [--built-in-option-name...] -- [taskName...] [--task-option-name...]
   ----
   
   Consider a task named `mytask` that accepts an option named `profile`:
   
   - In `gradle mytask --profile`, Gradle accepts `--profile` as the built-in Gradle option.
   
   - In `gradle \-- mytask --profile=value`, Gradle passes `--profile` as a task option.
   
   === Executing tasks in multi-project builds
   In a <<intro_multi_project_builds.adoc#intro_multi_project_builds, multi-project build>>, subproject tasks can be executed with `:` separating the subproject name and task name.
   The following are equivalent when _run from the root project_:
   
   ----
   $ gradle :subproject:taskName
   ----
   
   ----
   $ gradle subproject:taskName
   ----
   
   You can also run a task for _all_ subprojects using a task _selector_ that consists of only the task name.
   
   The following command runs the `test` task for all subprojects when invoked from the _root project directory_:
   
   ----
   $ gradle test
   ----
   
   NOTE: Some tasks selectors, like `help` or `dependencies`, will only run the task on the project they are invoked on and not on all the subprojects.
   
   When invoking Gradle from within a subproject, the project name should be omitted:
   
   ----
   $ cd subproject
   ----
   ----
   $ gradle taskName
   ----
   
   TIP: When executing the Gradle Wrapper from a subproject directory, reference `gradlew` relatively. For example: `../gradlew taskName`.
   
   === Executing multiple tasks
   You can also specify multiple tasks.
   The tasks' dependencies determine the precise order of execution, and a task having no dependencies may execute earlier than it is listed on the command-line.
   
   For example, the following will execute the `test` and `deploy` tasks in the order that they are listed on the command-line and will also execute the dependencies for each task.
   
   ----
   $ gradle test deploy
   ----
   
   === Command line order safety
   Although Gradle will always attempt to execute the build quickly, command line ordering safety will also be honored.
   
   For example, the following will
   execute `clean` and `build` along with their dependencies:
   
   ----
   $ gradle clean build
   ----
   
   However, the intention implied in the command line order is that `clean` should run first and then `build`. It would be incorrect to execute `clean` _after_ `build`, even if doing so would cause the build to execute faster since `clean` would remove what `build` created.
   
   Conversely, if the command line order was `build` followed by `clean`, it would not be correct to execute `clean` before `build`. Although Gradle will execute the build as quickly as possible, it will also respect the safety of the order of tasks specified on the command line and ensure that `clean` runs before `build` when specified in that order.
   
   Note that <<incremental_build.adoc#incremental_build,command line order safety>> relies on tasks properly declaring what they create, consume, or remove.
   
   === Excluding tasks from execution
   You can exclude a task from being executed using the `-x` or `--exclude-task` command-line option and providing the name of the task to exclude:
   
   ----
   $ gradle dist --exclude-task test
   ----
   ----
   include::{snippetsPath}/tutorial/excludeTasks/tests/excludeTask.out[]
   ----
   
   .Simple Task Graph
   image::commandLineTutorialTasks.png[]
   
   You can see that the `test` task is not executed, even though the `dist` task depends on it.
   The `test` task뗩 dependencies, such as `compileTest`, are not executed either.
   The dependencies of `test` that other tasks depend on, such as `compile`, are still executed.
   
   === Forcing tasks to execute
   You can force Gradle to execute all tasks ignoring <<incremental_build.adoc#incremental_build,up-to-date checks>> using the `--rerun-tasks` option:
   
   ----
   $ gradle test --rerun-tasks
   ----
   
   This will force `test` and _all_ task dependencies of `test` to execute. It is similar to running `gradle clean test`, but without the build's generated output being deleted.
   
   Alternatively, you can tell Gradle to rerun a specific task using the `--rerun` built-in <<#sec:task_options, task option>>.
   
   === Continue the build after a task failure
   By default, Gradle aborts execution and fails the build when any task fails.
   This allows the build to complete sooner and prevents cascading failures from obfuscating the root cause of an error.
   
   You can use the `--continue` option to force Gradle to execute every task when a failure occurs:
   
   ----
   $ gradle test --continue
   ----
   
   When executed with `--continue`, Gradle executes _every_ task in the build if all the dependencies for that task are completed without failure.
   
   For example, tests do not run if there is a compilation error in the code under test because the `test` task depends on the `compilation` task.
   Gradle outputs each of the encountered failures at the end of the build.
   
   NOTE: If any tests fail, many test suites fail the entire `test` task.
   Code coverage and reporting tools frequently run after the test task, so "fail fast" behavior may halt execution before those tools run.
   
   === Name abbreviation
   When you specify tasks on the command-line, you don't have to provide the full name of the task.
   You can provide enough of the task name to identify the task uniquely.
   For example, it is likely `gradle che` is enough for Gradle to identify the `check` task.
   
   The same applies to project names. You can execute the `check` task in the `library` subproject with the `gradle lib:che` command.
   
   You can use https://en.wikipedia.org/wiki/Camel_case[camel case] patterns for more complex abbreviations. These patterns are expanded to match camel case and https://en.wikipedia.org/wiki/Kebab_case[kebab case] names.
   For example, the pattern `foBa` (or `fB`) matches `fooBar` and `foo-bar`.
   
   More concretely, you can run the `compileTest` task in the `my-awesome-library` subproject with the command `gradle mAL:cT`.
   
   ----
   $ gradle mAL:cT
   ----
   ----
   include::{snippetsPath}/tutorial/nameMatching/tests/nameMatching.out[]
   ----
   
   Abbreviations can also be used with the `-x` command-line option.
   
   === Tracing name expansion
   For complex projects, it might be ambiguous if the intended tasks were executed. When using abbreviated names, a single typo can lead to the execution of unexpected tasks.
   
   When `INFO`, or more <<logging.adoc#logLevels,verbose logging>> is enabled, the output will contain extra information about the project and task name expansion.
   
   For example, when executing the `mAL:cT` command on the previous example, the following log messages will be visible:
   
   ----
   No exact project with name ':mAL' has been found. Checking for abbreviated names.
   Found exactly one project that matches the abbreviated name ':mAL': ':my-awesome-library'.
   No exact task with name ':cT' has been found. Checking for abbreviated names.
   Found exactly one task name, that matches the abbreviated name ':cT': ':compileTest'.
   ----
   
   == Common tasks
   
   The following are task conventions applied by built-in and most major Gradle plugins.
   
   === Computing all outputs
   It is common in Gradle builds for the `build` task to designate assembling all outputs and running all checks:
   
   ----
   $ gradle build
   ----
   
   === Running applications
   It is common for applications to run with the `run` task, which assembles the application and executes some script or binary:
   
   ----
   $ gradle run
   ----
   
   === Running all checks
   It is common for _all_ verification tasks, including tests and linting, to be executed using the `check` task:
   
   ----
   $ gradle check
   ----
   
   === Cleaning outputs
   You can delete the contents of the build directory using the `clean` task. Doing so will cause pre-computed outputs to be lost, causing significant additional build time for the subsequent task execution:
   
   ----
   $ gradle clean
   ----
   
   == Project reporting
   
   Gradle provides several built-in tasks which show particular details of your build.
   This can be useful for understanding your build's structure and dependencies, as well as debugging problems.
   
   === Listing projects
   Running the `projects` task gives you a list of the subprojects of the selected project, displayed in a hierarchy:
   
   ----
   $ gradle projects
   ----
   
   You also get a project report within https://scans.gradle.com/[Build Scans].
   
   === Listing tasks
   Running `gradle tasks` gives you a list of the main tasks of the selected project. This report shows the default tasks for the project, if any, and a description for each task:
   
   ----
   $ gradle tasks
   ----
   
   By default, this report shows only those tasks assigned to a task group.
   
   Groups (such as verification, publishing, help, build...) are available as the header of each section when listing tasks:
   
   ----
   > Task :tasks
   
   Build tasks
   -----------
   assemble - Assembles the outputs of this project.
   
   Build Setup tasks
   -----------------
   init - Initializes a new Gradle build.
   
   Distribution tasks
   ------------------
   assembleDist - Assembles the main distributions
   
   Documentation tasks
   -------------------
   javadoc - Generates Javadoc API documentation for the main source code.
   ----
   
   You can obtain more information in the task listing using the `--all` option:
   
   ----
   $ gradle tasks --all
   ----
   
   The option `--no-all` can limit the report to tasks assigned to a task group.
   
   If you need to be more precise, you can display only the tasks from a specific group using the `--group` option:
   
   ----
   $ gradle tasks --group="build setup"
   ----
   
   
   
   === Show task usage details
   Running `gradle help --task someTask` gives you detailed information about a specific task:
   
   ----
   $ gradle -q help --task libs
   ----
   ----
   include::{snippetsPath}/tutorial/projectReports/tests/taskHelp.out[]
   ----
   
   This information includes the full task path, the task type, possible <<sec:task_options,task-specific command line options>>, and the description of the given task.
   
   You can get detailed information about the task class types using the `--types` option or using `--no-types` to hide this information.
   
   === Reporting dependencies
   https://scans.gradle.com/[Build Scans] give a full, visual report of what dependencies exist on which configurations, transitive dependencies, and dependency version selection.
   They can be invoked using the `--scan` options:
   
   ----
   $ gradle myTask --scan
   ----
   
   This will give you a link to a web-based report, where you can find <<viewing_debugging_dependencies.adoc#sec:debugging-build-scans,dependency information>> like this:
   
   image::gradle-core-test-build-scan-dependencies.png[Build Scan dependencies report]
   
   === Listing project dependencies
   Running the `dependencies` task gives you a list of the dependencies of the selected project, broken down by configuration. For each configuration, the direct and transitive dependencies of that configuration are shown in a tree.
   
   Below is an example of this report:
   
   ----
   $ gradle dependencies
   ----
   
   ----
   > Task :app:dependencies
   
   ------------------------------------------------------------
   Project ':app'
   ------------------------------------------------------------
   
   compileClasspath - Compile classpath for source set 'main'.
   +--- project :model
   |    \--- org.json:json:20220924
   +--- com.google.inject:guice:5.1.0
   |    +--- javax.inject:javax.inject:1
   |    +--- aopalliance:aopalliance:1.0
   |    \--- com.google.guava:guava:30.1-jre -> 28.2-jre
   |         +--- com.google.guava:failureaccess:1.0.1
   |         +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
   |         +--- com.google.code.findbugs:jsr305:3.0.2
   |         +--- org.checkerframework:checker-qual:2.10.0 -> 3.28.0
   |         +--- com.google.errorprone:error_prone_annotations:2.3.4
   |         \--- com.google.j2objc:j2objc-annotations:1.3
   +--- com.google.inject:guice:{strictly 5.1.0} -> 5.1.0 (c)
   +--- org.json:json:{strictly 20220924} -> 20220924 (c)
   +--- javax.inject:javax.inject:{strictly 1} -> 1 (c)
   +--- aopalliance:aopalliance:{strictly 1.0} -> 1.0 (c)
   +--- com.google.guava:guava:{strictly [28.0-jre, 28.5-jre]} -> 28.2-jre (c)
   +--- com.google.guava:guava:{strictly 28.2-jre} -> 28.2-jre (c)
   +--- com.google.guava:failureaccess:{strictly 1.0.1} -> 1.0.1 (c)
   +--- com.google.guava:listenablefuture:{strictly 9999.0-empty-to-avoid-conflict-with-guava} -> 9999.0-empty-to-avoid-conflict-with-guava (c)
   +--- com.google.code.findbugs:jsr305:{strictly 3.0.2} -> 3.0.2 (c)
   +--- org.checkerframework:checker-qual:{strictly 3.28.0} -> 3.28.0 (c)
   +--- com.google.errorprone:error_prone_annotations:{strictly 2.3.4} -> 2.3.4 (c)
   \--- com.google.j2objc:j2objc-annotations:{strictly 1.3} -> 1.3 (c)
   ----
   Concrete examples of build scripts and output available in <<viewing_debugging_dependencies.adoc#sec:debugging-build-scans,Viewing and debugging dependencies>>.
   
   Running the `buildEnvironment` task visualises the buildscript dependencies of the selected project, similarly to how `gradle dependencies` visualizes the dependencies of the software being built:
   
   ----
   $ gradle buildEnvironment
   ----
   
   Running the `dependencyInsight` task gives you an insight into a particular dependency (or dependencies) that match specified input:
   
   ----
   $ gradle dependencyInsight --dependency [...] --configuration [...]
   ----
   
   The `--configuration` parameter restricts the report to a particular configuration such as `compileClasspath`.
   
   === Listing project properties
   Running the `properties` task gives you a list of the properties of the selected project:
   
   ----
   $ gradle -q api:properties
   ----
   ----
   include::{snippetsPath}/tutorial/projectReports/tests/propertyListReport.out[]
   ----
   
   You can also query a single property with the optional `--property` argument:
   
   ----
   $ gradle -q api:properties --property allprojects
   ----
   ----
   include::{snippetsPath}/tutorial/projectReports/tests/propertyReport.out[]
   ----
   
   == Command-line completion
   
   Gradle provides `bash` and `zsh` tab completion support for tasks, options, and Gradle properties through https://github.com/gradle/gradle-completion[gradle-completion] (installed separately):
   
   image::gradle-completion-4.0.gif[]
   
   == Debugging options
   
   `-?`, `-h`, `--help`::
   Shows a help message with the built-in CLI options.
   To show project-contextual options, including help on a specific task, see the `help` task.
   
   `-v`, `--version`::
   Prints Gradle, Groovy, Ant, JVM, and operating system version information and exit without executing any tasks.
   
   `-V`, `--show-version`::
   Prints Gradle, Groovy, Ant, JVM, and operating system version information and continue execution of specified tasks.
   
   `-S`, `--full-stacktrace`::
   Print out the full (very verbose) stacktrace for any exceptions. See also <<#sec:command_line_logging, logging options>>.
   
   `-s`, `--stacktrace`::
   Print out the stacktrace also for user exceptions (e.g. compile error). See also <<#sec:command_line_logging, logging options>>.
   
   `--scan`::
   Create a https://gradle.com/build-scans[Build Scan] with fine-grained information about all aspects of your Gradle build.
   
   `-Dorg.gradle.debug=true`::
   Debug <<gradle_daemon.adoc#gradle_daemon, Gradle Daemon>> process. Gradle will wait for you to attach a debugger at `localhost:5005` by default.
   
   `-Dorg.gradle.debug.host=(host address)`::
   Specifies the host address to listen on or connect to when debug is enabled.
   In the server mode on Java 9 and above, passing `*` for the host will make the server listen on all network interfaces.
   By default, no host address is passed to JDWP, so on Java 9 and above, the loopback address is used, while earlier versions listen on all interfaces.
   
   `-Dorg.gradle.debug.port=(port number)`::
   Specifies the port number to listen on when debug is enabled. _Default is `5005`._
   
   `-Dorg.gradle.debug.server=(true,false)`::
   If set to `true` and debugging is enabled, Gradle will run the build with the socket-attach mode of the debugger. Otherwise, the socket-listen mode is used. _Default is `true`._
   
   `-Dorg.gradle.debug.suspend=(true,false)`::
   When set to `true` and debugging is enabled, the JVM running Gradle will suspend until a debugger is attached. _Default is `true`._
   
   `-Dorg.gradle.daemon.debug=true`::
   Debug <<gradle_daemon.adoc#gradle_daemon, Gradle Daemon>> process. (duplicate of `-Dorg.gradle.debug`)
   
   == Performance options
   
   Try these options when optimizing and <<performance.adoc#performance_gradle,improving>> build performance.
   
   Many of these options can be <<build_environment.adoc#sec:gradle_configuration_properties,specified>> in the `gradle.properties` file, so command-line flags are unnecessary.
   
   `--build-cache`, `--no-build-cache`::
   Toggles the <<build_cache.adoc#build_cache, Gradle Build Cache>>. Gradle will try to reuse outputs from previous builds. _Default is off_.
   
   `--configuration-cache`, `--no-configuration-cache`::
   Toggles the <<configuration_cache.adoc#config_cache,Configuration Cache>>. Gradle will try to reuse the build configuration from previous builds. _Default is off_.
   
   `--configuration-cache-problems=(fail,warn)`::
   Configures how the configuration cache handles problems. Default is `fail`.
   +
   Set to `warn` to report problems without failing the build.
   +
   Set to `fail` to report problems and fail the build if there are any problems.
   
   `--configure-on-demand`, `--no-configure-on-demand`::
   Toggles configure-on-demand. Only relevant projects are configured in this build run. _Default is off_.
   
   `--max-workers`::
   Sets the maximum number of workers that Gradle may use. _Default is number of processors_.
   
   `--parallel`, `--no-parallel`::
   Build projects in parallel. For limitations of this option, see <<performance.adoc#parallel_execution, Parallel Project Execution>>. _Default is off_.
   
   `--priority`::
   Specifies the scheduling priority for the Gradle daemon and all processes launched by it. Values are `normal` or `low`. _Default is normal_.
   
   `--profile`::
   Generates a high-level performance report in the `layout.buildDirectory.dir("reports/profile")` directory. `--scan` is preferred.
   
   `--scan`::
   Generate a build scan with detailed performance diagnostics.
   
   image::gradle-core-test-build-scan-performance.png[Build Scan performance report]
   
   `--watch-fs`, `--no-watch-fs`::
   Toggles <<file_system_watching.adoc#sec:daemon_watch_fs,watching the file system>>.
   When enabled, Gradle reuses information it collects about the file system between builds.
   _Enabled by default on operating systems where Gradle supports this feature._
   
   === Gradle daemon options
   You can manage the <<gradle_daemon.adoc#gradle_daemon,Gradle Daemon>> through the following command line options.
   
   `--daemon`, `--no-daemon`::
   Use the <<gradle_daemon.adoc#gradle_daemon, Gradle Daemon>> to run the build. Starts the daemon if not running or the existing daemon is busy. _Default is on_.
   
   `--foreground`::
   Starts the Gradle Daemon in a foreground process.
   
   `--status` (Standalone command)::
   Run `gradle --status` to list running and recently stopped Gradle daemons. It only displays daemons of the same Gradle version.
   
   `--stop` (Standalone command)::
   Run `gradle --stop` to stop all Gradle Daemons of the same version.
   
   `-Dorg.gradle.daemon.idletimeout=(number of milliseconds)`::
   Gradle Daemon will stop itself after this number of milliseconds of idle time. _Default is 10800000_ (3 hours).
   
   == Logging options
   
   === Setting log level
   You can customize the <<logging.adoc#logging,verbosity>> of Gradle logging with the following options, ordered from least verbose to most verbose.
   
   `-Dorg.gradle.logging.level=(quiet,warn,lifecycle,info,debug)`::
   Set logging level via Gradle properties.
   
   `-q`, `--quiet`::
   Log errors only.
   
   `-w`, `--warn`::
   Set log level to warn.
   
   `-i`, `--info`::
   Set log level to info.
   
   `-d`, `--debug`::
   Log in debug mode (includes normal stacktrace).
   
   _Lifecycle_ is the default log level.
   
   === Customizing log format
   You can control the use of rich output (colors and font variants) by specifying the console mode in the following ways:
   
   `-Dorg.gradle.console=(auto,plain,rich,verbose)`::
   Specify console mode via Gradle properties. Different modes are described immediately below.
   
   `--console=(auto,plain,rich,verbose)`::
   Specifies which type of console output to generate.
   +
   Set to `plain` to generate plain text only. This option disables all color and other rich output in the console output. This is the default when Gradle is _not_ attached to a terminal.
   +
   Set to `auto` (the default) to enable color and other rich output in the console output when the build process is attached to a console or to generate plain text only when not attached to a console. _This is the default when Gradle is attached to a terminal._
   +
   Set to `rich` to enable color and other rich output in the console output, regardless of whether the build process is not attached to a console. When not attached to a console, the build output will use ANSI control characters to generate the rich output.
   +
   Set to `verbose` to enable color and other rich output like `rich` with output task names and outcomes at the lifecycle log level, (as is done by default in Gradle 3.5 and earlier).
   
   === Showing or hiding warnings
   By default, Gradle won't display all warnings (e.g. deprecation warnings). Instead, Gradle will collect them and render a summary at the end of the build like:
   
   ----
   Deprecated Gradle features were used in this build, making it incompatible with Gradle 5.0.
   ----
   
   You can control the verbosity of warnings on the console with the following options:
   
   `-Dorg.gradle.warning.mode=(all,fail,none,summary)`::
   Specify warning mode via <<build_environment.adoc#sec:gradle_configuration_properties, Gradle properties>>. Different modes are described immediately below.
   
   `--warning-mode=(all,fail,none,summary)`::
   Specifies how to log warnings. Default is `summary`.
   +
   Set to `all` to log all warnings.
   +
   Set to `fail` to log all warnings and fail the build if there are any warnings.
   +
   Set to `summary` to suppress all warnings and log a summary at the end of the build.
   +
   Set to `none` to suppress all warnings, including the summary at the end of the build.
   
   === Rich console
   Gradle's rich console displays extra information while builds are running.
   
   image::rich-cli.png[alt="Gradle Rich Console"]
   
   Features:
   
   * Progress bar and timer visually describe the overall status
   * Parallel work-in-progress lines below describe what is happening now
   * Colors and fonts are used to highlight significant output and errors
   
   == Execution options
   The following options affect how builds are executed by changing what is built or how dependencies are resolved.
   
   `--include-build`::
   Run the build as a <<composite_builds.adoc#composite_builds,composite>>, including the specified build.
   
   `--offline`::
   Specifies that the build should operate <<dynamic_versions.adoc#sec:controlling_dependency_caching_command_line,without accessing network resources>>.
   
   `-U`, `--refresh-dependencies`::
   Refresh the <<dynamic_versions.adoc#sec:controlling_dependency_caching_command_line,state of dependencies>>.
   
   `--continue`::
   <<command_line_interface.adoc#sec:continue_build_on_failure,Continue task execution>> after a task failure.
   
   `-m`, `--dry-run`::
   Run Gradle with all task actions disabled. Use this to show which task would have executed.
   
   `-t`, `--continuous`::
   Enables <<#sec:continuous_build,continuous build>>. Gradle does not exit and will re-execute tasks when task file inputs change.
   
   `--write-locks`::
   Indicates that all resolved configurations that are _lockable_ should have their <<dependency_locking.adoc#dependency-locking,lock state>> persisted.
   
   `--update-locks <group:name>[,<group:name>]*`::
   Indicates that versions for the specified modules have to be updated in the <<dependency_locking.adoc#dependency-locking,lock file>>.
   +
   This flag also implies `--write-locks`.
   
   `-a`, `--no-rebuild`::
   Do not rebuild project dependencies.
   Useful for <<sharing_build_logic_between_subprojects.adoc#sec:using_buildsrc, debugging and fine-tuning `buildSrc`>>, but can lead to wrong results. Use with caution!
   
   == Dependency verification options
   Learn more about this in <<dependency_verification.adoc#verifying-dependencies,dependency verification>>.
   
   `-F=(strict,lenient,off)`, `--dependency-verification=(strict,lenient,off)`::
   Configures the <<dependency_verification.adoc#sec:disabling-verification,dependency verification mode>>.
   +
   The default mode is `strict`.
   
   `-M`, `--write-verification-metadata`::
   Generates checksums for dependencies used in the project (comma-separated list) for <<dependency_verification.adoc#sec:bootstrapping-verification,dependency verification>>.
   
   `--refresh-keys`::
   Refresh the public keys used for dependency verification.
   
   `--export-keys`::
   Exports the public keys used for dependency verification.
   
   == Environment options
   You can <<build_environment.adoc#build_environment,customize>> many aspects about where build scripts, settings, caches, and so on through the options below.
   
   `-b`, `--build-file` (deprecated)::
   Specifies the build file. For example: `gradle --build-file=foo.gradle`. The default is `build.gradle`, then `build.gradle.kts`.
   
   `-c`, `--settings-file` (deprecated)::
   Specifies the settings file. For example: `gradle --settings-file=somewhere/else/settings.gradle`
   
   `-g`, `--gradle-user-home`::
   Specifies the Gradle User Home directory. The default is the `.gradle` directory in the user's home directory.
   
   `-p`, `--project-dir`::
   Specifies the start directory for Gradle. Defaults to current directory.
   
   `--project-cache-dir`::
   Specifies the project-specific cache directory. Default value is `.gradle` in the root project directory.
   
   `-D`, `--system-prop`::
   Sets a <<build_environment.adoc#sec:gradle_system_properties,system property>> of the JVM, for example `-Dmyprop=myvalue`.
   
   `-I`, `--init-script`::
   Specifies an <<init_scripts.adoc#init_scripts,initialization script>>.
   
   `-P`, `--project-prop`::
   Sets a <<project_properties.adoc#sec:project_properties,project property>> of the root project, for example `-Pmyprop=myvalue`.
   
   `-Dorg.gradle.jvmargs`::
   Set JVM arguments.
   
   `-Dorg.gradle.java.home`::
   Set JDK home dir.
   
   == Task options
   
   Tasks may define task-specific options which are different from most of the global options described in the sections above (which are interpreted by Gradle itself, can appear anywhere in the command line, and can be listed using the `--help` option).
   
   Task options:
   
   1. Are consumed and interpreted by the tasks themselves;
   2. *Must* be specified immediately after the task in the command-line;
   3. May be listed using `gradle help --task someTask` (see <<#sec:show_task_details, Show task usage details>>).
   
   To learn how to declare command-line options for your own tasks, see <<custom_tasks.adoc#sec:declaring_and_using_command_line_options,Declaring and Using Command Line Options>>.
   
   === Built-in task options
   Built-in task options are options available as task options for all tasks. At this time, the following built-in task options exist:
   
   `--rerun`::
   Causes the task to be rerun even if up-to-date. Similar to `<<#sec:rerun_tasks,--rerun-tasks>>`, but for a specific task.
   
   == Bootstrapping new projects
   
   === Creating new Gradle builds
   Use the built-in `gradle init` task to create a new Gradle build, with new or existing projects.
   
   ----
   $ gradle init
   ----
   
   Most of the time, a project type is specified.
   Available types include `basic` (default), `java-library`, `java-application`, and more.
   See <<build_init_plugin.adoc#build_init_plugin, init plugin documentation>> for details.
   
   ----
   $ gradle init --type java-library
   ----
   
   === Standardize and provision Gradle
   The built-in `gradle wrapper` task generates a script, `gradlew`, that invokes a declared version of Gradle, downloading it beforehand if necessary.
   
   ----
   $ gradle wrapper --gradle-version=8.1
   ----
   
   You can also specify `--distribution-type=(bin|all)`, `--gradle-distribution-url`, `--gradle-distribution-sha256-sum` in addition to `--gradle-version`. +
   Full details on using these options are documented in the <<gradle_wrapper.adoc#gradle_wrapper_reference,Gradle wrapper section>>.
   
   == Continuous build
   
   Continuous Build allows you to automatically re-execute the requested tasks when file inputs change.
   You can execute the build in this mode using the `-t` or `--continuous` command-line option.
   
   For example, you can continuously run the `test` task and all dependent tasks by running:
   
   ----
   $ gradle test --continuous
   ----
   
   Gradle will behave as if you ran `gradle test` after a change to sources or tests that contribute to the requested tasks.
   This means unrelated changes (such as changes to build scripts) will not trigger a rebuild.
   To incorporate build logic changes, the continuous build must be restarted manually.
   
   Continuous build uses <<file_system_watching.adoc#sec:daemon_watch_fs,file system watching>> to detect changes to the inputs.
   If file system watching does not work on your system, then continuous build won't work either.
   In particular, continuous build does not work when using `--no-daemon`.
   
   When Gradle detects a change to the inputs, it will not trigger the build immediately.
   Instead, it will wait until no additional changes are detected for a certain period of time - the quiet period.
   You can configure the quiet period in milliseconds by the Gradle property `<<build_environment.adoc#sec:gradle_configuration_properties,org.gradle.continuous.quietperiod>>`.
   
   === Terminating Continuous Build
   If Gradle is attached to an interactive input source, such as a terminal, the continuous build can be exited by pressing `CTRL-D` (On Microsoft Windows, it is required to also press `ENTER` or `RETURN` after `CTRL-D`).
   
   If Gradle is not attached to an interactive input source (e.g. is running as part of a script), the build process must be terminated (e.g. using the `kill` command or similar).
   
   If the build is being executed via the Tooling API, the build can be cancelled using the Tooling API's cancellation mechanism.
   
   Learn more in <<continuous_builds.adoc#continuous_builds>> Continuous Builds.
   
   ==== Changes to symbolic links
   In general, Gradle will not detect changes to symbolic links or to files referenced via symbolic links.
   
   ==== Changes to build logic are not considered
   The current implementation does not recalculate the build model on subsequent builds.
   This means that changes to task configuration, or any other change to the build model, are effectively ignored.

/docs/userguide/reference/gradle_wrapper.adoc
=============================================

.. code-block::

   = Gradle Wrapper Reference
   
   The **recommended way to execute any Gradle build** is with the help of the Gradle Wrapper (referred to as "Wrapper").
   
   The Wrapper is a script that invokes a declared version of Gradle, downloading it beforehand if necessary.
   As a result, developers can get up and running with a Gradle project quickly.
   
   image::wrapper-workflow.png[]
   
   In a nutshell, you gain the following benefits:
   
   - Standardizes a project on a given Gradle version for more reliable and robust builds.
   - Provisioning the Gradle version for different users is done with a simple Wrapper definition change.
   - Provisioning the Gradle version for different execution environments (e.g., IDEs or Continuous Integration servers) is done with a simple Wrapper definition change.
   
   There are three ways to use the Wrapper:
   
   1. You set up a new Gradle project and <<#sec:adding_wrapper,add the Wrapper>> to it.
   2. You <<#sec:using_wrapper,run a project with the Wrapper>> that already provides it.
   3. You <<#sec:upgrading_wrapper,upgrade the Wrapper>> to a new version of Gradle.
   
   The following sections explain each of these use cases in more detail.
   
   == Adding the Gradle Wrapper
   
   Generating the Wrapper files requires an installed version of the Gradle runtime on your machine as described in <<installation.adoc#installation,Installation>>.
   Thankfully, generating the initial Wrapper files is a one-time process.
   
   Every vanilla Gradle build comes with a built-in task called `wrapper`.
   The task is listed under the group "Build Setup tasks" when <<command_line_interface.adoc#sec:listing_tasks,listing the tasks>>.
   
   Executing the `wrapper` task generates the necessary Wrapper files in the project directory:
   
   ----
   $ gradle wrapper
   ----
   ----
   include::{snippetsPath}/wrapper/simple/tests/wrapperCommandLine.out[]
   ----
   
   [TIP]
   ====
   To make the Wrapper files available to other developers and execution environments, you need to check them into version control.
   Wrapper files, including the JAR file, are small.
   Adding the JAR file to version control is expected.
   Some organizations do not allow projects to submit binary files to version control, and there is no workaround available.
   ====
   
   The generated Wrapper properties file, `gradle/wrapper/gradle-wrapper.properties`, stores the information about the Gradle distribution:
   
   * The *server hosting* the Gradle distribution.
   * The *type of Gradle distribution*. By default, the `-bin` distribution contains only the runtime but no sample code and documentation.
   * The *Gradle version* used for executing the build. By default, the `wrapper` task picks the same Gradle version used to generate the Wrapper files.
   * Optionally, a *timeout* in ms used when downloading the Gradle distribution.
   * Optionally, a *boolean* to set the *validation of the distribution* URL.
   
   The following is an example of the generated distribution URL in `gradle/wrapper/gradle-wrapper.properties`:
   [source,properties,subs=+attributes]
   ----
   distributionUrl=https\://services.gradle.org/distributions/gradle-{gradleVersion}-bin.zip
   ----
   
   All of those aspects are configurable at the time of generating the Wrapper files with the help of the following command line options:
   
   `--gradle-version`::
   The Gradle version used for downloading and executing the Wrapper.
   The resulting distribution URL is validated before it is written to the properties file.
   +
   The following labels are allowed:
   +
   * `link:https://gradle.org/releases[latest]`
   * `link:https://gradle.org/release-candidate[release-candidate]`
   * `link:https://gradle.org/nightly[nightly]`
   * `link:https://gradle.org/release-nightly[release-nightly]`
   
   `--distribution-type`::
   The Gradle distribution type used for the Wrapper.
   Available options are `bin` and `all`.
   The default value is `bin`.
   
   `--gradle-distribution-url`::
   The full URL pointing to the Gradle distribution ZIP file.
   This option makes `--gradle-version` and `--distribution-type` obsolete, as the URL already contains this information.
   This option is valuable if you want to host the Gradle distribution inside your company's network.
   The URL is validated before it is written to the properties file.
   
   `--gradle-distribution-sha256-sum`::
   The SHA256 hash sum used for <<#sec:verification,verifying the downloaded Gradle distribution>>.
   
   `--network-timeout`::
   The network timeout to use when downloading the Gradle distribution, in ms. The default value is `10000`.
   
   `--no-validate-url`::
   Disables the validation of the configured distribution URL.
   
   `--validate-url`::
   Enables the validation of the configured distribution URL. Enabled by default.
   
   If the distribution URL is configured with `--gradle-version` or `--gradle-distribution-url`, the URL is validated by sending a HEAD request in the case of the `https` scheme or by checking the existence of the file in the case of the `file` scheme.
   
   Let's assume the following use-case to illustrate the use of the command line options.
   You would like to generate the Wrapper with version {gradleVersion} and use the `-all` distribution to enable your IDE to enable code-completion and being able to navigate to the Gradle source code.
   
   The following command-line execution captures those requirements:
   
   [listing,subs=+attributes]
   ----
   $ gradle wrapper --gradle-version {gradleVersion} --distribution-type all
   include::{snippetsPath}/wrapper/simple/tests/wrapperCommandLine.out[]
   ----
   
   As a result, you can find the desired information (the generated distribution URL) in the Wrapper properties file:
   
   [source,properties,subs=+attributes]
   ----
   distributionUrl=https\://services.gradle.org/distributions/gradle-{gradleVersion}-all.zip
   ----
   
   Let's have a look at the following project layout to illustrate the expected Wrapper files:
   
   ====
   [.multi-language-sample]
   =====
   [source,kotlin]
   ----
   .
   較럭較 a-subproject
   較   較덕較 build.gradle.kts
   較럭較 settings.gradle.kts
   較럭較 gradle
   較   較덕較 wrapper
   較       較럭較 gradle-wrapper.jar
   較       較덕較 gradle-wrapper.properties
   較럭較 gradlew
   較덕較 gradlew.bat
   ----
   =====
   [.multi-language-sample]
   =====
   [source,groovy]
   ----
   .
   較럭較 a-subproject
   較   較덕較 build.gradle
   較럭較 settings.gradle
   較럭較 gradle
   較   較덕較 wrapper
   較       較럭較 gradle-wrapper.jar
   較       較덕較 gradle-wrapper.properties
   較럭較 gradlew
   較덕較 gradlew.bat
   ----
   =====
   ====
   
   A Gradle project typically provides a `settings.gradle(.kts)` file and one `build.gradle(.kts)` file for each subproject.
   The Wrapper files live alongside in the `gradle` directory and the root directory of the project.
   
   The following list explains their purpose:
   
   `gradle-wrapper.jar`::
   The Wrapper JAR file containing code for downloading the Gradle distribution.
   
   `gradle-wrapper.properties`::
   A properties file responsible for configuring the Wrapper runtime behavior e.g. the Gradle version compatible with this version. Note that more generic settings, like <<networking.adoc#sec:accessing_the_web_via_a_proxy,configuring the Wrapper to use a proxy>>, need to go into a <<build_environment.adoc#sec:gradle_configuration_properties,different file>>.
   
   `gradlew`, `gradlew.bat`::
   A shell script and a Windows batch script for executing the build with the Wrapper.
   
   You can go ahead and <<#sec:using_wrapper,execute the build with the Wrapper>> without installing the Gradle runtime.
   If the project you are working on does not contain those Wrapper files, you will need to <<#sec:adding_wrapper,generate them>>.
   
   == Using the Gradle Wrapper
   
   It is always recommended to execute a build with the Wrapper to ensure a reliable, controlled, and standardized execution of the build.
   Using the Wrapper looks like running the build with a Gradle installation.
   Depending on the operating system you either run `gradlew` or `gradlew.bat` instead of the `gradle` command.
   
   The following console output demonstrates the use of the Wrapper on a Windows machine for a Java-based project:
   
   ----
   $ gradlew.bat build
   include::{snippetsPath}/wrapper/simple/tests/wrapperBatchFileExecution.out[]
   ----
   
   If the Gradle distribution is unavailable on the machine, the Wrapper will download it and store it in the local file system.
   Any subsequent build invocation will reuse the existing local distribution as long as the distribution URL in the Gradle properties doesn't change.
   
   NOTE: The Wrapper shell script and batch file reside in the root directory of a single or multi-project Gradle build. You will need to reference the correct path to those files in case you want to execute the build from a subproject directory e.g. `../../gradlew tasks`.
   
   == Upgrading the Gradle Wrapper
   
   Projects typically want to keep up with the times and upgrade their Gradle version to benefit from new features and improvements.
   
   One way to upgrade the Gradle version is by manually changing the `distributionUrl` property in the Wrapper's `gradle-wrapper.properties` file.
   
   The better and recommended option is to run the `wrapper` task and provide the target Gradle version as described in <<#sec:adding_wrapper,Adding the Gradle Wrapper>>.
   Using the `wrapper` task ensures that any optimizations made to the Wrapper shell script or batch file with that specific Gradle version are applied to the project.
   
   As usual, you should commit the changes to the Wrapper files to version control.
   
   Note that running the wrapper task once will update `gradle-wrapper.properties` only, but leave the wrapper itself in `gradle-wrapper.jar` untouched.
   This is usually fine as new versions of Gradle can be run even with older wrapper files.
   
   NOTE: If you want *all* the wrapper files to be completely up-to-date, you will need to run the `wrapper` task a second time.
   
   The following command upgrades the Wrapper to the `latest` version:
   
   [listing,subs=+attributes]
   ----
   $ ./gradlew wrapper --gradle-version latest
   include::{snippetsPath}/wrapper/simple/tests/wrapperGradleVersionUpgrade.out[]
   ----
   
   The following command upgrades the Wrapper to a specific version:
   
   [listing,subs=+attributes]
   ----
   $ ./gradlew wrapper --gradle-version {gradleVersion}
   include::{snippetsPath}/wrapper/simple/tests/wrapperGradleVersionUpgrade.out[]
   ----
   
   Once you have upgraded the wrapper, you can check that it's the version you expected by executing `./gradlew --version`.
   
   Don't forget to run the `wrapper` task again to download the Gradle distribution binaries (if needed) and update the `gradlew` and `gradlew.bat` files.
   
   == Customizing the Gradle Wrapper
   
   Most users of Gradle are happy with the default runtime behavior of the Wrapper.
   However, organizational policies, security constraints or personal preferences might require you to dive deeper into customizing the Wrapper.
   
   Thankfully, the built-in `wrapper` task exposes numerous options to bend the runtime behavior to your needs.
   Most configuration options are exposed by the underlying task type link:{groovyDslPath}#[Wrapper].
   
   Let's assume you grew tired of defining the `-all` distribution type on the command line every time you upgrade the Wrapper.
   You can save yourself some keyboard strokes by re-configuring the `wrapper` task.
   
   ====
   include::sample[dir="snippets/wrapper/customized-task/kotlin",files="build.gradle.kts[tags=customized-wrapper-task]"]
   include::sample[dir="snippets/wrapper/customized-task/groovy",files="build.gradle[tags=customized-wrapper-task]"]
   ====
   
   With the configuration in place, running `./gradlew wrapper --gradle-version {gradleVersion}` is enough to produce a `distributionUrl` value in the Wrapper properties file that will request the `-all` distribution:
   
   [listing,subs=+attributes]
   ----
   distributionUrl=https\://services.gradle.org/distributions/gradle-{gradleVersion}-all.zip
   ----
   
   Check out the link:{javadocPath}#[API documentation] for a more detailed description of the available configuration options. You can also find link:{javadocPath}#[various samples for configuring the Wrapper] in the Gradle distribution.
   
   === Authenticated Gradle distribution download
   
   The Gradle `Wrapper` can download Gradle distributions from servers using HTTP Basic Authentication.
   This enables you to host the Gradle distribution on a private protected server.
   
   You can specify a username and password in two different ways depending on your use case: as system properties or directly embedded in the `distributionUrl`.
   Credentials in system properties take precedence over the ones embedded in `distributionUrl`.
   
   [TIP]
   ====
   HTTP Basic Authentication should only be used with `HTTPS` URLs and not plain `HTTP` ones.
   With Basic Authentication, the user credentials are sent in clear text.
   ====
   
   System properties can be specified in the `.gradle/gradle.properties` file in the user's home directory or by other <<build_environment.adoc#sec:gradle_configuration_properties,means>>.
   
   To specify the HTTP Basic Authentication credentials, add the following lines to the system properties file:
   
   [source,properties]
   ----
   systemProp.gradle.wrapperUser=username
   systemProp.gradle.wrapperPassword=password
   ----
   
   Embedding credentials in the `distributionUrl` in the `gradle/wrapper/gradle-wrapper.properties` file also works.
   Please note that this file is to be committed into your source control system.
   
   TIP: Shared credentials embedded in `distributionUrl` should only be used in a controlled environment.
   
   To specify the HTTP Basic Authentication credentials in `distributionUrl`, add the following line:
   
   [listing]
   ----
   distributionUrl=https://username:password@somehost/path/to/gradle-distribution.zip
   ----
   
   This can be used in conjunction with a proxy, authenticated or not.
   See <<networking.adoc#sec:accessing_the_web_via_a_proxy,Accessing the web via a proxy>> for more information on how to configure the `Wrapper` to use a proxy.
   
   === Verification of downloaded Gradle distributions
   
   The Gradle Wrapper allows for verification of the downloaded Gradle distribution via SHA-256 hash sum comparison.
   This increases security against targeted attacks by preventing a man-in-the-middle attacker from tampering with the downloaded Gradle distribution.
   
   To enable this feature, download the `.sha256` file associated with the Gradle distribution you want to verify.
   
   ==== Downloading the SHA-256 file
   You can download the `.sha256` file from the link:https://services.gradle.org/distributions/[stable releases] or link:https://services.gradle.org/distributions-snapshots/[release candidate and nightly releases].
   The format of the file is a single line of text that is the SHA-256 hash of the corresponding zip file.
   
   You can also reference the link:https://gradle.org/release-checksums/[list of Gradle distribution checksums].
   
   ==== Configuring checksum verification
   Add the downloaded (SHA-256 checksum) hash sum to `gradle-wrapper.properties` using the `distributionSha256Sum` property or use `--gradle-distribution-sha256-sum` on the command-line:
   
   [source,properties]
   ----
   distributionSha256Sum=371cb9fbebbe9880d147f59bab36d61eee122854ef8c9ee1ecf12b82368bcf10
   ----
   
   Gradle will report a build failure if the configured checksum does not match the checksum found on the server hosting the distribution.
   Checksum verification is only performed if the configured Wrapper distribution hasn't been downloaded yet.
   
   NOTE: The `Wrapper` task fails if `gradle-wrapper.properties` contains `distributionSha256Sum`, but the task configuration does not define a sum.
   Executing the `Wrapper` task preserves the `distributionSha256Sum` configuration when the Gradle version does not change.
   
   == Verifying the integrity of the Gradle Wrapper JAR
   
   The Wrapper JAR is a binary file that will be executed on the computers of developers and build servers.
   As with all such files, you should ensure it's trustworthy before executing it.
   
   Since the Wrapper JAR is usually checked into a project's version control system, there is the potential for a malicious actor to replace the original JAR with a modified one by submitting a pull request that only upgrades the Gradle version.
   
   To verify the integrity of the Wrapper JAR, Gradle has created a link:https://github.com/marketplace/actions/gradle-wrapper-validation[GitHub Action] that automatically checks Wrapper JARs in pull requests against a list of known good checksums.
   
   Gradle also publishes the link:https://gradle.org/release-checksums/[checksums of all releases] (except for version 3.3 to 4.0.2, which did not generate reproducible JARs), so you can manually verify the integrity of the Wrapper JAR.
   
   === Automatically verifying the Gradle Wrapper JAR on GitHub
   
   The link:https://github.com/marketplace/actions/gradle-wrapper-validation[GitHub Action] is released separately from Gradle, so please check its documentation for how to apply it to your project.
   
   === Manually verifying the Gradle Wrapper JAR
   You can manually verify the checksum of the Wrapper JAR to ensure that it has not been tampered with by running the following commands on one of the major operating systems.
   
   Manually verifying the checksum of the Wrapper JAR on Linux:
   
   [source,bash,subs=+attributes]
   ----
   $ cd gradle/wrapper
   ----
   ----
   
   $ curl --location --output gradle-wrapper.jar.sha256 \
          https://services.gradle.org/distributions/gradle-{gradleVersion}-wrapper.jar.sha256
   ----
   ----
   $ echo " gradle-wrapper.jar" >> gradle-wrapper.jar.sha256
   ----
   ----
   $ sha256sum --check gradle-wrapper.jar.sha256
   ----
   ----
   gradle-wrapper.jar: OK
   ----
   
   Manually verifying the checksum of the Wrapper JAR on macOS:
   
   [source,bash,subs=+attributes]
   ----
   $ cd gradle/wrapper
   ----
   ----
   $ curl --location --output gradle-wrapper.jar.sha256 \
          https://services.gradle.org/distributions/gradle-{gradleVersion}-wrapper.jar.sha256
   ----
   ----
   $ echo " gradle-wrapper.jar" >> gradle-wrapper.jar.sha256
   ----
   ----
   $ shasum --check gradle-wrapper.jar.sha256
   ----
   ----
   gradle-wrapper.jar: OK
   ----
   
   Manually verifying the checksum of the Wrapper JAR on Windows (using PowerShell):
   
   [source,powershell,subs=+attributes]
   ----
   > $expected = Invoke-RestMethod -Uri https://services.gradle.org/distributions/gradle-{gradleVersion}-wrapper.jar.sha256
   ----
   ----
   > $actual = (Get-FileHash gradle\wrapper\gradle-wrapper.jar -Algorithm SHA256).Hash.ToLower()
   ----
   ----
   > @{$true = 'OK: Checksum match'; $false = "ERROR: Checksum mismatch!`nExpected: $expected`nActual:   $actual"}[$actual -eq $expected]
   ----
   ----
   OK: Checksum match
   ----
   
   === Troubleshooting a checksum mismatch
   
   If the checksum does not match the one you expected, chances are the `wrapper` task wasn't executed with the upgraded Gradle distribution.
   
   You should first check whether the actual checksum matches a different Gradle version.
   
   Here are the commands you can run on the major operating systems to generate the actual checksum of the Wrapper JAR.
   
   Generating the checksum of the Wrapper JAR on Linux:
   
   [source,bash,subs=+attributes]
   ----
   $ sha256sum gradle/wrapper/gradle-wrapper.jar
   d81e0f23ade952b35e55333dd5f1821585e887c6d24305aeea2fbc8dad564b95 gradle/wrapper/gradle-wrapper.jar
   ----
   
   Generating the actual checksum of the Wrapper JAR on macOS:
   
   [source,bash,subs=+attributes]
   ----
   $ shasum --algorithm=256 gradle/wrapper/gradle-wrapper.jar
   d81e0f23ade952b35e55333dd5f1821585e887c6d24305aeea2fbc8dad564b95 gradle/wrapper/gradle-wrapper.jar
   ----
   
   Generating the actual checksum of the Wrapper JAR on Windows (using PowerShell):
   
   [source,powershell,subs=+attributes]
   
   ----
   > (Get-FileHash gradle\wrapper\gradle-wrapper.jar -Algorithm SHA256).Hash.ToLower()
   d81e0f23ade952b35e55333dd5f1821585e887c6d24305aeea2fbc8dad564b95
   ----
   
   Once you know the actual checksum, check whether it's listed on https://gradle.org/release-checksums/.
   If it is listed, you have verified the integrity of the Wrapper JAR.
   If the version of Gradle that generated the Wrapper JAR doesn't match the version in `gradle/wrapper/gradle-wrapper.properties`, it's safe to run the `wrapper` task again to update the Wrapper JAR.
   
   If the checksum is not listed on the page, the Wrapper JAR might be from a milestone, release candidate, or nightly build or may have been generated by Gradle 3.3 to 4.0.2.
   Try to find out how it was generated but treat it as untrustworthy until proven otherwise.
   If you think the Wrapper JAR was compromised, please let the Gradle team know by sending an email to mailto:security@gradle.com[security@gradle.com].

/docs/userguide/reference/third_party_integration.adoc
======================================================

.. code-block::

   = Gradle & Third-party Tools
   
   Gradle can be integrated with many different third-party tools such as IDEs and continuous integration platforms. Here we look at some of the more common ones as well as how to integrate your own tool with Gradle.
   
   == IDEs
   
   Android Studio::
   As a variant of IntelliJ IDEA, https://developer.android.com/studio/[Android Studio] has built-in support for importing and building Gradle projects.
   You can also use the <<idea_plugin.adoc#idea_plugin,IDEA Plugin for Gradle>> to fine-tune the import process if that's necessary.
   +
   This IDE also has an https://developer.android.com/studio/intro/[extensive user guide] to help you get the most out of the IDE and Gradle.
   
   Eclipse::
   If you want to work on a project within Eclipse that has a Gradle build, you should use the https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship plugin].
   This will allow you to import and run Gradle builds.
   If you need to fine tune the import process so that the project loads correctly, you can use the <<eclipse_plugin.adoc#eclipse_plugin,Eclipse Plugins for Gradle>>.
   See https://discuss.gradle.org/t/buildship-1-0-18-is-now-available/19012[the associated release announcement] for details on what fine tuning you can do.
   
   IntelliJ IDEA::
   IDEA has built-in support for importing Gradle projects.
   If you need to fine tune the import process so that the project loads correctly, you can use the <<idea_plugin.adoc#idea_plugin,IDEA Plugin for Gradle>>.
   
   NetBeans::
   Built-in support for Gradle in https://netbeans.apache.org/[Apache NetBeans]
   
   Visual Studio::
   For developing C++ projects, Gradle comes with a <<visual_studio_plugin.adoc#visual_studio_plugin,Visual Studio plugin>>.
   
   Xcode::
   For developing C++ projects, Gradle comes with a <<xcode_plugin.adoc#xcode_plugin,Xcode plugin>>.
   
   CLion::
   JetBrains supports building https://blog.jetbrains.com/clion/2018/05/clion-starts-2018-2-eap-sanitizers-gradle-db-performance/[C++ projects with Gradle].
   
   == Continuous integration
   
   We have dedicated guides showing you how to integrate a Gradle project with the following CI platforms:
   
    * <<jenkins.adoc#build_jenkins,Jenkins>>
    * <<teamcity.adoc#build_teamcity,TeamCity>>
    * <<travis-ci.adoc#build_travis,Travis CI>>
   
   Even if you don't use one of the above, you can almost certainly configure your CI platform to use the <<gradle_wrapper.adoc#gradle_wrapper_reference,Gradle Wrapper>> scripts.
   
   == How to integrate with Gradle
   
   There are two main ways to integrate a tool with Gradle:
   
    * The Gradle build uses the tool
    * The tool executes the Gradle build
   
   The former case is typically <<custom_plugins.adoc#custom_plugins,implemented as a Gradle plugin>>. The latter can be accomplished by embedding Gradle through the Tooling API as described below.
   
   == Embedding Gradle using the Tooling API
   
   === Introduction to the Tooling API
   
   Gradle provides a programmatic API called the Tooling API, which you can use for embedding Gradle into your own software. This API allows you to execute and monitor builds and to query Gradle about the details of a build. The main audience for this API is IDE, CI server, other UI authors; however, the API is open for anyone who needs to embed Gradle in their application.
   
   * <<test_kit.adoc#test_kit,Gradle TestKit>> uses the Tooling API for functional testing of your Gradle plugins.
   * http://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship] uses the Tooling API for importing your Gradle project and running tasks.
   * https://www.jetbrains.com/idea/[IntelliJ IDEA] uses the Tooling API for importing your Gradle project and running tasks.
   
   
   === Tooling API Features
   
   A fundamental characteristic of the Tooling API is that it operates in a version independent way.
   This means that you can use the same API to work with builds that use different versions of Gradle, including versions that are newer or older than the version of the Tooling API that you are using.
   The Tooling API is Gradle wrapper aware and, by default, uses the same Gradle version as that used by the wrapper-powered build.
   
   Some features that the Tooling API provides:
   
   * Query the details of a build, including the project hierarchy and the project dependencies, external dependencies (including source and Javadoc jars), source directories and tasks of each project.
   * Execute a build and listen to stdout and stderr logging and progress messages (e.g. the messages shown in the 'status bar' when you run on the command line).
   * Execute a specific test class or test method.
   * Receive interesting events as a build executes, such as project configuration, task execution or test execution.
   * Cancel a build that is running.
   * Combine multiple separate Gradle builds into a single composite build.
   * The Tooling API can download and install the appropriate Gradle version, similar to the wrapper.
   * The implementation is lightweight, with only a small number of dependencies.
   It is also a well-behaved library, and makes no assumptions about your classloader structure or logging configuration.
   This makes the API easy to embed in your application.
   
   
   === Tooling API and the Gradle Build Daemon
   
   The Tooling API always uses the Gradle daemon.
   This means that subsequent calls to the Tooling API, be it model building requests or task executing requests will be executed in the same long-living process.
   <<gradle_daemon.adoc#gradle_daemon,Gradle Daemon>> contains more details about the daemon, specifically information on situations when new daemons are forked.
   
   === Quickstart
   
   As the Tooling API is an interface for developers, the Javadoc is the main documentation for it.
   
   To use the Tooling API, add the following repository and dependency declarations to your build script:
   
   .Using the tooling API
   ====
   include::sample[dir="snippets/toolingApi/runBuild/kotlin",files="build.gradle.kts[tags=use-tooling-api]"]
   include::sample[dir="snippets/toolingApi/runBuild/groovy",files="build.gradle[tags=use-tooling-api]"]
   ====
   
   The main entry point to the Tooling API is the link:{javadocPath}#[GradleConnector].
   You can navigate from there to find code samples and explore the available Tooling API models.
   You can use link:{javadocPath}#[GradleConnector.connect()] to create a link:{javadocPath}#[ProjectConnection].
   A `ProjectConnection` connects to a single Gradle project.
   Using the connection you can execute tasks, tests and retrieve models relative to this project.
   
   === Compatibility of Java and Gradle versions
   
   The following components should be considered when implementing Gradle integration: the Tooling API version, The JVM running the Tooling API client (i.e. the IDE process), the JVM running the Gradle daemon, and the Gradle version.
   
   The Tooling API itself is a Java library published as part of the Gradle release.
   Each Gradle release has a corresponding Tooling API version with the same version number.
   
   The Tooling API classes are loaded into the client's JVM, so they should have a matching version.
   The current version of the Tooling API library is compiled with Java 8 compatibility.
   
   The JVM running the Tooling API client and the one running the daemon can be different.
   At the same time, classes that are sent to the build via custom build actions need to be targeted to the lowest supported Java version.
   The JVM versions supported by Gradle is version-specific.
   The upper bound is defined in the <<compatibility.adoc#compatibility,compatibility matrix>>.
   The rule for the lower bound is the following:
   
   - Gradle 3.x and 4.x require a minimum version of Java 7.
   - Gradle 5 and above require a minimum version of Java 8.
   
   The Tooling API version is guaranteed to support running builds with all Gradle versions for the last five major releases.
   For example, the Tooling API 8.0 release is compatible with Gradle versions >= 3.0.
   Besides, the Tooling API is guaranteed to be compatible with future Gradle releases for the current and the next major.
   This means, for example, that the 8.1 version of the Tooling API will be able to run Gradle 9.x builds and _might_ break with Gradle 10.0.

/Section: 游릭 Gradle DSLs and API
==================================


/docs/userguide/api/groovy_build_script_primer.adoc
===================================================

.. code-block::

   = A Groovy Build Script Primer
   
   Ideally, a Groovy build script looks mostly like configuration: setting some properties of the project, configuring dependencies, declaring tasks, and so on. That configuration is based on Groovy language constructs. This primer aims to explain what those constructs are and 댹맔ost importantly 댹맏ow they relate to Gradle's API documentation.
   
   == The `Project` object
   
   As Groovy is an object-oriented language based on Java, its properties and methods apply to objects. In some cases, the object is implicit  particularly at the top level of a build script, i.e. not nested inside a `{}` block.
   
   Consider this fragment of build script, which contains an unqualified property and block:
   
   [source,groovy]
   ----
   version = '1.0.0.GA'
   
   configurations {
       ...
   }
   ----
   
   Both `version` and `configurations {}` are part of link:{groovyDslPath}#[org.gradle.api.Project].
   
   This example reflects how every Groovy build script is backed by an implicit instance of `Project`. If you see an unqualified element and you don't know where it's defined, always check the `Project` API documentation to see if that's where it's coming from.
   
   [CAUTION]
   --
   Avoid using https://groovy-lang.org/metaprogramming.html#_metaclasses[Groovy MetaClass] programming techniques in your build scripts. Gradle provides its own API for adding <<writing_build_scripts#sec:extra_properties,dynamic runtime properties>>.
   
   Use of Groovy-specific metaprogramming can cause builds to retain large amounts of memory between builds that will eventually cause the Gradle daemon to run out-of-memory.
   --
   
   == Properties
   
   [source,groovy]
   <obj>.<name>                // Get a property value
   <obj>.<name> = <value>      // Set a property to a new value
   "$<name>"                   // Embed a property value in a string
   "${<obj>.<name>}"           // Same as previous (embedded value)
   
   [source,groovy]
   .Examples
   ----
   version = '1.0.1'
   myCopyTask.description = 'Copies some files'
   
   file("$projectDir/src")
   println "Destination: ${myCopyTask.destinationDir}"
   ----
   
   A property represents some state of an object. The presence of an `=` sign is a clear indicator that you're looking at a property. Otherwise, a qualified name  it begins with `<obj>.` 댹망ithout any other decoration is also a property.
   
   If the name is unqualified, then it may be one of the following:
   
    * A task instance with that name.
    * A property on link:{groovyDslPath}#[Project].
    * An <<writing_build_scripts#sec:extra_properties,extra property>> defined elsewhere in the project.
    * A property of an implicit object within a <<#groovy:blocks,block>>.
    * A <<#groovy:local_variables,local variable>> defined earlier in the build script.
   
   Note that plugins can add their own properties to the `Project` object. The link:{groovyDslPath}#[API documentation] lists all the properties added by core plugins. If you're struggling to find where a property comes from, check the documentation for the plugins that the build uses.
   
   TIP: When referencing a project property in your build script that is added by a non-core plugin, consider prefixing it with `project.` 댹말t's clear then that the property belongs to the project object.
   
   === Properties in the API documentation
   
   The link:{groovyDslPath}#[Groovy DSL reference] shows properties as they are used in your build scripts, but the Javadocs only display methods. That's because properties are implemented as methods behind the scenes:
   
    * A property can be _read_ if there is a method named `get<PropertyName>` with zero arguments that returns the same type as the property.
    * A property can be _modified_ if there is a method named `set<PropertyName>` with one argument that has the same type as the property and a return type of `void`.
   
   Note that property names usually start with a lower-case letter, but that letter is upper case in the method names. So the getter method `getProjectVersion()` corresponds to the property `projectVersion`. This convention does not apply when the name begins with at least two upper-case letters, in which case there is not change in case. For example, `getRAM()` corresponds to the property `RAM`.
   
   [source,groovy]
   .Examples
   ----
   project.getVersion()
   project.version
   
   project.setVersion('1.0.1')
   project.version = '1.0.1'
   ----
   
   
   == Methods
   
   [source,groovy]
   <obj>.<name>()              // Method call with no arguments
   <obj>.<name>(<arg>, <arg>)  // Method call with multiple arguments
   <obj>.<name> <arg>, <arg>   // Method call with multiple args (no parentheses)
   
   [source,groovy]
   .Examples
   ----
   myCopyTask.include '**/*.xml', '**/*.properties'
   
   ext.resourceSpec = copySpec()   // `copySpec()` comes from `Project`
   
   file('src/main/java')
   println 'Hello, World!'
   ----
   
   A method represents some behavior of an object, although Gradle often uses methods to configure the state of objects as well. Methods are identifiable by their arguments or empty parentheses. Note that parentheses are sometimes required, such as when a method has zero arguments, so you may find it simplest to always use parentheses.
   
   NOTE: Gradle has a convention whereby if a method has the same name as a collection-based property, then the method _appends_ its values to that collection.
   
   == Blocks
   
   Blocks are also <<#groovy:methods,methods>>, just with specific types for the last argument.
   
   [source,groovy]
   ----
   <obj>.<name> {
        ...
   }
   
   <obj>.<name>(<arg>, <arg>) {
        ...
   }
   ----
   
   [source,groovy]
   .Examples
   ----
   plugins {
       id 'java-library'
   }
   
   configurations {
       assets
   }
   
   sourceSets {
       main {
           java {
               srcDirs = ['src']
           }
       }
   }
   
   dependencies {
       implementation project(':util')
   }
   ----
   
   Blocks are a mechanism for configuring multiple aspects of a build element in one go. They also provide a way to nest configuration, leading to a form of structured data.
   
   There are two important aspects of blocks that you should understand:
   
    1. They are implemented as methods with specific signatures.
    2. They can change the target ("delegate") of unqualified methods and properties.
   
   Both are based on Groovy language features and we explain them in the following sections.
   
   === Block method signatures
   
   You can easily identify a method as the implementation behind a block by its signature, or more specifically, its argument types. If a method corresponds to a block:
   
    * It must have at least one argument.
    * The _last_ argument must be of type https://docs.groovy-lang.org/latest/html/gapi/groovy/lang/Closure.html[`groovy.lang.Closure`] or link:{javadocPath}#[org.gradle.api.Action].
   
   For example, link:{groovyDslPath}#[Project.copy(Action)] matches these requirements, so you can use the syntax:
   
   [source,groovy]
   copy {
       into layout.buildDirectory.dir("tmp")
       from 'custom-resources'
   }
   
   That leads to the question of how `into()` and `from()` work. They're clearly methods, but where would you find them in the API documentation? The answer comes from understanding object _delegation_.
   
   === Delegation
   
   The <<#groovy:properties,section on properties>> lists where unqualified properties might be found. One common place is on the `Project` object. But there is an alternative source for those unqualified properties and methods inside a block: the block's _delegate object_.
   
   To help explain this concept, consider the last example from the previous section:
   
   [source,groovy]
   copy {
       into layout.buildDirectory.dir("tmp")
       from 'custom-resources'
   }
   
   All the methods and properties in this example are unqualified. You can easily find `copy()` and `layout` in the link:{groovyDslPath}#[`Project` API documentation], but what about `into()` and `from()`? These are resolved against the delegate of the `copy {}` block. What is the type of that delegate? You'll need to link:{groovyDslPath}#[check the API documentation for that].
   
   There are two ways to determine the delegate type, depending on the signature of the block method:
   
    * For `Action` arguments, look at the type's parameter.
   +
   In the example above, the method signature is `copy(Action<? super CopySpec>)` and it's the bit inside the angle brackets that tells you the delegate type 댹맓ink:{javadocPath}#[CopySpec] in this case.
    * For `Closure` arguments, the documentation will explicitly say in the description what type is being configured or what type the delegate it (different terminology for the same thing).
   
   Hence you can find both link:{javadocPath}#[into()] and link:{javadocPath}#[from()] on `CopySpec`. You might even notice that both of those methods have variants that take an `Action` as their last argument, which means you can use block syntax with them.
   
   All new Gradle APIs declare an `Action` argument type rather than `Closure`, which makes it very easy to pick out the delegate type. Even older APIs have an `Action` variant in addition to the old `Closure` one.
   
   == Local variables
   
   [source,groovy]
   def <name> = <value>        // Untyped variable
   <type> <name> = <value>     // Typed variable
   
   [source,groovy]
   .Examples
   ----
   def i = 1
   String errorMsg = 'Failed, because reasons'
   ----
   
   Local variables are a Groovy construct  unlike <<writing_build_scripts#sec:extra_properties,extra properties>> 댹맚hat can be used to share values within a build script.
   
   [CAUTION]
   ====
   Avoid using local variables in the root of the project, i.e. as pseudo project properties. They cannot be read outside of the build script and Gradle has no knowledge of them.
   
   Within a narrower context 댹맙uch as configuring a task  local variables can occasionally be helpful.
   ====

/docs/userguide/api/kotlin_dsl.adoc
===================================

.. code-block::

   :kotlin-reference: https://kotlinlang.org/docs/reference/
   :kotlin-tutorials: https://kotlinlang.org/tutorials/
   :gradle-issues: https://github.com/gradle/gradle/issues/
   :plugin-portal: https://plugins.gradle.org/
   
   = Gradle Kotlin DSL Primer
   
   Gradle's Kotlin DSL provides an alternative syntax to the traditional Groovy DSL with an enhanced editing experience in supported IDEs, with superior content assist, refactoring, documentation, and more.
   This chapter provides details of the main Kotlin DSL constructs and how to use it to interact with the Gradle API.
   
   TIP: If you are interested in migrating an existing Gradle build to the Kotlin DSL, please also check out the dedicated <<migrating_from_groovy_to_kotlin_dsl.adoc#migrating_groovy_kotlin,migration section>>.
   
   == Prerequisites
   
   * The embedded Kotlin compiler is known to work on Linux, macOS, Windows, Cygwin, FreeBSD and Solaris on x86-64 architectures.
   * Knowledge of Kotlin syntax and basic language features is very helpful. The link:{kotlin-reference}[Kotlin reference documentation] and link:https://kotlinlang.org/docs/tutorials/koans.html[Kotlin Koans] will help you to learn the basics.
   * Use of the <<plugins#sec:plugins_block,plugins {}>> block to declare Gradle plugins significantly improves the editing experience and is highly recommended.
   
   == IDE support
   
   The Kotlin DSL is fully supported by IntelliJ IDEA and Android Studio. Other IDEs do not yet provide helpful tools for editing Kotlin DSL files, but you can still import Kotlin-DSL-based builds and work with them as usual.
   
   .IDE support matrix
   [cols=">.^,^.^,^.^,^.^",frame=none,grid=rows,options="header"]
   |===
   ||Build import|Syntax highlighting ^1^|Semantic editor ^2^
   
   |IntelliJ IDEA
   |[.green]#*九*#
   |[.green]#*九*#
   |[.green]#*九*#
   
   |Android Studio
   |[.green]#*九*#
   |[.green]#*九*#
   |[.green]#*九*#
   
   |Eclipse IDE
   |[.green]#*九*#
   |[.green]#*九*#
   |[.red]#九#
   
   |CLion
   |[.green]#*九*#
   |[.green]#*九*#
   |[.red]#九#
   
   |Apache NetBeans
   |[.green]#*九*#
   |[.green]#*九*#
   |[.red]#九#
   
   |Visual Studio Code ^(LSP)^
   |[.green]#*九*#
   |[.green]#*九*#
   |[.red]#九#
   
   |Visual Studio
   |[.green]#*九*#
   |[.red]#九#
   |[.red]#九#
   
   |===
   
   [%hardbreaks]
   ^1^ ^Kotlin^ ^syntax^ ^highlighting^ ^in^ ^Gradle^ ^Kotlin^ ^DSL^ ^scripts^
   ^2^ ^code^ ^completion,^ ^navigation^ ^to^ ^sources,^ ^documentation,^ ^refactorings^ ^etc...^ ^in^ ^Gradle^ ^Kotlin^ ^DSL^ ^scripts^
   
   As mentioned in the limitations, you must link:https://www.jetbrains.com/help/idea/gradle.html#gradle_import[import your project from the Gradle model] to get content-assist and refactoring tools for Kotlin DSL scripts in IntelliJ IDEA.
   
   Builds with slow configuration time might affect the IDE responsiveness, so please check out the <<performance.adoc#performance_gradle,performance section>> to help resolve such issues.
   
   === Automatic build import vs. automatic reloading of script dependencies
   
   Both IntelliJ IDEA and Android Studio 댹망hich is derived from IntelliJ IDEA  will detect when you make changes to your build logic and offer two suggestions:
   
    1. Import the whole build again
   +
   image::intellij-build-import-popup.png[IntelliJ IDEA, width=300]
   +
   image::android-studio-build-sync-popup.png[IntelliJ IDEA]
    2. Reload script dependencies when editing a build script
   +
   image::intellij-script-dependencies-reload.png[Reload script dependencies]
   
   We recommend that you _disable automatic build import_, but _enable automatic reloading of script dependencies_.
   That way you get early feedback while editing Gradle scripts and control over when the whole build setup gets synchronized with your IDE.
   
   === Troubleshooting
   
   The IDE support is provided by two components:
   
   * The Kotlin Plugin used by IntelliJ IDEA/Android Studio
   * Gradle
   
   The level of support varies based on the versions of each.
   
   If you run into trouble, the first thing you should try is running `./gradlew tasks` from the command line to see whether your issue is limited to the IDE. If you encounter the same problem from the command line, then the issue is with the build rather than the IDE integration.
   
   If you can run the build successfully from the command line but your script editor is complaining, then you should try restarting your IDE and invalidating its caches.
   
   If the above doesn't work and you suspect an issue with the Kotlin DSL script editor, you can:
   
   * Run `./gradle tasks` to get more details
   * Check the logs in one of these locations:
   ** `$HOME/Library/Logs/gradle-kotlin-dsl` on Mac OS X
   ** `$HOME/.gradle-kotlin-dsl/log` on Linux
   ** `$HOME/AppData/Local/gradle-kotlin-dsl/log` on Windows
   * Open an issue on the link:{gradle-issues}[Gradle issue tracker], including as much detail as you can.
   
   From version 5.1 onwards, the log directory is cleaned up automatically.
   It is checked periodically (at most every 24 hours) and log files are deleted if they haven뗪 been used for 7 days.
   
   If the above isn't enough to pinpoint the problem, you can enable the `org.gradle.kotlin.dsl.logging.tapi` system property in your IDE. This will cause the Gradle Daemon to log extra information in its log file located in `$HOME/.gradle/daemon`. In IntelliJ IDEA this can be done by opening `Help > Edit Custom VM Options...` and adding `-Dorg.gradle.kotlin.dsl.logging.tapi=true`.
   
   For IDE problems outside of the Kotlin DSL script editor, please open issues in the corresponding IDE's issue tracker:
   
   * link:[JetBrains's IDEA issue tracker],
   * link:[Google's Android Studio issue tracker].
   
   Lastly, if you face problems with Gradle itself or with the Kotlin DSL, please open issues on the link:{gradle-issues}[Gradle issue tracker].
   
   
   == Kotlin DSL scripts
   
   Just like the Groovy-based equivalent, the Kotlin DSL is implemented on top of Gradle's Java API.
   Everything you can read in a Kotlin DSL script is Kotlin code compiled and executed by Gradle.
   Many of the objects, functions and properties you use in your build scripts come from the Gradle API and the APIs of the applied plugins.
   
   TIP: You can use the link:{kotlinDslPath}/[Kotlin DSL reference] search functionality to drill through the available members.
   
   === Script file names
   
   * Groovy DSL script files use the `.gradle` file name extension.
   * Kotlin DSL script files use the `.gradle.kts` file name extension.
   
   To activate the Kotlin DSL, simply use the `.gradle.kts` extension for your build scripts in place of `.gradle`. That also applies to the <<organizing_gradle_projects#sec:settings_file,settings file>>  for example `settings.gradle.kts`  and <<init_scripts#init_scripts,initialization scripts>>.
   
   Note that you can mix Groovy DSL build scripts with Kotlin DSL ones, i.e. a Kotlin DSL build script can apply a Groovy DSL one and each project in a multi-project build can use either one.
   
   We recommend that you apply the following conventions to get better IDE support:
   
   * Name settings scripts (or any script that is backed by a Gradle `Settings` object) according to the pattern `*.settings.gradle.kts` 댹맚his includes script plugins that are applied from settings scripts
   * Name <<init_scripts#init_scripts,initialization scripts>> according to the pattern `*.init.gradle.kts` or simply `init.gradle.kts`.
   
   This is so that the IDE knows what type of object "backs" the script, be it link:{groovyDslPath}#[Project], link:{groovyDslPath}#[Settings] or link:{groovyDslPath}#[Gradle].
   
   === Implicit imports
   
   All Kotlin DSL build scripts have implicit imports consisting of:
   
   * The <<writing_build_scripts#script-default-imports,default Gradle API imports>>
   * The Kotlin DSL API, which is all types within the following packages:
   ** `org.gradle.kotlin.dsl`
   ** `org.gradle.kotlin.dsl.plugins.dsl`
   ** `org.gradle.kotlin.dsl.precompile`
   
   .Avoid using internal Kotlin DSL APIs
   --
   Use of internal Kotlin DSL APIs in plugins and build scripts has the potential to break builds when either Gradle or plugins change.
   The link:{kotlinDslPath}/[Kotlin DSL API] extends the <<authoring_maintainable_build_scripts#sec:avoiding_gradle_internal_apis,Gradle public API>> with the types listed in the link:{kotlinDslPath}/[corresponding API docs] that are in the packages listed above (but not subpackages of those).
   --
   
   === Compilation warnings
   
   Gradle Kotlin DSL scripts are compiled by Gradle during the configuration phase of your build.
   Deprecation warnings found by the Kotlin compiler are reported on the console when compiling the scripts.
   
   [source,text]
   ----
   > Configure project :
   w: build.gradle.kts:4:5: 'getter for uploadTaskName: String!' is deprecated. Deprecated in Java
   ----
   
   It is possible to configure your build to fail on any warning emitted during script compilation by <<build_environment#sec:gradle_configuration_properties,setting>> the `org.gradle.kotlin.dsl.allWarningsAsErrors` Gradle property to `true`:
   
   [source,properties]
   ----
   # gradle.properties
   org.gradle.kotlin.dsl.allWarningsAsErrors=true
   ----
   
   == Type-safe model accessors
   
   The Groovy DSL allows you to reference many elements of the build model by name, even when they are defined at runtime. Think named configurations, named source sets, and so on. For example, you can get hold of the `implementation` configuration via `configurations.implementation`.
   
   The Kotlin DSL replaces such dynamic resolution with type-safe model accessors that work with model elements contributed by plugins.
   
   === Understanding when type-safe model accessors are available
   
   The Kotlin DSL currently supports type-safe model accessors for any of the following that are contributed by plugins:
   
   * Dependency and artifact configurations (such as `implementation` and `runtimeOnly` contributed by the Java Plugin)
   * Project extensions and conventions (such as `sourceSets`)
   * Extensions on the `dependencies` and `repositories` containers
   * Elements in the `tasks` and `configurations` containers
   * Elements in <<kotdsl:containers,project-extension containers>> (for example the source sets contributed by the Java Plugin that are added to the `sourceSets` container)
   * Extensions on each of the above
   
   [IMPORTANT]
   ====
   Only the main project build scripts and precompiled project script plugins have type-safe model accessors.
   Initialization scripts, settings scripts, script plugins do not.
   These limitations will be removed in a future Gradle release.
   ====
   
   The set of type-safe model accessors available is calculated right before evaluating the script body, immediately after the `plugins {}` block.
   Any model elements contributed after that point do not work with type-safe model accessors.
   For example, this includes any configurations you might define in your own build script.
   However, this approach does mean that you can use type-safe accessors for any model elements that are contributed by plugins that are _applied by parent projects_.
   
   The following project build script demonstrates how you can access various configurations, extensions and other elements using type-safe accessors:
   
   .Using type-safe model accessors
   ====
   include::sample[dir="snippets/kotlinDsl/accessors/kotlin",files="build.gradle.kts[tags=accessors]"]
   ====
   <1> Uses type-safe accessors for the `api`, `implementation` and `testImplementation` dependency configurations contributed by the <<java_library_plugin#java_library_plugin,Java Library Plugin>>
   <2> Uses an accessor to configure the `sourceSets` project extension
   <3> Uses an accessor to configure the `main` source set
   <4> Uses an accessor to configure the `java` source for the `main` source set
   <5> Uses an accessor to configure the `test` task
   
   [TIP]
   ====
   Your IDE knows about the type-safe accessors, so it will include them in its suggestions.
   
   This will happen both at the top level of your build scripts  most plugin extensions are added to the `Project` object  and within the blocks that configure an extension.
   ====
   
   Note that accessors for elements of containers such as `configurations`, `tasks` and `sourceSets` leverage Gradle's <<lazy_configuration#lazy_configuration,configuration avoidance APIs>>.
   For example, on `tasks` they are of type `TaskProvider<T>` and provide a lazy reference and lazy configuration of the underlying task.
   Here are some examples that illustrate the situations in which configuration avoidance applies:
   
   [source,kotlin]
   ----
   tasks.test {
       // lazy configuration
   }
   
   // Lazy reference
   val testProvider: TaskProvider<Test> = tasks.test
   
   testProvider {
       // lazy configuration
   }
   
   // Eagerly realized Test task, defeat configuration avoidance if done out of a lazy context
   val test: Test = tasks.test.get()
   ----
   
   For all other containers than `tasks`, accessors for elements are of type `NamedDomainObjectProvider<T>` and provide the same behavior.
   
   === Understanding what to do when type-safe model accessors are not available
   
   Consider the sample build script shown above that demonstrates the use of type-safe accessors.
   The following sample is exactly the same except that is uses the `apply()` method to apply the plugin.
   The build script can not use type-safe accessors in this case because the `apply()` call happens in the body of the build script.
   You have to use other techniques instead, as demonstrated here:
   
   .Configuring plugins without type-safe accessors
   ====
   include::sample[dir="snippets/kotlinDsl/noAccessors/kotlin",files="build.gradle.kts[tags=no-accessors]"]
   ====
   
   Type-safe accessors are unavailable for model elements contributed by the following:
   
    * Plugins applied via the `apply(plugin = "id")` method
    * The project build script
    * Script plugins, via `apply(from = "script-plugin.gradle.kts")`
    * Plugins applied via <<sec:kotlin_cross_project_configuration,cross-project configuration>>
   
   You also can not use type-safe accessors in Binary Gradle plugins implemented in Kotlin.
   
   If you can't find a type-safe accessor, _fall back to using the normal API_ for the corresponding types.
   To do that, you need to know the names and/or types of the configured model elements.
   We'll now show you how those can be discovered by looking at the above script in detail.
   
   ==== Artifact configurations
   
   The following sample demonstrates how to reference and configure artifact configurations without type accessors:
   
   .Artifact configurations
   ====
   include::sample[dir="snippets/kotlinDsl/noAccessors/kotlin",files="build.gradle.kts[tags=dependencies]"]
   ====
   
   The code looks similar to that for the type-safe accessors, except that the configuration names are string literals in this case.
   You can use string literals for configuration names in dependency declarations and within the `configurations {}` block.
   
   The IDE won't be able to help you discover the available configurations in this situation, but you can look them up either in the corresponding plugin's documentation or by running `gradle dependencies`.
   
   ==== Project extensions and conventions
   
   Project extensions and <<#sec:kotlin_dsl_about_conventions,conventions>> have both a name and a unique type, but the Kotlin DSL only needs to know the type in order to configure them.
   As the following sample shows for the `sourceSets {}` and `java {}` blocks from the original example build script, you can use the link:{kotlinDslPath}/gradle/org.gradle.kotlin.dsl/configure.html[`configure<T>()`] function with the corresponding type to do that:
   
   .Project extensions and conventions
   ====
   include::sample[dir="snippets/kotlinDsl/noAccessors/kotlin",files="build.gradle.kts[tags=project-extension]"]
   ====
   
   Note that `sourceSets` is a Gradle extension on `Project` of type `SourceSetContainer` and `java` is an extension on `Project` of type `JavaPluginExtension`.
   
   You can discover what extensions and conventions are available either by looking at the documentation for the applied plugins or by running `gradle kotlinDslAccessorsReport`, which prints the Kotlin code necessary to access the model elements contributed by all the applied plugins.
   The report provides both names and types.
   As a last resort, you can also check a plugin's source code, but that shouldn't be necessary in the majority of cases.
   
   Note that you can also use the link:{kotlinDslPath}/gradle/org.gradle.kotlin.dsl/the.html[`the<T>()`] function if you only need a reference to the extension or convention without configuring it, or if you want to perform a one-line configuration, like so:
   
   [source,kotlin]
   ----
   the<SourceSetContainer>()["main"].srcDir("src/core/java")
   ----
   
   The snippet above also demonstrates one way of configuring the elements of a project extension that is a container.
   
   ==== Elements in project-extension containers
   
   Container-based project extensions, such as `SourceSetContainer`, also allow you to configure the elements held by them.
   In our sample build script, we want to configure a source set named `main` within the source set container, which we can do by using the link:{javadocPath}#[named()] method in place of an accessor, like so:
   
   .Elements of project extensions that are containers
   ====
   include::sample[dir="snippets/kotlinDsl/noAccessors/kotlin",files="build.gradle.kts[tags=project-container-extension]"]
   ====
   
   All elements within a container-based project extension have a name, so you can use this technique in all such cases.
   
   As for project extensions and conventions themselves, you can discover what elements are present in any container by either looking at the documentation of the applied plugins or by running `gradle kotlinDslAccessorsReport`.
   And as a last resort, you may be able to view the plugin's source code to find out what it does, but that shouldn't be necessary in the majority of cases.
   
   ==== Tasks
   
   Tasks are not managed through a container-based project extension, but they are part of a container that behaves in a similar way.
   This means that you can configure tasks in the same way as you do for source sets, as you can see in this example:
   
   .Tasks
   ====
   include::sample[dir="snippets/kotlinDsl/noAccessors/kotlin",files="build.gradle.kts[tags=tasks]"]
   ====
   
   We are using the Gradle API to refer to the tasks by name and type, rather than using accessors.
   Note that it's necessary to specify the type of the task explicitly, otherwise the script won't compile because the inferred type will be `Task`, not `Test`, and the `testLogging` property is specific to the `Test` task type.
   You can, however, omit the type if you only need to configure properties or to call methods that are common to all tasks, i.e. they are declared on the `Task` interface.
   
   One can discover what tasks are available by running `gradle tasks`. You can then find out the type of a given task by running `gradle help --task <taskName>`, as demonstrated here:
   
   [source,text]
   ----
   仇 ./gradlew help --task test
   ...
   Type
        Test (org.gradle.api.tasks.testing.Test)
   ----
   
   Note that the IDE can assist you with the required imports, so you only need the simple names of the types, i.e. without the package name part.
   In this case, there's no need to import the `Test` task type as it is part of the Gradle API and is therefore <<kotlin_dsl#sec:implicit_imports,imported implicitly>>.
   
   === About conventions
   
   Some of the Gradle core plugins expose configurability with the help of a so-called _convention_ object.
   These serve a similar purpose to 댹마nd have now been superseded by 댹_extensions_.
   Conventions are deprecated.
   Please avoid using convention objects when writing new plugins.
   
   As seen above, the Kotlin DSL provides accessors only for convention objects on `Project`.
   There are situations that require you to interact with a Gradle plugin that uses convention objects on other types.
   The Kotlin DSL provides the `withConvention(T::class) {}` extension function to do this:
   
   .Configuring source set conventions
   ====
   include::sample[dir="snippets/kotlinDsl/sourceSetConvention/kotlin",files="build.gradle.kts[tags=source-set-convention]"]
   ====
   
   This technique is primarily necessary for source sets added by language plugins that have yet to be migrated to extensions.
   
   == Multi-project builds
   
   As with single-project builds, you should try to use the `plugins {}` block in your multi-project builds so that you can use the type-safe accessors. Another consideration with multi-project builds is that you won't be able to use type-safe accessors when configuring subprojects within the root build script or with other forms of cross configuration between projects. We discuss both topics in more detail in the following sections.
   
   === Applying plugins
   
   You can declare your plugins within the subprojects to which they apply, but we recommend that you also declare them within the root project build script. This makes it easier to keep plugin versions consistent across projects within a build. The approach also improves the performance of the build.
   
   The <<plugins#sec:subprojects_plugins_dsl,Using Gradle plugins>> chapter explains how you can declare plugins in the root project build script with a version and then apply them to the appropriate subprojects' build scripts. What follows is an example of this approach using three subprojects and three plugins. Note how the root build script only declares the community plugins as the Java Library Plugin is tied to the version of Gradle you are using:
   
   .Declare plugin dependencies in the root build script using the `plugins {}` block
   ====
   include::sample[dir="snippets/kotlinDsl/multiProjectBuild/kotlin",files="settings.gradle.kts[tags=base];build.gradle.kts[tags=root];domain/build.gradle.kts[];infra/build.gradle.kts[];http/build.gradle.kts[]"]
   ====
   
   If your build requires additional plugin repositories on top of the Gradle Plugin Portal, you should declare them in the `pluginManagement {}` block in your `settings.gradle.kts` file, like so:
   
   .Declare additional plugin repositories
   ====
   include::sample[dir="snippets/kotlinDsl/multiProjectBuild/kotlin",files="settings.gradle.kts[tags=repositories]"]
   ====
   
   Plugins fetched from a source other than the link:https://plugins.gradle.org/[Gradle Plugin Portal] can only be declared via the `plugins {}` block if they are published with their <<plugins#sec:plugin_markers,plugin marker artifacts>>.
   
   NOTE: At the time of writing, all versions of the Android Plugin for Gradle up to 3.2.0 present in the `google()` repository lack plugin marker artifacts.
   
   If those artifacts are missing, then you can't use the `plugins {}` block. You must instead fall back to declaring your plugin dependencies using the `buildscript {}` block in the root project build script. Here's an example of doing that for the Android Plugin:
   
   .Declare plugin dependencies in the root build script using the `buildscript {}` block
   ====
   include::sample[dir="snippets/kotlinDsl/androidBuild/kotlin",files="settings.gradle.kts[tags=android];build.gradle.kts[tags=android-buildscript];lib/build.gradle.kts[tags=android];app/build.gradle.kts[tags=android]"]
   ====
   
   This technique is not that different from what Android Studio produces when creating a new build.
   The main difference is that the subprojects' build scripts in the above sample declare their plugins using the `plugins {}` block. This means that you can use type-safe accessors for the model elements that they contribute.
   
   Note that you can't use this technique if you want to apply such a plugin either to the root project build script of a multi-project build (rather than solely to its subprojects) or to a single-project build. You'll need to use a different approach in those cases that we detail in <<kotlin_dsl#sec:plugins_resolution_strategy,another section>>.
   
   === Cross-configuring projects
   
   <<sharing_build_logic_between_subprojects#sec:convention_plugins_vs_cross_configuration,Cross project configuration>> is a mechanism by which you can configure a project from another project's build script. A common example is when you configure subprojects in the root project build script.
   
   Taking this approach means that you won't be able to use type-safe accessors for model elements contributed by the plugins. You will instead have to rely on string literals and the standard Gradle APIs.
   
   As an example, let's modify the <<ex:multi_project_ratpack,Java/Ratpack sample build>> to fully configure its subprojects from the root project build script:
   
   .Cross-configuring projects
   ====
   include::sample[dir="snippets/kotlinDsl/multiProjectBuild/kotlin",files="settings.gradle.kts[tags=base];build.gradle.kts[tags=cross]"]
   ====
   
   Note how we're using the `apply()` method to apply the plugins since the `plugins {}` block doesn't work in this context.
   We are also using standard APIs instead of type-safe accessors to configure tasks, extensions and conventions  an approach that we discussed in <<kotlin_dsl#sec:kotlin_using_standard_api,more detail elsewhere>>.
   
   == When you can't use the `plugins {}` block
   
   Plugins fetched from a source other than the link:https://plugins.gradle.org/[Gradle Plugin Portal] may or may not be usable with the `plugins {}` block.
   It depends on how they have been published and, specifically, whether they have been published with the necessary <<plugins#sec:plugin_markers,plugin marker artifacts>>.
   
   For example, the Android Plugin for Gradle is not published to the Gradle Plugin Portal and 댹마t least up to version 3.2.0 of the plugin 댹맚he metadata required to resolve the artifacts for a given plugin identifier is not published to the Google repository.
   
   If your build is a multi-project build and you don't need to apply such a plugin to your _root_ project, then you can get round this issue using the technique <<kotlin_dsl#sec:multi_project_builds_applying_plugins,described above>>.
   For any other situation, keep reading.
   
   [TIP]
   ====
   When publishing plugins, please use Gradle's built-in <<java_gradle_plugin#java_gradle_plugin,Gradle Plugin Development Plugin>>.
   
   It automates the publication of the metadata necessary to make your plugins usable with the `plugins {}` block.
   ====
   
   We will show you in this section how to apply the Android Plugin to a single-project build or the root project of a multi-project build.
   The goal is to instruct your build on how to map the `com.android.application` plugin identifier to a resolvable artifact.
   This is done in two steps:
   
   * Add a plugin repository to the build's settings script
   * Map the plugin ID to the corresponding artifact coordinates
   
   You accomplish both steps by configuring a `pluginManagement {}` block in the build's settings script.
   To demonstrate, the following sample adds the `google()` repository  where the Android plugin is published  to the repository search list, and uses a `resolutionStrategy {}` block to map the `com.android.application` plugin ID to the `com.android.tools.build:gradle:<version>` artifact available in the `google()` repository:
   
   .Mapping plugin IDs to dependency coordinates
   ====
   include::sample[dir="snippets/kotlinDsl/androidSingleBuild/kotlin",files="settings.gradle.kts[tags=android];build.gradle.kts[tags=android]"]
   ====
   
   In fact, the above sample will work for all `com.android.*` plugins that are provided by the specified module. That's because the packaged module contains the details of which plugin ID maps to which plugin implementation class, using the properties-file mechanism described in the <<custom_plugins#sec:custom_plugins_standalone_project,Writing Custom Plugins>> chapter.
   
   See the <<plugins#sec:plugin_management,Plugin Management>> section of the Gradle user manual for more information on the `pluginManagement {}` block and what it can be used for.
   
   // [PL] It seems to me that this block of content should really be in a more generic part
   //      of the user manual as it discusses techniques that apply outside of the Kotlin DSL.
   //      In fact, it indicates missing content that this chapter should be able to link to.
   //
   // In the case of multi-project builds, this approach is similar to using a `buildscript {}` block in the root project build script to depend on third party plugins and then using `plugins {}` in your sub project build scripts to apply them.
   // The main difference is that this approach means that the root project can also benefit from the `plugins {}` block and it is more aligned with Gradle best practices.
   //
   // [PL] We should also aim to avoid temporary information in the user manual that could
   //      be out of date at any time.
   // The same approach can be used to resolve plugins from composite builds, which link:https://github.com/gradle/gradle/issues/2528[do not expose plugin markers] yet.
   // Simply map the plugin ID to the corresponding artifact coordinates as shown in the Android samples above.
   
   
   // TODO ?
   // == Using `buildSrc`
   //
   // 1. what is buildSrc -> link
   // 2. apply the `kotlin-dsl` plugin, see below for the details
   // 3. all dependencies added to `buildSrc/build.gradle.kts` will be available to all build scripts
   // 3. all members from `buildSrc/src/main/kotlin` will be available to all build scripts
   // 4. handy for constants, objects, functions, extension functions
   // 5. perfect for Gradle Tasks, Gradle Plugins and DSL Extensions
   
   
   == Working with container objects
   
   The Gradle build model makes heavy use of container objects (or just "containers").
   For example, both `configurations` and `tasks` are container objects that contain `Configuration` and `Task` objects respectively.
   Community plugins also contribute containers, like the `android.buildTypes` container contributed by the Android Plugin.
   
   The Kotlin DSL provides several ways for build authors to interact with containers.
   We look at each of those ways next, using the `tasks` container as an example.
   
   TIP: Note that you can leverage the type-safe accessors described in <<kotdsl:accessor_applicability,another section>> if you are configuring existing elements on supported containers. That section also describes which containers support type-safe accessors.
   
   === Using the container API
   
   All containers in Gradle implement link:{groovyDslPath}#[NamedDomainObjectContainer<DomainObjectType>].
   Some of them can contain objects of different types and implement link:{groovyDslPath}#[PolymorphicDomainObjectContainer<BaseType>].
   The simplest way to interact with containers is through these interfaces.
   
   The following sample demonstrates how you can use the link:{groovyDslPath}#[named()] method to configure existing tasks and the link:{groovyDslPath}#[register()] method to create new ones.
   
   .Using the container API
   ====
   include::sample[dir="snippets/kotlinDsl/containers-api/kotlin",files="build.gradle.kts[tags=api]"]
   ====
   <1> Gets a reference of type `Task` to the existing task named `check`
   <2> Registers a new untyped task named `myTask1`
   <3> Gets a reference to the existing task named `compileJava` of type `JavaCompile`
   <4> Registers a new task named `myCopy1` of type `Copy`
   <5> Gets a reference to the existing (untyped) task named `assemble` and configures it 댹맟ou can only configure properties and methods that are available on `Task` with this syntax
   <6> Registers a new untyped task named `myTask2` and configures it 댹맟ou can only configure properties and methods that are available on `Task` in this case
   <7> Gets a reference to the existing task named `test` of type `Test` and configures it 댹말n this case you have access to the properties and methods of the specified type
   <8> Registers a new task named `myCopy2` of type `Copy` and configures it
   
   NOTE: The above sample relies on the configuration avoidance APIs. If you need or want to eagerly configure or register container elements, simply replace `named()` with `getByName()` and `register()` with `create()`.
   
   === Using Kotlin delegated properties
   
   Another way to interact with containers is via Kotlin delegated properties.
   These are particularly useful if you need a reference to a container element that you can use elsewhere in the build.
   In addition, Kotlin delegated properties can easily be renamed via IDE refactoring.
   
   The following sample does the exact same things as the one in the previous section, but it uses delegated properties and reuses those references in place of string-literal task paths:
   
   .Using Kotlin delegated properties
   ====
   include::sample[dir="snippets/kotlinDsl/containers-delegated-properties/kotlin",files="build.gradle.kts[tags=delegated-properties]"]
   ====
   <1> Uses the reference to the `myTask1` task rather than a task path
   
   
   [NOTE]
   ====
   The above rely on configuration avoidance APIs.
   If you need to eagerly configure or register container elements simply replace link:{kotlinDslPath}/gradle/org.gradle.kotlin.dsl/existing.html[`existing()`] with link:{kotlinDslPath}/gradle/org.gradle.kotlin.dsl/getting.html[`getting()`] and link:{kotlinDslPath}/gradle/org.gradle.kotlin.dsl/registering.html[`registering()`] with link:{kotlinDslPath}/gradle/org.gradle.kotlin.dsl/creating.html[`creating()`].
   ====
   
   === Configuring multiple container elements together
   
   When configuring several elements of a container one can group interactions in a block in order to avoid repeating the container's name on each interaction.
   The following example uses a combination of type-safe accessors, the container API and Kotlin delegated properties:
   
   .Container scope
   ====
   include::sample[dir="snippets/kotlinDsl/containers-scope/kotlin",files="build.gradle.kts[tags=scope]"]
   ====
   
   // TODO decide if we should document this given the current limitation
   // === The container scope string invoke extension
   //
   // .The container scope string invoke extension
   // ====
   // include::sample[dir="snippets/kotlinDsl/containers-string-invoke/kotlin",files="build.gradle.kts[tags=string-invoke]"]
   // ====
   
   
   == Working with runtime properties
   
   Gradle has two main sources of properties that are defined at runtime: <<project_properties.adoc#sec:project_properties,_project properties_>> and <<writing_build_scripts#sec:extra_properties,_extra properties_>>.
   The Kotlin DSL provides specific syntax for working with these types of properties, which we look at in the following sections.
   
   === Project properties
   
   The Kotlin DSL allows you to access project properties by binding them via Kotlin delegated properties.
   Here's a sample snippet that demonstrates the technique for a couple of project properties, one of which _must_ be defined:
   
   .build.gradle.kts
   [source,kotlin]
   ----
   val myProperty: String by project  // <1>
   val myNullableProperty: String? by project // <2>
   ----
   <1> Makes the `myProperty` project property available via a `myProperty` delegated property 댹맚he project property must exist in this case, otherwise the build will fail when the build script attempts to use the `myProperty` value
   <2> Does the same for the `myNullableProperty` project property, but the build won't fail on using the `myNullableProperty` value as long as you check for null (standard https://kotlinlang.org/docs/reference/null-safety.html[Kotlin rules for null safety] apply)
   
   The same approach works in both settings and initialization scripts, except you use `by settings` and `by gradle` respectively in place of `by project`.
   
   === Extra properties
   
   Extra properties are available on any object that implements the link:{groovyDslPath}#[ExtensionAware] interface.
   Kotlin DSL allows you to access extra properties and create new ones via delegated properties, using any of the `by extra` forms demonstrated in the following sample:
   
   .build.gradle.kts
   [source,kotlin]
   ----
   val myNewProperty by extra("initial value")  // <1>
   val myOtherNewProperty by extra { "calculated initial value" }  // <2>
   
   val myProperty: String by extra  // <3>
   val myNullableProperty: String? by extra  // <4>
   ----
   <1> Creates a new extra property called `myNewProperty` in the current context (the project in this case) and initializes it with the value `"initial value"`, which also determines the property's _type_
   <2> Create a new extra property whose initial value is calculated by the provided lambda
   <3> Binds an existing extra property from the current context (the project in this case) to a `myProperty` reference
   <4> Does the same as the previous line but allows the property to have a null value
   
   This approach works for all Gradle scripts: project build scripts, script plugins, settings scripts and initialization scripts.
   
   You can also access extra properties on a root project from a subproject using the following syntax:
   
   .my-sub-project/build.gradle.kts
   [source,kotlin]
   ----
   val myNewProperty: String by rootProject.extra  // <1>
   ----
   <1> Binds the root project's `myNewProperty` extra property to a reference of the same name
   
   Extra properties aren't just limited to projects.
   For example, `Task` extends `ExtensionAware`, so you can attach extra properties to tasks as well.
   Here's an example that defines a new `myNewTaskProperty` on the `test` task and then uses that property to initialize another task:
   
   .build.gradle.kts
   [source,kotlin]
   ----
   tasks {
       test {
           val reportType by extra("dev")  // <1>
           doLast {
               // Use 'suffix' for post processing of reports
           }
       }
   
       register<Zip>("archiveTestReports") {
           val reportType: String by test.get().extra  // <2>
           archiveAppendix = reportType
           from(test.get().reports.html.destination)
       }
   }
   ----
   <1> Creates a new `reportType` extra property on the `test` task
   <2> Makes the `test` task's `reportType` extra property available to configure the `archiveTestReports` task
   
   If you're happy to use eager configuration rather than the configuration avoidance APIs, you could use a single, "global" property for the report type, like this:
   
   .build.gradle.kts
   [source,kotlin]
   ----
   tasks.test.doLast { ... }
   
   val testReportType by tasks.test.get().extra("dev")  // <1>
   
   tasks.create<Zip>("archiveTestReports") {
       archiveAppendix = testReportType  // <2>
       from(test.get().reports.html.destination)
   }
   ----
   <1> Creates and initializes an extra property on the `test` task, binding it to a "global" property
   <2> Uses the "global" property to initialize the `archiveTestReports` task
   
   There is one last syntax for extra properties that we should cover, one that treats `extra` as a map.
   We recommend against using this in general as you lose the benefits of Kotlin's type checking and it prevents IDEs from providing as much support as they could.
   However, it is more succinct than the delegated properties syntax and can reasonably be used if you only need to set the value of an extra property without referencing it later.
   
   Here's a simple example demonstrating how to set and read extra properties using the map syntax:
   
   .build.gradle.kts
   [source,kotlin]
   ----
   extra["myNewProperty"] = "initial value"  // <1>
   
   tasks.create("myTask") {
       doLast {
           println("Property: ${project.extra["myNewProperty"]}")  // <2>
       }
   }
   ----
   <1> Creates a new project extra property called `myNewProperty` and sets its value
   <2> Reads the value from the project extra property we created  note the `project.` qualifier on `extra[...]`, otherwise Gradle will assume we want to read an extra property from the _task_
   
   // === `Property`, `Provider` and `NamedDomainObjectProvider`
   
   
   == Kotlin lazy property assignment
   
   Gradle's Kotlin DSL supports lazy property assignment using the `=` operator .
   Lazy property assignment reduces the verbosity for Kotlin DSL when <<lazy_configuration#lazy_properties,lazy properties>> are used.
   It works for properties that are publicly seen as `final` (without a setter) and have type `Property` or `ConfigurableFileCollection`.
   Since properties have to be `final`, our general recommendation is not to implement custom setters for properties with lazy types and, if possible, implement such properties via an abstract getter.
   
   Using the `=` operator is the preferred way to call `set()` in the Kotlin DSL.
   
   .Kotlin lazy property assignment
   ====
   include::sample[dir="snippets/kotlinDsl/assignment/kotlin",files="build.gradle.kts[tags=assignment]"]
   ====
   <1> Set value with the `.set()` method
   <2> Set value with lazy property assignment using the `=` operator
   <3> The `=` operator can be used also for assigning lazy values
   
   === IDE support
   
   Lazy property assignment is supported from IntelliJ 2022.3 and from Android Studio Giraffe.
   
   
   == The Kotlin DSL Plugin
   
   The Kotlin DSL Plugin provides a convenient way to develop Kotlin-based projects that contribute build logic.
   That includes <<sharing_build_logic_between_subprojects.adoc#sec:using_buildsrc,buildSrc projects>>, <<composite_builds#composite_builds,included builds>> and <<custom_plugins#custom_plugins,Gradle plugins>>.
   
   The plugin achieves this by doing the following:
   
    * Applies the link:https://kotlinlang.org/docs/reference/using-gradle.html#targeting-the-jvm[Kotlin Plugin], which adds support for compiling Kotlin source files.
    * Adds the `kotlin-stdlib`, `kotlin-reflect` and `gradleKotlinDsl()` dependencies to the `compileOnly` and `testImplementation` configurations, which allows you to make use of those Kotlin libraries and the Gradle API in your Kotlin code.
    * Configures the Kotlin compiler with the same settings that are used for Kotlin DSL scripts, ensuring consistency between your build logic and those scripts:
    ** adds <<kotlin_dsl#sec:kotlin_compiler_arguments, Kotlin compiler arguments>>,
    ** registers the link:https://kotlinlang.org/docs/sam-with-receiver-plugin.html[SAM-with-receiver Kotlin compiler plugin].
    * Enables support for <<custom_plugins#sec:precompile_script_plugin,precompiled script plugins>>.
   
   .Avoid specifying a version for the `kotlin-dsl` plugin
   --
   Each Gradle release is meant to be used with a specific version of the `kotlin-dsl` plugin and compatibility between arbitrary Gradle releases and `kotlin-dsl` plugin versions is not guaranteed. Using an unexpected version of the `kotlin-dsl` plugin in a build will emit a warning and can cause hard to diagnose problems.
   --
   
   This is the basic configuration you need to use the plugin:
   
   .Applying the Kotlin DSL Plugin to a `buildSrc` project
   ====
   include::sample[dir="snippets/kotlinDsl/kotlinDslPlugin/kotlin",files="buildSrc/build.gradle.kts[tags=apply]"]
   ====
   
   The Kotlin DSL Plugin leverages <<toolchains#toolchains,Java Toolchains>>.
   By default the code will target Java 8.
   You can change that by defining a Java toolchain to be used by the project:
   
   .Changing the JVM target using toolchains
   ====
   include::sample[dir="samples/java/jvm-multi-project-with-toolchains/kotlin/",files="buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts[tags=toolchain]"]
   include::sample[dir="samples/java/jvm-multi-project-with-toolchains/groovy/",files="buildSrc/src/main/groovy/myproject.java-conventions.gradle[tags=toolchain]"]
   ====
   
   == The embedded Kotlin
   
   Gradle embeds Kotlin in order to provide support for Kotlin-based scripts.
   
   === Kotlin versions
   
   Gradle ships with `kotlin-compiler-embeddable` plus matching versions of `kotlin-stdlib` and `kotlin-reflect` libraries. For details see the Kotlin section of Gradle's <<compatibility#kotlin,compatibility matrix>>. The `kotlin` package from those modules is visible through the Gradle classpath.
   
   The link:https://kotlinlang.org/docs/reference/compatibility.html[compatibility guarantees] provided by Kotlin apply for both backward and forward compatibility.
   
   ==== Backward compatibility
   
   Our approach is to only do backwards-breaking Kotlin upgrades on a major Gradle release. We will always clearly document which Kotlin version we ship and announce upgrade plans before a major release.
   
   Plugin authors who want to stay compatible with older Gradle versions need to limit their API usage to a subset that is compatible with these old versions. It뗩 not really different from any other new API in Gradle. E.g. if we introduce a new API for dependency resolution and a plugin wants to use that API, then they either need to drop support for older Gradle versions or they need to do some clever organization of their code to only execute the new code path on newer versions.
   
   ==== Forward compatibility
   
   The biggest issue is the compatibility between the external `kotlin-gradle-plugin` version and the `kotlin-stdlib` version shipped with Gradle. More generally, between any plugin that transitively depends on `kotlin-stdlib` and its version shipped with Gradle. As long as the combination is compatible everything should work. This will become less of an issue as the language matures.
   
   === Kotlin compiler arguments
   
   These are the Kotlin compiler arguments used for compiling Kotlin DSL scripts and Kotlin sources and scripts in a project that has the `kotlin-dsl` plugin applied:
   
   `-java-parameters`::
   Generate metadata for Java >= 1.8 reflection on method parameters.
   See link:https://kotlinlang.org/docs/compiler-reference.html#kotlin-jvm-compiler-options[Kotlin/JVM compiler options] in the Kotlin documentation for more information.
   
   `-Xjvm-default=all`::
   Makes all non-abstract members of Kotlin interfaces default for the Java classes implementing them.
   This is to provide a better interoperability with Java and Groovy for plugins written in Kotlin.
   See link:https://kotlinlang.org/docs/java-to-kotlin-interop.html#default-methods-in-interfaces[Default methods in interfaces] in the Kotlin documentation for more information.
   
   `-Xsam-conversions=class`::
   Sets up the implementation strategy for SAM (single abstract method) conversion to always generate anonymous classes, instead of using the `invokedynamic` JVM instruction.
   This is to provide a better support for configuration cache and incremental build.
   See link:https://youtrack.jetbrains.com/issue/KT-44912[KT-44912] in the Kotlin issue tracker for more information.
   
   `-Xjsr305=strict`::
   Sets up Kotlin's Java interoperability to strictly follow JSR-305 annotations for increased null safety.
   See link:https://kotlinlang.org/docs/reference/java-interop.html#compiler-configuration[Calling Java code from Kotlin] in the Kotlin documentation for more information.
   
   == Interoperability
   
   When mixing languages in your build logic, you may have to cross language boundaries.
   An extreme example would be a build that uses tasks and plugins that are implemented in Java, Groovy and Kotlin, while also using both Kotlin DSL and Groovy DSL build scripts.
   
   Quoting the Kotlin reference documentation:
   
   > Kotlin is designed with Java Interoperability in mind. Existing Java code can be called from Kotlin in a natural way, and Kotlin code can be used from Java rather smoothly as well.
   
   Both link:{kotlin-reference}java-interop.html[calling Java from Kotlin] and link:{kotlin-reference}java-to-kotlin-interop.html[calling Kotlin from Java] are very well covered in the Kotlin reference documentation.
   
   The same mostly applies to interoperability with Groovy code.
   In addition, the Kotlin DSL provides several ways to opt into Groovy semantics, which we look at next.
   
   === Static extensions
   
   Both the Groovy and Kotlin languages support extending existing classes via link:https://groovy-lang.org/metaprogramming.html#_extension_modules[Groovy Extension modules] and link:{kotlin-reference}extensions.html[Kotlin extensions].
   
   To call a Kotlin extension function from Groovy, call it as a static function, passing the receiver as the first parameter:
   
   .Calling a Kotlin extension from Groovy
   ====
   include::sample[dir="snippets/kotlinDsl/interoperability-static-extensions/kotlin",files="build.gradle[tags=kotlin-from-groovy]"]
   ====
   
   Kotlin extension functions are package-level functions and you can learn how to locate the name of the type declaring a given Kotlin extension in the link:{kotlin-reference}java-to-kotlin-interop.html#package-level-functions[Package-Level Functions] section of the Kotlin reference documentation.
   
   To call a Groovy extension method from Kotlin, the same approach applies: call it as a static function passing the receiver as the first parameter.
   Here's an example:
   
   .Calling a Groovy extension from Kotlin
   ====
   include::sample[dir="snippets/kotlinDsl/interoperability-static-extensions/kotlin",files="build.gradle.kts[tags=groovy-from-kotlin]"]
   ====
   
   === Named parameters and default arguments
   
   Both the Groovy and Kotlin languages support named function parameters and default arguments, although they are implemented very differently.
   Kotlin has fully-fledged support for both, as described in the Kotlin language reference under맓ink:{kotlin-reference}functions.html#named-arguments[named arguments] and link:{kotlin-reference}functions.html#default-arguments[default arguments].
   Groovy implements link:https://groovy-lang.org/objectorientation.html#_named_arguments[named arguments] in a non-type-safe way based on a `Map<String, ?>` parameter, which means they cannot be combined with link:https://groovy-lang.org/objectorientation.html#_default_arguments[default arguments].
   In other words, you can only use one or the other in Groovy for any given method.
   
   ==== Calling Kotlin from Groovy
   
   To call a Kotlin function that has named arguments from Groovy, just use a normal method call with positional parameters.
   There is no way to provide values by argument name.
   
   To call a Kotlin function that has default arguments from Groovy, always pass values for all the function parameters.
   
   ==== Calling Groovy from Kotlin
   
   To call a Groovy function with named arguments from Kotlin, you need to pass a `Map<String, ?>`, as shown in this example:
   
   .Call Groovy function with named arguments from Kotlin
   [.multi-language-sample]
   ====
   .build.gradle.kts
   [source, kotlin]
   ----
   groovyNamedArgumentTakingMethod(mapOf(
       "parameterName" to "value",
       "other" to 42,
       "and" to aReference))
   ----
   ====
   
   To call a Groovy function with default arguments from Kotlin, always pass values for all the parameters.
   
   === Groovy closures from Kotlin
   
   You may sometimes have to call Groovy methods that take link:https://groovy-lang.org/closures.html[Closure] arguments from Kotlin code.
   For example, some third-party plugins written in Groovy expect closure arguments.
   
   NOTE: Gradle plugins written in any language should prefer the type `Action<T>` type in place of closures. Groovy closures and Kotlin lambdas are automatically mapped to arguments of that type.
   
   In order to provide a way to construct closures while preserving Kotlin's strong typing, two helper methods exist:
   
   * `closureOf<T> {}`
   * `delegateClosureOf<T> {}`
   
   Both methods are useful in different circumstances and depend upon the method you are passing the `Closure` instance into.
   
   Some plugins expect simple closures, as with the link:{plugin-portal}plugin/com.jfrog.bintray[Bintray] plugin:
   
   .Use `closureOf<T> {}`
   ====
   include::sample[dir="snippets/kotlinDsl/interoperability-closure-of/kotlin",files="build.gradle.kts[tags=closureOf]"]
   ====
   
   In other cases, like with the link:{plugin-portal}plugin/org.gretty[Gretty Plugin] when configuring farms, the plugin expects a delegate closure:
   
   .Use `delegateClosureOf<T> {}`
   ====
   include::sample[dir="snippets/kotlinDsl/interoperability-delegate-closure-of/kotlin",files="build.gradle.kts[tags=delegateClosureOf]"]
   ====
   
   There sometimes isn't a good way to tell, from looking at the source code, which version to use.
   Usually, if you get a `NullPointerException` with `closureOf<T> {}`, using `delegateClosureOf<T> {}`
   will resolve the problem.
   
   These two utility functions are useful for _configuration closures_, but some plugins might expect Groovy closures for other purposes.
   The `KotlinClosure0` to `KotlinClosure2` types allows adapting Kotlin functions to Groovy closures with more flexibility.
   
   .Use `KotlinClosureX` types
   ====
   include::sample[dir="snippets/kotlinDsl/interoperability-kotlinClosure/kotlin",files="build.gradle.kts[tags=kotlinClosure]"]
   ====
   
   === The Kotlin DSL Groovy Builder
   
   If some plugin makes heavy use of link:https://groovy-lang.org/metaprogramming.html[Groovy metaprogramming], then using it from Kotlin or Java or any statically-compiled language can be very cumbersome.
   
   The Kotlin DSL provides a `withGroovyBuilder {}` utility extension that attaches the Groovy metaprogramming semantics to objects of type `Any`.
   The following example demonstrates several features of the method on the object `target`:
   
   .Use `withGroovyBuilder {}`
   ====
   include::sample[dir="snippets/kotlinDsl/interoperability-groovy-builder/kotlin",files="build.gradle.kts[tags=withGroovyBuilder]"]
   ====
   <1> The receiver is a link:https://docs.groovy-lang.org/latest/html/api/groovy/lang/GroovyObject.html[GroovyObject] and provides Kotlin helpers
   <2> The `GroovyObject` API is available
   <3> Invoke the `methodName` method, passing some parameters
   <4> Configure the `blockName` property, maps to a `Closure` taking method invocation
   <5> Invoke `another` method taking named arguments, maps to a Groovy named arguments `Map<String, ?>` taking method invocation
   
   === Using a Groovy script
   
   Another option when dealing with problematic plugins that assume a Groovy DSL build script is to configure them in a Groovy DSL build script that is applied from the main Kotlin DSL build script:
   
   .Using a Groovy script
   ====
   [.multi-language-sample]
   =====
   .dynamic-groovy-plugin-configuration.gradle
   [source, groovy]
   ----
   native {                                                    <1>
       dynamic {
           groovy as Usual
       }
   }
   ----
   =====
   ====
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source, kotlin]
   ----
   plugins {
       id("dynamic-groovy-plugin") version "1.0"               <2>
   }
   apply(from = "dynamic-groovy-plugin-configuration.gradle")  <3>
   ----
   =====
   ====
   <1> The Groovy script uses dynamic Groovy to configure plugin
   <2> The Kotlin build script requests and applies the plugin
   <3> The Kotlin build script applies the Groovy script
   
   == Limitations
   
   * The Kotlin DSL is link:{gradle-issues}15886[known to be slower than the Groovy DSL] on first use, for example with clean checkouts or on ephemeral continuous integration agents.
   Changing something in the _buildSrc_ directory also has an impact as it invalidates build-script caching.
   The main reason for this is the slower script compilation for Kotlin DSL.
   * In IntelliJ IDEA, you must link:https://www.jetbrains.com/help/idea/gradle.html#gradle_import[import your project from the Gradle model] in order to get content assist and refactoring support for your Kotlin DSL build scripts.
   * Kotlin DSL script compilation avoidance has known issues.
     If you encounter problems, it can be disabled by <<build_environment#sec:gradle_system_properties, setting>> the `org.gradle.kotlin.dsl.scriptCompilationAvoidance` system property to `false`.
   * The Kotlin DSL will not support the `model {}` block, which is part of the link:https://blog.gradle.org/state-and-future-of-the-gradle-software-model[discontinued Gradle Software Model].
   
   If you run into trouble or discover a suspected bug, please report the issue in the link:{gradle-issues}[Gradle issue tracker].

 /Groovy DSL Reference
 =====================
 `Groovy DSL Reference <https://docs.gradle.org/current/dsl/index.html>`__


.. container:: main-content

   .. container:: search-container

   -  `User Manual Home <https://docs.gradle.org/current/userguide/userguide.html>`__
   -  `DSL Reference Home <https://docs.gradle.org/current/dsl/index.html>`__
   -  `Release Notes <https://docs.gradle.org/current/release-notes.html>`__

      -  `Introduction <#N1000C>`__
      -  `Some basics <#N10011>`__
      -  `Build script structure <#N10060>`__
      -  `Core types <#N100CA>`__
      -  `Publishing types <#N1022D>`__
      -  `Container types <#N10374>`__
      -  `Authentication types <#N103D9>`__
      -  `Build Cache types <#N10456>`__
      -  `Input Normalization types <#N10484>`__
      -  `Help Task types <#N104AE>`__
      -  `Task types <#N10526>`__
      -  `Test types <#N106AD>`__
      -  `Reporting types <#N1073A>`__
      -  `Eclipse/IDEA model types <#N1079F>`__
      -  `Eclipse/IDEA task types <#N10828>`__
      -  `Xcode task types <#N10885>`__
      -  `Visual Studio task types <#N108C4>`__
      -  `Artifact transform types <#N108F7>`__
      -  `Native tool chains model types <#N10921>`__
      -  `Native software model types <#N10960>`__
      -  `C++ component model types <#N10AC0>`__
      -  `Swift component model types <#N10AEA>`__
      -  `Native binary task types <#N10B14>`__
      -  `Native binary task types <#N10B7D>`__

   -  .. rubric:: Build script blocks 
      :name: build-script-blocks

   -  `allprojects https://docs.gradle.org/current/dsl/{ } <https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:allprojects(groovy.lang.Closure)>`__
   -  `artifacts https://docs.gradle.org/current/dsl/{ } <https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:artifacts(groovy.lang.Closure)>`__
   -  `buildscript https://docs.gradle.org/current/dsl/{ } <https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:buildscript(groovy.lang.Closure)>`__
   -  `configurations https://docs.gradle.org/current/dsl/{ } <https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:configurations(groovy.lang.Closure)>`__
   -  `dependencies https://docs.gradle.org/current/dsl/{ } <https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:dependencies(groovy.lang.Closure)>`__
   -  `repositories https://docs.gradle.org/current/dsl/{ } <https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:repositories(groovy.lang.Closure)>`__
   -  `sourceSets https://docs.gradle.org/current/dsl/{ } <https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:sourceSets(groovy.lang.Closure)>`__
   -  `subprojects https://docs.gradle.org/current/dsl/{ } <https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:subprojects(groovy.lang.Closure)>`__
   -  `publishing https://docs.gradle.org/current/dsl/{ } <https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:publishing(groovy.lang.Closure)>`__

   .. rubric:: Core types 
      :name: core-types

   -  `Project <https://docs.gradle.org/current/dsl/org.gradle.api.Project.html>`__
   -  `Task <https://docs.gradle.org/current/dsl/org.gradle.api.Task.html>`__
   -  `Gradle <https://docs.gradle.org/current/dsl/org.gradle.api.invocation.Gradle.html>`__
   -  `Settings <https://docs.gradle.org/current/dsl/org.gradle.api.initialization.Settings.html>`__
   -  `IncludedBuild <https://docs.gradle.org/current/dsl/org.gradle.api.initialization.IncludedBuild.html>`__
   -  `ProjectLayout <https://docs.gradle.org/current/dsl/org.gradle.api.file.ProjectLayout.html>`__
   -  `BuildLayout <https://docs.gradle.org/current/dsl/org.gradle.api.file.BuildLayout.html>`__
   -  `Script <https://docs.gradle.org/current/dsl/org.gradle.api.Script.html>`__
   -  `SourceSet <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.SourceSet.html>`__
   -  `SourceSetOutput <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.SourceSetOutput.html>`__
   -  `SourceDirectorySet <https://docs.gradle.org/current/dsl/org.gradle.api.file.SourceDirectorySet.html>`__
   -  `Configuration <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.Configuration.html>`__
   -  `ConsumableConfiguration <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ConsumableConfiguration.html>`__
   -  `ResolvableConfiguration <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ResolvableConfiguration.html>`__
   -  `DependencyScopeConfiguration <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.DependencyScopeConfiguration.html>`__
   -  `ResolutionStrategy <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ResolutionStrategy.html>`__
   -  `ArtifactResolutionQuery <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.query.ArtifactResolutionQuery.html>`__
   -  `ComponentSelection <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ComponentSelection.html>`__
   -  `ComponentSelectionRules <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ComponentSelectionRules.html>`__
   -  `DependencyCollector <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.dsl.DependencyCollector.html>`__
   -  `ExtensionAware <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtensionAware.html>`__
   -  `ExtraPropertiesExtension <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtraPropertiesExtension.html>`__
   -  `PluginDependenciesSpec <https://docs.gradle.org/current/dsl/org.gradle.plugin.use.PluginDependenciesSpec.html>`__
   -  `PluginDependencySpec <https://docs.gradle.org/current/dsl/org.gradle.plugin.use.PluginDependencySpec.html>`__
   -  `PluginManagementSpec <https://docs.gradle.org/current/dsl/org.gradle.plugin.management.PluginManagementSpec.html>`__
   -  `ProviderFactory <https://docs.gradle.org/current/dsl/org.gradle.api.provider.ProviderFactory.html>`__
   -  `ResourceHandler <https://docs.gradle.org/current/dsl/org.gradle.api.resources.ResourceHandler.html>`__
   -  `TextResourceFactory <https://docs.gradle.org/current/dsl/org.gradle.api.resources.TextResourceFactory.html>`__
   -  `InputChanges <https://docs.gradle.org/current/dsl/org.gradle.work.InputChanges.html>`__
   -  `Distribution <https://docs.gradle.org/current/dsl/org.gradle.api.distribution.Distribution.html>`__

   .. rubric:: Publishing types 
      :name: publishing-types

   -  `PublishingExtension <https://docs.gradle.org/current/dsl/org.gradle.api.publish.PublishingExtension.html>`__
   -  `IvyPublication <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.IvyPublication.html>`__
   -  `IvyArtifact <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.IvyArtifact.html>`__
   -  `IvyArtifactSet <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.IvyArtifactSet.html>`__
   -  `IvyModuleDescriptorSpec <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.IvyModuleDescriptorSpec.html>`__
   -  `IvyModuleDescriptorAuthor <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.IvyModuleDescriptorAuthor.html>`__
   -  `IvyModuleDescriptorLicense <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.IvyModuleDescriptorLicense.html>`__
   -  `IvyModuleDescriptorDescription <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.IvyModuleDescriptorDescription.html>`__
   -  `MavenPublication <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPublication.html>`__
   -  `MavenArtifact <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenArtifact.html>`__
   -  `MavenArtifactSet <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenArtifactSet.html>`__
   -  `MavenPom <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPom.html>`__
   -  `MavenPomCiManagement <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomCiManagement.html>`__
   -  `MavenPomContributor <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomContributor.html>`__
   -  `MavenPomContributorSpec <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomContributorSpec.html>`__
   -  `MavenPomDeveloper <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomDeveloper.html>`__
   -  `MavenPomDeveloperSpec <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomDeveloperSpec.html>`__
   -  `MavenPomDistributionManagement <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomDistributionManagement.html>`__
   -  `MavenPomIssueManagement <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomIssueManagement.html>`__
   -  `MavenPomLicense <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomLicense.html>`__
   -  `MavenPomLicenseSpec <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomLicenseSpec.html>`__
   -  `MavenPomMailingList <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomMailingList.html>`__
   -  `MavenPomMailingListSpec <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomMailingListSpec.html>`__
   -  `MavenPomOrganization <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomOrganization.html>`__
   -  `MavenPomRelocation <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomRelocation.html>`__
   -  `MavenPomScm <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomScm.html>`__

   .. rubric:: Container types 
      :name: container-types

   -  `TaskContainer <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.TaskContainer.html>`__
   -  `ConfigurationContainer <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ConfigurationContainer.html>`__
   -  `RepositoryHandler <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.dsl.RepositoryHandler.html>`__
   -  `DependencyHandler <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html>`__
   -  `ComponentMetadataHandler <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.dsl.ComponentMetadataHandler.html>`__
   -  `ArtifactHandler <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.dsl.ArtifactHandler.html>`__

   .. rubric:: Build Cache types 
      :name: build-cache-types

   -  `BuildCacheConfiguration <https://docs.gradle.org/current/dsl/org.gradle.caching.configuration.BuildCacheConfiguration.html>`__
   -  `DirectoryBuildCache <https://docs.gradle.org/current/dsl/org.gradle.caching.local.DirectoryBuildCache.html>`__
   -  `HttpBuildCache <https://docs.gradle.org/current/dsl/org.gradle.caching.http.HttpBuildCache.html>`__

   .. rubric:: Input Normalization types 
      :name: input-normalization-types

   -  `InputNormalizationHandler <https://docs.gradle.org/current/dsl/org.gradle.normalization.InputNormalizationHandler.html>`__
   -  `InputNormalization <https://docs.gradle.org/current/dsl/org.gradle.normalization.InputNormalization.html>`__
   -  `RuntimeClasspathNormalization <https://docs.gradle.org/current/dsl/org.gradle.normalization.RuntimeClasspathNormalization.html>`__

   .. rubric:: Help Task types 
      :name: help-task-types

   -  `TaskReportTask <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.diagnostics.TaskReportTask.html>`__
   -  `ProjectReportTask <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.diagnostics.ProjectReportTask.html>`__
   -  `DependencyReportTask <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.diagnostics.DependencyReportTask.html>`__
   -  `DependencyInsightReportTask <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.diagnostics.DependencyInsightReportTask.html>`__
   -  `PropertyReportTask <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.diagnostics.PropertyReportTask.html>`__
   -  `ComponentReport <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.components.ComponentReport.html>`__
   -  `DependentComponentsReport <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.dependents.DependentComponentsReport.html>`__
   -  `ModelReport <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.model.ModelReport.html>`__
   -  `OutgoingVariantsReportTask <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.diagnostics.OutgoingVariantsReportTask.html>`__
   -  `ResolvableConfigurationsReportTask <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.diagnostics.ResolvableConfigurationsReportTask.html>`__

   .. rubric:: Task types 
      :name: task-types

   -  `AntlrTask <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.antlr.AntlrTask.html>`__
   -  `BuildEnvironmentReportTask <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.diagnostics.BuildEnvironmentReportTask.html>`__
   -  `Checkstyle <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.quality.Checkstyle.html>`__
   -  `CodeNarc <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.quality.CodeNarc.html>`__
   -  `Copy <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Copy.html>`__
   -  `CreateStartScripts <https://docs.gradle.org/current/dsl/org.gradle.jvm.application.tasks.CreateStartScripts.html>`__
   -  `Delete <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Delete.html>`__
   -  `Ear <https://docs.gradle.org/current/dsl/org.gradle.plugins.ear.Ear.html>`__
   -  `Exec <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Exec.html>`__
   -  `GenerateIvyDescriptor <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.tasks.GenerateIvyDescriptor.html>`__
   -  `GenerateMavenPom <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.tasks.GenerateMavenPom.html>`__
   -  `GenerateBuildDashboard <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.GenerateBuildDashboard.html>`__
   -  `GradleBuild <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.GradleBuild.html>`__
   -  `GroovyCompile <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.compile.GroovyCompile.html>`__
   -  `Groovydoc <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.javadoc.Groovydoc.html>`__
   -  `HtmlDependencyReportTask <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.dependencies.HtmlDependencyReportTask.html>`__
   -  `JacocoReport <https://docs.gradle.org/current/dsl/org.gradle.testing.jacoco.tasks.JacocoReport.html>`__
   -  `JacocoCoverageVerification <https://docs.gradle.org/current/dsl/org.gradle.testing.jacoco.tasks.JacocoCoverageVerification.html>`__
   -  `Jar <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.bundling.Jar.html>`__
   -  `JavaCompile <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.compile.JavaCompile.html>`__
   -  `Javadoc <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.javadoc.Javadoc.html>`__
   -  `JavaExec <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.JavaExec.html>`__
   -  `Pmd <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.quality.Pmd.html>`__
   -  `ProcessResources <https://docs.gradle.org/current/dsl/org.gradle.language.jvm.tasks.ProcessResources.html>`__
   -  `PublishToIvyRepository <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.tasks.PublishToIvyRepository.html>`__
   -  `PublishToMavenRepository <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.tasks.PublishToMavenRepository.html>`__
   -  `ScalaCompile <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.scala.ScalaCompile.html>`__
   -  `ScalaDoc <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.scala.ScalaDoc.html>`__
   -  `InitBuild <https://docs.gradle.org/current/dsl/org.gradle.buildinit.tasks.InitBuild.html>`__
   -  `Sign <https://docs.gradle.org/current/dsl/org.gradle.plugins.signing.Sign.html>`__
   -  `Sync <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Sync.html>`__
   -  `Tar <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.bundling.Tar.html>`__
   -  `AbstractTestTask <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.testing.AbstractTestTask.html>`__
   -  `Test <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.testing.Test.html>`__
   -  `TestReport <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.testing.TestReport.html>`__
   -  `War <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.bundling.War.html>`__
   -  `Wrapper <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.wrapper.Wrapper.html>`__
   -  `WriteProperties <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.WriteProperties.html>`__
   -  `Zip <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.bundling.Zip.html>`__

   .. rubric:: Test types 
      :name: test-types

   -  `TestingExtension <https://docs.gradle.org/current/dsl/org.gradle.testing.base.TestingExtension.html>`__
   -  `TestSuite <https://docs.gradle.org/current/dsl/org.gradle.testing.base.TestSuite.html>`__
   -  `JvmTestSuite <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.jvm.JvmTestSuite.html>`__
   -  `TestSuiteTarget <https://docs.gradle.org/current/dsl/org.gradle.testing.base.TestSuiteTarget.html>`__
   -  `JvmTestSuiteTarget <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.jvm.JvmTestSuiteTarget.html>`__
   -  `Test <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.testing.Test.html>`__
   -  `Dependencies <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.dsl.Dependencies.html>`__
   -  `GradleDependencies <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.dsl.GradleDependencies.html>`__
   -  `TestFixturesDependencyModifiers <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.jvm.TestFixturesDependencyModifiers.html>`__
   -  `PlatformDependencyModifiers <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.jvm.PlatformDependencyModifiers.html>`__
   -  `JvmComponentDependencies <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.jvm.JvmComponentDependencies.html>`__

   .. rubric:: Reporting types 
      :name: reporting-types

   -  `CustomizableHtmlReport <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.CustomizableHtmlReport.html>`__
   -  `SingleFileReport <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.SingleFileReport.html>`__
   -  `DirectoryReport <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.DirectoryReport.html>`__
   -  `Report <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.Report.html>`__
   -  `Reporting <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.Reporting.html>`__
   -  `ReportContainer <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.ReportContainer.html>`__
   -  `ReportingExtension <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.ReportingExtension.html>`__
   -  `AggregateTestReport <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.testing.AggregateTestReport.html>`__
   -  `JacocoCoverageReport <https://docs.gradle.org/current/dsl/org.gradle.testing.jacoco.plugins.JacocoCoverageReport.html>`__

   .. rubric:: Eclipse/IDEA model types 
      :name: eclipseidea-model-types

   -  `EclipseModel <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.model.EclipseModel.html>`__
   -  `EclipseProject <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.model.EclipseProject.html>`__
   -  `EclipseClasspath <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.model.EclipseClasspath.html>`__
   -  `EclipseJdt <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.model.EclipseJdt.html>`__
   -  `EclipseWtp <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.model.EclipseWtp.html>`__
   -  `EclipseWtpComponent <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent.html>`__
   -  `EclipseWtpFacet <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.model.EclipseWtpFacet.html>`__
   -  `IdeaModel <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.idea.model.IdeaModel.html>`__
   -  `IdeaProject <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.idea.model.IdeaProject.html>`__
   -  `IdeaModule <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.idea.model.IdeaModule.html>`__
   -  `IdeaWorkspace <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.idea.model.IdeaWorkspace.html>`__
   -  `XmlFileContentMerger <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.api.XmlFileContentMerger.html>`__
   -  `FileContentMerger <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.api.FileContentMerger.html>`__

   .. rubric:: Eclipse/IDEA task types 
      :name: eclipseidea-task-types

   -  `GenerateEclipseProject <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.GenerateEclipseProject.html>`__
   -  `GenerateEclipseClasspath <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.GenerateEclipseClasspath.html>`__
   -  `GenerateEclipseJdt <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.GenerateEclipseJdt.html>`__
   -  `GenerateEclipseWtpComponent <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.GenerateEclipseWtpComponent.html>`__
   -  `GenerateEclipseWtpFacet <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.GenerateEclipseWtpFacet.html>`__
   -  `GenerateIdeaModule <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.idea.GenerateIdeaModule.html>`__
   -  `GenerateIdeaProject <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.idea.GenerateIdeaProject.html>`__
   -  `GenerateIdeaWorkspace <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.idea.GenerateIdeaWorkspace.html>`__

   .. rubric:: Xcode task types 
      :name: xcode-task-types

   -  `GenerateSchemeFileTask <https://docs.gradle.org/current/dsl/org.gradle.ide.xcode.tasks.GenerateSchemeFileTask.html>`__
   -  `GenerateWorkspaceSettingsFileTask <https://docs.gradle.org/current/dsl/org.gradle.ide.xcode.tasks.GenerateWorkspaceSettingsFileTask.html>`__
   -  `GenerateXcodeProjectFileTask <https://docs.gradle.org/current/dsl/org.gradle.ide.xcode.tasks.GenerateXcodeProjectFileTask.html>`__
   -  `GenerateXcodeWorkspaceFileTask <https://docs.gradle.org/current/dsl/org.gradle.ide.xcode.tasks.GenerateXcodeWorkspaceFileTask.html>`__

   .. rubric:: Visual Studio task types 
      :name: visual-studio-task-types

   -  `GenerateSolutionFileTask <https://docs.gradle.org/current/dsl/org.gradle.ide.visualstudio.tasks.GenerateSolutionFileTask.html>`__
   -  `GenerateProjectFileTask <https://docs.gradle.org/current/dsl/org.gradle.ide.visualstudio.tasks.GenerateProjectFileTask.html>`__
   -  `GenerateFiltersFileTask <https://docs.gradle.org/current/dsl/org.gradle.ide.visualstudio.tasks.GenerateFiltersFileTask.html>`__

   .. rubric:: Artifact transform types 
      :name: artifact-transform-types

   -  `TransformAction <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.transform.TransformAction.html>`__
   -  `TransformOutputs <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.transform.TransformOutputs.html>`__
   -  `TransformSpec <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.transform.TransformSpec.html>`__

   .. rubric:: Native tool chain types 
      :name: native-tool-chain-types

   -  `Gcc <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.toolchain.Gcc.html>`__
   -  `Clang <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.toolchain.Clang.html>`__
   -  `VisualCpp <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.toolchain.VisualCpp.html>`__
   -  `Swiftc <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.toolchain.Swiftc.html>`__

   .. rubric:: C++ component types 
      :name: c-component-types

   -  `CppApplication <https://docs.gradle.org/current/dsl/org.gradle.language.cpp.CppApplication.html>`__
   -  `CppLibrary <https://docs.gradle.org/current/dsl/org.gradle.language.cpp.CppLibrary.html>`__
   -  `CppTestSuite <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.test.cpp.CppTestSuite.html>`__

   .. rubric:: Swift component types 
      :name: swift-component-types

   -  `SwiftApplication <https://docs.gradle.org/current/dsl/org.gradle.language.swift.SwiftApplication.html>`__
   -  `SwiftLibrary <https://docs.gradle.org/current/dsl/org.gradle.language.swift.SwiftLibrary.html>`__
   -  `SwiftXCTestSuite <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.test.xctest.SwiftXCTestSuite.html>`__

   .. rubric:: Native component task types 
      :name: native-component-task-types

   -  `CppCompile <https://docs.gradle.org/current/dsl/org.gradle.language.cpp.tasks.CppCompile.html>`__
   -  `SwiftCompile <https://docs.gradle.org/current/dsl/org.gradle.language.swift.tasks.SwiftCompile.html>`__
   -  `LinkExecutable <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.tasks.LinkExecutable.html>`__
   -  `LinkSharedLibrary <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.tasks.LinkSharedLibrary.html>`__
   -  `CreateStaticLibrary <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.tasks.CreateStaticLibrary.html>`__
   -  `LinkMachOBundle <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.tasks.LinkMachOBundle.html>`__
   -  `InstallExecutable <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.tasks.InstallExecutable.html>`__
   -  `InstallXCTestBundle <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.test.xctest.tasks.InstallXCTestBundle.html>`__
   -  `RunTestExecutable <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.test.tasks.RunTestExecutable.html>`__
   -  `XCTest <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.test.xctest.tasks.XCTest.html>`__


.. container:: book

   .. rubric:: `Introduction
      :name: N1000C
      :class: title

   This reference guide describes the various types which
   make up the Gradle build language, or DSL.

.. container:: section

   .. rubric:: `Some basics
      :name: N10011
      :class: title

   There are a few basic concepts that you should
   understand, which will help you write Gradle scripts.

   First, Gradle scripts are *configuration scripts*. As
   the script executes, it configures an object of a
   particular type. For example, as a build script
   executes, it configures an object of type
   `Project <https://docs.gradle.org/current/dsl/org.gradle.api.Project.html>`__.
   This object is called the *delegate object* of the
   script. The following table shows the delegate for
   each type of Gradle script.

      =================  ===========================
       Type of script    Delegates to instance of
      =================  ===========================
       Build script      `Project`__
       Init script       `Gradle`__
       Settings script   `Settings`__
      =================  ===========================

   .. _Project:  https://docs.gradle.org/current/dsl/org.gradle.api.Project.html
   .. _Gradle:  https://docs.gradle.org/current/dsl/org.gradle.api.invocation.Gradle.html
   .. _Settings:  https://docs.gradle.org/current/dsl/org.gradle.api.initialization.Settings.html

   The properties and methods of the delegate object are
   available for you to use in the script.

   Second, each Gradle script implements the
   `Script <https://docs.gradle.org/current/dsl/org.gradle.api.Script.html>`__
   interface. This interface defines a number of
   properties and methods which you can use in the script.

   .. container:: section

      .. rubric:: `Build script structure
         :name: N10060
         :class: title

   A build script is made up of zero or more statements
   and script blocks. Statements can include method
   calls, property assignments, and local variable
   definitions. A script block is a method call which
   takes a closure as a parameter. The closure is treated
   as a *configuration closure* which configures some
   delegate object as it executes. The top level script
   blocks are listed below.

      ======================  ===========================
       Block                  Description
      ======================  ===========================
      `allprojects { }`__     Configures this project and each of its sub-projects.
      `artifacts { }`__       Configures the published artifacts for this project.
      `buildscript { }`__     Configures the build script classpath for this project.
      `configurations { }`__  Configures the dependency configurations for this project.
      `dependencies { }`__    Configures the dependencies for this project.
      `repositories { }`__    Configures the repositories for this project.
      `sourceSets { }`__      Configures the source sets of this project.
      `subprojects { }`__     Configures the sub-projects of this project.
      `publishing { }`__      Configures the `PublishingExtension`__ added by the publishing plugin.
      ======================  ===========================
   
   .. _allprojects { }: https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:allprojects(groovy.lang.Closure)
   .. _artifacts { }: https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:artifacts(groovy.lang.Closure)
   .. _buildscript { }: https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:buildscript(groovy.lang.Closure)
   .. _configurations { }: https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:configurations(groovy.lang.Closure)
   .. _dependencies { }: https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:dependencies(groovy.lang.Closure)
   .. _repositories { }: https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:repositories(groovy.lang.Closure)
   .. _sourceSets { }: https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:sourceSets(groovy.lang.Closure)
   .. _subprojects { }: https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:subprojects(groovy.lang.Closure)
   .. _publishing { }: https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:publishing(groovy.lang.Closure)
   .. _PublishingExtension: https://docs.gradle.org/current/dsl/org.gradle.api.publish.PublishingExtension.html

   A build script is also a Groovy script, and so can
   contain those elements allowed in a Groovy script,
   such as method definitions and class definitions.

   .. container:: section

      .. rubric:: `Core types
         :name: N100CA
         :class: title

   Listed below are some of the central types which are
   used in Gradle scripts:

   .. list-table::
      :header-rows: 1

      - 

         - Type
         - Description
      - 

         - `Project <https://docs.gradle.org/current/dsl/org.gradle.api.Project.html>`__
         - This interface is the main API you use
            to interact with Gradle from your build
            file. From a ``Project``, you have
            programmatic access to all of Gradle's
            features.
      - 

         - `Task <https://docs.gradle.org/current/dsl/org.gradle.api.Task.html>`__
         - A ``Task`` represents a single atomic
            piece of work for a build, such as
            compiling classes or generating
            javadoc.
      - 

         - `Gradle <https://docs.gradle.org/current/dsl/org.gradle.api.invocation.Gradle.html>`__
         - Represents an invocation of Gradle.
      - 

         - `Settings <https://docs.gradle.org/current/dsl/org.gradle.api.initialization.Settings.html>`__
         - Declares the configuration required to
            instantiate and configure the hierarchy
            of
            `Project <https://docs.gradle.org/current/dsl/org.gradle.api.Project.html>`__
            instances which are to participate in a
            build.
      - 

         - `IncludedBuild <https://docs.gradle.org/current/dsl/org.gradle.api.initialization.IncludedBuild.html>`__
         - A build that is included in the
            composite.
      - 

         - `ProjectLayout <https://docs.gradle.org/current/dsl/org.gradle.api.file.ProjectLayout.html>`__
         - Provides access to several important
            locations for a project.
      - 

         - `BuildLayout <https://docs.gradle.org/current/dsl/org.gradle.api.file.BuildLayout.html>`__
         - Provides access to important locations
            for a Gradle build.
      - 

         - `Script <https://docs.gradle.org/current/dsl/org.gradle.api.Script.html>`__
         - This interface is implemented by all
            Gradle Groovy DSL scripts to add in
            some Gradle-specific methods. As your
            compiled script class will implement
            this interface, you can use the methods
            and properties declared by this
            interface directly in your script.
      - 

         - `SourceSet <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.SourceSet.html>`__
         - A ``SourceSet`` represents a logical
            group of Java source and resource
            files. They are covered in more detail
            in the `user
            manual <https://docs.gradle.org/current/userguide/building_java_projects.html#sec:java_source_sets>`__.
      - 

         - `SourceSetOutput <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.SourceSetOutput.html>`__
         - A collection of all output directories
            (compiled classes, processed resources,
            etc.) - notice that
            `SourceSetOutput <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.SourceSetOutput.html>`__
            extends
            `FileCollection <https://docs.gradle.org/current/javadoc/org/gradle/api/file/FileCollection.html>`__.
      - 

         - `SourceDirectorySet <https://docs.gradle.org/current/dsl/org.gradle.api.file.SourceDirectorySet.html>`__
         - A ``SourceDirectorySet`` represents a
            set of source files composed from a set
            of source directories, along with
            associated include and exclude
            patterns.
      - 

         - `Configuration <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.Configuration.html>`__
         - A ``Configuration`` represents a group
            of artifacts and their dependencies.
            Find more information about declaring
            dependencies to a configuration or
            about managing configurations in docs
            for
            `ConfigurationContainer <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ConfigurationContainer.html>`__
      - 

         - `ConsumableConfiguration <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ConsumableConfiguration.html>`__
         - A
            `Configuration <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.Configuration.html>`__
            which can be consumed via Publishing
            and Dependency Management.
      - 

         - `ResolvableConfiguration <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ResolvableConfiguration.html>`__
         - A
            `Configuration <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.Configuration.html>`__
            which performs dependency resolution to
            build dependency graphs and resolve
            artifacts.
      - 

         - `DependencyScopeConfiguration <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.DependencyScopeConfiguration.html>`__
         - A
            `Configuration <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.Configuration.html>`__
            which collects dependencies, dependency
            constraints, and exclude rules.
      - 

         - `ResolutionStrategy <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ResolutionStrategy.html>`__
         - Defines the strategies around dependency
            resolution. For example, forcing
            certain dependency versions,
            substitutions, conflict resolutions or
            snapshot timeouts.
      - 

         - `ArtifactResolutionQuery <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.query.ArtifactResolutionQuery.html>`__
         - A builder to construct a query that can
            resolve selected software artifacts of
            the specified components.
      - 

         - `ComponentSelection <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ComponentSelection.html>`__
         - Represents a tuple of the component
            selector of a module and a candidate
            version to be evaluated in a component
            selection rule.
      - 

         - `ComponentSelectionRules <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ComponentSelectionRules.html>`__
         - Represents a container for component
            selection rules. Rules can be applied
            as part of the resolutionStrategy of a
            configuration and individual components
            can be explicitly accepted or rejected
            by rule. Components that are neither
            accepted or rejected will be subject to
            the default version matching
            strategies.
      - 

         - `DependencyCollector <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.dsl.DependencyCollector.html>`__
         - A ``DependencyCollector`` is used as
            part of a dependencies block in the
            DSL. A collector implements a single
            dependency scope and exposes the
            declared dependencies on
            `DependencyCollector.getDependencies() <https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/dsl/DependencyCollector.html#getDependencies-->`__.
      - 

         - `ExtensionAware <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtensionAware.html>`__
         - Objects that can be extended at runtime
            with other objects.
      - 

         - `ExtraPropertiesExtension <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtraPropertiesExtension.html>`__
         - Additional, ad-hoc, properties for
            Gradle domain objects.
      - 

         - `PluginDependenciesSpec <https://docs.gradle.org/current/dsl/org.gradle.plugin.use.PluginDependenciesSpec.html>`__
         - The DSL for declaring plugins to use in
            a script.
      - 

         - `PluginDependencySpec <https://docs.gradle.org/current/dsl/org.gradle.plugin.use.PluginDependencySpec.html>`__
         - A mutable specification of a dependency
            on a plugin.
      - 

         - `PluginManagementSpec <https://docs.gradle.org/current/dsl/org.gradle.plugin.management.PluginManagementSpec.html>`__
         - Configures how plugins are resolved.
      - 

         - `ProviderFactory <https://docs.gradle.org/current/dsl/org.gradle.api.provider.ProviderFactory.html>`__
         - A factory for creating instances of
            `Provider <https://docs.gradle.org/current/javadoc/org/gradle/api/provider/Provider.html>`__.
      - 

         - `ResourceHandler <https://docs.gradle.org/current/dsl/org.gradle.api.resources.ResourceHandler.html>`__
         - Provides access to resource-specific
            utility methods, for example factory
            methods that create various resources.
      - 

         - `TextResourceFactory <https://docs.gradle.org/current/dsl/org.gradle.api.resources.TextResourceFactory.html>`__
         - Creates ``TextResource``\ s backed by
            sources such as strings, files, and
            archive entries.
      - 

         - `InputChanges <https://docs.gradle.org/current/dsl/org.gradle.work.InputChanges.html>`__
         - Provides access to any input files that
            need to be processed by an incremental
            work action.
      - 

         - `Distribution <https://docs.gradle.org/current/dsl/org.gradle.api.distribution.Distribution.html>`__
         - A distribution allows to bundle an
            application or a library including
            dependencies, sources...

   .. container:: section

      .. rubric:: `Publishing types
         :name: N1022D
         :class: title

   Listed below are the types used to configure
   publishing:

   .. list-table::
      :header-rows: 1

      - 

         - Type
         - Description
      - 

         - `PublishingExtension <https://docs.gradle.org/current/dsl/org.gradle.api.publish.PublishingExtension.html>`__
         - The configuration of how to
            랋ublish롹맚he different components of a project.
      - 

         - `IvyPublication <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.IvyPublication.html>`__
         - An ``IvyPublication`` is the
            representation/configuration of how
            Gradle should publish something in Ivy
            format, to an Ivy repository. You
            directly add a named Ivy publication the project's
            ``publishing.publications`` container by providing
            `IvyPublication <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.IvyPublication.html>`__
            as the type.
      - 

         - `IvyArtifact <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.IvyArtifact.html>`__
         - An artifact published as part of a
            `IvyPublication <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.IvyPublication.html>`__.
      - 

         - `IvyArtifactSet <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.IvyArtifactSet.html>`__
         - A Collection of
            `IvyArtifact <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.IvyArtifact.html>`__\ s
            to be included in an
            `IvyPublication <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.IvyPublication.html>`__.
            Being a
            `DomainObjectSet <https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectSet.html>`__,
            an ``IvyArtifactSet`` provides
            convenient methods for querying,
            filtering, and applying actions to the set of
            `IvyArtifact <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.IvyArtifact.html>`__\ s.
      - 

         - `IvyModuleDescriptorSpec <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.IvyModuleDescriptorSpec.html>`__
         - The descriptor of any Ivy publication.
      - 

         - `IvyModuleDescriptorAuthor <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.IvyModuleDescriptorAuthor.html>`__
         - An author of an Ivy publication.
      - 

         - `IvyModuleDescriptorLicense <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.IvyModuleDescriptorLicense.html>`__
         - A license of an Ivy publication.
      - 

         - `IvyModuleDescriptorDescription <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.IvyModuleDescriptorDescription.html>`__
         - The description of an Ivy publication.
      - 

         - `MavenPublication <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPublication.html>`__
         - A ``MavenPublication`` is the
            representation/configuration of how
            Gradle should publish something in
            Maven format. You directly add a named
            Maven publication the project's
            ``publishing.publications`` container by providing
            `MavenPublication <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPublication.html>`__
            as the type.
      - 

         - `MavenArtifact <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenArtifact.html>`__
         - An artifact published as part of a
            `MavenPublication <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPublication.html>`__.
      - 

         - `MavenArtifactSet <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenArtifactSet.html>`__
         - A Collection of
            `MavenArtifact <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenArtifact.html>`__\ s
            to be included in a
            `MavenPublication <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPublication.html>`__.
            Being a
            `DomainObjectSet <https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectSet.html>`__,
            a ``MavenArtifactSet`` provides
            convenient methods for querying,
            filtering, and applying actions to the set of
            `MavenArtifact <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenArtifact.html>`__\ s.
      - 

         - `MavenPom <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPom.html>`__
         - The POM for a Maven publication.
      - 

         - `MavenPomCiManagement <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomCiManagement.html>`__
         - The CI management system of a Maven publication.
      - 

         - `MavenPomContributor <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomContributor.html>`__
         - A contributor of a Maven publication.
      - 

         - `MavenPomContributorSpec <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomContributorSpec.html>`__
         - Allows to add contributors of a Maven publication.
      - 

         - `MavenPomDeveloper <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomDeveloper.html>`__
         - A developer of a Maven publication.
      - 

         - `MavenPomDeveloperSpec <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomDeveloperSpec.html>`__
         - Allows to add developers to a Maven publication.
      - 

         - `MavenPomDistributionManagement <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomDistributionManagement.html>`__
         - The distribution management configuration of a Maven publication.
      - 

         - `MavenPomIssueManagement <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomIssueManagement.html>`__
         - The issue management system of a Maven publication.
      - 

         - `MavenPomLicense <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomLicense.html>`__
         - A license of a Maven publication.
      - 

         - `MavenPomLicenseSpec <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomLicenseSpec.html>`__
         - Allows to add licenses to a Maven publication.
      - 

         - `MavenPomMailingList <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomMailingList.html>`__
         - A mailing list of a Maven publication.
      - 

         - `MavenPomMailingListSpec <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomMailingListSpec.html>`__
         - Allows to add mailing lists to a Maven publication.
      - 

         - `MavenPomOrganization <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomOrganization.html>`__
         - The organization of a Maven publication.
      - 

         - `MavenPomRelocation <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomRelocation.html>`__
         - The relocation information of a Maven publication that has been 
           moved to a new group and/or artifact ID.
      - 

         - `MavenPomScm <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPomScm.html>`__
         - The SCM (source control management) of a
            Maven publication.

   .. container:: section

      .. rubric:: `Container types
         :name: N10374
         :class: title

   Container types that handle various declarative
   elements (e.g. dependencies, configurations,
   artifacts, tasks, etc.):

   .. list-table::
      :header-rows: 1

      - 

         - Type
         - Description
      - 

         - `TaskContainer <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.TaskContainer.html>`__
         - A ``TaskContainer`` is responsible for managing a set of
            `Task <https://docs.gradle.org/current/dsl/org.gradle.api.Task.html>`__
            instances.
      - 

         - `ConfigurationContainer <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ConfigurationContainer.html>`__
         - A ``ConfigurationContainer`` is
            responsible for declaring and managing configurations. See also
            `Configuration <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.Configuration.html>`__.
      - 

         - `RepositoryHandler <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.dsl.RepositoryHandler.html>`__
         - A ``RepositoryHandler`` manages a set of
            repositories, allowing repositories to
            be defined and queried.
      - 

         - `DependencyHandler <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html>`__
         - A ``DependencyHandler`` is used to
            declare dependencies. Dependencies are
            grouped into configurations (see
            `Configuration <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.Configuration.html>`__).
      - 

         - `ComponentMetadataHandler <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.dsl.ComponentMetadataHandler.html>`__
         - Allows the build to provide rules that
            modify the metadata of depended-on
            software components. Component metadata
            rules are applied in the components
            section of the dependencies block
            `DependencyHandler <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html>`__
            of a build script. The rules can be
            defined in two different ways:
      - 

         - `ArtifactHandler <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.dsl.ArtifactHandler.html>`__
         - This class is for defining artifacts to
            be published and adding them to
            configurations. Creating publish
            artifacts does not mean to create an
            archive. What is created is a domain
            object which represents a file to be
            published and information on how it
            should be published (e.g. the name).

   .. container:: section

      .. rubric:: `Authentication types
         :name: N103D9
         :class: title

   Credentials and Authentication types for connecting to
   repositories:

   .. list-table::
      :header-rows: 1

      - 

         - Type
         - Description
      - 

         - `AuthenticationSupported <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.repositories.AuthenticationSupported.html>`__
         - An artifact repository which supports
            username/password authentication.
      - 

         - `Credentials <https://docs.gradle.org/current/dsl/org.gradle.api.credentials.Credentials.html>`__
         - Base interface for credentials used for
            different authentication purposes. (e.g authenticated
            `RepositoryHandler <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.dsl.RepositoryHandler.html>`__)
      - 

         - `PasswordCredentials <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.repositories.PasswordCredentials.html>`__
         - A username/password credentials that can
            be used to login to password-protected remote repository.
      - 

         - `AwsCredentials <https://docs.gradle.org/current/dsl/org.gradle.api.credentials.AwsCredentials.html>`__
         - Represents credentials used to
            authenticate with Amazon Web Services.
      - 

         - `HttpHeaderCredentials <https://docs.gradle.org/current/dsl/org.gradle.api.credentials.HttpHeaderCredentials.html>`__
         - Credentials that can be used to login to a protected server, 
            e.g. a remote repository by using HTTP header. The
            properties used for creating credentials from a property are
            ``repoAuthHeaderName`` and ``repoAuthHeaderValue``, where ``repo``
            is the identity of the repository.
      - 

         - `AuthenticationContainer <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.repositories.AuthenticationContainer.html>`__
         - Container for configuring repository
            authentication schemes of type
            `Authentication <https://docs.gradle.org/current/dsl/org.gradle.authentication.Authentication.html>`__.
      - 

         - `Authentication <https://docs.gradle.org/current/dsl/org.gradle.authentication.Authentication.html>`__
         - Base interface for transport
            authentication schemes.
      - 

         - `BasicAuthentication <https://docs.gradle.org/current/dsl/org.gradle.authentication.http.BasicAuthentication.html>`__
         - Authentication scheme for basic access
            authentication over HTTP. When using
            this scheme, credentials are sent
            preemptively.
      - 

         - `HttpHeaderAuthentication <https://docs.gradle.org/current/dsl/org.gradle.authentication.http.HttpHeaderAuthentication.html>`__
         - Authentication scheme for HTTP header
            authentication over HTTP.
      - 

         - `DigestAuthentication <https://docs.gradle.org/current/dsl/org.gradle.authentication.http.DigestAuthentication.html>`__
         - Authentication scheme for digest access
            authentication over HTTP.

   .. container:: section

      .. rubric:: `Build Cache types
         :name: N10456
         :class: title

   Types used to connect to and configure the build
   cache:

   .. list-table::
      :header-rows: 1

      - 

         - Type
         - Description
      - 

         - `BuildCacheConfiguration <https://docs.gradle.org/current/dsl/org.gradle.caching.configuration.BuildCacheConfiguration.html>`__
         - Configuration for the `build cache <https://docs.gradle.org/current/userguide/build_cache.html>`__
            for an entire Gradle build.
      - 

         - `DirectoryBuildCache <https://docs.gradle.org/current/dsl/org.gradle.caching.local.DirectoryBuildCache.html>`__
         - Configuration object for the local
            directory build cache.
      - 

         - `HttpBuildCache <https://docs.gradle.org/current/dsl/org.gradle.caching.http.HttpBuildCache.html>`__
         - Configuration object for the HTTP build
            cache. Cache entries are loaded via GET
            and stored via PUT requests.

   .. container:: section

      .. rubric:: `Input Normalization types
         :name: N10484
         :class: title

   Types used to configure input normalization

   .. list-table::
      :header-rows: 1

      - 

         - Type
         - Description
      - 

         - `InputNormalizationHandler <https://docs.gradle.org/current/dsl/org.gradle.normalization.InputNormalizationHandler.html>`__
         - Used to configure input normalization.
            Currently, it is only possible to
            configure runtime classpath
            normalization.
      - 

         - `InputNormalization <https://docs.gradle.org/current/dsl/org.gradle.normalization.InputNormalization.html>`__
         - Input normalization configuration. Input
            normalization is used when Gradle tries
            to determine if two task inputs are
            different. Gradle normalizes both
            inputs and the inputs are considered
            different if and only if the
            normalizations are different.
      - 

         - `RuntimeClasspathNormalization <https://docs.gradle.org/current/dsl/org.gradle.normalization.RuntimeClasspathNormalization.html>`__
         - Configuration of runtime classpath
            normalization.

   .. container:: section

      .. rubric:: `Help Task types
         :name: N104AE
         :class: title

   Below are the task types that are available for every
   Gradle project. Those task types can also be declared
   and configured directly in the build script.

   .. list-table::
      :header-rows: 1

      - 

         - Type
         - Description
      - 

         - `TaskReportTask <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.diagnostics.TaskReportTask.html>`__
         - Displays a list of tasks in the project.
            An instance of this type is used when
            you execute the ``tasks`` task from the
            command-line.
      - 

         - `ProjectReportTask <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.diagnostics.ProjectReportTask.html>`__
         - Displays a list of projects in the
            build. An instance of this type is used
            when you execute the ``projects`` task
            from the command-line.
      - 

         - `DependencyReportTask <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.diagnostics.DependencyReportTask.html>`__
         - Displays the dependency tree for a
            project. An instance of this type is
            used when you execute the
            ``dependencies`` task from the
            command-line.
      - 

         - `DependencyInsightReportTask <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.diagnostics.DependencyInsightReportTask.html>`__
         - Generates a report that attempts to
            answer questions like:
      - 

         - `PropertyReportTask <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.diagnostics.PropertyReportTask.html>`__
         - Displays the properties of a project. An
            instance of this type is used when you
            execute the ``properties`` task from
            the command-line.
      - 

         - `ComponentReport <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.components.ComponentReport.html>`__
         - Displays some details about the software
            components produced by the project.
      - 

         - `DependentComponentsReport <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.dependents.DependentComponentsReport.html>`__
         - Displays dependent components.
      - 

         - `ModelReport <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.model.ModelReport.html>`__
         - Displays some details about the
            configuration model of the project. An
            instance of this type is used when you
            execute the ``model`` task from the
            command-line.
      - 

         - `OutgoingVariantsReportTask <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.diagnostics.OutgoingVariantsReportTask.html>`__
         - A task which reports the outgoing
            variants of a project on the command
            line. This is useful for listing what a
            project produces in terms of variants
            and what artifacts are attached to each
            variant. Variants, in this context,
            must be understood as "things produced
            by a project which can safely be
            consumed by another project".
      - 

         - `ResolvableConfigurationsReportTask <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.diagnostics.ResolvableConfigurationsReportTask.html>`__
         - A task which reports the configurations
            of a project which can be resolved on
            the command line. This is useful for
            determining which attributes are
            associated with the resolvable
            configurations being used to resolve a
            project's dependencies. The output can
            help predict which variant of each
            dependency will be resolved.

   .. container:: section

      .. rubric:: `Task types
         :name: N10526
         :class: title

   Listed below are the various task types which are
   available for use in your build script:

   .. list-table::
      :header-rows: 1

      - 

         - Type
         - Description
      - 

         - `AntlrTask <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.antlr.AntlrTask.html>`__
         - Generates parsers from Antlr grammars.
      - 

         - `BuildEnvironmentReportTask <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.diagnostics.BuildEnvironmentReportTask.html>`__
         - Provides information about the build
            environment for the project that the
            task is associated with.
      - 

         - `Checkstyle <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.quality.Checkstyle.html>`__
         - Runs Checkstyle against some source
            files.
      - 

         - `CodeNarc <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.quality.CodeNarc.html>`__
         - Runs CodeNarc against some source files.
      - 

         - `Copy <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Copy.html>`__
         - Copies files into a destination
            directory. This task can also rename
            and filter files as it copies. The task
            implements
            `CopySpec <https://docs.gradle.org/current/javadoc/org/gradle/api/file/CopySpec.html>`__
            for specifying what to copy.
      - 

         - `CreateStartScripts <https://docs.gradle.org/current/dsl/org.gradle.jvm.application.tasks.CreateStartScripts.html>`__
         - Creates start scripts for launching JVM
            applications.
      - 

         - `Delete <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Delete.html>`__
         - Deletes files or directories. Example:
      - 

         - `Ear <https://docs.gradle.org/current/dsl/org.gradle.plugins.ear.Ear.html>`__
         - Assembles an EAR archive.
      - 

         - `Exec <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Exec.html>`__
         - Executes a command line process.
            Example:
      - 

         - `GenerateIvyDescriptor <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.tasks.GenerateIvyDescriptor.html>`__
         - Generates an Ivy XML Module Descriptor
            file.
      - 

         - `GenerateMavenPom <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.tasks.GenerateMavenPom.html>`__
         - Generates a Maven module descriptor
            (POM) file.
      - 

         - `GenerateBuildDashboard <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.GenerateBuildDashboard.html>`__
         - Generates build dashboard report.
      - 

         - `GradleBuild <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.GradleBuild.html>`__
         - Executes a Gradle build.
      - 

         - `GroovyCompile <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.compile.GroovyCompile.html>`__
         - Compiles Groovy source files, and
            optionally, Java source files.
      - 

         - `Groovydoc <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.javadoc.Groovydoc.html>`__
         - Generates HTML API documentation for
            Groovy source, and optionally, Java
            source.
      - 

         - `HtmlDependencyReportTask <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.dependencies.HtmlDependencyReportTask.html>`__
         - Generates an HTML dependency report.
            This report combines the features of
            the ASCII dependency report and those
            of the ASCII dependency insight report.
            For a given project, it generates a
            tree of the dependencies of every
            configuration, and each dependency can
            be clicked to show the insight of this
            dependency.
      - 

         - `JacocoReport <https://docs.gradle.org/current/dsl/org.gradle.testing.jacoco.tasks.JacocoReport.html>`__
         - Task to generate HTML, Xml and CSV
            reports of Jacoco coverage data.
      - 

         - `JacocoCoverageVerification <https://docs.gradle.org/current/dsl/org.gradle.testing.jacoco.tasks.JacocoCoverageVerification.html>`__
         - Task for verifying code coverage
            metrics. Fails the task if violations
            are detected based on specified rules.
      - 

         - `Jar <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.bundling.Jar.html>`__
         - Assembles a JAR archive.
      - 

         - `JavaCompile <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.compile.JavaCompile.html>`__
         - Compiles Java source files.
      - 

         - `Javadoc <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.javadoc.Javadoc.html>`__
         - Generates HTML API documentation for
            Java classes.
      - 

         - `JavaExec <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.JavaExec.html>`__
         - Executes a Java application in a child
            process.
      - 

         - `Pmd <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.quality.Pmd.html>`__
         - Runs a set of static code analysis rules
            on Java source code files and generates
            a report of problems found.
      - 

         - `ProcessResources <https://docs.gradle.org/current/dsl/org.gradle.language.jvm.tasks.ProcessResources.html>`__
         - Copies resources from their source to
            their target directory, potentially
            processing them. Makes sure no stale
            resources remain in the target
            directory.
      - 

         - `PublishToIvyRepository <https://docs.gradle.org/current/dsl/org.gradle.api.publish.ivy.tasks.PublishToIvyRepository.html>`__
         - Publishes an IvyPublication to an
            IvyArtifactRepository.
      - 

         - `PublishToMavenRepository <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.tasks.PublishToMavenRepository.html>`__
         - Publishes a
            `MavenPublication <https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPublication.html>`__
            to a
            `MavenArtifactRepository <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.repositories.MavenArtifactRepository.html>`__.
      - 

         - `ScalaCompile <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.scala.ScalaCompile.html>`__
         - Compiles Scala source files, and
            optionally, Java source files.
      - 

         - `ScalaDoc <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.scala.ScalaDoc.html>`__
         - Generates HTML API documentation for
            Scala source files.
      - 

         - `InitBuild <https://docs.gradle.org/current/dsl/org.gradle.buildinit.tasks.InitBuild.html>`__
         - Generates a Gradle project structure.
      - 

         - `Sign <https://docs.gradle.org/current/dsl/org.gradle.plugins.signing.Sign.html>`__
         - A task for creating digital signature
            files for one or more; tasks, files,
            publishable artifacts or
            configurations.
      - 

         - `Sync <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Sync.html>`__
         - Synchronizes the contents of a
            destination directory with some source
            directories and files.
      - 

         - `Tar <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.bundling.Tar.html>`__
         - Assembles a TAR archive.
      - 

         - `AbstractTestTask <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.testing.AbstractTestTask.html>`__
         - Abstract class for all test tasks.
      - 

         - `Test <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.testing.Test.html>`__
         - Executes JUnit (3.8.x, 4.x or 5.x) or
            TestNG tests. Test are always run in
            (one or more) separate JVMs.
      - 

         - `TestReport <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.testing.TestReport.html>`__
         - Generates an HTML test report from the
            results of one or more
            `Test <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.testing.Test.html>`__
            tasks.
      - 

         - `War <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.bundling.War.html>`__
         - Assembles a WAR archive.
      - 

         - `Wrapper <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.wrapper.Wrapper.html>`__
         - Generates scripts (for \*nix and
            windows) which allow you to build your
            project with Gradle, without having to
            install Gradle.
      - 

         - `WriteProperties <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.WriteProperties.html>`__
         - Writes a
            `Properties <https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html>`__
            in a way that the results can be
            expected to be reproducible.
      - 

         - `Zip <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.bundling.Zip.html>`__
         - Assembles a ZIP archive. The default is
            to compress the contents of the zip.

   .. container:: section

      .. rubric:: `Test types
         :name: N106AD
         :class: title

      Listed below are the tasks and configurable objects
      related to modeled Test Suites:

      .. list-table::
         :header-rows: 1

         - 

            - Type
            - Description
         - 

            - `TestingExtension <https://docs.gradle.org/current/dsl/org.gradle.testing.base.TestingExtension.html>`__
            - This DSL element exists to contain a
               collection of
               `TestSuite <https://docs.gradle.org/current/dsl/org.gradle.testing.base.TestSuite.html>`__\ s.
         - 

            - `TestSuite <https://docs.gradle.org/current/dsl/org.gradle.testing.base.TestSuite.html>`__
            - Base test suite component. A test suite
               is a collection of tests.
         - 

            - `JvmTestSuite <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.jvm.JvmTestSuite.html>`__
            - A test suite is a collection of
               JVM-based tests.
         - 

            - `TestSuiteTarget <https://docs.gradle.org/current/dsl/org.gradle.testing.base.TestSuiteTarget.html>`__
            - Base test suite target. A test suite
               target is a collection of tests that
               run in a particular context (operating
               system, Java runtime, etc).
         - 

            - `JvmTestSuiteTarget <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.jvm.JvmTestSuiteTarget.html>`__
            - Defines the target environment against
               which a
               `JvmTestSuite <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.jvm.JvmTestSuite.html>`__
               will be run.
         - 

            - `Test <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.testing.Test.html>`__
            - Executes JUnit (3.8.x, 4.x or 5.x) or
               TestNG tests. Test are always run in
               (one or more) separate JVMs.
         - 

            - `Dependencies <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.dsl.Dependencies.html>`__
            - Universal APIs that are available for
               all ``dependencies`` blocks.
         - 

            - `GradleDependencies <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.dsl.GradleDependencies.html>`__
            - Dependency APIs available for
               ``dependencies`` blocks that can build
               software that relies on Gradle APIs.
         - 

            - `TestFixturesDependencyModifiers <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.jvm.TestFixturesDependencyModifiers.html>`__
            - Dependency modifier APIs that can find
               test fixtures in other modules for
               ``dependencies`` blocks.
         - 

            - `PlatformDependencyModifiers <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.jvm.PlatformDependencyModifiers.html>`__
            - Dependency modifier APIs that can find
               platform and enforced platforms in
               other modules for ``dependencies``
               blocks.
         - 

            - `JvmComponentDependencies <https://docs.gradle.org/current/dsl/org.gradle.api.plugins.jvm.JvmComponentDependencies.html>`__
            - This DSL element is used to add
               dependencies to a component, for
               instance a
               `TestSuite <https://docs.gradle.org/current/dsl/org.gradle.testing.base.TestSuite.html>`__

   .. container:: section

      .. rubric:: `Reporting types
         :name: N1073A
         :class: title

      Listed below are some of the types which are used when
      generating reports:

      .. list-table::
         :header-rows: 1

         - 

            - Type
            - Description
         - 

            - `CustomizableHtmlReport <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.CustomizableHtmlReport.html>`__
            - A HTML Report whose generation can be
               customized with a XSLT stylesheet.
         - 

            - `SingleFileReport <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.SingleFileReport.html>`__
            - A report that is a single file.
         - 

            - `DirectoryReport <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.DirectoryReport.html>`__
            - A directory based report to be created.
         - 

            - `Report <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.Report.html>`__
            - A file based report to be created.
         - 

            - `Reporting <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.Reporting.html>`__
            - An object that provides reporting
               options.
         - 

            - `ReportContainer <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.ReportContainer.html>`__
            - A container of
               `Report <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.Report.html>`__
               objects, that represent potential
               reports.
         - 

            - `ReportingExtension <https://docs.gradle.org/current/dsl/org.gradle.api.reporting.ReportingExtension.html>`__
            - A project extension named "reporting"
               that provides basic reporting settings
               and utilities.
         - 

            - `AggregateTestReport <https://docs.gradle.org/current/dsl/org.gradle.api.tasks.testing.AggregateTestReport.html>`__
            - A container for the inputs of an
               aggregated test report.
         - 

            - `JacocoCoverageReport <https://docs.gradle.org/current/dsl/org.gradle.testing.jacoco.plugins.JacocoCoverageReport.html>`__
            - A container for the inputs of an
               aggregated JaCoCo code coverage report.

   .. container:: section

      .. rubric:: `Eclipse/IDEA model types
         :name: N1079F
         :class: title

      Used to configure Eclipse or IDEA plugins

      .. list-table::
         :header-rows: 1

         - 

            - Type
            - Description
         - 

            - `EclipseModel <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.model.EclipseModel.html>`__
            - DSL-friendly model of the Eclipse
               project information. First point of
               entry for customizing Eclipse project
               generation.
         - 

            - `EclipseProject <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.model.EclipseProject.html>`__
            - Enables fine-tuning project details
               (.project file) of the Eclipse plugin
         - 

            - `EclipseClasspath <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.model.EclipseClasspath.html>`__
            - The build path settings for the
               generated Eclipse project. Used by the
               `GenerateEclipseClasspath <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.GenerateEclipseClasspath.html>`__
               task to generate an Eclipse .classpath
               file.
         - 

            - `EclipseJdt <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.model.EclipseJdt.html>`__
            - Enables fine-tuning jdt details of the
               Eclipse plugin
         - 

            - `EclipseWtp <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.model.EclipseWtp.html>`__
            - Enables fine-tuning wtp/wst details of
               the Eclipse plugin
         - 

            - `EclipseWtpComponent <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent.html>`__
            - Enables fine-tuning wtp component
               details of the Eclipse plugin
         - 

            - `EclipseWtpFacet <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.model.EclipseWtpFacet.html>`__
            - Enables fine-tuning wtp facet details of
               the Eclipse plugin
         - 

            - `IdeaModel <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.idea.model.IdeaModel.html>`__
            - DSL-friendly model of the IDEA project
               information. First point of entry when
               it comes to customizing the IDEA
               generation.
         - 

            - `IdeaProject <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.idea.model.IdeaProject.html>`__
            - Enables fine-tuning project details
               (\*.ipr file) of the IDEA plugin.
         - 

            - `IdeaModule <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.idea.model.IdeaModule.html>`__
            - Enables fine-tuning module details
               (\*.iml file) of the IDEA plugin.
         - 

            - `IdeaWorkspace <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.idea.model.IdeaWorkspace.html>`__
            - Enables fine-tuning workspace details
               (\*.iws file) of the IDEA plugin.
         - 

            - `XmlFileContentMerger <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.api.XmlFileContentMerger.html>`__
            - Models the generation/parsing/merging
               capabilities. Adds XML-related hooks.
         - 

            - `FileContentMerger <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.api.FileContentMerger.html>`__
            - Models the generation/parsing/merging
               capabilities.

   .. container:: section

      .. rubric:: `Eclipse/IDEA task types
         :name: N10828
         :class: title

      Tasks contributed by IDE plugins. To configure IDE
      plugins please use IDE model types.

      .. list-table::
         :header-rows: 1

         - 

            - Type
            - Description
         - 

            - `GenerateEclipseProject <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.GenerateEclipseProject.html>`__
            - Generates an Eclipse ``.project`` file.
               If you want to fine tune the eclipse
               configuration
         - 

            - `GenerateEclipseClasspath <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.GenerateEclipseClasspath.html>`__
            - Generates an Eclipse ``.classpath``
               file. If you want to fine tune the
               eclipse configuration
         - 

            - `GenerateEclipseJdt <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.GenerateEclipseJdt.html>`__
            - Generates the Eclipse JDT configuration
               file. If you want to fine tune the
               eclipse configuration
         - 

            - `GenerateEclipseWtpComponent <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.GenerateEclipseWtpComponent.html>`__
            - Generates the
               org.eclipse.wst.common.component
               settings file for Eclipse WTP. If you
               want to fine tune the eclipse
               configuration
         - 

            - `GenerateEclipseWtpFacet <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.GenerateEclipseWtpFacet.html>`__
            - Generates the
               org.eclipse.wst.common.project.facet.core
               settings file for Eclipse WTP. If you
               want to fine tune the eclipse
               configuration
         - 

            - `GenerateIdeaModule <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.idea.GenerateIdeaModule.html>`__
            - Generates an IDEA module file. If you
               want to fine tune the idea
               configuration
         - 

            - `GenerateIdeaProject <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.idea.GenerateIdeaProject.html>`__
            - Generates an IDEA project file for root
               project \*only\*. If you want to fine
               tune the idea configuration
         - 

            - `GenerateIdeaWorkspace <https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.idea.GenerateIdeaWorkspace.html>`__
            - Generates an IDEA workspace file
               \*only\* for root project. There's
               little you can configure about
               workspace generation at the moment.

   .. container:: section

      .. rubric:: `Xcode task types
         :name: N10885
         :class: title

      Tasks contributed by Xcode IDE plugins. To configure
      IDE plugins please use IDE model types.

   .. list-table::
      :header-rows: 1

      - 

         - Type
         - Description
      - 

         - `GenerateSchemeFileTask <https://docs.gradle.org/current/dsl/org.gradle.ide.xcode.tasks.GenerateSchemeFileTask.html>`__
         - Task for generating a Xcode scheme file
            (e.g.
            ``Foo.xcodeproj/xcshareddata/xcschemes/Foo.xcscheme``).
            An Xcode scheme defines a collection of
            targets to build, a configuration to
            use when building, and a collection of
            tests to execute.
      - 

         - `GenerateWorkspaceSettingsFileTask <https://docs.gradle.org/current/dsl/org.gradle.ide.xcode.tasks.GenerateWorkspaceSettingsFileTask.html>`__
         - Task for generating a Xcode workspace
            settings file (e.g.
            ``Foo.xcodeproj/project.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings``).
      - 

         - `GenerateXcodeProjectFileTask <https://docs.gradle.org/current/dsl/org.gradle.ide.xcode.tasks.GenerateXcodeProjectFileTask.html>`__
         - Task for generating a Xcode project file
            (e.g.
            ``Foo.xcodeproj/project.pbxproj``). A
            project contains all the elements used
            to build your products and maintains
            the relationships between those
            elements. It contains one or more
            targets, which specify how to build
            products. A project defines default
            build settings for all the targets in
            the project (each target can also
            specify its own build settings, which
            override the project build settings).
      - 

         - `GenerateXcodeWorkspaceFileTask <https://docs.gradle.org/current/dsl/org.gradle.ide.xcode.tasks.GenerateXcodeWorkspaceFileTask.html>`__
         - Task for generating a Xcode workspace
            file (e.g.
            ``Foo.xcworkspace/contents.xcworkspacedata``).
            A workspace can contain any number of
            Xcode projects.

   .. container:: section

      .. rubric:: `Visual Studio task types
         :name: N108C4
         :class: title

      Tasks contributed by Visual Studio IDE plugins. To
      configure IDE plugins please use IDE model types.

      .. list-table::
         :header-rows: 1

         - 

            - Type
            - Description
         - 

            - `GenerateSolutionFileTask <https://docs.gradle.org/current/dsl/org.gradle.ide.visualstudio.tasks.GenerateSolutionFileTask.html>`__
            - Task for generating a Visual Studio
               solution file (e.g. ``foo.sln``).
         - 

            - `GenerateProjectFileTask <https://docs.gradle.org/current/dsl/org.gradle.ide.visualstudio.tasks.GenerateProjectFileTask.html>`__
            - Task for generating a Visual Studio
               project file (e.g. ``foo.vcxproj``).
         - 

            - `GenerateFiltersFileTask <https://docs.gradle.org/current/dsl/org.gradle.ide.visualstudio.tasks.GenerateFiltersFileTask.html>`__
            - Task for generating a Visual Studio
               filters file (e.g.
               ``foo.vcxproj.filters``).

   .. container:: section

      .. rubric:: `Artifact transform types
         :name: N108F7
         :class: title

      Used to define artifact transforms.

      .. list-table::
         :header-rows: 1

         - 

            - Type
            - Description
         - 

            - `TransformAction <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.transform.TransformAction.html>`__
            - Interface for artifact transform
               actions.
         - 

            - `TransformOutputs <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.transform.TransformOutputs.html>`__
            - The outputs of the artifact transform.
         - 

            - `TransformSpec <https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.transform.TransformSpec.html>`__
            - Base configuration for artifact
               transform registrations.

   .. container:: section

      .. rubric:: `Native tool chains model types
         :name: N10921
         :class: title

      Used to configure tool chains for building C++ and
      Swift components.

      .. list-table::
         :header-rows: 1

         - 

            - Type
            - Description
         - 

            - `Gcc <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.toolchain.Gcc.html>`__
            - The `GNU GCC <http://gcc.gnu.org/>`__
               tool chain.
         - 

            - `Clang <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.toolchain.Clang.html>`__
            - The `Clang <http://clang.llvm.org>`__ tool chain.
         - 

            - `VisualCpp <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.toolchain.VisualCpp.html>`__
            - The Visual C++ tool chain.
         - 

            - `Swiftc <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.toolchain.Swiftc.html>`__
            - The `Swift Compiler <https://swift.org/>`__ tool chain.

   .. container:: section

      .. rubric:: `Native software model types
         :name: N10960
         :class: title

      Used to configure software components developed with native code.

      .. list-table::
         :header-rows: 1

         - 

            - Type
            - Description
         - 

            - `PrebuiltLibrary <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.PrebuiltLibrary.html>`__
            - A library component that is not built by gradle.
         - 

            - `PrebuiltSharedLibraryBinary <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.PrebuiltSharedLibraryBinary.html>`__
            - A shared library that exists at a known location on the filesystem.
         - 

            - `PrebuiltStaticLibraryBinary <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.PrebuiltStaticLibraryBinary.html>`__
            - A static library that exists at a known location on the filesystem.
         - 

            - `NativeComponentSpec <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.NativeComponentSpec.html>`__
            - Definition of a software component that
               is to be built by Gradle to run a on JVM platform.
         - 

            - `NativeExecutableSpec <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.NativeExecutableSpec.html>`__
            - Definition of a native executable
               component that is to be built by Gradle.
         - 

            - `NativeLibrarySpec <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.NativeLibrarySpec.html>`__
            - Definition of a native library component that is to be built by Gradle.
         - 

            - `NativeTestSuiteSpec <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.test.NativeTestSuiteSpec.html>`__
            - A component representing a suite of tests that will be executed together.
         - 

            - `CUnitTestSuiteSpec <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.test.cunit.CUnitTestSuiteSpec.html>`__
            - Test suite of CUnit tests.
         - 

            - `GoogleTestTestSuiteSpec <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.test.googletest.GoogleTestTestSuiteSpec.html>`__
            - Test suite of Google Test tests.
         - 

            - `NativeBinarySpec <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.NativeBinarySpec.html>`__
            - Represents a binary artifact that is the
               result of building a native component.
         - 

            - `NativeExecutableBinarySpec <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.NativeExecutableBinarySpec.html>`__
            - An binary built by Gradle for a native application.
         - 

            - `NativeLibraryBinarySpec <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.NativeLibraryBinarySpec.html>`__
            - Represents a binary artifact that is the
               result of building a native library component.
         - 

            - `SharedLibraryBinarySpec <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.SharedLibraryBinarySpec.html>`__
            - A shared library binary built by Gradle
               for a native library.
         - 

            - `StaticLibraryBinarySpec <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.StaticLibraryBinarySpec.html>`__
            - A static library binary built by Gradle
               for a native library.
         - 

            - `NativeTestSuiteBinarySpec <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.test.NativeTestSuiteBinarySpec.html>`__
            - An executable which runs a suite of tests.
         - 

            - `CUnitTestSuiteBinarySpec <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.test.cunit.CUnitTestSuiteBinarySpec.html>`__
            - An executable which run a CUnit test suite.
         - 

            - `GoogleTestTestSuiteBinarySpec <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.test.googletest.GoogleTestTestSuiteBinarySpec.html>`__
            - An executable which run a Google Test test suite.
         - 

            - `NativePlatform <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.platform.NativePlatform.html>`__
            - A target platform for building native binaries. Each target 
               platform is given a name, and may optionally be given a specific
               `Architecture <https://docs.gradle.org/current/javadoc/org/gradle/nativeplatform/platform/Architecture.html>`__
               and/or
               `OperatingSystem <https://docs.gradle.org/current/javadoc/org/gradle/nativeplatform/platform/OperatingSystem.html>`__
               to target.
         - 

            - `BuildType <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.BuildType.html>`__
            - Specifies a build-type for a native
               binary. Common build types are 'debug'
               and 'release', but others may be defined.
         - 

            - `Flavor <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.Flavor.html>`__
            - Defines a custom variant that differentiate a
               `NativeBinary <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.NativeBinary.html>`__.
         - 

            - `AssemblerSourceSet <https://docs.gradle.org/current/dsl/org.gradle.language.assembler.AssemblerSourceSet.html>`__
            - A set of assembly language sources.
         - 

            - `CSourceSet <https://docs.gradle.org/current/dsl/org.gradle.language.c.CSourceSet.html>`__
            - A set of C source files.
         - 

            - `CppSourceSet <https://docs.gradle.org/current/dsl/org.gradle.language.cpp.CppSourceSet.html>`__
            - A set of C++ source files.
         - 

            - `ObjectiveCSourceSet <https://docs.gradle.org/current/dsl/org.gradle.language.objectivec.ObjectiveCSourceSet.html>`__
            - A set of Objective-C source files.
         - 

            - `ObjectiveCppSourceSet <https://docs.gradle.org/current/dsl/org.gradle.language.objectivecpp.ObjectiveCppSourceSet.html>`__
            - A set of Objective-C++ source files.
         - 

            - `WindowsResourceSet <https://docs.gradle.org/current/dsl/org.gradle.language.rc.WindowsResourceSet.html>`__
            - A set of Windows Resource definition files.
         - 

            - `VisualStudioProject <https://docs.gradle.org/current/dsl/org.gradle.ide.visualstudio.VisualStudioProject.html>`__
            - A visual studio project, created from
               one or more native binaries.
         - 

            - `VisualStudioSolution <https://docs.gradle.org/current/dsl/org.gradle.ide.visualstudio.VisualStudioSolution.html>`__
            - A visual studio solution, representing
               one or more native binaries in a build.
         - 

            - `NativeExecutable <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.NativeExecutable.html>`__
            - An executable native component that is
               built by Gradle.
         - 

            - `NativeLibrary <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.NativeLibrary.html>`__
            - A library component that is built by a gradle project.
         - 

            - `NativeBinary <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.NativeBinary.html>`__
            - Represents a particular binary artifact.
         - 

            - `NativeExecutableBinary <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.NativeExecutableBinary.html>`__
            - A binary artifact for a
               `NativeExecutable <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.NativeExecutable.html>`__,
               targeted at a particular platform with
               specific configuration.
         - 

            - `SharedLibraryBinary <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.SharedLibraryBinary.html>`__
            - A
               `NativeLibrary <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.NativeLibrary.html>`__
               that has been compiled and linked as a shared library.
         - 

            - `StaticLibraryBinary <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.StaticLibraryBinary.html>`__
            - A
               `NativeLibrary <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.NativeLibrary.html>`__
               that has been compiled and archived into a static library.

   .. container:: section

      .. rubric:: `C++ component model types
         :name: N10AC0
         :class: title

   Used to configure C++ components.

      .. list-table::
         :header-rows: 1

         - 

            - Type
            - Description
         - 

            - `CppApplication <https://docs.gradle.org/current/dsl/org.gradle.language.cpp.CppApplication.html>`__
            - Configuration for a C++ application,
               defining the source files that make up
               the application plus other settings.
         - 

            - `CppLibrary <https://docs.gradle.org/current/dsl/org.gradle.language.cpp.CppLibrary.html>`__
            - Configuration for a C++ library,
               defining the source files and header
               directories that make up the library
               plus other settings.
         - 

            - `CppTestSuite <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.test.cpp.CppTestSuite.html>`__
            - A C++ test suite.

   .. container:: section

      .. rubric:: `Swift component model types
         :name: N10AEA
         :class: title

   Used to configure Swift components.

      .. list-table::
         :header-rows: 1

         - 

            - Type
            - Description
         - 

            - `SwiftApplication <https://docs.gradle.org/current/dsl/org.gradle.language.swift.SwiftApplication.html>`__
            - Configuration for a Swift application,
               defining the source files that make up
               the application plus other settings.
         - 

            - `SwiftLibrary <https://docs.gradle.org/current/dsl/org.gradle.language.swift.SwiftLibrary.html>`__
            - Configuration for a Swift library,
               defining the source files that make up
               the library plus other settings.
         - 

            - `SwiftXCTestSuite <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.test.xctest.SwiftXCTestSuite.html>`__
            - A XCTest suite, implemented in Swift.

   .. container:: section

      .. rubric:: `Native binary task types
         :name: N10B14
         :class: title

   Tasks used to build native binaries.

      .. list-table::
         :header-rows: 1

         - 

            - Type
            - Description
         - 

            - `CppCompile <https://docs.gradle.org/current/dsl/org.gradle.language.cpp.tasks.CppCompile.html>`__
            - Compiles C++ source files into object
               files.
         - 

            - `SwiftCompile <https://docs.gradle.org/current/dsl/org.gradle.language.swift.tasks.SwiftCompile.html>`__
            - Compiles Swift source files into object
               files.
         - 

            - `LinkExecutable <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.tasks.LinkExecutable.html>`__
            - Links a binary executable from object
               files and libraries.
         - 

            - `LinkSharedLibrary <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.tasks.LinkSharedLibrary.html>`__
            - Links a binary shared library from
               object files and imported libraries.
         - 

            - `CreateStaticLibrary <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.tasks.CreateStaticLibrary.html>`__
            - Assembles a static library from object
               files.
         - 

            - `LinkMachOBundle <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.tasks.LinkMachOBundle.html>`__
            - Links a binary bundle from object files
               and imported libraries.
         - 

            - `InstallExecutable <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.tasks.InstallExecutable.html>`__
            - Installs an executable with it's
               dependent libraries so it can be easily
               executed.
         - 

            - `InstallXCTestBundle <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.test.xctest.tasks.InstallXCTestBundle.html>`__
            - Creates a XCTest bundle with a run
               script so it can be easily executed.
         - 

            - `RunTestExecutable <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.test.tasks.RunTestExecutable.html>`__
            - Runs a compiled and installed test
               executable.
         - 

            - `XCTest <https://docs.gradle.org/current/dsl/org.gradle.nativeplatform.test.xctest.tasks.XCTest.html>`__
            - Executes XCTest tests. Test are always
               run in a single execution.

   .. container:: section

      .. rubric:: `Native binary task types
         :name: N10B7D
         :class: title

   Tasks used to build native binaries.

      .. list-table::
         :header-rows: 1

         - 

            - Type
            - Description
         - 

            - `CCompile <https://docs.gradle.org/current/dsl/org.gradle.language.c.tasks.CCompile.html>`__
            - Compiles C source files into object
               files.
         - 

            - `Assemble <https://docs.gradle.org/current/dsl/org.gradle.language.assembler.tasks.Assemble.html>`__
            - Translates Assembly language source
               files into object files.
         - 

            - `ObjectiveCCompile <https://docs.gradle.org/current/dsl/org.gradle.language.objectivec.tasks.ObjectiveCCompile.html>`__
            - Compiles Objective-C source files into
               object files.
         - 

            - `ObjectiveCppCompile <https://docs.gradle.org/current/dsl/org.gradle.language.objectivecpp.tasks.ObjectiveCppCompile.html>`__
            - Compiles Objective-C++ source files into
               object files.
         - 

            - `WindowsResourceCompile <https://docs.gradle.org/current/dsl/org.gradle.language.rc.tasks.WindowsResourceCompile.html>`__
            - Compiles Windows Resource scripts into
               .res files.

 /Kotlin DSL Reference
 =====================
 `Kotlin DSL Reference <https://docs.gradle.org/current/kotlin-dsl/index.html>`__


.. container:: content sourceset-dependent-content

   .. rubric:: Kotlin DSL Reference for Gradle
      :name: kotlin-dsl-reference-for-gradle

   Gradle뗩 Kotlin DSL provides an enhanced editing
   experience in supported IDEs, with superior content
   assist, refactoring, documentation, and more. For
   an introduction see the `Kotlin DSL Primer <https://docs.gradle.org/current/userguide/kotlin_dsl.html>`__.

   The Kotlin DSL is implemented on top of Gradle뗩
   Java API. Many of the objects, functions and
   properties you use in your build scripts come from
   the Gradle API and the APIs of the applied plugins.
   This reference covers both the Kotlin DSL and the
   Java API, but it doesn't include functionality
   provided by external plugins.

   The main package of the Kotlin DSL is
   `org.gradle.kotlin.dsl <https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.kotlin.dsl/index.html>`__.
   All members of this package are implicitly imported
   and readily available in ``.gradle.kts`` scripts in
   addition to the Java API `default imports <#writing_build_scripts.html#script-default-imports>`__.


.. container:: table

   .. rubric:: Packages
   :name: packages

   DSL

   - `org.gradle.kotlin.dsl`__ The ``org.gradle.kotlin.dsl`` package contains 
      the Gradle Kotlin DSL public API.

   - `org.gradle.kotlin.dsl.precompile`__ 


   API

   - `org.gradle`__ Classes for embedding Gradle.
   - `org.gradle.api`__ Gradle's build language API, which is available from your build files. 
      Location of the main interfaces involved in build scripts.
   - `org.gradle.api.artifacts`__ Classes for declaring and using artifacts and artifact dependencies.
   - `org.gradle.api.artifacts.component`__ Classes that provide meta-data about software components.
   - `org.gradle.api.artifacts.dsl`__ Classes used in the artifact DSL.
   - `org.gradle.api.artifacts.ivy`__ Classes for declaring and using Ivy modules.
   - `org.gradle.api.artifacts.maven`__ Classes for declaring and using Maven modules.
   - `org.gradle.api.artifacts.query`__ Classes used for querying the artifacts.
   - `org.gradle.api.artifacts.repositories`__ Classes for declaring and using artifact repositories.
   - `org.gradle.api.artifacts.result`__ Classes that compose the resolution result
   - `org.gradle.api.artifacts.transform`__ Provides classes, interfaces and annotations for 
      registering and implementing artifact transforms.
   - `org.gradle.api.artifacts.type`__ Types related to artifact type definitions.
   - `org.gradle.api.artifacts.verification`__ Dependency verification related configuration classes
   - `org.gradle.api.attributes`__ Classes for dealing with configuration and artifact attributes.
   - `org.gradle.api.attributes.java`__ Attributes specific to the Java ecosystem.
   - `org.gradle.api.attributes.plugin`__ Attributes specific to Gradle's plugin system.
   - `org.gradle.api.cache`__ Classes for configuring cache-related components.
   - `org.gradle.api.capabilities`__ Classes for dealing with capabilities.
   - `org.gradle.api.component`__ Types for declaring and using Software Components.
   - `org.gradle.api.configuration`__ Classes related to build configuration.
   - `org.gradle.api.credentials`__ general credentials related classes.
   - `org.gradle.api.distribution`__ The main interfaces and classes of the distribution plugin.
   - `org.gradle.api.distribution.plugins`__ The distribution plugin itself.
   - `org.gradle.api.execution`__ Classes for managing and monitoring build execution.
   - `org.gradle.api.file`__ Classes for working with files.
   - `org.gradle.api.flow`__ Gradle Flow API.
   - `org.gradle.api.initialization`__ Classes for managing and monitoring build initialization.
   - `org.gradle.api.initialization.definition`__ Types related to the build definition 
      for included builds.
   - `org.gradle.api.initialization.dsl`__ Classes used in the initialization DSL.
   - `org.gradle.api.initialization.resolve`__ Classes for managing cross-project dependency resolution.
   - `org.gradle.api.invocation`__ Classes for invoking and monitoring gradle builds.
   - `org.gradle.api.java.archives`__ Classes for working with JAR manifests.
   - `org.gradle.api.jvm`__ Interfaces for configuring the Java Platform Module System (JPMS).
   - `org.gradle.api.launcher.cli`__ Interfaces for configuring the cli client.
   - `org.gradle.api.logging`__ Classes for managing logging in Gradle.
   - `org.gradle.api.logging.configuration`__ Classes for logging configuration.
   - `org.gradle.api.model`__ Classes that operate on the Gradle model.
   - `org.gradle.api.plugins`__ The standard `org.gradle.api.Plugin`__ implementations.
   - `org.gradle.api.plugins.antlr`__ A `org.gradle.api.Plugin`__ for generating parsers 
      from Antlr grammars.
   - `org.gradle.api.plugins.catalog`__
   - `org.gradle.api.plugins.jvm`__
   - `org.gradle.api.plugins.quality`__ Plugins which measure and enforce code quality.
   - `org.gradle.api.plugins.scala`__ A `org.gradle.api.Plugin`__ which compiles and tests Scala sources.
   - `org.gradle.api.problems`__ new Problems API
   - `org.gradle.api.provider`__ The interfaces for value providers.
   - `org.gradle.api.publish`__ Classes that deal with publishing artifacts.
   - `org.gradle.api.publish.ivy`__ Types that deal with publishing in the Ivy format.
   - `org.gradle.api.publish.ivy.plugins`__ Plugins for Ivy publishing.
   - `org.gradle.api.publish.ivy.tasks`__ Tasks for Ivy publishing.
   - `org.gradle.api.publish.maven`__ Types that deal with publishing in the Maven format.
   - `org.gradle.api.publish.maven.plugins`__ Plugins for publishing in the Maven format.
   - `org.gradle.api.publish.maven.tasks`__ Tasks for publishing in the Maven format.
   - `org.gradle.api.publish.plugins`__ Publishing plugin.
   - `org.gradle.api.publish.tasks`__ Tasks used for publishing to a binary repository.
   - `org.gradle.api.reflect`__ Classes and API for the reflection and types.
   - `org.gradle.api.reporting`__ Classes for reporting
   - `org.gradle.api.reporting.components`__ Component reporting tasks.
   - `org.gradle.api.reporting.dependencies`__ Types responsible for generating dependency reports.
   - `org.gradle.api.reporting.dependents`__ Types responsible for generating dependents components reports.
   - `org.gradle.api.reporting.model`__ Configuration model reporting tasks.
   - `org.gradle.api.reporting.plugins`__ Plugins for reporting
   - `org.gradle.api.resources`__ Interfaces and API for the 'Resources' concept.
   - `org.gradle.api.services`__ Types for defining and using build services.
   - `org.gradle.api.specs`__ Classes for defining general purpose criteria.
   - `org.gradle.api.tasks`__ The standard `org.gradle.api.Task`__ implementations.
   - `org.gradle.api.tasks.ant`__ The Ant integration `org.gradle.api.Task`__ implementations.
   - `org.gradle.api.tasks.application`__
   - `org.gradle.api.tasks.bundling`__ The archive bundling `org.gradle.api.Task`__ implementations.
   - `org.gradle.api.tasks.compile`__ The compilation `org.gradle.api.Task`__ implementations.
   - `org.gradle.api.tasks.diagnostics`__ The diagnostic `org.gradle.api.Task`__ implementations.
   - `org.gradle.api.tasks.diagnostics.configurations`__ Diagnostic tasks which report information about configurations.
   - `org.gradle.api.tasks.incremental`__ API classes for implementing incremental tasks.
   - `org.gradle.api.tasks.javadoc`__ The documentation generation `org.gradle.api.Task`__ implementations.
   - `org.gradle.api.tasks.options`__ Annotations for exposing task properties as command line options.
   - `org.gradle.api.tasks.scala`__
   - `org.gradle.api.tasks.testing`__ The unit testing `org.gradle.api.Task`__ implementations.
   - `org.gradle.api.tasks.testing.junit`__ JUnit specific testing classes.
   - `org.gradle.api.tasks.testing.junitplatform`__
   - `org.gradle.api.tasks.testing.logging`__ Types related to logging of test related information to the console.
   - `org.gradle.api.tasks.testing.testng`__ TestNG specific testing classes.
   - `org.gradle.api.tasks.util`__ Utility classes used by the standard task implementations.
   - `org.gradle.api.tasks.wrapper`__ The Gradle wrapper `org.gradle.api.Task`__.
   - `org.gradle.api.toolchain.management`__ APIs to influence how toolchains are resolved.
   - `org.gradle.authentication`__ Classes related to transport authentication protocols.
   - `org.gradle.authentication.aws`__ Classes related to transport authentication protocols for S3.
   - `org.gradle.authentication.http`__ Classes related to transport authentication protocols for HTTP.
   - `org.gradle.build.event`__ Types for receiving build events.
   - `org.gradle.buildinit`__ Build init plugins and tasks. This powers "gradle init".
   - `org.gradle.buildinit.plugins`__ Build init plugins.
   - `org.gradle.buildinit.tasks`__ Build init plugins.
   - `org.gradle.caching`__
   - `org.gradle.caching.configuration`__ Classes for configuring build caches.
   - `org.gradle.caching.http`__ Classes for HTTP build cache service.
   - `org.gradle.caching.local`__ Classes for local build cache services.
   - `org.gradle.concurrent`__ Classes related to Gradle parallelism and concurrency.
   - `org.gradle.external.javadoc`__ Classes to run Javadoc.
   - `org.gradle.ide.visualstudio`__ Model classes for visual studio.
   - `org.gradle.ide.visualstudio.plugins`__ Plugins for Visual Studio integration.
   - `org.gradle.ide.visualstudio.tasks`__ Task classes for visual studio.
   - `org.gradle.ide.xcode`__ Model classes for XCode.
   - `org.gradle.ide.xcode.plugins`__ Plugins for XCode integration.
   - `org.gradle.ide.xcode.tasks`__ Task classes for XCode.
   - `org.gradle.ivy`__ Component types for Ivy modules.
   - `org.gradle.jvm`__ Types for support of JVM runtime.
   - `org.gradle.jvm.application.scripts`__ Classes that enable JVM application script generation.
   - `org.gradle.jvm.application.tasks`__ Tasks for the JVM application plugin.
   - `org.gradle.jvm.tasks`__ Tasks that add support for JVM runtime.
   - `org.gradle.jvm.toolchain`__ Defines tools that can build things that run on the JVM.
   - `org.gradle.language`__ Model classes for managing language sources.
   - `org.gradle.language.assembler`__ Model classes for building from Assembler language sources.
   - `org.gradle.language.assembler.plugins`__ Plugins for building from Assembler language sources.
   - `org.gradle.language.assembler.tasks`__ Tasks for assembling Assembler sources for a native runtime.
   - `org.gradle.language.base`__ General purpose types for language support.
   - `org.gradle.language.base.artifact`__ Classes representing artifacts relevant to languages in general.
   - `org.gradle.language.base.compile`__ General purpose types for related to compiling.
   - `org.gradle.language.base.plugins`__ Base plugins for language support.
   - `org.gradle.language.base.sources`__ General purpose types for language sources support.
   - `org.gradle.language.c`__ Model classes for building from C language sources.
   - `org.gradle.language.c.plugins`__ Plugins for building from C language sources.
   - `org.gradle.language.c.tasks`__ Tasks for compiling C sources for a native runtime.
   - `org.gradle.language.cpp`__ Model classes for building from C++ language sources.
   - `org.gradle.language.cpp.plugins`__ Plugins for building from C++ language sources.
   - `org.gradle.language.cpp.tasks`__ Tasks for compiling C++ sources for a native runtime.
   - `org.gradle.language.java.artifact`__ Classes representing artifacts relevant to the Java language.
   - `org.gradle.language.jvm.tasks`__ Tasks for support for JVM languages.
   - `org.gradle.language.nativeplatform`__
   - `org.gradle.language.nativeplatform.tasks`__ Base classes for native language compile tasks.
   - `org.gradle.language.objectivec`__ Model classes for building from Objective-C language sources.
   - `org.gradle.language.objectivec.plugins`__ Plugins for building from Objective-C language sources.
   - `org.gradle.language.objectivec.tasks`__ Tasks for compiling Objective-C sources for a native runtime.
   - `org.gradle.language.objectivecpp`__ Model classes for building from Objective-C++ language sources.
   - `org.gradle.language.objectivecpp.plugins`__ Plugins for building from Objective-C++ language sources.
   - `org.gradle.language.objectivecpp.tasks`__ Tasks for compiling Objective-C++ sources for a native runtime.
   - `org.gradle.language.plugins`__ Base plugins for the native languages.
   - `org.gradle.language.rc`__ Model classes for building from Windows Resource scripts.
   - `org.gradle.language.rc.plugins`__ Plugins for building from Windows Resource scripts.
   - `org.gradle.language.rc.tasks`__ Tasks for compiling Windows resources for a native runtime.
   - `org.gradle.language.scala.tasks`__ Tasks that add support for Scala language.
   - `org.gradle.language.swift`__ Model classes for building from Swift language sources.
   - `org.gradle.language.swift.plugins`__ Plugins for building from Swift language sources.
   - `org.gradle.language.swift.tasks`__ Tasks for compiling Swift sources for a native runtime.
   - `org.gradle.maven`__ Component types for Maven modules.
   - `org.gradle.model`__ Classes that operate upon the Gradle model.
   - `org.gradle.nativeplatform`__ Classes that model aspects of native component projects.
   - `org.gradle.nativeplatform.platform`__ Classes that allow defining a native binary platform.
   - `org.gradle.nativeplatform.plugins`__ Plugins for building native component projects.
   - `org.gradle.nativeplatform.tasks`__ Tasks for building native component projects.
   - `org.gradle.nativeplatform.test`__ API classes for testing native binaries.
   - `org.gradle.nativeplatform.test.cpp`__ API classes for C++ test integration.
   - `org.gradle.nativeplatform.test.cpp.plugins`__ Plugins for C++ test integration.
   - `org.gradle.nativeplatform.test.cunit`__ API classes for cunit integration.
   - `org.gradle.nativeplatform.test.cunit.plugins`__ Plugins for cunit testing.
   - `org.gradle.nativeplatform.test.cunit.tasks`__ Tasks for cunit integration.
   - `org.gradle.nativeplatform.test.googletest`__ API classes for Google Test integration.
   - `org.gradle.nativeplatform.test.googletest.plugins`__ Plugins for Google Test testing.
   - `org.gradle.nativeplatform.test.plugins`__ Plugin classes for generic support for testing native binaries.
   - `org.gradle.nativeplatform.test.tasks`__ Tasks for test execution.
   - `org.gradle.nativeplatform.test.xctest`__ Model classes for the XCTest plugins.
   - `org.gradle.nativeplatform.test.xctest.plugins`__ Plugins for XCTest testing.
   - `org.gradle.nativeplatform.test.xctest.tasks`__ Tasks for XCTest execution.
   - `org.gradle.nativeplatform.toolchain`__ Classes that allow C++ tool chains to be configured.
   - `org.gradle.nativeplatform.toolchain.plugins`__ Built-in tool chain support.
   - `org.gradle.normalization`__ Interfaces and API for input normalization.
   - `org.gradle.platform`__ Types to define build environment.
   - `org.gradle.platform.base`__ General purpose types for runtime support.
   - `org.gradle.platform.base.binary`__ General purpose types for binary support.
   - `org.gradle.platform.base.component`__ General purpose types for library support.
   - `org.gradle.platform.base.plugins`__ Base plugins for software model support.
   - `org.gradle.plugin.devel`__ Classes for assisting with plugin development.
   - `org.gradle.plugin.devel.plugins`__ Plugins for assisting with plugin development.
   - `org.gradle.plugin.devel.tasks`__ Tasks for assisting with plugin development.
   - `org.gradle.plugin.management`__ APIs to influence how plugins are resolved.
   - `org.gradle.plugin.use`__ Classes for managing plugin resolution and use.
   - `org.gradle.plugins.ear`__ Support for generating EAR archives in a Gradle build
   - `org.gradle.plugins.ear.descriptor`__ Classes for working with EAR deployment descriptors.
   - `org.gradle.plugins.ide`__ General purpose IDE types.
   - `org.gradle.plugins.ide.api`__ General ide plugin api.
   - `org.gradle.plugins.ide.eclipse`__ A `org.gradle.api.Plugin`__ for generating Eclipse files.
   - `org.gradle.plugins.ide.eclipse.model`__ Classes for the model used by the eclipse plugins.
   - `org.gradle.plugins.ide.idea`__
   - `org.gradle.plugins.ide.idea.model`__
   - `org.gradle.plugins.signing`__ The signing plugin.
   - `org.gradle.plugins.signing.signatory`__
   - `org.gradle.plugins.signing.signatory.pgp`__
   - `org.gradle.plugins.signing.type`__ The signing plugin signature types.
   - `org.gradle.plugins.signing.type.pgp`__ PGP signing support.
   - `org.gradle.process`__ Classes for executing system and Java processes.
   - `org.gradle.swiftpm`__ Model classes that describe a Swift Package Manager package.
   - `org.gradle.swiftpm.plugins`__ Plugins that produce Swift Package Manager manifests 
      from the Gradle model.
   - `org.gradle.swiftpm.tasks`__ Tasks that produce Swift Package Manager manifests 
      from the Gradle model.
   - `org.gradle.testfixtures`__
   - `org.gradle.testing.base`__ General purpose types for test suite support.
   - `org.gradle.testing.base.plugins`__
   - `org.gradle.testing.jacoco.plugins`__ Plugins to work with the JaCoCo code coverage library.
   - `org.gradle.testing.jacoco.tasks`__ Tasks to work with the JaCoCo code coverage library.
   - `org.gradle.testing.jacoco.tasks.rules`__ Implementations for Jacoco code coverage rules.
   - `org.gradle.testkit.runner`__ Support for executing contrived Gradle builds for the 
      purpose of testing build logic.
   - `org.gradle.tooling`__ The main interfaces and classes of the Gradle tooling API.
   - `org.gradle.tooling.events`__ The interfaces and classes related to registering for event notifications and listening to dispatched events.
   - `org.gradle.tooling.events.configuration`__ Project configuration specific interfaces and classes related to event notifications.
   - `org.gradle.tooling.events.download`__ File download specific interfaces and classes related to event notifications.
   - `org.gradle.tooling.events.lifecycle`__ Build lifecycle interfaces and classes related to event notifications.
   - `org.gradle.tooling.events.problems`__ Problem specific interfaces and classes related to event notifications.
   - `org.gradle.tooling.events.task`__ Task execution specific interfaces and classes related to event notifications.
   - `org.gradle.tooling.events.task.java`__ Task execution result interfaces specific to Java projects.
   - `org.gradle.tooling.events.test`__ Test execution specific interfaces and classes related to event notifications.
   - `org.gradle.tooling.events.transform`__ Artifact transform execution specific interfaces and classes related to event notifications.
   - `org.gradle.tooling.events.work`__ Work item execution specific interfaces and classes related to event notifications.
   - `org.gradle.tooling.exceptions`__ Exceptions thrown when using the tooling API.
   - `org.gradle.tooling.model`__ The general-purpose tooling model types, provided by the tooling API.
   - `org.gradle.tooling.model.build`__ Tooling models for the build environment, 
      which includes information such as Gradle or Java versions.
   - `org.gradle.tooling.model.cpp`__ Types that represent the tooling model for C++ projects.
   - `org.gradle.tooling.model.eclipse`__ Eclipse-centric tooling models.
   - `org.gradle.tooling.model.gradle`__ The tooling models for Gradle builds and projects.
   - `org.gradle.tooling.model.idea`__ IntelliJ IDEA centric tooling models.
   - `org.gradle.tooling.model.java`__ Java-specific details for tooling models.
   - `org.gradle.tooling.model.kotlin.dsl`__ Kotlin DSL related tooling models.
   - `org.gradle.tooling.provider.model`__ Interfaces and classes that allow tooling models 
      to be made available to the tooling API client.
   - `org.gradle.util`__
   - `org.gradle.vcs`__ Packages for version control systems.
   - `org.gradle.vcs.git`__ The API for dealing with Version Control Systems in Gradle.
   - `org.gradle.work`__ Classes used for implementing units of work.
   - `org.gradle.workers`__ Workers allow running pieces of work in the background, 
      either in-process in isolated classloaders or out-of-process in reusable daemons.

.. _org.gradle: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle/index.html
.. _org.gradle.api: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api/index.html
.. _org.gradle.api.artifacts: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.artifacts/index.html
.. _org.gradle.api.artifacts.component: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.artifacts.component/index.html
.. _org.gradle.api.artifacts.dsl: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.artifacts.dsl/index.html
.. _org.gradle.api.artifacts.ivy: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.artifacts.ivy/index.html
.. _org.gradle.api.artifacts.maven: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.artifacts.maven/index.html
.. _org.gradle.api.artifacts.query: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.artifacts.query/index.html
.. _org.gradle.api.artifacts.repositories: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.artifacts.repositories/index.html
.. _org.gradle.api.artifacts.result: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.artifacts.result/index.html
.. _org.gradle.api.artifacts.transform: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.artifacts.transform/index.html
.. _org.gradle.api.artifacts.type: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.artifacts.type/index.html
.. _org.gradle.api.artifacts.verification: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.artifacts.verification/index.html
.. _org.gradle.api.attributes: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.attributes/index.html
.. _org.gradle.api.attributes.java: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.attributes.java/index.html
.. _org.gradle.api.attributes.plugin: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.attributes.plugin/index.html
.. _org.gradle.api.cache: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.cache/index.html
.. _org.gradle.api.capabilities: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.capabilities/index.html
.. _org.gradle.api.component: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.component/index.html
.. _org.gradle.api.configuration: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.configuration/index.html
.. _org.gradle.api.credentials: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.credentials/index.html
.. _org.gradle.api.distribution: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.distribution/index.html
.. _org.gradle.api.distribution.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.distribution.plugins/index.html
.. _org.gradle.api.execution: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.execution/index.html
.. _org.gradle.api.file: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.file/index.html
.. _org.gradle.api.flow: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.flow/index.html
.. _org.gradle.api.initialization: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.initialization/index.html
.. _org.gradle.api.initialization.definition: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.initialization.definition/index.html
.. _org.gradle.api.initialization.dsl: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.initialization.dsl/index.html
.. _org.gradle.api.initialization.resolve: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.initialization.resolve/index.html
.. _org.gradle.api.invocation: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.invocation/index.html
.. _org.gradle.api.java.archives: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.java.archives/index.html
.. _org.gradle.api.jvm: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.jvm/index.html
.. _org.gradle.api.launcher.cli: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.launcher.cli/index.html
.. _org.gradle.api.logging: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.logging/index.html
.. _org.gradle.api.logging.configuration: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.logging.configuration/index.html
.. _org.gradle.api.model: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.model/index.html
.. _org.gradle.api.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.plugins/index.html
.. _org.gradle.api.Plugin: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api/-plugin/index.html
.. _org.gradle.api.plugins.antlr: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.plugins.antlr/index.html
.. _org.gradle.api.plugins.catalog: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.plugins.catalog/index.html
.. _org.gradle.api.plugins.jvm: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.plugins.jvm/index.html
.. _org.gradle.api.plugins.quality: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.plugins.quality/index.html
.. _org.gradle.api.plugins.scala: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.plugins.scala/index.html
.. _org.gradle.api.problems: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.problems/index.html
.. _org.gradle.api.provider: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.provider/index.html
.. _org.gradle.api.publish: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.publish/index.html
.. _org.gradle.api.publish.ivy: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.publish.ivy/index.html
.. _org.gradle.api.publish.ivy.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.publish.ivy.plugins/index.html
.. _org.gradle.api.publish.ivy.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.publish.ivy.tasks/index.html
.. _org.gradle.api.publish.maven: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.publish.maven/index.html
.. _org.gradle.api.publish.maven.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.publish.maven.plugins/index.html
.. _org.gradle.api.publish.maven.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.publish.maven.tasks/index.html
.. _org.gradle.api.publish.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.publish.plugins/index.html
.. _org.gradle.api.publish.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.publish.tasks/index.html
.. _org.gradle.api.reflect: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.reflect/index.html
.. _org.gradle.api.reporting: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.reporting/index.html
.. _org.gradle.api.reporting.components: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.reporting.components/index.html
.. _org.gradle.api.reporting.dependencies: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.reporting.dependencies/index.html
.. _org.gradle.api.reporting.dependents: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.reporting.dependents/index.html
.. _org.gradle.api.reporting.model: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.reporting.model/index.html
.. _org.gradle.api.reporting.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.reporting.plugins/index.html
.. _org.gradle.api.resources: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.resources/index.html
.. _org.gradle.api.services: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.services/index.html
.. _org.gradle.api.specs: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.specs/index.html
.. _org.gradle.api.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.tasks/index.html
.. _gradle.api.Task: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api/-task/index.html
.. _org.gradle.api.tasks.ant: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.tasks.ant/index.html
.. _org.gradle.api.tasks.application: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.tasks.application/index.html
.. _org.gradle.api.tasks.bundling: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.tasks.bundling/index.html
.. _org.gradle.api.tasks.compile: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.tasks.compile/index.html
.. _org.gradle.api.tasks.diagnostics: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.tasks.diagnostics/index.html
.. _org.gradle.api.tasks.diagnostics.configurations: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.tasks.diagnostics.configurations/index.html
.. _org.gradle.api.tasks.incremental: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.tasks.incremental/index.html
.. _org.gradle.api.tasks.javadoc: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.tasks.javadoc/index.html
.. _org.gradle.api.tasks.options: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.tasks.options/index.html
.. _org.gradle.api.tasks.scala: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.tasks.scala/index.html
.. _org.gradle.api.tasks.testing: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.tasks.testing/index.html
.. _org.gradle.api.tasks.testing.junit: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.tasks.testing.junit/index.html
.. _org.gradle.api.tasks.testing.junitplatform: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.tasks.testing.junitplatform/index.html
.. _org.gradle.api.tasks.testing.logging: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.tasks.testing.logging/index.html
.. _org.gradle.api.tasks.testing.testng: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.tasks.testing.testng/index.html
.. _org.gradle.api.tasks.util: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.tasks.util/index.html
.. _org.gradle.api.tasks.wrapper: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.tasks.wrapper/index.html
.. _org.gradle.api.toolchain.management: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.toolchain.management/index.html
.. _org.gradle.authentication: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.authentication/index.html
.. _org.gradle.authentication.aws: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.authentication.aws/index.html
.. _org.gradle.authentication.http: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.authentication.http/index.html
.. _org.gradle.build.event: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.build.event/index.html
.. _org.gradle.buildinit: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.buildinit/index.html
.. _org.gradle.buildinit.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.buildinit.plugins/index.html
.. _org.gradle.buildinit.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.buildinit.tasks/index.html
.. _org.gradle.caching: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.caching/index.html
.. _org.gradle.caching.configuration: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.caching.configuration/index.html
.. _org.gradle.caching.http: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.caching.http/index.html
.. _org.gradle.caching.local: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.caching.local/index.html
.. _org.gradle.concurrent: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.concurrent/index.html
.. _org.gradle.external.javadoc: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.external.javadoc/index.html
.. _org.gradle.ide.visualstudio: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.ide.visualstudio/index.html
.. _org.gradle.ide.visualstudio.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.ide.visualstudio.plugins/index.html
.. _org.gradle.ide.visualstudio.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.ide.visualstudio.tasks/index.html
.. _org.gradle.ide.xcode: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.ide.xcode/index.html
.. _org.gradle.ide.xcode.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.ide.xcode.plugins/index.html
.. _org.gradle.ide.xcode.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.ide.xcode.tasks/index.html
.. _org.gradle.ivy: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.ivy/index.html
.. _org.gradle.jvm: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.jvm/index.html
.. _org.gradle.jvm.application.scripts: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.jvm.application.scripts/index.html
.. _org.gradle.jvm.application.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.jvm.application.tasks/index.html
.. _org.gradle.jvm.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.jvm.tasks/index.html
.. _org.gradle.jvm.toolchain: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.jvm.toolchain/index.html
.. _org.gradle.kotlin.dsl: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.kotlin.dsl/index.html
.. _org.gradle.kotlin.dsl.precompile: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.kotlin.dsl.precompile/index.html
.. _org.gradle.language: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language/index.html
.. _org.gradle.language.assembler: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.assembler/index.html
.. _org.gradle.language.assembler.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.assembler.plugins/index.html
.. _org.gradle.language.assembler.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.assembler.tasks/index.html
.. _org.gradle.language.base: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.base/index.html
.. _org.gradle.language.base.artifact: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.base.artifact/index.html
.. _org.gradle.language.base.compile: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.base.compile/index.html
.. _org.gradle.language.base.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.base.plugins/index.html
.. _org.gradle.language.base.sources: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.base.sources/index.html
.. _org.gradle.language.c: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.c/index.html
.. _org.gradle.language.c.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.c.plugins/index.html
.. _org.gradle.language.c.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.c.tasks/index.html
.. _org.gradle.language.cpp: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.cpp/index.html
.. _org.gradle.language.cpp.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.cpp.plugins/index.html
.. _org.gradle.language.cpp.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.cpp.tasks/index.html
.. _org.gradle.language.java.artifact: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.java.artifact/index.html
.. _org.gradle.language.jvm.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.jvm.tasks/index.html
.. _org.gradle.language.nativeplatform: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.nativeplatform/index.html
.. _org.gradle.language.nativeplatform.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.nativeplatform.tasks/index.html
.. _org.gradle.language.objectivec: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.objectivec/index.html
.. _org.gradle.language.objectivec.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.objectivec.plugins/index.html
.. _org.gradle.language.objectivec.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.objectivec.tasks/index.html
.. _org.gradle.language.objectivecpp: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.objectivecpp/index.html
.. _org.gradle.language.objectivecpp.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.objectivecpp.plugins/index.html
.. _org.gradle.language.objectivecpp.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.objectivecpp.tasks/index.html
.. _org.gradle.language.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.plugins/index.html
.. _org.gradle.language.rc: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.rc/index.html
.. _org.gradle.language.rc.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.rc.plugins/index.html
.. _org.gradle.language.rc.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.rc.tasks/index.html
.. _org.gradle.language.scala.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.scala.tasks/index.html
.. _org.gradle.language.swift: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.swift/index.html
.. _org.gradle.language.swift.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.swift.plugins/index.html
.. _org.gradle.language.swift.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.language.swift.tasks/index.html
.. _org.gradle.maven: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.maven/index.html
.. _org.gradle.model: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.model/index.html
.. _org.gradle.nativeplatform: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.nativeplatform/index.html
.. _org.gradle.nativeplatform.platform: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.nativeplatform.platform/index.html
.. _org.gradle.nativeplatform.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.nativeplatform.plugins/index.html
.. _org.gradle.nativeplatform.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.nativeplatform.tasks/index.html
.. _org.gradle.nativeplatform.test: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.nativeplatform.test/index.html
.. _org.gradle.nativeplatform.test.cpp: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.nativeplatform.test.cpp/index.html
.. _org.gradle.nativeplatform.test.cpp.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.nativeplatform.test.cpp.plugins/index.html
.. _org.gradle.nativeplatform.test.cunit: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.nativeplatform.test.cunit/index.html
.. _org.gradle.nativeplatform.test.cunit.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.nativeplatform.test.cunit.plugins/index.html
.. _org.gradle.nativeplatform.test.cunit.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.nativeplatform.test.cunit.tasks/index.html
.. _org.gradle.nativeplatform.test.googletest: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.nativeplatform.test.googletest/index.html
.. _org.gradle.nativeplatform.test.googletest.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.nativeplatform.test.googletest.plugins/index.html
.. _org.gradle.nativeplatform.test.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.nativeplatform.test.plugins/index.html
.. _org.gradle.nativeplatform.test.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.nativeplatform.test.tasks/index.html
.. _org.gradle.nativeplatform.test.xctest: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.nativeplatform.test.xctest/index.html
.. _org.gradle.nativeplatform.test.xctest.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.nativeplatform.test.xctest.plugins/index.html
.. _org.gradle.nativeplatform.test.xctest.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.nativeplatform.test.xctest.tasks/index.html
.. _org.gradle.nativeplatform.toolchain: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.nativeplatform.toolchain/index.html
.. _org.gradle.nativeplatform.toolchain.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.nativeplatform.toolchain.plugins/index.html
.. _org.gradle.normalization: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.normalization/index.html
.. _org.gradle.platform: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.platform/index.html
.. _org.gradle.platform.base: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.platform.base/index.html
.. _org.gradle.platform.base.binary: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.platform.base.binary/index.html
.. _org.gradle.platform.base.component: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.platform.base.component/index.html
.. _org.gradle.platform.base.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.platform.base.plugins/index.html
.. _org.gradle.plugin.devel: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.plugin.devel/index.html
.. _org.gradle.plugin.devel.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.plugin.devel.plugins/index.html
.. _org.gradle.plugin.devel.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.plugin.devel.tasks/index.html
.. _org.gradle.plugin.management: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.plugin.management/index.html
.. _org.gradle.plugin.use: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.plugin.use/index.html
.. _org.gradle.plugins.ear: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.plugins.ear/index.html
.. _org.gradle.plugins.ear.descriptor: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.plugins.ear.descriptor/index.html
.. _org.gradle.plugins.ide: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.plugins.ide/index.html
.. _org.gradle.plugins.ide.api: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.plugins.ide.api/index.html
.. _org.gradle.plugins.ide.eclipse: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.plugins.ide.eclipse/index.html
.. _org.gradle.plugins.ide.eclipse.model: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.plugins.ide.eclipse.model/index.html
.. _org.gradle.plugins.ide.idea: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.plugins.ide.idea/index.html
.. _org.gradle.plugins.ide.idea.model: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.plugins.ide.idea.model/index.html
.. _org.gradle.plugins.signing: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.plugins.signing/index.html
.. _org.gradle.plugins.signing.signatory: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.plugins.signing.signatory/index.html
.. _org.gradle.plugins.signing.signatory.pgp: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.plugins.signing.signatory.pgp/index.html
.. _org.gradle.plugins.signing.type: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.plugins.signing.type/index.html
.. _org.gradle.plugins.signing.type.pgp: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.plugins.signing.type.pgp/index.html
.. _org.gradle.process: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.process/index.html
.. _org.gradle.swiftpm: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.swiftpm/index.html
.. _org.gradle.swiftpm.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.swiftpm.plugins/index.html
.. _org.gradle.swiftpm.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.swiftpm.tasks/index.html
.. _org.gradle.testfixtures: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.testfixtures/index.html
.. _org.gradle.testing.base: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.testing.base/index.html
.. _org.gradle.testing.base.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.testing.base.plugins/index.html
.. _org.gradle.testing.jacoco.plugins: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.testing.jacoco.plugins/index.html
.. _org.gradle.testing.jacoco.tasks: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.testing.jacoco.tasks/index.html
.. _org.gradle.testing.jacoco.tasks.rules: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.testing.jacoco.tasks.rules/index.html
.. _org.gradle.testkit.runner: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.testkit.runner/index.html
.. _org.gradle.tooling: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.tooling/index.html
.. _org.gradle.tooling.events: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.tooling.events/index.html
.. _org.gradle.tooling.events.configuration: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.tooling.events.configuration/index.html
.. _org.gradle.tooling.events.download: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.tooling.events.download/index.html
.. _org.gradle.tooling.events.lifecycle: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.tooling.events.lifecycle/index.html
.. _org.gradle.tooling.events.problems: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.tooling.events.problems/index.html
.. _org.gradle.tooling.events.task: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.tooling.events.task/index.html
.. _org.gradle.tooling.events.task.java: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.tooling.events.task.java/index.html
.. _org.gradle.tooling.events.test: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.tooling.events.test/index.html
.. _org.gradle.tooling.events.transform: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.tooling.events.transform/index.html
.. _org.gradle.tooling.events.work: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.tooling.events.work/index.html
.. _org.gradle.tooling.exceptions: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.tooling.exceptions/index.html
.. _org.gradle.tooling.model: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.tooling.model/index.html
.. _org.gradle.tooling.model.build: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.tooling.model.build/index.html
.. _org.gradle.tooling.model.cpp: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.tooling.model.cpp/index.html
.. _org.gradle.tooling.model.eclipse: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.tooling.model.eclipse/index.html
.. _org.gradle.tooling.model.gradle: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.tooling.model.gradle/index.html
.. _org.gradle.tooling.model.idea: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.tooling.model.idea/index.html
.. _org.gradle.tooling.model.java: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.tooling.model.java/index.html
.. _org.gradle.tooling.model.kotlin.dsl: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.tooling.model.kotlin.dsl/index.html
.. _org.gradle.tooling.provider.model: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.tooling.provider.model/index.html
.. _org.gradle.util: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.util/index.html
.. _org.gradle.vcs: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.vcs/index.html
.. _org.gradle.vcs.git: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.vcs.git/index.html
.. _org.gradle.work: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.work/index.html
.. _org.gradle.workers: https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.workers/index.html

 /Samples
 ========
 `Samples <https://docs.gradle.org/current/samples/index.html>`__

.. container:: chapter

   .. rubric:: Sample Index
      :name: sample-index

      version 8.7

   .. container:: toc
      :name: toc

      Contents

      -  `Android <#android>`__
      -  `Build organization <#build_organization>`__
      -  `C++ <#c>`__
      -  `Groovy <#groovy>`__
      -  `IDE integration <#ide_integration>`__
      -  `Java <#java>`__
      -  `Java Modules <#java_modules>`__
      -  `Kotlin <#kotlin>`__
      -  `Scala <#scala>`__
      -  `Spring <#spring>`__
      -  `Swift <#swift>`__
      -  `Using Credentials <#using_credentials>`__
      -  `Writing Custom Tasks <#writing_custom_tasks>`__

   .. container:: sect1

      .. rubric:: `Android <#android>`__
         :name: android

         -  `Building Android Apps <https://docs.gradle.org/current/samples/sample_building_android_apps.html>`__:
            Build a simple Android app.

   .. container:: sect1

      .. rubric:: `Build organization <#build_organization>`__
         :name: build_organization

         -  `Composite Builds Basics <https://docs.gradle.org/current/samples/sample_composite_builds_basics.html>`__:
            Defining and using a composite build

         -  `Composite Builds Declared Substitutions <https://docs.gradle.org/current/samples/sample_composite_builds_declared_substitutions.html>`__:
            Applying and testing changes in downstream
            dependencies without publishing.

         -  `Composite Builds Hierarchical Multirepo <https://docs.gradle.org/current/samples/sample_composite_builds_hierarchical_multirepo.html>`__:
            Defining and using a composite build to
            combine multiple independent builds.

         -  `Composite Builds Plugin Development <https://docs.gradle.org/current/samples/sample_composite_builds_plugin_development.html>`__:
            Developing a Gradle plugin in a build without
            publishing.

         -  `Gradle Plugin <https://docs.gradle.org/current/samples/sample_gradle_plugin.html>`__:
            Organize your build logic into a Gradle
            plugin written in Java.

         -  `Sharing build logic between subprojects <https://docs.gradle.org/current/samples/sample_convention_plugins.html>`__:
            Organize build logic into reusable pieces

         -  `Sharing build logic in a multi-repo setup <https://docs.gradle.org/current/samples/sample_publishing_convention_plugins.html>`__:
            Organize and publish build logic for reuse in
            other projects

         -  `Sharing convention plugins with build logic build <https://docs.gradle.org/current/samples/sample_sharing_convention_plugins_with_build_logic.html>`__:
            Reuse convention plugins in both main build
            and build logic build

         -  `Sharing task outputs across projects in a multi-project build <https://docs.gradle.org/current/samples/sample_cross_project_output_sharing.html>`__:
            Sharing a file made by a task in one Gradle
            project, with a task in another Gradle
            project.

         -  `Structuring Software Projects <https://docs.gradle.org/current/samples/sample_structuring_software_projects.html>`__:
            Structuring a software product project with
            Gradle

   .. container:: sect1

      .. rubric:: `C++ <#c>`__
         :name: c

         -  `Building C++ Applications <https://docs.gradle.org/current/samples/sample_building_cpp_applications.html>`__:
            Setup a C++ application project step-by-step.

         -  `Building C++ Libraries <https://docs.gradle.org/current/samples/sample_building_cpp_libraries.html>`__:
            Setup a C++ library project step-by-step.

   .. container:: sect1

      .. rubric:: `Groovy <#groovy>`__
         :name: groovy

         -  `Building Groovy Applications <https://docs.gradle.org/current/samples/sample_building_groovy_applications.html>`__:
            Setup a Groovy application project
            step-by-step.

         -  `Building Groovy Applications with libraries <https://docs.gradle.org/current/samples/sample_building_groovy_applications_multi_project.html>`__:
            Setup a Groovy application project with
            libraries step-by-step.

         -  `Building Groovy Libraries <https://docs.gradle.org/current/samples/sample_building_groovy_libraries.html>`__:
            Setup a Groovy library project step-by-step.

         -  `Publishing Groovy Libraries <https://docs.gradle.org/current/samples/sample_publishing_groovy_libraries.html>`__:
            Publish a Groovy library to a binary
            repository.

   .. container:: sect1

      .. rubric:: `IDE integration <#ide_integration>`__
         :name: ide_integration

         -  `Reporting and receiving problems via the Problems API <https://docs.gradle.org/current/samples/sample_problems_api_usage.html>`__:
            Reporting problems from plugins and consuming
            it in IDE integrations

   .. container:: sect1

      .. rubric:: `Java <#java>`__
         :name: java

         -  `Aggregating code coverage with JaCoCo from an application/distribution (Incubating) <https://docs.gradle.org/current/samples/sample_jvm_multi_project_with_code_coverage_distribution.html>`__:
            Report code coverage on the
            application/distribution of a multi-module
            project using
            `JaCoCo <https://www.jacoco.org/jacoco/>`__.

         -  `Aggregating code coverage with JaCoCo using a standalone utility project (Incubating) <https://docs.gradle.org/current/samples/sample_jvm_multi_project_with_code_coverage_standalone.html>`__:
            Report code coverage on a multi-module
            project using
            `JaCoCo <https://www.jacoco.org/jacoco/>`__.

         -  `Aggregating test results of an application/distribution (Incubating) <https://docs.gradle.org/current/samples/sample_jvm_multi_project_with_test_aggregation_distribution.html>`__:
            Report all test results using the
            application/distribution of a multi-module
            project.

         -  `Aggregating test results using a standalone utility project (Incubating) <https://docs.gradle.org/current/samples/sample_jvm_multi_project_with_test_aggregation_standalone.html>`__:
            Report all test results using a standalone
            utility project as part of a multi-module
            project.

         -  `Building Java Applications <https://docs.gradle.org/current/samples/sample_building_java_applications.html>`__:
            Setup a Java application project
            step-by-step.

         -  `Building Java Applications with libraries <https://docs.gradle.org/current/samples/sample_building_java_applications_multi_project.html>`__:
            Setup a Java application project with
            libraries step-by-step.

         -  `Building Java Libraries <https://docs.gradle.org/current/samples/sample_building_java_libraries.html>`__:
            Setup a Java library project step-by-step.

         -  `Publishing Java Libraries <https://docs.gradle.org/current/samples/sample_publishing_java_libraries.html>`__:
            Publish a Java library to a binary
            repository.

         -  `Sharing build logic in a multi-repo setup with Test Suites (Incubating) <https://docs.gradle.org/current/samples/sample_incubating_publishing_convention_plugins.html>`__:
            Organize and publish build logic for reuse in
            other projects using the new Test Suites API.

         -  `Using additional test types <https://docs.gradle.org/current/samples/sample_jvm_multi_project_with_additional_test_types.html>`__:
            Add an additional test type (e.g. integration
            tests) to a project.

         -  `Using additional test types with Test Suites (Incubating) <https://docs.gradle.org/current/samples/sample_incubating_jvm_multi_project_with_additional_test_types.html>`__:
            Add an additional test type (e.g. integration
            tests) to a project using the new Test Suites
            API.

         -  `Using toolchains <https://docs.gradle.org/current/samples/sample_jvm_multi_project_with_toolchains.html>`__:
            Use toolchains to configure the JVM to use
            for compilation and testing.

   .. container:: sect1

      .. rubric:: `Java Modules <#java_modules>`__
         :name: java_modules

         -  `Building Java Modules <https://docs.gradle.org/current/samples/sample_java_modules_multi_project.html>`__:
            Build Java Modules and a modular Java
            application.

         -  `Building Java Modules with Blackbox Tests <https://docs.gradle.org/current/samples/sample_java_modules_multi_project_with_integration_tests.html>`__:
            Build Java Modules with blackbox integration
            tests.

         -  `Building Java Modules with Blackbox Tests with Test Suites (Incubating) <https://docs.gradle.org/current/samples/sample_incubating_java_modules_multi_project_with_integration_tests.html>`__:
            Build Java Modules with blackbox integration
            tests using the new Test Suites API.

         -  `Building Java Modules with Legacy Libraries <https://docs.gradle.org/current/samples/sample_java_modules_with_transform.html>`__:
            Build a modular Java application that
            integrates legacy libraries.

   .. container:: sect1

      .. rubric:: `Kotlin <#kotlin>`__
         :name: kotlin

         -  `Building Kotlin Applications <https://docs.gradle.org/current/samples/sample_building_kotlin_applications.html>`__:
            Setup a Kotlin application project
            step-by-step.

         -  `Building Kotlin Applications with libraries <https://docs.gradle.org/current/samples/sample_building_kotlin_applications_multi_project.html>`__:
            Setup a Kotlin application project with
            libraries step-by-step.

         -  `Building Kotlin Libraries <https://docs.gradle.org/current/samples/sample_building_kotlin_libraries.html>`__:
            Setup a Kotlin library project step-by-step.

   .. container:: sect1

      .. rubric:: `Scala <#scala>`__
         :name: scala

         -  `Building Scala Applications <https://docs.gradle.org/current/samples/sample_building_scala_applications.html>`__:
            Setup a Scala application project
            step-by-step.

         -  `Building Scala Applications with libraries <https://docs.gradle.org/current/samples/sample_building_scala_applications_multi_project.html>`__:
            Setup a Scala application project with
            libraries step-by-step.

         -  `Building Scala Libraries <https://docs.gradle.org/current/samples/sample_building_scala_libraries.html>`__:
            Setup a Scala library project step-by-step.

   .. container:: sect1

      .. rubric:: `Spring <#spring>`__
         :name: spring

         -  `Building Spring Boot Web Applications <https://docs.gradle.org/current/samples/sample_building_spring_boot_web_applications.html>`__:
            Build a simple Spring Boot application.

   .. container:: sect1

      .. rubric:: `Swift <#swift>`__
         :name: swift

         -  `Building Swift Applications <https://docs.gradle.org/current/samples/sample_building_swift_applications.html>`__:
            Setup a Swift application project
            step-by-step.

         -  `Building Swift Libraries <https://docs.gradle.org/current/samples/sample_building_swift_libraries.html>`__:
            Setup a Swift library project step-by-step.

   .. container:: sect1

      .. rubric:: `Using Credentials <#using_credentials>`__
         :name: using_credentials

         -  `Publishing Credentials <https://docs.gradle.org/current/samples/sample_publishing_credentials.html>`__:
            Publish to a password protected repository

         -  `Supply credentials to external tool <https://docs.gradle.org/current/samples/sample_credentials_for_external_tool_via_stdin.html>`__:
            Pass credentials to an external tool via
            stdin using Gradle properties.

   .. container:: sect1

      .. rubric:: `Writing Custom Tasks <#writing_custom_tasks>`__
         :name: writing_custom_tasks

         -  `Implementing Tasks with Command-line Arguments <https://docs.gradle.org/current/samples/sample_task_with_arguments.html>`__:
            Pass arguments to a custom task.

         -  `Implementing tasks with dependency resolution result inputs <https://docs.gradle.org/current/samples/sample_tasks_with_dependency_resolution_result_inputs.html>`__:
            Consume dependency resolution result inputs
            in tasks.



/Topic: 游댯 Gradle Plugin Reference
====================================


/docs/userguide/core-plugins/plugin_reference.adoc
==================================================

.. code-block::

   = Gradle Plugin Reference
   
   This page contains links and short descriptions for all the core plugins provided by Gradle itself.
   
   == JVM languages and frameworks
   
   <<java_plugin.adoc#java_plugin,Java>>::
   Provides support for building any type of Java project.
   
   <<java_library_plugin.adoc#java_library_plugin,Java Library>>::
   Provides support for building a Java library.
   
   <<java_platform_plugin.adoc#java_platform_plugin,Java Platform>>::
   Provides support for building a Java platform.
   
   <<groovy_plugin.adoc#groovy_plugin,Groovy>>::
   Provides support for building any type of https://groovy-lang.org/[Groovy] project.
   
   <<scala_plugin.adoc#scala_plugin,Scala>>::
   Provides support for building any type of https://www.scala-lang.org/[Scala] project.
   
   <<antlr_plugin.adoc#antlr_plugin,ANTLR>>::
   Provides support for generating parsers using http://www.antlr.org/[ANTLR].
   
   <<jvm_test_suite_plugin.adoc#jvm_test_suite_plugin,JVM Test Suite>>::
   Provides support for modeling and configuring multiple test suite invocations.
   
   <<test_report_aggregation_plugin.adoc#test_report_aggregation_plugin,Test Report Aggregation>>::
   Aggregates the results of multiple link:{groovyDslPath}#[Test] task invocations (potentially spanning multiple Gradle projects) into a single HTML report.
   
   == Native languages
   
   <<cpp_application_plugin.adoc#cpp_application_plugin,C++ Application>>::
   Provides support for building C++ applications on Windows, Linux, and macOS.
   
   <<cpp_library_plugin.adoc#cpp_library_plugin,C++ Library>>::
   Provides support for building C++ libraries on Windows, Linux, and macOS.
   
   <<cpp_unit_test_plugin.adoc#cpp_unit_test_plugin,C++ Unit Test>>::
   Provides support for building and running C++ executable-based tests on Windows, Linux, and macOS.
   
   <<swift_application_plugin.adoc#swift_application_plugin,Swift Application>>::
   Provides support for building Swift applications on Linux and macOS.
   
   <<swift_library_plugin.adoc#swift_library_plugin,Swift Library>>::
   Provides support for building Swift libraries on Linux and macOS.
   
   <<xctest_plugin.adoc#xctest_plugin,XCTest>>::
   Provides support for building and running XCTest-based tests on Linux and macOS.
   
   == Packaging and distribution
   
   <<application_plugin.adoc#application_plugin,Application>>::
   Provides support for building JVM-based, runnable applications.
   
   <<war_plugin.adoc#war_plugin,WAR>>::
   Provides support for building and packaging WAR-based Java web applications.
   
   <<ear_plugin.adoc#ear_plugin,EAR>>::
   Provides support for building and packaging Java EE applications.
   
   <<publishing_maven.adoc#publishing_maven,Maven Publish>>::
   Provides support for <<publishing_setup.adoc#publishing_components,publishing artifacts>> to Maven-compatible repositories.
   
   <<publishing_ivy.adoc#publishing_ivy,Ivy Publish>>::
   Provides support for <<publishing_setup.adoc#publishing_components,publishing artifacts>> to Ivy-compatible repositories.
   
   <<distribution_plugin.adoc#distribution_plugin,Distribution>>::
   Makes it easy to create ZIP and tarball distributions of your project.
   
   <<java_library_distribution_plugin.adoc#java_library_distribution_plugin,Java Library Distribution>>::
   Provides support for creating a ZIP distribution of a Java library project that includes its runtime dependencies.
   
   == Code analysis
   
   <<checkstyle_plugin.adoc#checkstyle_plugin,Checkstyle>>::
   Performs quality checks on your project뗩 Java source files using https://checkstyle.org/index.html[Checkstyle] and generates associated reports.
   
   <<pmd_plugin.adoc#pmd_plugin,PMD>>::
   Performs quality checks on your project뗩 Java source files using http://pmd.github.io/[PMD] and generates associated reports.
   
   <<jacoco_plugin.adoc#jacoco_plugin,JaCoCo>>::
   Provides code coverage metrics for your Java project using http://www.eclemma.org/jacoco/[JaCoCo].
   
   <<jacoco_report_aggregation_plugin.adoc#jacoco_report_aggregation_plugin,JaCoCo Report Aggregation>>::
   Aggregates the results of multiple JaCoCo code coverage reports (potentially spanning multiple Gradle projects) into a single HTML report.
   
   <<codenarc_plugin.adoc#codenarc_plugin,CodeNarc>>::
   Performs quality checks on your Groovy source files using https://codenarc.org/[CodeNarc] and generates associated reports.
   
   == IDE integration
   
   <<eclipse_plugin.adoc#eclipse_plugin,Eclipse>>::
   Generates Eclipse project files for the build that can be opened by the IDE. This set of plugins can also be used to fine tune http://projects.eclipse.org/projects/tools.buildship[Buildship's] import process for Gradle builds.
   
   <<idea_plugin.adoc#idea_plugin,IntelliJ IDEA>>::
   Generates IDEA project files for the build that can be opened by the IDE. It can also be used to fine tune IDEA's import process for Gradle builds.
   
   <<visual_studio_plugin.adoc#visual_studio_plugin,Visual Studio>>::
   Generates Visual Studio solution and project files for build that can be opened by the IDE.
   
   <<xcode_plugin.adoc#xcode_plugin,Xcode>>::
   Generates Xcode workspace and project files for the build that can be opened by the IDE.
   
   == Utility
   
   <<base_plugin.adoc#base_plugin,Base>>::
   Provides common lifecycle tasks, such as `clean`, and other features common to most builds.
   
   <<build_init_plugin.adoc#build_init_plugin,Build Init>>::
   Generates a new Gradle build of a specified type, such as a Java library. It can also generate a build script from a Maven POM  see <<migrating_from_maven.adoc#migrating_from_maven,Migrating from Maven to Gradle>> for more details.
   
   <<signing_plugin.adoc#signing_plugin,Signing>>::
   Provides support for digitally signing generated files and artifacts.
   
   <<java_gradle_plugin.adoc#java_gradle_plugin,Plugin Development>>::
   Makes it easier to develop and publish a Gradle plugin.
   
   <<project_report_plugin.adoc#project_report_plugin,Project Report Plugin>>::
   Helps to generate reports containing useful information about your build.

/Section: 游릭 JVM languages and frameworks
===========================================


/docs/userguide/jvm/java_plugin.adoc
====================================

.. code-block::

   = The Java Plugin
   
   The Java plugin adds Java compilation along with testing and bundling capabilities to a project.
   It serves as the basis for many of the other JVM language Gradle plugins.
   You can find a comprehensive introduction and overview to the Java Plugin in the <<building_java_projects.adoc#building_java_projects,Building Java Projects>> chapter.
   
   [NOTE]
   ====
   As indicated above, this plugin adds basic building blocks for working with JVM projects.
   Its feature set has been superseded by other plugins, offering more features based on your project type.
   Instead of applying it directly to your project, you should look into the `java-library` or `application` plugins or one of the supported alternative JVM language.
   ====
   
   == Usage
   
   To use the Java plugin, include the following in your build script:
   
   .Using the Java plugin
   ====
   include::sample[dir="snippets/java/quickstart/kotlin", files="build.gradle.kts[tags=use-plugin]"]
   include::sample[dir="snippets/java/quickstart/groovy", files="build.gradle[tags=use-plugin]"]
   ====
   
   == Tasks
   
   The Java plugin adds a number of tasks to your project, as shown below.
   
   `compileJava`  link:{groovyDslPath}#[JavaCompile]::
   _Depends on_: All tasks which contribute to the compilation classpath, including `jar` tasks from projects that are on the classpath via project dependencies
   +
   Compiles production Java source files using the JDK compiler.
   
   `processResources`  link:{groovyDslPath}#[ProcessResources]::
   Copies production resources into the production resources directory.
   
   `classes`::
   _Depends on_: `compileJava`, `processResources`
   +
   This is an aggregate task that just depends on other tasks. Other plugins may attach additional compilation tasks to it.
   
   `compileTestJava`  link:{groovyDslPath}#[JavaCompile]::
   _Depends on_: `classes`, and all tasks that contribute to the test compilation classpath
   +
   Compiles test Java source files using the JDK compiler.
   
   `processTestResources`  link:{groovyDslPath}#[Copy]::
   Copies test resources into the test resources directory.
   
   `testClasses`::
   _Depends on_: `compileTestJava`, `processTestResources`
   +
   This is an aggregate task that just depends on other tasks. Other plugins may attach additional test compilation tasks to it.
   
   `jar`  link:{groovyDslPath}#[Jar]::
   _Depends on_: `classes`
   +
   Assembles the production JAR file, based on the classes and resources attached to the `main` source set.
   
   `javadoc`  link:{groovyDslPath}#[Javadoc]::
   _Depends on_: `classes`
   +
   Generates API documentation for the production Java source using Javadoc.
   
   `test`  link:{groovyDslPath}#[Test]::
   _Depends on_: `testClasses`, and all tasks which produce the test runtime classpath
   +
   Runs the unit tests using JUnit or TestNG.
   
   `clean`  link:{groovyDslPath}#[Delete]::
   Deletes the project build directory.
   
   `clean__TaskName__`  link:{groovyDslPath}#[Delete]::
   Deletes files created by the specified task. For example, `cleanJar` will delete the JAR file created by the `jar` task and `cleanTest` will delete the test results created by the `test` task.
   
   === SourceSet Tasks
   
   For each source set you add to the project, the Java plugin adds the following tasks:
   
   
   `compile__SourceSet__Java`  link:{groovyDslPath}#[JavaCompile]::
   _Depends on_: All tasks which contribute to the source set's compilation classpath
   +
   Compiles the given source set's Java source files using the JDK compiler.
   
   `process__SourceSet__Resources`  link:{groovyDslPath}#[Copy]::
   Copies the given source set's resources into the resources directory.
   
   `__sourceSet__Classes`  link:{groovyDslPath}#[Task]::
   _Depends on_: `compile__SourceSet__Java`, `process__SourceSet__Resources`
   +
   Prepares the given source set's classes and resources for packaging and execution. Some plugins may add additional compilation tasks for the source set.
   
   === Lifecycle Tasks
   
   The Java plugin attaches some of its tasks to the lifecycle tasks defined by the <<base_plugin.adoc#sec:base_tasks,Base Plugin>>  which the Java Plugin applies automatically  and it also adds a few other lifecycle tasks:
   
   `assemble`::
   _Depends on_: `jar`
   +
   Aggregate task that assembles all the archives in the project. This task is added by the Base Plugin.
   
   `check`::
   _Depends on_: `test`
   +
   Aggregate task that performs verification tasks, such as running the tests. Some plugins add their own verification tasks to `check`. You should also attach any custom `Test` tasks to this lifecycle task if you want them to execute for a full build. This task is added by the Base Plugin.
   
   `build`::
   _Depends on_: `check`, `assemble`
   +
   Aggregate tasks that performs a full build of the project. This task is added by the Base Plugin.
   
   `buildNeeded`::
   _Depends on_: `build`, and `buildNeeded` tasks in all projects that are dependencies in the `testRuntimeClasspath` configuration.
   +
   Performs a full build of the project and all projects it depends on.
   
   `buildDependents`::
   _Depends on_: `build`, and `buildDependents` tasks in all projects that have this project as a dependency in their `testRuntimeClasspath` configurations
   +
   Performs a full build of the project and all projects which depend upon it.
   
   `build__ConfigName__` 댹_task rule_::
   _Depends on_: all tasks that generate the artifacts attached to the named 댹_ConfigName_  configuration
   +
   Assembles the artifacts for the specified configuration. This rule is added by the Base Plugin.
   
   The following diagram shows the relationships between these tasks.
   
   .Java plugin - tasks
   image::javaPluginTasks.png[]
   
   == Project layout
   
   The Java plugin assumes the project layout shown below. None of these directories need to exist or have anything in them. The Java plugin will compile whatever it finds, and handles anything which is missing.
   
   include::javaProjectMainLayout.adoc[]
   
   include::javaProjectTestLayout.adoc[]
   
   include::javaProjectGenericLayout.adoc[]
   
   === Changing the project layout
   
   You configure the project layout by configuring the appropriate source set. This is discussed in more detail in the following sections. Here is a brief example which changes the main Java and resource source directories.
   
   .Custom Java source layout
   ====
   include::sample[dir="snippets/java/customizedLayout/kotlin", files="build.gradle.kts[tags=define-main]"]
   include::sample[dir="snippets/java/customizedLayout/groovy", files="build.gradle[tags=define-main]"]
   ====
   
   == Source sets
   
   The plugin adds the following <<building_java_projects.adoc#sec:java_source_sets,source sets>>:
   
   `main`::
   Contains the production source code of the project, which is compiled and assembled into a JAR.
   
   `test`::
   Contains your test source code, which is compiled and executed using JUnit or TestNG. These are typically unit tests, but you can include any test in this source set as long as they all share the same compilation and runtime classpaths.
   
   === Source set properties
   
   The following table lists some of the important properties of a source set. You can find more details in the API documentation for link:{groovyDslPath}#[SourceSet].
   
   `name` 댹(read-only) `String`::
   The name of the source set, used to identify it.
   
   `output` 댹(read-only) link:{groovyDslPath}#[SourceSetOutput]::
   The output files of the source set, containing its compiled classes and resources.
   
   `output.classesDirs` 댹(read-only) link:{javadocPath}#[FileCollection]::
   _Default value_: `layout.buildDirectory.dir("classes/java/$name")`, e.g. _build/classes/java/main_
   +
   The directories to generate the classes of this source set into. May contain directories for other JVM languages, e.g. _build/classes/kotlin/main_.
   
   `output.resourcesDir` 댹`File`::
   _Default value_: `layout.buildDirectory.dir("resources/$name")`, e.g. _build/resources/main_
   +
   The directory to generate the resources of this source set into.
   
   `compileClasspath` 댹맓ink:{javadocPath}#[FileCollection]::
   _Default value_: `${name}CompileClasspath` configuration
   +
   The classpath to use when compiling the source files of this source set.
   
   `annotationProcessorPath` 댹맓ink:{javadocPath}#[FileCollection]::
   _Default value_: `${name}AnnotationProcessor` configuration
   +
   The processor path to use when compiling the source files of this source set.
   
   `runtimeClasspath` 댹맓ink:{javadocPath}#[FileCollection]::
   _Default value_: `$output`, `${name}RuntimeClasspath` configuration
   +
   The classpath to use when executing the classes of this source set.
   
   `java` 댹(read-only) link:{groovyDslPath}#[SourceDirectorySet]::
   The Java source files of this source set. Contains only `.java` files found in the Java source directories, and excludes all other files.
   
   `java.srcDirs` 댹`Set&lt;File&gt;`::
   _Default value_: `src/$name/java`, e.g. _src/main/java_
   +
   The source directories containing the Java source files of this source set.  You can set this to any value that is described in <<working_with_files.adoc#sec:specifying_multiple_files,this section>>.
   
   `java.destinationDirectory` 댹`DirectoryProperty`::
   _Default value_: `layout.buildDirectory.dir("classes/java/$name")`, e.g. _build/classes/java/main_
   +
   The directory to generate compiled Java sources into. You can set this to any value that is described in <<working_with_files.adoc#sec:single_file_paths,this section>>.
   
   `resources` 댹(read-only) link:{groovyDslPath}#[SourceDirectorySet]::
   The resources of this source set. Contains only resources, and excludes any `.java` files found in the resource directories. Other plugins, such as the <<groovy_plugin.adoc#groovy_plugin,Groovy Plugin>>, exclude additional types of files from this collection.
   
   `resources.srcDirs` 댹`Set&lt;File&gt;`::
   _Default value_: `[src/$name/resources]`
   +
   The directories containing the resources of this source set. You can set this to any type of value that is described in <<working_with_files.adoc#sec:specifying_multiple_files,this section>>.
   
   `allJava` 댹(read-only) link:{groovyDslPath}#[SourceDirectorySet]::
   _Default value_: Same as `java` property
   +
   All Java files of this source set. Some plugins, such as the Groovy Plugin, add additional Java source files to this collection.
   
   `allSource` 댹(read-only) link:{groovyDslPath}#[SourceDirectorySet]::
   _Default value_: Sum of everything in the `resources` and `java` properties
   +
   All source files of this source set of any language. This includes all resource files and all Java source files. Some plugins, such as the Groovy Plugin, add additional source files to this collection.
   
   === Defining new source sets
   
   See the <<java_testing.adoc#sec:configuring_java_integration_tests,integration test example>> in the _Testing in Java & JVM projects_ chapter.
   
   === Some other simple source set examples
   
   Adding a JAR containing the classes of a source set:
   
   .Assembling a JAR for a source set
   ====
   include::sample[dir="snippets/java/sourceSets/kotlin", files="build.gradle.kts[tags=jar]"]
   include::sample[dir="snippets/java/sourceSets/groovy", files="build.gradle[tags=jar]"]
   ====
   
   Generating Javadoc for a source set:
   
   .Generating the Javadoc for a source set
   ====
   include::sample[dir="snippets/java/sourceSets/kotlin", files="build.gradle.kts[tags=javadoc]"]
   include::sample[dir="snippets/java/sourceSets/groovy", files="build.gradle[tags=javadoc]"]
   ====
   
   Adding a test suite to run the tests in a source set:
   
   .Running tests in a source set
   ====
   include::sample[dir="snippets/java/sourceSets/kotlin", files="build.gradle.kts[tags=test]"]
   include::sample[dir="snippets/java/sourceSets/groovy", files="build.gradle[tags=test]"]
   ====
   
   == Dependency management
   
   The Java plugin adds a number of <<declaring_dependencies.adoc#sec:what-are-dependency-configurations,dependency configurations>> to your project, as shown below.
   Tasks such as `compileJava` and `test` then use one or more of those configurations to get the corresponding files and use them, for example by placing them on a compilation or runtime classpath.
   
   === Dependency configurations
   
   For information on the `default` and `archives` configurations, please consult the
   <<base_plugin.adoc#sec:base_plugin_configurations,Base Plugin>> reference documentation.
   
   For information on the `api` or `compileOnlyApi` configurations, please consult the
   <<java_library_plugin.adoc#sec:java_library_separation, Java Library Plugin>> reference documentation and
   <<dependency_management_for_java_projects.adoc#dependency_management_for_java_projects, Dependency Management for Java Projects>>.
   
   `implementation`::
   Implementation only dependencies.
   
   `compileOnly`::
   Compile time only dependencies, not used at runtime.
   
   `compileClasspath` extends `compileOnly, implementation`::
   Compile classpath, used when compiling source. Used by task `compileJava`.
   
   `annotationProcessor`::
   Annotation processors used during compilation.
   
   `runtimeOnly`::
   Runtime only dependencies.
   
   `runtimeClasspath` extends `runtimeOnly, implementation`::
   Runtime classpath contains elements of the implementation, as well as runtime only elements.
   
   `testImplementation` extends `implementation`::
   Implementation only dependencies for tests.
   
   `testCompileOnly`::
   Additional dependencies only for compiling tests, not used at runtime.
   
   `testCompileClasspath` extends `testCompileOnly, testImplementation`::
   Test compile classpath, used when compiling test sources. Used by task `compileTestJava`.
   
   `testRuntimeOnly` extends `runtimeOnly`::
   Runtime only dependencies for running tests.
   
   `testRuntimeClasspath` extends `testRuntimeOnly, testImplementation`::
   Runtime classpath for running tests. Used by task `test`.
   
   The following diagrams show the dependency configurations for the _main_ and _test_ source sets respectively. You can use this legend to interpret the colors:
   
    * Green background 댹맟ou can declare dependencies against the configuration.
    * Blue-gray background 댹맚he configuration is for consumption by tasks, not for you to declare dependencies.
    * Light blue background with monospace text 댹마 task.
   
   .Java plugin - _main_ source set dependency configurations
   image::java-main-configurations.png[]
   
   .Java plugin - _test_ source set dependency configurations
   image::java-test-configurations.png[]
   
   For each source set you add to the project, the Java plugins adds the following dependency configurations:
   
   === SourceSet dependency configurations
   
   `__sourceSet__Implementation`::
   Compile time dependencies for the given source set. Used by `__sourceSet__CompileClasspath, __sourceSet__RuntimeClasspath`.
   
   `__sourceSet__CompileOnly`::
   Compile time only dependencies for the given source set, not used at runtime.
   
   `__sourceSet__CompileClasspath` extends `__sourceSet__CompileOnly, __sourceSet__Implementation`::
   Compile classpath, used when compiling source. Used by `compile__SourceSet__Java`.
   
   `__sourceSet__AnnotationProcessor`::
   Annotation processors used during compilation of this source set.
   
   `__sourceSet__RuntimeOnly`::
   Runtime only dependencies for the given source set.
   
   `__sourceSet__RuntimeClasspath` extends `__sourceSet__RuntimeOnly, __sourceSet__Implementation`::
   Runtime classpath contains elements of the implementation, as well as runtime only elements.
   
   == Contributed extension
   
   The Java plugin adds the link:{groovyDslPath}#[`java` extension] to the project.
   This allows to configure a number of Java related properties inside a dedicated DSL block.
   
   .Using the `java` extension to configure a toolchain
   ====
   include::sample[dir="snippets/java/basic/kotlin",files="build.gradle.kts[tags=java-extension]"]
   include::sample[dir="snippets/java/basic/groovy",files="build.gradle[tags=java-extension]"]
   ====
   
   Below is the list of properties and DSL functions with short explanations available inside the `java` extension.
   
   === Toolchain and compatibility
   
   `toolchain`::
   <<toolchains.adoc#toolchains, Java toolchain>> to be used by tasks using JVM tools, such as compilation and execution. Default value: build JVM toolchain.
   
   `link:{javadocPath}#[JavaVersion] sourceCompatibility`::
   Java version compatibility to use when compiling Java source. Default value: language version of the toolchain from this extension. +
   _Note that using a <<toolchains.adoc#toolchains, toolchain>> is preferred to using a compatibility setting for most cases._
   
   `link:{javadocPath}#[JavaVersion] targetCompatibility`::
   Java version to generate classes for. Default value: `__sourceCompatibility__`. +
   _Note that using a <<toolchains.adoc#toolchains, toolchain>> is preferred to using a compatibility setting for most cases._
   
   === Packaging
   
   `withJavadocJar()`::
   Automatically packages Javadoc and creates a variant `javadocElements` with an artifact `-javadoc.jar`, which will be part of the publication.
   
   `withSourcesJar()`::
   Automatically packages source code and creates a variant `sourceElements` with an artifact `-sources.jar`, which will be part of the publication.
   
   === Directory properties
   
   `String reporting.baseDir`::
   The name of the directory to generate reports into, relative to the build directory. Default value: `reports`
   
   `(read-only) File reportsDir`::
   The directory to generate reports into. Default value: `__reporting.baseDirectory__`
   
   `String testResultsDirName`::
   The name of the directory to generate test result .xml files into, relative to the build directory. Default value: `test-results`
   
   `(read-only) File testResultsDir`::
   The directory to generate test result .xml files into. Default value: `layout.buildDirectory.dir(__testResultsDirName__)`
   
   `String testReportDirName`::
   The name of the directory to generate the test report into, relative to the reports directory. Default value: `tests`
   
   `(read-only) File testReportDir`::
   The directory to generate the test report into. Default value: `__reportsDir__/testReportDirName`
   
   `String libsDirName`::
   The name of the directory to generate libraries into, relative to the build directory. Default value: `libs`
   
   `(read-only) File libsDir`::
   The directory to generate libraries into. Default value: `layout.buildDirectory.dir(__libsDirName__)`
   
   `String distsDirName`::
   The name of the directory to generate distributions into, relative to the build directory. Default value: `distributions`
   
   `(read-only) File distsDir`::
   The directory to generate distributions into. Default value: `layout.buildDirectory.dir(__distsDirName__)`
   
   `String docsDirName`::
   The name of the directory to generate documentation into, relative to the build directory. Default value: `docs`
   
   `(read-only) File docsDir`::
   The directory to generate documentation into. Default value: `layout.buildDirectory.dir(__docsDirName__)`
   
   `String dependencyCacheDirName`::
   The name of the directory to cache source dependency information relative to the build directory. Default value: `dependency-cache`.
   
   === Other properties
   
   `(read-only) link:{javadocPath}#[SourceSetContainer] sourceSets`::
   Contains the project's source sets. Default value: Not null link:{javadocPath}#[SourceSetContainer]
   
   `String archivesBaseName`::
   The basename to use for archives, such as JAR or ZIP files. Default value: `__projectName__`
   
   `link:{javadocPath}#[Manifest] manifest`::
   The manifest to include in all JAR files. Default value: an empty manifest.
   
   == Convention properties (deprecated)
   
   The Java Plugin adds a number of convention properties to the project. You can use these properties in your build script as though they were properties of the project object.
   These are *deprecated* and superseded by the extension described above.
   See the link:{groovyDslPath}#[JavaPluginConvention] DSL documentation for information on them.
   
   == Testing
   
   See the <<java_testing.adoc#java_testing,Testing in Java & JVM projects>> chapter for more details.
   
   == Publishing
   
   `components.java`::
   A link:{javadocPath}#[SoftwareComponent] for <<publishing_setup.adoc#publishing_overview,publishing>> the production JAR created by the `jar` task.
   This component includes the runtime dependency information for the JAR.
   
   See also the <<#sec:java-extension,`java` extension>>.
   
   == Incremental Java compilation
   
   Gradle comes with a sophisticated incremental Java compiler that is active by default.
   
   This gives you the following benefits
   
   * Incremental builds are much faster.
   * The smallest possible number of class files are changed.
     Classes that don't need to be recompiled remain unchanged in the output directory.
     An example scenario when this is really useful is using JRebel  the fewer output classes are changed the quicker the JVM can use refreshed classes.
   
   To help you understand how incremental compilation works, the following provides a high-level overview:
   
   * Gradle will recompile all classes _affected_ by a change.
   * A class is _affected_ if it has been changed or if it depends on another affected class.
       This works no matter if the other class is defined in the same project, another project or even an external library.
   * A class's dependencies are determined from type references in its bytecode or symbol analysis via a compiler plugin.
   * Since source-retention annotations are not visible in bytecode, changes to a source-retention annotation will result in full recompilation.
   * You can improve incremental compilation performance by applying good software design principles like loose coupling.
       For instance, if you put an interface between a concrete class and its dependents, the dependent classes are only recompiled when the interface changes, but not when the implementation changes.
   * The class analysis is cached in the project directory, so the first build after a clean checkout can be slower. Consider turning off the incremental compiler on your build server.
   * The class analysis is also an output stored in the build cache, which means that if a compilation output is fetched from the build cache, then the incremental compilation analysis will be too and the next compilation will be incremental.
   
   === Known issues
   
   * If you are using an annotation processor that reads resources (e.g. a configuration file), you need to declare those resources as an input of the compile task.
   * If a resource file is changed, Gradle will trigger a full recompilation.
   * Using a custom `executable` or `javaHome` deactivates some optimizations.
       The compile task does not use incremental build immediately after a compile error or if a Java constant changes.
       Use <<toolchains.adoc#toolchains, toolchains>> instead if possible.
   * Having a source structure that does not match the package names, while legal for compilation, might end up causing trouble in the toolchain.
       Even more if annotation processing and <<build_cache.adoc#build_cache,caching>> are involved.
   
   == Incremental annotation processing
   
   Starting with Gradle 4.7, the incremental compiler also supports incremental annotation processing.
   All annotation processors need to opt in to this feature, otherwise they will trigger a full recompilation.
   
   As a user you can see which annotation processors are triggering full recompilations in the `--info` log.
   Incremental annotation processing will be deactivated if a custom `executable` or `javaHome` is configured on the compile task.
   
   === Making an annotation processor incremental
   
   Please first have a look at <<#sec:incremental_compile,incremental Java compilation>>, as incremental annotation processing builds on top of it.
   
   Gradle supports incremental compilation for two common categories of annotation processors: "isolating" and "aggregating".
   Please consult the information below to decide which category fits your processor.
   
   You can then register your processor for incremental compilation using a file in the processor's META-INF directory.
   The format is one line per processor, with the fully qualified name of the processor class and its case-insensitive category separated by a comma.
   
   === Example: Registering incremental annotation processors
   
   [listing]
   .processor/src/main/resources/META-INF/gradle/incremental.annotation.processors
   ----
   include::{snippetsPath}/java/incrementalAnnotationProcessing/groovy/processor/src/main/resources/META-INF/gradle/incremental.annotation.processors[tag=registering-incremental-annotation-processors]
   ----
   
   
   If your processor can only decide at runtime whether it is incremental or not, you can declare it as "dynamic" in the META-INF descriptor
   and return its true type at runtime using the link:{javaApi}/javax/annotation/processing/Processor.html#getSupportedOptions--[Processor#getSupportedOptions()] method.
   
   === Example: Registering incremental annotation processors dynamically
   
   [source,java,indent=0]
   .processor/src/main/java/org/gradle/ServiceRegistryProcessor.java
   ----
   include::{snippetsPath}/java/incrementalAnnotationProcessing/groovy/processor/src/main/java/org/gradle/ServiceRegistryProcessor.java[tag=options-of-dynamic-processor]
   ----
   
   Both categories have the following limitations:
   
   * They can only read `CLASS` or `RUNTIME` retention annotations.
   * They can only read parameter names if the user passes the `-parameters` compiler argument.
   * They must generate their files using the link:{javaApi}/javax/annotation/processing/Filer.html[Filer API].
       Writing files any other way will result in silent failures later on, as these files won't be cleaned up correctly.
       If your processor does this, it cannot be incremental.
   * They must not depend on compiler-specific APIs like `com.sun.source.util.Trees`.
       Gradle wraps the processing APIs, so attempts to cast to compiler-specific types will fail.
       If your processor does this, it cannot be incremental, unless you have some fallback mechanism.
   * If they use link:{javaApi}/javax/annotation/processing/Filer.html#createResource(javax.tools.JavaFileManager.Location,java.lang.CharSequence,java.lang.CharSequence,javax.lang.model.element.Element++...++)[Filer#createResource],
       the `location` argument must be one of these values from link:{javaApi}/javax/tools/StandardLocation.html[StandardLocation]: `CLASS_OUTPUT`, `SOURCE_OUTPUT`, or `NATIVE_HEADER_OUTPUT`.
       Any other argument will disable incremental processing.
   
   === "Isolating" annotation processors
   
   The fastest category, these look at each annotated element in isolation, creating generated files or validation messages for it.
   For instance an `EntityProcessor` could create a `<TypeName>Repository` for each type annotated  with `@Entity`.
   
   === Example: An isolated annotation processor
   
   [source,java,indent=0]
   .processor/src/main/java/org/gradle/EntityProcessor.java
   ----
   include::{snippetsPath}/java/incrementalAnnotationProcessing/groovy/processor/src/main/java/org/gradle/EntityProcessor.java[tag=isolating-annotation-processor]
   ----
   
   "Isolating" processors have the following additional limitations:
   
   * They must make all decisions (code generation, validation messages) for an annotated type based on information reachable from its AST.
       This means you can analyze the types' super-class, method return types, annotations etc., even transitively.
       But you cannot make decisions based on unrelated elements in the RoundEnvironment.
       Doing so will result in silent failures because too few files will be recompiled later.
       If your processor needs to make decisions based on a combination of otherwise unrelated elements, mark it as "aggregating" instead.
   * They must provide exactly one originating element for each file generated with the `Filer` API.
       If zero or many originating elements are provided, Gradle will recompile all source files.
   
   
   When a source file is recompiled, Gradle will recompile all files generated from it.
   When a source file is deleted, the files generated from it are deleted.
   
   === "Aggregating" annotation processors
   
   These can aggregate several source files into one or more output files or validation messages.
   For instance, a `ServiceRegistryProcessor` could create a single `ServiceRegistry` with one method for each type annotated with `@Service`.
   
   === Example: An aggregating annotation processor
   
   [source,java,indent=0]
   .processor/src/main/java/org/gradle/ServiceRegistryProcessor.java
   ----
   include::{snippetsPath}/java/incrementalAnnotationProcessing/groovy/processor/src/main/java/org/gradle/ServiceRegistryProcessor.java[tag=aggregating-annotation-processor]
   ----
   
   Gradle will always reprocess (but not recompile) all annotated files that the processor was registered for.
   Gradle will always recompile any files the processor generates.
   
   === State of support in popular annotation processors
   
   NOTE: Many popular annotation processors support incremental annotation processing (see the table below).
   Check with the annotation processor project directly for the most up-to-date information and documentation.
   
   [cols="a,a,a", options="header"]
   |===
   | Annotation Processor
   | Supported since
   | Details
   
   | link:https://github.com/google/auto[Auto Value]
   | link:https://github.com/google/auto/releases/tag/auto-value-1.6.3[1.6.3]
   | N/A
   
   | link:https://github.com/google/auto[Auto Service]
   | link:https://github.com/google/auto/releases/tag/auto-value-1.6.3[1.6.3]
   | N/A
   
   | link:https://github.com/google/auto[Auto Value extensions]
   | Partly supported.
   | link:https://github.com/google/auto/issues/673[Details in issue]
   
   | link:https://github.com/JakeWharton/butterknife[Butterknife]
   | link:https://github.com/JakeWharton/butterknife/commit/2acac62c7354fee46a5201d50a4712732f6dd1ed[10.2.0]
   | N/A
   
   | link:https://github.com/rzwitserloot/lombok[Lombok]
   | link:https://github.com/rzwitserloot/lombok/releases/tag/v1.16.22[1.16.22]
   | N/A
   
   | DataBinding
   | link:https://issuetracker.google.com/issues/110061530#comment28[AGP 3.5.0-alpha5]
   | Hidden behind a feature toggle
   
   | Dagger
   | link:https://github.com/google/dagger/issues/1120[2.18]
   | 2.18 Feature toggle support, 2.24 Enabled by default
   
   | kapt
   | link:https://youtrack.jetbrains.com/issue/KT-23880[1.3.30]
   | Hidden behind a feature toggle
   
   | Toothpick
   | link:https://github.com/stephanenicolas/toothpick/pull/320[2.0]
   | N/A
   
   | Glide
   | link:https://github.com/bumptech/glide/releases/tag/v4.9.0[4.9.0]
   | N/A
   
   | Android-State
   | link:https://github.com/evernote/android-state/releases/tag/v1.3.0[1.3.0]
   | N/A
   
   | Parceler
   | link:https://github.com/johncarl81/parceler/releases/tag/parceler-project-1.1.11[1.1.11]
   | N/A
   
   | Dart and Henson
   | link:https://github.com/f2prateek/dart/releases/tag/3.1.0[3.1.0]
   | N/A
   
   | link:https://github.com/mapstruct/mapstruct[MapStruct]
   | link:https://github.com/mapstruct/mapstruct/releases/tag/1.4.0.Beta1[1.4.0.Beta1]
   | N/A
   
   | link:https://github.com/square/AssistedInject[Assisted Inject]
   | link:https://github.com/square/AssistedInject/blob/master/CHANGELOG.md#version-050-2019-08-08[0.5.0]
   | N/A
   
   | link:https://github.com/realm/realm-java[Realm]
   | link:https://github.com/realm/realm-java/blob/v5.11.0/CHANGELOG.md[5.11.0]
   | N/A
   
   | Requery
   | link:https://github.com/requery/requery/issues/773[Open issue]
   | N/A
   
   | link:https://github.com/greenrobot/EventBus[EventBus]
   | link:https://github.com/greenrobot/EventBus/releases/tag/V3.2.0[3.2.0]
   | N/A
   
   | EclipseLink
   | link:https://bugs.eclipse.org/bugs/show_bug.cgi?id=535985[Open issue]
   | N/A
   
   | link:https://github.com/permissions-dispatcher/PermissionsDispatcher[PermissionsDispatcher]
   | link:https://github.com/permissions-dispatcher/PermissionsDispatcher/releases/tag/4.2.0[4.2.0]
   | N/A
   
   | Immutables
   | link:https://github.com/immutables/immutables/issues/804[Open issue]
   | N/A
   
   | link:https://developer.android.com/topic/libraries/architecture/room[Room]
   | link:https://developer.android.com/jetpack/androidx/releases/room#version_220_3[2.2.0]
   | 2.2.0 Feature toggle support, 2.3.0-alpha02 Enabled by default
   
   | link:https://developer.android.com/jetpack/androidx/releases/lifecycle[Lifecycle]
   | link:https://issuetracker.google.com/issues/129115778[2.2.0-alpha02]
   | N/A
   
   | link:https://github.com/androidannotations/androidannotations[AndroidAnnotations]
   | link:https://github.com/androidannotations/androidannotations/wiki/ReleaseNotes#4.7.0[4.7.0]
   | N/A
   
   | DBFlow
   | link:https://github.com/agrosner/DBFlow/issues/1648[Open issue]
   | N/A
   
   | AndServer
   | link:https://github.com/yanzhenjie/AndServer/issues/152[Open issue]
   | N/A
   
   | link:https://github.com/facebook/litho[Litho]
   | link:https://github.com/facebook/litho/blob/master/CHANGELOG.md#version-0250[0.25.0]
   | N/A
   
   | link:https://github.com/moxy-community/Moxy/[Moxy]
   | https://github.com/moxy-community/Moxy/releases/tag/2.0.0[2.0]
   | N/A
   
   | link:https://github.com/airbnb/epoxy[Epoxy]
   | link:https://github.com/airbnb/epoxy/releases/tag/4.0.0-beta1[4.0.0-beta1]
   | N/A
   
   | link:https://docs.jboss.org/hibernate/orm/5.4/topical/html_single/metamodelgen/MetamodelGenerator.html[JPA Static Metamodel Generator]
   | link:https://github.com/hibernate/hibernate-orm/releases/tag/5.4.11[5.4.11]
   | N/A
   
   | link:https://github.com/airbnb/DeepLinkDispatch[DeepLinkDispatch]
   | link:https://github.com/airbnb/DeepLinkDispatch/releases/tag/5.0.0-beta01[5.0.0-beta01]
   | Hidden behind a feature toggle
   
   | link:https://github.com/MatthiasRobbers/shortbread[Shortbread]
   | link:https://github.com/MatthiasRobbers/shortbread/releases/tag/v1.1.0[1.1.0]
   | N/A
   
   |===
   
   == Compilation avoidance
   
   If a dependent project has changed in an https://en.wikipedia.org/wiki/Application_binary_interface[ABI]-compatible way (only its private API has changed), then Java compilation tasks will be up-to-date. This means that if project `A` depends on project `B` and a class in `B` is changed in an ABI-compatible way (typically, changing only the body of a method), then Gradle won't recompile `A`.
   
   Some of the types of changes that do not affect the public API and are ignored:
   
   * Changing a method body
   * Changing a comment
   * Adding, removing or changing private methods, fields, or inner classes
   * Adding, removing or changing a resource
   * Changing the name of jars or directories in the classpath
   * Renaming a parameter
   
   
   Since implementation details matter for annotation processors, they must be declared separately on the annotation processor path.
   Gradle ignores annotation processors on the compile classpath.
   
   .Declaring annotation processors
   ====
   include::sample[dir="snippets/java/apt/kotlin", files="build.gradle.kts[tags=annotation-processing]"]
   include::sample[dir="snippets/java/apt/groovy", files="build.gradle[tags=annotation-processing]"]
   ====
   
   == Variant aware selection
   
   The whole set of JVM plugins leverage <<variant_model.adoc#understanding-variant-selection,variant aware resolution>> for the dependencies used.
   They also install a set of attributes compatibility and disambiguation rules to <<variant_attributes.adoc#sub:jvm_default_attributes,configure the Gradle attributes>> for the specifics of the JVM ecosystem.

/docs/userguide/core-plugins/antlr_plugin.adoc
==============================================

.. code-block::

   = The ANTLR Plugin
   
   The ANTLR plugin extends the Java plugin to add support for generating parsers using http://www.antlr.org/[ANTLR].
   
   NOTE: The ANTLR plugin supports ANTLR version 2, 3 and 4.
   
   == Usage
   
   To use the ANTLR plugin, include the following in your build script:
   
   .Using the ANTLR plugin
   ====
   include::sample[dir="snippets/antlr/useAntlrPlugin/kotlin",files="build.gradle.kts[tags=use-plugin]"]
   include::sample[dir="snippets/antlr/useAntlrPlugin/groovy",files="build.gradle[tags=use-plugin]"]
   ====
   
   == Tasks
   
   The ANTLR plugin adds a number of tasks to your project, as shown below.
   
   `generateGrammarSource`  link:{groovyDslPath}#[AntlrTask]::
   Generates the source files for all production ANTLR grammars.
   
   `generateTestGrammarSource`  link:{groovyDslPath}#[AntlrTask]::
   Generates the source files for all test ANTLR grammars.
   
   `generate__SourceSet__GrammarSource`  link:{groovyDslPath}#[AntlrTask]::
   Generates the source files for all ANTLR grammars for the given source set.
   
   The ANTLR plugin adds the following dependencies to tasks added by the Java plugin.
   
   .ANTLR plugin - additional task dependencies
   [cols="a,a", options="header"]
   |===
   | Task name
   | Depends on
   | `compileJava`
   | `generateGrammarSource`
   
   | `compileTestJava`
   | `generateTestGrammarSource`
   
   | `compile__SourceSet__Java`
   | `generate__SourceSet__GrammarSource`
   |===
   
   
   == Project layout
   
   `src/main/antlr`::
   Production ANTLR grammar files. If the ANTLR grammar is organized in packages, the structure in the antlr folder should reflect the package structure. This ensures that the generated sources end up in the correct target subfolder.
   
   `src/test/antlr`::
   Test ANTLR grammar files.
   
   `src/__sourceSet__/antlr`::
   ANTLR grammar files for the given source set.
   
   
   == Dependency management
   
   The ANTLR plugin adds an `antlr` dependency configuration which provides the ANTLR implementation to use. The following example shows how to use ANTLR version 3.
   
   .Declare ANTLR version
   ====
   include::sample[dir="snippets/antlr/useAntlrPlugin/kotlin",files="build.gradle.kts[tags=declare-dependency]"]
   include::sample[dir="snippets/antlr/useAntlrPlugin/groovy",files="build.gradle[tags=declare-dependency]"]
   ====
   
   If no dependency is declared, `antlr:antlr:2.7.7` will be used as the default. To use a different ANTLR version add the appropriate dependency to the `antlr` dependency configuration as above.
   
   == Contributed extension
   
   `antlr`  link:{groovyDslPath}#[AntlrSourceDirectorySet]::
   The ANTLR grammar files of this source set. Contains all `.g` or `.g4` files found in the ANTLR source directories, and excludes all other types of files. _Default value is non-null._
   
   == Convention properties (deprecated)
   
   The ANTLR plugin adds one convention property.
   
   `antlr`  link:{groovyDslPath}#[SourceDirectorySet]::
   The ANTLR grammar files of this source set. Contains all `.g` or `.g4` files found in the ANTLR source directories, and excludes all other types of files. _Default value is non-null._
   
   This convention property is *deprecated* and superseded by the extension described above.
   
   == Source set properties
   
   The ANTLR plugin adds the following properties to each source set in the project.
   
   `antlr.srcDirs`  `Set&lt;File&gt;`::
   The source directories containing the ANTLR grammar files of this source set.
   Can set using anything <<working_with_files.adoc#sec:specifying_multiple_files, that implicitly converts to a file collection>>.
   Default value is `[__projectDir__/src/__name__/antlr]`.
   
   == Controlling the ANTLR generator process
   
   The ANTLR tool is executed in a forked process. This allows fine grained control over memory settings for the ANTLR process. To set the heap size of an ANTLR process, the `maxHeapSize` property of link:{groovyDslPath}#[AntlrTask] can be used. To pass additional command-line arguments, append to the `arguments` property of link:{groovyDslPath}#[AntlrTask].
   
   .Setting custom max heap size and extra arguments for ANTLR
   ====
   include::sample[dir="snippets/antlr/useAntlrPlugin/kotlin",files="build.gradle.kts[tags=generate-grammar-settings]"]
   include::sample[dir="snippets/antlr/useAntlrPlugin/groovy",files="build.gradle[tags=generate-grammar-settings]"]
   ====
   

/docs/userguide/jvm/jvm_test_suite_plugin.adoc
==============================================

.. code-block::

   = The JVM Test Suite Plugin
   
   The JVM Test Suite plugin (plugin id: `jvm-test-suite`) provides a DSL and API to model multiple groups of automated tests into test suites in JVM-based projects.  Tests suites are intended to grouped by their purpose and can have separate dependencies and use different testing frameworks.
   
   For instance, this plugin can be used to define a group of Integration Tests, which might run much longer than unit tests and have different environmental requirements.
   
   NOTE: The JVM Test Suite plugin is an <<feature_lifecycle.adoc#sec:incubating_state,incubating>> API and is subject to change in a future release.
   
   == Usage
   
   This plugin is applied automatically by the `java` plugin but can be additionally applied explicitly if desired. The plugin cannot be used without a JVM language plugin applied as it relies on several conventions of the `java` plugin.
   
   .Applying the JVM Test Suite plugin
   ====
   include::sample[dir="snippets/testing/test-suite-plugin/kotlin",files="build.gradle.kts[tags=apply-jvm-test-suite]"]
   include::sample[dir="snippets/testing/test-suite-plugin/groovy",files="build.gradle[tags=apply-jvm-test-suite]"]
   ====
   
   The plugins adds the following objects to the project:
   
    * A `testing` extension (type: link:{groovyDslPath}#[TestingExtension]) to the project used to configure test suites.
   
   When used with the <<java_plugin#java_plugin,Java Plugin>>:
   
    * A test suite named `test` (type: link:{groovyDslPath}#[JvmTestSuite]).
    * A `test` link:{groovyDslPath}#[SourceSet].
    * Several configurations derived from the `test` SourceSet name: `testImplementation`, `testCompileOnly`, `testRuntimeOnly`
    * A single test suite target backed by a task named `test`.
   
   The `test` task, SourceSet and derived configurations are identical in name and function to those used in prior Gradle releases.
   
   == Tasks
   
   The JVM Test Suite plugin adds the following task to the project:
   
   `test`  link:{groovyDslPath}#[Test]::
   _Depends on_: `testClasses` from the `java` plugin, and all tasks which produce the test runtime classpath
   +
   Runs the tests using the framework configured for the default test suite.
   
   Additional instances of link:{groovyDslPath}#[Test] tasks will be automatically created for each test suite added via the `testing` extension.
   
   == Configuration
   
   See the link:{groovyDslPath}#[TestingExtension] class in the API documentation.
   
   === Terminology and Modeling
   The JVM Test Suite Plugin introduces some modeling concepts backed by new APIs.  Here are their definitions.
   
   ==== Test Suite ====
   A test suite is a collection of JVM-based tests.
   
   ==== Test Suite Target ====
   For the initial release of this plugin, each test suite has a single target.  This results in a 1:1:1 relationship between test suite, test suite target and a matching link:{groovyDslPath}#[Test] task.  The name of the `Test` task is derived from the suite name.  Future iterations of the plugin will allow defining multiple targets based other attributes, such as a particular JDK/JRE runtime.
   
   Each test suite has some configuration that is common across for all tests contained in the suite:
   
   * Testing framework
   * Sources
   * Dependencies
   
   In the future, other properties may be specified in the test suite which may influence the toolchains selected to compile and run tests.
   
   The `Test` task associated with the target inherits its name from the suite.  Other properties of the `Test` task are configurable.
   
   ==== Test Suite Type ====
   Each test suite must be assigned a type.
   Types can be used to group related test suites across multiple Gradle projects within a build.
   
   The type of a test suite can be configured using the suites's link:{groovyDslPath}#[test type property].
   The type *must be unique* across all test suites in the same Gradle project.
   By convention, the type is set to the name of the test suite, converted to dash-case - with the exception of the built-in test suite, which uses the value link:{javadocPath}#['unit-test'].
   
   Common values are available as constants in link:{javadocPath}#[TestSuiteType].
   
   [discrete]
   == Configuration Examples
   
   Here are several examples to illustrate the configurability of test suites.
   
   == Declare an additional test suite
   ====
   include::sample[dir="snippets/testing/test-suite-plugin/kotlin",files="build.gradle.kts[tags=configure-testing-extension]"]
   include::sample[dir="snippets/testing/test-suite-plugin/groovy",files="build.gradle[tags=configure-testing-extension]"]
   ====
   
   <1> Configure all test suites for this project.
   <2> Configure the built-in `test` suite.  This suite is automatically created for backwards compatibility.  You *must* specify a testing framework to use in order to run these tests (e.g. JUnit 4, JUnit Jupiter).  This suite is the only suite that will automatically have access to the production source's `implementation` dependencies, all other suites must explicitly declare these.
   <3> Declare this test suite uses JUnit Jupiter.  The framework's dependencies are automatically included.  It is always necessary to explicitly configure the built-in `test` suite even if JUnit4 is desired.
   <4> Define a new suite called `integrationTest`.  Note that all suites other than the built-in `test` suite will by convention work as if `useJUnitJupiter()` was called.  You do *not* have to explicitly configure the testing framework on these additional suites, unless you wish to change to another framework.
   <5> Add a dependency on the production code of the project to the `integrationTest` suite targets.  By convention, only the built-in `test` suite will automatically have a dependency on the production code of the project.
   <6> Configure all targets of this suite.  By convention, test suite targets have no relationship to other `Test` tasks.  This example shows that the slower integration test suite targets should run after all targets of the `test` suite are complete.
   <7> Configure the `check` task to depend on all `integrationTest` targets.  By convention, test suite targets are not associated with the `check` task.
   
   Invoking the `check` task on the above configured build should show output similar to:
   
   [listing]
   ----
   include::{snippetsPath}/testing/test-suite-plugin/tests/checkTaskOutput.out[]
   ----
   
   Note that the `integrationTest` test suite does not run until after the `test` test suite completes.
   
   == Configure the built-in `test` suite
   ====
   include::sample[dir="snippets/testing/test-suite-configure-default-suite/kotlin",files="build.gradle.kts[tags=configure-default-suite]"]
   include::sample[dir="snippets/testing/test-suite-configure-default-suite/groovy",files="build.gradle[tags=configure-default-suite]"]
   ====
   
   <1> Declare the `test` test suite uses the TestNG test framework.
   <2> Lazily configure the test task of all targets of the suite; note the return type of `testTask` is `TaskProvider<Test>`.
   <3> Configure more detailed test framework options.  The `options` will be a subclass of `org.gradle.api.tasks.testing.TestFrameworkOptions`, in this case it is `org.gradle.api.tasks.testing.testng.TestNGOptions`.
   
   
   == Configure dependencies of a test suite
   ====
   include::sample[dir="snippets/testing/test-suite-configure-suite-dependencies/kotlin",files="build.gradle.kts[tags=configure-suite-dependencies]"]
   include::sample[dir="snippets/testing/test-suite-configure-suite-dependencies/groovy",files="build.gradle[tags=configure-suite-dependencies]"]
   ====
   
   <1> Configure the built-in `test` test suite.
   <2> Add the assertj library to the test's compile and runtime classpaths.  The `dependencies` block within a test suite is already scoped for that test suite.  Instead of having to know the global name of the configuration, test suites have a consistent name that you use in this block for declaring `implementation`, `compileOnly`, `runtimeOnly` and `annotationProcessor` dependencies.
   <3> Add the Auto Value annotation processor to the suite's annotation processor classpath so that it will be run when compiling the tests.
   
   == Configure dependencies of a test suite to reference project outputs
   ====
   include::sample[dir="snippets/testing/test-suite-configure-suite-dependencies-project/kotlin",files="build.gradle.kts[tags=configure-suite-dependencies-project]"]
   include::sample[dir="snippets/testing/test-suite-configure-suite-dependencies-project/groovy",files="build.gradle[tags=configure-suite-dependencies-project]"]
   ====
   
   <1> Add a production dependency which is used as part of the library's public API.
   <2> Add a production dependency which is only used internally and is not exposed as part of this project's public classes.
   <3> Configure a new test suite which adds a `project()` dependency to the suite's compile and runtime classpaths. This dependency provides access to the project's outputs as well as any dependencies declared on its `api` and `compileOnlyApi` configurations.
   
   == Configure source directories of a test suite
   ====
   include::sample[dir="snippets/testing/test-suite-configure-source-dir/kotlin",files="build.gradle.kts[tags=configure-source-dir]"]
   include::sample[dir="snippets/testing/test-suite-configure-source-dir/groovy",files="build.gradle[tags=configure-source-dir]"]
   ====
   
   <1> Declare and configure a suite named `integrationTest`.  The `SourceSet` and synthesized `Test` tasks will be based on this name.
   <2> Configure the `sources` of the test suite.
   <3> Configure the `java` SourceDirectorySet of the test suite.
   <4> Overwrite the `srcDirs` property, replacing the conventional `src/integrationTest/java` location with `src/it/java`.
   
   == Configure the type of a test suite
   
   ====
   include::sample[dir="snippets/testing/test-suite-configure-type/kotlin",files="build.gradle.kts[tags=configure-type]"]
   include::sample[dir="snippets/testing/test-suite-configure-type/groovy",files="build.gradle[tags=configure-type]"]
   ====
   
   <1> This suite would use a type value of 'secondary-test' by default.  This explicitly sets the type to 'integration-test'.
   
   == Configure the `Test` task for a test suite
   ====
   include::sample[dir="snippets/testing/test-suite-configure-source-dir/kotlin",files="build.gradle.kts[tags=configure-test-task]"]
   include::sample[dir="snippets/testing/test-suite-configure-source-dir/groovy",files="build.gradle[tags=configure-test-task]"]
   ====
   
   <1> Configure the `integrationTest` task created by declaring a suite of the same name.
   <2> Configure the `Test` task properties.
   
   `Test` tasks associated with a test suite target can also be configured directly, by name.  It is not necessary to configure via the test suite DSL.
   
   == Sharing configuration between multiple test suites
   
   There are several ways to share configuration between multiple test suites to avoid the duplication of dependencies or other configuration.  Each method is a tradeoff between flexibility and the use of a declarative vs. imperative configuration style.
   
   1. Use the `configureEach` method on the `suites` container to configure every test suite the same way.
   2. Use `withType` and `matching` with `configureEach` to filter test suites and configure a subset of them.
   3. Extract the configuration block to a local variable and apply it only to the desired test suites.
   
   === Method 1: Use `configureEach`
   
   This is the most straightforward way to share configuration across _every_ test suite.  The configuration is applied to each test suite.
   
   ====
   include::sample[dir="snippets/testing/test-suite-multi-configure-each/kotlin",files="build.gradle.kts[tags=multi-configure]"]
   include::sample[dir="snippets/testing/test-suite-multi-configure-each/groovy",files="build.gradle[tags=multi-configure]"]
   ====
   
   <1> Configure every JVM test suite
   <2> Provide the dependencies to be shared by all test suites
   <3> Define the additional test suites which will be configured upon creation
   <4> Add dependencies specific to the `functionalTest` test suite
   
   === Method 2: Use `withType`, `matching` and `configureEach`
   
   This method adds filtering commands to only apply the configuration to a subset of the test suites, as identified by name.
   
   ====
   include::sample[dir="snippets/testing/test-suite-multi-configure-each-matching/kotlin",files="build.gradle.kts[tags=multi-configure]"]
   include::sample[dir="snippets/testing/test-suite-multi-configure-each-matching/groovy",files="build.gradle[tags=multi-configure]"]
   ====
   
   <1> Configure every JVM test suite matching the given criteria
   <2> Use a different testing framework for the `functionalTest` test suite
   <3> Add dependencies specific to the `functionalTest` test suite
   
   
   === Method 3: Extract a custom configuration block
   
   This method is the most flexible, but also the most imperative.
   
   ====
   include::sample[dir="snippets/testing/test-suite-multi-configure-each-extracted/kotlin",files="build.gradle.kts[tags=multi-configure]"]
   include::sample[dir="snippets/testing/test-suite-multi-configure-each-extracted/groovy",files="build.gradle[tags=multi-configure]"]
   ====
   
   <1> Define a closure which takes a single `JvmTestSuite` parameter and configures it
   <2> Apply the closure to a test suite, using the default (`test`) test suite
   <3> Alternate means of applying a configuration closure to a test suite outside of its declaration, using the `integrationTest` test suite
   
   == Differences between the test suite `dependencies` and the top-level `dependencies` blocks
   
   Gradle 7.6 changed the API of the test suite's `dependencies` block to be more strongly-typed.
   
   Each dependency scope returns a link:{groovyDslPath}#[`DependencyAdder`] that provides strongly-typed methods to add and configure dependencies.
   
   There is also a link:{javadocPath}#[`DependencyFactory`] with factory methods to create new dependencies from different notations.
   Dependencies can be created lazily using these factory methods, as shown below.
   
   This API differs from the top-level `dependencies` block in the following ways:
   
   * Dependencies must be declared using a `String`, an instance of `Dependency`, a `FileCollection`, a `Provider` of `Dependency`, or a `ProviderConvertible` of `MinimalExternalModuleDependency`.
   * Outside of Gradle build scripts, you must explicitly call a getter for the `DependencyAdder` and `add`.
       ** `dependencies.add("implementation", x)` becomes `getImplementation().add(x)`
   * You cannot declare dependencies with the `Map` notation from Kotlin and Java.
     Use multi-argument methods instead in Kotlin and Java.
       ** Kotlin: `compileOnly(mapOf("group" to "foo", "name" to "bar"))` becomes `compileOnly(module(group = "foo", name = "bar"))`
       ** Java: `compileOnly(Map.of("group", "foo", "name", "bar"))` becomes `getCompileOnly().add(module("foo", "bar", null))`
   * You cannot add a dependency with an instance of `Project`. You must turn it into a `ProjectDependency` first.
   * You cannot add version catalog bundles directly.
     Instead, use the `bundle` method on each configuration.
       ** Kotlin and Groovy: `implementation(libs.bundles.testing)` becomes `implementation.bundle(libs.bundles.testing)`
   * You cannot use providers for non-`Dependency` types directly.
     Instead, map them to a `Dependency` using the `DependencyFactory`.
       ** Kotlin and Groovy: `implementation(myStringProvider)` becomes `implementation(myStringProvider.map { dependencyFactory.create(it) })`
       ** Java: `implementation(myStringProvider)` becomes `getImplementation().add(myStringProvider.map(getDependencyFactory()::create)`
   
   The `dependencies` block within a test suite may not provide access to the same methods as the link:{groovyDslPath}#[top-level `dependencies` block].
   To access these methods, you need to use the top-level `dependencies` block.
   
   NOTE: Adding dependencies via the test suite's own `dependencies` block is the preferred and recommended way.
   You can also access the configurations of a test suite in a top-level `dependencies` block after creating the test suite, but the exact names of the configurations used by test suites should be considered an implementation detail subject to change.
   
   == Differences between similar methods on link:{groovyDslPath}#[JvmTestSuite] and link:{groovyDslPath}#[Test] task types
   
   Instances of JvmTestSuite have methods link:{javadocPath}#[useJUnit()] and link:{javadocPath}#[useJUnitJupiter()], which are similar in name to methods on the link:{groovyDslPath}#[Test] task type:  link:{javadocPath}#[useJUnit()] and link:{javadocPath}#[useJUnitPlatform()].  However, there are important differences.
   
   Unlike the methods on the link:{groovyDslPath}#[Test] task, link:{groovyDslPath}#[JvmTestSuite] methods perform two additional pieces of configuration:
   
   . link:{javadocPath}#[JvmTestSuite#useJUnit()], link:{javadocPath}#[#useJUnitJupiter()] and other framework-specific methods automatically apply the relevant testing framework libraries to the compile and runtime classpaths of the suite targets.  Note the overloaded methods like link:{javadocPath}#[JvmTestSuite#useJUnit(String)] and link:{javadocPath}#[#useJUnitJupiter(String)] allow you to provide specific versions of the framework dependencies.
   . link:{javadocPath}#[JvmTestSuite#useJUnit()] and link:{javadocPath}#[#useJUnitJupiter()] automatically configure the suite targets' link:{groovyDslPath}#[Test] tasks to execute using the specified framework.
   
   An example of this behavior is shown in the first configuration example above, <<#sec:configuring_the_built_in_test_suite,Configuring the built-in `test` suite>>.
   
   Note that unlike the link:{groovyDslPath}#[Test] task, the aforementioned methods on link:{groovyDslPath}#[JvmTestSuite] do not accept a closure or action for configuring the framework.  These framework configuration options can be set on the individual targets.
   
   == Outgoing Variants
   Each test suite creates an outgoing variant containing its test execution results.  These variants are designed for consumption by the <<test_report_aggregation_plugin#test_report_aggregation_plugin, Test Report Aggregation Plugin>>.
   
   The attributes will resemble the following.  User-configurable attributes are highlighted below the sample.
   
   .outgoingVariants task output
   [source,text]
   ----
   --------------------------------------------------
   Variant testResultsElementsForTest (i)
   --------------------------------------------------
   Description = Directory containing binary results of running tests for the test Test Suite's test target.
   
   Capabilities
       - org.gradle.sample:list:1.0.2 (default capability)
   Attributes
       - org.gradle.category              = verification
       - org.gradle.testsuite.name        = test           // <1>
       - org.gradle.testsuite.target.name = test           // <2>
       - org.gradle.testsuite.type        = unit-test      // <3>
       - org.gradle.verificationtype      = test-results
   
   Artifacts
       - build/test-results/test/binary (artifactType = directory)
   ----
   <1> TestSuiteName attribute; value is derived from link:{javadocPath}#[JvmTestSuite#getName()].
   <2> TestSuiteTargetName attribute; value is derived from link:{javadocPath}#[JvmTestSuiteTarget#getName()].
   <3> TestSuiteType attribute; value is derived from link:{javadocPath}#[JvmTestSuite#getTestType()].

/docs/userguide/jvm/test_report_aggregation_plugin.adoc
=======================================================

.. code-block::

   = The Test Report Aggregation Plugin
   
   The Test Report Aggregation plugin (plugin id: `test-report-aggregation`) provides tasks and configurations used to aggregate the results of multiple link:{groovyDslPath}#[Test] task invocations (potentially spanning multiple Gradle projects) into a single HTML report.
   
   == Usage
   
   To use the Test Report Aggregation plugin, include the following in your build script:
   
   [.multi-language-text.lang-groovy]
   ----
   plugins {
       id 'test-report-aggregation'
   }
   ----
   [.multi-language-text.lang-kotlin]
   ----
   plugins {
       id("test-report-aggregation")
   }
   ----
   
   Note that this plugin takes no action unless applied in concert with the <<jvm_test_suite_plugin#jvm_test_suite_plugin,JVM Test Suite Plugin>>.  The <<java_plugin#java_plugin, Java Plugin>> automatically applies the JVM Test Suite Plugin.
   
   There are now two ways to collect test results across multiple subprojects:
   
   1. From the distribution's project, such as an application or WAR subproject -> link:#[distribution sample]
   2. Using a standalone project to specify subprojects -> link:#[standalone sample]
   
   Example 2 could also be used to aggregate results via the root project.
   
   WARNING: The Test Report Aggregation plugin does not currently work with the ``com.android.application`` plugin.
   
   == Tasks
   
   When the project also applies the `jvm-test-suite` plugin, the following tasks are added for each test suite:
   
   `__testSuite__AggregateTestReport`  link:{groovyDslPath}#[TestReport]::
   _Depends on_: Artifacts of variants matching the below attributes
   +
   Collects variants of direct and transitive project dependencies via the `testReportAggregation` configuration. The following Attributes will be matched:
   
   [source]
   ----
       - org.gradle.category              = verification   // <1>
       - org.gradle.testsuite.type        = unit-test      // <2>
       - org.gradle.verificationtype      = test-results   // <3>
   ----
   <1> Category attribute; value is fixed.
   <2> TestSuiteType attribute; value is derived from link:{javadocPath}#[JvmTestSuite#getTestType()].
   <3> VerificationType attribute; value is fixed.
   
   More information about the variants produced by test execution are available in the <<jvm_test_suite_plugin#sec:outgoing_variants,Outgoing Variants>> section of the JVM Test Suite Plugin documentation.
   
   == Reports
   
   [IMPORTANT]
   ====
   By default, Gradle stops executing tasks when any task fails -- including test failures.
   To ensure that your builds always generate aggregation reports, specify the `--continue` option in your Gradle command.
   For more information, see <<command_line_interface.adoc#sec:continue_build_on_failure, continuing the build when a failure occurs>>.
   ====
   
   === Automatic report creation
   
   When the project also applies the `jvm-test-suite` plugin, the following reporting objects are added for each test suite:
   
   `__testSuite__AggregateTestReport`  link:{javadocPath}#[AggregateTestReport]::
   Creates a container to parameterize the link:{javadocPath}#[TestSuiteType] value.
   
   === Manual report creation
   
   When the project does not apply the `jvm-test-suite` plugin, you must manually register one or more reports:
   
   .Create a reporting container
   ====
   include::sample[dir="samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/kotlin/test-results",files="build.gradle.kts[tags=create_report]"]
   include::sample[dir="samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/groovy/test-results",files="build.gradle[tags=create_report]"]
   ====
   <.> Creates a report named `testAggregateTestReport` of type `AggregateTestReport`.  For convenience, sets `TestType` using a constant value from the  link:{javadocPath}#[TestSuiteType] class.  Any String value is acceptable.
   
   Report creation automatically creates backing tasks to aggregate by the given test suite type value.
   
   == Dependency management
   The Test Report Aggregation plugin adds the following dependency configurations:
   
   .Test Report Aggregation plugin - dependency configurations
   [cols="a,a", options="header"]
   |===
   | Name
   | Meaning
   
   | `testReportAggregation`
   | The configuration used to declare all project dependencies having test result data to be aggregated.
   | `aggregateTestReportResults`
   | Consumes the project dependencies from the `testReportAggregation` configuration using <<variant_model#sec:variant-aware-matching,variant-aware matching>> to find the appropriate test suite type.
   |===
   
   It is not necessary to explicitly add dependencies to the `testReportAggregation` configuration if the project also applies the `jvm-test-suite` plugin.

/Section: 游릭 Native languages
===============================


/docs/userguide/native/cpp_application_plugin.adoc
==================================================

.. code-block::

   = {cpp} Application
   
   WARNING: The {cpp} Application Plugin is not compatible with the <<configuration_cache.adoc#config_cache:plugins:core,configuration cache>>.
   
   The {cpp} Application Plugin provides the tasks, configurations and conventions for a building {cpp} application.
   
   == Usage
   
   .Applying the {cpp} Application Plugin
   ====
   include::sample[dir="snippets/cpp/cppApplication/kotlin",files="build.gradle.kts[tags=apply-plugin]"]
   include::sample[dir="snippets/cpp/cppApplication/groovy",files="build.gradle[tags=apply-plugin]"]
   ====
   
   == Build variants
   
   The {cpp} Application Plugin understands the following dimensions.
   Read the <<building_cpp_projects.adoc#sec:introducing_build_variants-cpp,introduction to build variants>> for more information.
   
   Build types - always either _debug_ or _release_::
   The build type controls the debuggability as well as the optimization of the generated binaries.
   - `debug` - Generate debug symbols and don뗪 optimized the binary
   - `release` - Generate debug symbols and optimize, but extract the debug symbols from the binary
   
   Target machines - defaults to the build host::
   The target machine expresses which machines the application expects to run.
   A target machine is identified by its operating system and architecture.
   Gradle uses the target machine to decide which tool chain to choose based on availability on the host machine.
   
   The target machine can be configured as follows:
   
   .Configure application target machines
   ====
   include::sample[dir="snippets/cpp/cppApplication/kotlin",files="build.gradle.kts[tags=configure-target-machines]"]
   include::sample[dir="snippets/cpp/cppApplication/groovy",files="build.gradle[tags=configure-target-machines]"]
   ====
   
   == Tasks
   
   The following diagram shows the relationships between tasks added by this plugin.
   
   .{cpp} Application Plugin default task graph
   image::cpp-application-task-graph.png[]
   
   === Variant-dependent Tasks
   
   The {cpp} Application Plugin creates tasks based on the variants of the application component.
   Read the <<building_cpp_projects.adoc#sec:introducing_build_variants-cpp,introduction to build variants>> for more information.
   The following diagram shows the relationship between variant-dependent tasks.
   
   .{cpp} Application Plugin variant-dependent task graph
   image::cpp-application-variant-task-graph.png[]
   
   `compile__Variant__Cpp` (e.g. `compileDebugCpp` and `compileReleaseCpp`)  - link:{groovyDslPath}#[CppCompile]::
   Depends on: All tasks that contribute source files to the compilation
   ::
   Compiles {cpp} source files using the selected compiler.
   
   `link__Variant__` (e.g. `linkDebug` and `linkRelease`) - link:{groovyDslPath}#[LinkExecutable]::
   Depends on: All tasks which contribute to the link executable, including `link__Variant__` and `create__Variant__` tasks from projects that are resolved via project dependencies
   ::
   Links executable from compiled object files using the selected linker.
   
   `install__Variant__` (e.g. `installDebug` and `installRelease`) - link:{groovyDslPath}#[InstallExecutable]::
   Depends on: `link__Variant__` and all tasks which contribute to the runtime of the executable, including `link__Variant__` tasks from projects that are resolved via project dependencies
   ::
   Installs the executable and all of it's runtime dependencies for easy execution.
   
   `assemble__Variant__` (e.g. `assembleDebug` and `assembleRelease`) - Task (lifecycle)::
   Depends on: `link__Variant__`
   ::
   Aggregates tasks that assemble the specific variant of this application.
   
   === Lifecycle Tasks
   
   The {cpp} Application Plugin attaches some of its tasks to the standard lifecycle tasks documented in the <<base_plugin.adoc#base_plugin,Base Plugin chapter>> - which the {cpp} Application Plugin applies automatically:
   
   `assemble` - Task (lifecycle)::
   Depends on: `linkDebug`
   ::
   Aggregate task that assembles the debug variant of the application for the current host (if present) in the project.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   `check` - Task (lifecycle)::
   Aggregate task that performs verification tasks, such as running the tests.
   Some plugins add their own verification task to `check`.
   For example, the <<cpp_unit_test_plugin.adoc#cpp_unit_test_plugin,{cpp} Unit Test Plugin>> attaches a task to this lifecycle task to run tests.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   `build` - Task (lifecycle)::
   Depends on: `check`, `assemble`
   ::
   Aggregate tasks that perform a full build of the project.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   `clean` - Delete::
   Deletes the build directory and everything in it, i.e. the path specified by the `layout.buildDirectory` project property.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   == Dependency management
   
   Just like the tasks created by the {cpp} Application Plugin, multiple configurations are created based on the variants of the application component.
   Read the <<building_cpp_projects.adoc#sec:introducing_build_variants-cpp,introduction to build variants>> for more information.
   The following graph describes the configurations added by the {cpp} Application Plugin:
   
   .{cpp} Application Plugin configurations
   image::cpp-application-configurations.png[]
   
   * The configurations in white are the ones a user should use to declare dependencies
   * The configurations in pink, also known as consumable denoted by \(C), are the ones used when a component runs against the library
   * The configurations in blue, also known as resolvable denoted by \(R), are internal to the component, for its own use
   
   The following configurations are used to declare dependencies:
   
   `implementation`::
   Used for declaring implementation dependencies for all variants of the main component.
   This is where you should declare dependencies of any variants.
   
   `main__Variant__Implementation` (e.g. `mainDebugImplementation` and `mainReleaseImplementation`) extends `implementation`::
   Used for declaring implementation dependencies for a specific variant of the main component.
   This is where you should declare dependencies of the specific variant.
   
   
   The following configurations are used by downstream consumers that depend on the application component:
   
   `__variant__RuntimeElements` (e.g. `debugRuntimeElements` and `releaseRuntimeElements) extends `main__Variant__Implementation`::
   Used for executing the application.
   This configuration is meant to be used by consumers, to retrieve all the elements necessary to run the application.
   
   The following configurations are used by the application itself:
   
   `cppCompile__Variant__` (e.g. `cppCompileDebug` and `cppCompileRelease`) extends `main__Variant__Implementation`::
   Used for compiling the application.
   This configuration contains the compile include roots of the application and is therefore used when invoking the {cpp} compiler to compile it.
   
   `nativeLink__Variant__` (e.g. `nativeLinkDebug` and `nativeLinkRelease`) extends `main__Variant__Implementation`::
   Used for linking the application.
   This configuration contains the libraries of the application and is therefore used when invoking the {cpp} linker to link it.
   
   `nativeRuntime__Variant__` (e.g. `nativeRuntimeDebug` and `nativeRuntimeRelease`) extends `main__Variant__Implementation`::
   Used for executing the application.
   This configuration contains the runtime libraries of the application.
   
   == Conventions
   
   The {cpp} Application Plugin adds conventions for sources and tasks, shown below.
   
   === Project layout
   
   The {cpp} Application Plugin assumes the project layout shown below.
   None of these directories need to exist or have anything in them.
   The {cpp} Application Plugin will compile whatever it finds and ignore anything missing.
   
   `src/main/cpp`::
   {cpp} source with extension of `.cpp`, `.c++` or `.cc`
   
   `src/main/headers`::
   Headers - headers needed to compile the application
   
   You <<building_cpp_projects.adoc#sec:custom_cpp_source_set_paths,configure the project layout>> by configuring the `source` and `privateHeaders` respectively on the `application` script block.
   
   === `compile__Variant__Cpp` Task
   
   The {cpp} Application Plugin adds a link:{groovyDslPath}#[CppCompile] instance for each variant of the application component to build (e.g. `compileDebugCpp` and `compileReleaseCpp`).
   Read the <<building_cpp_projects.adoc#sec:introducing_build_variants-cpp,introduction to build variants>> for more information.
   Some of the most common configuration options are shown below.
   
   [horizontal]
   link:{groovyDslPath}#[compilerArgs]:: []
   
   link:{groovyDslPath}#[debuggable]:: `true`
   
   link:{groovyDslPath}#[includes]:: `configurations.cppCompile__Variant__` + `application.privateHeaders`
   
   link:{groovyDslPath}#[macros]:: [:]
   
   link:{groovyDslPath}#[objectFileDir]:: `layout.buildDirectory.dir("obj/main/__$variant__")`
   
   link:{groovyDslPath}#[optimized]:: `false` for debug build type or `true` otherwise
   
   link:{groovyDslPath}#[positionIndependentCode]:: `false`
   
   link:{groovyDslPath}#[source]:: `application.cppSource`
   
   link:{groovyDslPath}#[systemIncludes]:: derived from the tool chain
   
   link:{groovyDslPath}#[targetPlatform]:: derived from the `TargetMachine` of the binary
   
   link:{groovyDslPath}#[toolChain]:: <<building_cpp_projects.adoc#sec:cpp_supported_tool_chain,automatically selected based on target machine>>
   
   === `link__Variant__` Task
   
   The {cpp} Application Plugin adds a link:{groovyDslPath}#[LinkExecutable] instance for each variant of the application  e.g. `linkDebug` and `linkRelease`.
   Read the <<building_cpp_projects.adoc#sec:introducing_build_variants-cpp,introduction to build variants>> for more information.
   Some of the most common configuration options are shown below.
   
   [horizontal]
   link:{groovyDslPath}#[debuggable]:: `true`
   
   link:{groovyDslPath}#[libs]:: `configurations.nativeLink__Variant__`
   
   link:{groovyDslPath}#[linkedFile]:: `layout.buildDirectory.dir("exe/main/__$variant__/baseName")` (*nix) or `layout.buildDirectory.dir("exe\main{backslash}__$variant__\baseName.exe")` (Windows)
   
   link:{groovyDslPath}#[linkerArgs]:: []
   
   link:{groovyDslPath}#[source]:: `compile__Variant__Cpp.objects`
   
   link:{groovyDslPath}#[targetPlatform]:: derived from the `TargetMachine` of the binary
   
   link:{groovyDslPath}#[toolChain]:: <<building_cpp_projects.adoc#sec:cpp_supported_tool_chain,automatically selected based on target machine>>
   
   === `install__Variant__` Task
   
   The {cpp} Application Plugin adds a link:{groovyDslPath}#[InstallExecutable] instance for each variant of the test component  e.g. `installDebug` and `installRelease`.
   Read the <<building_cpp_projects.adoc#sec:introducing_build_variants-cpp,introduction to build variants>> for more information.
   There is no need to configure any properties on the task.

/docs/userguide/native/cpp_library_plugin.adoc
==============================================

.. code-block::

   = {cpp} Library
   
   WARNING: The {cpp} Library Plugin is not compatible with the <<configuration_cache.adoc#config_cache:plugins:core,configuration cache>>.
   
   The {cpp} Library Plugin provides the tasks, conventions and conventions for building a {cpp} library.
   In particular, a {cpp} library provides functionality that can be used by consumers (i.e., other projects using this plugin or the <<cpp_application_plugin.adoc#cpp_application_plugin,{cpp} Application Plugin>>).
   
   == Usage
   
   .Applying the {cpp} Library Plugin
   ====
   include::sample[dir="snippets/cpp/cppLibrary/kotlin",files="build.gradle.kts[tags=apply-plugin]"]
   include::sample[dir="snippets/cpp/cppLibrary/groovy",files="build.gradle[tags=apply-plugin]"]
   ====
   
   == Build variants
   
   The {cpp} Library Plugin understands the following dimensions.
   Read the <<building_cpp_projects.adoc#sec:introducing_build_variants-cpp,introduction to build variants>> for more information.
   
   Build types - always set to _debug_ and _release_::
   The build type controls the debuggability as well as the optimization of the generated binaries.
   - `debug` - Generate debug symbols and don뗪 optimized the binary
   - `release` - Generate debug symbols and optimize, but extract the debug symbols from the binary
   
   Linkages - default to _shared_::
   The linkage expresses whether a shared library or static library should be created. Libraries can produce a shared library, a static library or both.
   
   The linkage can be configured as follows:
   
   .Configure library linkages
   ====
   include::sample[dir="snippets/cpp/cppLibrary/kotlin",files="build.gradle.kts[tags=configure-linkages]"]
   include::sample[dir="snippets/cpp/cppLibrary/groovy",files="build.gradle[tags=configure-linkages]"]
   ====
   
   Target machines - defaults to the build host::
   The target machine expresses which machines the application expects to run.
   A target machine is identified by its operating system and architecture.
   Gradle uses the target machine to decide which tool chain to choose based on availability on the host machine.
   
   The target machine can be configured as follows:
   
   .Configure library target machines
   ====
   include::sample[dir="snippets/cpp/cppLibrary/kotlin",files="build.gradle.kts[tags=configure-target-machines]"]
   include::sample[dir="snippets/cpp/cppLibrary/groovy",files="build.gradle[tags=configure-target-machines]"]
   ====
   
   == Tasks
   
   The following diagram shows the relationships between tasks added by this plugin.
   
   Note the default linkage of a {cpp} library is shared linkage as shown in the diagram.
   
   .{cpp} Library Plugin default task graph
   image::cpp-shared-library-task-graph.png[]
   
   With static linkage, the diagram changes to the following:
   
   .{cpp} Library Plugin static library only task graph
   image::cpp-static-library-task-graph.png[]
   
   === Variant-dependent Tasks
   
   The {cpp} Library Plugin creates tasks based on variants of the library component.
   Read the <<building_cpp_projects.adoc#sec:introducing_build_variants-cpp,introduction to build variants>> for more information.
   The following diagrams show the relationship between variant-dependent tasks.
   
   .{cpp} Library Plugin variant-dependent task graph
   image::cpp-library-variant-task-graph.png[]
   NOTE: Depending on the linkage property
   
   `compile__Variant__Cpp` (e.g. `compileDebugCpp` and `compileReleaseCpp`)  - link:{groovyDslPath}#[CppCompile]::
   Depends on: All tasks that contribute source files to the compilation
   ::
   Compiles {cpp} source files using the selected compiler.
   
   `link__Variant__` (e.g. `linkDebug` and `linkRelease`) - link:{groovyDslPath}#[LinkSharedLibrary] (shared linkage)::
   Depends on: All tasks which contribute to the link libraries, including `link__Variant__` and `create__Variant__` tasks from projects that are resolved via project dependencies
   ::
   Links shared library from compiled object files using the selected linker.
   
   `create__Variant__` (e.g. `createDebug` and `createRelease`) - link:{groovyDslPath}#[CreateStaticLibrary] (static linkage)::
   Creates static library from compiled object files using selected archiver
   
   `assemble__Variant__` (e.g. `assembleDebug` and `assembleRelease`) - Task (lifecycle)::
   Depends on: `link__Variant__` (shared linkage) or `create__Variant__` (static linkage)
   ::
   Aggregates tasks that assemble the specific variant of this library.
   
   === Lifecycle Tasks
   
   The {cpp} Library Plugin attaches some of its tasks to the standard lifecycle tasks documented in the <<base_plugin.adoc#base_plugin,Base Plugin chapter>>  which the {cpp} Library Plugin applies automatically:
   
   `assemble` - Task (lifecycle)::
   Depends on: `linkDebug` when linkage includes `shared` or `createDebug` otherwise.
   ::
   Aggregate task that assembles the debug variant of the shared library (if available) for the current host (if present) in the project.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   `check` - Task (lifecycle)::
   Aggregate task that performs verification tasks, such as running the tests.
   Some plugins add their own verification task to `check`.
   For example, the <<cpp_unit_test_plugin.adoc#cpp_unit_test_plugin,{cpp} Unit Test Plugin>> attach its test task to this lifecycle task.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   `build` - Task (lifecycle)::
   Depends on: `check`, `assemble`
   ::
   Aggregate tasks that perform a full build of the project.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   `clean` - Delete::
   Deletes the build directory and everything in it, i.e. the path specified by the `layout.buildDirectory` project property.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   == Dependency management
   
   Just like the tasks created by the {cpp} Library Plugin, multiple configurations are created based on the variants of the library component.
   Read the <<building_cpp_projects.adoc#sec:introducing_build_variants-cpp,introduction to build variants>> for more information.
   The following graph describes the configurations added by the {cpp} Library Plugin:
   
   .{cpp} Library Plugin configurations
   image::cpp-library-configurations.png[]
   
   * The configurations in white are the ones a user should use to declare dependencies
   * The configurations in pink, also known as consumable denoted by \(C), are the ones used when a component compiles, links, or runs against the library
   * The configurations in blue, also known as resolvable denoted by \(R), are internal to the component, for its own use
   
   The following configurations are used to declare dependencies:
   
   `api`::
   Used for declaring API dependencies (see <<sec:cpp_library_api_vs_implementation,API vs implementation section>>).
   This is where you should declare dependencies which are transitively exported to consumers, for compile and link.
   
   `implementation` extends `api`::
   Used for declaring implementation dependencies for all variants of the main component (see <<sec:cpp_library_api_vs_implementation,API vs implementation section>>).
   This is where you should declare dependencies which are purely internal and not meant to be exposed to consumers of any variants.
   
   `main__Variant__Implementation` (e.g. `mainDebugImplementation` and `mainReleaseImplementation`) extends `implementation`::
   Used for declaring implementation dependencies for a specific variant of the main component (see <<sec:cpp_library_api_vs_implementation,API vs implementation section>>).
   This is where you should declare dependencies which are purely internal and not meant to be exposed to consumers of this specific variant.
   
   
   The following configurations are used by consumers:
   
   `cppApiElements` extends `main__Variant__Implementation`::
   Used for compiling against the library.
   This configuration is meant to be used by consumers, to retrieve all the elements necessary to compile against the library.
   
   `__variant__LinkElements` (e.g. `debugLinkElements` and `releaseLinkElements`) extends `main__Variant__Implementation`::
   Used for linking against the library.
   This configuration is meant to be used by consumers, to retrieve all the elements necessary to link against the library.
   
   `__variant__RuntimeElements` (e.g. `debugRuntimeElements` and `releaseRuntimeElements) extends `main__Variant__Implementation`::
   Used for executing the library.
   This configuration is meant to be used by consumers, to retrieve all the elements necessary to run against the library.
   
   The following configurations are used by the library itself:
   
   `cppCompile__Variant__` (e.g. `cppCompileDebug` and `cppCompileRelease`) extends `main__Variant__Implementation`::
   Used for compiling the library.
   This configuration contains the compile include roots of the library and is therefore used when invoking the {cpp} compiler to compile it.
   
   `nativeLink__Variant__` (e.g. `nativeLinkDebug` and `nativeLinkRelease`) extends `main__Variant__Implementation`::
   Used for linking the library the shared library only.
   This configuration contains the libraries of the library and is therefore used when invoking the {cpp} linker to link it.
   
   `nativeRuntime__Variant__` (e.g. `nativeRuntimeDebug` and `nativeRuntimeRelease`) extends `main__Variant__Implementation`::
   Used for executing the library.
   This configuration contains the runtime libraries of the library.
   
   === API vs implementation
   
   The plugin exposes two configurations that can be used to declare dependencies: `api` and `implementation`.
   The `api` configuration should be used to declare dependencies which are exported by the library API, whereas the `implementation` configuration should be used to declare dependencies which are internal to the component.
   
   .Adding dependencies
   ====
   include::sample[dir="snippets/cpp/cppLibrary/kotlin",files="build.gradle.kts[tags=dependency-management]"]
   include::sample[dir="snippets/cpp/cppLibrary/groovy",files="build.gradle[tags=dependency-management]"]
   ====
   
   Dependencies appearing in the `api` configurations will be transitively exposed to consumers of the library, and as such will appear on the compile include root and link libraries of consumers.
   Dependencies found in the `implementation` configuration will, on the other hand, not be exposed to consumers, and therefore not leak into the consumer's compile include root and link libraries.
   This comes with several benefits:
   
   * dependencies do not leak into the compile include roots and link libraries of consumers, so they can never accidentally depend on a transitive dependency
   * faster compilation thanks to the reduced include roots and link libraries
   * fewer recompilations when implementation dependencies change since the consumer would not need to be recompiled
   
   == Conventions
   
   The {cpp} Library Plugin adds conventions for sources and tasks, shown below.
   
   === Project layout
   
   The {cpp} Library Plugin assumes the project layout shown below.
   None of these directories needs to exist or have anything in them.
   The {cpp} Library Plugin will compile whatever it finds and ignore anything missing.
   
   `src/main/cpp`::
   {cpp} source with extension of `.cpp`, `.{cpp}` or `.cc`
   
   `src/main/headers`::
   Private headers - headers needed to compile the library but are not needed by consumers
   
   `src/main/public`::
   Public headers - headers needed to compile the library and required by consumers
   
   You <<building_cpp_projects.adoc#sec:custom_cpp_source_set_paths,configure the project layout>> by configuring the `source`, `privateHeaders` and `publicHeaders` respectively on the `library` script block.
   
   === `compile__Variant__Cpp` Task
   
   The {cpp} Library Plugin adds a link:{groovyDslPath}#[CppCompile] instance for each variant of the library component to build (e.g. `compileDebugCpp` and `compileReleaseCpp`).
   Read the <<building_cpp_projects.adoc#sec:introducing_build_variants-cpp,introduction to build variants>> for more information.
   Some of the most common configuration options are shown below.
   
   [horizontal]
   link:{groovyDslPath}#[compilerArgs]:: []
   
   link:{groovyDslPath}#[debuggable]:: `true`
   
   link:{groovyDslPath}#[includes]:: `configurations.cppCompile__Variant__` + `library.publicHeaders` + `library.privateHeaders`
   
   link:{groovyDslPath}#[macros]:: [:]
   
   link:{groovyDslPath}#[objectFileDir]:: `layout.buildDirectory.dir("obj/main/__$variant__")`
   
   link:{groovyDslPath}#[optimized]:: `false` for debug build type or `true` otherwise
   
   link:{groovyDslPath}#[positionIndependentCode]:: `true` for shared linkage or `false` otherwise
   
   link:{groovyDslPath}#[source]:: `library.cppSource`
   
   link:{groovyDslPath}#[systemIncludes]:: derived from the tool chain
   
   link:{groovyDslPath}#[targetPlatform]:: derived from the `TargetMachine` of the binary
   
   link:{groovyDslPath}#[toolChain]:: <<building_cpp_projects.adoc#sec:cpp_supported_tool_chain,automatically selected based on target machine>>
   
   === `link__Variant__` Task
   
   The {cpp} Library Plugin adds a link:{groovyDslPath}#[LinkSharedLibrary] instance for each variant of the library containing shared linkage as a dimension - e.g. `linkDebug` and `linkRelease`.
   Read the <<building_cpp_projects.adoc#sec:introducing_build_variants-cpp,introduction to build variants>> for more information.
   Some of the most common configuration options are shown below.
   
   [horizontal]
   link:{groovyDslPath}#[debuggable]:: `true`
   
   link:{groovyDslPath}#[libs]:: `configurations.nativeLink__Variant__`
   
   link:{groovyDslPath}#[linkedFile]:: `layout.buildDirectory.dir("lib/main/__$variant__/libBaseName[.so|dylib]")` (*nix) or `layout.buildDirectory.dir("lib\main{backslash}__$variant__\baseName.dll")` (Windows)
   
   link:{groovyDslPath}#[linkerArgs]:: []
   
   link:{groovyDslPath}#[source]:: `compile__Variant__Cpp.objects`
   
   link:{groovyDslPath}#[targetPlatform]:: derived from the `TargetMachine` of the binary
   
   link:{groovyDslPath}#[toolChain]:: <<building_cpp_projects.adoc#sec:cpp_supported_tool_chain,automatically selected based on target machine>>
   
   === `create__Variant__` Task
   
   The {cpp} Library Plugin adds a link:{groovyDslPath}#[CreateStaticLibrary] instance for each variant of the library containing static linkage as a dimension - e.g. `createDebug` and `createRelease`.
   Read the <<building_cpp_projects.adoc#sec:introducing_build_variants-cpp,introduction to build variants>> for more information.
   Some of the most common configuration options are shown below.
   
   [horizontal]
   link:{groovyDslPath}#[outputFile]:: `layout.buildDirectory.dir("lib/main/__variant__/libBaseName.a")` (*nix) or `layout.buildDirectory.dir("lib\main{backslash}__variant__\baseName.lib")` (Windows)
   
   link:{groovyDslPath}#[source]:: `compile__Variant__Cpp.objects`
   
   link:{groovyDslPath}#[staticLibArgs]:: []
   
   link:{groovyDslPath}#[targetPlatform]:: derived from the `TargetMachine` of the binary
   
   link:{groovyDslPath}#[toolChain]:: <<building_cpp_projects.adoc#sec:cpp_supported_tool_chain,automatically selected based on target machine>>

/docs/userguide/native/cpp_unit_test_plugin.adoc
================================================

.. code-block::

   = {cpp} Unit Test
   
   WARNING: The {cpp} Unit Test Plugin is not compatible with the <<configuration_cache.adoc#config_cache:plugins:core,configuration cache>>.
   
   The {cpp} Unit Test Plugin provides the tasks, configurations and conventions for integrating with a {cpp} executable-based testing framework, such as https://github.com/google/googletest[Google Test].
   
   == Usage
   
   .Applying the {cpp} Unit Test Plugin
   ====
   include::sample[dir="snippets/cpp/cppUnitTest/kotlin",files="build.gradle.kts[tags=apply-plugin]"]
   include::sample[dir="snippets/cpp/cppUnitTest/groovy",files="build.gradle[tags=apply-plugin]"]
   ====
   
   == Build variants
   
   The {cpp} Unit Test Plugin understands the following dimensions.
   Read the <<building_cpp_projects.adoc#sec:introducing_build_variants-cpp,introduction to build variants>> for more information.
   
   Target machines - defaults to the tested component (if present) or build host (otherwise)::
   The target machine expresses which machines the application expects to run.
   A target machine is identified by its operating system and architecture.
   Gradle uses the target machine to decide which tool chain to choose based on availability on the host machine.
   
   The target machine can be configured as follows:
   
   .Configure application target machines
   ====
   include::sample[dir="snippets/cpp/cppUnitTest/kotlin",files="build.gradle.kts[tags=configure-target-machines]"]
   include::sample[dir="snippets/cpp/cppUnitTest/groovy",files="build.gradle[tags=configure-target-machines]"]
   ====
   
   == Tasks
   
   The following diagram shows the relationships between tasks added by this plugin.
   
   .{cpp} Unit Test Plugin default task graph
   image::cpp-unit-test-task-graph.png[]
   
   === Variant-dependent Tasks
   
   The {cpp} Unit Test Plugin creates tasks based on the variants of the unit test component.
   Read the <<building_cpp_projects.adoc#sec:introducing_build_variants-cpp,introduction to build variants>> for more information.
   The following diagrams show the relationship between variant-dependent tasks.
   
   .{cpp} Unit Test Plugin variant-dependent task graph
   image::cpp-unit-test-variant-task-graph.png[]
   
   `compileTest__Variant__Cpp` (e.g. `compileTestCpp`)  - link:{groovyDslPath}#[CppCompile]::
   Depends on: All tasks that contribute source files to the compilation
   ::
   Compiles {cpp} source files using the selected compiler.
   
   `linkTest__Variant__` (e.g. `linkTest`) - link:{groovyDslPath}#[LinkExecutable]::
   Depends on: All tasks which contribute to the link executable, including `link__Variant__` and `create__Variant__` tasks from projects that are resolved via project dependencies and tested component
   ::
   Links executable from compiled object files using the selected linker.
   
   `installTest__Variant__` (e.g. `installTest`) - link:{groovyDslPath}#[InstallExecutable]::
   Depends on: `linkTest__Variant__` and all tasks which contribute to the runtime of the executable, including `link__Variant__` tasks from projects that are resolved via project dependencies
   ::
   Installs the executable and all of it's runtime dependencies for easy execution.
   
   `runTest__Variant__` (e.g. `runTest`) - link:{groovyDslPath}#[RunTestExecutable]::
   Depends on: `installTest__Variant__`
   ::
   Run the installed executable.
   
   === Lifecycle Tasks
   
   The {cpp} Unit Test Plugin attaches some of its tasks to the standard lifecycle tasks documented in the <<base_plugin.adoc#base_plugin,Base Plugin chapter>>  which the {cpp} Unit Test Plugin applies automatically:
   
   `assemble` - Task (lifecycle)::
   Aggregate task that assembles the debug variant of the tested component for the current host (if present) in the project.
   For example, the <<cpp_application_plugin.adoc#cpp_application_plugin,{cpp} Application Plugin>> and <<cpp_library_plugin.adoc#cpp_library_plugin,{cpp} Library Plugin>> attach their link and create tasks to this lifecycle task.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   `test` - Task (lifecycle)::
   Depends on: `runTest__Variant__` that most closely matches the build host
   ::
   Aggregate task of the variant that most closely match the build host for testing the component.
   
   `check` - Task (lifecycle)::
   Depends on: `test`
   ::
   Aggregate task that performs verification tasks, such as running the tests.
   Some plugins add their own verification task to `check`.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   `build` - Task (lifecycle)::
   Depends on: `check`, `assemble`
   ::
   Aggregate tasks that perform a full build of the project.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   `clean` - Delete::
   Deletes the build directory and everything in it, i.e. the path specified by the `layout.buildDirectory` project property.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   == Dependency management
   
   Just like the tasks created by the {cpp} Unit Test Plugin, the configurations are created based on the variant of the application component.
   Read the <<building_cpp_projects.adoc#sec:introducing_build_variants-cpp,introduction to build variants>> for more information.
   The following graph describes the configurations added by the {cpp} Unit Test Plugin:
   
   .{cpp} Unit Test Plugin configurations
   image::cpp-unit-test-configurations.png[]
   
   * The configurations in white are the ones a user should use to declare dependencies
   * The configurations in blue, also known as resolvable denoted by \(R), are internal to the component, for its own use
   
   The following configurations are used to declare dependencies:
   
   `testImplementation`::
   Used for declaring implementation dependencies for all variants of the test component.
   This is where you should declare dependencies of any variants.
   Note this configuration inherit all dependencies declared on the tested component (library or application).
   
   `test__Variant__ExecutableImplementation` (e.g. `testExecutableImplementation`) extends `testImplementation`::
   Used for declaring implementation dependencies for a specific variant of the test component.
   This is where you should declare dependencies of the specific variant.
   
   
   There is no configurations that can be used by consumers for this plugin.
   
   The following configurations are used by the unit test itself:
   
   `cppCompileTest__Variant__` (e.g. `cppCompileTest`) extends `test__Variant__ExecutableImplementation`::
   Used for compiling the unit test.
   This configuration contains the compile include roots of the unit test and is therefore used when invoking the {cpp} compiler to compile it.
   
   `nativeLinkTest__Variant__` (e.g. `nativeLinkTest`) extends `test__Variant__ExecutableImplementation`::
   Used for linking the unit test.
   This configuration contains the libraries of the unit test and is therefore used when invoking the {cpp} linker to link it.
   
   `nativeRuntimeTest__Variant__` (e.g. `nativeRuntimeTest`) extends `test__Variant__ExecutableImplementation`::
   Used for executing the unit test.
   This configuration contains the runtime libraries of the unit test.
   
   == Conventions
   
   The {cpp} Unit Test Plugin adds conventions for sources and tasks, shown below.
   
   === Project layout
   
   The {cpp} Unit Test Plugin assumes the project layout shown below.
   None of these directories needs to exist or have anything in them.
   The {cpp} Unit Test Plugin will compile whatever it finds, and handles anything which is missing.
   
   `src/test/cpp`::
   {cpp} source with extension of `.cpp`, `.c++` or `.cc`
   
   `src/test/headers`::
   Headers - headers needed to compile the unit test
   
   You <<building_cpp_projects.adoc#sec:custom_cpp_source_set_paths,configure the project layout>> by configuring the `source` and `privateHeaders` respectively on the `unitTest` script block.
   
   === `compileTest__Variant__Cpp` Task
   
   The {cpp} Unit Test Plugin adds a link:{groovyDslPath}#[CppCompile] instance for each variant of the test component to build (e.g. `compileTestCpp`).
   Read the <<building_cpp_projects.adoc#sec:introducing_build_variants-cpp,introduction to build variants>> for more information.
   Some of the most common configuration options are shown below.
   
   [horizontal]
   link:{groovyDslPath}#[compilerArgs]:: []
   
   link:{groovyDslPath}#[debuggable]:: `true`
   
   link:{groovyDslPath}#[includes]:: `configurations.cppCompileTest__Variant__` + `unitTest.privateHeaders`
   
   link:{groovyDslPath}#[macros]:: [:]
   
   link:{groovyDslPath}#[objectFileDir]:: `layout.buildDirectory.dir("obj/test/__$variant__")`
   
   link:{groovyDslPath}#[optimized]:: `false`
   
   link:{groovyDslPath}#[positionIndependentCode]:: `false`
   
   link:{groovyDslPath}#[source]:: `unitTest.cppSource`
   
   link:{groovyDslPath}#[systemIncludes]:: derived from the tool chain
   
   link:{groovyDslPath}#[targetPlatform]:: derived from the `TargetMachine` of the binary
   
   link:{groovyDslPath}#[toolChain]:: <<building_cpp_projects.adoc#sec:cpp_supported_tool_chain,automatically selected based on target machine>>
   
   === `linkTest__Variant__` Task
   
   The {cpp} Unit Test Plugin adds a link:{groovyDslPath}#[LinkExecutable] instance for each variant of the test component - e.g. `linkTest`.
   Read the <<building_cpp_projects.adoc#sec:introducing_build_variants-cpp,introduction to build variants>> for more information.
   Some of the most common configuration options are shown below.
   
   [horizontal]
   link:{groovyDslPath}#[debuggable]:: `true`
   
   link:{groovyDslPath}#[libs]:: `configurations.nativeLinkTest__Variant__`
   
   link:{groovyDslPath}#[linkedFile]:: `layout.buildDirectory.dir("exe/test/__$variant__/baseName")` (*nix) or `layout.buildDirectory.dir("exe\test{backslash}__$variant__\baseName.exe")` (Windows)
   
   link:{groovyDslPath}#[linkerArgs]:: []
   
   link:{groovyDslPath}#[source]:: `compile__Variant__Cpp.objects` (if present) + `compileTest__Variant__Cpp.objects`
   
   link:{groovyDslPath}#[targetPlatform]:: derived from the `TargetMachine` of the binary
   
   link:{groovyDslPath}#[toolChain]:: <<building_cpp_projects.adoc#sec:cpp_supported_tool_chain,automatically selected based on target machine>>
   
   === `installTest__Variant__` Task
   
   The {cpp} Unit Test Plugin adds a link:{groovyDslPath}#[InstallExecutable] instance for each variant of the test component - e.g. `installTest`.
   Read the <<building_cpp_projects.adoc#sec:introducing_build_variants-cpp,introduction to build variants>> for more information.
   There is no need to configure any properties on the task.
   
   === `runTest__Variant__` Task
   
   The {cpp} Unit Test Plugin adds a link:{groovyDslPath}#[RunTestExecutable] instance for each variant of the test component - e.g. `runTest`.
   Read the <<building_cpp_projects.adoc#sec:introducing_build_variants-cpp,introduction to build variants>> for more information.
   Some of the most common configuration options are shown below.
   
   [horizontal]
   link:{groovyDslPath}#[args]:: `[]`
   
   link:{groovyDslPath}#[ignoreFailures]:: `false`

/docs/userguide/native/swift_application_plugin.adoc
====================================================

.. code-block::

   = Swift Application
   
   WARNING: The Swift Application Plugin is not compatible with the <<configuration_cache.adoc#config_cache:plugins:core,configuration cache>>.
   
   The Swift Application Plugin provides the tasks, configurations and conventions for a building Swift application.
   
   == Usage
   
   .Applying the Swift Application Plugin
   ====
   include::sample[dir="snippets/swift/swiftApplication/kotlin",files="build.gradle.kts[tags=apply-plugin]"]
   include::sample[dir="snippets/swift/swiftApplication/groovy",files="build.gradle[tags=apply-plugin]"]
   ====
   
   == Build variants
   
   The Swift Application Plugin understands the following dimensions.
   Read the <<building_swift_projects.adoc#sec:introducing_build_variants-swift,introduction to build variants>> for more information.
   
   Build types - always either _debug_ or _release_::
   The build type controls the debuggability as well as the optimization of the generated binaries.
   - `debug` - Generate debug symbols and don뗪 optimized the binary
   - `release` - Generate debug symbols and optimize, but extract the debug symbols from the binary
   
   Target machines - defaults to the build host::
   The target machine expresses which machines the application expects to run.
   A target machine is identified by its operating system and architecture.
   Gradle uses the target machine to decide which tool chain to choose based on availability on the host machine.
   
   The target machine can be configured as follows:
   
   .Configure application target machines
   ====
   include::sample[dir="snippets/swift/swiftApplication/kotlin",files="build.gradle.kts[tags=configure-target-machines]"]
   include::sample[dir="snippets/swift/swiftApplication/groovy",files="build.gradle[tags=configure-target-machines]"]
   ====
   
   == Tasks
   
   The following diagram shows the relationships between tasks added by this plugin.
   
   .Swift Application Plugin default task graph
   image::swift-application-task-graph.png[]
   
   === Variant-dependent Tasks
   
   The Swift Application Plugin creates tasks based on the variants of the application component.
   Read the <<building_swift_projects.adoc#sec:introducing_build_variants-swift,introduction to build variants>> for more information.
   The following diagram shows the relationship between variant-dependent tasks.
   
   .Swift Application Plugin variant-dependent task graph
   image::swift-application-variant-task-graph.png[]
   
   `compile__Variant__Swift` (e.g. `compileDebugSwift` and `compileReleaseSwift`)  - link:{groovyDslPath}#[SwiftCompile]::
   Depends on: All tasks that contribute source files to the compilation
   ::
   Compiles Swift source files using the selected compiler.
   
   `link__Variant__` (e.g. `linkDebug` and `linkRelease`) - link:{groovyDslPath}#[LinkExecutable]::
   Depends on: All tasks which contribute to the link executable, including `link__Variant__` and `create__Variant__` tasks from projects that are resolved via project dependencies
   ::
   Links executable from compiled object files using the selected linker.
   
   `install__Variant__` (e.g. `installDebug` and `installRelease`) - link:{groovyDslPath}#[InstallExecutable]::
   Depends on: `link__Variant__` and all tasks which contribute to the runtime of the executable, including `link__Variant__` tasks from projects that are resolved via project dependencies
   ::
   Installs the executable and all of it's runtime dependencies for easy execution.
   
   `assemble__Variant__` (e.g. `assembleDebug` and `assembleRelease`) - Task (lifecycle)::
   Depends on: `link__Variant__`
   ::
   Aggregates tasks that assemble the specific variant of this application.
   
   === Lifecycle Tasks
   
   The Swift Application Plugin attaches some of its tasks to the standard lifecycle tasks documented in the <<base_plugin.adoc#base_plugin,Base Plugin chapter>>  which the Swift Application Plugin applies automatically:
   
   `assemble` - Task (lifecycle)::
   Depends on: `linkDebug`
   ::
   Aggregate task that assembles the debug variant of the application for the current host (if present) in the project.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   `check` - Task (lifecycle)::
   Aggregate task that performs verification tasks, such as running the tests.
   Some plugins add their own verification task to `check`.
    For example, the <<xctest_plugin.adoc#xctest_plugin,XCTest Plugin>> attaches a task to this lifecycle task to run tests.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   `build` - Task (lifecycle)::
   Depends on: `check`, `assemble`
   ::
   Aggregate tasks that perform a full build of the project.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   `clean` - Delete::
   Deletes the build directory and everything in it, i.e. the path specified by the `layout.buildDirectory` project property.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   == Dependency management
   
   Just like the tasks created by the Swift Application Plugin, multiple configurations are created based on the variants of the application component.
   Read the <<building_swift_projects.adoc#sec:introducing_build_variants-swift,introduction to build variants>> for more information.
   The following graph describes the configurations added by the Swift Application Plugin:
   
   .Swift Application Plugin configurations
   image::swift-application-configurations.png[]
   
   * The configurations in white are the ones a user should use to declare dependencies
   * The configurations in pink, also known as consumable denoted by \(C), are the ones used when a component runs against the library
   * The configurations in blue, also known as resolvable denoted by \(R), are internal to the component, for its own use
   
   The following configurations are used to declare dependencies:
   
   `implementation`::
   Used for declaring implementation dependencies for all variants of the main component.
   This is where you should declare dependencies of any variants.
   
   `main__Variant__Implementation` (e.g. `mainDebugImplementation` and `mainReleaseImplementation`) extends `implementation`::
   Used for declaring implementation dependencies for a specific variant of the main component.
   This is where you should declare dependencies of the specific variant.
   
   
   The following configurations are used by downstream consumers that depend on the application component:
   
   `__variant__RuntimeElements` (e.g. `debugRuntimeElements` and `releaseRuntimeElements) extends `main__Variant__Implementation`::
   Used for executing the application.
   This configuration is meant to be used by consumers, to retrieve all the elements necessary to run the application.
   
   The following configurations are used by the application itself:
   
   `swiftCompile__Variant__` (e.g. `swiftCompileDebug` and `swiftCompileRelease`) extends `main__Variant__Implementation`::
   Used for compiling the application.
   This configuration contains the compile include roots of the application and is therefore used when invoking the Swift compiler to compile it.
   
   `nativeLink__Variant__` (e.g. `nativeLinkDebug` and `nativeLinkRelease`) extends `main__Variant__Implementation`::
   Used for linking the application.
   This configuration contains the libraries of the application and is therefore used when invoking the Swift linker to link it.
   
   `nativeRuntime__Variant__` (e.g. `nativeRuntimeDebug` and `nativeRuntimeRelease`) extends `main__Variant__Implementation`::
   Used for executing the application.
   This configuration contains the runtime libraries of the application.
   
   == Conventions
   
   The Swift Application Plugin adds conventions for sources and tasks, shown below.
   
   === Project layout
   
   The Swift Application Plugin assumes the project layout shown below.
   None of these directories need to exist or have anything in them.
   The Swift Application Plugin will compile whatever it finds and ignore anything missing.
   
   `src/main/swift`::
   Swift source with extension of `.swift`
   
   You <<building_swift_projects.adoc#sec:custom_swift_source_set_paths,configure the project layout>> by configuring the `source` on the `application` script block.
   
   === `compile__Variant__Swift` Task
   
   The Swift Application Plugin adds a link:{groovyDslPath}#[SwiftCompile] instance for each variant of the application component to build (e.g. `compileDebugSwift` and `compileReleaseSwift`).
   Read the <<building_swift_projects.adoc#sec:introducing_build_variants-swift,introduction to build variants>> for more information.
   Some of the most common configuration options are shown below.
   
   [horizontal]
   link:{groovyDslPath}#[compilerArgs]:: []
   
   link:{groovyDslPath}#[debuggable]:: `true`
   
   link:{groovyDslPath}#[modules]:: `configurations.swiftCompile__Variant__`
   
   link:{groovyDslPath}#[macros]:: []
   
   link:{groovyDslPath}#[objectFileDir]:: `layout.buildDirectory.dir("obj/main/__$variant__")`
   
   link:{groovyDslPath}#[optimized]:: `false` for debug build type or `true` otherwise
   
   link:{groovyDslPath}#[source]:: `application.swiftSource`
   
   link:{groovyDslPath}#[targetPlatform]:: derived from the `TargetMachine` of the binary
   
   link:{groovyDslPath}#[toolChain]:: <<building_swift_projects.adoc#sec:swift_supported_tool_chain,automatically selected based on target machine>>
   
   === `link__Variant__` Task
   
   The Swift Application Plugin adds a link:{groovyDslPath}#[LinkExecutable] instance for each variant of the application - e.g. `linkDebug` and `linkRelease`.
   Read the <<building_swift_projects.adoc#sec:introducing_build_variants-swift,introduction to build variants>> for more information.
   Some of the most common configuration options are shown below.
   
   [horizontal]
   link:{groovyDslPath}#[debuggable]:: `true`
   
   link:{groovyDslPath}#[libs]:: `configurations.nativeLink__Variant__`
   
   link:{groovyDslPath}#[linkedFile]:: `layout.buildDirectory.dir("exe/main/__$variant__/module")`
   
   link:{groovyDslPath}#[linkerArgs]:: []
   
   link:{groovyDslPath}#[source]:: `compile__Variant__Swift.objects`
   
   link:{groovyDslPath}#[targetPlatform]:: derived from the `TargetMachine` of the binary
   
   link:{groovyDslPath}#[toolChain]:: <<building_swift_projects.adoc#sec:swift_supported_tool_chain,automatically selected based on target machine>>
   
   === `install__Variant__` Task
   
   The Swift Application Plugin adds a link:{groovyDslPath}#[InstallExecutable] instance for each variant of the test component - e.g. `installDebug` and `installRelease`.
   Read the <<building_swift_projects.adoc#sec:introducing_build_variants-swift,introduction to build variants>> for more information.
   There is no need to configure any properties on the task.

/docs/userguide/native/swift_library_plugin.adoc
================================================

.. code-block::

   = Swift Library
   
   WARNING: The Swift Library Plugin is not compatible with the <<configuration_cache.adoc#config_cache:plugins:core,configuration cache>>.
   
   The Swift Library Plugin provides the tasks, conventions and conventions for building a Swift library.
   In particular, a Swift library provides functionality that can be used by consumers (i.e., other projects using this plugin or the <<swift_application_plugin.adoc#swift_application_plugin,Swift Application Plugin>>).
   
   == Usage
   
   .Applying the Swift Library Plugin
   ====
   include::sample[dir="snippets/swift/swiftLibrary/kotlin",files="build.gradle.kts[tags=apply-plugin]"]
   include::sample[dir="snippets/swift/swiftLibrary/groovy",files="build.gradle[tags=apply-plugin]"]
   ====
   
   == Build variants
   
   The Swift Library Plugin understands the following dimensions.
   Read the <<building_swift_projects.adoc#sec:introducing_build_variants-swift,introduction to build variants>> for more information.
   
   Build types - always set to _debug_ and _release_::
   The build type controls the debuggability as well as the optimization of the generated binaries.
   - `debug` - Generate debug symbols and don뗪 optimized the binary
   - `release` - Generate debug symbols and optimize, but extract the debug symbols from the binary
   
   Linkages - default to _shared_::
   The linkage expresses whether a shared library or static library should be created. Libraries can produce a shared library, a static library or both.
   
   The linkage can be configured as follows:
   
   .Configure library linkages
   ====
   include::sample[dir="snippets/swift/swiftLibrary/kotlin",files="build.gradle.kts[tags=configure-linkages]"]
   include::sample[dir="snippets/swift/swiftLibrary/groovy",files="build.gradle[tags=configure-linkages]"]
   ====
   
   Target machines - defaults to the build host::
   The target machine expresses which machines the application expects to run.
   A target machine is identified by its operating system and architecture.
   Gradle uses the target machine to decide which tool chain to choose based on availability on the host machine.
   
   The target machine can be configured as follows:
   
   .Configure library target machines
   ====
   include::sample[dir="snippets/swift/swiftLibrary/kotlin",files="build.gradle.kts[tags=configure-target-machines]"]
   include::sample[dir="snippets/swift/swiftLibrary/groovy",files="build.gradle[tags=configure-target-machines]"]
   ====
   
   == Tasks
   
   The following diagram shows the relationships between tasks added by this plugin.
   
   Note the default linkage of a Swift library is shared linkage as shown in the diagram.
   
   .Swift Library Plugin default task graph
   image::swift-shared-library-task-graph.png[]
   
   With static linkage, the diagram changes to the following:
   
   .Swift Library Plugin static library only task graph
   image::swift-static-library-task-graph.png[]
   
   === Variant-dependent Tasks
   
   The Swift Library Plugin creates tasks based on variants of the library component.
   Read the <<building_swift_projects.adoc#sec:introducing_build_variants-swift,introduction to build variants>> for more information.
   The following diagrams show the relationship between variant-dependent tasks.
   
   .Swift Library Plugin variant-dependent task graph
   image::swift-library-variant-task-graph.png[]
   NOTE: Depending on the linkage property
   
   `compile__Variant__Swift` (e.g. `compileDebugSwift` and `compileReleaseSwift`)  - link:{groovyDslPath}#[SwiftCompile]::
   Depends on: All tasks that contribute source files to the compilation
   ::
   Compiles Swift source files using the selected compiler.
   
   `link__Variant__` (e.g. `linkDebug` and `linkRelease`) - link:{groovyDslPath}#[LinkSharedLibrary] (shared linkage)::
   Depends on: All tasks which contribute to the link libraries, including `link__Variant__` and `create__Variant__` tasks from projects that are resolved via project dependencies
   ::
   Links shared library from compiled object files using the selected linker.
   
   `create__Variant__` (e.g. `createDebug` and `createRelease`) - link:{groovyDslPath}#[CreateStaticLibrary] (static linkage)::
   Creates static library from compiled object files using selected archiver
   
   `assemble__Variant__` (e.g. `assembleDebug` and `assembleRelease`) - Task (lifecycle)::
   Depends on: `link__Variant__` (shared linkage) or `create__Variant__` (static linkage)
   ::
   Aggregates tasks that assemble the specific variant of this library.
   
   === Lifecycle Tasks
   
   The Swift Library Plugin attaches some of its tasks to the standard lifecycle tasks documented in the <<base_plugin.adoc#base_plugin,Base Plugin chapter>>  which the Swift Library Plugin applies automatically:
   
   `assemble` - Task (lifecycle)::
   Depends on: `linkDebug` when linkage includes `shared` or `createDebug` otherwise.
   ::
   Aggregate task that assembles the debug variant of the shared library (if available) for the current host (if present) in the project.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   `check` - Task (lifecycle)::
   Aggregate task that performs verification tasks, such as running the tests.
   Some plugins add their own verification task to `check`.
    For example, the <<xctest_plugin.adoc#xctest_plugin,XCTest Plugin>> attach its test task to this lifecycle task.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   `build` - Task (lifecycle)::
   Depends on: `check`, `assemble`
   ::
   Aggregate tasks that perform a full build of the project.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   `clean` - Delete::
   Deletes the build directory and everything in it, i.e. the path specified by the `layout.buildDirectory` project property.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   == Dependency management
   
   Just like the tasks created by the Swift Library Plugin, multiple configurations are created based on the variants of the library component.
   Read the <<building_swift_projects.adoc#sec:introducing_build_variants-swift,introduction to build variants>> for more information.
   The following graph describes the configurations added by the Swift Library Plugin:
   
   .Swift Library Plugin configurations
   image::swift-library-configurations.png[]
   
   * The configurations in white are the ones a user should use to declare dependencies
   * The configurations in pink, also known as consumable denoted by \(C), are the ones used when a component compiles, links, or runs against the library
   * The configurations in blue, also known as resolvable denoted by \(R), are internal to the component, for its own use
   
   The following configurations are used to declare dependencies:
   
   `api`::
   Used for declaring API dependencies (see <<sec:swift_library_api_vs_implementation,API vs implementation section>>).
   This is where you should declare dependencies which are transitively exported to consumers, for compile and link.
   
   `implementation` extends `api`::
   Used for declaring implementation dependencies for all variants of the main component (see <<sec:swift_library_api_vs_implementation,API vs implementation section>>).
   This is where you should declare dependencies which are purely internal and not meant to be exposed to consumers of any variants.
   
   `main__Variant__Implementation` (e.g. `mainDebugImplementation` and `mainReleaseImplementation`) extends `implementation`::
   Used for declaring implementation dependencies for a specific variant of the main component (see <<sec:swift_library_api_vs_implementation,API vs implementation section>>).
   This is where you should declare dependencies which are purely internal and not meant to be exposed to consumers of this specific variant.
   
   
   The following configurations are used by consumers:
   
   `__variant__SwiftApiElements` (e.g. `debugSwiftApiElements` and `releaseSwiftApiElements`) extends `main__Variant__Implementation`::
   Used for compiling against the library.
   This configuration is meant to be used by consumers, to retrieve all the elements necessary to compile against the library.
   
   `__variant__LinkElements` (e.g. `debugLinkElements` and `releaseLinkElements`) extends `main__Variant__Implementation`::
   Used for linking against the library.
   This configuration is meant to be used by consumers, to retrieve all the elements necessary to link against the library.
   
   `__variant__RuntimeElements` (e.g. `debugRuntimeElements` and `releaseRuntimeElements) extends `main__Variant__Implementation`::
   Used for executing the library.
   This configuration is meant to be used by consumers, to retrieve all the elements necessary to run against the library.
   
   The following configurations are used by the library itself:
   
   `swiftCompile__Variant__` (e.g. `swiftCompileDebug` and `swiftCompileRelease`) extends `main__Variant__Implementation`::
   Used for compiling the library.
   This configuration contains the compile include roots of the library and is therefore used when invoking the Swift compiler to compile it.
   
   `nativeLink__Variant__` (e.g. `nativeLinkDebug` and `nativeLinkRelease`) extends `main__Variant__Implementation`::
   Used for linking the library the shared library only.
   This configuration contains the libraries of the library and is therefore used when invoking the Swift linker to link it.
   
   `nativeRuntime__Variant__` (e.g. `nativeRuntimeDebug` and `nativeRuntimeRelease`) extends `main__Variant__Implementation`::
   Used for executing the library.
   This configuration contains the runtime libraries of the library.
   
   === API vs implementation
   
   The plugin exposes two configurations that can be used to declare dependencies: `api` and `implementation`.
   The `api` configuration should be used to declare dependencies which are exported by the library API, whereas the `implementation` configuration should be used to declare dependencies which are internal to the component.
   
   .Adding dependencies
   ====
   include::sample[dir="snippets/swift/swiftLibrary/kotlin",files="build.gradle.kts[tags=dependency-management]"]
   include::sample[dir="snippets/swift/swiftLibrary/groovy",files="build.gradle[tags=dependency-management]"]
   ====
   
   Dependencies appearing in the `api` configurations will be transitively exposed to consumers of the library, and as such will appear on the compile include root and link libraries of consumers.
   Dependencies found in the `implementation` configuration will, on the other hand, not be exposed to consumers, and therefore not leak into the consumer's compile include root and link libraries.
   This comes with several benefits:
   
   * dependencies do not leak into the compile include roots and link libraries of consumers, so they can never accidentally depend on a transitive dependency
   * faster compilation thanks to the reduced include roots and link libraries
   * fewer recompilations when implementation dependencies change since the consumer would not need to be recompiled
   
   == Conventions
   
   The Swift Library Plugin adds conventions for sources and tasks, shown below.
   
   === Project layout
   
   The Swift Library Plugin assumes the project layout shown below.
   None of these directories needs to exist or have anything in them.
   The Swift Library Plugin will compile whatever it finds and ignore anything missing.
   
   `src/main/swift`::
   Swift source with extension of `.swift`
   
   You <<building_swift_projects.adoc#sec:custom_swift_source_set_paths,configure the project layout>> by configuring the `source` on the `library` script block.
   
   
   === `compile__Variant__Swift` Task
   
   The Swift Library Plugin adds a link:{groovyDslPath}#[SwiftCompile] instance for each variant of the library component to build (e.g. `compileDebugSwift` and `compileReleaseSwift`).
   Read the <<building_swift_projects.adoc#sec:introducing_build_variants-swift,introduction to build variants>> for more information.
   Some of the most common configuration options are shown below.
   
   [horizontal]
   link:{groovyDslPath}#[compilerArgs]:: []
   
   link:{groovyDslPath}#[debuggable]:: `true`
   
   link:{groovyDslPath}#[modules]:: `configurations.swiftCompile__Variant__`
   
   link:{groovyDslPath}#[macros]:: []
   
   link:{groovyDslPath}#[objectFileDir]:: `layout.buildDirectory.dir("obj/main/__$variant__")`
   
   link:{groovyDslPath}#[optimized]:: `false` for debug build type or `true` otherwise
   
   link:{groovyDslPath}#[source]:: `library.swiftSource`
   
   link:{groovyDslPath}#[targetPlatform]:: derived from the `TargetMachine` of the binary
   
   link:{groovyDslPath}#[toolChain]:: <<building_swift_projects.adoc#sec:swift_supported_tool_chain,automatically selected based on target machine>>
   
   === `link__Variant__` Task
   
   The Swift Library Plugin adds a link:{groovyDslPath}#[LinkSharedLibrary] instance for each variant of the library containing shared linkage as a dimension - e.g. `linkDebug` and `linkRelease`.
   Read the <<building_swift_projects.adoc#sec:introducing_build_variants-swift,introduction to build variants>> for more information.
   Some of the most common configuration options are shown below.
   
   [horizontal]
   link:{groovyDslPath}#[debuggable]:: `true`
   
   link:{groovyDslPath}#[libs]:: `configurations.nativeLink__Variant__`
   
   link:{groovyDslPath}#[linkedFile]:: `layout.buildDirectory.dir("lib/main/__$variant__/libModule[.so|dylib]")`
   
   link:{groovyDslPath}#[linkerArgs]:: []
   
   link:{groovyDslPath}#[source]:: `compile__Variant__Swift.objects`
   
   link:{groovyDslPath}#[targetPlatform]:: derived from the `TargetMachine` of the binary
   
   link:{groovyDslPath}#[toolChain]:: <<building_swift_projects.adoc#sec:swift_supported_tool_chain,automatically selected based on target machine>>
   
   === `create__Variant__` Task
   
   The Swift Library Plugin adds a link:{groovyDslPath}#[CreateStaticLibrary] instance for each variant of the library containing static linkage as a dimension - e.g. `createDebug` and `createRelease`.
   Read the <<building_swift_projects.adoc#sec:introducing_build_variants-swift,introduction to build variants>> for more information.
   Some of the most common configuration options are shown below.
   
   [horizontal]
   link:{groovyDslPath}#[outputFile]:: `layout.buildDirectory.dir("lib/main/__$variant__/libModule.a")`
   
   link:{groovyDslPath}#[source]:: `compile__Variant__Swift.objects`
   
   link:{groovyDslPath}#[staticLibArgs]:: []
   
   link:{groovyDslPath}#[targetPlatform]:: derived from the `TargetMachine` of the binary
   
   link:{groovyDslPath}#[toolChain]:: <<building_swift_projects.adoc#sec:swift_supported_tool_chain,automatically selected based on target machine>>

/docs/userguide/native/xctest_plugin.adoc
=========================================

.. code-block::

   = XCTest
   
   WARNING: The XCTest Plugin is not compatible with the <<configuration_cache.adoc#config_cache:plugins:core,configuration cache>>.
   
   The XCTest Plugin provides the tasks, configurations and conventions for integrating with a https://developer.apple.com/documentation/xctest[XCTest testing framework on macOS] as well as https://github.com/apple/swift-corelibs-xctest[Linux's open source implementation].
   
   == Usage
   
   .Applying the XCTest Plugin
   ====
   include::sample[dir="snippets/swift/swiftXCTest/kotlin",files="build.gradle.kts[tags=apply-plugin]"]
   include::sample[dir="snippets/swift/swiftXCTest/groovy",files="build.gradle[tags=apply-plugin]"]
   ====
   
   == Build variants
   
   The XCTest Plugin understands the following dimensions.
   Read the <<building_swift_projects.adoc#sec:introducing_build_variants-swift,introduction to build variants>> for more information.
   
   Target machines - defaults to the tested component (if present) or build host (otherwise)::
   The target machine expresses which machines the application expects to run.
   A target machine is identified by its operating system and architecture.
   Gradle uses the target machine to decide which tool chain to choose based on availability on the host machine.
   
   The target machine can be configured as follows:
   
   .Configure application target machines
   ====
   include::sample[dir="snippets/swift/swiftXCTest/kotlin",files="build.gradle.kts[tags=configure-target-machines]"]
   include::sample[dir="snippets/swift/swiftXCTest/groovy",files="build.gradle[tags=configure-target-machines]"]
   ====
   
   == Tasks
   
   The following diagram shows the relationships between tasks added by this plugin.
   
   .XCTest Plugin default task graph
   image::xctest-task-graph.png[]
   
   === Variant-dependent Tasks
   
   The XCTest Plugin creates tasks based on the variants of the test component.
   Read the <<building_swift_projects.adoc#sec:introducing_build_variants-swift,introduction to build variants>> for more information.
   The following diagrams show the relationship between variant-dependent tasks.
   
   .XCTest Plugin variant-dependent task graph
   image::xctest-variant-task-graph.png[]
   
   `compileTest__Variant__Swift` (e.g. `compileTestSwift`)  - link:{groovyDslPath}#[SwiftCompile]::
   Depends on: All tasks that contribute source files to the compilation
   ::
   Compiles Swift source files using the selected compiler.
   
   `linkTest__Variant__` (e.g. `linkTest`) - link:{groovyDslPath}#[LinkMachOBundle] (on macOS) or link:{groovyDslPath}#[LinkExecutable] (on Linux)::
   Depends on: All tasks which contribute to the link executable, including `link__Variant__` and `create__Variant__` tasks from projects that are resolved via project dependencies and tested component
   ::
   Links executable from compiled object files using the selected linker.
   
   `installTest__Variant__` (e.g. `installTest`) - link:{groovyDslPath}#[InstallXCTestBundle] (on macOS) or link:{groovyDslPath}#[InstallExecutable] (on Linux)::
   Depends on: `linkTest__Variant__` and all tasks which contribute to the runtime of the executable, including `link__Variant__` tasks from projects that are resolved via project dependencies
   ::
   Installs the executable and all of it's runtime dependencies for easy execution.
   
   `xcTest__Variant__` (e.g. `xcTest`) - link:{groovyDslPath}#[XCTest]::
   Depends on: `installTest__Variant__`
   ::
   Run the installed executable.
   
   === Lifecycle Tasks
   
   The XCTest Plugin attaches some of its tasks to the standard lifecycle tasks documented in the <<base_plugin.adoc#base_plugin,Base Plugin chapter>>  which the XCTest Plugin applies automatically:
   
   `assemble` - Task (lifecycle)::
   Aggregate task that assembles the debug variant of the tested component for the current host (if present) in the project.
   For example, the <<swift_application_plugin.adoc#swift_application_plugin,Swift Application Plugin>> and <<swift_library_plugin.adoc#swift_library_plugin,Swift Library Plugin>> attach their link and create tasks to this lifecycle task.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   `test` - Task (lifecycle)::
   Depends on: `xcTest__Variant__` that most closely matches the build host
   ::
   Aggregate task of the variant that most closely match the build host for testing the component.
   
   `check` - Task (lifecycle)::
   Depends on: `test`
   ::
   Aggregate task that performs verification tasks, such as running the tests.
   Some plugins add their own verification task to `check`.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   `build` - Task (lifecycle)::
   Depends on: `check`, `assemble`
   ::
   Aggregate tasks that perform a full build of the project.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   `clean` - Delete::
   Deletes the build directory and everything in it, i.e. the path specified by the `layout.buildDirectory` project property.
   This task is added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   == Dependency management
   
   Just like the tasks created by the XCTest Plugin, the configurations are created based on the variant of the application component.
   Read the <<building_swift_projects.adoc#sec:introducing_build_variants-swift,introduction to build variants>> for more information.
   The following graph describes the configurations added by the XCTest Plugin:
   
   .XCTest Plugin configurations
   image::xctest-configurations.png[]
   
   * The configurations in white are the ones a user should use to declare dependencies
   * The configurations in blue, also known as resolvable denoted by \(R), are internal to the component, for its own use
   
   The following configurations are used to declare dependencies:
   
   `testImplementation`::
   Used for declaring implementation dependencies for all variants of the test component.
   This is where you should declare dependencies of any variants.
   Note this configuration inherit all dependencies declared on the tested component (library or application).
   
   `test__Variant__ExecutableImplementation` (e.g. `testExecutableImplementation`) extends `testImplementation`::
   Used for declaring implementation dependencies for a specific variant of the test component.
   This is where you should declare dependencies of the specific variant.
   
   
   There is no configurations that can be used by consumers for this plugin.
   
   The following configurations are used by the test component itself:
   
   `swiftCompileTest__Variant__` (e.g. `swiftCompileTest`) extends `test__Variant__ExecutableImplementation`::
   Used for compiling the test component.
   This configuration contains the compile module of the test component and is therefore used when invoking the Swift compiler to compile it.
   
   `nativeLinkTest__Variant__` (e.g. `nativeLinkTest`) extends `test__Variant__ExecutableImplementation`::
   Used for linking the test component.
   This configuration contains the libraries of the test component and is therefore used when invoking the Swift linker to link it.
   
   `nativeRuntimeTest__Variant__` (e.g. `nativeRuntimeTest`) extends `test__Variant__ExecutableImplementation`::
   Used for executing the test component.
   This configuration contains the runtime libraries of the test component.
   
   == Conventions
   
   The XCTest Plugin adds conventions for sources and tasks, shown below.
   
   === Project layout
   
   The XCTest Plugin assumes the project layout shown below.
   None of these directories needs to exist or have anything in them.
   The XCTest Plugin will compile whatever it finds, and handles anything which is missing.
   
   `src/test/swift`::
   Swift source with extension of `.swift`
   
   You <<building_swift_projects.adoc#sec:custom_swift_source_set_paths,configure the project layout>> by configuring the `source` on the `xctest` script block.
   
   === `compileTest__Variant__Swift` Task
   
   The XCTest Plugin adds a link:{groovyDslPath}#[SwiftCompile] instance for each variant of the test component to build (e.g. `compileTestSwift`).
   Read the <<building_swift_projects.adoc#sec:introducing_build_variants-swift,introduction to build variants>> for more information.
   Some of the most common configuration options are shown below.
   
   [horizontal]
   link:{groovyDslPath}#[compilerArgs]:: []
   
   link:{groovyDslPath}#[debuggable]:: `true`
   
   link:{groovyDslPath}#[modules]:: `configurations.swiftCompileTest__Variant__`
   
   link:{groovyDslPath}#[macros]:: []
   
   link:{groovyDslPath}#[objectFileDir]:: `layout.buildDirectory.dir("obj/test/__$variant__")`
   
   link:{groovyDslPath}#[optimized]:: `false`
   
   link:{groovyDslPath}#[source]:: `xctest.swiftSource`
   
   link:{groovyDslPath}#[targetPlatform]:: derived from the `TargetMachine` of the binary
   
   link:{groovyDslPath}#[toolChain]:: <<building_swift_projects.adoc#sec:swift_supported_tool_chain,automatically selected based on target machine>>
   
   === `linkTest__Variant__` Task
   
   The XCTest Plugin adds a link:{groovyDslPath}#[LinkMachOBundle] instance on macOS or link:{groovyDslPath}#[LinkExecutable] instance on Linux for each variant of the test component - e.g. `linkTest`.
   Read the <<building_swift_projects.adoc#sec:introducing_build_variants-swift,introduction to build variants>> for more information.
   Some of the most common configuration options are shown below.
   
   ==== macOS
   
   [horizontal]
   link:{groovyDslPath}#[debuggable]:: `true`
   
   link:{groovyDslPath}#[libs]:: `configurations.nativeLinkTest__Variant__`
   
   link:{groovyDslPath}#[linkedFile]:: `layout.buildDirectory.dir("exe/test/__$variant__/module")`
   
   link:{groovyDslPath}#[linkerArgs]:: []
   
   link:{groovyDslPath}#[source]:: `compile__Variant__Swift.objects` (if present) + `compileTest__Variant__Swift.objects`
   
   link:{groovyDslPath}#[targetPlatform]:: derived from the `TargetMachine` of the binary
   
   link:{groovyDslPath}#[toolChain]:: <<building_swift_projects.adoc#sec:swift_supported_tool_chain,automatically selected based on target machine>>
   
   ==== Linux
   
   [horizontal]
   link:{groovyDslPath}#[debuggable]:: `true`
   
   link:{groovyDslPath}#[libs]:: `configurations.nativeLinkTest__Variant__`
   
   link:{groovyDslPath}#[linkedFile]:: `layout.buildDirectory.dir("exe/test/__$variant__/baseName")`
   
   link:{groovyDslPath}#[linkerArgs]:: []
   
   link:{groovyDslPath}#[source]:: `compile__Variant__Swift.objects` (if present) + `compileTest__Variant__Swift.objects`
   
   link:{groovyDslPath}#[targetPlatform]:: derived from the `TargetMachine` of the binary
   
   link:{groovyDslPath}#[toolChain]:: <<building_swift_projects.adoc#sec:swift_supported_tool_chain,automatically selected based on target machine>>
   
   === `installTest__Variant__` Task
   
   The XCTest Plugin adds a link:{groovyDslPath}#[InstallXCTestBundle] instance on macOS or link:{groovyDslPath}#[InstallExecutable] instance on Linux for each variant of the test component - e.g. `installTest`.
   Read the <<building_swift_projects.adoc#sec:introducing_build_variants-swift,introduction to build variants>> for more information.
   There is no need to configure any properties on the task.
   
   === `xcTest__Variant__` Task
   
   The XCTest Plugin adds a link:{groovyDslPath}#[XCTest] instance for each variant of the test component - e.g. `xcTest`.
   Read the <<building_swift_projects.adoc#sec:introducing_build_variants-swift,introduction to build variants>> for more information.
   Some of the most common configuration options are shown below.
   
   [horizontal]
   link:{groovyDslPath}#[binResultDir]:: `layout.buildDirectory.dir("test-results/xctest/__$variant__/")`
   
   link:{groovyDslPath}#[ignoreFailures]:: `false`
   
   link:{groovyDslPath}#[reports]:: `layout.buildDirectory.dir("reports/tests/xctest/__$variant__/")` (HTML only)
   
   link:{groovyDslPath}#[runScriptFile]:: `layout.buildDirectory.dir("install/test/__$variant__/__${xctest.module}__")`
   
   link:{groovyDslPath}#[testInstallDirectory]:: `layout.buildDirectory.dir("install/test/__$variant__/")`
   
   link:{groovyDslPath}#[workingDirectory]:: `layout.buildDirectory.dir("install/test/__$variant__/")`

/Section: 游릭 Packaging and distribution
=========================================


/docs/userguide/core-plugins/war_plugin.adoc
============================================

.. code-block::

   = The War Plugin
   
   The War plugin extends the <<java_plugin.adoc#java_plugin,Java plugin>> to add support for assembling web application WAR files.
   It disables the default JAR archive generation of the Java plugin and adds a default WAR archive task.
   
   == Usage
   
   To use the War plugin, include the following in your build script:
   
   .Using the War plugin
   ====
   include::sample[dir="snippets/webApplication/quickstart/kotlin",files="build.gradle.kts[tags=use-war-plugin]"]
   include::sample[dir="snippets/webApplication/quickstart/groovy",files="build.gradle[tags=use-war-plugin]"]
   ====
   
   == Project layout
   
   In addition to the <<java_plugin.adoc#sec:java_project_layout,standard Java project layout>>, the War Plugin adds:
   
   `src/main/webapp`::
   Web application sources
   
   == Tasks
   
   The War plugin adds and modifies the following tasks:
   
   `war`  link:{groovyDslPath}#[War]::
   _Depends on_: `compile`
   +
   Assembles the application WAR file.
   
   `assemble` - _lifecycle task_::
   _Depends on_: `war`
   
   The War plugin adds the following dependencies to tasks added by the Java plugin;
   
   .War plugin - tasks
   image::warPluginTasks.png[]
   
   == Dependency management
   
   The War plugin adds two dependency configurations:
   
   `providedCompile`::
   This configuration should be used for dependencies required at compilation but which are provided by the environment in which the WAR is deployed.
   Dependencies declared here are thus visible to the `main` and `test` compilation classpaths.
   
   `providedRuntime`::
   This configuration should be used for dependencies required at runtime but which are provided by the environment in which the WAR is deployed.
   Dependencies declared here are only visible to the `main` and `test` runtime classpaths.
   
   
   [NOTE]
   ====
   It is important to note that these `provided` configurations work transitively.
   
   Let's say you add `commons-httpclient:commons-httpclient:3.0` to any of the provided configurations.
   This dependency has a dependency on `commons-codec`.
   Because this is a "provided" configuration, this means that neither of these dependencies will be added to your WAR, even if the `commons-codec` library is an explicit dependency of your `implementation` configuration.
   
   If you don't want this transitive behavior, simply declare your `provided` dependencies like `commons-httpclient:commons-httpclient:3.0@jar`.
   ====
   
   == Publishing
   
   `components.web`::
   A link:{javadocPath}#[SoftwareComponent] for <<publishing_setup.adoc#publishing_overview,publishing>> the production WAR created by the `war` task.
   
   == Convention properties (deprecated)
   
   `webAppDirName` 댹`String`::
   _Default value_: `src/main/webapp`
   +
   The name of the web application source directory, relative to the project directory.
   
   `webAppDir` 댹(read-only) `File`::
   _Default value_: `$webAppDirName`, e.g. _src/main/webapp_
   +
   The path to the web application source directory.
   
   These properties are provided by a link:{groovyDslPath}#[WarPluginConvention] object.
   
   Configuring war tasks via convention properties is **deprecated**. If you need to set default values the `war` task then configure the task directly. If you want to configure all tasks of type `War` in the project then use link:{javadocPath}#[tasks.withType(War.class).configureEach(...)].
   
   == War
   
   The default behavior of the `War` task is to copy the content of `src/main/webapp` to the root of the archive. Your `webapp` directory may of course contain a `WEB-INF` sub-directory, which may contain a `web.xml` file. Your compiled classes are compiled to `WEB-INF/classes`. All the dependencies of the `runtime` footnote:[The `runtime` configuration extends the `compile` configuration.] configuration are copied to `WEB-INF/lib`.
   
   The link:{groovyDslPath}#[War] class in the API documentation has additional useful information.
   
   == Customizing
   
   Here is an example with the most important customization options:
   
   .Customization of war plugin
   ====
   include::sample[dir="snippets/webApplication/customized/kotlin",files="build.gradle.kts[tags=customization]"]
   include::sample[dir="snippets/webApplication/customized/groovy",files="build.gradle[tags=customization]"]
   ====
   
   Of course one can configure the different file-sets with a closure to define excludes and includes.

/docs/userguide/core-plugins/ear_plugin.adoc
============================================

.. code-block::

   = The Ear Plugin
   
   The Ear plugin adds support for assembling web application EAR files.
   It adds a default EAR archive task.
   It doesn't require the <<java_plugin.adoc#java_plugin,Java plugin>>, but for projects that also use the Java plugin it disables the default JAR archive generation.
   
   
   == Usage
   
   To use the Ear plugin, include the following in your build script:
   
   .Using the Ear plugin
   ====
   include::sample[dir="snippets/ear/earWithWar/kotlin",files="build.gradle.kts[tags=use-ear-plugin]"]
   include::sample[dir="snippets/ear/earWithWar/groovy",files="build.gradle[tags=use-ear-plugin]"]
   ====
   
   == Tasks
   
   The Ear plugin adds the following tasks to the project.
   
   `ear`  link:{groovyDslPath}#[Ear]::
   _Depends on_: `compile` (only if the Java plugin is also applied)
   +
   Assembles the application EAR file.
   
   === Dependencies added to other tasks
   
   The Ear plugin adds the following dependencies to tasks added by the <<base_plugin.adoc#base_plugin,Base Plugin>>.
   
   `assemble`::
   _Depends on_: `ear`.
   
   
   == Project layout
   
   ----
   .
   較덕較 src
       較덕較 main
           較덕較 application // <1>
   ----
   <1> Ear resources, such as a META-INF directory
   
   
   == Dependency management
   
   The Ear plugin adds two dependency configurations: `deploy` and `earlib`. All dependencies in the `deploy` configuration are placed in the root of the EAR archive, and are _not_ transitive. All dependencies in the `earlib` configuration are placed in the 'lib' directory in the EAR archive and _are_ transitive.
   
   == Convention properties (ear)
   
   `appDirName`  `String`::
   The name of the application source directory, relative to the project directory. _Default value: `src/main/application`_.
   
   `libDirName`  `String`::
   The name of the lib directory inside the generated EAR. _Default value: `lib`_.
   
   `deploymentDescriptor`  link:{javadocPath}#[DeploymentDescriptor]::
   Metadata to generate a deployment descriptor file, e.g. `application.xml`. _Default value: A deployment descriptor with sensible defaults named `application.xml`_. If this file already exists in the `appDirName/META-INF` then the existing file contents will be used and the explicit configuration in the `ear.deploymentDescriptor` will be ignored.
   
   `generateDeploymentDescriptor`  `Boolean`::
   Specifies if deploymentDescriptor should be generated. _Default value: `true`_.
   
   These properties are provided by a link:{groovyDslPath}#[EarPluginConvention] convention object.
   
   Configuring the ear tasks via the plugin's convention properties is **deprecated**. If you need to change from the default values, configure the appropriate tasks directly. If you want to configure all `Ear` tasks in the project, use  link:{javadocPath}#[tasks.withType(Ear.class).configureEach(...)].
   
   == Ear
   
   The default behavior of the Ear task is to copy the content of `src/main/application` to the root of the archive. If your `application` directory doesn't contain a `META-INF/application.xml` deployment descriptor then one will be generated for you.
   
   The link:{groovyDslPath}#[Ear] class in the API documentation has additional useful information.
   
   == Customizing
   
   Here is an example with the most important customization options:
   
   .Customization of ear plugin
   ====
   include::sample[dir="snippets/ear/earCustomized/kotlin/ear",files="build.gradle.kts[]"]
   include::sample[dir="snippets/ear/earCustomized/groovy/ear",files="build.gradle[]"]
   ====
   
   You can also use customization options that the link:{groovyDslPath}#[Ear] task provides, such as `from` and `metaInf`.
   
   == Using custom descriptor file
   
   You may already have appropriate settings in a `application.xml` file and want to use that instead of configuring the `ear.deploymentDescriptor` section of the build script. To accommodate that goal, place the `META-INF/application.xml` in the right place inside your source folders (see the `appDirName` property). The file contents will be used and the explicit configuration in the `ear.deploymentDescriptor` will be ignored.

/docs/userguide/dep-man/06-publishing/publishing_maven.adoc
===========================================================

.. code-block::

   = The Maven Publish Plugin
   
   The Maven Publish Plugin provides the ability to publish build artifacts to an https://maven.apache.org/[Apache Maven] repository.
   A module published to a Maven repository can be consumed by Maven, Gradle (see <<declaring_dependencies.adoc#declaring-dependencies,Declaring Dependencies>>) and other tools that understand the Maven repository format.
   You can learn about the fundamentals of publishing in <<publishing_setup.adoc#publishing_overview,Publishing Overview>>.
   
   
   == Usage
   
   To use the Maven Publish Plugin, include the following in your build script:
   
   .Applying the Maven Publish Plugin
   ====
   include::sample[dir="snippets/maven-publish/quickstart/kotlin",files="build.gradle.kts[tags=use-plugin]"]
   include::sample[dir="snippets/maven-publish/quickstart/groovy",files="build.gradle[tags=use-plugin]"]
   ====
   
   The Maven Publish Plugin uses an extension on the project named `publishing` of type link:{groovyDslPath}#[PublishingExtension]. This extension provides a container of named publications and a container of named repositories. The Maven Publish Plugin works with link:{groovyDslPath}#[MavenPublication] publications and link:{groovyDslPath}#[MavenArtifactRepository] repositories.
   
   == Tasks
   
   `generatePomFileFor__PubName__Publication`  link:{groovyDslPath}#[GenerateMavenPom]::
   Creates a POM file for the publication named _PubName_, populating the known metadata such as project name, project version, and the dependencies. The default location for the POM file is _build/publications/$pubName/pom-default.xml_.
   
   `publish__PubName__PublicationTo__RepoName__Repository`  link:{groovyDslPath}#[PublishToMavenRepository]::
   Publishes the _PubName_ publication to the repository named _RepoName_. If you have a repository definition without an explicit name, _RepoName_ will be "Maven".
   
   `publish__PubName__PublicationToMavenLocal`  link:{javadocPath}#[PublishToMavenLocal]::
   Copies the _PubName_ publication to the local Maven cache 댹맚ypically _<home directory of the current user>/.m2/repository_ 댹마long with the publication's POM file and other metadata.
   
   `publish`::
   _Depends on_: All `publish__PubName__PublicationTo__RepoName__Repository` tasks
   +
   An aggregate task that publishes all defined publications to all defined repositories. It does _not_ include copying publications to the local Maven cache.
   
   `publishToMavenLocal`::
   _Depends on_: All `publish__PubName__PublicationToMavenLocal` tasks
   +
   Copies all defined publications to the local Maven cache, including their metadata (POM files, etc.).
   
   
   == Publications
   
   This plugin provides <<dependency_management_terminology.adoc#sub:terminology_publication,publications>> of type link:{groovyDslPath}#[MavenPublication]. To learn how to define and use publications, see the section on <<publishing_setup.adoc#sec:basic_publishing,basic publishing>>.
   
   There are four main things you can configure in a Maven publication:
   
    * A <<dependency_management_terminology.adoc#sub:terminology_component,component>> 댹맜ia link:{groovyDslPath}#[MavenPublication.from(org.gradle.api.component.SoftwareComponent)].
    * <<publishing_customization.adoc#sec:publishing_custom_artifacts_to_maven,Custom artifacts>> 댹맜ia the link:{groovyDslPath}#[MavenPublication.artifact(java.lang.Object)] method. See link:{groovyDslPath}#[MavenArtifact] for the available configuration options for custom Maven artifacts.
    * Standard metadata like `artifactId`, `groupId` and `version`.
    * Other contents of the POM file 댹맜ia link:{groovyDslPath}#[MavenPublication.pom(org.gradle.api.Action)].
   
   You can see all of these in action in the <<#publishing_maven:complete_example,complete publishing example>>. The API documentation for `MavenPublication` has additional code samples.
   
   === Identity values in the generated POM
   
   The attributes of the generated POM file will contain identity values derived from the following project properties:
   
   * `groupId` - link:{groovyDslPath}#[Project.getGroup()]
   * `artifactId` - link:{groovyDslPath}#[Project.getName()]
   * `version` - link:{groovyDslPath}#[Project.getVersion()]
   
   Overriding the default identity values is easy: simply specify the `groupId`, `artifactId` or `version` attributes when configuring the link:{groovyDslPath}#[MavenPublication].
   
   .Customizing the publication identity
   ====
   include::sample[dir="snippets/maven-publish/customize-identity/kotlin/library",files="build.gradle.kts[tags=customize-identity]"]
   include::sample[dir="snippets/maven-publish/customize-identity/groovy/library",files="build.gradle[tags=customize-identity]"]
   ====
   
   TIP: Certain repositories will not be able to handle all supported characters. For example, the `:` character cannot be used as an identifier when publishing to a filesystem-backed repository on Windows.
   
   Maven restricts `groupId` and `artifactId` to a limited character set (`[A-Za-z0-9_\\-.]+`) and Gradle enforces this restriction. For `version` (as well as the artifact `extension` and `classifier` properties), Gradle will handle any valid Unicode character.
   
   The only Unicode values that are explicitly prohibited are `\`, `/` and any ISO control character. Supplied values are validated early in publication.
   
   === Customizing the generated POM
   
   The generated POM file can be customized before publishing. For example, when publishing a library to Maven Central you will need to set certain metadata. The Maven Publish Plugin provides a DSL for that purpose. Please see link:{groovyDslPath}#[MavenPom] in the DSL Reference for the complete documentation of available properties and methods. The following sample shows how to use the most common ones:
   
   .Customizing the POM file
   ====
   include::sample[dir="snippets/signing/maven-publish/kotlin",files="build.gradle.kts[tags=pom-customization]"]
   include::sample[dir="snippets/signing/maven-publish/groovy",files="build.gradle[tags=pom-customization]"]
   ====
   
   === Customizing dependencies versions
   
   Two strategies are supported for publishing dependencies:
   
   Declared versions (default)::
   This strategy publishes the versions that are defined by the build script author with the dependency declarations in the `dependencies` block.
   Any other kind of processing, for example through <<resolution_rules.adoc#resolution_rules,a rule changing the resolved version>>, will not be taken into account for the publication.
   
   Resolved versions::
   This strategy publishes the versions that were resolved during the build, possibly by applying resolution rules and automatic conflict resolution.
   This has the advantage that the published versions correspond to the ones the published artifact was tested against.
   
   Example use cases for resolved versions:
   
   * A project uses dynamic versions for dependencies but prefers exposing the resolved version for a given release to its consumers.
   * In combination with <<dependency_locking.adoc#dependency-locking,dependency locking>>, you want to publish the locked versions.
   * A project leverages the rich versions constraints of Gradle, which have a lossy conversion to Maven.
   Instead of relying on the conversion, it publishes the resolved versions.
   
   This is done by using the `versionMapping` DSL method which allows to configure the link:{javadocPath}#[VersionMappingStrategy]:
   
   .Using resolved versions
   ====
   include::sample[dir="snippets/signing/maven-publish/kotlin",files="build.gradle.kts[tags=versions-resolved]"]
   include::sample[dir="snippets/signing/maven-publish/groovy",files="build.gradle[tags=versions-resolved]"]
   ====
   
   In the example above, Gradle will use the versions resolved on the `runtimeClasspath` for dependencies declared in `api`, which are mapped to the `compile` scope of Maven.
   Gradle will also use the versions resolved on the `runtimeClasspath` for dependencies declared in `implementation`, which are mapped to the `runtime` scope of Maven.
   `fromResolutionResult()` indicates that Gradle should use the default classpath of a variant and `runtimeClasspath` is the default classpath of `java-runtime`.
   
   == Repositories
   
   This plugin provides <<dependency_management_terminology.adoc#sub:terminology_repository,repositories>> of type link:{groovyDslPath}#[MavenArtifactRepository]. To learn how to define and use repositories for publishing, see the section on <<publishing_setup.adoc#sec:basic_publishing,basic publishing>>.
   
   Here's a simple example of defining a publishing repository:
   
   .Declaring repositories to publish to
   ====
   include::sample[dir="snippets/maven-publish/quickstart/kotlin",files="build.gradle.kts[tags=repositories]"]
   include::sample[dir="snippets/maven-publish/quickstart/groovy",files="build.gradle[tags=repositories]"]
   ====
   
   The two main things you will want to configure are the repository's:
   
    * URL (required)
    * Name (optional)
   
   You can define multiple repositories as long as they have unique names within the build script. You may also declare one (and only one) repository without a name. That repository will take on an implicit name of "Maven".
   
   You can also configure any authentication details that are required to connect to the repository. See link:{groovyDslPath}#[MavenArtifactRepository] for more details.
   
   === Snapshot and release repositories
   
   It is a common practice to publish snapshots and releases to different Maven repositories. A simple way to accomplish this is to configure the repository URL based on the project version. The following sample uses one URL for versions that end with "SNAPSHOT" and a different URL for the rest:
   
   .Configuring repository URL based on project version
   ====
   include::sample[dir="snippets/maven-publish/javaProject/kotlin",files="build.gradle.kts[tags=repo-url-from-variable]"]
   include::sample[dir="snippets/maven-publish/javaProject/groovy",files="build.gradle[tags=repo-url-from-variable]"]
   ====
   
   Similarly, you can use a <<build_environment.adoc#build_environment, project or system property>> to decide which repository to publish to. The following example uses the release repository if the project property `release` is set, such as when a user runs `gradle -Prelease publish`:
   
   .Configuring repository URL based on project property
   ====
   include::sample[dir="snippets/maven-publish/javaProject/kotlin",files="build.gradle.kts[tags=repo-url-from-project-property]"]
   include::sample[dir="snippets/maven-publish/javaProject/groovy",files="build.gradle[tags=repo-url-from-project-property]"]
   ====
   
   == Publishing to Maven Local
   
   For integration with a local Maven installation, it is sometimes useful to publish the module into the Maven local repository (typically at _<home directory of the current user>/.m2/repository_), along with its POM file and other metadata. In Maven parlance, this is referred to as 'installing' the module.
   
   The Maven Publish Plugin makes this easy to do by automatically creating a link:{javadocPath}#[PublishToMavenLocal] task for each link:{groovyDslPath}#[MavenPublication] in the `publishing.publications` container. The task name follows the pattern of `publish__PubName__PublicationToMavenLocal`. Each of these tasks is wired into the `publishToMavenLocal` aggregate task. You do not need to have `mavenLocal()` in your `publishing.repositories` section.
   
   == Publishing Maven relocation information
   
   When a project changes the `groupId` or `artifactId` (the _coordinates_) of an artifact it publishes, it is important to let users know where the new artifact can be found. Maven can help with that through the _relocation_ feature. The way this works is that a project publishes an additional artifact under the old coordinates consisting only of a minimal _relocation POM_; that POM file specifies where the new artifact can be found. Maven repository browsers and build tools can then inform the user that the coordinates of an artifact have changed.
   
   For this, a project adds an additional `MavenPublication` specifying a link:{groovyDslPath}#[MavenPomRelocation]:
   
   .Specifying a relocation POM
   ====
   include::sample[dir="snippets/maven-publish/specify-relocation/kotlin/library",files="build.gradle.kts[tags=specify-relocation]"]
   include::sample[dir="snippets/maven-publish/specify-relocation/groovy/library",files="build.gradle[tags=specify-relocation]"]
   ====
   
   Only the property which has changed needs to be specified under `relocation`, that is `artifactId` and / or `groupId`. All other properties are optional.
   
   [TIP]
   ====
   Specifying the `version` can be useful when the new artifact has a different version, for example because version numbering has started at 1.0.0 again.
   
   A custom `message` allows explaining why the artifact coordinates have changed.
   ====
   
   The relocation POM should be created for what would be the next version of the old artifact. For example when the artifact coordinates of `com.example:lib:1.0.0` are changed and the artifact with the new coordinates continues version numbering and is published as `com.new-example:lib:2.0.0`, then the relocation POM should specify a relocation from `com.example:lib:2.0.0` to `com.new-example:lib:2.0.0`.
   
   A relocation POM only has to be published once, the build file configuration for it should be removed again once it has been published.
   
   Note that a relocation POM is not suitable for all situations; when an artifact has been split into two or more separate artifacts then a relocation POM might not be helpful.
   
   === Retroactively publishing relocation information
   
   It is possible to publish relocation information retroactively after the coordinates of an artifact have changed in the past, and no relocation information was published back then.
   
   The same recommendations as described above apply. To ease migration for users, it is important to pay attention to the `version` specified in the relocation POM. The relocation POM should allow the user to move to the new artifact in one step, and then allow them to update to the latest version in a separate step. For example when for the coordinates of `com.new-example:lib:5.0.0` were changed in version 2.0.0, then ideally the relocation POM should be published for the old coordinates `com.example:lib:2.0.0` relocating to `com.new-example:lib:2.0.0`. The user can then switch from `com.example:lib` to `com.new-example` and then separately update from version 2.0.0 to 5.0.0, handling breaking changes (if any) step by step.
   
   When relocation information is published retroactively, it is not necessary to wait for next regular release of the project, it can be published in the meantime. As mentioned above, the relocation information should then be removed again from the build file once the relocation POM has been published.
   
   === Avoiding duplicate dependencies
   
   When only the coordinates of the artifact have changed, but package names of the classes inside the artifact have remained the same, dependency conflicts can occur. A project might (transitively) depend on the old artifact but at the same time also have a dependency on the new artifact which both contain the same classes, potentially with incompatible changes.
   
   To detect such conflicting duplicate dependencies, <<dependency_capability_conflict.adoc#sub:declaring-component-capabilities,capabilities>> can be published as part of the <<publishing_gradle_module_metadata.adoc#sec:understanding-gradle-module-md,Gradle Module Metadata>>.  For an example using a <<java_library_plugin.adoc#java_library_plugin,Java Library>> project, see <<component_capabilities.adoc#sec:declaring-additional-capabilities-for-a-local-component,declaring additional capabilities for a local component>>.
   
   === Performing a dry run
   
   To verify that relocation information works as expected before publishing it to a remote repository, it can first be <<#publishing_maven:install,published to the local Maven repository>>. Then a local test Gradle or Maven project can be created which has the relocation artifact as dependency.
   
   == Complete example
   
   The following example demonstrates how to sign and publish a Java library including sources, Javadoc, and a customized POM:
   
   .Publishing a Java library
   ====
   include::sample[dir="snippets/signing/maven-publish/kotlin",files="build.gradle.kts[tags=all]"]
   include::sample[dir="snippets/signing/maven-publish/groovy",files="build.gradle[tags=all]"]
   ====
   
   The result is that the following artifacts will be published:
   
   * The POM: `my-library-1.0.pom`
   * The primary JAR artifact for the Java component: `my-library-1.0.jar`
   * The sources JAR artifact that has been explicitly configured: `my-library-1.0-sources.jar`
   * The Javadoc JAR artifact that has been explicitly configured: `my-library-1.0-javadoc.jar`
   
   The <<signing_plugin.adoc#signing_plugin, Signing Plugin>> is used to generate a signature file for each artifact. In addition, checksum files will be generated for all artifacts and signature files.
   
   TIP: publishToMavenLocal` does not create checksum files in `$USER_HOME/.m2/repository`.
   If you want to verify that the checksum files are created correctly, or use them for later publishing, consider configuring a <<declaring_repositories.adoc#sec:maven_repo,custom Maven repository>> with a `file://` URL and using that as the publishing target instead.
   
   == Removal of deferred configuration behavior
   
   Prior to Gradle 5.0, the `publishing {}` block was (by default) implicitly treated as if all the logic inside it was executed after the project is evaluated.
   This behavior caused quite a bit of confusion and was deprecated in Gradle 4.8, because it was the only block that behaved that way.
   
   You may have some logic inside your publishing block or in a plugin that is depending on the deferred configuration behavior.
   For instance, the following logic assumes that the subprojects will be evaluated when the artifactId is set:
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   subprojects {
       publishing {
           publications {
               create<MavenPublication>("mavenJava") {
                   from(components["java"])
                   artifactId = tasks.jar.get().archiveBaseName.get()
               }
           }
       }
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   subprojects {
       publishing {
           publications {
               mavenJava(MavenPublication) {
                   from components.java
                   artifactId = jar.archiveBaseName
               }
           }
       }
   }
   ----
   =====
   ====
   
   This kind of logic must now be wrapped in an `afterEvaluate {}` block.
   
   
   ====
   [.multi-language-sample]
   =====
   .build.gradle.kts
   [source,kotlin]
   ----
   subprojects {
       publishing {
           publications {
               create<MavenPublication>("mavenJava") {
                   from(components["java"])
                   afterEvaluate {
                       artifactId = tasks.jar.get().archiveBaseName.get()
                   }
               }
           }
       }
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .build.gradle
   [source,groovy]
   ----
   subprojects {
       publishing {
           publications {
               mavenJava(MavenPublication) {
                   from components.java
                   afterEvaluate {
                       artifactId = jar.archiveBaseName
                   }
               }
           }
       }
   }
   ----
   =====
   ====

/docs/userguide/dep-man/06-publishing/publishing_ivy.adoc
=========================================================

.. code-block::

   = The Ivy Publish Plugin
   
   The Ivy Publish Plugin provides the ability to publish build artifacts in the http://ant.apache.org/ivy/[Apache Ivy] format, usually to a repository for consumption by other builds or projects. What is published is one or more artifacts created by the build, and an Ivy _module descriptor_ (normally `ivy.xml`) that describes the artifacts and the dependencies of the artifacts, if any.
   
   A published Ivy module can be consumed by Gradle (see <<declaring_dependencies.adoc#declaring-dependencies,Declaring Dependencies>>) and other tools that understand the Ivy format. You can learn about the fundamentals of publishing in <<publishing_setup.adoc#publishing_overview,Publishing Overview>>.
   
   == Usage
   
   To use the Ivy Publish Plugin, include the following in your build script:
   
   .Applying the Ivy Publish Plugin
   ====
   include::sample[dir="snippets/ivy-publish/quickstart/kotlin",files="build.gradle.kts[tags=use-plugin]"]
   include::sample[dir="snippets/ivy-publish/quickstart/groovy",files="build.gradle[tags=use-plugin]"]
   ====
   
   The Ivy Publish Plugin uses an extension on the project named `publishing` of type link:{groovyDslPath}#[PublishingExtension]. This extension provides a container of named publications and a container of named repositories. The Ivy Publish Plugin works with link:{groovyDslPath}#[IvyPublication] publications and link:{groovyDslPath}#[IvyArtifactRepository] repositories.
   
   == Tasks
   
   `generateDescriptorFileFor__PubName__Publication`  link:{groovyDslPath}#[GenerateIvyDescriptor]::
   Creates an Ivy descriptor file for the publication named _PubName_, populating the known metadata such as project name, project version, and the dependencies. The default location for the descriptor file is _build/publications/$pubName/ivy.xml_.
   
   `publish__PubName__PublicationTo__RepoName__Repository`  link:{groovyDslPath}#[PublishToIvyRepository]::
   Publishes the _PubName_ publication to the repository named _RepoName_. If you have a repository definition without an explicit name, _RepoName_ will be "Ivy".
   
   `publish`::
   _Depends on_: All `publish__PubName__PublicationTo__RepoName__Repository` tasks
   +
   An aggregate task that publishes all defined publications to all defined repositories.
   
   == Publications
   
   This plugin provides <<dependency_management_terminology.adoc#sub:terminology_publication,publications>> of type link:{groovyDslPath}#[IvyPublication]. To learn how to define and use publications, see the section on <<publishing_setup.adoc#sec:basic_publishing,basic publishing>>.
   
   There are four main things you can configure in an Ivy publication:
   
    * A <<dependency_management_terminology.adoc#sub:terminology_component,component>> 댹맜ia link:{groovyDslPath}#[IvyPublication.from(org.gradle.api.component.SoftwareComponent)].
    * <<publishing_customization.adoc#sec:publishing_custom_artifacts_to_maven,Custom artifacts>> 댹맜ia the link:{groovyDslPath}#[IvyPublication.artifact(java.lang.Object)] method. See link:{groovyDslPath}#[IvyArtifact] for the available configuration options for custom Ivy artifacts.
    * Standard metadata like `module`, `organisation` and `revision`.
    * Other contents of the module descriptor 댹맜ia link:{groovyDslPath}#[IvyPublication.descriptor(org.gradle.api.Action)].
   
   You can see all of these in action in the <<#publishing_ivy:example,complete publishing example>>. The API documentation for `IvyPublication` has additional code samples.
   
   === Identity values for the published project
   
   The generated Ivy module descriptor file contains an `&lt;info&gt;` element that identifies the module. The default identity values are derived from the following:
   
   * `organisation` - link:{groovyDslPath}#[Project.getGroup()]
   * `module` - link:{groovyDslPath}#[Project.getName()]
   * `revision` - link:{groovyDslPath}#[Project.getVersion()]
   * `status` - link:{groovyDslPath}#[Project.getStatus()]
   * `branch` - (not set)
   
   Overriding the default identity values is easy: simply specify the `organisation`, `module` or `revision` properties when configuring the link:{groovyDslPath}#[IvyPublication]. `status` and `branch` can be set via the `descriptor` property  see link:{groovyDslPath}#[IvyModuleDescriptorSpec].
   
   The `descriptor` property can also be used to add additional custom elements as children of the `&lt;info&gt;` element, like so:
   
   .customizing the publication identity
   ====
   include::sample[dir="snippets/ivy-publish/customize-identity/kotlin",files="build.gradle.kts[tags=customize-identity]"]
   include::sample[dir="snippets/ivy-publish/customize-identity/groovy",files="build.gradle[tags=customize-identity]"]
   ====
   
   TIP: Certain repositories are not able to handle all supported characters. For example, the `:` character cannot be used as an identifier when publishing to a filesystem-backed repository on Windows.
   
   Gradle will handle any valid Unicode character for `organisation`, `module` and `revision` (as well as the artifact's `name`, `extension` and `classifier`). The only values that are explicitly prohibited are `\`, `/` and any ISO control character. The supplied values are validated early during publication.
   
   === Customizing the generated module descriptor
   
   At times, the module descriptor file generated from the project information will need to be tweaked before publishing. The Ivy Publish Plugin provides a DSL for that purpose. Please see link:{groovyDslPath}#[IvyModuleDescriptorSpec] in the DSL Reference for the complete documentation of available properties and methods.
   
   The following sample shows how to use the most common aspects of the DSL:
   
   .Customizing the module descriptor file
   ====
   include::sample[dir="snippets/ivy-publish/descriptor-customization/kotlin",files="build.gradle.kts[tags=customize-descriptor]"]
   include::sample[dir="snippets/ivy-publish/descriptor-customization/groovy",files="build.gradle[tags=customize-descriptor]"]
   ====
   
   In this example we are simply adding a 'description' element to the generated Ivy dependency descriptor, but this hook allows you to modify any aspect of the generated descriptor. For example, you could replace the version range for a dependency with the actual version used to produce the build.
   
   You can also add arbitrary XML to the descriptor file via link:{groovyDslPath}#[IvyModuleDescriptorSpec.withXml(org.gradle.api.Action)], but you cannot use it to modify any part of the module identifier (organisation, module, revision).
   
   CAUTION: It is possible to modify the descriptor in such a way that it is no longer a valid Ivy module descriptor, so care must be taken when using this feature.
   
   === Customizing dependencies versions
   
   Two strategies are supported for publishing dependencies:
   
   Declared versions (default)::
   This strategy publishes the versions that are defined by the build script author with the dependency declarations in the `dependencies` block.
   Any other kind of processing, for example through <<resolution_rules.adoc#resolution_rules,a rule changing the resolved version>>, will not be taken into account for the publication.
   
   Resolved versions::
   This strategy publishes the versions that were resolved during the build, possibly by applying resolution rules and automatic conflict resolution.
   This has the advantage that the published versions correspond to the ones the published artifact was tested against.
   
   Example use cases for resolved versions:
   
   * A project uses dynamic versions for dependencies but prefers exposing the resolved version for a given release to its consumers.
   * In combination with <<dependency_locking.adoc#dependency-locking,dependency locking>>, you want to publish the locked versions.
   * A project leverages the rich versions constraints of Gradle, which have a lossy conversion to Ivy.
   Instead of relying on the conversion, it publishes the resolved versions.
   
   This is done by using the `versionMapping` DSL method which allows to configure the link:{javadocPath}#[VersionMappingStrategy]:
   
   .Using resolved versions
   ====
   include::sample[dir="snippets/ivy-publish/descriptor-customization/kotlin",files="build.gradle.kts[tags=versions-resolved]"]
   include::sample[dir="snippets/ivy-publish/descriptor-customization/groovy",files="build.gradle[tags=versions-resolved]"]
   ====
   
   In the example above, Gradle will use the versions resolved on the `runtimeClasspath` for dependencies declared in `api`, which are mapped to the `compile` configuration of Ivy.
   Gradle will also use the versions resolved on the `runtimeClasspath` for dependencies declared in `implementation`, which are mapped to the `runtime` configuration of Ivy.
   `fromResolutionResult()` indicates that Gradle should use the default classpath of a variant and `runtimeClasspath` is the default classpath of `java-runtime`.
   
   == Repositories
   
   This plugin provides <<dependency_management_terminology.adoc#sub:terminology_repository,repositories>> of type link:{groovyDslPath}#[IvyArtifactRepository]. To learn how to define and use repositories for publishing, see the section on <<publishing_setup.adoc#sec:basic_publishing,basic publishing>>.
   
   Here's a simple example of defining a publishing repository:
   
   .Declaring repositories to publish to
   ====
   include::sample[dir="snippets/ivy-publish/quickstart/kotlin",files="build.gradle.kts[tags=repositories]"]
   include::sample[dir="snippets/ivy-publish/quickstart/groovy",files="build.gradle[tags=repositories]"]
   ====
   
   The two main things you will want to configure are the repository's:
   
    * URL (required)
    * Name (optional)
   
   You can define multiple repositories as long as they have unique names within the build script. You may also declare one (and only one) repository without a name. That repository will take on an implicit name of "Ivy".
   
   You can also configure any authentication details that are required to connect to the repository. See link:{groovyDslPath}#[IvyArtifactRepository] for more details.
   
   
   == Complete example
   
   The following example demonstrates publishing with a multi-project build.
   Each project publishes a Java component configured to also build and publish Javadoc and source code artifacts.
   The descriptor file is customized to include the project description for each project.
   
   .Publishing a Java module
   ====
   include::sample[dir="snippets/ivy-publish/java-multi-project/kotlin",files="settings.gradle.kts[];buildSrc/build.gradle.kts[];buildSrc/src/main/kotlin/myproject.publishing-conventions.gradle.kts[];project1/build.gradle.kts[];project2/build.gradle.kts[]"]
   include::sample[dir="snippets/ivy-publish/java-multi-project/groovy",files="settings.gradle[];buildSrc/build.gradle[];buildSrc/src/main/groovy/myproject.publishing-conventions.gradle[];project1/build.gradle[];project2/build.gradle[]"]
   ====
   
   The result is that the following artifacts will be published for each project:
   
   * The Gradle Module Metadata file: `project1-1.0.module`.
   * The Ivy module metadata file: `ivy-1.0.xml`.
   * The primary JAR artifact for the Java component: `project1-1.0.jar`.
   * The Javadoc and sources JAR artifacts of the Java component (because we configured `withJavadocJar()` and `withSourcesJar()`): `project1-1.0-javadoc.jar`, `project1-1.0-source.jar`.

/docs/userguide/core-plugins/distribution_plugin.adoc
=====================================================

.. code-block::

   = The Distribution Plugin
   
   The Distribution Plugin facilitates building archives that serve as distributions of the project. Distribution archives typically contain the executable application and other supporting files, such as documentation.
   
   
   == Usage
   
   To use the Distribution Plugin, include the following in your build script:
   
   .Using the Distribution Plugin
   ====
   include::sample[dir="snippets/base/distribution/kotlin",files="build.gradle.kts[tags=use-plugin]"]
   include::sample[dir="snippets/base/distribution/groovy",files="build.gradle[tags=use-plugin]"]
   ====
   
   The plugin adds an extension named `distributions` of type link:{groovyDslPath}#[DistributionContainer] to the project. It also creates a single distribution in the distributions container extension named `main`. If your build only produces one distribution you only need to configure this distribution (or use the defaults).
   
   You can run `gradle distZip` to package the main distribution as a ZIP, or `gradle distTar` to create a TAR file. To build both types of archives just run `gradle assembleDist`.
   The files will be created at `__layout.buildDirectory.dir__("distributions/__${project.name}__-__${project.version}__.__춺ext췉__")`.
   
   You can run `gradle installDist` to assemble the uncompressed distribution into `__layout.buildDirectory.dir__("install/__${project.name}__")`.
   
   == Tasks
   
   The Distribution Plugin adds a number of tasks to your project, as shown below.
   
   `distZip`  link:{groovyDslPath}#[Zip]::
   Creates a ZIP archive of the distribution contents.
   
   `distTar`  link:{groovyDslPath}#[Task]::
   Creates a TAR archive of the distribution contents.
   
   `assembleDist`  link:{groovyDslPath}#[Task]::
   _Depends on_: `distTar`, `distZip`
   +
   Creates ZIP and TAR archives of the distribution contents.
   
   `installDist`  link:{groovyDslPath}#[Sync]::
   Assembles the distribution content and installs it on the current machine.
   
   For each additional distribution you add to the project, the Distribution Plugin adds the following tasks, where _distributionName_ comes from link:{javadocPath}#[Distribution.getName()]:
   
   `__distributionName__DistZip`  link:{groovyDslPath}#[Zip]::
   Creates a ZIP archive of the distribution contents.
   
   `__distributionName__DistTar`  link:{groovyDslPath}#[Tar]::
   Creates a TAR archive of the distribution contents.
   
   `assemble__DistributionName__Dist`  link:{groovyDslPath}#[Task]::
   _Depends on_: `__distributionName__DistTar`, `__distributionName__DistZip`
   +
   Creates ZIP and TAR archives of the distribution contents.
   
   `install__DistributionName__Dist`  link:{groovyDslPath}#[Sync]::
   Assembles the distribution content and installs it on the current machine.
   
   The following sample creates a `custom` distribution that will cause four additional tasks to be added to the project: `customDistZip`, `customDistTar`, `assembleCustomDist`, and `installCustomDist`:
   
   .Adding extra distributions
   ====
   include::sample[dir="snippets/base/distribution/kotlin",files="build.gradle.kts[tags=custom-distribution]"]
   include::sample[dir="snippets/base/distribution/groovy",files="build.gradle[tags=custom-distribution]"]
   ====
   
   Given that the project name is `myproject` and version `1.2`, running `gradle customDistZip` will produce a ZIP file named `myproject-custom-1.2.zip`.
   
   Running `gradle installCustomDist` will install the distribution contents into `__layout.buildDirectory.dir__("install/custom")`.
   
   == Distribution contents
   
   All of the files in the `src/__$distribution.name__/dist` directory will automatically be included in the distribution. You can add additional files by configuring the link:{javadocPath}#[Distribution] object that is part of the container.
   
   .Configuring the main distribution
   ====
   include::sample[dir="snippets/base/distribution/kotlin",files="build.gradle.kts[tags=configure-distribution]"]
   include::sample[dir="snippets/base/distribution/groovy",files="build.gradle[tags=configure-distribution]"]
   ====
   
   In the example above, the content of the `src/readme` directory will be included in the distribution (along with the files in the `src/main/dist` directory which are added by default).
   
   The `distributionBaseName` and `distributionClassifier` properties have also been changed. This will cause the distribution archives to be created with a different name.
   
   == Publishing
   
   A distribution can be published using the <<publishing_ivy.adoc#publishing_ivy, Ivy Publish Plugin>> or <<publishing_maven.adoc#publishing_maven, Maven Publish Plugin>>.
   
   === Using the Ivy/Maven Publish Plugins
   
   To publish a distribution to an Ivy repository with the <<publishing_ivy.adoc#publishing_ivy, Ivy Publish Plugin>>, add one or both of its archive tasks to an link:{groovyDslPath}#[IvyPublication]. The following sample demonstrates how to add the ZIP archive of the `main` distribution and the TAR archive of the `custom` distribution to the `myDistribution` publication:
   
   .Adding distribution archives to an Ivy publication
   ====
   include::sample[dir="snippets/ivy-publish/distribution/kotlin",files="build.gradle.kts[tags=publishing]"]
   include::sample[dir="snippets/ivy-publish/distribution/groovy",files="build.gradle[tags=publishing]"]
   ====
   
   Similarly, to publish a distribution to a Maven repository using the <<publishing_maven.adoc#publishing_maven, Maven Publish Plugin>>, add one or both of its archive tasks to a link:{groovyDslPath}#[MavenPublication] as follows:
   
   .Adding distribution archives to a Maven publication
   ====
   include::sample[dir="snippets/maven-publish/distribution/kotlin",files="build.gradle.kts[tags=publishing]"]
   include::sample[dir="snippets/maven-publish/distribution/groovy",files="build.gradle[tags=publishing]"]
   ====

/docs/userguide/jvm/java_library_distribution_plugin.adoc
=========================================================

.. code-block::

   = The Java Library Distribution Plugin
   
   The Java library distribution plugin adds support for building a distribution ZIP for a Java library. The distribution contains the JAR file for the library and its dependencies.
   
   
   == Usage
   
   To use the Java library distribution plugin, include the following in your build script:
   
   .Using the Java library distribution plugin
   ====
   include::sample[dir="snippets/java/javaLibraryDistribution/kotlin",files="build.gradle.kts[tags=use-plugin]"]
   include::sample[dir="snippets/java/javaLibraryDistribution/groovy",files="build.gradle[tags=use-plugin]"]
   ====
   
   To define the name for the distribution you have to set the `baseName` property as shown below:
   
   .Configure the distribution name
   ====
   include::sample[dir="snippets/java/javaLibraryDistribution/kotlin",files="build.gradle.kts[tags=name-conf]"]
   include::sample[dir="snippets/java/javaLibraryDistribution/groovy",files="build.gradle[tags=name-conf]"]
   ====
   
   The plugin builds a distribution for your library. The distribution will package up the runtime dependencies of the library. All files stored in `src/main/dist` will be added to the root of the archive distribution. You can run `gradle distZip` to create a ZIP file containing the distribution.
   
   == Tasks
   
   The Java library distribution plugin adds the following tasks to the project.
   
   `distZip`  link:{groovyDslPath}#[Zip]::
   _Depends on_: `jar`
   +
   Creates a full distribution ZIP archive including runtime libraries.
   
   
   == Including other resources in the distribution
   
   All of the files from the `src/dist` directory are copied. To include any static files in the distribution, simply arrange them in the `src/dist` directory, or add them to the content of the distribution.
   
   .Include files in the distribution
   ====
   include::sample[dir="snippets/java/javaLibraryDistribution/kotlin",files="build.gradle.kts[tags=custom-distribution]"]
   include::sample[dir="snippets/java/javaLibraryDistribution/groovy",files="build.gradle[tags=custom-distribution]"]
   ====

/Section: 游릭 Code analysis
============================


/docs/userguide/core-plugins/checkstyle_plugin.adoc
===================================================

.. code-block::

   = The Checkstyle Plugin
   
   The Checkstyle plugin performs quality checks on your project's Java source files using https://checkstyle.org/index.html[Checkstyle] and generates reports from these checks.
   
   
   == Usage
   
   To use the Checkstyle plugin, include the following in your build script:
   
   .Using the Checkstyle plugin
   ====
   include::sample[dir="snippets/codeQuality/codeQuality/kotlin",files="build.gradle.kts[tags=use-checkstyle-plugin]"]
   include::sample[dir="snippets/codeQuality/codeQuality/groovy",files="build.gradle[tags=use-checkstyle-plugin]"]
   ====
   
   The plugin adds a number of tasks to the project that perform the quality checks. You can execute the checks by running `gradle check`.
   
   Note that Checkstyle will run with the same Java version used to run Gradle.
   
   == Tasks
   
   The Checkstyle plugin adds the following tasks to the project:
   
   `checkstyleMain`  link:{groovyDslPath}#[Checkstyle]::
   _Depends on_: `classes`
   +
   Runs Checkstyle against the production Java source files.
   
   `checkstyleTest`  link:{groovyDslPath}#[Checkstyle]::
   _Depends on_: `testClasses`
   +
   Runs Checkstyle against the test Java source files.
   
   `checkstyle__SourceSet__`  link:{groovyDslPath}#[Checkstyle]::
   _Depends on_: `__sourceSet__Classes`
   +
   Runs Checkstyle against the given source set's Java source files.
   
   === Dependencies added to other tasks
   
   The Checkstyle plugin adds the following dependencies to tasks defined by the Java plugin.
   
   `check`::
   _Depends on_: All Checkstyle tasks, including `checkstyleMain` and `checkstyleTest`.
   
   
   == Project layout
   
   By default, the Checkstyle plugin expects configuration files to be placed in the root project, but this can be changed.
   
   ----
   <root>
   較덕較 config
       較덕較 checkstyle           // <1>
           較덕較 checkstyle.xml   // <2>
           較덕較 suppressions.xml
   ----
   <1> Checkstyle configuration files go here
   <2> Primary Checkstyle configuration file
   
   
   == Dependency management
   
   The Checkstyle plugin adds the following dependency configurations:
   
   .Checkstyle plugin - dependency configurations
   [cols="a,a", options="header"]
   |===
   | Name
   | Meaning
   
   | `checkstyle`
   | The Checkstyle libraries to use
   |===
   
   
   == Configuration
   
   See the link:{groovyDslPath}#[CheckstyleExtension] class in the API documentation.
   
   
   === Built-in variables
   
   The Checkstyle plugin defines a `config_loc` property that can be used in Checkstyle configuration files to define paths to other configuration files like `suppressions.xml`.
   
   .Using the config_loc property
   ====
   include::sample[dir="snippets/codeQuality/codeQuality/groovy/config/checkstyle",files="checkstyle.xml[tags=use-config-loc]"]
   ====
   
   
   == Customizing the HTML report
   
   The HTML report generated by the link:{groovyDslPath}#[Checkstyle] task can be customized using a XSLT stylesheet, for example to highlight specific errors or change its appearance:
   
   .Customizing the HTML report
   ====
   include::sample[dir="snippets/codeQuality/codeQuality/kotlin",files="build.gradle.kts[tags=customize-checkstyle-report]"]
   include::sample[dir="snippets/codeQuality/codeQuality/groovy",files="build.gradle[tags=customize-checkstyle-report]"]
   ====
   
   https://github.com/checkstyle/contribution/tree/master/xsl[View a sample Checkstyle stylesheet.]
   
   == Generate SARIF report
   
   link:https://docs.oasis-open.org/sarif/sarif/v2.1.0/sarif-v2.1.0.html[SARIF] report is supported on Checkstyle versions 10.3.3 and newer. It is not enabled by default.
   
   .Enable SARIF Report
   ====
   include::sample[dir="snippets/codeQuality/codeQuality/kotlin",files="build.gradle.kts[tags=enable-checkstyle-sarif-report]"]
   include::sample[dir="snippets/codeQuality/codeQuality/groovy",files="build.gradle[tags=enable-checkstyle-sarif-report]"]
   ====
   
   == Changing the amount of memory given to Checkstyle
   
   Checkstyle analysis is performed in a separate process. By default, the Checkstyle process is given a max heap of 512MB. When analyzing many source files, you may need to provide additional memory to this process.
   You can change the amount of memory for Checkstyle by configuring the link:{groovyDslPath}#[Checkstyle.maxHeapSize].
   
   .Customizing the amount of memory given to Checkstyle
   ====
   include::sample[dir="snippets/codeQuality/codeQuality/kotlin",files="build.gradle.kts[tags=customize-checkstyle-memory]"]
   include::sample[dir="snippets/codeQuality/codeQuality/groovy",files="build.gradle[tags=customize-checkstyle-memory]"]
   ====
   

/docs/userguide/core-plugins/pmd_plugin.adoc
============================================

.. code-block::

   = The PMD Plugin
   
   The PMD plugin performs quality checks on your project's Java source files using https://pmd.github.io/[PMD] and generates reports from these checks.
   
   == Usage
   
   To use the PMD plugin, include the following in your build script:
   
   .Using the PMD plugin
   ====
   include::sample[dir="snippets/codeQuality/codeQuality/kotlin",files="build.gradle.kts[tags=use-pmd-plugin]"]
   include::sample[dir="snippets/codeQuality/codeQuality/groovy",files="build.gradle[tags=use-pmd-plugin]"]
   ====
   
   The plugin adds a number of tasks to the project that perform the quality checks. You can execute the checks by running `gradle check`.
   
   Note that PMD will run with the same Java version used to run Gradle.
   
   == Tasks
   
   The PMD plugin adds the following tasks to the project:
   
   `pmdMain`  link:{groovyDslPath}#[Pmd]::
   +
   Runs PMD against the production Java source files.
   
   `pmdTest`  link:{groovyDslPath}#[Pmd]::
   +
   Runs PMD against the test Java source files.
   
   The PMD plugin adds the following dependencies to tasks defined by the Java plugin.
   
   .PMD plugin - additional task dependencies
   [%header%autowidth,compact]
   |===
   | Task name | Depends on
   | `check`   | All PMD tasks, including `pmdMain` and `pmdTest`.
   |===
   
   == Dependency management
   
   The PMD plugin adds the following dependency configurations:
   
   .PMD plugin - dependency configurations
   [%header%autowidth,compact]
   |===
   | Name | Meaning
   | `pmd` | The PMD libraries to use
   | `pmdAux` | The additional libraries that are available for type resolution during analysis. This might be useful if PMD complains about missing classes.
   |===
   
   == Configuration
   
   ====
   include::sample[dir="snippets/codeQuality/codeQuality/kotlin",files="build.gradle.kts[tags=customize-pmd]"]
   include::sample[dir="snippets/codeQuality/codeQuality/groovy",files="build.gradle[tags=customize-pmd]"]
   ====
   
   See the link:{groovyDslPath}#[PmdExtension] class in the API documentation.
   
   === Parallel analysis
   
   You can configure the number of threads to be used by PMD for running its analysis.
   
   ====
   include::sample[dir="snippets/codeQuality/codeQuality/kotlin",files="build.gradle.kts[tags=pmd-threads]"]
   include::sample[dir="snippets/codeQuality/codeQuality/groovy",files="build.gradle[tags=pmd-threads]"]
   ====
   
   [NOTE]
   ====
   This configuration is internal to PMD and is not linked to <<performance#parallel_execution,the number of workers>> used by Gradle.
   It means that you have to pay attention to the value entered here and make sure it still makes sense in a multi project build.
   This is because parallel Gradle task execution could result in different PMD tasks from different projects running in parallel.
   If multiple PMD tasks execute simultaneously in n projects, then up to a maximum of (n * `thread`) PMD threads could run at the same time.
   ====

/docs/userguide/core-plugins/jacoco_plugin.adoc
===============================================

.. code-block::

   = The JaCoCo Plugin
   
   
   The JaCoCo plugin provides code coverage metrics for Java code via integration with http://www.eclemma.org/jacoco/[JaCoCo].
   
   
   == Getting Started
   
   To get started, apply the JaCoCo plugin to the project you want to calculate code coverage for.
   
   .Applying the JaCoCo plugin
   ====
   include::sample[dir="snippets/testing/jacoco-quickstart/kotlin",files="build.gradle.kts[tags=apply-plugin]"]
   include::sample[dir="snippets/testing/jacoco-quickstart/groovy",files="build.gradle[tags=apply-plugin]"]
   ====
   
   If the Java plugin is also applied to your project, a new task named `jacocoTestReport` is created.
   By default, a HTML report is generated at `layout.buildDirectory.dir("reports/jacoco/test")`.
   
   NOTE: While tests should be executed before generation of the report, the `jacocoTestReport` task does not depend on the `test` task.
   
   Depending on your usecases, you may want to always generate the `jacocoTestReport` or run the `test` task before generating the report explicitly.
   
   .Define dependencies between code coverage reports and test execution
   ====
   include::sample[dir="snippets/testing/jacoco-quickstart/kotlin",files="build.gradle.kts[tags=testtask-dependency]"]
   include::sample[dir="snippets/testing/jacoco-quickstart/groovy",files="build.gradle[tags=testtask-dependency]"]
   ====
   
   == Configuring the JaCoCo Plugin
   
   The JaCoCo plugin adds a project extension named `jacoco` of type link:{groovyDslPath}#[JacocoPluginExtension], which allows configuring defaults for JaCoCo usage in your build.
   
   .Configuring JaCoCo plugin settings
   ====
   include::sample[dir="snippets/testing/jacoco-quickstart/kotlin",files="build.gradle.kts[tags=jacoco-configuration]"]
   include::sample[dir="snippets/testing/jacoco-quickstart/groovy",files="build.gradle[tags=jacoco-configuration]"]
   ====
   
   .Gradle defaults for JaCoCo properties
   [%header%autowidth,compact]
   |===
   | Property | Gradle default
   | reportsDirectory | `layout.buildDirectory.dir("reports/jacoco")`
   |===
   
   
   == JaCoCo Report configuration
   
   The link:{groovyDslPath}#[JacocoReport] task can be used to generate code coverage reports in different formats. It implements the standard Gradle type link:{groovyDslPath}#[Reporting] and exposes a report container of type link:{javadocPath}#[JacocoReportsContainer].
   
   .Configuring test task
   ====
   include::sample[dir="snippets/testing/jacoco-quickstart/kotlin",files="build.gradle.kts[tags=report-configuration]"]
   include::sample[dir="snippets/testing/jacoco-quickstart/groovy",files="build.gradle[tags=report-configuration]"]
   ====
   image::jacocoHtmlReport.png[JaCoCo HTML report,903,277]
   
   == Enforcing code coverage metrics
   
   
   NOTE: This feature requires the use of JaCoCo version 0.6.3 or higher.
   
   The link:{groovyDslPath}#[JacocoCoverageVerification] task can be used to verify if code coverage metrics are met based on configured rules. Its API exposes the method link:{javadocPath}#[JacocoCoverageVerification.violationRules(org.gradle.api.Action)] which is used as main entry point for configuring rules. Invoking any of those methods returns an instance of link:{javadocPath}#[JacocoViolationRulesContainer] providing extensive configuration options. The build fails if any of the configured rules are not met. JaCoCo only reports the first violated rule.
   
   Code coverage requirements can be specified for a project as a whole, for individual files, and for particular JaCoCo-specific types of coverage, e.g., lines covered or branches covered. The following example describes the syntax.
   
   .Configuring violation rules
   ====
   include::sample[dir="snippets/testing/jacoco-quickstart/kotlin",files="build.gradle.kts[tags=violation-rules-configuration]"]
   include::sample[dir="snippets/testing/jacoco-quickstart/groovy",files="build.gradle[tags=violation-rules-configuration]"]
   ====
   
   
   The link:{groovyDslPath}#[JacocoCoverageVerification] task is not a task dependency of the `check` task provided by the Java plugin. There is a good reason for it. The task is currently not incremental as it doesn't declare any outputs. Any violation of the declared rules would automatically result in a failed build when executing the `check` task. This behavior might not be desirable for all users. Future versions of Gradle might change the behavior.
   
   == JaCoCo specific task configuration
   
   The JaCoCo plugin adds a link:{groovyDslPath}#[JacocoTaskExtension] extension to all tasks of type link:{groovyDslPath}#[Test]. This extension allows the configuration of the JaCoCo specific properties of the test task.
   
   .Configuring test task
   ====
   include::sample[dir="snippets/testing/jacoco-quickstart/kotlin",files="build.gradle.kts[tags=testtask-configuration]"]
   include::sample[dir="snippets/testing/jacoco-quickstart/groovy",files="build.gradle[tags=testtask-configuration]"]
   ====
   
   [NOTE]
   ====
   Tasks configured for running with the JaCoCo agent delete the destination file for the execution data when the task starts executing.
   This ensures that no stale coverage data is present in the execution data.
   ====
   
   === Default values of the JaCoCo Task extension
   
   .JaCoCo task extension default values
   ====
   include::sample[dir="snippets/testing/jacoco-quickstart/kotlin",files="build.gradle.kts[tags=testtask-configuration-defaults]"]
   include::sample[dir="snippets/testing/jacoco-quickstart/groovy",files="build.gradle[tags=testtask-configuration-defaults]"]
   ====
   
   While all tasks of type link:{groovyDslPath}#[Test] are automatically enhanced to provide coverage information when the `java` plugin has been applied, any task that implements link:{javadocPath}#[JavaForkOptions] can be enhanced by the JaCoCo plugin. That is, any task that forks Java processes can be used to generate coverage information.
   
   For example you can configure your build to generate code coverage using the `application` plugin.
   
   .Using application plugin to generate code coverage data
   ====
   include::sample[dir="snippets/testing/jacoco-application/kotlin",files="build.gradle.kts[tags=application-configuration]"]
   include::sample[dir="snippets/testing/jacoco-application/groovy",files="build.gradle[tags=application-configuration]"]
   ====
   
   
   .Coverage reports generated by applicationCodeCoverageReport
   ----
   .
   較덕較 build
       較럭較 jacoco
       較먝 較덕較 run.exec
       較덕較 reports
           較덕較 jacoco
               較덕較 applicationCodeCoverageReport
                   較덕較 html
                       較덕較 index.html
   
   ----
   
   
   == Tasks
   
   For projects that also apply the Java Plugin, the JaCoCo plugin automatically adds the following tasks:
   
   `jacocoTestReport`  link:{groovyDslPath}#[JacocoReport]::
   +
   Generates code coverage report for the test task.
   
   `jacocoTestCoverageVerification`  link:{groovyDslPath}#[JacocoCoverageVerification]::
   +
   Verifies code coverage metrics based on specified rules for the test task.
   
   
   == Dependency management
   
   The JaCoCo plugin adds the following dependency configurations:
   
   .JaCoCo plugin - dependency configurations
   [%header%autowidth,compact]
   |===
   | Name          | Meaning
   
   | `jacocoAnt`
   | The JaCoCo Ant library used for running the `JacocoReport` and `JacocoCoverageVerification` tasks.
   
   | `jacocoAgent`
   | The JaCoCo agent library used for instrumenting the code under test.
   
   |===
   
   == Outgoing Variants
   
   When a project producing JaCoCo coverage data is applied alongside the <<jvm_test_suite_plugin#jvm_test_suite_plugin,JVM Test Suite Plugin>>, additional outgoing variants will be created.  These variants are designed for consumption by the <<jacoco_report_aggregation_plugin#jacoco_report_aggregation_plugin, JaCoCo Report Aggregation Plugin>>.
   
   The attributes will resemble the following.  User-configurable attributes are highlighted below the sample.
   
   .outgoingVariants task output
   [source,text]
   ----
   --------------------------------------------------
   Variant coverageDataElementsForTest (i)
   --------------------------------------------------
   Description = Binary data file containing results of Jacoco test coverage reporting for the test Test Suite's test target.
   
   Capabilities
       - org.gradle.sample:application:1.0.2 (default capability)
   Attributes
       - org.gradle.category              = verification
       - org.gradle.testsuite.name        = test           // <1>
       - org.gradle.testsuite.target.name = test           // <2>
       - org.gradle.testsuite.type        = unit-test      // <3>
       - org.gradle.verificationtype      = jacoco-coverage
   
   Artifacts
       - build/jacoco/test.exec (artifactType = binary)
   ----
   <1> TestSuiteName attribute; value is derived from link:{javadocPath}#[JvmTestSuite#getName()].
   <2> TestSuiteTargetName attribute; value is derived from link:{javadocPath}#[JvmTestSuiteTarget#getName()].
   <3> TestSuiteType attribute; value is derived from link:{javadocPath}#[JvmTestSuite#getTestType()].

/docs/userguide/jvm/jacoco_report_aggregation_plugin.adoc
=========================================================

.. code-block::

   = The JaCoCo Report Aggregation Plugin
   
   The JaCoCo Report Aggregation plugin (plugin id: `jacoco-report-aggregation`) provides the ability to aggregate the results of multiple JaCoCo code coverage reports (potentially spanning multiple Gradle projects) into a single HTML report.  The binary data backing the coverage reports are produced by link:{groovyDslPath}#[Test] task invocations; see more at the <<jacoco_plugin#jacoco_plugin,JaCoCo Plugin>> chapter.
   
   == Usage
   
   To use the JaCoCo Report Aggregation plugin, include the following in your build script:
   
   [.multi-language-text.lang-groovy]
   ----
   plugins {
       id 'jacoco-report-aggregation'
   }
   ----
   [.multi-language-text.lang-kotlin]
   ----
   plugins {
       id("jacoco-report-aggregation")
   }
   ----
   
   Note that this plugin takes no action unless applied in concert with the <<jvm_test_suite_plugin#jvm_test_suite_plugin,JVM Test Suite Plugin>>.  The <<java_plugin#java_plugin, Java Plugin>> automatically applies the JVM Test Suite Plugin.
   
   There are now two ways to collect code coverage results across multiple subprojects:
   
   1. From the distribution's project, such as an application or WAR subproject -> link:#[distribution sample]
   2. Using a standalone project to specify subprojects -> link:#[standalone sample]
   
   Example 2 could also be used to aggregate results via the root project.
   
   WARNING: The JaCoCo Report Aggregation plugin does not currently work with the ``com.android.application`` plugin.
   
   == Tasks
   
   When the project also applies the `jvm-test-suite` plugin, the following tasks are added for each test suite:
   
   `__testSuite__CodeCoverageReport`  link:{groovyDslPath}#[JacocoReport]::
   _Depends on_: Artifacts of variants matching the below attributes
   +
   Collects variants of direct and transitive project dependencies via the `jacocoAggregation` configuration. The following Attributes will be matched:
   
   [source]
   ----
       - org.gradle.category              = verification   // <1>
       - org.gradle.testsuite.type        = unit-test      // <2>
       - org.gradle.verificationtype      = jacoco-results   // <3>
   ----
   <1> Category attribute; value is fixed.
   <2> TestSuiteType attribute; value is derived from link:{javadocPath}#[JvmTestSuite#getTestType()].
   <3> VerificationType attribute; value is fixed.
   
   More information about the variants produced by test execution with JaCoCo are available in the <<jacoco_plugin#sec:outgoing_variants,Outgoing Variants>> section of the JaCoCo Plugin documentation.
   
   == Reports
   
   [IMPORTANT]
   ====
   By default, Gradle stops executing tasks when any task fails -- including test failures.
   To ensure that your builds always generate aggregation reports, specify the `--continue` option in your Gradle command.
   For more information, see <<command_line_interface.adoc#sec:continue_build_on_failure, continuing the build when a failure occurs>>.
   ====
   
   === Automatic report creation
   
   When the project also applies the `jvm-test-suite` plugin, the following reporting objects are added for each test suite:
   
   `__testSuite__CodeCoverageReport`  link:{javadocPath}#[JacocoCoverageReport]::
   Creates a container to parameterize the link:{javadocPath}#[TestSuiteType] value.
   
   === Manual report creation
   
   When the project does not apply the `jvm-test-suite` plugin, you must manually register one or more reports:
   
   .Create a reporting container
   ====
   include::sample[dir="samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/kotlin/code-coverage-report",files="build.gradle.kts[tags=create_report]"]
   include::sample[dir="samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/groovy/code-coverage-report",files="build.gradle[tags=create_report]"]
   ====
   <.> Creates a report named `testCodeCoverageReport` of type `JacocoCoverageReport`.  For convenience, sets `TestType` using a constant value from the  link:{javadocPath}#[TestSuiteType] class.  Any String value is acceptable.
   
   Report creation automatically creates backing tasks to aggregate coverage results for the given test suite type value.
   
   == Dependency management
   The JaCoCo Report Aggregation plugin adds the following dependency configurations:
   
   .JaCoCo Report Aggregation plugin - dependency configurations
   [cols="a,a", options="header"]
   |===
   | Name
   | Meaning
   
   | `jacocoAggregation`
   | The configuration used to declare all project dependencies having code coverage data to be aggregated.
   | `aggregateCodeCoverageReportResults`
   | Consumes the project dependencies from the `jacocoAggregation` configuration using <<variant_model#sec:variant-aware-matching,variant-aware matching>> to find the appropriate test suite type.
   |===
   
   It is not necessary to explicitly add dependencies to the `jacocoAggregation` configuration if the project also applies the `jvm-test-suite` plugin.

/docs/userguide/core-plugins/codenarc_plugin.adoc
=================================================

.. code-block::

   = The CodeNarc Plugin
   
   The CodeNarc plugin performs quality checks on your project's Groovy source files using https://codenarc.org/[CodeNarc] and generates reports from these checks.
   
   
   == Usage
   
   To use the CodeNarc plugin, include the following in your build script:
   
   .Using the CodeNarc plugin
   ====
   include::sample[dir="snippets/codeQuality/codeQuality/kotlin",files="build.gradle.kts[tags=use-codenarc-plugin]"]
   include::sample[dir="snippets/codeQuality/codeQuality/groovy",files="build.gradle[tags=use-codenarc-plugin]"]
   ====
   
   The plugin adds a number of tasks to the project that perform the quality checks when used with the <<groovy_plugin.adoc#groovy_plugin, Groovy Plugin>>. You can execute the checks by running `gradle check`.
   
   == Tasks
   
   The CodeNarc plugin adds the following tasks to the project:
   
   `codenarcMain`  link:{groovyDslPath}#[CodeNarc]::
   +
   Runs CodeNarc against the production Groovy source files.
   
   `codenarcTest`  link:{groovyDslPath}#[CodeNarc]::
   +
   Runs CodeNarc against the test Groovy source files.
   
   `codenarc__SourceSet__`  link:{groovyDslPath}#[CodeNarc]::
   +
   Runs CodeNarc against the given source set's Groovy source files.
   
   === Dependencies added to other tasks
   
   The CodeNarc plugin adds the following dependencies to tasks defined by the Groovy plugin.
   
   `check`::
   _Depends on_: All CodeNarc tasks, including `codenarcMain` and `codenarcTest`.
   
   
   == Project layout
   
   The CodeNarc plugin expects the following project layout:
   
   ----
   <root>
   較덕較 config
       較덕較 codenarc           // <1>
           較덕較 codenarc.xml   // <2>
   ----
   <1> CodeNarc configuration files go here
   <2> Primary CodeNarc configuration file
   
   
   == Dependency management
   
   The CodeNarc plugin adds the following dependency configurations:
   
   .CodeNarc plugin - dependency configurations
   [cols="a,a", options="header"]
   |===
   | Name
   | Meaning
   
   | `codenarc`
   | The CodeNarc libraries to use
   |===
   
   
   == Configuration
   
   See the link:{groovyDslPath}#[CodeNarcExtension] class in the API documentation.

/Section: 游릭 IDE integration
==============================


/docs/userguide/core-plugins/eclipse_plugin.adoc
================================================

.. code-block::

   = The Eclipse Plugins
   
   WARNING: The Eclipse Plugins are not compatible with the <<configuration_cache.adoc#config_cache:plugins:core,configuration cache>>.
   
   The Eclipse plugins generate files that are used by the http://eclipse.org[Eclipse IDE], thus making it possible to import the project into Eclipse (`File` - `Import...` - `Existing Projects into Workspace`).
   
   The `eclipse-wtp` is automatically applied whenever the `eclipse` plugin is applied to a <<war_plugin.adoc#war_plugin,War>> or <<ear_plugin.adoc#ear_plugin,Ear>> project. For utility projects (i.e. <<java_plugin.adoc#java_plugin,Java>> projects used by other web projects), you need to apply the `eclipse-wtp` plugin explicitly.
   
   What exactly the `eclipse` plugin generates depends on which other plugins are used:
   
   .Eclipse plugin behavior
   [%header%autowidth,compact]
   |===
   | Plugin | Description
   
   | None
   | Generates minimal `.project` file.
   
   | <<java_plugin.adoc#java_plugin,Java>>
   | Adds Java configuration to `.project`. Generates `.classpath` and JDT settings file.
   
   | <<groovy_plugin.adoc#groovy_plugin,Groovy>>
   | Adds Groovy configuration to `.project` file.
   
   | <<scala_plugin.adoc#scala_plugin,Scala>>
   | Adds Scala support to `.project` and `.classpath` files.
   
   | <<war_plugin.adoc#war_plugin,War>>
   | Adds web application support to `.project` file.
   
   | <<ear_plugin.adoc#ear_plugin,Ear>>
   | Adds ear application support to `.project` file.
   |===
   
   The `eclipse-wtp` plugin generates all WTP settings files and enhances the `.project` file. If a <<java_plugin.adoc#java_plugin,Java>> or <<war_plugin.adoc#war_plugin,War>> is applied, `.classpath` will be extended to get a proper packaging structure for this utility library or web application project.
   
   Both Eclipse plugins are open to customization and provide a standardized set of hooks for adding and removing content from the generated files.
   
   
   == Usage
   
   To use either the Eclipse or the Eclipse WTP plugin, include one of the lines in your build script:
   
   .Using the Eclipse plugin
   ====
   include::sample[dir="snippets/ide/eclipse/kotlin",files="build.gradle.kts[tags=use-eclipse-plugin]"]
   include::sample[dir="snippets/ide/eclipse/groovy",files="build.gradle[tags=use-eclipse-plugin]"]
   ====
   
   .Using the Eclipse WTP plugin
   ====
   include::sample[dir="snippets/ide/eclipse/kotlin",files="build.gradle.kts[tags=use-eclipse-wtp-plugin]"]
   include::sample[dir="snippets/ide/eclipse/groovy",files="build.gradle[tags=use-eclipse-wtp-plugin]"]
   ====
   
   _Note:_ Internally, the `eclipse-wtp` plugin also applies the `eclipse` plugin so you don't need to apply both.
   
   Both Eclipse plugins add a number of tasks to your projects. The main tasks that you will use are the `eclipse` and `cleanEclipse` tasks.
   
   == Tasks
   
   The Eclipse plugins add the tasks shown below to a project.
   
   === Eclipse Plugin tasks
   
   `eclipse`  link:{groovyDslPath}#[Task]::
   _Depends on_: all Eclipse configuration file generation tasks
   +
   Generates all Eclipse configuration files
   
   `cleanEclipse`  link:{groovyDslPath}#[Delete]::
   _Depends on_: all Eclipse configuration file clean tasks
   +
   Removes all Eclipse configuration files
   
   `cleanEclipseProject`  link:{groovyDslPath}#[Delete]::
   +
   Removes the `.project` file.
   
   `cleanEclipseClasspath`  link:{groovyDslPath}#[Delete]::
   +
   Removes the `.classpath` file.
   
   `cleanEclipseJdt`  link:{groovyDslPath}#[Delete]::
   +
   Removes the `.settings/org.eclipse.jdt.core.prefs` file.
   
   `eclipseProject`  link:{groovyDslPath}#[GenerateEclipseProject]::
   +
   Generates the `.project` file.
   
   `eclipseClasspath`  link:{groovyDslPath}#[GenerateEclipseClasspath]::
   +
   Generates the `.classpath` file.
   
   `eclipseJdt`  link:{groovyDslPath}#[GenerateEclipseJdt]::
   +
   Generates the `.settings/org.eclipse.jdt.core.prefs` file.
   
   === Eclipse WTP Plugin  additional tasks
   
   `cleanEclipseWtpComponent`  link:{groovyDslPath}#[Delete]::
   +
   Removes the `.settings/org.eclipse.wst.common.component` file.
   
   `cleanEclipseWtpFacet`  link:{groovyDslPath}#[Delete]::
   +
   Removes the `.settings/org.eclipse.wst.common.project.facet.core.xml` file.
   
   `eclipseWtpComponent`  link:{groovyDslPath}#[GenerateEclipseWtpComponent]::
   +
   Generates the `.settings/org.eclipse.wst.common.component` file.
   
   `eclipseWtpFacet`  link:{groovyDslPath}#[GenerateEclipseWtpFacet]::
   +
   Generates the `.settings/org.eclipse.wst.common.project.facet.core.xml` file.
   
   
   == Configuration
   
   
   .Configuration of the Eclipse plugins
   [%header%autowidth,compact]
   |===
   | Model | Reference name | Description
   
   | link:{groovyDslPath}#[EclipseModel]
   | `eclipse`
   | Top level element that enables configuration of the Eclipse plugin in a DSL-friendly fashion.
   
   | link:{groovyDslPath}#[EclipseProject]
   | `eclipse.project`
   | Allows configuring project information
   
   | link:{groovyDslPath}#[EclipseClasspath]
   | `eclipse.classpath`
   | Allows configuring classpath information.
   
   | link:{groovyDslPath}#[EclipseJdt]
   | `eclipse.jdt`
   | Allows configuring jdt information (source/target Java compatibility).
   
   | link:{groovyDslPath}#[EclipseWtpComponent]
   | `eclipse.wtp.component`
   | Allows configuring wtp component information only if `eclipse-wtp` plugin was applied.
   
   | link:{groovyDslPath}#[EclipseWtpFacet]
   | `eclipse.wtp.facet`
   | Allows configuring wtp facet information only if `eclipse-wtp` plugin was applied.
   |===
   
   
   == Customizing the generated files
   
   The Eclipse plugins allow you to customize the generated metadata files. The plugins provide a DSL for configuring model objects that model the Eclipse view of the project. These model objects are then merged with the existing Eclipse XML metadata to ultimately generate new metadata. The model objects provide lower level hooks for working with domain objects representing the file content before and after merging with the model configuration. They also provide a very low level hook for working directly with the raw XML for adjustment before it is persisted, for fine tuning and configuration that the Eclipse and Eclipse WTP plugins do not model.
   
   
   === Merging
   
   Sections of existing Eclipse files that are also the target of generated content will be amended or overwritten, depending on the particular section. The remaining sections will be left as-is.
   
   
   ==== Disabling merging with a complete rewrite
   
   To completely rewrite existing Eclipse files, execute a clean task together with its corresponding generation task, like `gradle cleanEclipse eclipse` (in that order). If you want to make this the default behavior, add `tasks.eclipse.dependsOn(cleanEclipse)` to your build script. This makes it unnecessary to execute the clean task explicitly.
   
   This strategy can also be used for individual files that the plugins would generate. For instance, this can be done for the `.classpath` file with `gradle cleanEclipseClasspath eclipseClasspath`.
   
   === Hooking into the generation lifecycle
   
   The Eclipse plugins provide objects modeling the sections of the Eclipse files that are generated by Gradle. The generation lifecycle is as follows:
   
   . The file is read; or a default version provided by Gradle is used if it does not exist
   . The `beforeMerged` hook is executed with a domain object representing the existing file
   . The existing content is merged with the configuration inferred from the Gradle build or defined explicitly in the eclipse DSL
   . The `whenMerged` hook is executed with a domain object representing contents of the file to be persisted
   . The `withXml` hook is executed with a raw representation of the XML that will be persisted
   . The final XML is persisted
   
   ==== Advanced configuration hooks
   
   The following list covers the domain object used for each of the Eclipse model types:
   
   link:{groovyDslPath}#[EclipseProject]::
     * `beforeMerged { link:{javadocPath}#[Project] arg -&gt; ... }`
     * `whenMerged { link:{javadocPath}#[Project] arg -&gt; ... }`
     * `withXml { link:{javadocPath}#[XmlProvider] arg -&gt; ... }`
   
   link:{groovyDslPath}#[EclipseClasspath]::
     * `beforeMerged { link:{javadocPath}#[Classpath] arg -&gt; ... }`
     * `whenMerged { link:{javadocPath}#[Classpath] arg -&gt; ... }`
     * `withXml { link:{javadocPath}#[XmlProvider] arg -&gt; ... }`
   
   link:{groovyDslPath}#[EclipseWtpComponent]::
     * `beforeMerged { link:{javadocPath}#[WtpComponent] arg -&gt; ... }`
     * `whenMerged { link:{javadocPath}#[WtpComponent] arg -&gt; ... }`
     * `withXml { link:{javadocPath}#[XmlProvider] arg -&gt; ... }`
   
   link:{groovyDslPath}#[EclipseWtpFacet]::
     * `beforeMerged { link:{javadocPath}#[WtpFacet] arg -&gt; ... }`
     * `whenMerged { link:{javadocPath}#[WtpFacet] arg -&gt; ... }`
     * `withXml { link:{javadocPath}#[XmlProvider] arg -&gt; ... }`
   
   link:{groovyDslPath}#[EclipseJdt]::
     * `beforeMerged { link:{javadocPath}#[Jdt] arg -&gt; ... }`
     * `whenMerged { link:{javadocPath}#[Jdt] arg -&gt; ... }`
     * `withProperties { arg -&gt; }` argument type => link:{javaApi}/java/util/Properties.html[`java.util.Properties`]
   
   
   ==== Partial overwrite of existing content
   
   A complete overwrite causes all existing content to be discarded, thereby losing any changes made directly in the IDE. Alternatively, the `beforeMerged` hook makes it possible to overwrite just certain parts of the existing content. The following example removes all existing dependencies from the `Classpath` domain object:
   
   .Partial Overwrite for Classpath
   ====
   include::sample[dir="snippets/ide/eclipse/kotlin",files="build.gradle.kts[tags=module-before-merged]"]
   include::sample[dir="snippets/ide/eclipse/groovy",files="build.gradle[tags=module-before-merged]"]
   ====
   
   The resulting `.classpath` file will only contain Gradle-generated dependency entries, but not any other dependency entries that may have been present in the original file. (In the case of dependency entries, this is also the default behavior.) Other sections of the `.classpath` file will be either left as-is or merged. The same could be done for the natures in the `.project` file:
   
   .Partial Overwrite for Project
   ====
   include::sample[dir="snippets/ide/eclipse/kotlin",files="build.gradle.kts[tags=project-before-merged]"]
   include::sample[dir="snippets/ide/eclipse/groovy",files="build.gradle[tags=project-before-merged]"]
   ====
   
   ==== Modifying the fully populated domain objects
   
   The `whenMerged` hook allows to manipulate the fully populated domain objects. Often this is the preferred way to customize Eclipse files. Here is how you would export all the dependencies of an Eclipse project:
   
   .Export Classpath Entries
   ====
   include::sample[dir="snippets/ide/eclipse/kotlin",files="build.gradle.kts[tags=module-when-merged]"]
   include::sample[dir="snippets/ide/eclipse/groovy",files="build.gradle[tags=module-when-merged]"]
   ====
   
   ==== Modifying the XML representation
   
   The `withXml` hook allows to manipulate the in-memory XML representation just before the file gets written to disk. Although Groovy's XML support and Kotlin's extension functions make up for a lot, this approach is less convenient than manipulating the domain objects. In return, you get total control over the generated file, including sections not modeled by the domain objects.
   
   .Customizing the XML
   ====
   include::sample[dir="snippets/ide/eclipse/kotlin",files="build.gradle.kts[tags=wtp-with-xml]"]
   include::sample[dir="snippets/ide/eclipse/groovy",files="build.gradle[tags=wtp-with-xml]"]
   ====
   
   == Separation of test classpath entries
   
   Eclipse defines only one classpath per project which implies limitations on how Gradle projects can be mapped.
   Eclipse 4.8 introduced the concept of link:https://www.eclipse.org/eclipse/news/4.8/jdt.php#jdt-test-sources[test sources].
   This feature allows the Eclipse plugin to define better separation between test and non-test sources.
   
   The Eclipse classpath consists of classpath entries: source directories, jar files, project dependencies, etc.
   Each classpath entry can have a list of classpath attributes, where the attributes are string key-value pairs.
   There are two classpath attribute relevant for test sources: `test` and `without_test_code`, both of which can have `true` or `false` as values.
   
   If a source directory has the `test=true` classpath attribute then the contents are considered test sources.
   Test sources have access to non-test sources, but non-test sources don't have access to test sources.
   Similarly, test sources can only reference classes from a jar file if the jar file has the `test=true` classpath attribute.
   For project dependencies if the `test=true` attribute is present the classes in the target project are visible to test sources.
   If the `without_test_code=false` attribute is present then the test sources of the target project are also accessible.  By default, test code is not available (which can be thought of as implicitly having `without_test_code=true`).
   
   The following rules apply for the test attribute declaration when generating the Eclipse classpath:
   
   - Source sets and dependency configurations are categorized as test if their name contain the 'test' substring, irrespective of case.
   - All source sets and dependency configurations defined by the JVM test suite plugin are categorized as test.
   - Source directories have the `test=true` classpath attribute if the container source set is a test source set.
   - Jar files and project dependencies have the `test=true` attribute if they are present only in test dependency configurations.
   - Project dependencies have the `without_test_sources=false` attribute if the target project applies the java-test-fixtures plugin.
   
   You can customize the test source sets and configurations:
   
   .Customizing test sources
   ====
   include::sample[dir="snippets/ide/eclipse/kotlin",files="build.gradle.kts[tags=test-sources]"]
   include::sample[dir="snippets/ide/eclipse/groovy",files="build.gradle[tags=test-sources]"]
   ====
   
   TIP: Consider migrating away from manual definition of additional test source sets and towards the use of the <<jvm_test_suite_plugin#jvm_test_suite_plugin,JVM Test Suite Plugin>> in scenarios like this.
   
   You can also customize if a project should expose test sources to upstream project dependencies via the `containsTestFixtures` property.
   
   .Customizing test fixtures
   ====
   include::sample[dir="snippets/ide/eclipse/kotlin",files="build.gradle.kts[tags=test-fixtures]"]
   include::sample[dir="snippets/ide/eclipse/groovy",files="build.gradle[tags=test-fixtures]"]
   ====
   
   Note, that this configuration also applies to the classpath of Buildship projects.

/docs/userguide/core-plugins/idea_plugin.adoc
=============================================

.. code-block::

   = The IDEA Plugin
   
   WARNING: The IDEA Plugin is not compatible with the <<configuration_cache.adoc#config_cache:plugins:core,configuration cache>>.
   
   The IDEA plugin generates files that are used by http://www.jetbrains.com/idea/[IntelliJ IDEA], thus making it possible to open the project from IDEA (`File` - `Open Project`). Both external dependencies (including associated source and Javadoc files) and project dependencies are considered.
   
   [NOTE]
   ====
   If you simply want to load a Gradle project into IntelliJ IDEA, then use the IDE's https://www.jetbrains.com/help/idea/gradle.html#gradle_import[import facility].
   You do not need to apply this plugin to import your project into IDEA, although if you do, the import will take account of any extra IDEA configuration you have that doesn't directly modify the generated files  see the <<#sec:idea_configuration,Configuration>> section for more details.
   ====
   
   What exactly the IDEA plugin generates depends on which other plugins are used:
   
   *Always*::
   Generates an IDEA module file. Also generates an IDEA project and workspace file if the project is the root project.
   
   *<<java_plugin.adoc#java_plugin,Java Plugin>>*::
   Additionally adds Java configuration to the IDEA module and project files.
   
   One focus of the IDEA plugin is to be open to customization. The plugin provides a standardized set of hooks for adding and removing content from the generated files.
   
   
   == Usage
   
   To use the IDEA plugin, include this in your build script:
   
   .Using the IDEA plugin
   ====
   include::sample[dir="snippets/ide/idea/kotlin",files="build.gradle.kts[tags=use-plugin]"]
   include::sample[dir="snippets/ide/idea/groovy",files="build.gradle[tags=use-plugin]"]
   ====
   
   The IDEA plugin adds a number of tasks to your project. The `idea` task generates an IDEA module file for the project. When the project is the root project, the `idea` task also generates an IDEA project and workspace. The IDEA project includes modules for each of the projects in the Gradle build.
   
   The IDEA plugin also adds an `openIdea` task when the project is the root project. This task generates the IDEA configuration files and opens the result in IDEA. This means you can simply run `./gradlew openIdea` from the root project to generate and open the IDEA project in one convenient step.
   
   The IDEA plugin also adds a `cleanIdea` task to the project. This task deletes the generated files, if present.
   
   == Tasks
   
   The IDEA plugin adds the tasks shown below to a project. Notice that the `clean` task does not depend on the `cleanIdeaWorkspace` task. This is because the workspace typically contains a lot of user specific temporary data and it is not desirable to manipulate it outside IDEA.
   
   `idea`::
   _Depends on_: `ideaProject`, `ideaModule`, `ideaWorkspace`
   +
   Generates all IDEA configuration files
   
   `openIdea`::
   _Depends on_: `idea`
   +
   Generates all IDEA configuration files and opens the project in IDEA
   
   `cleanIdea`  link:{groovyDslPath}#[Delete]::
   _Depends on_: `cleanIdeaProject`, `cleanIdeaModule`
   +
   Removes all IDEA configuration files
   
   `cleanIdeaProject`  link:{groovyDslPath}#[Delete]::
   Removes the IDEA project file
   
   `cleanIdeaModule`  link:{groovyDslPath}#[Delete]::
   Removes the IDEA module file
   
   `cleanIdeaWorkspace`  link:{groovyDslPath}#[Delete]::
   Removes the IDEA workspace file
   
   `ideaProject`  link:{groovyDslPath}#[GenerateIdeaProject]::
   Generates the `.ipr` file. This task is only added to the root project.
   
   `ideaModule`  link:{groovyDslPath}#[GenerateIdeaModule]::
   Generates the `.iml` file
   
   `ideaWorkspace`  link:{groovyDslPath}#[GenerateIdeaWorkspace]::
   Generates the `.iws` file. This task is only added to the root project.
   
   
   == Configuration
   
   The plugin adds some configuration options that allow to customize the IDEA project and module files that it generates. These take the form of both model properties and lower-level mechanisms that modify the generated files directly. For example, you can add source and resource directories, as well as inject your own fragments of XML. The former type of configuration is honored by IDEA's import facility, whereas the latter is not.
   
   Here are the configuration properties you can use:
   
   
   `idea`  link:{groovyDslPath}#[IdeaModel]::
   Top level element that enables configuration of the idea plugin in a DSL-friendly fashion
   
   `idea.project` link:{groovyDslPath}#[IdeaProject]::
   Allows configuring project information
   
   `idea.module` link:{groovyDslPath}#[IdeaModule]::
   Allows configuring module information
   
   `idea.workspace` link:{groovyDslPath}#[IdeaWorkspace]::
   Allows configuring the workspace XML
   
   Follow the links to the types for examples of using these configuration properties.
   
   
   == Customizing the generated files
   
   The IDEA plugin provides hooks and behavior for customizing the generated content in a more controlled and detailed way. In addition, the `withXml` hook is the only practical way to modify the workspace file because its corresponding domain object is essentially empty.
   
   NOTE: The techniques we discuss in this section don't work with IDEA's import facility
   
   The tasks recognize existing IDEA files and merge them with the generated content.
   
   
   === Merging
   
   Sections of existing IDEA files that are also the target of generated content will be amended or overwritten, depending on the particular section. The remaining sections will be left as-is.
   
   
   ==== Disabling merging with a complete overwrite
   
   To completely rewrite existing IDEA files, execute a clean task together with its corresponding generation task, like `gradle cleanIdea idea` (in that order). If you want to make this the default behavior, add `tasks.idea.dependsOn(cleanIdea)` to your build script. This makes it unnecessary to execute the clean task explicitly.
   
   This strategy can also be used for individual files that the plugin would generate. For instance, this can be done for the `.iml` file with `gradle cleanIdeaModule ideaModule`.
   
   === Hooking into the generation lifecycle
   
   The plugin provides objects modeling the sections of the metadata files that are generated by Gradle. The generation lifecycle is as follows:
   
    1. The file is read; or a default version provided by Gradle is used if it does not exist
    2. The `beforeMerged` hook is executed with a domain object representing the existing file
    3. The existing content is merged with the configuration inferred from the Gradle build or defined explicitly in the eclipse DSL
    4. The `whenMerged` hook is executed with a domain object representing contents of the file to be persisted
    5. The `withXml` hook is executed with a raw representation of the XML that will be persisted
    6. The final XML is persisted
   
   The following are the domain objects used for each of the model types:
   
   link:{groovyDslPath}#[IdeaProject]::
   +
    * `beforeMerged { link:{javadocPath}#[Project] arg \-> ... }`
    * `whenMerged { link:{javadocPath}#[Project] arg \-> ... }`
    * `withXml { link:{javadocPath}#[XmlProvider] arg \-> ... }`
   
   link:{javadocPath}#[IdeaModule]::
    * `beforeMerged { link:{javadocPath}#[Module] arg \-> ... }`
    * `whenMerged { link:{javadocPath}#[Module] arg \-> ... }`
    * `withXml { link:{javadocPath}#[XmlProvider] arg \-> ... }`
   
   link:{javadocPath}#[IdeaWorkspace]::
    * `beforeMerged { link:{javadocPath}#[Workspace] arg \-> ... }`
    * `whenMerged { link:{javadocPath}#[Workspace] arg \-> ... }`
    * `withXml { link:{javadocPath}#[XmlProvider] arg \-> ... }`
   
   
   ==== Partial rewrite of existing content
   
   A "complete rewrite" causes all existing content to be discarded, thereby losing any changes made directly in the IDE. The `beforeMerged` hook makes it possible to overwrite just certain parts of the existing content. The following example removes all existing dependencies from the `Module` domain object:
   
   .Partial Rewrite for Module
   ====
   include::sample[dir="snippets/ide/idea/kotlin",files="build.gradle.kts[tags=module-before-merged]"]
   include::sample[dir="snippets/ide/idea/groovy",files="build.gradle[tags=module-before-merged]"]
   ====
   
   The resulting module file will only contain Gradle-generated dependency entries, but not any other dependency entries that may have been present in the original file. (In the case of dependency entries, this is also the default behavior.) Other sections of the module file will be either left as-is or merged. The same could be done for the module paths in the project file:
   
   .Partial Rewrite for Project
   ====
   include::sample[dir="snippets/ide/idea/kotlin",files="build.gradle.kts[tags=project-before-merged]"]
   include::sample[dir="snippets/ide/idea/groovy",files="build.gradle[tags=project-before-merged]"]
   ====
   
   ==== Modifying the fully populated domain objects
   
   The `whenMerged` hook allows you to manipulate the fully populated domain objects. Often this is the preferred way to customize IDEA files. Here is how you would export all the dependencies of an IDEA module:
   
   .Export Dependencies
   ====
   include::sample[dir="snippets/ide/idea/kotlin",files="build.gradle.kts[tags=module-when-merged]"]
   include::sample[dir="snippets/ide/idea/groovy",files="build.gradle[tags=module-when-merged]"]
   ====
   
   ==== Modifying the XML representation
   
   The `withXml` hook allows you to manipulate the in-memory XML representation just before the file gets written to disk. Although Groovy's XML support and Kotlin's extension functions make up for a lot, this approach is less convenient than manipulating the domain objects. In return, you get total control over the generated file, including sections not modeled by the domain objects.
   
   .Customizing the XML
   ====
   include::sample[dir="snippets/ide/idea/kotlin",files="build.gradle.kts[tags=project-with-xml]"]
   include::sample[dir="snippets/ide/idea/groovy",files="build.gradle[tags=project-with-xml]"]
   ====
   
   == Identifying additional test directories
   
   When using this plugin together with the <<java_plugin.adoc#java_plugin,Java plugin>>, after adding additional source sets you may wish to inform IDEA when they contain test source rather than production source, so that the IDE can treat the directories appropriately.  This can be accomplished by using this plugin's `Module` block.
   
   .Identifying Additional Test Directories in SourceSets
   ====
   include::sample[dir="snippets/ide/ideaAdditionalTestSources/kotlin",files="build.gradle.kts[tags=mark-additional-sourcesets-as-test]"]
   include::sample[dir="snippets/ide/ideaAdditionalTestSources/groovy",files="build.gradle[tags=mark-additional-sourcesets-as-test]"]
   ====
   
   NOTE: When working with the <<jvm_test_suite_plugin#jvm_test_suite_plugin,JVM Test Suite Plugin>>, test sources will automatically identified correctly.
   
   == Further things to consider
   
   The paths of dependencies in the generated IDEA files are absolute. If you manually define a path variable pointing to the Gradle dependency cache, IDEA will automatically replace the absolute dependency paths with this path variable. you can configure this path variable via the `idea.pathVariables` property, so that it can do a proper merge without creating duplicates.

/docs/userguide/core-plugins/visual_studio_plugin.adoc
======================================================

.. code-block::

   = Visual Studio
   
   WARNING: The Visual Studio Plugin is not compatible with the <<configuration_cache.adoc#config_cache:plugins:core,configuration cache>>.
   
   The Visual Studio Plugin generate files that are used by the https://visualstudio.microsoft.com/[Visual Studio IDE], thus making it possible to open the solution into Visual Studio (`File` - `Open` - `Project/Solution...`).
   
   What exactly the `visual-studio` plugin generates depends on which other plugins are used:
   
   .Visual Studio Plugin behavior
   [%header%autowidth,compact]
   |===
   | Plugin | Description
   
   | None
   | Generates minimal solution file.
   
   | <<cpp_application_plugin.adoc#cpp_application_plugin,{cpp} Application>>
   | Adds a project representing the {cpp} application to the solution file.
   
   | <<cpp_library_plugin.adoc#cpp_library_plugin,{cpp} Library>>
   | Adds a project for each specified linkage representing the shared and/or static library to the solution file.
   |===
   
   == Usage
   
   .Applying the Visual Studio Plugin
   ====
   include::sample[dir="snippets/ide/visualStudio/kotlin",files="build.gradle.kts[tags=apply-plugin]"]
   include::sample[dir="snippets/ide/visualStudio/groovy",files="build.gradle[tags=apply-plugin]"]
   ====
   
   The Visual Studio Plugin adds a number of tasks to your project.
   The main tasks that you will use are the `visualStudio`, `cleanVisualStudio` and `openVisualStudio` tasks.
   
   == Tasks
   
   The following diagram shows the relationships between tasks added by this plugin.
   
   .Visual Studio Plugin default task graph
   image::visual-studio-task-graph.png[]
   
   === Lifecycle Tasks
   
   `visualStudio`  link:{groovyDslPath}#[Task]::
   _Depends on_: `__projectName__VisualStudioSolution` and all Visual Studio project file generation tasks
   +
   Generates all Visual Studio configuration files.
   
   `cleanVisualStudio`  link:{groovyDslPath}#[Delete]::
   _Depends on_: all Visual Studio project and solution file clean tasks
   +
   Removes all Visual Studio configuration files.
   
   `openVisualStudio` - link:{groovyDslPath}#[Task]::
   _Depends on_: `visualStudio`
   +
   Open the Visual Studio solution inside the IDE.
   
   === IDE Workspace Tasks
   
   `__projectName__VisualStudioSolution` - link:{groovyDslPath}#[GenerateSolutionFileTask]::
   +
   Generates the `.sln` file. This task is only available on the root project.
   
   === IDE Project Tasks
   
   ==== {cpp} Application Plugin Tasks
   
   `__projectName__VisualStudioProject`  link:{groovyDslPath}#[GenerateProjectFileTask]::
   +
   Generates the `.vcxproj` file for the application component.
   
   `__projectName__VisualStudioFilters`  link:{groovyDslPath}#[GenerateFiltersFileTask]::
   +
   Generates the `.vcxproj.filters` file for the application component.
   
   `mainVisualStudio` - link:{groovyDslPath}#[Task] (lifecycle)::
   _Depends on_: `__projectName__VisualStudioProject` and `__projectName__VisualStudioFilters`
   +
   Generates all Visual Studio project files for the application component.
   
   ==== {cpp} Library Plugin Tasks
   
   `__projectName__DllVisualStudioProject`  link:{groovyDslPath}#[GenerateProjectFileTask]::
   +
   Generates the `.vcxproj` file for the shared linkage of the `main` component.
   
   `__projectName__DllVisualStudioFilters`  link:{groovyDslPath}#[GenerateFiltersFileTask]::
   +
   Generates the `.vcxproj.filters` file for the shared linkage of the `main` component.
   
   `__projectName__LibVisualStudioProject`  link:{groovyDslPath}#[GenerateProjectFileTask]::
   +
   Generates the `.vcxproj` file for the static linkage of the `main` component.
   
   `__projectName__LibVisualStudioFilters`  link:{groovyDslPath}#[GenerateFiltersFileTask]::
   +
   Generates the `.vcxproj.filters` file for the static linkage of the `main` component.
   
   `mainVisualStudio` - link:{groovyDslPath}#[Task] (lifecycle)::
   _Depends on_: `__projectName__DllVisualStudioProject` (for shared linkage), `__projectName__DllVisualStudioFilters` (for shared linkage), `__projectName__LibVisualStudioProject` (for static linkage) and `__projectName__LibVisualStudioFilters` (for static linkage)
   +
   Generates all Visual Studio project files for the library component.
   
   == Configuration
   
   The Visual Studio Plugin allows for some customization of the generated files.
   The following sections are shows the customization.
   
   === Change solution generated file location
   
   The location of the generated solution can be configured on the root project:
   
   .Change the generated solution file location
   ====
   include::sample[dir="snippets/ide/visualStudio/kotlin",files="build.gradle.kts[tags=configure-solution-location]"]
   include::sample[dir="snippets/ide/visualStudio/groovy",files="build.gradle[tags=configure-solution-location]"]
   ====
   
   === Change project generated files location
   
   The location of the generated project files can be configured on any project:
   
   .Change the generated project files location
   ====
   include::sample[dir="snippets/ide/visualStudio/kotlin",files="build.gradle.kts[tags=configure-project-and-filters-location]"]
   include::sample[dir="snippets/ide/visualStudio/groovy",files="build.gradle[tags=configure-project-and-filters-location]"]
   ====

/docs/userguide/native/xcode_plugin.adoc
========================================

.. code-block::

   = Xcode
   
   WARNING: The Xcode Plugin is not compatible with the <<configuration_cache.adoc#config_cache:plugins:core,configuration cache>>.
   
   The Xcode Plugin generate files that are used by the https://developer.apple.com/xcode/[Xcode IDE] to open Gradle projects into Xcode (`File` - `Open...`). The generated Xcode project delegates build actions to Gradle.
   
   What exactly the `xcode` plugin generates depends on which other plugins are used:
   
   .Xcode Plugin behavior
   [%header%autowidth,compact]
   |===
   | Plugin | Description
   
   | None
   | Generates minimal solution file.
   
   | <<cpp_application_plugin.adoc#cpp_application_plugin,{cpp} Application>>
   | Adds a target representing the {cpp} application to the project file.
   
   | <<cpp_library_plugin.adoc#cpp_library_plugin,{cpp} Library>>
   | Adds a target for each specified linkage representing the shared and/or static library to the project file.
   
   | <<swift_application_plugin.adoc#swift_application_plugin,Swift Application>>
   | Adds a target representing the Swift application to the project file.
   
   | <<swift_library_plugin.adoc#swift_library_plugin,Swift Library>>
   | Adds a target for each specified linkage representing the shared and/or static library to the project file.
   
   | <<xctest_plugin.adoc#xctest_plugin,XCTest>>
   | Adds a target representing the XCTest bundle to the project file.
   | The tested target is also configured to enable a seamless workflow from the IDE.
   |===
   
   == Usage
   
   .Applying the Xcode Plugin
   ====
   include::sample[dir="snippets/ide/xcode/kotlin",files="build.gradle.kts[tags=apply-plugin]"]
   include::sample[dir="snippets/ide/xcode/groovy",files="build.gradle[tags=apply-plugin]"]
   ====
   
   == Tasks
   
   The Xcode Plugin adds a number of tasks to your project.
   The main tasks that you will use are the `xcode`, `cleanXcode` and `openXcode` tasks.
   
   The following diagram shows the relationships between tasks added by this plugin.
   
   .Xcode Plugin default task graph
   image::xcode-task-graph.png[]
   
   === Lifecycle Tasks
   
   `xcode`  link:{groovyDslPath}#[Task]::
   _Depends on_: `__projectName__XcodeWorkspace` and all `xcodeProject` tasks
   +
   Generates all Xcode configuration files.
   
   `cleanXcode`  link:{groovyDslPath}#[Delete]::
   _Depends on_: all Xcode project and workspace file clean tasks
   +
   Removes all Xcode configuration files.
   
   `openXcode` - link:{groovyDslPath}#[Task]::
   _Depends on_: `xcode`
   +
   Open the Xcode workspace inside the IDE.
   
   === IDE Workspace Tasks
   
   `xcodeWorkspaceWorkspaceSettings` - link:{groovyDslPath}#[GenerateWorkspaceSettingsFileTask]::
   +
   Generates the `__projectName__.xcworkspace` file. This task is only available on the root project.
   
   `xcodeWorkspace` - link:{groovyDslPath}#[GenerateXcodeProjectFileTask]::
   _Depends on_: `xcodeWorkspaceWorkspaceSettings`
   +
   Generates the `__projectName__.xcworkspace` file. This task is only available on the root project.
   
   === IDE Project Tasks
   
   Both the <<cpp_application_plugin.adoc#cpp_application_plugin,{cpp} Application Plugin>> and <<cpp_library_plugin.adoc#cpp_library_plugin,{cpp} Library Plugin>> introduce the same tasks for generating Xcode projects to be included in an Xcode workspace.
   
   `xcodeProjectWorkspaceSettings`  link:{groovyDslPath}#[GenerateWorkspaceSettingsFileTask]::
   +
   Generates the `__projectName__.xcodeproj/project.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings` file.
   
   `xcodeScheme`  link:{groovyDslPath}#[GenerateSchemeFileTask]::
   +
   Generates the `__projectName__.xcodeproj/xcshareddata/xcschemes/__ProjectName__.xcscheme` file.
   
   `xcodeProject`  link:{groovyDslPath}#[GenerateXcodeProjectFileTask]::
   _Depends on_: `xcodeProjectWorkspaceSettings` and `xcodeScheme` (if buildable binary present)
   +
   Generates the `__projectName__.xcodeproj/project.pbxproj` file.
   
   == Configuration
   
   The Xcode Plugin doesn't allows any customization of the generated files.

/Section: 游릭 Utility
======================


/docs/userguide/core-plugins/base_plugin.adoc
=============================================

.. code-block::

   = The Base Plugin
   
   The Base Plugin provides some tasks and conventions that are common to most builds and adds a structure to the build that promotes consistency in how they are run. Its most significant contribution is a set of <<lifecycle_tasks.adoc#sec:lifecycle_tasks,_lifecycle_ tasks>> that act as an umbrella for the more specific tasks provided by other plugins and build authors.
   
   == Usage
   
   
   .Applying the Base Plugin
   ====
   include::sample[dir="snippets/base/basePlugin/kotlin",files="build.gradle.kts[tags=apply-base-plugin]"]
   include::sample[dir="snippets/base/basePlugin/groovy",files="build.gradle[tags=apply-base-plugin]"]
   ====
   
   == Task
   
   `clean`  `Delete`::
   Deletes the build directory and everything in it, i.e. the path specified by the link:{groovyDslPath}#[layout.buildDirectory] project property.
   
   `check` 댹_lifecycle task_::
   Plugins and build authors should attach their verification tasks, such as ones that run tests, to this lifecycle task using `check.dependsOn(__task__)`.
   
   `assemble`  _lifecycle task_::
   Plugins and build authors should attach tasks that produce distributions and other consumable artifacts to this lifecycle task. For example, `jar` produces the consumable artifact for Java libraries. Attach tasks to this lifecycle task using `assemble.dependsOn(__task__)`.
   
   `build` 댹_lifecycle task_::
   _Depends on_: `check`, `assemble`
   +
   Intended to build everything, including running all tests, producing the production artifacts and generating documentation. You will probably rarely attach concrete tasks directly to `build` as `assemble` and `check` are typically more appropriate.
   
   `build__Configuration__` 댹맚ask rule::
   Assembles those artifacts attached to the named configuration. For example, `buildRuntimeElements` will execute any task that is required to create any artifact attached to the `runtimeElements` configuration.
   
   `clean__Task__` 댹맚ask rule::
   Removes the <<incremental_build.adoc#sec:task_inputs_outputs,defined outputs>> of a task, e.g. `cleanJar` will delete the JAR file produced by the `jar` task of the Java Plugin.
   
   
   == Dependency management
   
   The Base Plugin adds no <<declaring_dependencies.adoc#sec:what-are-dependency-configurations,configurations for dependencies>>, but it does add the following configurations:
   
   `default`::
   A fallback configuration used when dependency resolution is performed without request attributes.
   +
   *New builds and plugins should not be using the `default` configuration!*
   It remains solely for backwards compatibility.
   Dependency resolution should be performed with request attributes.
   
   `archives`::
   All artifacts defined on the `archives` configuration are automatically built by the `assemble` task.
   +
   *New builds and plugins should not be using the `archives` configuration!*
   It remains solely for backwards compatibility.
   Instead, task dependencies should be declared directly on the `assemble` task.
   
   == Contributed extensions
   
   The Base Plugin adds the link:{groovyDslPath}#[`base` extension] to the project.
   This allows to configure the following properties inside a dedicated DSL block.
   
   .Using the `base` extension
   ====
   include::sample[dir="snippets/files/archivesChangedBaseName/kotlin",files="build.gradle.kts[tags=base-plugin-config]"]
   include::sample[dir="snippets/files/archivesChangedBaseName/groovy",files="build.gradle[tags=base-plugin-config]"]
   ====
   
   `archivesName`  default: `$project.name`::
   Provides the default link:{groovyDslPath}#[AbstractArchiveTask.getArchiveBaseName()] for archive tasks.
   
   `distsDirectory`  default: `layout.buildDirectory.dir("distributions")`::
   Default name of the directory in which distribution archives, i.e. non-JARs, are created.
   
   `libsDirectory`  default: `layout.buildDirectory.dir("libs")`::
   Default name of the directory in which library archives, i.e. JARs, are created.
   
   The plugin also provides default values for the following properties on any task that extends link:{groovyDslPath}#[AbstractArchiveTask]:
   
   `destinationDirectory`::
   Defaults to `distsDirectory` for non-JAR archives and `libsDirectory` for JARs and derivatives of JAR, such as WARs.
   
   `archiveVersion`::
   Defaults to `$project.version` or 'unspecified' if the project has no version.
   
   `archiveBaseName`::
   Defaults to `$archivesBaseName`.
   
   == Conventions (deprecated)
   
   The Base Plugin also adds conventions related to the creation of archives, such as ZIPs, TARs and JARs.
   These are *deprecated* and superseded by the extension described above.
   See the link:{groovyDslPath}#[BasePluginConvention] DSL documentation for information on them.

/docs/userguide/core-plugins/build_init_plugin.adoc
===================================================

.. code-block::

   = Build Init Plugin
   
   
   The Build Init plugin can be used to create a new Gradle build. It supports creating brand new Gradle builds of various types as well as converting existing Apache Maven builds to Gradle.
   
   == Sample usage
   
   ```bash
   gradle init \
     --type java-application \
     --dsl kotlin \
     --test-framework junit-jupiter \
     --package my.project \
     --project-name my-project  \
     --no-split-project  \
     --java-version 17
   ```
   
   Gradle enters interactive mode and prompts the user when a required parameter for the selected project type is missing.
   
   == Supported Gradle build types
   
   The Build Init plugin supports generating various build _types_. These are listed below and more detail is available about each type in the following <<#sec:build_init_types,section>>.
   
   .Build init types
   [options="header"]
   |=================
   |Type|Description
   |<<#sec:pom_maven_conversion,pom>>|Converts an existing Apache Maven build to Gradle
   |<<#sec:basic,basic>>|A basic, empty, Gradle build
   |<<#sec:java_application,java-application>>|A command-line application implemented in Java
   |<<#sec:java_gradle_plugin,java-gradle-plugin>>|A Gradle plugin implemented in Java
   |<<#sec:java_library,java-library>>|A Java library
   |<<#sec:kotlin_application,kotlin-application>>|A command-line application implemented in Kotlin/JVM
   |<<#sec:kotlin_gradle_plugin,kotlin-gradle-plugin>>|A Gradle plugin implemented in Kotlin/JVM
   |<<#sec:kotlin_library,kotlin-library>>|A Kotlin/JVM library
   |<<#sec:groovy_application,groovy-application>>|A command-line application implemented in Groovy
   |<<#sec:groovy_gradle_plugin,groovy-gradle-plugin>>|A Gradle plugin implemented in Groovy
   |<<#sec:groovy_library,groovy-library>>|A Groovy library
   |<<#sec:scala_application,scala-application>>|A Scala application
   |<<#sec:scala_library,scala-library>>|A Scala library
   |<<#sec:cpp_application,cpp-application>>|A command-line application implemented in C++
   |<<#sec:cpp_library,cpp-library>>|A C++ library
   |=================
   
   == Tasks
   
   The plugin adds the following tasks to the project:
   
   `init`  link:{groovyDslPath}#[InitBuild]::
   Generates a Gradle build.
   
   Gradle plugins usually need to be _applied_ to a project before they can be used (see <<plugins.adoc#sec:using_plugins,Using plugins>>). However, the Build Init plugin is automatically applied to the root project of every build, which means you do not need to apply it explicitly in order to use it. You can simply execute the task named `init` in the directory where you would like to create the Gradle build. There is no need to create a 랍tub `build.gradle` file in order to apply the plugin.
   
   == What to create
   
   The simplest, and recommended, way to use the `init` task is to run `gradle init` from an interactive console. Gradle will list the available build types and ask you to select one. It will then ask some additional questions to allow you to fine-tune the result.
   
   There are several command-line options available for the `init` task that control what it will generate. You can use these when Gradle is not running from an interactive console.
   You can see available options using the `help` task:
   
   ```bash
   gradle help --task init
   ```
   
   The build type can be specified by using the `--type` command-line option.
   For example, to create a Java library project run:
   
   ```bash
   gradle init --type java-library
   ```
   
   If a `--type` option is not provided, Gradle will attempt to infer the type from the environment. For example, it will infer a type of `pom` if it finds a `pom.xml` file to convert to a Gradle build. If the type could not be inferred, the type `basic` will be used.
   
   The `init` task also supports generating build scripts using either the Gradle Kotlin DSL or the Gradle Groovy DSL. The build script DSL defaults to the Kotlin DSL for most build types and to the Groovy DSL for Groovy build types. The DSL can be selected by using the `--dsl` command-line option.
   
   For example, to create a Java library project with Kotlin DSL build scripts, run:
   
   ```bash
   gradle init --type java-library --dsl kotlin
   ```
   
   You can change the name of the generated project using the `--project-name` option. It defaults to the name of the directory where the `init` task is run.
   
   You can change the package used for generated source files using the `--package` option. It defaults to the project name.
   
   If the `--incubating` option is provided, Gradle will generate build scripts which may use the latest versions of APIs, which are marked `@Incubating` and remain <<feature_lifecycle.adoc#feature_lifecycle,subject to change>>. To disable this behavior, use `--no-incubating`.
   
   All build types also set up <<gradle_wrapper.adoc#gradle_wrapper_reference, Gradle Wrapper>> in the build.
   
   == Build init types
   
   
   === `pom` build type (Maven conversion)
   
   The `pom` type can be used to convert an Apache Maven build to a Gradle build. This works by converting the POM to one or more Gradle files. It is only able to be used if there is a valid `pom.xml` file in the directory that the `init` task is invoked in or, if invoked via the "`-p`" <<command_line_interface.adoc#command_line_interface,command line option>>, in the specified project directory. This `pom` type will be automatically inferred if such a file exists.
   
   The Maven conversion implementation was inspired by the https://github.com/jbaruch/maven2gradle[maven2gradle tool] that was originally developed by Gradle community members.
   
   The conversion process has the following features:
   
   * Uses effective POM and effective settings (support for POM inheritance, dependency management, properties)
   * Supports both single module and multimodule projects
   * Supports custom module names (that differ from directory names)
   * Generates general metadata - id, description and version
   * Applies <<publishing_maven.adoc#publishing_maven,Maven Publish>>, <<java_library_plugin.adoc#java_library_plugin,Java Library>> and <<war_plugin.adoc#war_plugin,War>> Plugins (as needed)
   * Supports packaging war projects as jars if needed
   * Generates dependencies (both external and inter-module)
   * Generates download repositories (inc. local Maven repository)
   * Adjusts Java compiler settings
   * Supports packaging of sources, tests, and javadocs
   * Supports TestNG runner
   * Generates global exclusions from Maven enforcer plugin settings
   * Provides <<build_init_plugin.adoc#sec:allow_insecure,an option for handling Maven repositories located at URLs using `http`>>
   
   ==== The `--insecure-protocol` option
   This option is used to tell the conversion process how to handle converting Maven repositories located at insecure `http` URLs.  Insecure Repositories Set the
   link:{groovyDslPath}#[--insecure-protocol] option.  The default value is `warn`.
   
   Available values are:
   
   * `fail` - Abort the build immediately upon encountering an insecure repository URL.
   * `allow` - Automatically sets the `allowInsecureProtocol` property to `true` for the Maven repository URL in the generated Gradle build script.
   * `warn` - Emits a warning about each insecure URL.  Generates commented-out lines to enable each repository, as per the `allow` option.  You will have to opt-in by editing the generated script and uncommenting each repository URL, or else the Gradle build will fail.
   * `upgrade` - Convert `http` URLs to `https` URLs automatically.
   
   ==== Compile-time dependencies
   
   Maven automatically exposes dependencies using its implicit `compile` scope to the consumers of that project.
   This behavior is undesirable, and Gradle takes steps to help library authors reduce their API footprint using the `api` and `implementation` configurations of the `java-library` plugin.
   
   Nevertheless, many Maven projects rely on this _leaking_ behavior. As such, the `init` task will map `compile`-scoped dependencies to the `api` configuration in the generated Gradle build script. The dependencies of the resulting Gradle project will most closely match the exposed dependencies of the existing Maven project; however, post-conversion to Gradle we strongly encourage moving as many `api` dependencies to the `implementation` configuration as possible. This has several benefits:
   
   * Library maintainability - By exposing fewer transitive dependencies to consumers, library maintainers can add or remove dependencies without fear of causing compile-time breakages for consumers.
   * Consumers' dependency hygiene - Leveraging the `implementation` configuration in a library prevents its consumers from implicitly relying on the library's transitive dependencies at compile-time, which is considered a bad practice.
   * Increased compile avoidance - Reducing the number of transitive dependencies leaked from a project also reduces the likelihood that an ABI change will trigger recompilation of consumers. Gradle will also spend less time indexing the dependencies for its up-to-date checks.
   * Compilation speed increase - Reducing the number of transitive dependencies leaked from a project aids the compiler process of its consumers as there are fewer libraries to classload and fewer namespaces for Gradle's incremental compiler to track.
   
   See the <<java_library_plugin.adoc#sec:java_library_separation,API and implementation separation>> and <<java_plugin.adoc#sec:java_compile_avoidance,Compilation avoidance>> sections for more information.
   
   === `java-application` build type
   
   The `java-application` build type is not inferable. It must be explicitly specified.
   
   It has the following features:
   
   * Uses the `application` plugin to produce a command-line application implemented in Java
   * Uses the `mavenCentral` dependency repository
   * Uses https://junit.org/junit4/[JUnit 4] for testing
   * Has directories in the conventional locations for source code
   * Contains a sample class and unit test, if there are no existing source or test files
   
   Alternative test framework can be specified by supplying a `--test-framework` argument value. To use a different test framework, execute one of the following commands:
   
   * `gradle init --type java-application --test-framework junit-jupiter`: Uses https://junit.org[JUnit Jupiter] for testing instead of JUnit 4
   * `gradle init --type java-application --test-framework spock`: Uses https://spockframework.org[Spock] for testing instead of JUnit 4
   * `gradle init --type java-application --test-framework testng`: Uses https://testng.org/doc/index.html[TestNG] for testing instead of JUnit 4
   
   
   ==== The `--java-version` option
   
   When creating a java project you must set the java version. You can do that by supplying *the major version* of java you wish to use:
   
   ```bash
   gradle init --type java-application  --java-version 11 --dsl kotlin # and other parameters
   ```
   
   === `java-library` build type
   
   The `java-library` build type is not inferable. It must be explicitly specified.
   
   It has the following features:
   
   * Uses the `java` plugin to produce a library implemented in Java
   * Uses the `mavenCentral` dependency repository
   * Uses https://junit.org/junit4/[JUnit 4] for testing
   * Has directories in the conventional locations for source code
   * Contains a sample class and unit test, if there are no existing source or test files
   
   Alternative test framework can be specified by supplying a `--test-framework` argument value. To use a different test framework, execute one of the following commands:
   
   * `gradle init --type java-library --test-framework junit-jupiter`: Uses https://junit.org[JUnit Jupiter] for testing instead of JUnit 4
   * `gradle init --type java-library --test-framework spock`: Uses http://code.google.com/p/spock/[Spock] for testing instead of JUnit 4
   * `gradle init --type java-library --test-framework testng`: Uses http://testng.org/doc/index.html[TestNG] for testing instead of JUnit 4
   
   
   === `java-gradle-plugin` build type
   
   The `java-gradle-plugin` build type is not inferable. It must be explicitly specified.
   
   It has the following features:
   
   * Uses the `java-gradle-plugin` plugin to produce a Gradle plugin implemented in Java
   * Uses the `mavenCentral` dependency repository
   * Uses https://junit.org/junit4/[JUnit 4] and TestKit for testing
   * Has directories in the conventional locations for source code
   * Contains a sample class and unit test, if there are no existing source or test files
   
   
   === `kotlin-application` build type
   
   The `kotlin-application` build type is not inferable. It must be explicitly specified.
   
   It has the following features:
   
   * Uses the `org.jetbrains.kotlin.jvm` and `application` plugins to produce a command-line application implemented in Kotlin
   * Uses the `mavenCentral` dependency repository
   * Uses Kotlin 1.x
   * Uses https://kotlinlang.org/api/latest/kotlin.test/index.html[Kotlin test library] for testing
   * Has directories in the conventional locations for source code
   * Contains a sample Kotlin class and an associated Kotlin test class, if there are no existing source or test files
   
   
   === `kotlin-library` build type
   
   The `kotlin-library` build type is not inferable. It must be explicitly specified.
   
   It has the following features:
   
   * Uses the `org.jetbrains.kotlin.jvm` plugin to produce a library implemented in Kotlin
   * Uses the `mavenCentral` dependency repository
   * Uses Kotlin 1.x
   * Uses https://kotlinlang.org/api/latest/kotlin.test/index.html[Kotlin test library] for testing
   * Has directories in the conventional locations for source code
   * Contains a sample Kotlin class and an associated Kotlin test class, if there are no existing source or test files
   
   
   === `kotlin-gradle-plugin` build type
   
   The `kotlin-gradle-plugin` build type is not inferable. It must be explicitly specified.
   
   It has the following features:
   
   * Uses the `java-gradle-plugin` and `org.jetbrains.kotlin.jvm` plugins to produce a Gradle plugin implemented in Kotlin
   * Uses the `mavenCentral` dependency repository
   * Uses Kotlin 1.x
   * Uses https://kotlinlang.org/api/latest/kotlin.test/index.html[Kotlin test library] and TestKit for testing
   * Has directories in the conventional locations for source code
   * Contains a sample class and unit test, if there are no existing source or test files
   
   === `scala-application` build type
   
   The `scala-application` build type is not inferable. It must be explicitly specified.
   
   It has the following features:
   
   * Uses the `scala` plugin to produce an application implemented in Scala
   * Uses the `mavenCentral` dependency repository
   * Uses Scala 2.13
   * Uses http://www.scalatest.org[ScalaTest] for testing
   * Has directories in the conventional locations for source code
   * Contains a sample Scala class and an associated ScalaTest test suite, if there are no existing source or test files
   
   === `scala-library` build type
   
   The `scala-library` build type is not inferable. It must be explicitly specified.
   
   It has the following features:
   
   * Uses the `scala` plugin to produce a library implemented in Scala
   * Uses the `mavenCentral` dependency repository
   * Uses Scala 2.13
   * Uses http://www.scalatest.org[ScalaTest] for testing
   * Has directories in the conventional locations for source code
   * Contains a sample Scala class and an associated ScalaTest test suite, if there are no existing source or test files
   
   === `groovy-library` build type
   
   The `groovy-library` build type is not inferable. It must be explicitly specified.
   
   It has the following features:
   
   * Uses the `groovy` plugin to produce a library implemented in Groovy
   * Uses the `mavenCentral` dependency repository
   * Uses Groovy 2.x
   * Uses http://spockframework.org[Spock testing framework] for testing
   * Has directories in the conventional locations for source code
   * Contains a sample Groovy class and an associated Spock specification, if there are no existing source or test files
   
   
   === `groovy-application` build type
   
   The `groovy-application` build type is not inferable. It must be explicitly specified.
   
   It has the following features:
   
   * Uses the `application` and `groovy` plugins to produce a command-line application implemented in Groovy
   * Uses the `mavenCentral` dependency repository
   * Uses Groovy 2.x
   * Uses http://spockframework.org[Spock testing framework] for testing
   * Has directories in the conventional locations for source code
   * Contains a sample Groovy class and an associated Spock specification, if there are no existing source or test files
   
   
   === `groovy-gradle-plugin` build type
   
   The `groovy-gradle-plugin` build type is not inferable. It must be explicitly specified.
   
   It has the following features:
   
   * Uses the `java-gradle-plugin` and `groovy` plugins to produce a Gradle plugin implemented in Groovy
   * Uses the `mavenCentral` dependency repository
   * Uses Groovy 2.x
   * Uses http://spockframework.org[Spock testing framework] and TestKit for testing
   * Has directories in the conventional locations for source code
   * Contains a sample class and unit test, if there are no existing source or test files
   
   
   === `cpp-application` build type
   
   The `cpp-application` build type is not inferable. It must be explicitly specified.
   
   It has the following features:
   
   * Uses the `cpp-application` plugin to produce a command-line application implemented in C++
   * Uses the `cpp-unit-test` plugin to build and run simple unit tests
   * Has directories in the conventional locations for source code
   * Contains a sample C++ class, a private header file and an associated test class, if there are no existing source or test files
   
   
   === `cpp-library` build type
   
   The `cpp-library` build type is not inferable. It must be explicitly specified.
   
   It has the following features:
   
   * Uses the `cpp-library` plugin to produce a C++ library
   * Uses the `cpp-unit-test` plugin to build and run simple unit tests
   * Has directories in the conventional locations for source code
   * Contains a sample C++ class, a public header file and an associated test class, if there are no existing source or test files
   
   
   === `basic` build type
   
   The `basic` build type is useful for creating a new Gradle build. It creates sample settings and build files, with comments and links to help get started.
   
   This type is used when no type was explicitly specified, and no type could be inferred.

/docs/userguide/dep-man/06-publishing/signing_plugin.adoc
=========================================================

.. code-block::

   = The Signing Plugin
   
   The Signing Plugin adds the ability to digitally sign built files and artifacts. These digital signatures can then be used to prove who built the artifact the signature is attached to as well as other information such as when the signature was generated.
   
   The Signing Plugin currently only provides support for generating https://en.wikipedia.org/wiki/Pretty_Good_Privacy#OpenPGP[OpenPGP signatures] (which is the signature format http://central.sonatype.org/pages/requirements.html#sign-files-with-gpgpgp[required for publication to the Maven Central Repository]).
   
   == Usage
   
   To use the Signing Plugin, include the following in your build script:
   
   .Using the Signing Plugin
   ====
   include::sample[dir="snippets/signing/maven-publish/kotlin",files="build.gradle.kts[tags=use-plugin]"]
   include::sample[dir="snippets/signing/maven-publish/groovy",files="build.gradle[tags=use-plugin]"]
   ====
   
   == Signatory credentials
   
   In order to create OpenPGP signatures, you will need a key pair (instructions on creating a key pair using the https://www.gnupg.org/[GnuPG tools] can be found in the https://www.gnupg.org/documentation/howtos.html[GnuPG HOWTOs]). You need to provide the Signing Plugin with your key information, which means three things:
   
   * The public key ID (The last 8 symbols of the keyId. You can use `gpg -K` to get it).
   * The absolute path to the secret key ring file containing your private key. (Since gpg 2.1, you need to export the keys with command `gpg --keyring secring.gpg --export-secret-keys > ~/.gnupg/secring.gpg`).
   * The passphrase used to protect your private key.
   
   These items must be supplied as the values of the `signing.keyId`, `signing.secretKeyRingFile`, and `signing.password` properties, respectively.
   
   NOTE: Given the personal and private nature of these values, a good practice is to store them in the `gradle.properties` file in the user's Gradle home directory (described in <<build_environment.adoc#sec:gradle_system_properties,System properties>>) instead of in the project directory itself.
   
   [source,properties]
   ----
   signing.keyId=24875D73
   signing.password=secret
   signing.secretKeyRingFile=/Users/me/.gnupg/secring.gpg
   ----
   
   If specifying this information (especially `signing.password`) in the user `gradle.properties` file is not feasible for your environment, you can supply the information via the command line:
   ----
   > gradle sign -Psigning.secretKeyRingFile=/Users/me/.gnupg/secring.gpg -Psigning.password=secret -Psigning.keyId=24875D73
   ----
   
   === Using in-memory ascii-armored keys
   
   In some setups it is easier to use environment variables to pass the secret key and password used for signing.
   For instance, when using a CI server to sign artifacts, securely providing the keyring file is often troublesome.
   On the other hand, most CI servers provide means to securely store environment variables and provide them to builds.
   Using the following setup, you can pass the secret key (in ascii-armored format) and the password using the `ORG_GRADLE_PROJECT_signingKey` and `ORG_GRADLE_PROJECT_signingPassword` environment variables, respectively:
   
   ====
   include::sample[dir="snippets/signing/in-memory/kotlin",files="build.gradle.kts[tags=signing]"]
   include::sample[dir="snippets/signing/in-memory/groovy",files="build.gradle[tags=signing]"]
   ====
   
   === Using in-memory ascii-armored OpenPGP subkeys
   
   To prevent sharing of the master key and to keep it secure it is also possible to use in-memory ascii-armored subkeys.
   The main difference between using in-memory ascii-armored keys and subkeys is that it is necessary to specify key identifier as well.
   Using the following setup, you can pass the key identifier, secret key (in ascii-armored format) and the password using the `ORG_GRADLE_PROJECT_signingKeyId`, `ORG_GRADLE_PROJECT_signingKey` and `ORG_GRADLE_PROJECT_signingPassword`
   environment variables respectively:
   
   ====
   include::sample[dir="snippets/signing/in-memory-subkey/kotlin",files="build.gradle.kts[tags=signing]"]
   include::sample[dir="snippets/signing/in-memory-subkey/groovy",files="build.gradle[tags=signing]"]
   ====
   
   === Using OpenPGP subkeys
   
   OpenPGP supports subkeys, which are like the normal keys, except they're bound to a master key pair. One feature of OpenPGP subkeys is that they can be revoked independently of the master keys which makes key management easier. A practical case study of how subkeys can be leveraged in software development can be read on the https://wiki.debian.org/Subkeys[Debian wiki].
   
   The Signing Plugin supports OpenPGP subkeys out of the box. Just specify a subkey ID as the value in the `signing.keyId` property.
   
   == Using gpg-agent
   
   By default the Signing Plugin uses a Java-based implementation of PGP for signing. This implementation cannot use the gpg-agent program for managing private keys, though. If you want to use the gpg-agent, you can change the signatory implementation used by the Signing Plugin:
   
   .Sign with GnuPG
   ====
   include::sample[dir="snippets/signing/gnupg-signatory/kotlin",files="build.gradle.kts[tags=configure-signatory]"]
   include::sample[dir="snippets/signing/gnupg-signatory/groovy",files="build.gradle[tags=configure-signatory]"]
   ====
   
   This tells the Signing Plugin to use the `GnupgSignatory` instead of the default link:{javadocPath}#[PgpSignatory]. The `GnupgSignatory` relies on the gpg2 program to sign the artifacts. Of course, this requires that GnuPG is installed.
   
   Without any further configuration the `gpg` (on Windows: `gpg.exe`) executable found on the `PATH` will be used. The password is supplied by the `gpg-agent` and the default key is used for signing.
   
   
   === Gnupg signatory configuration
   
   The `GnupgSignatory` supports a number of configuration options for controlling how gpg is invoked. These are typically set in gradle.properties:
   
   === Example: Configure the GnupgSignatory
   
   [source.multi-language-sample,properties]
   .gradle.properties
   ----
   include::{snippetsPath}/signing/gnupg-signatory/groovy/gradle.properties[tag=user-properties]
   ----
   
   `signing.gnupg.executable`::
   The gpg executable that is invoked for signing. The default value of this property depends on `useLegacyGpg`. If that is `true` then the default value of executable is "gpg" otherwise it is "gpg2".
   `signing.gnupg.useLegacyGpg`::
   Must be `true` if GnuPG version 1 is used and `false` otherwise. The default value of the property is `false`.
   `signing.gnupg.homeDir`::
   Sets the home directory for GnuPG. If not given the default home directory of GnuPG is used.
   `signing.gnupg.optionsFile`::
   Sets a custom options file for GnuPG. If not given GnuPG's default configuration file is used.
   `signing.gnupg.keyName`::
   The id of the key that should be used for signing. If not given then the default key configured in GnuPG will be used.
   `signing.gnupg.passphrase`::
   The passphrase for unlocking the secret key. If not given then the gpg-agent program is used for getting the passphrase.
   
   All configuration properties are optional.
   
   == Specifying what to sign
   
   As well as configuring how things are to be signed (i.e. the signatory configuration), you must also specify what is to be signed. The Signing Plugin provides a DSL that allows you to specify the tasks and/or configurations that should be signed.
   
   === Signing Publications
   
   When publishing artifacts, you often want to sign them so the consumer of your artifacts can verify their signature. For example, the <<java_plugin.adoc#java_plugin,Java plugin>> defines a component that you can use to define a publication to a Maven (or Ivy) repository using the <<publishing_maven.adoc#publishing_maven, Maven Publish Plugin>> (or the <<publishing_ivy.adoc#publishing_ivy, Ivy Publish Plugin>>, respectively). Using the Signing DSL, you can specify that all of the artifacts of this publication should be signed.
   
   .Signing a publication
   ====
   include::sample[dir="snippets/signing/maven-publish/kotlin",files="build.gradle.kts[tags=sign-publication]"]
   include::sample[dir="snippets/signing/maven-publish/groovy",files="build.gradle[tags=sign-publication]"]
   ====
   
   This will create a task (of type link:{groovyDslPath}#[Sign]) in your project named `signMavenJavaPublication` that will build all artifacts that are part of the publication (if needed) and then generate signatures for them. The signature files will be placed alongside the artifacts being signed.
   
   === Example: Signing a publication output
   
   .Output of **`gradle signMavenJavaPublication`**
   ----
   > gradle signMavenJavaPublication
   include::{snippetsPath}/signing/maven-publish/tests/signingPluginSignPublication.out[]
   ----
   
   In addition, the above DSL allows to `sign` multiple comma-separated publications. Alternatively, you may specify `publishing.publications` to sign all publications, or use `publishing.publications.matching {  }` to sign all publications that match the specified predicate.
   
   === Signing Configurations
   
   It is common to want to sign the artifacts of a configuration. For example, the <<java_plugin.adoc#java_plugin,Java plugin>> configures a jar to build and this jar artifact is added to the `runtimeElements` configuration. Using the Signing DSL, you can specify that all of the artifacts of this configuration should be signed.
   
   .Signing a configuration
   ====
   include::sample[dir="snippets/signing/configurations/kotlin",files="build.gradle.kts[tags=sign-runtime-elements]"]
   include::sample[dir="snippets/signing/configurations/groovy",files="build.gradle[tags=sign-runtime-elements]"]
   ====
   
   This will create a task (of type link:{groovyDslPath}#[Sign]) in your project named `signRuntimeElements`, that will build any `runtimeElements` artifacts (if needed) and then generate signatures for them. The signature files will be placed alongside the artifacts being signed.
   
   === Example: Signing a configuration output
   
   .Output of **`gradle signRuntimeElements`**
   ----
   > gradle signRuntimeElements
   include::{snippetsPath}/signing/configurations/tests/signingRuntimeElementsOutput.out[]
   ----
   
   === Signing Task Output
   
   In some cases the artifact that you need to sign may not be part of a configuration.
   In this case you can directly sign the task that produces the artifact to sign.
   
   .Signing a task output
   ====
   include::sample[dir="snippets/signing/tasks/kotlin",files="build.gradle.kts[tags=sign-task]"]
   include::sample[dir="snippets/signing/tasks/groovy",files="build.gradle[tags=sign-task]"]
   ====
   
   This will create a task (of type link:{groovyDslPath}#[Sign]) in your project named `signStuffZip`, that will build the input task's archive (if needed) and then sign it.
   The signature file will be placed alongside the artifact being signed.
   
   === Example: Signing a task output
   
   .Output of **`gradle signStuffZip`**
   ----
   > gradle signStuffZip
   include::{snippetsPath}/signing/tasks/tests/signingTaskOutput.out[]
   ----
   
   For a task to be _signable_, it must produce an archive of some type, i.e. it must extend link:{groovyDslPath}#[AbstractArchiveTask].
   Tasks that do this are the link:{groovyDslPath}#[Tar], link:{groovyDslPath}#[Zip], link:{groovyDslPath}#[Jar], link:{groovyDslPath}#[War] and link:{groovyDslPath}#[Ear] tasks.
   
   === Conditional Signing
   
   A common usage pattern is to require the signing of build artifacts only under certain conditions.
   For example, you may not need to sign artifacts for non-release versions.
   To achieve this, you can specify the condition as an argument of the `required()` method.
   
   .Specifying when signing is required
   ====
   include::sample[dir="snippets/signing/conditional/kotlin",files="build.gradle.kts[tags=conditional-signing]"]
   include::sample[dir="snippets/signing/conditional/groovy",files="build.gradle[tags=conditional-signing]"]
   ====
   
   In this example, we only want to require signing if we are building a release version and we are going to publish it.
   Because we are inspecting the task graph to determine if we are going to be publishing, we must set the `signing.required` property to a closure to defer the evaluation.
   See link:{javadocPath}#[SigningExtension.setRequired(java.lang.Object)] for more information.
   
   If the `required` condition does not hold true, artifacts will only be signed if signatory credentials are configured.
   Alternatively, you may want to skip signing entirely whether or not signatory credentials are available.
   If so, you can configure the link:{groovyDslPath}#[Sign] tasks to be skipped, for example by attaching a predicate using the `onlyIf()` method shown in the following example:
   
   .Specifying when signing is skipped
   ====
   include::sample[dir="snippets/signing/conditional/kotlin",files="build.gradle.kts[tags=only-if]"]
   include::sample[dir="snippets/signing/conditional/groovy",files="build.gradle[tags=only-if]"]
   ====
   
   == Publishing the signatures
   
   When signing <<#sec:signing_publications,publications>>, the resultant signature artifacts are automatically added to the corresponding publication.
   Thus, when publishing to a repository, e.g. by executing the `publish` task, your signatures will be distributed along with the other artifacts without any additional configuration.
   
   When signing <<#sec:signing_configurations,configurations>> and <<#sec:signing_tasks,tasks>>, the resultant signature artifacts are automatically added to the `signatures` dependency configuration.

/docs/userguide/core-plugins/java_gradle_plugin.adoc
====================================================

.. code-block::

   = Gradle Plugin Development Plugin
   
   The Java Gradle Plugin development plugin can be used to assist in the development of Gradle plugins.
   It automatically applies the <<java_library_plugin.adoc#java_library_plugin,Java Library (`java-library`)>> plugin, adds the `gradleApi()` dependency to the `api` configuration and performs validation of plugin metadata during `jar` task execution.
   
   The plugin also integrates with <<test_kit.adoc#test_kit,TestKit>>, a library that aids in writing and executing functional tests for plugin code.
   It automatically adds the `gradleTestKit()` dependency to the `testImplementation` configuration and generates a plugin classpath manifest file consumed by a `GradleRunner` instance if found.
   Please refer to <<test_kit.adoc#sub:test-kit-automatic-classpath-injection,Automatic classpath injection with the Plugin Development Plugin>> for more on its usage, configuration options and samples.
   
   
   == Usage
   
   To use the Java Gradle Plugin Development plugin, include the following in your build script:
   
   .Using the Java Gradle Plugin Development plugin
   ====
   include::sample[dir="snippets/java/javaGradlePlugin/kotlin",files="build.gradle.kts[tags=use-java-gradle-plugin-plugin]"]
   include::sample[dir="snippets/java/javaGradlePlugin/groovy",files="build.gradle[tags=use-java-gradle-plugin-plugin]"]
   ====
   
   Applying the plugin automatically applies the <<java_library_plugin.adoc#java_library_plugin,Java Library(`java-library`)>> plugin and adds the `gradleApi()` dependency to the `api` configuration.
   It also adds some validations to the build.
   
   The following validations are performed:
   
   * There is a plugin descriptor defined for the plugin.
   * The plugin descriptor contains an `implementation-class` property.
   * The `implementation-class` property references a valid class file in the jar.
   * Each property getter or the corresponding field must be annotated with a property annotation like `@InputFile` and `@OutputDirectory`.
   Properties that don't participate in up-to-date checks should be annotated with `@Internal`.
   
   Any failed validations will result in a warning message.
   
   For each plugin you are developing, add an entry to the `gradlePlugin {}` script block:
   
   .Using the gradlePlugin {} block.
   ====
   include::sample[dir="snippets/java/javaGradlePlugin/kotlin",files="build.gradle.kts[tags=gradle-plugin-block]"]
   include::sample[dir="snippets/java/javaGradlePlugin/groovy",files="build.gradle[tags=gradle-plugin-block]"]
   ====
   
   The `gradlePlugin {}` block defines the plugins being built by the project including the `id` and `implementationClass` of the plugin.
   From this data about the plugins being developed, Gradle can automatically:
   
   * Generate the plugin descriptor in the `jar` file's `META-INF` directory.
   * Configure the <<plugins.adoc#sec:plugin_markers,Plugin Marker Artifact>> publications (Maven or Ivy) for each plugin.
   * Publish each plugin to the Gradle Plugin Portal (see <<publishing_gradle_plugins.adoc#publishing_portal,Publishing Plugins to Gradle Plugin Portal>> for details), but only if the link:https://plugins.gradle.org/docs/publish-plugin[Plugin Publishing Plugin] has also been applied.
   
   == Interactions
   
   Some of the plugin's behaviour depends on other, related plugins also being applied in your build, namely the <<publishing_maven.adoc#publishing_maven,Maven Publish (`maven-publish`)>> and <<publishing_ivy.adoc#publishing_ivy,Ivy Publish (`ivy-publish`)>> plugins.
   
   Other plugins auto apply the Java Gradle Plugin, like the link:https://plugins.gradle.org/plugin/com.gradle.plugin-publish[Plugin Publishing Plugin].
   
   === Maven Publish Plugin
   
   When the Java Gradle Plugin (`java-gradle-plugin`) detects that the Maven Publish Plugin (`maven-publish`) is also applied by the build, it will automatically configure the following link:{groovyDslPath}#[MavenPublications]:
   
   * a single "main" publication, named `pluginMaven`, based on the <<java_plugin.adoc#sec:java_plugin_publishing,main Java component>>
   * multiple <<plugins.adoc#sec:plugin_markers,"marker" publications>> (one for each plugin defined in the `gradlePlugin {}` block), named `<pluginName>PluginMarkerMaven` (for example in the above example it would be `simplePluginPluginMarkerMaven`)
   
   This automatic configuration happens in a link:{groovyDslPath}#[Project.afterEvaluate()] block (so at the end of the <<build_lifecycle.adoc#sec:build_phases,build configuration phase>>), and only if these publications haven't already been defined, so it's possible to create and customise them during the earlier stages of build configuration.
   
   === Ivy Publish Plugin
   
   When the Java Gradle Plugin(`java-gradle-plugin`) detects that the Ivy Publish Plugin (`ivy-publish`) is also applied by the build, it will automatically configure the following link:{groovyDslPath}#[IvyPublications]:
   
   * a single "main" publication, named `pluginIvy`, based on the <<java_plugin.adoc#sec:java_plugin_publishing,main Java component>>
   * multiple <<plugins.adoc#sec:plugin_markers,"marker" publications>> (one for each plugin defined in the `gradlePlugin {}` block), named `<pluginName>PluginMarkerIvy` (for example in the above example it would be `simplePluginPluginMarkerIvy`)
   
   This automatic configuration happens in a link:{groovyDslPath}#[Project.afterEvaluate()] block (so at the end of the <<build_lifecycle.adoc#sec:build_phases,build configuration phase>>), and only if these publications haven't already been defined, so it's possible to create and customise them during the earlier stages of build configuration.
   
   === Plugin Publish Plugin
   
   Starting from link:https://plugins.gradle.org/plugin/com.gradle.plugin-publish/1.0.0[version 1.0.0, the Plugin Publish Plugin] always auto-applies the Java Gradle Plugin (`java-gradle-plugin`) and the Maven Publish Plugin (`maven-publish`).

/docs/userguide/core-plugins/project_report_plugin.adoc
=======================================================

.. code-block::

   = The Project Report Plugin
   
   The Project report plugin adds some tasks to your project which generate reports containing useful information about your build. These tasks generate the same content that you get by executing the `tasks`, `dependencies`, and `properties` tasks from the command line (see <<command_line_interface.adoc#sec:command_line_project_reporting,Command-line project reporting>>). In contrast to the command line reports, the report plugin generates the reports into a file. There is also an aggregating task that depends on all report tasks added by the plugin.
   
   We plan to add much more to the existing reports and create additional ones in future releases of Gradle.
   
   
   == Usage
   
   To use the Project report plugin, include the following in your build script:
   
   [source,groovy]
   ----
   plugins {
       id 'project-report'
   }
   ----
   
   
   == Tasks
   
   The project report plugin defines the following tasks:
   
   `dependencyReport`  link:{groovyDslPath}#[DependencyReportTask]::
   Generates the project dependency report.
   
   `htmlDependencyReport`  link:{groovyDslPath}#[HtmlDependencyReportTask]::
   Generates an HTML dependency and dependency insight report for the project or a set of projects.
   
   `propertyReport`  link:{groovyDslPath}#[PropertyReportTask]::
   Generates the project property report.
   
   `taskReport`  link:{groovyDslPath}#[TaskReportTask]::
   Generates the project task report.
   
   `projectReport`  link:{groovyDslPath}#[Task]::
   _Depends on_: `dependencyReport`, `propertyReport`, `taskReport`, `htmlDependencyReport`
   +
   Generates all project reports.
   
   
   == Project layout
   
   The project report plugin does not require any particular project layout.
   
   == Dependency management
   
   The project report plugin does not define any dependency configurations.
   
   == Convention properties
   
   The project report defines the following convention properties:
   
   `projects`  `Set&lt;Project&gt;`::
   The projects to generate the reports for. _Default value_: A one element set with the project the plugin was applied to.
   
   `projectReportDirName`  `String`::
   The name of the directory to generate the project report into, relative to the reports directory. _Default value_: `"project"`.
   
   `projectReportDir`  `File` (read-only)::
   The directory to generate the project report into. _Default value_: `__reportsDir__/__projectReportDirName__`.
   
   `reportsDirName`  `String`::
   The name of the directory to generate the project report into, relative to the reports directory. _Default value_: `"reports"`.
   
   `reportsDir`  `File` (read-only)::
   The directory to generate the project reports into. _Default value_: `__buildDir__/__reportsDirName__`.
   
   These convention properties are provided by a convention object of type link:{groovyDslPath}#[ProjectReportsPluginConvention].
   
   Configuring the project report tasks via the plugin's convention properties is **deprecated**. If you need to change from the default values, configure the appropriate tasks directly. If you want to configure all report tasks of the same type in the project, use link:{javadocPath}#[tasks.withType(...).configureEach(...)] (where the type can be `HtmlDependencyReportTask` for example).

/Topic: 游댯 License Information
================================


/docs/userguide/licenses.adoc
=============================


.. code-block::

   // Copyright (C) 2023 Gradle, Inc.
   //
   // Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      https://creativecommons.org/licenses/by-nc-sa/4.0/
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.

   = License Information
   
   == Gradle Documentation
   
   _Copyright 춸 2007-2023 Gradle, Inc._
   
   Gradle build tool source code is open-source and licensed under the link:https://github.com/gradle/gradle/blob/master/LICENSE[Apache License 2.0].
   
   Gradle user manual and DSL reference manual are licensed under link:http://creativecommons.org/licenses/by-nc-sa/4.0/[Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License].
   
   == Gradle Build Scan Plugin
   
   Use of the link:https://scans.gradle.com/plugin/[build scan plugin] is subject to link:https://gradle.com/legal/terms-of-service/[Gradle's Terms of Service].


/Topic: 游댯 Others
===================

/docs/userguide/core-plugins/build_dashboard_plugin.adoc
========================================================

.. code-block::

   = The Build Dashboard Plugin
   
   The Build Dashboard plugin can be used to generate a single HTML dashboard that provides a single point of access to all of the reports generated by a build.
   
   == Usage
   
   To use the Build Dashboard plugin, include the following in your build script:
   
   .Using the Build Dashboard plugin
   ====
   include::sample[dir="snippets/base/buildDashboard/kotlin",files="build.gradle.kts[tags=use-build-dashboard-plugin]"]
   include::sample[dir="snippets/base/buildDashboard/groovy",files="build.gradle[tags=use-build-dashboard-plugin]"]
   ====
   
   Applying the plugin adds the `buildDashboard` task to your project. The task aggregates the reports for all tasks that implement the link:{groovyDslPath}#[Reporting] interface from _all projects_ in the build. It is typically only applied to the root project.
   
   The `buildDashboard` task does not depend on any other tasks. It will only aggregate the reporting tasks that are independently being executed as part of the build run. To generate the build dashboard, simply include this task in the list of tasks to execute. For example, `gradle buildDashboard build` will generate a dashboard for all of the reporting tasks that are dependents of the `build` task.
   
   == Tasks
   
   The Build Dashboard plugin adds the following task to the project:
   
   `buildDashboard`  link:{groovyDslPath}#[GenerateBuildDashboard]::
   Generates build dashboard report.
   
   == Project layout
   
   The Build Dashboard plugin does not require any particular project layout.
   
   == Dependency management
   
   The Build Dashboard plugin does not define any dependency configurations.
   
   == Configuration
   
   You can influence the location of build dashboard plugin generation via link:{groovyDslPath}#[ReportingExtension].

/docs/userguide/jvm/javaProjectGenericLayout.adoc
=================================================

.. code-block::

   `src/__sourceSet__/java`::
   Java source for the source set named _sourceSet_.
   
   `src/__sourceSet__/resources`::
   Resources for the source set named _sourceSet_.

/docs/userguide/jvm/javaProjectMainLayout.adoc
==============================================

.. code-block::

   `src/main/java`::
   Production Java source.
   
   `src/main/resources`::
   Production resources, such as XML and properties files.

/docs/userguide/jvm/javaProjectTestLayout.adoc
==============================================

.. code-block::

   `src/test/java`::
   Test Java source.
   
   `src/test/resources`::
   Test resources.

/docs/userguide/legacy/rule_source.adoc
=======================================

.. code-block::

   = Implementing model rules in a plugin
   
   [CAUTION]
   ====
   Rule based configuration link:https://blog.gradle.org/state-and-future-of-the-gradle-software-model[will be deprecated].
   New plugins should not use this concept.
   Instead, use the standard approach described in the <<custom_plugins.adoc#custom_plugins, Writing Custom Plugins>> chapter.
   ====
   
   A plugin can define rules by extending link:{javadocPath}#[RuleSource] and adding methods that define the rules. The plugin class can either extend link:{javadocPath}#[RuleSource] directly or can implement link:{javadocPath}#[Plugin] and include a nested link:{javadocPath}#[RuleSource] subclass.
   
   Refer to the API docs for link:{javadocPath}#[RuleSource] for more details.
   
   
   == Applying additional rules
   
   A rule method annotated with link:{javadocPath}#[Rules] can apply a link:{javadocPath}#[RuleSource] to a target model element.

/docs/userguide/optimizing-performance/isolated_projects.adoc
=============================================================

.. code-block::

   :gradle-issues: https://github.com/gradle/gradle/issues/
   
   = Isolated Projects
   
   Isolated Projects is a pre-alpha Gradle feature that extends the configuration cache to further improve performance, in particular the performance of Android Studio and IDEA sync.
   
   When isolated projects is enabled, the configuration model of Gradle projects are "isolated" from each other.
   This means that build logic, such as build scripts or plugins, applied to a project cannot directly access the mutable state of another project.
   This allows configuration and tooling model creation for each project to safely run in parallel and the result cached and invalidated for each project independently.
   
   == Status as of Gradle 8.5
   
   When isolated projects is enabled, Gradle applies two levels of caching during IDE sync:
   
   Gradle starts by applying coarse-grained caching.
   To do this, Gradle caches the result of the entire sync operation and reuses it when nothing that affects the IDE model has changed.
   When the cache entry can be reused, Gradle short-circuits the entire sync operation and simply returns the cached result to the IDE.
   
   Generally, the settings and build scripts affect the IDE model, but the source code of the projects does not.
   So, when these scripts change the cache entry cannot be reused.
   When this happens, Gradle falls back to fine-grained caching.
   To do this, Gradle caches the result of creating the tooling models for each project and reuses these models when nothing that affects them has changed.
   When the cached models for a project can be reused, Gradle short-circuits all work for that project,
   including the project's configuration phase and other work such as dependency resolution.
   
   This means that Gradle will only configure and create tooling models for projects whose configuration has changed.
   This work is done in parallel for each project.
   
   === Current limitations
   
   Isolated projects is a pre-alpha feature, and as such there are a number of limitations in the current implementation.
   These will addressed in future Gradle releases:
   
   * Gradle, IDEA, Android Studio and the Kotlin plugins are not yet 100% compatible with isolated projects, so you should expect to see some violations reported. The teams are actively working on fixing these incompatibilities.
   * Parallel configuration and fine-grained caching are not applied to task execution. They are only applied to IDE sync.
   * Changes to included builds invalidate all cached results, even when the change would not affect the cached results.
   * The implementation does not attempt to take advantage of the isolation to limit peak memory consumption. Currently, peak memory consumption is a function of how many project need to be configured.
   * All caching is done on the local machine, as for the configuration cache. There is no support for remote caching yet.
   
   == How do I use it?
   
   To use isolated projects, you will need Gradle 8.5 or later and preferably a recent nightly.
   You should also use the most recent version of IDEA or Android Studio.
   
   The feature is off by default.
   You can enable it by setting the `org.gradle.unsafe.isolated-projects` system property to `true`.
   For example:
   
   ----
   $ gradle build -Dorg.gradle.unsafe.isolated-projects=true
   ----
   
   When enabled, Gradle will fail the build whenever build logic attempts to cross project boundaries and access the model of another project.
   Gradle collects all of these access problems in the configuration cache report, in the same way as other problems.
   
   The configuration cache command-line options can be used to control how Gradle handles these problems. For example:
   
   * `--configuration-cache-problems=warn` can be used to treat the access problems as warnings instead of errors.
   * `-Dorg.gradle.configuration-cache.max-problems=x` can be used to increase the maximum number of problems included in the report.
   
   You can also use `-Dorg.gradle.internal.invalidate-coupled-projects=false` to force parallel configuration when there are access problems.
   
   Please be aware that these options disable the validation that makes execution parallel- and caching-safe when isolated projects is enabled,
   so you may see some unexpected behaviour when using them.
   
   == Build logic constraints
   
   Isolated projects prevents build logic from accessing the state of another project. This includes:
   
   * Using most methods on the `Project` type. A small number of methods that return immutable information about the project are allowed:
   ** `getName()`
   ** `getPath()`
   ** `getBuildTreePath()`
   ** `getProjectDir()`
   ** `getRootDir()`
   ** `project()` overloads
   ** `getChildProjects()`
   ** `getSubprojects()`
   ** `subprojects()` overloads
   ** `getAllProjects()`
   ** `allprojects()` overloads
   
   Note that isolated projects is a pre-alpha feature.
   These constraints are not final and can change at any time.

/Topic: 游댯 Graphs
===================


/docs/userguide/img/cpp-application-configurations.dot
======================================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/cpp-application-configurations.dot > src/docs/userguide/img/cpp-application-configurations.png
   digraph cppApplicationConfigurations {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=2.5, height=0.5];
   
     subgraph central {
       node[style=filled, fillcolor=white]
       implementation -> mainVariantImplementation [style=invis, weight=1000]
       mainVariantImplementation -> implementation [headport=s, tailport=n]
   
       mainVariantImplementation[label=<main<i>Variant</i>Implementation>]
     }
   
     subgraph left {
       node[style=filled, fillcolor="#cfe2f3"]
       cppCompileVariant -> nativeLinkVariant -> nativeRuntimeVariant [style=invis, weight=1000]
   
       cppCompileVariant[label=<cppCompile<i>Variant</i> (R)>]
       nativeLinkVariant[label=<nativeLink<i>Variant</i> (R)>]
       nativeRuntimeVariant[label=<nativeRuntime<i>Variant</i> (R)>]
     }
   
     subgraph right {
       node[style=filled, fillcolor="#ea9999"]
       variantRuntimeElements [weight=1000]
   
       variantRuntimeElements[label=<<i>variant</i>RuntimeElements (C)>]
     }
   
     // Ensure the order is preserved
     {rank=same cppCompileVariant implementation}
     {rank=same mainVariantImplementation nativeLinkVariant variantRuntimeElements}
     nativeLinkVariant -> mainVariantImplementation -> variantRuntimeElements [style=invis]
   
     {cppCompileVariant, nativeLinkVariant, nativeRuntimeVariant} -> mainVariantImplementation [headport=w, tailport=e]
     variantRuntimeElements -> mainVariantImplementation [headport=e, tailport=w]
   }

/docs/userguide/img/cpp-application-task-graph.dot
==================================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/cpp-application-task-graph.dot > src/docs/userguide/img/cpp-application-task-graph.png
   digraph cppApplicationTaskGraph {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=2.5, height=0.5];
     node [style=filled, fillcolor="#cfe2f3"]
     rankdir=LR
   
     compileDebugCpp -> linkDebug -> assemble -> build [dir=back]
     linkDebug -> assembleDebug [dir=back]
     check -> build [dir=back]
     compileReleaseCpp -> linkRelease -> assembleRelease [dir=back]
     clean
   
     // Ensure ordering
     compileDebugCpp -> compileReleaseCpp -> clean [style=invis]
     {rank=same compileDebugCpp compileReleaseCpp clean}
   
     check -> assemble -> assembleDebug -> assembleRelease [style=invis]
     {rank=same check assemble assembleDebug assembleRelease}
   }

/docs/userguide/img/cpp-application-variant-task-graph.dot
==========================================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/cpp-application-variant-task-graph.dot > src/docs/userguide/img/cpp-application-variant-task-graph.png
   digraph cppLibraryVariantTaskGraph {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=2.5, height=0.5];
     node [style="dashed,filled", fillcolor=grey]
     rankdir=LR
   
     compileVariantCpp -> linkVariant -> installVariant -> assembleVariant [dir=back, style=dashed]
     compileVariantCpp[label=<compile<i>Variant</i>Cpp>]
     linkVariant[label=<link<i>Variant</i>>]
     installVariant[label=<install<i>Variant</i>>]
     assembleVariant[label=<assemble<i>Variant</i>>]
   }

/docs/userguide/img/cpp-library-configurations.dot
==================================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/cpp-library-configurations.dot > src/docs/userguide/img/cpp-library-configurations.png
   digraph cppLibraryConfigurations {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=2.5, height=0.5];
   
     subgraph central {
       node[style=filled, fillcolor=white]
       api -> implementation -> mainVariantImplementation [style=invis, weight=1000]
       mainVariantImplementation -> implementation -> api [headport=s, tailport=n]
   
       mainVariantImplementation[label=<main<i>Variant</i>Implementation>]
     }
   
     subgraph left {
       node[style=filled, fillcolor="#cfe2f3"]
       cppCompileVariant -> nativeLinkVariant -> nativeRuntimeVariant [style=invis, weight=1000]
   
       cppCompileVariant[label=<cppCompile<i>Variant</i> (R)>]
       nativeLinkVariant[label=<nativeLink<i>Variant</i> (R)>]
       nativeRuntimeVariant[label=<nativeRuntime<i>Variant</i> (R)>]
     }
   
     subgraph right {
       node[style=filled, fillcolor="#ea9999"]
       cppApiElements -> variantLinkElements -> variantRuntimeElements [style=invis, weight=1000]
   
       cppApiElements[label="cppApiElements (C)"]
       variantLinkElements[label=<<i>variant</i>LinkElements (C)>]
       variantRuntimeElements[label=<<i>variant</i>RuntimeElements (C)>]
     }
   
     // Ensure the order is preserved
     {rank=same cppCompileVariant implementation cppApiElements}
     {rank=same variantLinkElements mainVariantImplementation nativeLinkVariant}
     nativeLinkVariant -> mainVariantImplementation -> variantLinkElements [style=invis]
   
     {cppCompileVariant, nativeLinkVariant, nativeRuntimeVariant} -> mainVariantImplementation [headport=w, tailport=e]
     {cppApiElements, variantLinkElements, variantRuntimeElements} -> mainVariantImplementation [headport=e, tailport=w]
   }

/docs/userguide/img/cpp-library-variant-task-graph.dot
======================================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/cpp-library-variant-task-graph.dot > src/docs/userguide/img/cpp-library-variant-task-graph.png
   digraph cppLibraryVariantTaskGraph {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=2.5, height=0.5];
     node [style="dashed,filled", fillcolor=grey]
     rankdir=LR
   
     compileVariantCpp -> {linkVariant, createVariant} -> assembleVariant [dir=back, style=dashed]
     compileVariantCpp[label=<compile<i>Variant</i>Cpp>]
     linkVariant[label=<link<i>Variant</i>>]
     createVariant[label=<create<i>Variant</i>>]
     assembleVariant[label=<assemble<i>Variant</i>>]
   
     // Adds linkage text between link* and create*
     linkVariant -> linkageText -> createVariant [style=invis]
     {rank=same linkVariant linkageText createVariant}
     linkageText[shape=plain, label="and/or\n(see note)"]
   }

/docs/userguide/img/cpp-shared-library-task-graph.dot
=====================================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/cpp-shared-library-task-graph.dot > src/docs/userguide/img/cpp-shared-library-task-graph.png
   digraph cppSharedLibraryTaskGraph {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=2.5, height=0.5];
     node [style=filled, fillcolor="#cfe2f3"]
     rankdir=LR
   
     compileDebugCpp -> linkDebug -> assembleDebug -> assemble -> build [dir=back]
     check -> build [dir=back]
     compileReleaseCpp -> linkRelease -> assembleRelease [dir=back]
     clean
   
     // Ensure ordering
     compileDebugCpp -> compileReleaseCpp -> clean [style=invis]
     {rank=same compileDebugCpp compileReleaseCpp clean}
   
     assemble -> empty1 -> empty2 -> check [style=invis]
     {rank=same assemble check empty1 empty2}
     empty1[shape=plain, label=""]
     empty2[shape=plain, label=""]
   }

/docs/userguide/img/cpp-sourcesets-compilation.dot
==================================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/cpp-sourcesets-compilation.dot > src/docs/userguide/img/cpp-sourcesets-compilation.png
   digraph cppSourcesetsCompilation {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=2.6, height=0.8];
   
     subgraph firstLine {
       {rank=same cppCompileVariant implementation variantImplementation}
       cppCompileVariant -> includeRoot
       implementation -> includeRoot
       variantImplementation -> includeRoot
   
       cppCompileVariant[style=dashed, label=<cppCompile<i>Variant</i><br/>(configuration)>]
       implementation[style=dashed, label="implementation\n(configuration)"]
       variantImplementation[style=dashed, label=<main<i>Variant</i>Implementation<br/>(configuration)>]
     }
   
     subgraph secondLine {
       includeRoot[style="rounded,filled", fillcolor="#bfffbf", label="Compilation include roots"]
     }
   
     subgraph thirdLine {
       {rank=same sourceFiles compileVariantCpp outputDirectory}
       includeRoot -> compileVariantCpp
       sourceFiles -> compileVariantCpp
       compileVariantCpp -> outputDirectory
   
       sourceFiles[style="rounded,filled", fillcolor="#bfffbf", label="Source files"]
       compileVariantCpp[label=<compile<i>Variant</i>Cpp>]
       outputDirectory[style="rounded,filled", fillcolor="#bfffbf", label="Output directory"]
     }
   }

/docs/userguide/img/cpp-static-library-task-graph.dot
=====================================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/cpp-static-library-task-graph.dot > src/docs/userguide/img/cpp-static-library-task-graph.png
   digraph cppStaticLibraryTaskGraph {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=2.5, height=0.5];
     node [style=filled, fillcolor="#cfe2f3"]
     rankdir=LR
   
     compileDebugCpp -> createDebug -> assembleDebug -> assemble -> build [dir=back]
     check -> build [dir=back]
     compileReleaseCpp -> createRelease -> assembleRelease [dir=back]
     clean
   
     // Ensure ordering
     compileDebugCpp -> compileReleaseCpp -> clean [style=invis]
     {rank=same compileDebugCpp compileReleaseCpp clean}
   
     assemble -> empty1 -> empty2 -> check [style=invis]
     {rank=same assemble check empty1 empty2}
     empty1[shape=plain, label=""]
     empty2[shape=plain, label=""]
   }

/docs/userguide/img/cpp-unit-test-configurations.dot
====================================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/cpp-unit-test-configurations.dot > src/docs/userguide/img/cpp-unit-test-configurations.png
   digraph cppUnitTestConfigurations {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=3.5, height=0.5];
   
     subgraph central {
       node[style=filled, fillcolor=white]
       implementation -> testVariantExecutableImplementation [style=invis, weight=1000]
       testVariantExecutableImplementation -> implementation [headport=s, tailport=n]
   
       testVariantExecutableImplementation[label=<test<i>Variant</i>ExecutableImplementation>]
       implementation[style=dashed]
     }
   
     subgraph left {
       node[style=filled, fillcolor="#cfe2f3"]
       cppCompilerTestVariant -> nativeLinkTestVariant -> nativeRuntimeTestVariant [style=invis, weight=1000]
   
       cppCompilerTestVariant[label=<cppCompilerTest<i>Variant</i> (R)>]
       nativeLinkTestVariant[label=<nativeLinkTest<i>Variant</i> (R)>]
       nativeRuntimeTestVariant[label=<nativeRuntimeTest<i>Variant</i> (R)>]
     }
   
     // Ensure the order is preserved
     {rank=same cppCompilerTestVariant implementation}
     {rank=same testVariantExecutableImplementation nativeLinkTestVariant}
     nativeLinkTestVariant -> testVariantExecutableImplementation [style=invis]
   
     {cppCompilerTestVariant, nativeLinkTestVariant, nativeRuntimeTestVariant} -> testVariantExecutableImplementation [headport=w, tailport=e]
   }

/docs/userguide/img/cpp-unit-test-task-graph.dot
================================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/cpp-unit-test-task-graph.dot > src/docs/userguide/img/cpp-unit-test-task-graph.png
   digraph cppUnitTestTaskGraph {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=2.5, height=0.5];
     node [style=filled, fillcolor="#cfe2f3"]
     rankdir=LR
   
     compileTestCpp -> linkTest -> installTest -> runTest -> test -> check -> build [dir=back]
     compileDebugCpp -> linkTest [dir=back]
     assemble -> build [dir=back]
     tripleDots -> assemble [dir=back]
     clean
   
     compileDebugCpp [style="dashed,filled", fillcolor=grey]
     tripleDots [style="dashed,filled", fillcolor=grey, label="..."]
   
     // Ensure ordering
     compileTestCpp -> compileDebugCpp -> clean [style=invis]
     {rank=same compileDebugCpp compileTestCpp clean}
   }

/docs/userguide/img/cpp-unit-test-variant-task-graph.dot
========================================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/cpp-unit-test-variant-task-graph.dot > src/docs/userguide/img/cpp-unit-test-variant-task-graph.png
   digraph cppUnitTestVariantTaskGraph {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=2.5, height=0.5];
     node [style="dashed,filled", fillcolor=grey]
     rankdir=LR
   
     compileTestVariantCpp -> linkTestVariant -> installTestVariant -> runTestVariant [dir=back, style=dashed]
     compileTestVariantCpp[label=<compile<i>Variant</i>Cpp>]
     linkTestVariant[label=<link<i>Variant</i>>]
     installTestVariant[label=<installTest<i>Variant</i>>]
     runTestVariant[label=<runTest<i>Variant</i>>]
   }

/docs/userguide/img/java-library-ignore-deprecated-main.dot
===========================================================

.. code-block::

   digraph configurations {
       rankdir = BT;
      graph [ dpi = 100, fontname="Sans"];
      node [fontname = "Sans"];
      edge [fontname = "Sans"];
   
      "apiElements" [shape="box", label=<<B>apiElements</B>(C)>, color="pink", bgcolor="pink", style="filled"]
      "apiElements" -> "api"
      "apiElements" -> "compileOnlyApi"
   
      "api" [shape="box", label=<<B>api</B>>, color="chartreuse3", bgcolor="chartreuse3", style="filled"]
      "compileOnlyApi" [shape="box", label=<<B>compileOnlyApi</B>>, color="chartreuse3", bgcolor="chartreuse3", style="filled"]
   
      "compileClasspath" [shape="box", label=<<B>compileClasspath</B>(R)>, color="lightblue", bgcolor="lightblue", style="filled"]
      "compileClasspath" -> "compileOnly"
      "compileOnly" [shape="box", label=<<B>compileOnly</B>>, color="chartreuse3", bgcolor="chartreuse3", style="filled"]
      "compileOnly" -> "compileOnlyApi"
      "compileClasspath" -> "implementation"
      "implementation" [shape="box", label=<<B>implementation</B>>, color="chartreuse3", bgcolor="chartreuse3", style="filled"]
      "implementation" -> "api"
   
      "runtimeClasspath" [shape="box", label=<<B>runtimeClasspath</B>(R)>, color="lightblue", bgcolor="lightblue", style="filled"]
      "runtimeClasspath" -> "runtimeOnly"
      "runtimeOnly" [shape="box", label=<<B>runtimeOnly</B>>, color="chartreuse3", bgcolor="chartreuse3", style="filled"]
      "runtimeClasspath" -> "implementation"
      "runtimeElements" [shape="box", label=<<B>runtimeElements</B>(C)>, color="pink", bgcolor="pink", style="filled"]
      "runtimeElements" -> "implementation"
      "runtimeElements" -> "runtimeOnly"
   
   }

/docs/userguide/img/java-library-ignore-deprecated-test.dot
===========================================================

.. code-block::

   digraph configurations {
       rankdir = BT;
      graph [ dpi = 100, fontname="Sans"];
      node [fontname = "Sans"];
      edge [fontname = "Sans"];
   
      "api" [shape="box", label=<<B>api</B>>, color="chartreuse3", bgcolor="chartreuse3", style="filled"]
   
      "compileOnlyApi" [shape="box", label=<<B>compileOnlyApi</B>>, color="chartreuse3", bgcolor="chartreuse3", style="filled"]
   
      "implementation" [shape="box", label=<<B>implementation</B>>, color="chartreuse3", bgcolor="chartreuse3", style="filled"]
      "implementation" -> "api"
   
      "runtimeOnly" [shape="box", label=<<B>runtimeOnly</B>>, color="chartreuse3", bgcolor="chartreuse3", style="filled"]
   
      "testCompileClasspath" [shape="box", label=<<B>testCompileClasspath</B>(R)>, color="lightblue", bgcolor="lightblue", style="filled"]
      "testCompileClasspath" -> "testCompileOnly"
      "testCompileOnly" [shape="box", label=<<B>testCompileOnly</B>>, color="chartreuse3", bgcolor="chartreuse3", style="filled"]
      "testCompileOnly" -> "compileOnlyApi"
      "testCompileClasspath" -> "testImplementation"
      "testImplementation" [shape="box", label=<<B>testImplementation</B>>, color="chartreuse3", bgcolor="chartreuse3", style="filled"]
      "testImplementation" -> "implementation"
   
      "testRuntimeClasspath" [shape="box", label=<<B>testRuntimeClasspath</B>(R)>, color="lightblue", bgcolor="lightblue", style="filled"]
      "testRuntimeClasspath" -> "testRuntimeOnly"
      "testRuntimeOnly" [shape="box", label=<<B>testRuntimeOnly</B>>, color="chartreuse3", bgcolor="chartreuse3", style="filled"]
      "testRuntimeOnly" -> "runtimeOnly"
      "testRuntimeClasspath" -> "testImplementation"
   }

/docs/userguide/img/java-main-configurations.dot
================================================

.. code-block::

   digraph javaMainConfigurations {
   
       rankdir = BT;
       node [fontname="Sans", shape=box, style=filled, fillcolor=chartreuse];
       edge [fontname="Sans"];
   
       /* tasks */
       compileJava [fillcolor=darkslategray1, fontname="Courier New"]
   
       /* consumed confs */
       compileClasspath [fillcolor=lightblue]
       runtimeClasspath [fillcolor=lightblue]
   
       /* configurations */
       compileClasspath -> {compileOnly implementation}
       runtimeClasspath -> {runtimeOnly implementation}
   
       /* tasks */
       compileJava -> compileClasspath [style=dashed label="uses"]
   }

/docs/userguide/img/java-test-configurations.dot
================================================

.. code-block::

   digraph javaTestConfigurations {
   
       rankdir = BT;
       node [fontname="Sans", shape=box, style=filled, fillcolor=chartreuse];
       edge [fontname="Sans"];
   
       /* tasks */
       compileTestJava [fillcolor=darkslategray1, fontname="Courier New"]
       test [fillcolor=darkslategray1, fontname="Courier New"]
   
       testCompileClasspath [fillcolor=lightblue]
       testRuntimeClasspath [fillcolor=lightblue]
   
       /* configurations */
       testImplementation -> implementation
       testCompileClasspath -> {testCompileOnly testImplementation}
       testRuntimeOnly -> runtimeOnly
       testRuntimeClasspath -> {testRuntimeOnly testImplementation}
   
       /* tasks */
       test -> testRuntimeClasspath [style=dashed label="uses"]
       compileTestJava -> testCompileClasspath [style=dashed label="uses"]
   }
docs/userguide/img/plugin-markers.puml
======================================

.. code-block::

   @startuml
   
   skinparam monochrome true
   skinparam component {
       BackgroundColor white
       BorderColor Black
   	ArrowColor Black
   }
   
   database "maven-repo" {
     file "<b>groupId</b> com.example.hello\n<b>artifactId</b> com.example.hello.gradle.plugin\n<b>version</b> 1.0.0" as marker1
     file "<b>groupId</b> com.example.goodbye\n<b>artifactId</b> com.example.goodbye.gradle.plugin\n<b>version</b> 1.0.0" as marker2
   
     file "<b>groupId</b> com.example\n<b>artifactId</b> sample-plugins\n<b>version</b> 1.0.0\n\n<&file> sample-plugins-1.0.0.jar" as main
   
     marker1 --> main
     marker2 --> main
   }
   
   @enduml
docs/userguide/img/software_architecture.puml
=============================================

.. code-block::

   @startuml
   
   skinparam monochrome true
   skinparam component {
       BackgroundColor white
       BorderColor Black
   	ArrowColor Black
   }
   
   database "External Repository" {
     [Spring Boot\nFramework] as SpringBoot
     [Android\nFramework] as Android
   }
   
   package "Application Layer" {
     [server-application]
     [android-app]
   }
   
   package "Business Logic Layer" {
     [user-feature]
     [admin-feature]
   }
   
   package "Domain Model Layer" {
     [domain-model] <-right- [state]
   }
   
   [server-application] -down-> [user-feature]
   [server-application] -down-> [admin-feature]
   [android-app] -down-> [user-feature]
   
   [user-feature] -down-> [domain-model]
   [user-feature] -down-> [state]
   
   [admin-feature] -down-> [domain-model]
   [admin-feature] -down-> [state]
   
   [server-application] -down-> [SpringBoot]
   [android-app] -down-> [Android]
   
   folder {
      [build-logic]
   }
   folder {
      [platforms]
   }
   folder {
       [aggregation]
   }
   
   @enduml

/docs/userguide/img/swift-application-configurations.dot
========================================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/swift-application-configurations.dot > src/docs/userguide/img/swift-application-configurations.png
   digraph swiftApplicationConfigurations {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=2.6, height=0.5];
   
     subgraph central {
       node[style=filled, fillcolor=white]
       implementation -> mainVariantImplementation [style=invis, weight=1000]
       mainVariantImplementation -> implementation [headport=s, tailport=n]
   
       mainVariantImplementation[label=<main<i>Variant</i>Implementation>]
     }
   
     subgraph left {
       node[style=filled, fillcolor="#cfe2f3"]
       swiftCompileVariant -> nativeLinkVariant -> nativeRuntimeVariant [style=invis, weight=1000]
   
       swiftCompileVariant[label=<swiftCompile<i>Variant</i> (R)>]
       nativeLinkVariant[label=<nativeLink<i>Variant</i> (R)>]
       nativeRuntimeVariant[label=<nativeRuntime<i>Variant</i> (R)>]
     }
   
     subgraph right {
       node[style=filled, fillcolor="#ea9999"]
       variantRuntimeElements [weight=1000]
   
       variantRuntimeElements[label=<<i>variant</i>RuntimeElements (C)>]
     }
   
     // Ensure the order is preserved
     {rank=same swiftCompileVariant implementation}
     {rank=same mainVariantImplementation nativeLinkVariant variantRuntimeElements}
     nativeLinkVariant -> mainVariantImplementation -> variantRuntimeElements [style=invis]
   
     {swiftCompileVariant, nativeLinkVariant, nativeRuntimeVariant} -> mainVariantImplementation [headport=w, tailport=e]
     variantRuntimeElements -> mainVariantImplementation [headport=e, tailport=w]
   }

/docs/userguide/img/swift-application-task-graph.dot
====================================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/swift-application-task-graph.dot > src/docs/userguide/img/swift-application-task-graph.png
   digraph swiftApplicationTaskGraph {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=2.5, height=0.5];
     node [style=filled, fillcolor="#cfe2f3"]
     rankdir=LR
   
     compileDebugSwift -> linkDebug -> assemble -> build [dir=back]
     linkDebug -> assembleDebug [dir=back]
     check -> build [dir=back]
     compileReleaseSwift -> linkRelease -> assembleRelease [dir=back]
     clean
   
     // Ensure ordering
     compileDebugSwift -> compileReleaseSwift -> clean [style=invis]
     {rank=same compileDebugSwift compileReleaseSwift clean}
   
     check -> assemble -> assembleDebug -> assembleRelease [style=invis]
     {rank=same check assemble assembleDebug assembleRelease}
   }

/docs/userguide/img/swift-application-variant-task-graph.dot
============================================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/swift-application-variant-task-graph.dot > src/docs/userguide/img/swift-application-variant-task-graph.png
   digraph swiftLibraryVariantTaskGraph {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=2.5, height=0.5];
     node [style="dashed,filled", fillcolor=grey]
     rankdir=LR
   
     compileVariantSwift -> linkVariant -> installVariant -> assembleVariant [dir=back, style=dashed]
     compileVariantSwift[label=<compile<i>Variant</i>Swift>]
     linkVariant[label=<link<i>Variant</i>>]
     installVariant[label=<install<i>Variant</i>>]
     assembleVariant[label=<assemble<i>Variant</i>>]
   }

/docs/userguide/img/swift-library-configurations.dot
====================================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/swift-library-configurations.dot > src/docs/userguide/img/swift-library-configurations.png
   digraph swiftLibraryConfigurations {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=2.5, height=0.5];
   
     subgraph central {
       node[style=filled, fillcolor=white]
       api -> implementation -> mainVariantImplementation [style=invis, weight=1000]
       mainVariantImplementation -> implementation -> api [headport=s, tailport=n]
   
       mainVariantImplementation[label=<main<i>Variant</i>Implementation>]
     }
   
     subgraph left {
       node[style=filled, fillcolor="#cfe2f3"]
       swiftCompileVariant -> nativeLinkVariant -> nativeRuntimeVariant [style=invis, weight=1000]
   
       swiftCompileVariant[label=<swiftCompile<i>Variant</i> (R)>]
       nativeLinkVariant[label=<nativeLink<i>Variant</i> (R)>]
       nativeRuntimeVariant[label=<nativeRuntime<i>Variant</i> (R)>]
     }
   
     subgraph right {
       node[style=filled, fillcolor="#ea9999"]
       swiftApiElements -> variantLinkElements -> variantRuntimeElements [style=invis, weight=1000]
   
       swiftApiElements[label="swiftApiElements (C)"]
       variantLinkElements[label=<<i>variant</i>LinkElements (C)>]
       variantRuntimeElements[label=<<i>variant</i>RuntimeElements (C)>]
     }
   
     // Ensure the order is preserved
     {rank=same swiftCompileVariant implementation swiftApiElements}
     {rank=same variantLinkElements mainVariantImplementation nativeLinkVariant}
     nativeLinkVariant -> mainVariantImplementation -> variantLinkElements [style=invis]
   
     {swiftCompileVariant, nativeLinkVariant, nativeRuntimeVariant} -> mainVariantImplementation [headport=w, tailport=e]
     {swiftApiElements, variantLinkElements, variantRuntimeElements} -> mainVariantImplementation [headport=e, tailport=w]
   }

/docs/userguide/img/swift-library-variant-task-graph.dot
========================================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/swift-library-variant-task-graph.dot > src/docs/userguide/img/swift-library-variant-task-graph.png
   digraph swiftLibraryVariantTaskGraph {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=2.5, height=0.5];
     node [style="dashed,filled", fillcolor=grey]
     rankdir=LR
   
     compileVariantSwift -> {linkVariant, createVariant} -> assembleVariant [dir=back, style=dashed]
     compileVariantSwift[label=<compile<i>Variant</i>Swift>]
     linkVariant[label=<link<i>Variant</i>>]
     createVariant[label=<create<i>Variant</i>>]
     assembleVariant[label=<assemble<i>Variant</i>>]
   
     // Adds linkage text between link* and create*
     linkVariant -> linkageText -> createVariant [style=invis]
     {rank=same linkVariant linkageText createVariant}
     linkageText[shape=plain, label="and/or\n(see note)"]
   }

/docs/userguide/img/swift-shared-library-task-graph.dot
=======================================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/swift-shared-library-task-graph.dot > src/docs/userguide/img/swift-shared-library-task-graph.png
   digraph swiftSharedLibraryTaskGraph {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=2.5, height=0.5];
     node [style=filled, fillcolor="#cfe2f3"]
     rankdir=LR
   
     compileDebugSwift -> linkDebug -> assembleDebug -> assemble -> build [dir=back]
     check -> build [dir=back]
     compileReleaseSwift -> linkRelease -> assembleRelease [dir=back]
     clean
   
     // Ensure ordering
     compileDebugSwift -> compileReleaseSwift -> clean [style=invis]
     {rank=same compileDebugSwift compileReleaseSwift clean}
   
     assemble -> empty1 -> empty2 -> check [style=invis]
     {rank=same assemble check empty1 empty2}
     empty1[shape=plain, label=""]
     empty2[shape=plain, label=""]
   }

/docs/userguide/img/swift-sourcesets-compilation.dot
====================================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/swift-sourcesets-compilation.dot > src/docs/userguide/img/swift-sourcesets-compilation.png
   digraph swiftSourcesetsCompilation {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=2.6, height=0.8];
   
     subgraph firstLine {
       {rank=same swiftCompileVariant implementation variantImplementation}
       swiftCompileVariant -> modules
       implementation -> modules
       variantImplementation -> modules
   
       swiftCompileVariant[style=dashed, label=<swiftCompile<i>Variant</i><br/>(configuration)>]
       implementation[style=dashed, label="implementation\n(configuration)"]
       variantImplementation[style=dashed, label=<main<i>Variant</i>Implementation<br/>(configuration)>]
     }
   
     subgraph secondLine {
       modules[style="rounded,filled", fillcolor="#bfffbf", label="Compilation modules"]
     }
   
     subgraph thirdLine {
       {rank=same sourceFiles compileVariantSwift outputDirectory}
       modules -> compileVariantSwift
       sourceFiles -> compileVariantSwift
       compileVariantSwift -> outputDirectory
   
       sourceFiles[style="rounded,filled", fillcolor="#bfffbf", label="Source files"]
       compileVariantSwift[label=<compile<i>Variant</i>Swift>]
       outputDirectory[style="rounded,filled", fillcolor="#bfffbf", label="Output directory"]
     }
   }

/docs/userguide/img/swift-static-library-task-graph.dot
=======================================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/swift-static-library-task-graph.dot > src/docs/userguide/img/swift-static-library-task-graph.png
   digraph swiftStaticLibraryTaskGraph {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=2.5, height=0.5];
     node [style=filled, fillcolor="#cfe2f3"]
     rankdir=LR
   
     compileDebugSwift -> createDebug -> assembleDebug -> assemble -> build [dir=back]
     check -> build [dir=back]
     compileReleaseSwift -> createRelease -> assembleRelease [dir=back]
     clean
   
     // Ensure ordering
     compileDebugSwift -> compileReleaseSwift -> clean [style=invis]
     {rank=same compileDebugSwift compileReleaseSwift clean}
   
     assemble -> empty1 -> empty2 -> check [style=invis]
     {rank=same assemble check empty1 empty2}
     empty1[shape=plain, label=""]
     empty2[shape=plain, label=""]
   }

/docs/userguide/img/visual-studio-task-graph.dot
================================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/visual-studio-task-graph.dot > src/docs/userguide/img/visual-studio-task-graph.png
   digraph visualStudioTaskGraph {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=3.3, height=0.5];
     node [style=filled, fillcolor="#cfe2f3"]
     rankdir=LR
   
   
     subgraph cluster_cppApplication {
       label = "C++ Application Plugin"
       color = black
   
       mainVisualStudio -> {nameVisualStudioProject, nameVisualStudioFilters}
   
       nameVisualStudioProject[label=<<i>projectName</i>VisualStudioProject>]
       nameVisualStudioFilters[label=<<i>projectName</i>VisualStudioFilters>]
       mainVisualStudio[label="mainVisualStudio"]
     }
   
     subgraph cluster_cppLibrary {
       label = "C++ Library Plugin"
       cppLibrary_mainVisualStudio[label="mainVisualStudio"]
   
       subgraph cluster_cppLibrarySharedLinkage {
         label = "Shared Linkage"
         style = dashed
   
         nameDllVisualStudioProject[label=<<i>projectName</i>DllVisualStudioProject>]
         nameDllVisualStudioFilters[label=<<i>projectName</i>DllVisualStudioFilters>]
       }
       cppLibrary_mainVisualStudio -> {nameDllVisualStudioProject, nameDllVisualStudioFilters}
   
       cppLibrary_mainVisualStudio -> text [style=invis]
       text[shape=plain, label="and/or"]
   
       subgraph cluster_cppLibraryStaticLinkage {
         label = "Static Linkage"
         style = dashed
   
         nameLibVisualStudioProject[label=<<i>projectName</i>LibVisualStudioProject>]
         nameLibVisualStudioFilters[label=<<i>projectName</i>LibVisualStudioFilters>]
       }
       cppLibrary_mainVisualStudio -> {nameLibVisualStudioProject, nameLibVisualStudioFilters}
     }
   
     {nameDllVisualStudioProject, nameDllVisualStudioFilters, nameLibVisualStudioProject, nameLibVisualStudioFilters} -> visualStudio [dir=back, style=dashed]
     {nameVisualStudioProject, nameVisualStudioFilters} -> visualStudio [dir=back, style=dashed]
     nameVisualStudioSolution -> visualStudio -> openVisualStudio [dir=back]
   
     nameVisualStudioSolution[label=<<i>projectName</i>VisualStudioSolution>]
   
     nameVisualStudioSolution -> cleanVisualStudio [style=invis]
     {rank=same nameVisualStudioSolution cleanVisualStudio}
   }

/docs/userguide/img/xcode-task-graph.dot
========================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/xcode-task-graph.dot > src/docs/userguide/img/xcode-task-graph.png
   digraph xcodeTaskGraph {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=3.3, height=0.5];
     node [style=filled, fillcolor="#cfe2f3"]
     rankdir=LR
   
     subgraph cluster_cppApplication {
       label = "C++ Application Plugin"
       color = black
   
       {cppApplication_xcodeScheme, cppApplication_xcodeProjectWorkspaceSettings} -> cppApplication_xcodeProject [dir=back]
   
       cppApplication_xcodeScheme[label="xcodeScheme"]
       cppApplication_xcodeProjectWorkspaceSettings[label="xcodeProjectWorkspaceSettings"]
       cppApplication_xcodeProject[label="xcodeProject"]
     }
   
     subgraph cluster_cppLibrary {
       label = "C++ Library Plugin\n(shared or static linkage)"
   
       {cppLibrary_xcodeScheme, cppLibrary_xcodeProjectWorkspaceSettings} -> cppLibrary_xcodeProject [dir=back]
   
       cppLibrary_xcodeScheme[label="xcodeScheme"]
       cppLibrary_xcodeProjectWorkspaceSettings[label="xcodeProjectWorkspaceSettings"]
       cppLibrary_xcodeProject[label="xcodeProject"]
     }
   
     {cppApplication_xcodeProject, cppLibrary_xcodeProject} -> xcode [dir=back, style=dashed]
     xcodeWorkspaceWorkspaceSettings -> xcodeWorkspace -> xcode -> openXcode [dir=back]
   
     xcodeWorkspace[label=<xcodeWorkspace>]
   
     xcodeWorkspace -> cleanXcode [style=invis]
     {rank=same xcodeWorkspace cleanXcode}
   }

/docs/userguide/img/xctest-configurations.dot
=============================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/xctest-configurations.dot > src/docs/userguide/img/xctest-configurations.png
   digraph xctestConfigurations {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=3.5, height=0.5];
   
     subgraph central {
       node[style=filled, fillcolor=white]
       implementation -> testVariantExecutableImplementation [style=invis, weight=1000]
       testVariantExecutableImplementation -> implementation [headport=s, tailport=n]
   
       testVariantExecutableImplementation[label=<test<i>Variant</i>ExecutableImplementation>]
       implementation[style=dashed]
     }
   
     subgraph left {
       node[style=filled, fillcolor="#cfe2f3"]
       swiftCompileTestVariant -> nativeLinkTestVariant -> nativeRuntimeTestVariant [style=invis, weight=1000]
   
       swiftCompileTestVariant[label=<swiftCompileTest<i>Variant</i> (R)>]
       nativeLinkTestVariant[label=<nativeLinkTest<i>Variant</i> (R)>]
       nativeRuntimeTestVariant[label=<nativeRuntimeTest<i>Variant</i> (R)>]
     }
   
     // Ensure the order is preserved
     {rank=same swiftCompileTestVariant implementation}
     {rank=same testVariantExecutableImplementation nativeLinkTestVariant}
     nativeLinkTestVariant -> testVariantExecutableImplementation [style=invis]
   
     {swiftCompileTestVariant, nativeLinkTestVariant, nativeRuntimeTestVariant} -> testVariantExecutableImplementation [headport=w, tailport=e]
   }

/docs/userguide/img/xctest-task-graph.dot
=========================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/xctest-task-graph.dot > src/docs/userguide/img/xctest-task-graph.png
   digraph xctestTaskGraph {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=2.5, height=0.5];
     node [style=filled, fillcolor="#cfe2f3"]
     rankdir=LR
   
     compileTestSwift -> linkTest -> installTest -> xcTest -> test -> check -> build [dir=back]
     compileDebugSwift -> linkTest [dir=back]
     assemble -> build [dir=back]
     tripleDots -> assemble [dir=back]
     clean
   
     compileDebugSwift [style="dashed,filled", fillcolor=grey]
     tripleDots [style="dashed,filled", fillcolor=grey, label="..."]
   
     // Ensure ordering
     compileTestSwift -> compileDebugSwift -> clean [style=invis]
     {rank=same compileDebugSwift compileTestSwift clean}
   }

/docs/userguide/img/xctest-variant-task-graph.dot
=================================================

.. code-block::

   // Copyright 2018 the original author or authors.
   //
   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //      http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
   
   // dot -Tpng src/docs/userguide/img/xctest-variant-task-graph.dot > src/docs/userguide/img/xctest-variant-task-graph.png
   digraph xctestVariantTaskGraph {
     graph [ dpi = 100, fontname="Sans"];
     node [fontname = "Sans"];
     edge [fontname = "Sans"];
     node [shape=rectangle, fixedsize=true, width=2.5, height=0.5];
     node [style="dashed,filled", fillcolor=grey]
     rankdir=LR
   
     compileTestVariantSwift -> linkTestVariant -> installTestVariant -> xcTestVariant [dir=back, style=dashed]
     compileTestVariantSwift[label=<compile<i>Variant</i>Swift>]
     linkTestVariant[label=<link<i>Variant</i>>]
     installTestVariant[label=<installTest<i>Variant</i>>]
     xcTestVariant[label=<xcTest<i>Variant</i>>]
   }

/Sample: 游릭 android-application
============================

samples/android-application/README.adoc

.. code-block::

   NOTE: You can open this sample inside a Android Studio IDE using the https://developer.android.com/studio/projects/create-project#ImportAProject[project importer].
   
   This sample shows how a simple Android application written in Java can be built with Gradle.
   The application was created following the https://developer.android.com/training/basics/firstapp[Build your first app guide].
   
   ====
   include::sample[dir="kotlin",files="app/build.gradle.kts[]"]
   include::sample[dir="groovy",files="app/build.gradle[]"]
   ====
   
   To build the application:
   
   [listing.terminal]
   ----
   $ ./gradlew build
   ----
   
   For more information, we suggest reading link:{userManualPath}#getting_started[Getting Started with Gradle].
   You can also find https://developer.android.com/guide[Android development related information inside the guides provided by the Android team].

samples/android-application/groovy/app/build.gradle

.. code-block::

   plugins {
       id('com.android.application') version '7.3.0'
   }
   
   repositories {
       google()
       mavenCentral()
   }
   
   android {
       compileSdkVersion 30
       defaultConfig {
           applicationId 'org.gradle.samples'
           minSdkVersion 16
           targetSdkVersion 30
           versionCode 1
           versionName '1.0'
           testInstrumentationRunner 'androidx.test.runner.AndroidJUnitRunner'
       }
       buildTypes {
           release {
               minifyEnabled false
               proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
           }
       }
   }
   
   dependencies {
       implementation 'androidx.appcompat:appcompat:1.2.0'
       implementation 'com.google.android.material:material:1.2.0'
       implementation 'androidx.constraintlayout:constraintlayout:2.0.4'
       testImplementation 'junit:junit:4.13.1'
       androidTestImplementation 'androidx.test.ext:junit:1.1.2'
       androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'
   }

samples/android-application/groovy/settings.gradle

.. code-block::

   pluginManagement {
       repositories {
           gradlePluginPortal()
           google()
       }
   }
   
   rootProject.name = 'my-app'
   
   include ':app'

samples/android-application/kotlin/app/build.gradle.kts

.. code-block::

   plugins {
       id("com.android.application") version "7.3.0"
   }
   
   repositories {
       google()
       mavenCentral()
   }
   
   android {
       compileSdkVersion(30)
       defaultConfig {
           applicationId = "org.gradle.samples"
           minSdkVersion(16)
           targetSdkVersion(30)
           versionCode = 1
           versionName = "1.0"
           testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
       }
       buildTypes {
           getByName("release") {
               isMinifyEnabled = false
               proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
           }
       }
   }
   
   dependencies {
       implementation("androidx.appcompat:appcompat:1.2.0")
       implementation("com.google.android.material:material:1.2.0")
       implementation("androidx.constraintlayout:constraintlayout:2.0.4")
       testImplementation("junit:junit:4.13.1")
       androidTestImplementation("androidx.test.ext:junit:1.1.2")
       androidTestImplementation("androidx.test.espresso:espresso-core:3.3.0")
   }

samples/android-application/kotlin/settings.gradle.kts

.. code-block::

   pluginManagement {
       repositories {
           gradlePluginPortal()
           google()
       }
   }
   
   rootProject.name = "my-app"
   
   include(":app")

samples/android-application/tests/buildTask.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: "build -x lint -x lintVitalRelease -Dorg.gradle.configuration-cache.internal.task-execution-access-pre-stable=true"
       # The following deprecation is coming from the Android plugin
       #> Task :app:javaPreCompileDebug
       #The Substitution.with(ComponentSelector) method has been deprecated. This is scheduled to be removed in Gradle 8.0. Please use the using(ComponentSelector) method instead. Consult the upgrading guide for further information: https://docs.gradle.org/7.1-20210406210000+0000/userguide/upgrading_version_7.html#dependency_substitutions_with
       flags: "--warning-mode=all"
   }]

samples/android-application/tests/sanityCheck.sample.conf

.. code-block::

   executable: gradle
   args: tasks
   # Do not fail for deprecation warnings: Android plugin 7.3.0 uses a deprecated Report.setDestination
   flags: "--warning-mode=all"

/Sample: 游릭 build-organization/composite-builds/basic
==================================================

samples/build-organization/composite-builds/basic/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   == Defining and using a composite build
   
   This sample shows how 2 Gradle builds that are normally developed separately and combined using binary integration can be wired together into a composite build with source integration. The `my-utils` multiproject build produces 2 different java libraries, and the `my-app` build produces an executable using functions from those libraries.
   
   Note that the `my-app` build does not have direct dependencies on `my-utils`. Instead, it declares module dependencies on the libraries produced by `my-utils`:
   
   ====
   include::sample[dir="kotlin",files="my-app/app/build.gradle.kts[tags=app_dependencies]"]
   include::sample[dir="groovy",files="my-app/app/build.gradle[tags=app_dependencies]"]
   ====
   
   == Using command-line composite build
   
   When using a composite build, no shared repository is required for the builds, and no changes need to be made to the build scripts.
   
   1. Change the sources of `Number.java`
   2. Run the `my-app` application, including the `my-utils` build.
   
   ```
   cd my-app
   gradle --include-build ../my-utils run
   ```
   
   Using _dependency substitution_, the module dependencies on the util libraries are replaced by project dependencies on `my-utils`.
   
   == Converting `my-app` to a composite build
   
   It's possible to make the above arrangement persistent, by making `my-app` a composite build that includes `my-utils`.
   
   ```
   cd my-app
   echo "includeBuild '../my-utils'" >> settings.gradle
   gradle run
   ```
   
   With this configuration, the module dependencies from `my-app` to `my-utils` will always be substituted with project dependencies.
   
   While simple, this approach has the downside of modifying the `my-app` build.
   
   == Using separate composite build
   
   It is also possible to create a separate composite build that includes both the `my-app` and `my-utils` builds.
   
   ====
   include::sample[dir="kotlin",files="settings.gradle.kts[]"]
   include::sample[dir="groovy",files="settings.gradle[]"]
   ====
   
   After doing so, you can reference any tasks in the included builds directly on the command line in order to execute.
   
   ```
   gradle :my-app:app:run
   ```
   
   Alternately, you can create delegating tasks in the composite project to execute tasks without specifying the full task path.
   
   ====
   include::sample[dir="kotlin",files="build.gradle.kts[tags=run]"]
   include::sample[dir="groovy",files="build.gradle[tags=run]"]
   ====
   
   ```
   gradle run
   ```

samples/build-organization/composite-builds/basic/groovy/build.gradle

.. code-block::

   defaultTasks 'run'
   
   // tag::run[]
   tasks.register('run') {
       dependsOn gradle.includedBuild('my-app').task(':app:run')
   }
   // end::run[]
   
   task checkAll {
       dependsOn gradle.includedBuild('my-app').task(':app:check')
       dependsOn gradle.includedBuild('my-utils').task(':number-utils:check')
       dependsOn gradle.includedBuild('my-utils').task(':string-utils:check')
   }

samples/build-organization/composite-builds/basic/groovy/my-app/app/build.gradle

.. code-block::

   // tag::app_dependencies[]
   plugins {
       id 'application'
   }
   
   application {
       mainClass = 'org.sample.myapp.Main'
   }
   
   dependencies {
       implementation 'org.sample:number-utils:1.0'
       implementation 'org.sample:string-utils:1.0'
   }
   // end::app_dependencies[]
   
   group 'org.sample'
   version '1.0'
   
   repositories {
       mavenCentral()
   }

samples/build-organization/composite-builds/basic/groovy/my-app/app/src/main/java/org/sample/myapp/Main.java

.. code-block::

   package org.sample.myapp;
   
   import org.sample.numberutils.Numbers;
   import org.sample.stringutils.Strings;
   
   public class Main {
   
       public static void main(String... args) {
           new Main().printAnswer();
       }
   
       public void printAnswer() {
           String output = Strings.concat(" The answer is    ", Numbers.add(19, 23));
           System.out.println(output);
       }
   }

samples/build-organization/composite-builds/basic/groovy/my-app/settings.gradle

.. code-block::

   rootProject.name = 'my-app'
   
   include 'app'

samples/build-organization/composite-builds/basic/groovy/my-utils/number-utils/build.gradle

.. code-block::

   plugins {
       id 'java-library'
   }
   
   group 'org.sample'
   version '1.0'
   
   repositories {
       mavenCentral()
   }

samples/build-organization/composite-builds/basic/groovy/my-utils/number-utils/src/main/java/org/sample/numberutils/Numbers.java

.. code-block::

   package org.sample.numberutils;
   
   public class Numbers {
      public static int add(int left, int right) { return left + right; }
   }

samples/build-organization/composite-builds/basic/groovy/my-utils/settings.gradle

.. code-block::

   rootProject.name = 'my-utils'
   
   include 'number-utils', 'string-utils'

samples/build-organization/composite-builds/basic/groovy/my-utils/string-utils/build.gradle

.. code-block::

   plugins {
       id 'java-library'
   }
   
   group 'org.sample'
   version '1.0'
   
   repositories {
       mavenCentral()
   }
   
   dependencies {
       implementation 'org.apache.commons:commons-lang3:3.4'
   }

samples/build-organization/composite-builds/basic/groovy/my-utils/string-utils/src/main/java/org/sample/stringutils/Strings.java

.. code-block::

   package org.sample.stringutils;
   
   import org.apache.commons.lang3.StringUtils;
   
   public class Strings {
      public static String concat(Object left, Object right) {
        return strip(left) + " " + strip(right);
      }
   
      private static String strip(Object val) {
        return StringUtils.strip(String.valueOf(val));
      }
   }

samples/build-organization/composite-builds/basic/groovy/settings.gradle

.. code-block::

   rootProject.name = 'my-composite'
   
   includeBuild 'my-app'
   includeBuild 'my-utils'

samples/build-organization/composite-builds/basic/kotlin/build.gradle.kts

.. code-block::

   defaultTasks("run")
   
   // tag::run[]
   tasks.register("run") {
       dependsOn(gradle.includedBuild("my-app").task(":app:run"))
   }
   // end::run[]
   
   tasks.register("checkAll") {
       dependsOn(gradle.includedBuild("my-app").task(":app:check"))
       dependsOn(gradle.includedBuild("my-utils").task(":number-utils:check"))
       dependsOn(gradle.includedBuild("my-utils").task(":string-utils:check"))
   }

samples/build-organization/composite-builds/basic/kotlin/my-app/app/build.gradle.kts

.. code-block::

   // tag::app_dependencies[]
   plugins {
       id("application")
   }
   
   application {
       mainClass = "org.sample.myapp.Main"
   }
   
   dependencies {
       implementation("org.sample:number-utils:1.0")
       implementation("org.sample:string-utils:1.0")
   }
   // end::app_dependencies[]
   
   group = "org.sample"
   version = "1.0"
   
   repositories {
       mavenCentral()
   }

samples/build-organization/composite-builds/basic/kotlin/my-app/app/src/main/java/org/sample/myapp/Main.java

.. code-block::

   package org.sample.myapp;
   
   import org.sample.numberutils.Numbers;
   import org.sample.stringutils.Strings;
   
   public class Main {
   
       public static void main(String... args) {
           new Main().printAnswer();
       }
   
       public void printAnswer() {
           String output = Strings.concat(" The answer is    ", Numbers.add(19, 23));
           System.out.println(output);
       }
   }

samples/build-organization/composite-builds/basic/kotlin/my-app/settings.gradle.kts

.. code-block::

   rootProject.name = "my-app"
   
   include("app")

samples/build-organization/composite-builds/basic/kotlin/my-utils/number-utils/build.gradle.kts

.. code-block::

   plugins {
       `java-library`
   }
   
   group = "org.sample"
   version = "1.0"
   
   repositories {
       mavenCentral()
   }

samples/build-organization/composite-builds/basic/kotlin/my-utils/number-utils/src/main/java/org/sample/numberutils/Numbers.java

.. code-block::

   package org.sample.numberutils;
   
   public class Numbers {
      public static int add(int left, int right) { return left + right; }
   }

samples/build-organization/composite-builds/basic/kotlin/my-utils/settings.gradle.kts

.. code-block::

   rootProject.name = "my-utils"
   
   include("number-utils", "string-utils")

samples/build-organization/composite-builds/basic/kotlin/my-utils/string-utils/build.gradle.kts

.. code-block::

   plugins {
       `java-library`
   }
   
   group = "org.sample"
   version = "1.0"
   
   repositories {
       mavenCentral()
   }
   
   dependencies {
       implementation("org.apache.commons:commons-lang3:3.4")
   }

samples/build-organization/composite-builds/basic/kotlin/my-utils/string-utils/src/main/java/org/sample/stringutils/Strings.java

.. code-block::

   package org.sample.stringutils;
   
   import org.apache.commons.lang3.StringUtils;
   
   public class Strings {
      public static String concat(Object left, Object right) {
        return strip(left) + " " + strip(right);
      }
   
      private static String strip(Object val) {
        return StringUtils.strip(String.valueOf(val));
      }
   }

samples/build-organization/composite-builds/basic/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "my-composite"
   
   includeBuild("my-app")
   includeBuild("my-utils")

samples/build-organization/composite-builds/basic/tests/basicCli.out

.. code-block::

   > Task :app:processResources NO-SOURCE
   > Task :my-utils:string-utils:compileJava
   > Task :my-utils:string-utils:processResources NO-SOURCE
   > Task :my-utils:string-utils:classes
   > Task :my-utils:string-utils:jar
   > Task :my-utils:number-utils:compileJava
   > Task :my-utils:number-utils:processResources NO-SOURCE
   > Task :my-utils:number-utils:classes
   > Task :my-utils:number-utils:jar
   > Task :app:compileJava
   > Task :app:classes
   
   > Task :app:run
   The answer is 42
   
   
   BUILD SUCCESSFUL in 0s
   6 actionable tasks: 6 executed

samples/build-organization/composite-builds/basic/tests/basicCli.sample.conf

.. code-block::

   execution-subdirectory: my-app
   executable: gradle
   args: run
   flags: "--include-build=../my-utils"
   expected-output-file: basicCli.out
   allow-additional-output: true
   allow-disordered-output: true

samples/build-organization/composite-builds/basic/tests/compositeRootProject.out

.. code-block::

   > Task :my-app:app:processResources NO-SOURCE
   > Task :my-utils:string-utils:compileJava
   > Task :my-utils:number-utils:compileJava
   > Task :my-utils:string-utils:processResources NO-SOURCE
   > Task :my-utils:string-utils:classes
   > Task :my-utils:string-utils:jar
   > Task :my-utils:number-utils:processResources NO-SOURCE
   > Task :my-utils:number-utils:classes
   > Task :my-utils:number-utils:jar
   > Task :my-app:app:compileJava
   > Task :my-app:app:classes
   
   > Task :my-app:app:run
   The answer is 42
   
   > Task :run
   
   BUILD SUCCESSFUL in 0s
   6 actionable tasks: 6 executed

samples/build-organization/composite-builds/basic/tests/compositeRootProject.sample.conf

.. code-block::

   executable: gradle
   args: run
   expected-output-file: compositeRootProject.out
   allow-disordered-output: true

samples/build-organization/composite-builds/basic/tests/sanityCheck.sample.conf

.. code-block::

   commands: [{
       execution-subdirectory: my-app
       executable: gradle
       args: tasks -q
   },{
       execution-subdirectory: my-utils
       executable: gradle
       args: tasks -q
   },{
       executable: gradle
       args: tasks -q
   }]

/Sample: 游릭 build-organization/composite-builds/declared-substitution
==================================================================

samples/build-organization/composite-builds/declared-substitution/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   == Declaring the dependencies substituted by an included build
   
   By default, Gradle will configure each included build in order to determine the dependencies it can provide. The algorithm for doing this is very simple: Gradle will inspect the `group` and `name` for the projects in the included build, and substitute project dependencies for any matching external dependency.
   
   In `dependencySubstitution` terms, the default substitutions are:
   ```
   dependencySubstitution {
       ... for each project in included build ...
       substitute module("${project.group}:${project.name}") using project(":${project.name}")
   }
   ```
   
   == Declaring substitutions for included build
   
   There are times when the default substitutions determined by Gradle are not sufficient, or they are not wanted in a particular composite. For these cases it is possible to explicitly declare the substitutions for an included build.
   
   Take for example a single-project build 'unpublished', that produces a java utility library but does not declare a value for the `group` attribute:
   
   ====
   include::sample[dir="kotlin/anonymous-library",files="build.gradle.kts[]"]
   include::sample[dir="groovy/anonymous-library",files="build.gradle[]"]
   ====
   
   When this build is included in a composite, it will attempt to substitute for the dependency module `undefined:unpublished` ('undefined' is the default value for `project.group`, and 'unpublished' is the root project name). Clearly this isn't going to be very useful in a composite build.
   
   In order to use the `unpublished` library as-is in a composite build, the composing build can explicitly declare the substitutions that it provides.
   
   ====
   include::sample[dir="kotlin",files="settings.gradle.kts[tags=composite_substitution]"]
   include::sample[dir="groovy",files="settings.gradle[tags=composite_substitution]"]
   ====
   
   With this configuration, the composite build will substitute any dependency on `org.sample:number-utils` with a dependency on the root project of `anonymous-library`.

samples/build-organization/composite-builds/declared-substitution/groovy/anonymous-library/build.gradle

.. code-block::

   plugins {
       id 'java'
   }

samples/build-organization/composite-builds/declared-substitution/groovy/anonymous-library/settings.gradle

.. code-block::

   rootProject.name = 'anonymous-library'

samples/build-organization/composite-builds/declared-substitution/groovy/anonymous-library/src/main/java/org/sample/numberutils/Numbers.java

.. code-block::

   package org.sample.numberutils;
   
   public class Numbers {
      public static int add(int left, int right) { return left + right; }
   }

samples/build-organization/composite-builds/declared-substitution/groovy/app/build.gradle

.. code-block::

   plugins {
       id 'java'
       id 'application'
   }
   
   application {
       mainClass = "org.sample.myapp.Main"
   }
   
   dependencies {
       implementation "org.sample:number-utils:1.0"
   }

samples/build-organization/composite-builds/declared-substitution/groovy/app/src/main/java/org/sample/myapp/Main.java

.. code-block::

   package org.sample.myapp;
   
   import org.sample.numberutils.Numbers;
   
   public class Main {
   
       public static void main(String... args) {
           new Main().printAnswer();
       }
   
       public void printAnswer() {
           String output = " The answer is " + Numbers.add(19, 23);
           System.out.println(output);
       }
   }

samples/build-organization/composite-builds/declared-substitution/groovy/settings.gradle

.. code-block::

   rootProject.name = 'declared-substitution'
   
   include 'app'
   
   // tag::composite_substitution[]
   includeBuild('anonymous-library') {
       dependencySubstitution {
           substitute module('org.sample:number-utils') using project(':')
       }
   }
   // end::composite_substitution[]

samples/build-organization/composite-builds/declared-substitution/kotlin/anonymous-library/build.gradle.kts

.. code-block::

   plugins {
       java
   }

samples/build-organization/composite-builds/declared-substitution/kotlin/anonymous-library/settings.gradle.kts

.. code-block::

   rootProject.name = "anonymous-library"

samples/build-organization/composite-builds/declared-substitution/kotlin/anonymous-library/src/main/java/org/sample/numberutils/Numbers.java

.. code-block::

   package org.sample.numberutils;
   
   public class Numbers {
      public static int add(int left, int right) { return left + right; }
   }

samples/build-organization/composite-builds/declared-substitution/kotlin/app/build.gradle.kts

.. code-block::

   plugins {
       java
       application
   }
   
   application {
       mainClass = "org.sample.myapp.Main"
   }
   
   dependencies {
       implementation("org.sample:number-utils:1.0")
   }

samples/build-organization/composite-builds/declared-substitution/kotlin/app/src/main/java/org/sample/myapp/Main.java

.. code-block::

   package org.sample.myapp;
   
   import org.sample.numberutils.Numbers;
   
   public class Main {
   
       public static void main(String... args) {
           new Main().printAnswer();
       }
   
       public void printAnswer() {
           String output = " The answer is " + Numbers.add(19, 23);
           System.out.println(output);
       }
   }

samples/build-organization/composite-builds/declared-substitution/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "declared-substitution"
   
   include("app")
   
   // tag::composite_substitution[]
   includeBuild("anonymous-library") {
       dependencySubstitution {
           substitute(module("org.sample:number-utils")).using(project(":"))
       }
   }
   // end::composite_substitution[]

samples/build-organization/composite-builds/declared-substitution/tests/sanityCheck.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: tasks -q
   },{
       execution-subdirectory: anonymous-library
       executable: gradle
       args: tasks -q
   }]

samples/build-organization/composite-builds/declared-substitution/tests/withDeclaredSubstitution.out

.. code-block::

   > Task :app:processResources NO-SOURCE
   > Task :anonymous-library:compileJava
   > Task :anonymous-library:processResources NO-SOURCE
   > Task :anonymous-library:classes
   > Task :anonymous-library:jar
   > Task :app:compileJava
   > Task :app:classes
   
   > Task :app:run
    The answer is 42
   
   BUILD SUCCESSFUL in 0s
   4 actionable tasks: 4 executed

samples/build-organization/composite-builds/declared-substitution/tests/withDeclaredSubstitution.sample.conf

.. code-block::

   executable: gradle
   args: run
   expected-output-file: withDeclaredSubstitution.out
   allow-disordered-output: true

/Sample: 游릭 build-organization/composite-builds/hierarchical-multirepo
===================================================================

samples/build-organization/composite-builds/hierarchical-multirepo/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   == Using composite builds in a hierarchical multirepo project
   
   This sample demonstrates how composite builds can be used to develop a hierarchical project that is composed from different Git repositories. Instead of Gradle subprojects in a multiproject build, this example uses separate Gradle builds included into a composite.
   
   In addition to the benefits of a multirepo architecture, using a Gradle composite build in this way allows a developer to easily choose which modules to develop as source dependencies and which to integrate via a binary repository.
   
   == Running `multirepo-app` with dependencies from included builds
   
   In the first instance, all of the required dependencies are present as builds in the `modules` directory. In a real-world example, these could well be clones of different Git repositories.
   
   In order to avoid hard-coding the included builds to load, the `settings.gradle` file in `multirepo-app` loads each of these builds dynamically:
   
   ====
   include::sample[dir="kotlin",files="settings.gradle.kts[tags=include_builds]"]
   include::sample[dir="groovy",files="settings.gradle[tags=include_builds]"]
   ====
   
   When the `multirepo-app` build is executed, these module builds are used to generate the dependent artifacts:
   
   ```
   gradle run
   ```
   
   And the 'dependencies' report shows the dependency substitution in action:
   
   ```
   gradle app:dependencies --configuration runtimeClasspath
   ```
   
   ```
   runtimeClasspath - Runtime classpath of source set 'main'.
   +--- org.sample:number-utils:1.0 -> project :number-utils
   \--- org.sample:string-utils:1.0 -> project :string-utils
        \--- org.apache.commons:commons-lang3:3.12.0
   ```
   
   == Switching to use binary dependency
   
   As long as the modules are available in a binary repository, the `multirepo-app` build will continue to work even if you don't have some modules available locally. In this case Gradle will use a binary dependency downloaded from a repository instead.
   
   === Preparing the binary repository
   
   To demonstrate this functionality, we first need to publish each module to a binary repository. In this case we use a local file repository for this purpose:
   
   ```
   gradle :publishDeps
   ```
   
   The `publishDeps` creates and uploads the artifacts for each included build. It is defined in `multirepo-app` as follows:
   
   ====
   include::sample[dir="kotlin",files="build.gradle.kts"]
   include::sample[dir="groovy",files="build.gradle"]
   ====
   
   === Removing the local module source
   
   With module artifacts available in a repository, we can now remove the module sources from the build. Since the composite is configured to automatically load available modules, this is as easy as deleting one or more module directories.
   
   ```
   rm -r modules/string-utils
   gradle run
   ```
   
   Note that the `number-utils` dependency is still satisfied by the included build, while the `string-utils` dependency is now resolved from the repository.
   
   The 'dependencies' report shows the dependency substitution in action:
   
   ```
   gradle app:dependencies --configuration runtimeClasspath
   ```
   
   ```
   runtimeClasspath - Runtime classpath of source set 'main'.
   +--- org.sample:number-utils:1.0 -> project :number-utils
   \--- org.sample:string-utils:1.0
        \--- org.apache.commons:commons-lang3:3.12.0
   ```
   
   == Including an external library as a submodule
   
   The power of this configuration can be demonstrated by adding the external 'commons-lang' build directly to the composite.
   
   ```
   git clone http://gitbox.apache.org/repos/asf/commons-lang.git modules/commons-lang --branch rel/commons-lang-3.12.0 --depth 1
   gradle --project-dir modules/commons-lang init
   gradle run
   ```
   
   You can see the external transitive dependency `commons-lang` being replaced with the local project dependency by running:
   
   ```
   gradle app:dependencies --configuration runtimeClasspath
   ```

samples/build-organization/composite-builds/hierarchical-multirepo/groovy/app/build.gradle

.. code-block::

   plugins {
       id 'application'
   }
   
   group "org.sample"
   version "1.0"
   
   application {
       mainClass = "org.sample.myapp.Main"
   }
   
   dependencies {
       implementation "org.sample:number-utils:1.0"
       implementation "org.sample:string-utils:1.0"
   }
   
   repositories {
       maven {
           url project.file("../local-repo")
       }
       mavenCentral()
   }

samples/build-organization/composite-builds/hierarchical-multirepo/groovy/app/src/main/java/org/sample/myapp/Main.java

.. code-block::

   package org.sample.myapp;
   
   import org.sample.numberutils.Numbers;
   import org.sample.stringutils.Strings;
   
   public class Main {
   
       public static void main(String... args) {
           new Main().printAnswer();
       }
   
       public void printAnswer() {
           String output = Strings.concat(" The answer is    ", Numbers.add(19, 23));
           System.out.println(output);
       }
   }

samples/build-organization/composite-builds/hierarchical-multirepo/groovy/build.gradle

.. code-block::

   tasks.register('publishDeps') {
       dependsOn gradle.includedBuilds*.task(':publishMavenPublicationToMavenRepository')
   }

samples/build-organization/composite-builds/hierarchical-multirepo/groovy/modules/number-utils/build.gradle

.. code-block::

   plugins {
       id 'java'
       id 'maven-publish'
   }
   
   group "org.sample"
   version "1.0"
   
   publishing {
       repositories {
           maven {
               url file("../../local-repo")
           }
       }
       publications {
           maven(MavenPublication) { from components.java }
       }
   }

samples/build-organization/composite-builds/hierarchical-multirepo/groovy/modules/number-utils/settings.gradle

.. code-block::

   rootProject.name = 'number-utils'

samples/build-organization/composite-builds/hierarchical-multirepo/groovy/modules/number-utils/src/main/java/org/sample/numberutils/Numbers.java

.. code-block::

   package org.sample.numberutils;
   
   public class Numbers {
      public static int add(int left, int right) { return left + right; }
   }

samples/build-organization/composite-builds/hierarchical-multirepo/groovy/modules/string-utils/build.gradle

.. code-block::

   plugins {
       id 'java'
       id 'maven-publish'
   }
   
   group "org.sample"
   version "1.0"
   
   dependencies {
       implementation "org.apache.commons:commons-lang3:3.12.0"
   }
   
   repositories {
       mavenCentral()
   }
   
   publishing {
       repositories {
           maven {
               url file("../../local-repo")
           }
       }
       publications {
           maven(MavenPublication) { from components.java }
       }
   }

samples/build-organization/composite-builds/hierarchical-multirepo/groovy/modules/string-utils/settings.gradle

.. code-block::

   rootProject.name = 'string-utils'

samples/build-organization/composite-builds/hierarchical-multirepo/groovy/modules/string-utils/src/main/java/org/sample/stringutils/Strings.java

.. code-block::

   package org.sample.stringutils;
   
   import org.apache.commons.lang3.StringUtils;
   
   public class Strings {
      public static String concat(Object left, Object right) {
        return strip(left) + " " + strip(right);
      }
   
      private static String strip(Object val) {
        return StringUtils.strip(String.valueOf(val));
      }
   }

samples/build-organization/composite-builds/hierarchical-multirepo/groovy/settings.gradle

.. code-block::

   rootProject.name = 'multirepo-app'
   
   include 'app'
   
   // tag::include_builds[]
   file('modules').listFiles().each { File moduleBuild ->
       includeBuild moduleBuild
   }
   // end::include_builds[]

samples/build-organization/composite-builds/hierarchical-multirepo/kotlin/app/build.gradle.kts

.. code-block::

   plugins {
       application
   }
   
   group = "org.sample"
   version = "1.0"
   
   application {
       mainClass = "org.sample.myapp.Main"
   }
   
   dependencies {
       implementation("org.sample:number-utils:1.0")
       implementation("org.sample:string-utils:1.0")
   }
   
   repositories {
       maven {
           url = uri(project.file("../local-repo"))
       }
       mavenCentral()
   }

samples/build-organization/composite-builds/hierarchical-multirepo/kotlin/app/src/main/java/org/sample/myapp/Main.java

.. code-block::

   package org.sample.myapp;
   
   import org.sample.numberutils.Numbers;
   import org.sample.stringutils.Strings;
   
   public class Main {
   
       public static void main(String... args) {
           new Main().printAnswer();
       }
   
       public void printAnswer() {
           String output = Strings.concat(" The answer is    ", Numbers.add(19, 23));
           System.out.println(output);
       }
   }

samples/build-organization/composite-builds/hierarchical-multirepo/kotlin/build.gradle.kts

.. code-block::

   tasks.register("publishDeps") {
       dependsOn(gradle.includedBuilds.map { it.task(":publishMavenPublicationToMavenRepository") })
   }

samples/build-organization/composite-builds/hierarchical-multirepo/kotlin/modules/number-utils/build.gradle.kts

.. code-block::

   plugins {
       `java-library`
       `maven-publish`
   }
   
   group = "org.sample"
   version = "1.0"
   
   publishing {
       repositories {
           maven {
               setUrl(file("../../local-repo"))
           }
       }
       publications {
           create<MavenPublication>("maven") { from(components["java"]) }
       }
   }

samples/build-organization/composite-builds/hierarchical-multirepo/kotlin/modules/number-utils/settings.gradle.kts

.. code-block::

   rootProject.name = "number-utils"

samples/build-organization/composite-builds/hierarchical-multirepo/kotlin/modules/number-utils/src/main/java/org/sample/numberutils/Numbers.java

.. code-block::

   package org.sample.numberutils;
   
   public class Numbers {
      public static int add(int left, int right) { return left + right; }
   }

samples/build-organization/composite-builds/hierarchical-multirepo/kotlin/modules/string-utils/build.gradle.kts

.. code-block::

   plugins {
       `java-library`
       `maven-publish`
   }
   
   group = "org.sample"
   version = "1.0"
   
   dependencies {
       implementation("org.apache.commons:commons-lang3:3.12.0")
   }
   
   repositories {
       mavenCentral()
   }
   
   publishing {
       repositories {
           maven {
               setUrl(file("../../local-repo"))
           }
       }
       publications {
           create<MavenPublication>("maven") { from(components["java"]) }
       }
   }

samples/build-organization/composite-builds/hierarchical-multirepo/kotlin/modules/string-utils/settings.gradle.kts

.. code-block::

   rootProject.name = "string-utils"

samples/build-organization/composite-builds/hierarchical-multirepo/kotlin/modules/string-utils/src/main/java/org/sample/stringutils/Strings.java

.. code-block::

   package org.sample.stringutils;
   
   import org.apache.commons.lang3.StringUtils;
   
   public class Strings {
      public static String concat(Object left, Object right) {
        return strip(left) + " " + strip(right);
      }
   
      private static String strip(Object val) {
        return StringUtils.strip(String.valueOf(val));
      }
   }

samples/build-organization/composite-builds/hierarchical-multirepo/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "multirepo-app"
   
   include("app")
   
   // tag::include_builds[]
   file("modules").listFiles().forEach { moduleBuild: File ->
       includeBuild(moduleBuild)
   }
   // end::include_builds[]

samples/build-organization/composite-builds/hierarchical-multirepo/tests/runComposite.out

.. code-block::

   > Task :app:processResources NO-SOURCE
   > Task :number-utils:compileJava
   > Task :number-utils:processResources NO-SOURCE
   > Task :number-utils:classes
   > Task :string-utils:compileJava
   > Task :string-utils:processResources NO-SOURCE
   > Task :string-utils:classes
   > Task :number-utils:jar
   > Task :string-utils:jar
   > Task :app:compileJava
   > Task :app:classes
   
   > Task :app:run
   The answer is 42
   
   BUILD SUCCESSFUL in 0s
   6 actionable tasks: 6 executed

samples/build-organization/composite-builds/hierarchical-multirepo/tests/runComposite.sample.conf

.. code-block::

   executable: gradle
   args: run
   expected-output-file: runComposite.out
   allow-disordered-output: true

samples/build-organization/composite-builds/hierarchical-multirepo/tests/sanityCheck.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: tasks -q
   },{
       execution-subdirectory: modules/number-utils
       executable: gradle
       args: tasks -q
   },{
       execution-subdirectory: modules/string-utils
       executable: gradle
       args: tasks -q
   }]

/Sample: 游릭 build-organization/composite-builds/plugin-dev
=======================================================

samples/build-organization/composite-builds/plugin-dev/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   == Composite build to develop a Gradle plugin
   
   This sample demonstrates a composite build used to develop a Gradle plugin in conjunction with a consuming build.
   
   The plugin could be in the same repository (only used by this build) or it could be in a different repository (used by many other builds).
   
   This removes the need for the special `buildSrc` project and makes prototyping plugins even easier.
   
   == Buildscript dependencies are substituted
   
   In a composite build, dependencies declared in the `plugins { }` block or in the `buildscript` `classpath` configuration are substituted in the same way as other dependencies. In this sample, the build declares that plugin 'org.sample.greeting', and this dependency is substituted by the `greeting-plugin` included build.
   
   Without ever publishing the `greeting-plugin` project to a repository, it is possible to build the project with the locally developed 'org.sample.greeting' plugin.
   
   [listing.terminal]
   ----
   > gradle --include-build ../greeting-plugin greeting
   [composite-build] Configuring build: /home/user/gradle/sample/compositeBuilds/plugin-dev/greeting-plugin
   :greeting-plugin:compileJava
   :greeting-plugin:pluginDescriptors
   :greeting-plugin:processResources
   :greeting-plugin:classes
   :greeting-plugin:jar
   :my-greeting-app:greeting
   Hi Bob!!!
   ----
   
   == Plugin changes can be tested
   
   This sample can be used to demonstrate the development lifecycle of a Gradle plugin. Edit the file `greeting-plugin/src/main/java/org/sample/GreetingTask.java` to change the greeting, and re-execute the consumer build:
   
   [listing.terminal]
   ----
   > gradle --include-build ../greeting-plugin greeting
   [composite-build] Configuring build: /home/user/gradle/sample/compositeBuilds/plugin-dev/greeting-plugin
   :greeting-plugin:compileJava
   :greeting-plugin:pluginDescriptors
   :greeting-plugin:processResources
   :greeting-plugin:classes
   :greeting-plugin:jar
   :my-greeting-app:greeting
   G'day Bob!!!
   ----
   

samples/build-organization/composite-builds/plugin-dev/groovy/greeting-plugin/build.gradle

.. code-block::

   plugins {
       id 'java-gradle-plugin'
       id 'idea'
   }
   
   group = 'org.sample'
   version = '1.0-SNAPSHOT'
   
   gradlePlugin {
       plugins {
           customPlugin {
               id = 'org.sample.greeting'
               implementationClass = 'org.sample.GreetingPlugin'
           }
       }
   }

samples/build-organization/composite-builds/plugin-dev/groovy/greeting-plugin/settings.gradle

.. code-block::

   rootProject.name = 'greeting-plugin'

samples/build-organization/composite-builds/plugin-dev/groovy/greeting-plugin/src/main/java/org/sample/GreetingExtension.java

.. code-block::

   package org.sample;
   
   import org.gradle.api.provider.Property;
   
   public abstract class GreetingExtension {
       public abstract Property<String> getWho();
   }

samples/build-organization/composite-builds/plugin-dev/groovy/greeting-plugin/src/main/java/org/sample/GreetingPlugin.java

.. code-block::

   package org.sample;
   
   import org.gradle.api.Plugin;
   import org.gradle.api.Project;
   import org.gradle.api.tasks.TaskProvider;
   
   import java.util.LinkedHashMap;
   
   public class GreetingPlugin implements Plugin<Project> {
   
       public void apply(Project project) {
           GreetingExtension extension = project.getExtensions().create("greeting", GreetingExtension.class);
           extension.getWho().convention("mate");
           TaskProvider<GreetingTask> task = project.getTasks().register("greeting", GreetingTask.class, t -> {
               t.getWho().convention(extension.getWho());
           });
       }
   }

samples/build-organization/composite-builds/plugin-dev/groovy/greeting-plugin/src/main/java/org/sample/GreetingTask.java

.. code-block::

   package org.sample;
   
   import org.gradle.api.DefaultTask;
   import org.gradle.api.provider.Property;
   import org.gradle.api.tasks.Input;
   import org.gradle.api.tasks.TaskAction;
   
   public abstract class GreetingTask extends DefaultTask {
   
       @Input
       public abstract Property<String> getWho();
   
       @TaskAction
       public void greet() {
           System.out.println("Hi " + getWho().get() + "!!!");
       }
   }

samples/build-organization/composite-builds/plugin-dev/groovy/my-greeting-app/build.gradle

.. code-block::

   plugins {
       id 'org.sample.greeting' version '1.0-SNAPSHOT'
   }
   
   greeting {
       who = 'Bob'
   }

samples/build-organization/composite-builds/plugin-dev/groovy/settings.gradle

.. code-block::

   rootProject.name = 'consumer'
   
   include 'my-greeting-app'
   
   // To function outside a composite, a plugin repository would be required here

samples/build-organization/composite-builds/plugin-dev/kotlin/greeting-plugin/build.gradle.kts

.. code-block::

   plugins {
       id("java-gradle-plugin")
   }
   
   group = "org.sample"
   version = "1.0-SNAPSHOT"
   
   gradlePlugin {
       plugins {
           create("customPlugin") {
               id = "org.sample.greeting"
               implementationClass = "org.sample.GreetingPlugin"
           }
       }
   }

samples/build-organization/composite-builds/plugin-dev/kotlin/greeting-plugin/settings.gradle.kts

.. code-block::

   rootProject.name = "greeting-plugin"

samples/build-organization/composite-builds/plugin-dev/kotlin/greeting-plugin/src/main/java/org/sample/GreetingExtension.java

.. code-block::

   package org.sample;
   
   import org.gradle.api.provider.Property;
   
   public abstract class GreetingExtension {
       public abstract Property<String> getWho();
   }

samples/build-organization/composite-builds/plugin-dev/kotlin/greeting-plugin/src/main/java/org/sample/GreetingPlugin.java

.. code-block::

   package org.sample;
   
   import org.gradle.api.Plugin;
   import org.gradle.api.Project;
   import org.gradle.api.tasks.TaskProvider;
   
   import java.util.LinkedHashMap;
   
   public class GreetingPlugin implements Plugin<Project> {
   
       public void apply(Project project) {
           GreetingExtension extension = project.getExtensions().create("greeting", GreetingExtension.class);
           extension.getWho().convention("mate");
           TaskProvider<GreetingTask> task = project.getTasks().register("greeting", GreetingTask.class, t -> {
               t.getWho().convention(extension.getWho());
           });
       }
   }

samples/build-organization/composite-builds/plugin-dev/kotlin/greeting-plugin/src/main/java/org/sample/GreetingTask.java

.. code-block::

   package org.sample;
   
   import org.gradle.api.DefaultTask;
   import org.gradle.api.provider.Property;
   import org.gradle.api.tasks.Input;
   import org.gradle.api.tasks.TaskAction;
   
   public abstract class GreetingTask extends DefaultTask {
   
       @Input
       public abstract Property<String> getWho();
   
       @TaskAction
       public void greet() {
           System.out.println("Hi " + getWho().get() + "!!!");
       }
   }

samples/build-organization/composite-builds/plugin-dev/kotlin/my-greeting-app/build.gradle.kts

.. code-block::

   plugins {
       id("org.sample.greeting").version("1.0-SNAPSHOT")
   }
   
   greeting {
       who = "Bob"
   }

samples/build-organization/composite-builds/plugin-dev/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "consumer"
   
   include("my-greeting-app")
   
   // To function outside a composite, a plugin repository would be required here

samples/build-organization/composite-builds/plugin-dev/tests/compositeBuilds_plugin_dev.out

.. code-block::

   > Task :greeting-plugin:compileJava
   > Task :greeting-plugin:pluginDescriptors
   > Task :greeting-plugin:processResources
   > Task :greeting-plugin:classes
   > Task :greeting-plugin:jar
   
   > Task :my-greeting-app:greeting
   Hi Bob!!!
   
   BUILD SUCCESSFUL in 0s
   5 actionable tasks: 5 executed

samples/build-organization/composite-builds/plugin-dev/tests/compositeBuilds_plugin_dev.sample.conf

.. code-block::

   executable: gradle
   args: greeting
   flags: "--include-build=greeting-plugin"
   expected-output-file: compositeBuilds_plugin_dev.out

samples/build-organization/composite-builds/plugin-dev/tests/sanityCheck.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: tasks -q
       flags: "--include-build=greeting-plugin"
   },{
       execution-subdirectory: greeting-plugin
       executable: gradle
       args: tasks -q
   }]

/Sample: 游릭 build-organization/cross-project-output-sharing
========================================================

samples/build-organization/cross-project-output-sharing/README.adoc

.. code-block::

   You want to share a file made by a task in one project with a task in another project.
   For example, one task makes a file, and the other task reads the file and uses some information inside it.
   This is one way you can share information across project boundaries. (Another way is to use extension objects.)
   
   [NOTE]
   ====
   This demonstrates the <<../userguide/cross_project_publications.adoc#simple-sharing-artifacts-between-projects, simple version>> of sharing information across project boundaries, by explicitly specifying which producer project's _consumable configuration_ to use for a locally available artifact.
   
   When the producer publishes an artifact to a repository, to retrieve that artifact you will need to use <<../userguide/cross_project_publications.adoc#variant-aware-sharing, the advanced version>> of variant aware dependency resolution.
   This method will also work locally.
   ====
   
   == Example
   
   .Settings
   ====
   include::sample[dir="kotlin",files="settings.gradle.kts[]"]
   include::sample[dir="groovy",files="settings.gradle[]"]
   ====
   
   .Producer's build
   ====
   include::sample[dir="kotlin",files="producer/build.gradle.kts[]"]
   include::sample[dir="groovy",files="producer/build.gradle[]"]
   ====
   
   .Consumer's build
   ====
   include::sample[dir="kotlin",files="consumer/build.gradle.kts[]"]
   include::sample[dir="groovy",files="consumer/build.gradle[]"]
   ====
   
   See also:
   
   - <<../userguide/cross_project_publications.adoc#cross_project_publications, Sharing outputs between projects>>
   
   == Anti-patterns:
   
   .Don't reference other project tasks directly
   --
   A frequent anti-pattern to declare cross-project dependencies is below.
   
   This publication model is unsafe and can lead to non-reproducible and hard to parallelize builds.
   By declaring a dependency in this way, the task ordering between consumers and producers is not known to Gradle at the time when it is deciding the order of tasks for a given build.
   This means that potentially, consumers of the file "someOtherJar" can execute before the producer task that creates the jar!
   This would lead to builds that are either totally broken, or worse, broken is a way that is subtle, flaky, and difficult to debug.
   
   [source,groovy]
   dependencies {
     // This publication model can make your build flaky and broken!
     implementation project(":other").tasks.someOtherJar
   }
   --

samples/build-organization/cross-project-output-sharing/groovy/consumer/build.gradle

.. code-block::

   configurations {
       sharedConfiguration {
           canBeConsumed = false
       }
   }
   
   dependencies {
       sharedConfiguration(project("path": ":producer", "configuration": "sharedConfiguration"))
   }
   
   tasks.register("showFile") {
       FileCollection sharedFiles = configurations.getByName("sharedConfiguration")
       inputs.files(sharedFiles)
       doFirst {
           logger.lifecycle("Shared file contains the text: '{}'", sharedFiles.singleFile.text)
       }
   }

samples/build-organization/cross-project-output-sharing/groovy/producer/build.gradle

.. code-block::

   def makeFile = tasks.register("makeFile") {
       def sharedFile = layout.buildDirectory.file("some-subdir/shared-file.txt")
       outputs.file(sharedFile)
       doFirst {
           sharedFile.get().asFile << "This file is shared across Gradle subprojects."
       }
   }
   
   configurations {
       sharedConfiguration {
           canBeResolved = false
       }
   }
   
   artifacts {
       sharedConfiguration(makeFile)
   }

samples/build-organization/cross-project-output-sharing/groovy/settings.gradle

.. code-block::

   rootProject.name = "sharing-outputs"
   include("producer")
   include("consumer")

samples/build-organization/cross-project-output-sharing/kotlin/consumer/build.gradle.kts

.. code-block::

   val sharedConfiguration: Configuration by configurations.creating {
       isCanBeConsumed = false
   }
   
   dependencies {
       sharedConfiguration(project(path = ":producer", configuration = "sharedConfiguration"))
   }
   
   tasks.register("showFile") {
       val sharedFiles: FileCollection = sharedConfiguration
       inputs.files(sharedFiles)
       doFirst {
           logger.lifecycle("Shared file contains the text: '{}'", sharedFiles.singleFile.readText())
       }
   }

samples/build-organization/cross-project-output-sharing/kotlin/producer/build.gradle.kts

.. code-block::

   val makeFile = tasks.register("makeFile") {
       val sharedFile = layout.buildDirectory.file("some-subdir/shared-file.txt")
       outputs.file(sharedFile)
       doFirst {
           sharedFile.get().asFile.writeText("This file is shared across Gradle subprojects.")
       }
   }
   
   val sharedConfiguration by configurations.creating {
       isCanBeResolved = false
   }
   
   artifacts {
       add(sharedConfiguration.name, makeFile)
   }

samples/build-organization/cross-project-output-sharing/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "sharing-outputs"
   include("producer")
   include("consumer")

samples/build-organization/cross-project-output-sharing/tests/check.out

.. code-block::

   > Task :producer:makeFile
   
   > Task :consumer:showFile
   Shared file contains the text: 'This file is shared across Gradle subprojects.'

samples/build-organization/cross-project-output-sharing/tests/check.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: showFile
       expected-output-file: check.out
       allow-additional-output: true
   }]

/Sample: 游릭 build-organization/gradle-plugin
=========================================

samples/build-organization/gradle-plugin/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how to build a Gradle plugin in the Java language.
   
   ====
   include::sample[dir="kotlin",files="greeting-plugin/build.gradle.kts[tags=plugin]"]
   include::sample[dir="groovy",files="greeting-plugin/build.gradle[tags=plugin]"]
   ====
   
   For a more guided tour with plugin development, see link:https://gradle.org/guides/?q=Plugin%20Development[the guides for plugin development].
   
   You can also generate this project locally using link:{userManualPath}#build_init_plugin-sec:java_gradle_plugin[`gradle init`].

samples/build-organization/gradle-plugin/groovy/greeting-plugin/build.gradle

.. code-block::

   // tag::plugin[]
   plugins {
       // Apply the Java Gradle plugin development plugin to add support for developing Gradle plugins
       id 'java-gradle-plugin'
   }
   
   repositories {
       // Use Maven Central for resolving dependencies.
       // You can declare any Maven/Ivy/file repository here.
       mavenCentral()
   }
   
   dependencies {
       // Use JUnit test framework for unit tests
       testImplementation 'junit:junit:4.13'
   }
   
   gradlePlugin {
       // Define the plugin
       plugins {
           greeting {
               id = 'com.example.plugin.greeting'
               implementationClass = 'com.example.plugin.GreetingPlugin'
           }
       }
   }
   // end::plugin[]
   
   // Add a source set and a task for a functional test suite
   def functionalTest = sourceSets.create('functionalTest')
   gradlePlugin.testSourceSets(functionalTest)
   
   configurations[functionalTest.implementationConfigurationName].extendsFrom(configurations.testImplementation)
   
   def functionalTestTask = tasks.register('functionalTest', Test) {
       testClassesDirs = functionalTest.output.classesDirs
       classpath = configurations[functionalTest.runtimeClasspathConfigurationName] + functionalTest.output
   }
   
   tasks.check.configure {
       // Run the functional tests as part of `check`
       dependsOn(functionalTestTask)
   }

samples/build-organization/gradle-plugin/groovy/settings.gradle

.. code-block::

   rootProject.name = 'gradle-plugin-in-java'
   
   include 'greeting-plugin'

samples/build-organization/gradle-plugin/kotlin/greeting-plugin/build.gradle.kts

.. code-block::

   // tag::plugin[]
   plugins {
       // Apply the Java Gradle plugin development plugin to add support for developing Gradle plugins
       `java-gradle-plugin`
   }
   
   repositories {
       // Use Maven Central for resolving dependencies
       mavenCentral()
   }
   
   dependencies {
       // Use JUnit test framework for unit tests
       testImplementation("junit:junit:4.13")
   }
   
   gradlePlugin {
       // Define the plugin
       val greeting by plugins.creating {
           id = "com.example.plugin.greeting"
           implementationClass = "com.example.plugin.GreetingPlugin"
       }
   }
   // end::plugin[]
   
   // Add a source set and a task for a functional test suite
   val functionalTest by sourceSets.creating
   gradlePlugin.testSourceSets(functionalTest)
   
   configurations[functionalTest.implementationConfigurationName].extendsFrom(configurations.testImplementation.get())
   
   val functionalTestTask = tasks.register<Test>("functionalTest") {
       testClassesDirs = functionalTest.output.classesDirs
       classpath = configurations[functionalTest.runtimeClasspathConfigurationName] + functionalTest.output
   }
   
   tasks.check {
       // Run the functional tests as part of `check`
       dependsOn(functionalTestTask)
   }

samples/build-organization/gradle-plugin/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "gradle-plugin-in-java"
   
   include("greeting-plugin")

samples/build-organization/gradle-plugin/tests/check.out

.. code-block::

   > Task :greeting-plugin:compileJava
   > Task :greeting-plugin:pluginDescriptors
   > Task :greeting-plugin:processResources
   > Task :greeting-plugin:classes
   > Task :greeting-plugin:compileFunctionalTestJava
   > Task :greeting-plugin:processFunctionalTestResources NO-SOURCE
   > Task :greeting-plugin:functionalTestClasses
   > Task :greeting-plugin:pluginUnderTestMetadata
   > Task :greeting-plugin:functionalTest
   > Task :greeting-plugin:compileTestJava
   > Task :greeting-plugin:processTestResources NO-SOURCE
   > Task :greeting-plugin:testClasses

samples/build-organization/gradle-plugin/tests/check.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: check
       expected-output-file: check.out
       allow-additional-output: true
       allow-disordered-output: true
   }]

/Sample: 游릭 build-organization/multi-project-with-convention-plugins
=================================================================

samples/build-organization/multi-project-with-convention-plugins/groovy/library-b/README.md

    API
    ---

    public API description for library b

    Changelog
    ---------

    -  change 1
    -  change 2


samples/build-organization/multi-project-with-convention-plugins/groovy/library-a/README.md

    API
    ---

    public API description for library a

    Changelog
    ---------

    -  change 1
    -  change 2

samples/build-organization/multi-project-with-convention-plugins/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how build logic in a multi-project build can be organized into reusable plugins.
   
   == Use case
   
   As an example, let's say a project with three subprojects produces two public Java libraries that use the third subproject as an internal shared library.
   This is the project structure:
   
   ====
   [.multi-language-sample]
   =====
   .Project structure
   [source, kotlin]
   ----
   較럭較 internal-module
   較   較덕較 build.gradle.kts
   較럭較 library-a
   較   較럭較 build.gradle.kts
   較   較덕較 README.md
   較럭較 library-b
   較   較럭較 build.gradle.kts
   較   較덕較 README.md
   較덕較 settings.gradle.kts
   ----
   =====
   [.multi-language-sample]
   =====
   .Project structure
   [source, groovy]
   ----
   較럭較 internal-module
   較   較덕較 build.gradle
   較럭較 library-a
   較   較럭較 build.gradle
   較   較덕較 README.md
   較럭較 library-b
   較   較럭較 build.gradle
   較   較덕較 README.md
   較덕較 settings.gradle
   ----
   =====
   ====
   
   Let's say that all our projects will be Java projects.
   In this case we want to apply a common set of rules to all of them, such as source directory layout, compiler flags,
   code style conventions, code quality checks and so on.
   
   Two out of three projects are more than just Java projects - they are libraries that we perhaps want to publish to an
   external repository. Publishing configuration, such as a common group name for the libraries as well as the repository coordinates
   might be a cross-cutting concern that both libraries need to share. For this example let's also say that we want to enforce that
   our libraries expose some documentation with a common structure.
   
   == Organizing build logic
   
   From the use case above, we have identified that we have two types of projects - generic Java projects and public libraries.
   We can model this use case by layering two separate plugins that each define the type of project that applies them:
   
   ====
   [.multi-language-sample]
   =====
   .Build logic layout
   [source, kotlin]
   ----
   較럭較 buildSrc
   較   較럭較 build.gradle.kts
   較   較럭較 settings.gradle.kts
   較   較럭較 src
   較   較   較럭較 main
   較   較   較   較덕較 kotlin
   較   較   較       較럭較 myproject.java-conventions.gradle.kts
   較   較   較       較덕較 myproject.library-conventions.gradle.kts
   ...
   ----
   =====
   [.multi-language-sample]
   =====
   .Build logic layout
   [source, groovy]
   ----
   較럭較 buildSrc
   較   較럭較 build.gradle
   較   較럭較 settings.gradle
   較   較럭較 src
   較   較   較럭較 main
   較   較   較   較덕較 groovy
   較   較   較       較럭較 myproject.java-conventions.gradle
   較   較   較       較덕較 myproject.library-conventions.gradle
   ...
   ----
   =====
   ====
   
   * `myproject.java-conventions` - configures conventions that are generic for any Java project in the organization.
   It applies the core `java` and `checkstyle` plugins as well as an external `com.github.spotbugs` plugin, configures common
   compiler options as well as code quality checks.
   * `myproject.library-conventions` - adds publishing configuration to publish to the organization's repository and checks for mandatory content in a README.
   It applies `java-library` and `maven-publish` plugins as well as the `myproject.java-conventions` plugin.
   
   The internal library subproject applies `myproject.java-conventions` plugin:
   ====
   include::sample[dir="kotlin",files="internal-module/build.gradle.kts[]"]
   include::sample[dir="groovy",files="internal-module/build.gradle[]"]
   ====
   
   The two public library subprojects apply `myproject.library-conventions` plugin.
   ====
   include::sample[dir="kotlin",files="library-a/build.gradle.kts[];library-b/build.gradle.kts[]"]
   include::sample[dir="groovy",files="library-a/build.gradle[];library-b/build.gradle[]"]
   ====
   
   Note how applying a convention plugin to a subproject effectively declares its type.
   By applying `myproject.java-conventions` plugin we state: this is a "Java" project.
   By applying `myproject.library-conventions` plugin we state: this is a "Library" project.
   
   All plugins created in this sample contain functional tests that use link:{userManualPath}#test_kit[TestKit] to verify their behavior.
   
   This sample does not have any project source code and only lays out a hypothetical project structure where two library subprojects depend on a shared internal subproject.
   
   
   == Compiling convention plugins
   
   In this sample, convention plugins are implemented as link:{userManualPath}#custom_plugins-sec:precompiled_plugins[precompiled script plugins] -
   this is the simplest way to start out as you can use one of Gradle's DSLs directly to implement the build logic, just as if the plugin was
   a regular build script.
   
   [.multi-language-text.lang-kotlin]
   In order for precompiled script plugins to be discovered, the `buildSrc` project needs to apply the `kotlin-dsl` plugin
   in its `build.gradle.kts` file:
   
   
   [.multi-language-text.lang-groovy]
   In order for precompiled script plugins to be discovered, the `buildSrc` project needs to apply the `groovy-gradle-plugin` plugin
   in its `build.gradle` file:
   
   .Enabling precompiled script plugins
   ====
   include::sample[dir="kotlin",files="buildSrc/build.gradle.kts[tags=apply]"]
   include::sample[dir="groovy",files="buildSrc/build.gradle[tags=apply]"]
   ====
   
   
   == Things to note
   
   === Applying an external plugin in precompiled script plugin
   
   The `myproject.java-conventions` plugin uses SpotBugs plugin to perform static code analysis.
   
   SpotBugs is an external plugin - external plugins link:{userManualPath}#custom_plugins-applying_external_plugins_in_precompiled_script_plugins[need to be added as implementation dependencies] before they can be applied in a precompiled script plugin:
   ====
   include::sample[dir="kotlin",files="buildSrc/build.gradle.kts[tags=repositories-and-dependencies]"]
   include::sample[dir="groovy",files="buildSrc/build.gradle[tags=repositories-and-dependencies]"]
   ====
   
   * The dependency artifact coordinates (GAV) for a plugin can be different from the plugin id.
   * The Gradle Plugin Portal (`gradlePluginPortal()`) is added as a repository for plugin dependencies.
   * The plugin version is determined from the dependency version.
   
   Once the dependency is added, the external plugin can be applied in precompiled script plugin by id:
   ====
   include::sample[dir="kotlin",files="buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts[tags=apply-external-plugin]"]
   include::sample[dir="groovy",files="buildSrc/src/main/groovy/myproject.java-conventions.gradle[tags=apply-external-plugin]"]
   ====
   
   === Applying other precompiled script plugins
   
   Precompiled script plugins can apply other precompiled script plugins.
   
   The `myproject.library-conventions` plugin applies the `myproject.java-conventions` plugin:
   ====
   include::sample[dir="kotlin",files="buildSrc/src/main/kotlin/myproject.library-conventions.gradle.kts[tags=plugins]"]
   include::sample[dir="groovy",files="buildSrc/src/main/groovy/myproject.library-conventions.gradle[tags=plugins]"]
   ====
   
   === Using classes from the main source set
   
   Precompiled script plugins can use classes defined in the main source set of the plugins project.
   
   In this sample, `myproject.library-conventions` plugin uses a custom task class from `buildSrc/src/main/java` to configure library README checks:
   ====
   include::sample[dir="kotlin",files="buildSrc/src/main/kotlin/myproject.library-conventions.gradle.kts[tags=use-java-class]"]
   include::sample[dir="groovy",files="buildSrc/src/main/groovy/myproject.library-conventions.gradle[tags=use-java-class]"]
   ====
   
   For more details on authoring custom Gradle plugins, consult the link:{userManualPath}#custom_plugins[user manual].

samples/build-organization/multi-project-with-convention-plugins/groovy/buildSrc/build.gradle

.. code-block::

   // tag::apply[]
   plugins {
       id 'groovy-gradle-plugin'
   }
   // end::apply[]
   
   // tag::repositories-and-dependencies[]
   repositories {
       gradlePluginPortal() // so that external plugins can be resolved in dependencies section
   }
   
   dependencies {
       implementation 'com.github.spotbugs.snom:spotbugs-gradle-plugin:5.2.1'
       testImplementation platform("org.spockframework:spock-bom:2.2-groovy-3.0")
       testImplementation 'org.spockframework:spock-core'
   }
   
   tasks.named('test', Test) {
       useJUnitPlatform()
   }
   // end::repositories-and-dependencies[]

samples/build-organization/multi-project-with-convention-plugins/groovy/buildSrc/settings.gradle

.. code-block::

   rootProject.name='my-org-conventions'

samples/build-organization/multi-project-with-convention-plugins/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle

.. code-block::

   // Define Java conventions for this organization.
   // Projects need to use the Java, Checkstyle and Spotbugs plugins.
   
   // tag::apply-external-plugin[]
   plugins {
       id 'java'
       id 'checkstyle'
   
       // NOTE: external plugin version is specified in implementation dependency artifact of the project's build file
       id 'com.github.spotbugs'
   }
   // end::apply-external-plugin[]
   
   // Projects should use Maven Central for external dependencies
   // This could be the organization's private repository
   repositories {
       mavenCentral()
   }
   
   // Use the Checkstyle rules provided by the convention plugin
   // Do not allow any warnings
   checkstyle {
       config = resources.text.fromString(com.example.CheckstyleUtil.getCheckstyleConfig("/checkstyle.xml"))
       maxWarnings = 0
   }
   
   // Enable deprecation messages when compiling Java code
   tasks.withType(JavaCompile).configureEach {
       options.compilerArgs << "-Xlint:deprecation"
   }

samples/build-organization/multi-project-with-convention-plugins/groovy/buildSrc/src/main/groovy/myproject.library-conventions.gradle

.. code-block::

   // Define Java Library conventions for this organization.
   // Projects need to use the organization's Java conventions and publish using Maven Publish
   
   // tag::plugins[]
   plugins {
       id 'java-library'
       id 'maven-publish'
       id 'myproject.java-conventions'
   }
   // end::plugins[]
   
   // Projects have the 'com.example' group by convention
   group = 'com.example'
   
   publishing {
       publications {
           library(MavenPublication) {
               from components.java
           }
       }
       repositories {
           maven {
               name "myOrgPrivateRepo"
               url 'build/my-repo'
           }
       }
   }
   
   // The project requires libraries to have a README containing sections configured below
   // tag::use-java-class[]
   def readmeCheck = tasks.register('readmeCheck', com.example.ReadmeVerificationTask) {
       // Expect the README in the project directory
       readme = layout.projectDirectory.file("README.md")
       // README must contain a Service API header
       readmePatterns = ['^## API$', '^## Changelog$']
   }
   // end::use-java-class[]
   
   tasks.named('check') { dependsOn(readmeCheck) }

samples/build-organization/multi-project-with-convention-plugins/groovy/buildSrc/src/test/groovy/com/example/JavaConventionPluginTest.groovy

.. code-block::

   package com.example
   
   import org.gradle.testkit.runner.TaskOutcome
   
   class JavaConventionPluginTest extends PluginTest {
   
       def setup() {
           buildFile << """
               plugins {
                   id 'myproject.java-conventions'
               }
           """
       }
   
       def "fails on checkstyle error"() {
           given:
           new File(testProjectDir, 'src/main/java/com/example').mkdirs()
           new File(testProjectDir, 'src/main/java/com/example/Foo.java') << """
               package com.example;
   
               import java.util.*;
   
               class Foo {
                   void bar() {
                   }
               }
           """
   
           when:
           def result = runTaskWithFailure('build')
   
           then:
           result.task(":checkstyleMain").outcome == TaskOutcome.FAILED
           result.output.contains('Checkstyle rule violations were found.')
           result.output.contains('Checkstyle violations by severity: [error:1]')
       }
   
       def "fails on checkstyle warning"() {
           given:
           new File(testProjectDir, 'src/main/java/com/example').mkdirs()
           new File(testProjectDir, 'src/main/java/com/example/Foo.java') << """
               package com.example;
   
               class Foo {
                   final static public String FOO = "BAR";
   
                   void bar() {
                   }
               }
           """
   
           when:
           def result = runTaskWithFailure('build')
   
           then:
           result.task(":checkstyleMain").outcome == TaskOutcome.FAILED
           result.output.contains('Checkstyle rule violations were found.')
           result.output.contains('Checkstyle violations by severity: [warning:1]')
       }
   
       def "fails on spotbugs error"() {
           given:
           new File(testProjectDir, 'src/main/java/com/example').mkdirs()
           new File(testProjectDir, 'src/main/java/com/example/Foo.java') << """
               package com.example;
   
               class Foo {
                   void bar() {
                       String s = null;
                       s.hashCode();
                   }
               }
           """
   
           when:
           def result = runTaskWithFailure('build')
   
           then:
           result.task(":spotbugsMain").outcome == TaskOutcome.FAILED
       }
   
       def "warns on deprecated API usage"() {
           given:
           new File(testProjectDir, 'src/main/java/com/example').mkdirs()
           new File(testProjectDir, 'src/main/java/com/example/Foo.java') << """
               package com.example;
   
               public class Foo {
                   @Deprecated
                   public void deprecatedMethod() {}
               }
           """
   
           new File(testProjectDir, 'src/main/java/com/example/Bar.java') << """
               package com.example;
   
               public class Bar {
                   public void bar() {
                       new Foo().deprecatedMethod();
                   }
               }
           """
   
           when:
           def result = runTask('build')
   
           then:
           result.task(":build").outcome == TaskOutcome.SUCCESS
           result.output.contains('warning: [deprecation] deprecatedMethod()')
       }
   }

samples/build-organization/multi-project-with-convention-plugins/groovy/buildSrc/src/test/groovy/com/example/LibraryPluginTest.groovy

.. code-block::

   package com.example
   
   import org.gradle.testkit.runner.TaskOutcome
   
   class LibraryPluginTest extends PluginTest {
   
       def setup() {
           buildFile << """
               plugins {
                   id 'myproject.library-conventions'
               }
           """
       }
   
       def "can declare api dependencies"() {
           given:
           readmeContainingMandatorySectionsExists()
           buildFile << """
               dependencies {
                   api 'org.apache.commons:commons-lang3:3.4'
               }
           """
   
           when:
           def result = runTask('build')
   
           then:
           result.task(":build").outcome == TaskOutcome.SUCCESS
       }
   
       def "publishes library with versionin"() {
           given:
           readmeContainingMandatorySectionsExists()
           settingsFile.setText("rootProject.name = 'my-library'")
           buildFile << """
               version = '0.1.0'
   
               publishing {
                   repositories {
                       maven {
                           name 'testRepo'
                           url 'build/test-repo'
                       }
                   }
               }
           """
   
           new File(testProjectDir, 'src/main/java/com/example').mkdirs()
           new File(testProjectDir, 'src/main/java/com/example/Util.java') << """
               package com.example;
   
               public class Util {
                   public static void someUtil() {
                   }
               }
           """
   
           when:
           def result = runTask('publishLibraryPublicationToTestRepoRepository')
   
           then:
           result.task(":jar").outcome == TaskOutcome.SUCCESS
           result.task(":publishLibraryPublicationToTestRepoRepository").outcome == TaskOutcome.SUCCESS
           new File(testProjectDir, 'build/test-repo/com/example/my-library/0.1.0/my-library-0.1.0.jar').exists()
       }
   
       def "fails when no README exists"() {
           when:
           def result = runTaskWithFailure('check')
   
           then:
           result.task(":readmeCheck").outcome == TaskOutcome.FAILED
       }
   
       def "fails when README does not have API section"() {
           given:
           new File(testProjectDir, 'README.md') << """
   ## Changelog
   - change 1
   - change 2
           """
   
           when:
           def result = runTaskWithFailure('check')
   
           then:
           result.task(":readmeCheck").outcome == TaskOutcome.FAILED
           result.output.contains('README should contain section: ^## API$')
       }
   
       def "fails when README does not have Changelog section"() {
           given:
           new File(testProjectDir, 'README.md') << """
   ## API
   public API description
           """
   
           when:
           def result = runTaskWithFailure('check')
   
           then:
           result.task(":readmeCheck").outcome == TaskOutcome.FAILED
           result.output.contains('README should contain section: ^## Changelog')
       }
   
       private def readmeContainingMandatorySectionsExists() {
           new File(testProjectDir, 'README.md') << """
   ## API
   public API description
   
   ## Changelog
   - change 1
   - change 2
           """
       }
   }

samples/build-organization/multi-project-with-convention-plugins/groovy/buildSrc/src/test/groovy/com/example/PluginTest.groovy

.. code-block::

   package com.example
   
   import org.gradle.testkit.runner.GradleRunner
   import spock.lang.Specification
   import spock.lang.TempDir
   
   abstract class PluginTest extends Specification {
       @TempDir
       File testProjectDir
       File settingsFile
       File buildFile
   
       def setup() {
           settingsFile = new File(testProjectDir, 'settings.gradle').tap { it << "rootProject.name = 'test'" }
           buildFile = new File(testProjectDir, 'build.gradle')
       }
   
       def runTask(String task) {
           return GradleRunner.create()
                   .withProjectDir(testProjectDir)
                   .withArguments(task, '--stacktrace')
                   .withPluginClasspath()
                   .build()
       }
   
       def runTaskWithFailure(String task) {
           return GradleRunner.create()
                   .withProjectDir(testProjectDir)
                   .withArguments(task, '--stacktrace')
                   .withPluginClasspath()
                   .buildAndFail()
       }
   }

samples/build-organization/multi-project-with-convention-plugins/groovy/internal-module/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
   }
   
   dependencies {
       // internal module dependencies
   }

samples/build-organization/multi-project-with-convention-plugins/groovy/library-a/build.gradle

.. code-block::

   plugins {
       id 'myproject.library-conventions'
   }
   
   dependencies {
       implementation project(':internal-module')
   }

samples/build-organization/multi-project-with-convention-plugins/groovy/library-b/build.gradle

.. code-block::

   plugins {
       id 'myproject.library-conventions'
   }
   
   dependencies {
       implementation project(':internal-module')
   }

samples/build-organization/multi-project-with-convention-plugins/groovy/settings.gradle

.. code-block::

   rootProject.name = 'sample'
   
   include 'internal-module', 'library-a', 'library-b'

samples/build-organization/multi-project-with-convention-plugins/kotlin/buildSrc/build.gradle.kts

.. code-block::

   // tag::apply[]
   plugins {
       `kotlin-dsl`
   }
   // end::apply[]
   
   // tag::repositories-and-dependencies[]
   repositories {
       gradlePluginPortal() // so that external plugins can be resolved in dependencies section
   }
   
   dependencies {
       implementation("com.github.spotbugs.snom:spotbugs-gradle-plugin:5.2.1")
       testImplementation("junit:junit:4.13")
   }
   // end::repositories-and-dependencies[]

samples/build-organization/multi-project-with-convention-plugins/kotlin/buildSrc/settings.gradle.kts

.. code-block::

   rootProject.name="my-org-conventions"

samples/build-organization/multi-project-with-convention-plugins/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts

.. code-block::

   // Define Java conventions for this organization.
   // Projects need to use the Java, Checkstyle and Spotbugs plugins.
   
   // tag::apply-external-plugin[]
   plugins {
       java
       checkstyle
   
       // NOTE: external plugin version is specified in implementation dependency artifact of the project's build file
       id("com.github.spotbugs")
   }
   // end::apply-external-plugin[]
   
   // Projects should use Maven Central for external dependencies
   // This could be the organization's private repository
   repositories {
       mavenCentral()
   }
   
   // Use the Checkstyle rules provided by the convention plugin
   // Do not allow any warnings
   checkstyle {
       config = resources.text.fromString(com.example.CheckstyleUtil.getCheckstyleConfig("/checkstyle.xml"))
       maxWarnings = 0
   }
   
   // Enable deprecation messages when compiling Java code
   tasks.withType<JavaCompile>().configureEach {
       options.compilerArgs.add("-Xlint:deprecation")
   }

samples/build-organization/multi-project-with-convention-plugins/kotlin/buildSrc/src/main/kotlin/myproject.library-conventions.gradle.kts

.. code-block::

   // Define Java Library conventions for this organization.
   // Projects need to use the organization's Java conventions and publish using Maven Publish
   
   // tag::plugins[]
   plugins {
       `java-library`
       `maven-publish`
       id("myproject.java-conventions")
   }
   // end::plugins[]
   
   // Projects have the 'com.example' group by convention
   group = "com.example"
   
   publishing {
       publications {
           create<MavenPublication>("library") {
               from(components["java"])
           }
       }
       repositories {
           maven {
               name = "myOrgPrivateRepo"
               url = uri("build/my-repo")
           }
       }
   }
   
   // The project requires libraries to have a README containing sections configured below
   // tag::use-java-class[]
   val readmeCheck by tasks.registering(com.example.ReadmeVerificationTask::class) {
       readme = layout.projectDirectory.file("README.md")
       readmePatterns = listOf("^## API$", "^## Changelog$")
   }
   // end::use-java-class[]
   
   tasks.named("check") { dependsOn(readmeCheck) }

samples/build-organization/multi-project-with-convention-plugins/kotlin/buildSrc/src/test/kotlin/com/example/JavaConventionPluginTest.kt

.. code-block::

   package com.example
   
   import org.gradle.testkit.runner.TaskOutcome
   import org.junit.Assert.assertEquals
   import org.junit.Assert.assertTrue
   import org.junit.Before
   import org.junit.Test
   
   class JavaConventionPluginTest : PluginTest() {
   
       @Before
       fun init() {
           buildFile.appendText("""
               plugins {
                   id("myproject.java-conventions")
               }
           """)
       }
   
       @Test
       fun `fails on checkstyle error`() {
           testProjectDir.newFolder("src", "main", "java", "com", "example")
           testProjectDir.newFile("src/main/java/com/example/Foo.java").appendText("""
               package com.example;
   
               import java.util.*;
   
               class Foo {
                   void bar() {
                   }
               }
           """)
   
           val result = runTaskWithFailure("build")
   
           assertEquals(TaskOutcome.FAILED, result.task(":checkstyleMain")?.outcome)
           assertTrue(result.output.contains("Checkstyle rule violations were found."))
           assertTrue(result.output.contains("Checkstyle violations by severity: [error:1]"))
       }
   
       @Test
       fun `fails on checkstyle warning`() {
           testProjectDir.newFolder("src", "main", "java", "com", "example")
           testProjectDir.newFile("src/main/java/com/example/Foo.java").writeText("""
               package com.example;
   
               class Foo {
                   final static public String FOO = "BAR";
   
                   void bar() {
                   }
               }
           """)
   
           val result = runTaskWithFailure("build")
   
           assertEquals(TaskOutcome.FAILED, result.task(":checkstyleMain")?.outcome)
           assertTrue(result.output.contains("Checkstyle rule violations were found."))
           assertTrue(result.output.contains("Checkstyle violations by severity: [warning:1]"))
       }
   
       @Test
       fun `fails on spotbugs error`() {
           testProjectDir.newFolder("src", "main", "java", "com", "example")
           testProjectDir.newFile("src/main/java/com/example/Foo.java").writeText("""
               package com.example;
   
               class Foo {
                   void bar() {
                       String s = null;
                       s.hashCode();
                   }
               }
           """)
   
           val result = runTaskWithFailure("build")
   
           assertEquals(TaskOutcome.FAILED, result.task(":spotbugsMain")?.outcome)
       }
   
       @Test
       fun `warns on deprecated API usage`() {
           testProjectDir.newFolder("src", "main", "java", "com", "example")
           testProjectDir.newFile("src/main/java/com/example/Foo.java").writeText("""
               package com.example;
   
               public class Foo {
                   @Deprecated
                   public void deprecatedMethod() {}
               }
           """)
   
           testProjectDir.newFile("src/main/java/com/example/Bar.java").writeText("""
               package com.example;
   
               public class Bar {
                   public void bar() {
                       new Foo().deprecatedMethod();
                   }
               }
           """)
   
           val result = runTask("build")
   
           assertEquals(TaskOutcome.SUCCESS, result.task(":build")?.outcome)
           assertTrue(result.output.contains("warning: [deprecation] deprecatedMethod()"))
       }
   }

samples/build-organization/multi-project-with-convention-plugins/kotlin/buildSrc/src/test/kotlin/com/example/LibraryPluginTest.kt

.. code-block::

   package com.example
   
   import org.gradle.testkit.runner.TaskOutcome
   import org.junit.Assert.assertEquals
   import org.junit.Assert.assertTrue
   import org.junit.Before
   import org.junit.Test
   import java.io.File
   
   class LibraryPluginTest : PluginTest() {
   
       @Before
       fun init() {
           buildFile.appendText("""
               plugins {
                   id("myproject.library-conventions")
               }
           """)
       }
   
       @Test
       fun `can declare api dependencies`() {
           readmeContainingMandatorySectionsExists()
           buildFile.appendText("""
               dependencies {
                   api("org.apache.commons:commons-lang3:3.4")
               }
           """)
   
           val result = runTask("build")
   
           assertEquals(TaskOutcome.SUCCESS, result.task(":build")?.outcome)
       }
   
       @Test
       fun `publishes library with versionin`() {
           readmeContainingMandatorySectionsExists()
           settingsFile.writeText("""
               rootProject.name = "my-library"
           """.trimIndent())
           buildFile.appendText("""
               version = "0.1.0"
   
               publishing {
                   repositories {
                       maven {
                           name = "testRepo"
                           url = uri("build/test-repo")
                       }
                   }
               }
           """)
   
           testProjectDir.newFolder("src", "main", "java", "com", "example")
           testProjectDir.newFile("src/main/java/com/example/Util.java").writeText("""
               package com.example;
   
               public class Util {
                   public static void someUtil() {
                   }
               }
           """)
   
           val result = runTask("publishLibraryPublicationToTestRepoRepository")
   
           assertEquals(TaskOutcome.SUCCESS, result.task(":jar")?.outcome)
           assertEquals(TaskOutcome.SUCCESS, result.task(":publishLibraryPublicationToTestRepoRepository")?.outcome)
           assertTrue(File(testProjectDir.getRoot(), "build/test-repo/com/example/my-library/0.1.0/my-library-0.1.0.jar").exists())
       }
   
       @Test
       fun `fails when no README exists`() {
           val result = runTaskWithFailure ("check")
   
           assertEquals(TaskOutcome.FAILED, result.task(":readmeCheck")?.outcome)
       }
   
       @Test
       fun `fails when README does not have API section`() {
           testProjectDir.newFile("README.md").writeText("""
               ## Changelog
               - change 1
               - change 2
           """.trimIndent())
   
           val result = runTaskWithFailure ("check")
   
           assertEquals(TaskOutcome.FAILED, result.task(":readmeCheck")?.outcome)
           assertTrue(result.output.contains("README should contain section: ^## API$"))
       }
   
       @Test
       fun `fails when README does not have Changelog section`() {
           testProjectDir.newFile("README.md").writeText("""
               ## API
               public API description
           """.trimIndent())
   
           val result = runTaskWithFailure ("check")
   
           assertEquals(TaskOutcome.FAILED, result.task(":readmeCheck")?.outcome)
           assertTrue(result.output.contains("README should contain section: ^## Changelog$"))
       }
   
       private fun readmeContainingMandatorySectionsExists() {
           testProjectDir.newFile("README.md").writeText("""
               ## API
               public API description
   
               ## Changelog
               - change 1
               - change 2
           """.trimIndent())
       }
   }

samples/build-organization/multi-project-with-convention-plugins/kotlin/buildSrc/src/test/kotlin/com/example/PluginTest.kt

.. code-block::

   package com.example
   
   import org.gradle.testkit.runner.BuildResult
   import org.gradle.testkit.runner.GradleRunner
   import org.junit.Before
   import org.junit.Rule
   import org.junit.rules.TemporaryFolder
   import java.io.File
   
   abstract class PluginTest {
   
       @Rule
       @JvmField
       val testProjectDir: TemporaryFolder = TemporaryFolder()
       protected lateinit var settingsFile: File
       protected lateinit var buildFile: File
   
       @Before
       fun setup() {
           settingsFile = testProjectDir.newFile("settings.gradle.kts")
           settingsFile.appendText("""
               rootProject.name = "test"
           """)
           buildFile = testProjectDir.newFile("build.gradle.kts")
       }
   
       fun runTask(task: String): BuildResult {
           return GradleRunner.create()
                   .withProjectDir(testProjectDir.root)
                   .withArguments(task, "--stacktrace")
                   .withPluginClasspath()
                   .build()
       }
   
       fun runTaskWithFailure(task: String): BuildResult {
           return GradleRunner.create()
                   .withProjectDir(testProjectDir.root)
                   .withArguments(task, "--stacktrace")
                   .withPluginClasspath()
                   .buildAndFail()
       }
   }

samples/build-organization/multi-project-with-convention-plugins/kotlin/internal-module/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
   }
   
   dependencies {
       // internal module dependencies
   }

samples/build-organization/multi-project-with-convention-plugins/kotlin/library-a/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.library-conventions")
   }
   
   dependencies {
       implementation(project(":internal-module"))
   }

samples/build-organization/multi-project-with-convention-plugins/kotlin/library-a/README.md

    API
    ---

    public API description for library a

    Changelog
    ---------

    -  change 1
    -  change 2

samples/build-organization/multi-project-with-convention-plugins/kotlin/library-b/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.library-conventions")
   }
   
   dependencies {
       implementation(project(":internal-module"))

samples/build-organization/multi-project-with-convention-plugins/kotlin/library-b/README.md

    API
    ---

    public API description for library b

    Changelog
    ---------

    -  change 1
    -  change 2

samples/build-organization/multi-project-with-convention-plugins/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "sample"
   include("internal-module", "library-a", "library-b")

samples/build-organization/multi-project-with-convention-plugins/tests/check.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: check
   }]

/Sample: 游릭 build-organization/publishing-convention-plugins
=========================================================

samples/build-organization/publishing-convention-plugins/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how build logic can be organized into reusable pieces and published to a repository for reuse in other projects
   for multi-repo setups.
   
   NOTE: There is also a link:#[new sample] demonstrating how to use the link:{userManualPath}#feature_lifecycle-sec:incubating_state[incubating] link:{userManualPath}#jvm_test_suite_plugin[Test Suite Plugin] in this scenario.
   
   == Use case
   
   As an example, let's say an organization produces two types of Java software - services and libraries.
   We want to apply a set of code quality checking rules to both types of projects and configure some aspects specific to each type.
   
   
   == Organizing build logic
   
   The use case can be modelled by layering three separate plugins:
   
   ====
   [.multi-language-sample]
   =====
   .Build logic layout
   [source, kotlin]
   ----
   較럭較 convention-plugins
   較   較럭較 build.gradle.kts
   較   較럭較 settings.gradle.kts
   較   較럭較 src
   較   較   較럭較 main
   較   較   較   較덕較 kotlin
   較   較   較       較럭較 com.myorg.java-conventions.gradle.kts
   較   較   較       較럭較 com.myorg.library-conventions.gradle.kts
   較   較   較       較덕較 com.myorg.service-conventions.gradle.kts
   ...
   ----
   =====
   [.multi-language-sample]
   =====
   .Build logic layout
   [source, groovy]
   ----
   較럭較 convention-plugins
   較   較럭較 build.gradle
   較   較럭較 settings.gradle
   較   較럭較 src
   較   較   較럭較 main
   較   較   較   較덕較 groovy
   較   較   較       較럭較 com.myorg.java-conventions.gradle
   較   較   較       較럭較 com.myorg.library-conventions.gradle
   較   較   較       較덕較 com.myorg.service-conventions.gradle
   ...
   ----
   =====
   ====
   
   * `com.myorg.java-conventions` - configures conventions that are generic for any Java project in the organization.
   This applies for both types of previously identified software and thus this plugin will be applied in both subsequent plugins.
   * `com.myorg.library-conventions` - adds publishing configuration to publish to the organization's repository and configures mandatory documentation checks.
   * `com.myorg.service-conventions` - configures integration tests and checks for mandatory content in a README.
   Since services differ from libraries, different requirements for documentation are configured in this case.
   
   All plugins created in this sample contain functional tests that use link:{userManualPath}#test_kit[TestKit] to verify their behavior.
   
   
   == Compiling convention plugins
   
   In this sample, convention plugins are implemented as link:{userManualPath}#custom_plugins-sec:precompiled_plugins[precompiled script plugins] -
   this is the simplest way to start out as you can use one of Gradle's DSLs directly to implement the build logic, just as if the plugin was
   a regular build script.
   
   [.multi-language-text.lang-groovy]
   In order for precompiled script plugins to be discovered, the `convention-plugins` project needs to apply the `groovy-gradle-plugin` plugin
   in its `build.gradle` file:
   
   [.multi-language-text.lang-kotlin]
   In order for precompiled script plugins to be discovered, the `convention-plugins` project needs to apply the `kotlin-dsl` plugin
   in its `build.gradle.kts` file:
   
   .Enabling precompiled script plugins
   ====
   include::sample[dir="kotlin",files="convention-plugins/build.gradle.kts[tags=apply]"]
   include::sample[dir="groovy",files="convention-plugins/build.gradle[tags=apply]"]
   ====
   
   == Publishing convention plugins
   
   In this sample we are targeting a multi-repo setup. In order to apply the above plugins to separate projects, they have to be published
   to a company's artifact repository.
   Convention plugins are regular Gradle plugins - thus they can be link:{userManualPath}#custom_plugins-sec:publishing_your_plugin[published to an external repository like any other Gradle plugin].
   
   Here, we configure the project to publish the plugins using the link:{userManualPath}#publishing_maven[maven-publish plugin].
   For demonstration purposes, we publish to a local filesystem directory.
   You can find information about how to publish to a remote repository in the link:{userManualPath}#publishing_maven-publishing_maven:repositories[repositories section of the maven-publish plugin].
   
   .Publishing configuration
   ====
   include::sample[dir="kotlin",files="convention-plugins/build.gradle.kts[tags=publish]"]
   include::sample[dir="groovy",files="convention-plugins/build.gradle[tags=publish]"]
   ====
   
   The plugins can be published using:
   
   ----
   ./gradlew publish
   ----
   
   In order to consume them in another project, configure the plugins repository in the settings file and apply the plugin:
   ====
   [.multi-language-sample]
   =====
   .settings.gradle.kts
   [source, kotlin]
   ----
   pluginManagement {
       repositories {
           gradlePluginPortal()
           maven {
               // replace the path with the actual path to the repository
               url = uri("<path-to>/convention-plugins/build/repo")
           }
       }
   }
   ----
   .build.gradle.kts
   [source, kotlin]
   ----
   plugins {
       id("com.myorg.service-conventions") version "1.0"
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .settings.gradle
   [source, groovy]
   ----
   pluginManagement {
       repositories {
           gradlePluginPortal()
           maven {
               // replace the path with the actual path to the repository
               url = uri('<path-to>/convention-plugins/build/repo')
           }
       }
   }
   ----
   .build.gradle
   [source, groovy]
   ----
   plugins {
       id 'com.myorg.service-conventions' version '1.0'
   }
   ----
   =====
   ====
   
   == Things to note
   
   === Applying an external plugin in convention plugin
   
   The `com.myorg.java-conventions` plugin uses the SpotBugs plugin to perform static code analysis.
   
   SpotBugs is an external plugin - external plugins link:{userManualPath}#custom_plugins-applying_external_plugins_in_precompiled_script_plugins[need to be added as implementation dependencies] before they can be applied in a convention plugin:
   ====
   include::sample[dir="kotlin",files="convention-plugins/build.gradle.kts[tags=repositories-and-dependencies]"]
   include::sample[dir="groovy",files="convention-plugins/build.gradle[tags=repositories-and-dependencies]"]
   ====
   
   * The dependency artifact coordinates (GAV) for a plugin can be different from the plugin id.
   * The Gradle Plugin Portal (`gradlePluginPortal()`) is added as a repository for plugin dependencies.
   * The plugin version is determined from the dependency version.
   
   Once the dependency is added, the external plugin can be applied in a convention plugin by id:
   ====
   include::sample[dir="kotlin",files="convention-plugins/src/main/kotlin/com.myorg.java-conventions.gradle.kts[tags=apply-external-plugin]"]
   include::sample[dir="groovy",files="convention-plugins/src/main/groovy/com.myorg.java-conventions.gradle[tags=apply-external-plugin]"]
   ====
   
   === Applying other convention plugins
   
   Convention plugins can apply other convention plugins.
   
   The `com.myorg.library-conventions` and `com.myorg.service-conventions` plugins both apply the `com.myorg.java-conventions` plugin:
   ====
   include::sample[dir="kotlin",files="convention-plugins/src/main/kotlin/com.myorg.library-conventions.gradle.kts[tags=plugins];convention-plugins/src/main/kotlin/com.myorg.service-conventions.gradle.kts[tags=plugins]"]
   include::sample[dir="groovy",files="convention-plugins/src/main/groovy/com.myorg.library-conventions.gradle[tags=plugins];convention-plugins/src/main/groovy/com.myorg.service-conventions.gradle[tags=plugins]"]
   ====
   
   === Using classes from the main source set
   
   Convention plugins can use classes defined in the main source set of the plugins project.
   
   In this sample, `com.myorg.service-conventions` plugin uses a custom task class from `src/main/java` to configure service README checks:
   ====
   include::sample[dir="kotlin",files="convention-plugins/src/main/kotlin/com.myorg.service-conventions.gradle.kts[tags=use-java-class]"]
   include::sample[dir="groovy",files="convention-plugins/src/main/groovy/com.myorg.service-conventions.gradle[tags=use-java-class]"]
   ====
   
   For more details on authoring custom Gradle plugins, consult the link:{userManualPath}#custom_plugins[user manual].

samples/build-organization/publishing-convention-plugins/groovy/convention-plugins/build.gradle

.. code-block::

   // tag::apply[]
   // tag::publish[]
   plugins {
       id 'groovy-gradle-plugin'
   // end::apply[]
       id 'maven-publish'
   // tag::apply[]
   }
   // end::apply[]
   
   group = 'com.myorg.conventions'
   version = '1.0'
   
   publishing {
       repositories {
           maven {
               // change to point to your repo, e.g. http://my.org/repo
               url = layout.buildDirectory.dir("repo")
           }
       }
   }
   
   tasks.named('publish') {
       dependsOn('check')
   }
   
   // end::publish[]
   
   // tag::repositories-and-dependencies[]
   repositories {
       gradlePluginPortal() // so that external plugins can be resolved in dependencies section
   }
   
   dependencies {
       implementation 'com.github.spotbugs.snom:spotbugs-gradle-plugin:5.2.1'
       testImplementation platform("org.spockframework:spock-bom:2.2-groovy-3.0")
       testImplementation 'org.spockframework:spock-core'
       testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
   }
   
   tasks.named('test', Test) {
       useJUnitPlatform()
   }
   
   // end::repositories-and-dependencies[]

samples/build-organization/publishing-convention-plugins/groovy/convention-plugins/settings.gradle

.. code-block::

   rootProject.name = 'my-org-conventions'

samples/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/main/groovy/com.myorg.java-conventions.gradle

.. code-block::

   // Define Java conventions for this organization.
   // Projects need to use the Java, Checkstyle and Spotbugs plugins.
   
   // tag::apply-external-plugin[]
   plugins {
       id 'java'
       id 'checkstyle'
   
       // NOTE: external plugin version is specified in implementation dependency artifact of the project's build file
       id 'com.github.spotbugs'
   }
   // end::apply-external-plugin[]
   
   // Projects should use Maven Central for external dependencies
   // This could be the organization's private repository
   repositories {
       mavenCentral()
   }
   
   // Use the Checkstyle rules provided by the convention plugin
   // Do not allow any warnings
   checkstyle {
       config = resources.text.fromString(com.example.CheckstyleUtil.getCheckstyleConfig("/checkstyle.xml"))
       maxWarnings = 0
   }
   
   // Enable deprecation messages when compiling Java code
   tasks.withType(JavaCompile).configureEach {
       options.compilerArgs << "-Xlint:deprecation"
   }

samples/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/main/groovy/com.myorg.library-conventions.gradle

.. code-block::

   // Define Java Library conventions for this organization.
   // Projects need to use the organization's Java conventions and publish using Maven Publish
   
   // tag::plugins[]
   plugins {
       id 'java-library'
       id 'maven-publish'
       id 'com.myorg.java-conventions'
   }
   // end::plugins[]
   
   // Projects have the 'com.myorg' group by convention
   group = 'com.myorg'
   
   publishing {
       publications {
           library(MavenPublication) {
               from components.java
           }
       }
       repositories {
           maven {
               name "myOrgPrivateRepo"
               url 'build/my-repo'
           }
       }
   }
   
   // The project requires libraries to have a README containing sections configured below
   // tag::use-java-class[]
   def readmeCheck = tasks.register('readmeCheck', com.example.ReadmeVerificationTask) {
       // Expect the README in the project directory
       readme = layout.projectDirectory.file("README.md")
       // README must contain a Service API header
       readmePatterns = ['^## API$', '^## Changelog$']
   }
   // end::use-java-class[]
   
   tasks.named('check') { dependsOn(readmeCheck) }

samples/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/main/groovy/com.myorg.service-conventions.gradle

.. code-block::

   // Define conventions for service projects this organization.
   // Service projects need to use the organization's Java conventions and pass some additional checks
   
   // tag::plugins[]
   plugins {
       id 'com.myorg.java-conventions'
   }
   // end::plugins[]
   
   def integrationTest = sourceSets.create('integrationTest')
   
   configurations[integrationTest.implementationConfigurationName].extendsFrom(configurations.testImplementation)
   configurations[integrationTest.runtimeOnlyConfigurationName].extendsFrom(configurations.testRuntimeOnly)
   
   def integrationTestTask = tasks.register('integrationTest', Test) {
       testClassesDirs = integrationTest.output.classesDirs
       classpath = integrationTest.runtimeClasspath
   
       shouldRunAfter(tasks.named('test'))
   }
   
   dependencies {
       integrationTestImplementation project
   }
   
   // The organization requires additional documentation in the README for this project
   // tag::use-java-class[]
   def readmeCheck = tasks.register('readmeCheck', com.example.ReadmeVerificationTask) {
       // Expect the README in the project directory
       readme = layout.projectDirectory.file("README.md")
       // README must contain a Service API header
       readmePatterns = ['^## Service API$']
   }
   // end::use-java-class[]
   
   tasks.named('check') { dependsOn(integrationTestTask, readmeCheck) }
   

samples/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/test/groovy/com/myorg/JavaConventionPluginTest.groovy

.. code-block::

   package com.myorg
   
   import org.gradle.testkit.runner.TaskOutcome
   
   class JavaConventionPluginTest extends PluginTest {
   
       def setup() {
           buildFile << """
               plugins {
                   id 'com.myorg.java-conventions'
               }
           """
       }
   
       def "fails on checkstyle error"() {
           given:
           new File(testProjectDir, 'src/main/java/com/myorg').mkdirs()
           new File(testProjectDir, 'src/main/java/com/myorg/Foo.java') << """
               package com.myorg;
   
               import java.util.*;
   
               class Foo {
                   void bar() {
                   }
               }
           """
   
           when:
           def result = runTaskWithFailure('build')
   
           then:
           result.task(":checkstyleMain").outcome == TaskOutcome.FAILED
           result.output.contains('Checkstyle rule violations were found.')
           result.output.contains('Checkstyle violations by severity: [error:1]')
       }
   
       def "fails on checkstyle warning"() {
           given:
           new File(testProjectDir, 'src/main/java/com/myorg').mkdirs()
           new File(testProjectDir, 'src/main/java/com/myorg/Foo.java') << """
               package com.myorg;
   
               class Foo {
                   final static public String FOO = "BAR";
   
                   void bar() {
                   }
               }
           """
   
           when:
           def result = runTaskWithFailure('build')
   
           then:
           result.task(":checkstyleMain").outcome == TaskOutcome.FAILED
           result.output.contains('Checkstyle rule violations were found.')
           result.output.contains('Checkstyle violations by severity: [warning:1]')
       }
   
       def "fails on spotbugs error"() {
           given:
           new File(testProjectDir, 'src/main/java/com/myorg').mkdirs()
           new File(testProjectDir, 'src/main/java/com/myorg/Foo.java') << """
               package com.myorg;
   
               class Foo {
                   void bar() {
                       String s = null;
                       s.hashCode();
                   }
               }
           """
   
           when:
           def result = runTaskWithFailure('build')
   
           then:
           result.task(":spotbugsMain").outcome == TaskOutcome.FAILED
       }
   
       def "warns on deprecated API usage"() {
           given:
           new File(testProjectDir, 'src/main/java/com/myorg').mkdirs()
           new File(testProjectDir, 'src/main/java/com/myorg/Foo.java') << """
               package com.myorg;
   
               public class Foo {
                   @Deprecated
                   public void deprecatedMethod() {}
               }
           """
   
           new File(testProjectDir, 'src/main/java/com/myorg/Bar.java') << """
               package com.myorg;
   
               public class Bar {
                   public void bar() {
                       new Foo().deprecatedMethod();
                   }
               }
           """
   
           when:
           def result = runTask('build')
   
           then:
           result.task(":build").outcome == TaskOutcome.SUCCESS
           result.output.contains('warning: [deprecation] deprecatedMethod()')
       }
   }

samples/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/test/groovy/com/myorg/LibraryPluginTest.groovy

.. code-block::

   package com.myorg
   
   import org.gradle.testkit.runner.TaskOutcome
   
   class LibraryPluginTest extends PluginTest {
   
       def setup() {
           buildFile << """
               plugins {
                   id 'com.myorg.library-conventions'
               }
           """
       }
   
       def "can declare api dependencies"() {
           given:
           readmeContainingMandatorySectionsExists()
           buildFile << """
               dependencies {
                   api 'org.apache.commons:commons-lang3:3.4'
               }
           """
   
           when:
           def result = runTask('build')
   
           then:
           result.task(":build").outcome == TaskOutcome.SUCCESS
       }
   
       def "publishes library with versionin"() {
           given:
           readmeContainingMandatorySectionsExists()
           settingsFile.setText("rootProject.name = 'my-library'")
           buildFile << """
               version = '0.1.0'
   
               publishing {
                   repositories {
                       maven {
                           name 'testRepo'
                           url 'build/test-repo'
                       }
                   }
               }
           """
   
           new File(testProjectDir, 'src/main/java/com/myorg').mkdirs()
           new File(testProjectDir, 'src/main/java/com/myorg/Util.java') << """
               package com.myorg;
   
               public class Util {
                   public static void someUtil() {
                   }
               }
           """
   
           when:
           def result = runTask('publishLibraryPublicationToTestRepoRepository')
   
           then:
           result.task(":jar").outcome == TaskOutcome.SUCCESS
           result.task(":publishLibraryPublicationToTestRepoRepository").outcome == TaskOutcome.SUCCESS
           new File(testProjectDir, 'build/test-repo/com/myorg/my-library/0.1.0/my-library-0.1.0.jar').exists()
       }
   
       def "fails when no README exists"() {
           when:
           def result = runTaskWithFailure('check')
   
           then:
           result.task(":readmeCheck").outcome == TaskOutcome.FAILED
       }
   
       def "fails when README does not have API section"() {
           given:
           new File(testProjectDir, 'README.md') << """
   ## Changelog
   - change 1
   - change 2
           """
   
           when:
           def result = runTaskWithFailure('check')
   
           then:
           result.task(":readmeCheck").outcome == TaskOutcome.FAILED
           result.output.contains('README should contain section: ^## API$')
       }
   
       def "fails when README does not have Changelog section"() {
           given:
           new File(testProjectDir, 'README.md') << """
   ## API
   public API description
           """
   
           when:
           def result = runTaskWithFailure('check')
   
           then:
           result.task(":readmeCheck").outcome == TaskOutcome.FAILED
           result.output.contains('README should contain section: ^## Changelog')
       }
   
       private def readmeContainingMandatorySectionsExists() {
           new File(testProjectDir, 'README.md') << """
   ## API
   public API description
   
   ## Changelog
   - change 1
   - change 2
           """
       }
   }

samples/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/test/groovy/com/myorg/PluginTest.groovy

.. code-block::

   package com.myorg
   
   import org.gradle.testkit.runner.GradleRunner
   import spock.lang.Specification
   import spock.lang.TempDir
   
   abstract class PluginTest extends Specification {
       @TempDir
       File testProjectDir
       File settingsFile
       File buildFile
   
       def setup() {
           settingsFile = new File(testProjectDir, 'settings.gradle').tap { it << "rootProject.name = 'test'" }
           buildFile = new File(testProjectDir, 'build.gradle')
       }
   
       def runTask(String task) {
           return GradleRunner.create()
                   .withProjectDir(testProjectDir)
                   .withArguments(task, '--stacktrace')
                   .withPluginClasspath()
                   .build()
       }
   
       def runTaskWithFailure(String task) {
           return GradleRunner.create()
                   .withProjectDir(testProjectDir)
                   .withArguments(task, '--stacktrace')
                   .withPluginClasspath()
                   .buildAndFail()
       }
   }

samples/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/test/groovy/com/myorg/ServicePluginTest.groovy

.. code-block::

   package com.myorg
   
   
   import org.gradle.testkit.runner.TaskOutcome
   
   class ServicePluginTest extends PluginTest {
   
       def setup() {
           buildFile << """
               plugins {
                   id 'com.myorg.service-conventions'
               }
           """
       }
   
       def "integrationTest and readmeCheck tasks run with check task"() {
           given:
           new File(testProjectDir, 'README.md') << """
   ## Service API
   
           """
   
           when:
           def result = runTask('check')
   
           then:
           result.task(":test").outcome == TaskOutcome.NO_SOURCE
           result.task(":integrationTest").outcome == TaskOutcome.NO_SOURCE
           result.task(":readmeCheck").outcome == TaskOutcome.SUCCESS
       }
   
       def "can use integrationTest configuration to define dependencies"() {
           given:
           buildFile << """
               dependencies {
                   integrationTestImplementation 'junit:junit:4.13'
               }
           """
   
           new File(testProjectDir, 'src/integrationTest/java/com/myorg').mkdirs()
           new File(testProjectDir, 'src/integrationTest/java/com/myorg/SomeIntegrationTest.java') << """
               package com.myorg;
   
               import org.junit.Test;
   
               public class SomeIntegrationTest {
                   @Test
                   public void sampleTest() {
                   }
               }
           """
   
           when:
           def result = runTask('integrationTest')
   
           then:
           result.task(":integrationTest").outcome == TaskOutcome.SUCCESS
       }
   
       def "fails when no README exists"() {
           when:
           def result = runTaskWithFailure('check')
   
           then:
           result.task(":readmeCheck").outcome == TaskOutcome.FAILED
       }
   
       def "fails when README does not have service API section"() {
           given:
           new File(testProjectDir, 'README.md') << """
   asdfadfsasf
           """
   
           when:
           def result = runTaskWithFailure('check')
   
           then:
           result.task(":readmeCheck").outcome == TaskOutcome.FAILED
           result.output.contains('README should contain section: ^## Service API$')
       }
   }

samples/build-organization/publishing-convention-plugins/groovy/settings.gradle

.. code-block::

   rootProject.name = 'convention-plugins'
   
   include 'convention-plugins'

samples/build-organization/publishing-convention-plugins/kotlin/convention-plugins/build.gradle.kts

.. code-block::

   // tag::apply[]
   // tag::publish[]
   plugins {
       `kotlin-dsl`
   // end::apply[]
       `maven-publish`
   // tag::apply[]
   }
   // end::apply[]
   
   group = "com.myorg.conventions"
   version = "1.0"
   
   publishing {
       repositories {
           maven {
               // change to point to your repo, e.g. http://my.org/repo
               url = uri(layout.buildDirectory.dir("repo"))
           }
       }
   }
   
   tasks.publish {
       dependsOn("check")
   }
   // end::publish[]
   
   // tag::repositories-and-dependencies[]
   repositories {
       gradlePluginPortal() // so that external plugins can be resolved in dependencies section
   }
   
   dependencies {
       implementation("com.github.spotbugs.snom:spotbugs-gradle-plugin:5.2.1")
       testImplementation("junit:junit:4.13")
   }
   // end::repositories-and-dependencies[]

samples/build-organization/publishing-convention-plugins/kotlin/convention-plugins/settings.gradle.kts

.. code-block::

   rootProject.name="my-org-conventions"

samples/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/main/kotlin/com.myorg.java-conventions.gradle.kts

.. code-block::

   // Define Java conventions for this organization.
   // Projects need to use the Java, Checkstyle and Spotbugs plugins.
   
   // tag::apply-external-plugin[]
   plugins {
       java
       checkstyle
   
       // NOTE: external plugin version is specified in implementation dependency artifact of the project's build file
       id("com.github.spotbugs")
   }
   // end::apply-external-plugin[]
   
   // Projects should use Maven Central for external dependencies
   // This could be the organization's private repository
   repositories {
       mavenCentral()
   }
   
   // Use the Checkstyle rules provided by the convention plugin
   // Do not allow any warnings
   checkstyle {
       config = resources.text.fromString(com.example.CheckstyleUtil.getCheckstyleConfig("/checkstyle.xml"))
       maxWarnings = 0
   }
   
   // Enable deprecation messages when compiling Java code
   tasks.withType<JavaCompile>().configureEach {
       options.compilerArgs.add("-Xlint:deprecation")
   }

samples/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/main/kotlin/com.myorg.library-conventions.gradle.kts

.. code-block::

   // Define Java Library conventions for this organization.
   // Projects need to use the organization's Java conventions and publish using Maven Publish
   
   // tag::plugins[]
   plugins {
       `java-library`
       `maven-publish`
       id("com.myorg.java-conventions")
   }
   // end::plugins[]
   
   // Projects have the 'com.myorg' group by convention
   group = "com.myorg"
   
   publishing {
       publications {
           create<MavenPublication>("library") {
               from(components["java"])
           }
       }
       repositories {
           maven {
               name = "myOrgPrivateRepo"
               url = uri("build/my-repo")
           }
       }
   }
   
   // The project requires libraries to have a README containing sections configured below
   // tag::use-java-class[]
   val readmeCheck by tasks.registering(com.example.ReadmeVerificationTask::class) {
       readme = layout.projectDirectory.file("README.md")
       readmePatterns = listOf("^## API$", "^## Changelog$")
   }
   // end::use-java-class[]
   
   tasks.named("check") { dependsOn(readmeCheck) }

samples/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/main/kotlin/com.myorg.service-conventions.gradle.kts

.. code-block::

   // Define conventions for service projects this organization.
   // Service projects need to use the organization's Java conventions and pass some additional checks
   
   // tag::plugins[]
   plugins {
       id("com.myorg.java-conventions")
   }
   // end::plugins[]
   
   val integrationTest by sourceSets.creating
   
   configurations[integrationTest.implementationConfigurationName].extendsFrom(configurations.testImplementation.get())
   configurations[integrationTest.runtimeOnlyConfigurationName].extendsFrom(configurations.testRuntimeOnly.get())
   
   val integrationTestTask = tasks.register<Test>("integrationTest") {
       testClassesDirs = integrationTest.output.classesDirs
       classpath = integrationTest.runtimeClasspath
   
       shouldRunAfter(tasks.test)
   }
   
   dependencies {
       "integrationTestImplementation"(project)
   }
   
   // The organization requires additional documentation in the README for this project
   // tag::use-java-class[]
   val readmeCheck by tasks.registering(com.example.ReadmeVerificationTask::class) {
       readme = layout.projectDirectory.file("README.md")
       readmePatterns = listOf("^## Service API$")
   }
   // end::use-java-class[]
   
   tasks.check { dependsOn(integrationTestTask, readmeCheck) }

samples/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/test/kotlin/com/myorg/JavaConventionPluginTest.kt

.. code-block::

   package com.myorg
   
   import org.gradle.testkit.runner.TaskOutcome
   import org.junit.Assert.assertEquals
   import org.junit.Assert.assertTrue
   import org.junit.Before
   import org.junit.Test
   
   class JavaConventionPluginTest : PluginTest() {
   
       @Before
       fun init() {
           buildFile.appendText("""
               plugins {
                   id("com.myorg.java-conventions")
               }
           """)
       }
   
       @Test
       fun `fails on checkstyle error`() {
           testProjectDir.newFolder("src", "main", "java", "com", "myorg")
           testProjectDir.newFile("src/main/java/com/myorg/Foo.java").appendText("""
               package com.myorg;
   
               import java.util.*;
   
               class Foo {
                   void bar() {
                   }
               }
           """)
   
           val result = runTaskWithFailure("build")
   
           assertEquals(TaskOutcome.FAILED, result.task(":checkstyleMain")?.outcome)
           assertTrue(result.output.contains("Checkstyle rule violations were found."))
           assertTrue(result.output.contains("Checkstyle violations by severity: [error:1]"))
       }
   
       @Test
       fun `fails on checkstyle warning`() {
           testProjectDir.newFolder("src", "main", "java", "com", "myorg")
           testProjectDir.newFile("src/main/java/com/myorg/Foo.java").writeText("""
               package com.myorg;
   
               class Foo {
                   final static public String FOO = "BAR";
   
                   void bar() {
                   }
               }
           """)
   
           val result = runTaskWithFailure("build")
   
           assertEquals(TaskOutcome.FAILED, result.task(":checkstyleMain")?.outcome)
           assertTrue(result.output.contains("Checkstyle rule violations were found."))
           assertTrue(result.output.contains("Checkstyle violations by severity: [warning:1]"))
       }
   
       @Test
       fun `fails on spotbugs error`() {
           testProjectDir.newFolder("src", "main", "java", "com", "myorg")
           testProjectDir.newFile("src/main/java/com/myorg/Foo.java").writeText("""
               package com.myorg;
   
               class Foo {
                   void bar() {
                       String s = null;
                       s.hashCode();
                   }
               }
           """)
   
           val result = runTaskWithFailure("build")
   
           assertEquals(TaskOutcome.FAILED, result.task(":spotbugsMain")?.outcome)
       }
   
       @Test
       fun `warns on deprecated API usage`() {
           testProjectDir.newFolder("src", "main", "java", "com", "myorg")
           testProjectDir.newFile("src/main/java/com/myorg/Foo.java").writeText("""
               package com.myorg;
   
               public class Foo {
                   @Deprecated
                   public void deprecatedMethod() {}
               }
           """)
   
           testProjectDir.newFile("src/main/java/com/myorg/Bar.java").writeText("""
               package com.myorg;
   
               public class Bar {
                   public void bar() {
                       new Foo().deprecatedMethod();
                   }
               }
           """)
   
           val result = runTask("build")
   
           assertEquals(TaskOutcome.SUCCESS, result.task(":build")?.outcome)
           assertTrue(result.output.contains("warning: [deprecation] deprecatedMethod()"))
       }
   }

samples/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/test/kotlin/com/myorg/LibraryPluginTest.kt

.. code-block::

   package com.myorg
   
   import org.gradle.testkit.runner.TaskOutcome
   import org.junit.Assert.assertEquals
   import org.junit.Assert.assertTrue
   import org.junit.Before
   import org.junit.Test
   import java.io.File
   
   class LibraryPluginTest : PluginTest() {
   
       @Before
       fun init() {
           buildFile.appendText("""
               plugins {
                   id("com.myorg.library-conventions")
               }
           """)
       }
   
       @Test
       fun `can declare api dependencies`() {
           readmeContainingMandatorySectionsExists()
           buildFile.appendText("""
               dependencies {
                   api("org.apache.commons:commons-lang3:3.4")
               }
           """)
   
           val result = runTask("build")
   
           assertEquals(TaskOutcome.SUCCESS, result.task(":build")?.outcome)
       }
   
       @Test
       fun `publishes library with versionin`() {
           readmeContainingMandatorySectionsExists()
           settingsFile.writeText("""
               rootProject.name = "my-library"
           """.trimIndent())
           buildFile.appendText("""
               version = "0.1.0"
   
               publishing {
                   repositories {
                       maven {
                           name = "testRepo"
                           url = uri("build/test-repo")
                       }
                   }
               }
           """)
   
           testProjectDir.newFolder("src", "main", "java", "com", "myorg")
           testProjectDir.newFile("src/main/java/com/myorg/Util.java").writeText("""
               package com.myorg;
   
               public class Util {
                   public static void someUtil() {
                   }
               }
           """)
   
           val result = runTask("publishLibraryPublicationToTestRepoRepository")
   
           assertEquals(TaskOutcome.SUCCESS, result.task(":jar")?.outcome)
           assertEquals(TaskOutcome.SUCCESS, result.task(":publishLibraryPublicationToTestRepoRepository")?.outcome)
           assertTrue(File(testProjectDir.getRoot(), "build/test-repo/com/myorg/my-library/0.1.0/my-library-0.1.0.jar").exists())
       }
   
       @Test
       fun `fails when no README exists`() {
           val result = runTaskWithFailure ("check")
   
           assertEquals(TaskOutcome.FAILED, result.task(":readmeCheck")?.outcome)
       }
   
       @Test
       fun `fails when README does not have API section`() {
           testProjectDir.newFile("README.md").writeText("""
               ## Changelog
               - change 1
               - change 2
           """.trimIndent())
   
           val result = runTaskWithFailure ("check")
   
           assertEquals(TaskOutcome.FAILED, result.task(":readmeCheck")?.outcome)
           assertTrue(result.output.contains("README should contain section: ^## API$"))
       }
   
       @Test
       fun `fails when README does not have Changelog section`() {
           testProjectDir.newFile("README.md").writeText("""
               ## API
               public API description
           """.trimIndent())
   
           val result = runTaskWithFailure ("check")
   
           assertEquals(TaskOutcome.FAILED, result.task(":readmeCheck")?.outcome)
           assertTrue(result.output.contains("README should contain section: ^## Changelog$"))
       }
   
       private fun readmeContainingMandatorySectionsExists() {
           testProjectDir.newFile("README.md").writeText("""
               ## API
               public API description
   
               ## Changelog
               - change 1
               - change 2
           """.trimIndent())
       }
   }

samples/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/test/kotlin/com/myorg/PluginTest.kt

.. code-block::

   package com.myorg
   
   import org.gradle.testkit.runner.BuildResult
   import org.gradle.testkit.runner.GradleRunner
   import org.junit.Before
   import org.junit.Rule
   import org.junit.rules.TemporaryFolder
   import java.io.File
   
   abstract class PluginTest {
   
       @Rule
       @JvmField
       val testProjectDir: TemporaryFolder = TemporaryFolder()
       protected lateinit var settingsFile: File
       protected lateinit var buildFile: File
   
       @Before
       fun setup() {
           settingsFile = testProjectDir.newFile("settings.gradle.kts")
           settingsFile.appendText("""
               rootProject.name = "test"
           """)
           buildFile = testProjectDir.newFile("build.gradle.kts")
       }
   
       fun runTask(task: String): BuildResult {
           return GradleRunner.create()
                   .withProjectDir(testProjectDir.root)
                   .withArguments(task, "--stacktrace")
                   .withPluginClasspath()
                   .build()
       }
   
       fun runTaskWithFailure(task: String): BuildResult {
           return GradleRunner.create()
                   .withProjectDir(testProjectDir.root)
                   .withArguments(task, "--stacktrace")
                   .withPluginClasspath()
                   .buildAndFail()
       }
   }

samples/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/test/kotlin/com/myorg/ServicePluginTest.kt

.. code-block::

   package com.myorg
   
   
   import org.gradle.testkit.runner.TaskOutcome
   import org.junit.Assert.assertEquals
   import org.junit.Assert.assertTrue
   import org.junit.Before
   import org.junit.Test
   
   class ServicePluginTest : PluginTest() {
   
       @Before
       fun init() {
           buildFile.appendText("""
               plugins {
                   id("com.myorg.service-conventions")
               }
           """)
       }
   
       @Test
       fun `integrationTest and readmeCheck tasks run with check task`() {
           testProjectDir.newFile("README.md").writeText("""
               ## Service API
   
           """.trimIndent())
   
           val result = runTask("check")
   
           assertEquals(TaskOutcome.NO_SOURCE, result.task(":test")?.outcome)
           assertEquals(TaskOutcome.NO_SOURCE, result.task(":integrationTest")?.outcome)
           assertEquals(TaskOutcome.SUCCESS, result.task(":readmeCheck")?.outcome)
       }
   
       @Test
       fun `can use integrationTest configuration to define dependencies`() {
           buildFile.appendText("""
               dependencies {
                   integrationTestImplementation("junit:junit:4.13")
               }
           """)
   
           testProjectDir.newFolder("src", "integrationTest", "java", "com", "myorg")
           testProjectDir.newFile("src/integrationTest/java/com/myorg/SomeIntegrationTest.java").writeText("""
               package com.myorg;
   
               import org.junit.Test;
   
               public class SomeIntegrationTest {
                   @Test
                   public void sampleTest() {
                   }
               }
           """)
   
           val result = runTask ("integrationTest")
   
           assertEquals(TaskOutcome.SUCCESS, result.task(":integrationTest")?.outcome)
       }
   
       @Test
       fun `fails when no README exists`() {
           val result = runTaskWithFailure ("check")
   
           assertEquals(TaskOutcome.FAILED, result.task(":readmeCheck")?.outcome)
       }
   
       @Test
       fun `fails when README does not have service API section`() {
           testProjectDir.newFile("README.md").writeText("""
               asdfadfsasf
           """.trimIndent())
   
           val result = runTaskWithFailure ("check")
   
           assertEquals(TaskOutcome.FAILED, result.task(":readmeCheck")?.outcome)
           assertTrue(result.output.contains("README should contain section: ^## Service API$"))
       }
   }

samples/build-organization/publishing-convention-plugins/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "convention-plugins"
   
   include("convention-plugins")

samples/build-organization/publishing-convention-plugins/tests/publish.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: publish
   }]

/Sample: 游릭 build-organization/sharing-convention-plugins-with-build-logic
=======================================================================

samples/build-organization/sharing-convention-plugins-with-build-logic/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how _convention plugins_ can be shared and applied to both the production code and the build logic code in _buildSrc_.
   
   Let's use the following project structure:
   ====
   [.multi-language-sample]
   =====
   .Project structure
   [source, kotlin]
   ----
   較럭較 application
   較   較럭較 src
   較   較   較덕較 main
   較   較덕較 build.gradle.kts
   較럭較 build-conventions
   較   較럭較 src
   較   較   ...
   較   較럭較 build.gradle.kts
   較   較덕較 settings.gradle.kts
   較럭較 buildSrc
   較   較럭較 src
   較   較   ...
   較   較덕較 build.gradle.kts
   較럭較 list
   較   較럭較 src
   較   較   ...
   較   較덕較 build.gradle.kts
   較럭較 utilities
   較   較럭較 src
   較   較   ...
   較   較덕較 build.gradle.kts
   較덕較 settings.gradle.kts
   ----
   =====
   [.multi-language-sample]
   =====
   .Project structure
   [source, groovy]
   ----
   較럭較 application
   較   較럭較 src
   較   較   較덕較 main
   較   較덕較 build.gradle
   較럭較 build-conventions
   較   較럭較 src
   較   較   ...
   較   較럭較 build.gradle
   較   較덕較 settings.gradle
   較럭較 buildSrc
   較   較럭較 src
   較   較   ...
   較   較덕較 build.gradle
   較럭較 list
   較   較럭較 src
   較   較   ...
   較   較덕較 build.gradle
   較럭較 utilities
   較   較럭較 src
   較   較   ...
   較   較덕較 build.gradle
   較덕較 settings.gradle
   ----
   =====
   ====
   
   The build is configured as follows:
   ====
   include::sample[dir="kotlin",files="settings.gradle.kts[]"]
   include::sample[dir="groovy",files="settings.gradle[]"]
   ====
   
   The shared _convention plugin_ `myproject.java-conventions` is implemented in an _included build_ called `build-conventions`.
   The build is then included in the root project's _settings_ file as seen in the above snippet.
   For more details about included builds, see link:{userManualPath}#composite_builds[Composing Builds] chapter.
   
   The `myproject.java-conventions` plugin is then applied to the `buildSrc` build:
   ====
   include::sample[dir="kotlin",files="buildSrc/build.gradle.kts[tags=plugins]"]
   include::sample[dir="groovy",files="buildSrc/build.gradle[tags=plugins]"]
   ====
   
   It is also applied in the subprojects of the root project:
   ====
   include::sample[dir="kotlin",files="application/build.gradle.kts[tags=plugins];utilities/build.gradle.kts[tags=plugins];list/build.gradle.kts[tags=plugins]"]
   include::sample[dir="groovy",files="application/build.gradle[tags=plugins];utilities/build.gradle[tags=plugins];list/build.gradle[tags=plugins]"]
   ====
   
   For more details on authoring custom Gradle plugins, consult the link:{userManualPath}#custom_plugins[user manual].

samples/build-organization/sharing-convention-plugins-with-build-logic/groovy/application/build.gradle

.. code-block::

   // tag::plugins[]
   plugins {
       id 'myproject.java-conventions'
       // myproject.greeting is implemented in the buildSrc project that has myproject.java-conventions applied as well
       id 'myproject.greeting'
       id 'application'
   }
   // end::plugins[]
   
   dependencies {
       implementation project(':utilities')
   }
   
   application {
       mainClass = 'org.gradle.sample.app.Main'
   }

samples/build-organization/sharing-convention-plugins-with-build-logic/groovy/build-conventions/build.gradle

.. code-block::

   plugins {
       id 'groovy-gradle-plugin'
   }

samples/build-organization/sharing-convention-plugins-with-build-logic/groovy/build-conventions/settings.gradle

.. code-block::

   rootProject.name = 'build-conventions'

samples/build-organization/sharing-convention-plugins-with-build-logic/groovy/build-conventions/src/main/groovy/myproject.java-conventions.gradle

.. code-block::

   plugins {
       id 'java'
   }
   
   repositories {
       mavenCentral()
   }
   
   tasks.withType(JavaCompile).configureEach {
       options.compilerArgs << "-Xlint:deprecation"
   }

samples/build-organization/sharing-convention-plugins-with-build-logic/groovy/buildSrc/build.gradle

.. code-block::

   // tag::plugins[]
   plugins {
       id 'myproject.java-conventions'
       id 'groovy-gradle-plugin'
   }
   // end::plugins[]

samples/build-organization/sharing-convention-plugins-with-build-logic/groovy/buildSrc/src/main/groovy/myproject.greeting.gradle

.. code-block::

   tasks.register("greet", com.example.GreetingTask) {
       greeting = "Hello from 'myproject.greeting' plugin"
   }

samples/build-organization/sharing-convention-plugins-with-build-logic/groovy/buildSrc/src/main/java/com/example/GreetingTask.java

.. code-block::

   package com.example;
   
   import org.gradle.api.DefaultTask;
   import org.gradle.api.tasks.TaskAction;
   import org.gradle.api.tasks.Input;
   import org.gradle.api.provider.Property;
   
   public abstract class GreetingTask extends DefaultTask {
   
       @Input
       public abstract Property<String> getGreeting();
   
       @TaskAction
       public void greet() {
           System.out.println(getGreeting().get());
       }
   }

samples/build-organization/sharing-convention-plugins-with-build-logic/groovy/list/build.gradle

.. code-block::

   // tag::plugins[]
   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }
   // end::plugins[]

samples/build-organization/sharing-convention-plugins-with-build-logic/groovy/settings.gradle

.. code-block::

   rootProject.name = 'sample'
   includeBuild 'build-conventions'
   include 'application', 'utilities', 'list'

samples/build-organization/sharing-convention-plugins-with-build-logic/groovy/utilities/build.gradle

.. code-block::

   // tag::plugins[]
   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }
   // end::plugins[]
   
   dependencies {
       api project(':list')
   }

samples/build-organization/sharing-convention-plugins-with-build-logic/kotlin/application/build.gradle.kts

.. code-block::

   // tag::plugins[]
   plugins {
       id("myproject.java-conventions")
       // myproject.greeting is implemented in the buildSrc project that has myproject.java-conventions applied as well
       id("myproject.greeting")
       id("application")
   }
   // end::plugins[]
   
   dependencies {
       implementation(project(":utilities"))
   }
   
   application {
       mainClass = "org.gradle.sample.app.Main"
   }

samples/build-organization/sharing-convention-plugins-with-build-logic/kotlin/build-conventions/build.gradle.kts

.. code-block::

   plugins {
       `kotlin-dsl`
   }
   
   repositories {
       gradlePluginPortal()
   }

samples/build-organization/sharing-convention-plugins-with-build-logic/kotlin/build-conventions/settings.gradle.kts

.. code-block::

   rootProject.name = "build-conventions"

samples/build-organization/sharing-convention-plugins-with-build-logic/kotlin/build-conventions/src/main/kotlin/myproject.java-conventions.gradle.kts

.. code-block::

   plugins {
       id("java")
   }
   
   repositories {
       mavenCentral()
   }
   
   tasks.withType<JavaCompile>().configureEach {
       options.compilerArgs.add("-Xlint:deprecation")
   }

samples/build-organization/sharing-convention-plugins-with-build-logic/kotlin/buildSrc/build.gradle.kts

.. code-block::

   // tag::plugins[]
   plugins {
       id("myproject.java-conventions")
       `kotlin-dsl`
   }
   
   repositories {
       // for kotlin-dsl plugin
       gradlePluginPortal()
   }
   // end::plugins[]

samples/build-organization/sharing-convention-plugins-with-build-logic/kotlin/buildSrc/src/main/java/com/example/GreetingTask.java

.. code-block::

   package com.example;
   
   import org.gradle.api.DefaultTask;
   import org.gradle.api.tasks.TaskAction;
   import org.gradle.api.tasks.Input;
   import org.gradle.api.provider.Property;
   
   public abstract class GreetingTask extends DefaultTask {
   
       @Input
       public abstract Property<String> getGreeting();
   
       @TaskAction
       public void greet() {
           System.out.println(getGreeting().get());
       }
   }

samples/build-organization/sharing-convention-plugins-with-build-logic/kotlin/buildSrc/src/main/kotlin/myproject.greeting.gradle.kts

.. code-block::

   tasks.register<com.example.GreetingTask>("greet") {
       greeting = "Hello from 'myproject.greeting' plugin"
   }

samples/build-organization/sharing-convention-plugins-with-build-logic/kotlin/list/build.gradle.kts

.. code-block::

   // tag::plugins[]
   plugins {
       id("myproject.java-conventions")
       id("java-library")
   }
   // end::plugins[]

samples/build-organization/sharing-convention-plugins-with-build-logic/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "sample"
   includeBuild("build-conventions")
   include("application", "utilities", "list")

samples/build-organization/sharing-convention-plugins-with-build-logic/kotlin/utilities/build.gradle.kts

.. code-block::

   // tag::plugins[]
   plugins {
       id("myproject.java-conventions")
       id("java-library")
   }
   // end::plugins[]
   
   dependencies {
       api(project(":list"))
   }

samples/build-organization/sharing-convention-plugins-with-build-logic/tests/check.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: check
   }, {
       executable: gradle
       args: greet -q
       expected-output-file: greet.out
   }, {
       executable: gradle
       args: run -q
       expected-output-file: run.out
   }]

samples/build-organization/sharing-convention-plugins-with-build-logic/tests/greet.out

.. code-block::

   Hello from 'myproject.greeting' plugin

samples/build-organization/sharing-convention-plugins-with-build-logic/tests/run.out

.. code-block::

   Hello, World!

samples/build-organization/sharing-convention-plugins-with-build-logic/tests/sanityCheck.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: tasks -q
   },{
       execution-subdirectory: build-conventions
       executable: gradle
       args: tasks -q
   }]

/Sample: 游릭 build-organization/structuring-software-projects
=========================================================

samples/build-organization/structuring-software-projects/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ's Gradle import] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how to structure a software product that consists of multiple components as a set of connected Gradle builds.
   As such, it shows how Gradle is used to model a project's architecture and reflect that in the physical structure of the files that make up the software.
   This example is described as part of the link:{userManualPath}#structuring_software_products[documentation on this topic].
   
   The product that is built in this sample is an application that displays link:https://gradle.org/releases/[Gradle Build Tool releases].
   
   There are different ways to work with the sample:
   
   - You may build or import the umbrella build in the root.
     There you can, for example, run the Spring Boot web application via `./gradlew :server-application:app:bootRun` or install the Android app using `./gradlew :android-app:app:installDebug`.
   - You may only build or import one of the application builds directly.
     For example, `cd server-application` and run the app using  `../gradlew :app:bootRun`.
   - You may only build or import a selected component (and its dependencies).
     For example, only import the `user-feature` build in the IDE.
   
   // TODO:Finalize Upload Removal - Issue #21439

samples/build-organization/structuring-software-projects/groovy/build.gradle

.. code-block::

   // This is an example of a lifecycle task that crosses build boundaries defined in the umbrella build.
   tasks.register('checkFeatures') {
       group = 'verification'
       description = 'Run all feature tests'
       dependsOn(gradle.includedBuild('admin-feature').task(':config:check'))
       dependsOn(gradle.includedBuild('user-feature').task(':data:check'))
       dependsOn(gradle.includedBuild('user-feature').task(':table:check'))
   }

samples/build-organization/structuring-software-projects/groovy/settings.gradle

.. code-block::

   // This is an empty umbrella build including all the component builds.
   // This build is not necessarily needed. The component builds work independently.
   
   includeBuild('platforms')
   includeBuild('build-logic')
   
   includeBuild('aggregation')
   
   includeBuild('user-feature')
   includeBuild('admin-feature')
   
   includeBuild('server-application')
   includeBuild('android-app')

samples/build-organization/structuring-software-projects/groovy/admin-feature/config/build.gradle

.. code-block::

   plugins {
       id('com.example.kotlin-library')
   }
   
   group = "${group}.admin-feature"
   
   dependencies {
       implementation('com.example.myproduct.state:application-state')
   }

samples/build-organization/structuring-software-projects/groovy/admin-feature/settings.gradle

.. code-block::

   // == Define locations for build logic ==
   pluginManagement {
       repositories {
           gradlePluginPortal() // if pluginManagement.repositories looks like this, it can be omitted as this is the default
       }
       includeBuild('../build-logic')
   }
   
   // == Define locations for components ==
   dependencyResolutionManagement {
       repositories {
           mavenCentral()
       }
   }
   includeBuild('../platforms')
   includeBuild('../domain-model')
   includeBuild('../state')
   
   // == Define the inner structure of this component ==
   rootProject.name = 'admin-feature'
   include('config')

samples/build-organization/structuring-software-projects/groovy/aggregation/settings.gradle

.. code-block::

   // == Define locations for build logic ==
   pluginManagement {
       repositories {
           gradlePluginPortal() // if pluginManagement.repositories looks like this, it can be omitted as this is the default
       }
       includeBuild('../build-logic')
   }
   
   // == Define locations for components ==
   dependencyResolutionManagement {
       repositories {
           mavenCentral()
       }
   }
   includeBuild('../platforms')
   includeBuild('../admin-feature')
   includeBuild('../user-feature')
   
   
   // == Define the inner structure of this component ==
   rootProject.name = 'aggregation'
   include('test-coverage')
   

samples/build-organization/structuring-software-projects/groovy/aggregation/test-coverage/build.gradle

.. code-block::

   plugins {
       id('com.example.report-aggregation')
   }
   
   dependencies {
       // Transitively collect coverage data from all features and their dependencies
       aggregate('com.example.myproduct.user-feature:table')
       aggregate('com.example.myproduct.admin-feature:config')
   }

samples/build-organization/structuring-software-projects/groovy/android-app/app/build.gradle

.. code-block::

   plugins {
       id('com.example.android-application')
   }
   
   group = "${group}.android-app"
   
   dependencies {
       implementation('com.example.myproduct.user-feature:table')
   }

samples/build-organization/structuring-software-projects/groovy/android-app/settings.gradle

.. code-block::

   // == Define locations for build logic ==
   pluginManagement {
       repositories {
           gradlePluginPortal()
           google()
       }
       includeBuild('../build-logic')
   }
   
   // == Define locations for components ==
   dependencyResolutionManagement {
       repositories {
           mavenCentral()
           google()
       }
   }
   includeBuild('../platforms')
   includeBuild('../user-feature')
   
   // == Define the inner structure of this component ==
   rootProject.name = 'android-app'
   include('app')

samples/build-organization/structuring-software-projects/groovy/build-logic/settings.gradle

.. code-block::

   dependencyResolutionManagement {
       repositories {
           gradlePluginPortal()
           google()
       }
   }
   includeBuild('../platforms')
   
   rootProject.name = 'build-logic'
   include('commons')
   include('java-library')
   include('kotlin-library')
   include('android-application')
   include('spring-boot-application')
   include('report-aggregation')

samples/build-organization/structuring-software-projects/groovy/build-logic/android-application/build.gradle

.. code-block::

   plugins {
       id('groovy-gradle-plugin')
   }
   
   dependencies {
       implementation(platform('com.example.platform:plugins-platform'))
   
       implementation(project(':commons'))
   
       implementation('com.android.tools.build:gradle')
       implementation('org.jetbrains.kotlin.android:org.jetbrains.kotlin.android.gradle.plugin')
   }

samples/build-organization/structuring-software-projects/groovy/build-logic/android-application/src/main/groovy/com.example.android-application.gradle

.. code-block::

   plugins {
       id('com.android.application')
       id('org.jetbrains.kotlin.android')
   }
   
   group = 'com.example.myproduct'
   
   java {
       toolchain {
           languageVersion = JavaLanguageVersion.of(8)
       }
   }
   
   android {
       compileSdkVersion(28)
       defaultConfig {
           minSdkVersion(24)
           targetSdkVersion(28)
       }
       compileOptions {
           sourceCompatibility = JavaVersion.VERSION_1_8
           targetCompatibility = JavaVersion.VERSION_1_8
       }
   }
   
   dependencies {
       implementation(platform('com.example.platform:product-platform'))
       testImplementation(platform('com.example.platform:test-platform'))
   
       implementation('org.jetbrains.kotlin:kotlin-stdlib')
   }

samples/build-organization/structuring-software-projects/groovy/build-logic/commons/build.gradle

.. code-block::

   plugins {
       id('groovy-gradle-plugin')
   }

samples/build-organization/structuring-software-projects/groovy/build-logic/commons/src/main/groovy/com.example.commons.gradle

.. code-block::

   plugins {
       id('java')
       id('com.example.jacoco')
   }
   
   group = 'com.example.myproduct'
   
   java {
       toolchain {
           languageVersion = JavaLanguageVersion.of(8)
       }
   }
   
   dependencies {
       implementation(platform('com.example.platform:product-platform'))
   
       testImplementation(platform('com.example.platform:test-platform'))
       testImplementation('org.junit.jupiter:junit-jupiter')
       testRuntimeOnly('org.junit.platform:junit-platform-launcher')
   }
   
   tasks.named("test") {
       useJUnitPlatform()
   }

samples/build-organization/structuring-software-projects/groovy/build-logic/commons/src/main/groovy/com.example.jacoco.gradle

.. code-block::

   plugins {
       id('java')
       id('jacoco')
   }
   
   // Do not generate reports for individual projects
   tasks.jacocoTestReport.configure {
       enabled = false
   }
   
   // Share sources folder with other projects for aggregated JaCoCo reports
   configurations.create('transitiveSourcesElements') {
       visible = false
       canBeResolved = false
       extendsFrom(configurations.implementation)
       attributes {
           attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
           attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
           attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'source-folders'))
       }
       sourceSets.main.java.srcDirs.forEach { outgoing.artifact(it) }
   }
   
   // Share the coverage data to be aggregated for the whole product
   configurations.create('coverageDataElements') {
       visible = false
       canBeResolved = false
       extendsFrom(configurations.implementation)
       attributes {
           attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
           attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
           attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'jacoco-coverage-data'))
       }
       outgoing.artifact(tasks.named('test').map { task ->
           task.extensions.getByType(JacocoTaskExtension).destinationFile
       })
   }

samples/build-organization/structuring-software-projects/groovy/build-logic/java-library/build.gradle

.. code-block::

   plugins {
       id('groovy-gradle-plugin')
   }
   
   dependencies {
       implementation(platform('com.example.platform:plugins-platform'))
   
       implementation(project(':commons'))
   }

samples/build-organization/structuring-software-projects/groovy/build-logic/java-library/src/main/groovy/com.example.java-library.gradle

.. code-block::

   plugins {
       id('com.example.commons')
       id('java-library')
   }

samples/build-organization/structuring-software-projects/groovy/build-logic/kotlin-library/build.gradle

.. code-block::

   plugins {
       id('groovy-gradle-plugin')
   }
   
   dependencies {
       implementation(platform('com.example.platform:plugins-platform'))
   
       implementation(project(':commons'))
       implementation('org.jetbrains.kotlin.jvm:org.jetbrains.kotlin.jvm.gradle.plugin')
   }

samples/build-organization/structuring-software-projects/groovy/build-logic/kotlin-library/src/main/groovy/com.example.kotlin-library.gradle

.. code-block::

   plugins {
       id('com.example.commons')
       id('org.jetbrains.kotlin.jvm')
       id('java-library')
   }
   
   dependencies {
       implementation('org.jetbrains.kotlin:kotlin-stdlib')
   }

samples/build-organization/structuring-software-projects/groovy/build-logic/report-aggregation/build.gradle

.. code-block::

   plugins {
       id('groovy-gradle-plugin')
   }

samples/build-organization/structuring-software-projects/groovy/build-logic/report-aggregation/src/main/groovy/com.example.report-aggregation.gradle

.. code-block::

   plugins {
       id('java-base') // we only apply 'java-base' as this plugin is for projects without source code
       id('jacoco')
   }
   
   // Configurations to declare dependencies
   def aggregate = configurations.create('aggregate') {
       visible = false
       canBeResolved = false
       canBeConsumed = false
   }
   
   // Resolvable configuration to resolve the classes of all dependencies
   def classesPath = configurations.create('classesPath') {
       visible = false
       canBeConsumed = false
       extendsFrom(aggregate)
       attributes {
           attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
           attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.LIBRARY))
           attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, objects.named(LibraryElements, LibraryElements.CLASSES))
       }
   }
   
   // A resolvable configuration to collect source code
   def sourcesPath = configurations.create('sourcesPath') {
       visible = false
       canBeConsumed = false
       extendsFrom(aggregate)
       attributes {
           attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.VERIFICATION))
           attribute(VerificationType.VERIFICATION_TYPE_ATTRIBUTE, objects.named(VerificationType, VerificationType.MAIN_SOURCES))
       }
   }
   
   // A resolvable configuration to collect JaCoCo coverage data
   def coverageDataPath = configurations.create('coverageDataPath') {
       visible = false
       canBeConsumed = false
       extendsFrom(aggregate)
       attributes {
           attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.VERIFICATION))
           attribute(VerificationType.VERIFICATION_TYPE_ATTRIBUTE, objects.named(VerificationType, VerificationType.JACOCO_RESULTS))
       }
   }
   
   // Register a code coverage report task to generate the aggregated report
   def codeCoverageReport = tasks.register('codeCoverageReport', JacocoReport) {
       classDirectories.from(classesPath.getIncoming().getFiles())
       sourceDirectories.from(sourcesPath.getIncoming().artifactView { lenient(true) }.getFiles())
       executionData(coverageDataPath.getIncoming().artifactView { lenient(true) }.getFiles().filter { it.exists() })
   
       reports {
           html.required = true
           xml.required = true
       }
   }
   
   // Make JaCoCo report generation part of the 'check' lifecycle phase
   tasks.named('check') {
       dependsOn(codeCoverageReport)
   }

samples/build-organization/structuring-software-projects/groovy/build-logic/spring-boot-application/build.gradle

.. code-block::

   plugins {
       id('groovy-gradle-plugin') // <1>
   }
   
   dependencies {
       implementation(platform('com.example.platform:plugins-platform')) // <2>
   
       implementation(project(':commons')) // <3>
   
       implementation('org.springframework.boot:org.springframework.boot.gradle.plugin')  // <4>
   }

samples/build-organization/structuring-software-projects/groovy/build-logic/spring-boot-application/src/main/groovy/com.example.spring-boot-application.gradle

.. code-block::

   plugins {
       id('com.example.commons')
       id('org.springframework.boot')
   }
   
   dependencies {
       implementation('org.springframework.boot:spring-boot-starter-web')
       implementation('org.springframework.boot:spring-boot-starter-thymeleaf')
   }

samples/build-organization/structuring-software-projects/groovy/domain-model/release/build.gradle

.. code-block::

   // tag::project-type[]
   plugins {
       id('com.example.kotlin-library')
   }
   // end::project-type[]
   
   group = "${group}.model"

samples/build-organization/structuring-software-projects/groovy/domain-model/settings.gradle

.. code-block::

   // == Define locations for build logic ==
   pluginManagement {
       repositories {
           gradlePluginPortal() // if pluginManagement.repositories looks like this, it can be omitted as this is the default
       }
       includeBuild('../build-logic')
   }
   
   // == Define locations for components ==
   dependencyResolutionManagement {
       repositories {
           mavenCentral()
       }
   }
   includeBuild('../platforms')
   
   // == Define the inner structure of this component ==
   rootProject.name = 'domain-model'
   // tag::include[]
   include('release') // a project for data classes that represent software releases
   // end::include[]

samples/build-organization/structuring-software-projects/groovy/platforms/plugins-platform/build.gradle

.. code-block::

   plugins {
       id('java-platform')
   }
   
   group = 'com.example.platform'
   
   dependencies {
       constraints {
           api('com.android.tools.build:gradle:7.3.0')
           api('org.jetbrains.kotlin.android:org.jetbrains.kotlin.android.gradle.plugin:1.9.22')
           api('org.jetbrains.kotlin.jvm:org.jetbrains.kotlin.jvm.gradle.plugin:1.9.22')
           api('org.springframework.boot:org.springframework.boot.gradle.plugin:2.7.8')
       }
   }

samples/build-organization/structuring-software-projects/groovy/platforms/product-platform/build.gradle

.. code-block::

   plugins {
       id('java-platform')
   }
   
   group = 'com.example.platform'
   
   // allow the definition of dependencies to other platforms like the Spring Boot BOM
   javaPlatform.allowDependencies()
   
   dependencies {
       api(platform('org.springframework.boot:spring-boot-dependencies:2.7.8'))
   
       constraints {
           api('org.apache.juneau:juneau-marshall:8.2.0')
       }
   }

samples/build-organization/structuring-software-projects/groovy/platforms/settings.gradle

.. code-block::

   rootProject.name = 'platforms'
   
   include('product-platform')
   include('test-platform')
   include('plugins-platform')

samples/build-organization/structuring-software-projects/groovy/platforms/test-platform/build.gradle

.. code-block::

   plugins {
       id('java-platform')
   }
   
   group = 'com.example.platform'
   
   // allow the definition of dependencies to other platforms like the JUnit 5 BOM
   javaPlatform.allowDependencies()
   
   dependencies {
       api(platform('org.junit:junit-bom:5.7.1'))
   }

samples/build-organization/structuring-software-projects/groovy/server-application/app/build.gradle

.. code-block::

   plugins {
       id('com.example.spring-boot-application')
   }
   
   group = "${group}.server-application"
   
   dependencies {
       implementation('com.example.myproduct.user-feature:table')
       implementation('com.example.myproduct.admin-feature:config')
   
       implementation('org.apache.juneau:juneau-marshall')
   }

samples/build-organization/structuring-software-projects/groovy/server-application/settings.gradle

.. code-block::

   // == Define locations for build logic ==
   pluginManagement {
       repositories {
           gradlePluginPortal()
       }
       includeBuild('../build-logic')
   }
   
   // == Define locations for components ==
   dependencyResolutionManagement {
       repositories {
           mavenCentral()
       }
   }
   includeBuild('../platforms')
   includeBuild('../user-feature')
   includeBuild('../admin-feature')
   
   // == Define the inner structure of this component ==
   rootProject.name = 'server-application' // the component name
   include('app')

samples/build-organization/structuring-software-projects/groovy/state/application-state/build.gradle

.. code-block::

   plugins {
       id('com.example.kotlin-library')
   }
   
   group = "${group}.state"

samples/build-organization/structuring-software-projects/groovy/state/settings.gradle

.. code-block::

   // == Define locations for build logic ==
   pluginManagement {
       repositories {
           gradlePluginPortal() // if pluginManagement.repositories looks like this, it can be omitted as this is the default
       }
       includeBuild('../build-logic')
   }
   
   // == Define locations for components ==
   dependencyResolutionManagement {
       repositories {
           mavenCentral()
       }
   }
   includeBuild('../platforms')
   
   // == Define the inner structure of this component ==
   rootProject.name = 'state'
   include('application-state')

samples/build-organization/structuring-software-projects/groovy/user-feature/data/build.gradle

.. code-block::

   // tag::project-type[]
   plugins {
       id('com.example.java-library')
   }
   // end::project-type[]
   
   group = "${group}.user-feature"
   
   dependencies {
       api('com.example.myproduct.model:release')
   
       implementation('com.fasterxml.jackson.core:jackson-databind')
   }

samples/build-organization/structuring-software-projects/groovy/user-feature/settings.gradle

.. code-block::

   // == Define locations for build logic ==
   pluginManagement {
       repositories {
           gradlePluginPortal() // if pluginManagement.repositories looks like this, it can be omitted as this is the default
       }
       includeBuild('../build-logic')
   }
   
   // == Define locations for components ==
   dependencyResolutionManagement {
       repositories {
           mavenCentral()
       }
   }
   includeBuild('../platforms')
   includeBuild('../domain-model')
   includeBuild('../state')
   
   // == Define the inner structure of this component ==
   rootProject.name = 'user-feature'
   include('table')
   include('data')

samples/build-organization/structuring-software-projects/groovy/user-feature/table/build.gradle

.. code-block::

   plugins {
       id('com.example.java-library')
   }
   
   group = "${group}.user-feature"
   
   dependencies {
       implementation(project(':data'))
   
       implementation('com.example.myproduct.state:application-state')
   }

samples/build-organization/structuring-software-projects/kotlin/build.gradle.kts

.. code-block::

   // This is an example of a lifecycle task that crosses build boundaries defined in the umbrella build.
   tasks.register("checkFeatures") {
       group = "verification"
       description = "Run all feature tests"
       dependsOn(gradle.includedBuild("admin-feature").task(":config:check"))
       dependsOn(gradle.includedBuild("user-feature").task(":data:check"))
       dependsOn(gradle.includedBuild("user-feature").task(":table:check"))
   }

samples/build-organization/structuring-software-projects/kotlin/settings.gradle.kts

.. code-block::

   // This is an empty umbrella build including all the component builds.
   // This build is not necessarily needed. The component builds work independently.
   
   includeBuild("platforms")
   includeBuild("build-logic")
   
   includeBuild("aggregation")
   
   includeBuild("user-feature")
   includeBuild("admin-feature")
   
   includeBuild("server-application")
   includeBuild("android-app")

samples/build-organization/structuring-software-projects/kotlin/admin-feature/config/build.gradle.kts

.. code-block::

   plugins {
       id("com.example.kotlin-library")
   }
   
   group = "${group}.admin-feature"
   
   dependencies {
       implementation("com.example.myproduct.state:application-state")
   }

samples/build-organization/structuring-software-projects/kotlin/admin-feature/settings.gradle.kts

.. code-block::

   // == Define locations for build logic ==
   pluginManagement {
       repositories {
           gradlePluginPortal() // if pluginManagement.repositories looks like this, it can be omitted as this is the default
       }
       includeBuild("../build-logic")
   }
   
   // == Define locations for components ==
   dependencyResolutionManagement {
       repositories {
           mavenCentral()
       }
   }
   includeBuild("../platforms")
   includeBuild("../domain-model")
   includeBuild("../state")
   
   // == Define the inner structure of this component ==
   rootProject.name = "admin-feature"
   include("config")

samples/build-organization/structuring-software-projects/kotlin/aggregation/settings.gradle.kts

.. code-block::

   // == Define locations for build logic ==
   pluginManagement {
       repositories {
           gradlePluginPortal() // if pluginManagement.repositories looks like this, it can be omitted as this is the default
       }
       includeBuild("../build-logic")
   }
   
   // == Define locations for components ==
   dependencyResolutionManagement {
       repositories {
           mavenCentral()
       }
   }
   includeBuild("../platforms")
   includeBuild("../admin-feature")
   includeBuild("../user-feature")
   
   
   // == Define the inner structure of this component ==
   rootProject.name = "aggregation"
   include("test-coverage")
   

samples/build-organization/structuring-software-projects/kotlin/aggregation/test-coverage/build.gradle.kts

.. code-block::

   plugins {
       id("com.example.report-aggregation")
   }
   
   dependencies {
       // Transitively collect coverage data from all features and their dependencies
       aggregate("com.example.myproduct.user-feature:table")
       aggregate("com.example.myproduct.admin-feature:config")
   }

samples/build-organization/structuring-software-projects/kotlin/android-app/app/build.gradle.kts

.. code-block::

   plugins {
       id("com.example.android-application")
   }
   
   group = "${group}.android-app"
   
   dependencies {
       implementation("com.example.myproduct.user-feature:table")
   }

samples/build-organization/structuring-software-projects/kotlin/android-app/settings.gradle.kts

.. code-block::

   // == Define locations for build logic ==
   pluginManagement {
       repositories {
           gradlePluginPortal()
           google()
       }
       includeBuild("../build-logic")
   }
   
   // == Define locations for components ==
   dependencyResolutionManagement {
       repositories {
           mavenCentral()
           google()
       }
   }
   includeBuild("../platforms")
   includeBuild("../user-feature")
   
   // == Define the inner structure of this component ==
   rootProject.name = "android-app"
   include("app")

samples/build-organization/structuring-software-projects/kotlin/build-logic/android-application/build.gradle.kts

.. code-block::

   plugins {
       `kotlin-dsl`
   }
   
   dependencies {
       implementation(platform("com.example.platform:plugins-platform"))
   
       implementation(project(":commons"))
   
       implementation("com.android.tools.build:gradle")
       implementation("org.jetbrains.kotlin.android:org.jetbrains.kotlin.android.gradle.plugin")
   }

samples/build-organization/structuring-software-projects/kotlin/build-logic/android-application/src/main/kotlin/com.example.android-application.gradle.kts

.. code-block::

   plugins {
       id("com.android.application")
       id("org.jetbrains.kotlin.android")
   }
   
   group = "com.example.myproduct"
   
   java {
       toolchain {
           languageVersion = JavaLanguageVersion.of(8)
       }
   }
   
   android {
       compileSdkVersion(28)
       defaultConfig {
           minSdkVersion(24)
           targetSdkVersion(28)
       }
       compileOptions {
           sourceCompatibility = JavaVersion.VERSION_1_8
           targetCompatibility = JavaVersion.VERSION_1_8
       }
   }
   
   dependencies {
       implementation(platform("com.example.platform:product-platform"))
       testImplementation(platform("com.example.platform:test-platform"))
   
       implementation(kotlin("stdlib"))
   }

samples/build-organization/structuring-software-projects/kotlin/build-logic/commons/build.gradle.kts

.. code-block::

   plugins {
       `kotlin-dsl`
   }

samples/build-organization/structuring-software-projects/kotlin/build-logic/commons/src/main/kotlin/com.example.commons.gradle.kts

.. code-block::

   plugins {
       id("java")
       id("com.example.jacoco")
   }
   
   group = "com.example.myproduct"
   
   java {
       toolchain {
           languageVersion = JavaLanguageVersion.of(8)
       }
   }
   
   dependencies {
       implementation(platform("com.example.platform:product-platform"))
   
       testImplementation(platform("com.example.platform:test-platform"))
       testImplementation("org.junit.jupiter:junit-jupiter")
       testRuntimeOnly("org.junit.platform:junit-platform-launcher")
   }
   
   tasks.test {
       useJUnitPlatform()
   }

samples/build-organization/structuring-software-projects/kotlin/build-logic/commons/src/main/kotlin/com.example.jacoco.gradle.kts

.. code-block::

   plugins {
       id("java")
       id("jacoco")
   }
   
   // Do not generate reports for individual projects
   tasks.jacocoTestReport.configure {
       enabled = false
   }

samples/build-organization/structuring-software-projects/kotlin/build-logic/java-library/build.gradle.kts

.. code-block::

   plugins {
       `kotlin-dsl`
   }
   
   dependencies {
       implementation(platform("com.example.platform:plugins-platform"))
   
       implementation(project(":commons"))
   }

samples/build-organization/structuring-software-projects/kotlin/build-logic/java-library/src/main/kotlin/com.example.java-library.gradle.kts

.. code-block::

   plugins {
       id("com.example.commons")
       id("java-library")
   }

samples/build-organization/structuring-software-projects/kotlin/build-logic/kotlin-library/build.gradle.kts

.. code-block::

   plugins {
       `kotlin-dsl`
   }
   
   dependencies {
       implementation(platform("com.example.platform:plugins-platform"))
   
       implementation(project(":commons"))
       implementation("org.jetbrains.kotlin.jvm:org.jetbrains.kotlin.jvm.gradle.plugin")
   }

samples/build-organization/structuring-software-projects/kotlin/build-logic/kotlin-library/src/main/kotlin/com.example.kotlin-library.gradle.kts

.. code-block::

   plugins {
       id("com.example.commons")
       id("org.jetbrains.kotlin.jvm")
       id("java-library")
   }
   
   dependencies {
       implementation(kotlin("stdlib"))
   }

samples/build-organization/structuring-software-projects/kotlin/build-logic/report-aggregation/build.gradle.kts

.. code-block::

   plugins {
       `kotlin-dsl`
   }

samples/build-organization/structuring-software-projects/kotlin/build-logic/report-aggregation/src/main/kotlin/com.example.report-aggregation.gradle.kts

.. code-block::

   plugins {
       id("java-base") // we only apply 'java-base' as this plugin is for projects without source code
       id("jacoco")
   }
   
   // Configurations to declare dependencies
   val aggregate by configurations.creating {
       isVisible = false
       isCanBeResolved = false
       isCanBeConsumed = false
   }
   
   // Resolvable configuration to resolve the classes of all dependencies
   val classesPath by configurations.creating {
       isVisible = false
       isCanBeConsumed = false
       extendsFrom(aggregate)
       attributes {
           attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage.JAVA_RUNTIME))
           attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category.LIBRARY))
           attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, objects.named(LibraryElements.CLASSES))
       }
   }
   
   // A resolvable configuration to collect source code
   val sourcesPath by configurations.creating {
       isVisible = false
       isCanBeConsumed = false
       extendsFrom(aggregate)
       attributes {
           attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category.VERIFICATION))
           attribute(VerificationType.VERIFICATION_TYPE_ATTRIBUTE, objects.named(VerificationType.MAIN_SOURCES))
       }
   }
   
   // A resolvable configuration to collect JaCoCo coverage data
   val coverageDataPath by configurations.creating {
       isVisible = false
       isCanBeConsumed = false
       extendsFrom(aggregate)
       attributes {
           attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category.VERIFICATION))
           attribute(VerificationType.VERIFICATION_TYPE_ATTRIBUTE, objects.named(VerificationType.JACOCO_RESULTS))
       }
   }
   
   // Register a code coverage report task to generate the aggregated report
   val codeCoverageReport by tasks.registering(JacocoReport::class) {
       additionalClassDirs(classesPath.filter { it.isDirectory() })
       additionalSourceDirs(sourcesPath.incoming.artifactView { lenient(true) }.files)
       executionData(coverageDataPath.incoming.artifactView { lenient(true) }.files.filter { it.exists() })
   
       reports {
           html.required = true
           xml.required = true
       }
   }
   
   // Make JaCoCo report generation part of the 'check' lifecycle phase
   tasks.check {
       dependsOn(codeCoverageReport)
   }

samples/build-organization/structuring-software-projects/kotlin/build-logic/settings.gradle.kts

.. code-block::

   dependencyResolutionManagement {
       repositories {
           gradlePluginPortal()
           google()
       }
   }
   includeBuild("../platforms")
   
   rootProject.name = "build-logic"
   include("commons")
   include("java-library")
   include("kotlin-library")
   include("android-application")
   include("spring-boot-application")
   include("report-aggregation")

samples/build-organization/structuring-software-projects/kotlin/build-logic/spring-boot-application/build.gradle.kts

.. code-block::

   plugins {
       `kotlin-dsl` // <1>
   }
   
   dependencies {
       implementation(platform("com.example.platform:plugins-platform")) // <2>
   
       implementation(project(":commons")) // <3>
   
       implementation("org.springframework.boot:org.springframework.boot.gradle.plugin")  // <4>
   }

samples/build-organization/structuring-software-projects/kotlin/build-logic/spring-boot-application/src/main/kotlin/com.example.spring-boot-application.gradle.kts

.. code-block::

   plugins {
       id("com.example.commons")
       id("org.springframework.boot")
   }
   
   dependencies {
       implementation("org.springframework.boot:spring-boot-starter-web")
       implementation("org.springframework.boot:spring-boot-starter-thymeleaf")
   }

samples/build-organization/structuring-software-projects/kotlin/domain-model/release/build.gradle.kts

.. code-block::

   // tag::project-type[]
   plugins {
       id("com.example.kotlin-library")
   }
   // end::project-type[]
   
   group = "${group}.model"

samples/build-organization/structuring-software-projects/kotlin/domain-model/settings.gradle.kts

.. code-block::

   // == Define locations for build logic ==
   pluginManagement {
       repositories {
           gradlePluginPortal() // if pluginManagement.repositories looks like this, it can be omitted as this is the default
       }
       includeBuild("../build-logic")
   }
   
   // == Define locations for components ==
   dependencyResolutionManagement {
       repositories {
           mavenCentral()
       }
   }
   includeBuild("../platforms")
   
   // == Define the inner structure of this component ==
   rootProject.name = "domain-model"
   // tag::include[]
   include("release") // a project for data classes that represent software releases
   // end::include[]

samples/build-organization/structuring-software-projects/kotlin/platforms/plugins-platform/build.gradle.kts

.. code-block::

   plugins {
       id("java-platform")
   }
   
   group = "com.example.platform"
   
   dependencies {
       constraints {
           api("com.android.tools.build:gradle:7.3.1")
           api("org.jetbrains.kotlin.android:org.jetbrains.kotlin.android.gradle.plugin:1.9.22")
           api("org.jetbrains.kotlin.jvm:org.jetbrains.kotlin.jvm.gradle.plugin:1.9.22")
           api("org.springframework.boot:org.springframework.boot.gradle.plugin:2.7.8")
       }
   }

samples/build-organization/structuring-software-projects/kotlin/platforms/product-platform/build.gradle.kts

.. code-block::

   plugins {
       id("java-platform")
   }
   
   group = "com.example.platform"
   
   // allow the definition of dependencies to other platforms like the Spring Boot BOM
   javaPlatform.allowDependencies()
   
   dependencies {
       api(platform("org.springframework.boot:spring-boot-dependencies:2.7.8"))
   
       constraints {
           api("org.apache.juneau:juneau-marshall:8.2.0")
       }
   }

samples/build-organization/structuring-software-projects/kotlin/platforms/settings.gradle.kts

.. code-block::

   rootProject.name = "platforms"
   
   include("product-platform")
   include("test-platform")
   include("plugins-platform")samples/build-organization/structuring-software-projects/kotlin/platforms/test-platform/build.gradle.kts

.. code-block::

   plugins {
       id("java-platform")
   }
   
   group = "com.example.platform"
   
   // allow the definition of dependencies to other platforms like the JUnit 5 BOM
   javaPlatform.allowDependencies()
   
   dependencies {
       api(platform("org.junit:junit-bom:5.7.1"))
   }

samples/build-organization/structuring-software-projects/kotlin/server-application/app/build.gradle.kts

.. code-block::

   plugins {
       id("com.example.spring-boot-application")
   }
   
   group = "${group}.server-application"
   
   dependencies {
       implementation("com.example.myproduct.user-feature:table")
       implementation("com.example.myproduct.admin-feature:config")
   
       implementation("org.apache.juneau:juneau-marshall")
   }

samples/build-organization/structuring-software-projects/kotlin/server-application/settings.gradle.kts

.. code-block::

   // == Define locations for build logic ==
   pluginManagement {
       repositories {
           gradlePluginPortal()
       }
       includeBuild("../build-logic")
   }
   
   // == Define locations for components ==
   dependencyResolutionManagement {
       repositories {
           mavenCentral()
       }
   }
   includeBuild("../platforms")
   includeBuild("../user-feature")
   includeBuild("../admin-feature")
   
   // == Define the inner structure of this component ==
   rootProject.name = "server-application" // the component name
   include("app")

samples/build-organization/structuring-software-projects/kotlin/state/application-state/build.gradle.kts

.. code-block::

   plugins {
       id("com.example.kotlin-library")
   }
   
   group = "${group}.state"

samples/build-organization/structuring-software-projects/kotlin/state/settings.gradle.kts

.. code-block::

   // == Define locations for build logic ==
   pluginManagement {
       repositories {
           gradlePluginPortal() // if pluginManagement.repositories looks like this, it can be omitted as this is the default
       }
       includeBuild("../build-logic")
   }
   
   // == Define locations for components ==
   dependencyResolutionManagement {
       repositories {
           mavenCentral()
       }
   }
   includeBuild("../platforms")
   
   // == Define the inner structure of this component ==
   rootProject.name = "state"
   include("application-state")

samples/build-organization/structuring-software-projects/kotlin/user-feature/data/build.gradle.kts

.. code-block::

   // tag::project-type[]
   plugins {
       id("com.example.java-library")
   }
   // end::project-type[]
   
   group = "${group}.user-feature"
   
   dependencies {
       api("com.example.myproduct.model:release")
   
       implementation("com.fasterxml.jackson.core:jackson-databind")
   }

samples/build-organization/structuring-software-projects/kotlin/user-feature/settings.gradle.kts

.. code-block::

   // == Define locations for build logic ==
   pluginManagement {
       repositories {
           gradlePluginPortal() // if pluginManagement.repositories looks like this, it can be omitted as this is the default
       }
       includeBuild("../build-logic")
   }
   
   // == Define locations for components ==
   dependencyResolutionManagement {
       repositories {
           mavenCentral()
       }
   }
   includeBuild("../platforms")
   includeBuild("../domain-model")
   includeBuild("../state")
   
   // == Define the inner structure of this component ==
   rootProject.name = "user-feature"
   include("table")
   include("data")

samples/build-organization/structuring-software-projects/kotlin/user-feature/table/build.gradle.kts

.. code-block::

   plugins {
       id("com.example.java-library")
   }
   
   group = "${group}.user-feature"
   
   dependencies {
       implementation(project(":data"))
   
       implementation("com.example.myproduct.state:application-state")
   }

samples/build-organization/structuring-software-projects/tests/aggregate-reports.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: check
       execution-subdirectory: aggregation
   }]

samples/build-organization/structuring-software-projects/tests/build-android-app.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       # There's a flaky stacktrace: java.io.FileNotFoundException: https://dl.google.com/android/repository/sys-img/android-desktop/sys-img2-1.xml
       #  at sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1896) ...
       args: build -x lint -x lintVitalRelease "-Dorg.gradle.sampletest.noStackTraceCheck=true"
       execution-subdirectory: android-app
       # Do not fail for deprecation warning in Kotlin Android plugin
       flags: "--warning-mode=all"
   }]

samples/build-organization/structuring-software-projects/tests/build-server-application.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: build
       execution-subdirectory: server-application
       # Do not fail for deprecation warnings: Project.getConvention; Spring boot 3.0.2+ no longer uses that API
       flags: "--warning-mode=none"
   }]

samples/build-organization/structuring-software-projects/tests/sanityCheck.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: tasks -q
   },{
       execution-subdirectory: admin-feature
       executable: gradle
       args: tasks -q
   },{
       execution-subdirectory: aggregation
       executable: gradle
       args: tasks -q
   },{
       execution-subdirectory: android-app
       executable: gradle
       args: tasks -q
   },{
       execution-subdirectory: build-logic
       executable: gradle
       args: tasks -q
   },{
       execution-subdirectory: domain-model
       executable: gradle
       args: tasks -q
   },{
       execution-subdirectory: platforms
       executable: gradle
       args: tasks -q
   },{
       execution-subdirectory: server-application
       executable: gradle
       args: tasks -q
   },{
       execution-subdirectory: state
       executable: gradle
       args: tasks -q
   },{
       execution-subdirectory: user-feature
       executable: gradle
       args: tasks -q
   }]

samples/build-organization/structuring-software-projects/tests/umbrella-build.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: checkFeatures
       # Do not fail for deprecation warning when configuring Kotlin Android plugin
       flags: "--warning-mode=all"
   }]

/Sample: 游릭 credentials-handling
=============================

samples/credentials-handling/pass-credentials-to-external-tool-via-stdin/README.adoc

.. code-block::

   NOTE: You can open the samples inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how credentials can be passed to an external tool that normally accepts them via standard input.
   
   Let's pretend that we have to log in to some system before performing some operation.
   This could be some external system that requires authentication before allowing us to upload some artifacts.
   
   TIP: This sample assumes that the external tool that requires interactive login does not support any form of non-interactive login.
   In reality, many tools provide options to authenticate without prompting the user for input.
   Command-line arguments can be passed to the Exec task using the `args` property.
   
   To demonstrate the concept, we will fake the authentication using a bash script that prompts the user for username and password:
   ====
   include::sample[dir="groovy",files="login.sh[]"]
   ====
   It has a hardcoded username/password pair that will result in successful login.
   The script can be executed without Gradle - it will mimic a tool that requires an interactive login.
   
   Gradle build file registers two tasks - one performs a login and the other one depends on the login having succeeded:
   ====
   include::sample[dir="kotlin",files="build.gradle.kts[]"]
   include::sample[dir="groovy",files="build.gradle[]"]
   ====
   
   The `login` task declares an input property and connects it with a credentials provider.
   The credentials provider will fetch the credentials pieces from the link:{userManualPath}#build_environment-sec:project_properties[project properties].
   
   Credentials can be passed to a task in multiple ways:
   
    * via command-line properties:
   =====
   ----
   $ ./gradlew doAuthenticated -PloginUsername=secret-user -PloginPassword=secret-password
   ----
   =====
    * via environment variables:
   =====
   ----
   $ ORG_GRADLE_PROJECT_loginUsername=secret-user ORG_GRADLE_PROJECT_loginPassword=secret-password ./gradlew doAuthenticated
   ----
   =====
    * by setting the properties in `gradle.properties` file:
   =====
   ----
   loginUsername=secret-user
   loginPassword=secret-password
   ----
   =====
   and running
   =====
   ----
   $ ./gradlew doAuthenticated
   ----
   =====
   This way the sensitive data can be kept outside of the project sources - `gradle.properties` can reside in the user's `~/.gradle` directory.
   The values are also not echoed anywhere this way.
   For more information about using Gradle properties, see link:{userManualPath}#build_environment-sec:gradle_configuration_properties[Gradle Properties user manual chapter].
   
   The output with correct credentials will be:
   =====
   [.sample-command]
   ----
   > Task :login
   Enter userame:
   Enter password:
   Welcome, secret-user!
   
   > Task :doAuthenticated
   doAuthenticated
   
   BUILD SUCCESSFUL in 496ms
   2 actionable tasks: 2 executed
   ----
   =====
   

samples/credentials-handling/pass-credentials-to-external-tool-via-stdin/common/login.sh

.. code-block::

   #!/bin/bash
   
   echo Enter username:
   read username
   echo Enter password:
   if [ -t 0 ] ; then # if connected to a terminal, do not echo the password input
       stty -echo
       read password
       stty echo
       echo
   else
       read password
   fi
   
   if [ "$username" = "secret-user" ] && [ "$password" = "secret-password" ] ; then
       echo "Welcome, $username!"
   else
       echo "Bad credentials!"
       exit 1
   fi

samples/credentials-handling/pass-credentials-to-external-tool-via-stdin/groovy/build.gradle

.. code-block::

   def login = tasks.register('login', Exec) {
       def loginProvider = providers.credentials(PasswordCredentials, 'login')
       inputs.property('credentials', loginProvider)
   
       commandLine = ['sh', 'login.sh']
       doFirst {
           def loginCredentials = loginProvider.get()
           standardInput = new ByteArrayInputStream("$loginCredentials.username\n$loginCredentials.password".getBytes())
       }
   }
   
   tasks.register('doAuthenticated') {
       dependsOn(login)
       doLast {
           println 'Doing authenticated task'
       }
   }

samples/credentials-handling/pass-credentials-to-external-tool-via-stdin/groovy/settings.gradle

.. code-block::

   rootProject.name = 'sample'

samples/credentials-handling/pass-credentials-to-external-tool-via-stdin/kotlin/build.gradle.kts

.. code-block::

   val login = tasks.register<Exec>("login") {
       val loginProvider = providers.credentials(PasswordCredentials::class.java, "login")
       inputs.property("credentials", loginProvider)
   
       commandLine = listOf("sh", "login.sh")
       doFirst {
           val loginCredentials = loginProvider.get()
           standardInput = java.io.ByteArrayInputStream("${loginCredentials.username}\n${loginCredentials.password}".toByteArray())
       }
   }
   
   tasks.register("doAuthenticated") {
       dependsOn(login)
       doLast {
           println("Doing authenticated task")
       }
   }

samples/credentials-handling/pass-credentials-to-external-tool-via-stdin/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "sample"

samples/credentials-handling/pass-credentials-to-external-tool-via-stdin/tests/commandLineCredentials.out

.. code-block::

   Enter username:
   Enter password:
   Welcome, secret-user!
   Doing authenticated task

samples/credentials-handling/pass-credentials-to-external-tool-via-stdin/tests/commandLineCredentials.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: "-q doAuthenticated -PloginUsername=secret-user -PloginPassword=secret-password"
       expected-output-file: commandLineCredentials.out
   }]

/Sample: 游릭 credentials-handling
=============================

samples/credentials-handling/publishing-credentials/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how credentials can be used when publishing artifacts to a Maven repository using link:{userManualPath}#build_environment-sec:project_properties[project properties].
   This approach allows you to keep sensitive configuration out of your project's source code and inject it only when needed.
   
   The code in the `maven-repository-stub` directory builds a plugin used to stub the Maven repository in order to demonstrate the authentication flow. It expects the following hardcoded credentials on the server stub:
   ====
   include::sample[dir="groovy",files="maven-repository-stub/src/main/java/com/example/MavenRepositoryStub.java[tags=credentials]"]
   ====
   
   In a real project, your build would point to a private repository for your organization.
   
   The published project has some sample Java code to be compiled and distributed as a Java library.
   Gradle build file registers a publication to a Maven repository using provided credentials:
   ====
   include::sample[dir="kotlin",files="build.gradle.kts[tags=publication]"]
   include::sample[dir="groovy",files="build.gradle[tags=publication]"]
   ====
   
   Credentials will be required by the build only if the task requiring them is to be executed - in this case the task publishing to the secure repository.
   This allows to build the project without worrying about the credentials.
   Try running `./gradlew jar` and it will succeed. Run `./gradlew publish` and it will tell you what is missing right away, without executing the build.
   Credentials can and should be kept externally from the project sources and be known only by those having to publish artifacts, perhaps injected by a CI server.
   
   Credential values are provided using Gradle properties and can be passed to the publish task in multiple ways:
   
   * via command-line properties:
   =====
   ----
   $ ./gradlew publish -PmySecureRepositoryUsername=secret-user -PmySecureRepositoryPassword=secret-password
   ----
   =====
   * via environment variables:
   =====
   ----
   $ ORG_GRADLE_PROJECT_mySecureRepositoryUsername=secret-user ORG_GRADLE_PROJECT_mySecureRepositoryPassword=secret-password ./gradlew publish
   ----
   =====
   * by setting the properties in `gradle.properties` file:
   =====
   ----
   mySecureRepositoryUsername=secret-user
   mySecureRepositoryPassword=secret-password
   ----
   =====
   and running
   =====
   ----
   $ ./gradlew publish
   ----
   =====
   The sensitive data is kept outside of the project sources since the `gradle.properties` file can reside in the user's `~/.gradle` directory.
   
   For more information about using Gradle properties, see link:{userManualPath}#build_environment-sec:gradle_configuration_properties[Gradle Properties user manual chapter].

samples/credentials-handling/publishing-credentials/common/maven-repository-stub/src/main/java/com/example/MavenRepositoryStub.java

.. code-block::

   package com.example;
   
   import com.github.tomakehurst.wiremock.WireMockServer;
   
   import static com.github.tomakehurst.wiremock.client.WireMock.anyUrl;
   import static com.github.tomakehurst.wiremock.client.WireMock.get;
   import static com.github.tomakehurst.wiremock.client.WireMock.notFound;
   import static com.github.tomakehurst.wiremock.client.WireMock.ok;
   import static com.github.tomakehurst.wiremock.client.WireMock.put;
   import static com.github.tomakehurst.wiremock.client.WireMock.unauthorized;
   import static com.github.tomakehurst.wiremock.core.WireMockConfiguration.wireMockConfig;
   
   public class MavenRepositoryStub {
   
       // tag::credentials[]
       private static final String USERNAME = "secret-user";
       private static final String PASSWORD = "secret-password";
       // end::credentials[]
   
       private static final WireMockServer SERVER = new WireMockServer(wireMockConfig().dynamicPort());
   
       public static String start() {
           SERVER.start();
   
           SERVER.stubFor(put(anyUrl()).willReturn(unauthorized()));
           SERVER.stubFor(put(anyUrl()).withBasicAuth(USERNAME, PASSWORD).willReturn(ok()));
           SERVER.stubFor(get(anyUrl()).withBasicAuth(USERNAME, PASSWORD).willReturn(notFound()));
   
           return String.format("http://127.0.0.1:%d", SERVER.port());
       }
   
       public static void stop() {
           SERVER.stop();
       }
   
   }

samples/credentials-handling/publishing-credentials/groovy/build.gradle

.. code-block::

   plugins {
       id 'java-library'
       id 'maven-publish'
   
       // this plugin comes from an included build - it fakes a maven repository to allow executing the authentication flow
       id 'maven-repository-stub'
   }
   
   version = '1.0.2'
   group = 'com.example'
   
   // tag::publication[]
   publishing {
       publications {
           library(MavenPublication) {
               from components.java
           }
       }
   // tag::repositories[]
       repositories {
           maven {
               name = 'mySecureRepository'
               credentials(PasswordCredentials)
               // url = uri(<<some repository url>>)
           }
       }
   // end::repositories[]
   }
   // end::publication[]
   

samples/credentials-handling/publishing-credentials/groovy/maven-repository-stub/build.gradle

.. code-block::

   plugins {
       id 'groovy-gradle-plugin'
   }
   
   repositories {
       mavenCentral()
   }
   
   dependencies {
       implementation "com.github.tomakehurst:wiremock:2.26.3"
   }

samples/credentials-handling/publishing-credentials/groovy/maven-repository-stub/settings.gradle

.. code-block::

   rootProject.name = 'maven-repository-stub'

samples/credentials-handling/publishing-credentials/groovy/maven-repository-stub/src/main/groovy/maven-repository-stub.gradle

.. code-block::

   tasks.withType(PublishToMavenRepository).configureEach {
       notCompatibleWithConfigurationCache("Configures repository at execution time")
       doFirst {
           def address = com.example.MavenRepositoryStub.start()
           getRepository().setUrl(address)
       }
       doLast {
           com.example.MavenRepositoryStub.stop()
       }
   }

samples/credentials-handling/publishing-credentials/groovy/settings.gradle

.. code-block::

   rootProject.name = 'sample'
   
   includeBuild 'maven-repository-stub'

samples/credentials-handling/publishing-credentials/kotlin/build.gradle.kts

.. code-block::

   plugins {
       `java-library`
       `maven-publish`
   
       // this plugin comes from an included build - it fakes a maven repository to allow executing the authentication flow
       id("maven-repository-stub")
   }
   
   version = "1.0.2"
   group = "com.example"
   
   // tag::publication[]
   publishing {
       publications {
           create<MavenPublication>("library") {
               from(components.getByName("java"))
           }
       }
   // tag::repositories[]
       repositories {
           maven {
               name = "mySecureRepository"
               credentials(PasswordCredentials::class)
               // url = uri(<<some repository url>>)
           }
       }
   // end::repositories[]
   }
   // end::publication[]

samples/credentials-handling/publishing-credentials/kotlin/maven-repository-stub/build.gradle.kts

.. code-block::

   plugins {
       `kotlin-dsl`
   }
   
   repositories {
       mavenCentral()
   }
   
   dependencies {
       implementation("com.github.tomakehurst:wiremock:2.26.3")
   }

samples/credentials-handling/publishing-credentials/kotlin/maven-repository-stub/settings.gradle.kts

.. code-block::

   rootProject.name = "maven-repository-stub"

samples/credentials-handling/publishing-credentials/kotlin/maven-repository-stub/src/main/kotlin/maven-repository-stub.gradle.kts

.. code-block::

   tasks.withType<PublishToMavenRepository>().configureEach {
       notCompatibleWithConfigurationCache("Configures repository at execution time")
       doFirst {
           val address = com.example.MavenRepositoryStub.start()
           getRepository().setUrl(address)
       }
       doLast {
           com.example.MavenRepositoryStub.stop()
       }
   }

samples/credentials-handling/publishing-credentials/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "sample"
   
   includeBuild("maven-repository-stub")

samples/credentials-handling/publishing-credentials/tests/publishCommandLineCredentials.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: "publish -PmySecureRepositoryUsername=secret-user -PmySecureRepositoryPassword=secret-password"
   }]

/Sample: 游릭 groovy/library
=======================

samples/groovy/library-publishing/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how a Groovy library can be published to a repository with Gradle.
   
   ====
   include::sample[dir="kotlin",files="my-library/build.gradle.kts[]"]
   include::sample[dir="groovy",files="my-library/build.gradle[]"]
   ====
   
   To publish the library:
   
   [listing.terminal]
   ----
   $ ./gradlew publish
   
   BUILD SUCCESSFUL
   4 actionable tasks: 4 executed
   $ tree build/publishing-repository
   build/publishing-repository/
   較덕較 org
       較덕較 gradle
           較덕較 sample
               較덕較 my-library
                   較럭較 1.0.2
                   較먝 較럭較 my-library-1.0.2.jar
                   較먝 較럭較 my-library-1.0.2.jar.md5
                   較먝 較럭較 my-library-1.0.2.jar.sha1
                   較먝 較럭較 my-library-1.0.2.jar.sha256
                   較먝 較럭較 my-library-1.0.2.jar.sha512
                   較먝 較럭較 my-library-1.0.2.module
                   較먝 較럭較 my-library-1.0.2.module.md5
                   較먝 較럭較 my-library-1.0.2.module.sha1
                   較먝 較럭較 my-library-1.0.2.module.sha256
                   較먝 較럭較 my-library-1.0.2.module.sha512
                   較먝 較럭較 my-library-1.0.2.pom
                   較먝 較럭較 my-library-1.0.2.pom.md5
                   較먝 較럭較 my-library-1.0.2.pom.sha1
                   較먝 較럭較 my-library-1.0.2.pom.sha256
                   較먝 較덕較 my-library-1.0.2.pom.sha512
                   較럭較 maven-metadata.xml
                   較럭較 maven-metadata.xml.md5
                   較럭較 maven-metadata.xml.sha1
                   較럭較 maven-metadata.xml.sha256
                   較덕較 maven-metadata.xml.sha512
   
   5 directories, 20 files
   ----
   
   For more information, see link:{userManualPath}#publishing_setup[Publishing Libraries].

samples/groovy/library-publishing/groovy/my-library/build.gradle

.. code-block::

   plugins {
       id 'groovy'
       id 'maven-publish'
   }
   
   version = '1.0.2'
   group = 'org.gradle.sample'
   
   repositories {
       mavenCentral()
   }
   
   dependencies {
       implementation 'org.codehaus.groovy:groovy-all:3.0.18'
   }
   
   publishing {
       publications {
           library(MavenPublication) {
               from components.java
           }
       }
       repositories {
           maven {
               url = layout.buildDirectory.dir("publishing-repository")
           }
       }
   }

samples/groovy/library-publishing/groovy/settings.gradle

.. code-block::

   rootProject.name = 'library-publishing'
   
   include 'my-library'

samples/groovy/library-publishing/kotlin/my-library/build.gradle.kts

.. code-block::

   plugins {
       groovy
       `maven-publish`
   }
   
   version = "1.0.2"
   group = "org.gradle.sample"
   
   repositories {
       mavenCentral()
   }
   
   dependencies {
       implementation("org.codehaus.groovy:groovy-all:3.0.18")
   }
   
   publishing {
       publications {
           create<MavenPublication>("library") {
               from(components["java"])
           }
       }
       repositories {
           maven {
               url = uri(layout.buildDirectory.dir("publishing-repository"))
           }
       }
   }

samples/groovy/library-publishing/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "library-publishing"
   
   include(":my-library")

samples/groovy/library-publishing/tests/publishTask.out

.. code-block::

   > Task :my-library:compileJava NO-SOURCE
   > Task :my-library:compileGroovy
   > Task :my-library:processResources NO-SOURCE
   > Task :my-library:classes
   > Task :my-library:jar
   > Task :my-library:generateMetadataFileForLibraryPublication
   > Task :my-library:generatePomFileForLibraryPublication
   > Task :my-library:publishLibraryPublicationToMavenRepository
   > Task :my-library:publish
   
   BUILD SUCCESSFUL in 0s
   5 actionable tasks: 5 executed

samples/groovy/library-publishing/tests/publishTask.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: publish
       expected-output-file: publishTask.out
       allow-disordered-output: true
   }]

/Sample: 游릭 ide/problems
=====================

samples/ide/problems-api-usage/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how problems can be emitted via the Problems API and how those reports are consumed on the IDE-side.
   
   ## Running the sample
   
   To run the sample, execute the `./gradlew :sample-ide:importBuild` command.
   
   ## Project structure
   
   The sample consists of multiple, individual builds composed into a composite build with the following layout
   
   * `sample-project`: A Gradle build with plugins that report problems
   * `sample-ide`: a project that simulates the IDE functionality. In other words, it uses the Gradle Tooling API to configure and run the `sample-project` build and prints the received problem reports received during the process.
   * `reporters/standard-plugin` shows the usage of the Problems API in a standard Gradle plugin.
   * `reporters/model-builder-plugin` shows how to use the Problems API to report problems when reading project configuration via the Tooling API.
   * `reporters/script-plugin` shows how to use the Problems API in a precompiled script plugin.
   
   
   ## Emitting a problem
   
   Problems can be emitted via an injected `Problems` service.
   Here's an example on how to report a problem from a plugin.
   
   ====
   include::sample[dir="groovy",files="reporters/standard-plugin/src/main/java/reporters/StandardPlugin.java[tags=problems-api-report]"]
   ====
   
   
   ## Receiving a problem report
   
   Problems are emitted as Tooling API progress events. They can be processed by registering a `ProgressListener`:
   
   ====
   include::sample[dir="groovy",files="sample-ide/src/main/java/org/gradle/sample/SampleIde.java[tags=problems-tapi-event]"]
   ====
   
   

samples/ide/problems-api-usage/groovy/build.gradle

.. code-block::

   plugins {
       id 'reporters.model.builder'
   }

samples/ide/problems-api-usage/groovy/reporters/model-builder-plugin/build.gradle

.. code-block::

   plugins {
       id 'java-gradle-plugin'
   }
   
   group = 'reporters'
   
   repositories {
       mavenCentral()
   }
   
   gradlePlugin {
       plugins {
           'model-builder-plugin' {
               id = 'reporters.model.builder'
               implementationClass = 'reporters.ModelBuilderPlugin'
           }
       }
   }

samples/ide/problems-api-usage/groovy/reporters/script-plugin/build.gradle

.. code-block::

   plugins {
       id 'groovy-gradle-plugin'
   }

samples/ide/problems-api-usage/groovy/reporters/script-plugin/src/main/groovy/reporters.script.plugin.gradle

.. code-block::

   import org.gradle.api.internal.GradleInternal
   import org.gradle.api.problems.Problems
   import org.gradle.api.problems.Severity
   
   def gradleInternal = gradle as GradleInternal
   def problems = gradleInternal.services.get(Problems)
   
   problems.forNamespace('buildscript').reporting {
       it.label("Deprecated script plugin 'demo-script-plugin'")
           .category('deprecation', 'plugin')
           .severity(Severity.WARNING)
           .solution("Please use 'standard-plugin-2' instead of this plugin")
   }
   
   tasks.register('warningTask') {
       doLast {
           problems.forNamespace('buildscript').reporting {
               it.label("Task 'warningTask' is deprecated")
                   .category('deprecation', 'task')
                   .severity(Severity.WARNING)
                   .solution("Please use 'warningTask2' instead of this task")
           }
       }
   }
   
   tasks.register('failingTask') {
       doLast {
           problems.forNamespace('buildscript').throwing {
               it.label("Task 'failingTask' should not be called")
                   .category('deprecation', 'task')
                   .severity(Severity.ERROR)
                   .withException(new RuntimeException("The 'failingTask' should not be called"))
                   .solution("Please use 'successfulTask' instead of this task")
           }
       }
   }

samples/ide/problems-api-usage/groovy/reporters/standard-plugin/build.gradle

.. code-block::

   plugins {
       id 'java-gradle-plugin'
   }
   
   repositories {
       mavenCentral()
   }
   
   gradlePlugin {
       plugins {
           create('standard-plugin') {
               id = 'reporters.standard.plugin'
               implementationClass = 'reporters.StandardPlugin'
           }
       }
   }

samples/ide/problems-api-usage/groovy/sample-ide/build.gradle

.. code-block::

   plugins {
       id 'application'
   }
   
   repositories {
       mavenCentral()
       maven {
           url = 'https://repo.gradle.org/artifactory/libs-releases'
       }
   }
   
   application {
       mainClass = 'org.gradle.sample.SampleIde'
   }
   
   dependencies {
       implementation('reporters:model-builder-plugin')
       implementation('org.gradle:gradle-tooling-api:8.6-milestone-1')
   }
   
   tasks.run.configure {
       args = [
           rootBuild(project.gradle).rootProject.projectDir.absolutePath, // The path of the project (this project's root)
           ':sample-project:assemble'  // The executed task
       ]
   }
   
   tasks.register('importBuild') {
       dependsOn(tasks.run)
   }
   
   Gradle rootBuild(Gradle gradle) {
       if (gradle?.parent) rootBuild(gradle.parent) else gradle
   }

samples/ide/problems-api-usage/groovy/sample-project/build.gradle

.. code-block::

   plugins {
       id 'java'
       id 'reporters.standard.plugin'
       id 'reporters.script.plugin'
   }

samples/ide/problems-api-usage/groovy/sample-project/settings.gradle

.. code-block::

   rootProject.name = 'sample-project'
   
   includeBuild('../reporters/standard-plugin')
   includeBuild('../reporters/script-plugin')

samples/ide/problems-api-usage/groovy/settings.gradle

.. code-block::

   rootProject.name = 'gradle-problems-sample'
   
   includeBuild('sample-ide')
   includeBuild('sample-project')
   includeBuild('reporters/standard-plugin')
   includeBuild('reporters/script-plugin')
   includeBuild('reporters/model-builder-plugin')
   

samples/ide/problems-api-usage/kotlin/build.gradle.kts

.. code-block::

   plugins {
       id("reporters.model.builder")
   }

samples/ide/problems-api-usage/kotlin/reporters/model-builder-plugin/build.gradle.kts

.. code-block::

   plugins {
       `java-gradle-plugin`
   }
   
   group = "reporters"
   
   repositories {
       mavenCentral()
   }
   
   gradlePlugin {
       plugins {
           create("model-builder-plugin") {
               id = "reporters.model.builder"
               implementationClass = "reporters.ModelBuilderPlugin"
           }
       }
   }

samples/ide/problems-api-usage/kotlin/reporters/script-plugin/build.gradle.kts

.. code-block::

   plugins {
       `kotlin-dsl`
   }
   
   repositories {
       mavenCentral()
   }

samples/ide/problems-api-usage/kotlin/reporters/script-plugin/src/main/kotlin/reporters/script.plugin.gradle.kts

.. code-block::

   package reporters
   import org.gradle.api.internal.GradleInternal
   import org.gradle.kotlin.dsl.registering
   
   val gradleInternal = gradle as GradleInternal
   val problems = gradleInternal.services.get(Problems::class.java)
   
   problems.forNamespace("buildscript").reporting {
       label("Deprecated script plugin 'demo-script-plugin'")
           .category("deprecation", "plugin")
           .severity(Severity.WARNING)
           .solution("Please use 'standard-plugin-2' instead of this plugin")
   }
   
   tasks {
       val warningTask by registering {
           doLast {
               problems.forNamespace("buildscript").reporting {
                   label("Task 'warningTask' is deprecated")
                       .category("deprecation", "task")
                       .severity(Severity.WARNING)
                       .solution("Please use 'warningTask2' instead of this task")
               }
           }
       }
   
       val failingTask by registering {
           doLast {
               problems.forNamespace("buildscript").throwing {
                   label("Task 'failingTask' should not be called")
                       .category("deprecation", "task")
                       .severity(Severity.ERROR)
                       .withException(RuntimeException("The 'failingTask' should not be called"))
                       .solution("Please use 'successfulTask' instead of this task")
               }
           }
       }
   }

samples/ide/problems-api-usage/kotlin/reporters/standard-plugin/build.gradle.kts

.. code-block::

   plugins {
       `java-gradle-plugin`
   }
   
   repositories {
       mavenCentral()
   }
   
   gradlePlugin {
       plugins {
           create("standard-plugin") {
               id = "reporters.standard.plugin"
               implementationClass = "reporters.StandardPlugin"
           }
       }
   }

samples/ide/problems-api-usage/kotlin/sample-ide/build.gradle.kts

.. code-block::

   import java.net.URI
   
   plugins {
       application
   }
   
   repositories {
       mavenCentral()
       maven {
           url = URI("https://repo.gradle.org/artifactory/libs-releases")
       }
   }
   
   application {
       mainClass.set("org.gradle.sample.SampleIde")
   }
   
   dependencies {
       implementation("reporters:model-builder-plugin")
       implementation("org.gradle:gradle-tooling-api:8.6-milestone-1")
   }
   
   tasks.run.configure {
       args = listOf(
           project.gradle.rootBuild().rootProject.projectDir.absolutePath, // The path of the project (this project's root)
           ":sample-project:assemble"  // The executed task
       )
   }
   
   tasks.register("importBuild") {
       dependsOn(tasks.run)
   }
   
   fun Gradle.rootBuild(): Gradle = parent?.rootBuild() ?: this

samples/ide/problems-api-usage/kotlin/sample-project/build.gradle.kts

.. code-block::

   plugins {
       java
       id("reporters.standard.plugin")
       id("reporters.script.plugin")
   }

samples/ide/problems-api-usage/kotlin/sample-project/settings.gradle.kts

.. code-block::

   rootProject.name = "sample-project"
   
   includeBuild("../reporters/standard-plugin")
   includeBuild("../reporters/script-plugin")

samples/ide/problems-api-usage/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "gradle-problems-sample"
   
   includeBuild("sample-ide")
   includeBuild("sample-project")
   includeBuild("reporters/standard-plugin")
   includeBuild("reporters/script-plugin")
   includeBuild("reporters/model-builder-plugin")
   

/Sample: 游릭 incubating/build-organization
======================================

samples/incubating/build-organization/publishing-convention-plugins/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how build logic can be organized into reusable pieces and published to a repository for reuse in other projects
   for multi-repo setups.
   
   NOTE: This sample shows how to adopt an link:#[existing sample] for use with Test Suites.
   
   IMPORTANT: Test Suites are an link:{userManualPath}#feature_lifecycle-sec:incubating_state[incubating] feature, and the details described here may change.
   
   == Use case
   
   As an example, let's say an organization produces two types of Java software - services and libraries.
   We want to apply a set of code quality checking rules to both types of projects and configure some aspects specific to each type.
   
   
   == Organizing build logic
   
   The use case can be modelled by layering three separate plugins:
   
   ====
   [.multi-language-sample]
   =====
   .Build logic layout
   [source, kotlin]
   ----
   較럭較 convention-plugins
   較   較럭較 build.gradle.kts
   較   較럭較 settings.gradle.kts
   較   較럭較 src
   較   較   較럭較 main
   較   較   較   較덕較 kotlin
   較   較   較       較럭較 com.myorg.java-conventions.gradle.kts
   較   較   較       較럭較 com.myorg.library-conventions.gradle.kts
   較   較   較       較덕較 com.myorg.service-conventions.gradle.kts
   ...
   ----
   =====
   [.multi-language-sample]
   =====
   .Build logic layout
   [source, groovy]
   ----
   較럭較 convention-plugins
   較   較럭較 build.gradle
   較   較럭較 settings.gradle
   較   較럭較 src
   較   較   較럭較 main
   較   較   較   較덕較 groovy
   較   較   較       較럭較 com.myorg.java-conventions.gradle
   較   較   較       較럭較 com.myorg.library-conventions.gradle
   較   較   較       較덕較 com.myorg.service-conventions.gradle
   ...
   ----
   =====
   ====
   
   * `com.myorg.java-conventions` - configures conventions that are generic for any Java project in the organization.
   This applies for both types of previously identified software and thus this plugin will be applied in both subsequent plugins.
   * `com.myorg.library-conventions` - adds publishing configuration to publish to the organization's repository and configures mandatory documentation checks.
   * `com.myorg.service-conventions` - configures integration tests and checks for mandatory content in a README.
   Since services differ from libraries, different requirements for documentation are configured in this case.
   
   All plugins created in this sample contain functional tests that use link:{userManualPath}#test_kit[TestKit] to verify their behavior.
   
   
   == Compiling convention plugins
   
   In this sample, convention plugins are implemented as link:{userManualPath}#custom_plugins-sec:precompiled_plugins[precompiled script plugins] -
   this is the simplest way to start out as you can use one of Gradle's DSLs directly to implement the build logic, just as if the plugin was
   a regular build script.
   
   [.multi-language-text.lang-kotlin]
   In order for precompiled script plugins to be discovered, the `convention-plugins` project needs to apply the `kotlin-dsl` plugin
   in its `build.gradle.kts` file:
   
   [.multi-language-text.lang-groovy]
   In order for precompiled script plugins to be discovered, the `convention-plugins` project needs to apply the `groovy-gradle-plugin` plugin
   in its `build.gradle` file:
   
   .Enabling precompiled script plugins
   ====
   include::sample[dir="kotlin",files="convention-plugins/build.gradle.kts[tags=apply]"]
   include::sample[dir="groovy",files="convention-plugins/build.gradle[tags=apply]"]
   ====
   
   == Publishing convention plugins
   
   In this sample we are targeting a multi-repo setup. In order to apply the above plugins to separate projects, they have to be published
   to a company's artifact repository.
   Convention plugins are regular Gradle plugins - thus they can be link:{userManualPath}#custom_plugins-sec:publishing_your_plugin[published to an external repository like any other Gradle plugin].
   
   Here, we configure the project to publish the plugins using the link:{userManualPath}#publishing_maven[maven-publish plugin].
   For demonstration purposes, we publish to a local filesystem directory.
   You can find information about how to publish to a remote repository in the link:{userManualPath}#publishing_maven-publishing_maven:repositories[repositories section of the maven-publish plugin].
   
   .Publishing configuration
   ====
   include::sample[dir="kotlin",files="convention-plugins/build.gradle.kts[tags=publish]"]
   include::sample[dir="groovy",files="convention-plugins/build.gradle[tags=publish]"]
   ====
   
   The plugins can be published using:
   
   ----
   ./gradlew publish
   ----
   
   In order to consume them in another project, configure the plugins repository in the settings file and apply the plugin:
   ====
   [.multi-language-sample]
   =====
   .settings.gradle.kts
   [source, kotlin]
   ----
   pluginManagement {
       repositories {
           gradlePluginPortal()
           maven {
               // replace the path with the actual path to the repository
               url = uri("<path-to>/convention-plugins/build/repo")
           }
       }
   }
   ----
   .build.gradle.kts
   [source, kotlin]
   ----
   plugins {
       id("com.myorg.service-conventions") version "1.0"
   }
   ----
   =====
   [.multi-language-sample]
   =====
   .settings.gradle
   [source, groovy]
   ----
   pluginManagement {
       repositories {
           gradlePluginPortal()
           maven {
               // replace the path with the actual path to the repository
               url = uri('<path-to>/convention-plugins/build/repo')
           }
       }
   }
   ----
   .build.gradle
   [source, groovy]
   ----
   plugins {
       id 'com.myorg.service-conventions' version '1.0'
   }
   ----
   =====
   ====
   
   == Things to note
   
   === Applying an external plugin in convention plugin
   
   The `com.myorg.java-conventions` plugin uses the SpotBugs plugin to perform static code analysis.
   
   SpotBugs is an external plugin - external plugins link:{userManualPath}#custom_plugins-applying_external_plugins_in_precompiled_script_plugins[need to be added as implementation dependencies] before they can be applied in a convention plugin:
   ====
   include::sample[dir="kotlin",files="convention-plugins/build.gradle.kts[tags=repositories-and-dependencies]"]
   include::sample[dir="groovy",files="convention-plugins/build.gradle[tags=repositories-and-dependencies]"]
   ====
   
   * The dependency artifact coordinates (GAV) for a plugin can be different from the plugin id.
   * The Gradle Plugin Portal (`gradlePluginPortal()`) is added as a repository for plugin dependencies.
   * The plugin version is determined from the dependency version.
   
   Once the dependency is added, the external plugin can be applied in a convention plugin by id:
   ====
   include::sample[dir="kotlin",files="convention-plugins/src/main/kotlin/com.myorg.java-conventions.gradle.kts[tags=apply-external-plugin]"]
   include::sample[dir="groovy",files="convention-plugins/src/main/groovy/com.myorg.java-conventions.gradle[tags=apply-external-plugin]"]
   ====
   
   === Applying other convention plugins
   
   Convention plugins can apply other convention plugins.
   
   The `com.myorg.library-conventions` and `com.myorg.service-conventions` plugins both apply the `com.myorg.java-conventions` plugin:
   ====
   include::sample[dir="kotlin",files="convention-plugins/src/main/kotlin/com.myorg.library-conventions.gradle.kts[tags=plugins];convention-plugins/src/main/kotlin/com.myorg.service-conventions.gradle.kts[tags=plugins]"]
   include::sample[dir="groovy",files="convention-plugins/src/main/groovy/com.myorg.library-conventions.gradle[tags=plugins];convention-plugins/src/main/groovy/com.myorg.service-conventions.gradle[tags=plugins]"]
   ====
   
   === Using classes from the main source set
   
   Convention plugins can use classes defined in the main source set of the plugins project.
   
   In this sample, `com.myorg.service-conventions` plugin uses a custom task class from `src/main/java` to configure service README checks:
   ====
   include::sample[dir="kotlin",files="convention-plugins/src/main/kotlin/com.myorg.service-conventions.gradle.kts[tags=use-java-class]"]
   include::sample[dir="groovy",files="convention-plugins/src/main/groovy/com.myorg.service-conventions.gradle[tags=use-java-class]"]
   ====
   
   For more details on authoring custom Gradle plugins, consult the link:{userManualPath}#custom_plugins[user manual].

samples/incubating/build-organization/publishing-convention-plugins/groovy/convention-plugins/build.gradle

.. code-block::

   // tag::apply[]
   // tag::publish[]
   plugins {
       id 'groovy-gradle-plugin'
   // end::apply[]
       id 'maven-publish'
       id 'java'
   // tag::apply[]
   }
   // end::apply[]
   
   group = 'com.myorg.conventions'
   version = '1.0'
   
   publishing {
       repositories {
           maven {
               // change to point to your repo, e.g. http://my.org/repo
               url = layout.buildDirectory.dir("repo")
           }
       }
   }
   
   tasks.named('publish') {
       dependsOn('check')
   }
   
   // end::publish[]
   
   testing {
       suites {
           test {
               useSpock()
           }
       }
   }
   
   // tag::repositories-and-dependencies[]
   repositories {
       gradlePluginPortal() // so that external plugins can be resolved in dependencies section
   }
   
   dependencies {
       implementation 'com.github.spotbugs.snom:spotbugs-gradle-plugin:5.2.1'
   }
   // end::repositories-and-dependencies[]

samples/incubating/build-organization/publishing-convention-plugins/groovy/convention-plugins/settings.gradle

.. code-block::

   rootProject.name = 'my-org-conventions'

samples/incubating/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/main/groovy/com.myorg.java-conventions.gradle

.. code-block::

   // Define Java conventions for this organization.
   // Projects need to use the Java, Checkstyle and Spotbugs plugins.
   
   // tag::apply-external-plugin[]
   plugins {
       id 'java'
       id 'checkstyle'
   
       // NOTE: external plugin version is specified in implementation dependency artifact of the project's build file
       id 'com.github.spotbugs'
   }
   // end::apply-external-plugin[]
   
   // Projects should use Maven Central for external dependencies
   // This could be the organization's private repository
   repositories {
       mavenCentral()
   }
   
   // Use the Checkstyle rules provided by the convention plugin
   // Do not allow any warnings
   checkstyle {
       config = resources.text.fromString(com.example.CheckstyleUtil.getCheckstyleConfig("/checkstyle.xml"))
       maxWarnings = 0
   }
   
   // Enable deprecation messages when compiling Java code
   tasks.withType(JavaCompile).configureEach {
       options.compilerArgs << "-Xlint:deprecation"
   }

samples/incubating/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/main/groovy/com.myorg.library-conventions.gradle

.. code-block::

   // Define Java Library conventions for this organization.
   // Projects need to use the organization's Java conventions and publish using Maven Publish
   
   // tag::plugins[]
   plugins {
       id 'java-library'
       id 'maven-publish'
       id 'com.myorg.java-conventions'
   }
   // end::plugins[]
   
   // Projects have the 'com.myorg' group by convention
   group = 'com.myorg'
   
   publishing {
       publications {
           library(MavenPublication) {
               from components.java
           }
       }
       repositories {
           maven {
               name "myOrgPrivateRepo"
               url 'build/my-repo'
           }
       }
   }
   
   // The project requires libraries to have a README containing sections configured below
   // tag::use-java-class[]
   def readmeCheck = tasks.register('readmeCheck', com.example.ReadmeVerificationTask) {
       // Expect the README in the project directory
       readme = layout.projectDirectory.file("README.md")
       // README must contain a Service API header
       readmePatterns = ['^## API$', '^## Changelog$']
   }
   // end::use-java-class[]
   
   tasks.named('check') { dependsOn(readmeCheck) }

samples/incubating/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/main/groovy/com.myorg.service-conventions.gradle

.. code-block::

   // Define conventions for service projects this organization.
   // Service projects need to use the organization's Java conventions and pass some additional checks
   
   // tag::plugins[]
   plugins {
       id 'com.myorg.java-conventions'
   }
   // end::plugins[]
   
   
   testing {
       suites {
           test {
               useJUnitJupiter('5.7.1')
           }
   
           integrationTest(JvmTestSuite) {
               dependencies {
                   implementation project()
               }
   
               targets {
                   all {
                       testTask.configure {
                           shouldRunAfter(test)
                       }
                   }
               }
           }
       }
   }
   
   // The organization requires additional documentation in the README for this project
   // tag::use-java-class[]
   def readmeCheck = tasks.register('readmeCheck', com.example.ReadmeVerificationTask) {
       // Expect the README in the project directory
       readme = layout.projectDirectory.file("README.md")
       // README must contain a Service API header
       readmePatterns = ['^## Service API$']
   }
   // end::use-java-class[]
   
   tasks.named('check') { dependsOn(testing.suites.integrationTest, readmeCheck) }

samples/incubating/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/test/groovy/com/myorg/JavaConventionPluginTest.groovy

.. code-block::

   package com.myorg
   
   import org.gradle.testkit.runner.TaskOutcome
   
   class JavaConventionPluginTest extends PluginTest {
   
       def setup() {
           buildFile << """
               plugins {
                   id 'com.myorg.java-conventions'
               }
           """
       }
   
       def "fails on checkstyle error"() {
           given:
           new File(testProjectDir, 'src/main/java/com/myorg').mkdirs()
           new File(testProjectDir, 'src/main/java/com/myorg/Foo.java') << """
               package com.myorg;
   
               import java.util.*;
   
               class Foo {
                   void bar() {
                   }
               }
           """
   
           when:
           def result = runTaskWithFailure('build')
   
           then:
           result.task(":checkstyleMain").outcome == TaskOutcome.FAILED
           result.output.contains('Checkstyle rule violations were found.')
           result.output.contains('Checkstyle violations by severity: [error:1]')
       }
   
       def "fails on checkstyle warning"() {
           given:
           new File(testProjectDir, 'src/main/java/com/myorg').mkdirs()
           new File(testProjectDir, 'src/main/java/com/myorg/Foo.java') << """
               package com.myorg;
   
               class Foo {
                   final static public String FOO = "BAR";
   
                   void bar() {
                   }
               }
           """
   
           when:
           def result = runTaskWithFailure('build')
   
           then:
           result.task(":checkstyleMain").outcome == TaskOutcome.FAILED
           result.output.contains('Checkstyle rule violations were found.')
           result.output.contains('Checkstyle violations by severity: [warning:1]')
       }
   
       def "fails on spotbugs error"() {
           given:
           new File(testProjectDir, 'src/main/java/com/myorg').mkdirs()
           new File(testProjectDir, 'src/main/java/com/myorg/Foo.java') << """
               package com.myorg;
   
               class Foo {
                   void bar() {
                       String s = null;
                       s.hashCode();
                   }
               }
           """
   
           when:
           def result = runTaskWithFailure('build')
   
           then:
           result.task(":spotbugsMain").outcome == TaskOutcome.FAILED
       }
   
       def "warns on deprecated API usage"() {
           given:
           new File(testProjectDir, 'src/main/java/com/myorg').mkdirs()
           new File(testProjectDir, 'src/main/java/com/myorg/Foo.java') << """
               package com.myorg;
   
               public class Foo {
                   @Deprecated
                   public void deprecatedMethod() {}
               }
           """
   
           new File(testProjectDir, 'src/main/java/com/myorg/Bar.java') << """
               package com.myorg;
   
               public class Bar {
                   public void bar() {
                       new Foo().deprecatedMethod();
                   }
               }
           """
   
           when:
           def result = runTask('build')
   
           then:
           result.task(":build").outcome == TaskOutcome.SUCCESS
           result.output.contains('warning: [deprecation] deprecatedMethod()')
       }
   }

samples/incubating/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/test/groovy/com/myorg/LibraryPluginTest.groovy

.. code-block::

   package com.myorg
   
   import org.gradle.testkit.runner.TaskOutcome
   
   class LibraryPluginTest extends PluginTest {
   
       def setup() {
           buildFile << """
               plugins {
                   id 'com.myorg.library-conventions'
               }
           """
       }
   
       def "can declare api dependencies"() {
           given:
           readmeContainingMandatorySectionsExists()
           buildFile << """
               dependencies {
                   api 'org.apache.commons:commons-lang3:3.4'
               }
           """
   
           when:
           def result = runTask('build')
   
           then:
           result.task(":build").outcome == TaskOutcome.SUCCESS
       }
   
       def "publishes library with versionin"() {
           given:
           readmeContainingMandatorySectionsExists()
           settingsFile.setText("rootProject.name = 'my-library'")
           buildFile << """
               version = '0.1.0'
   
               publishing {
                   repositories {
                       maven {
                           name 'testRepo'
                           url 'build/test-repo'
                       }
                   }
               }
           """
   
           new File(testProjectDir, 'src/main/java/com/myorg').mkdirs()
           new File(testProjectDir, 'src/main/java/com/myorg/Util.java') << """
               package com.myorg;
   
               public class Util {
                   public static void someUtil() {
                   }
               }
           """
   
           when:
           def result = runTask('publishLibraryPublicationToTestRepoRepository')
   
           then:
           result.task(":jar").outcome == TaskOutcome.SUCCESS
           result.task(":publishLibraryPublicationToTestRepoRepository").outcome == TaskOutcome.SUCCESS
           new File(testProjectDir, 'build/test-repo/com/myorg/my-library/0.1.0/my-library-0.1.0.jar').exists()
       }
   
       def "fails when no README exists"() {
           when:
           def result = runTaskWithFailure('check')
   
           then:
           result.task(":readmeCheck").outcome == TaskOutcome.FAILED
       }
   
       def "fails when README does not have API section"() {
           given:
           new File(testProjectDir, 'README.md') << """
   ## Changelog
   - change 1
   - change 2
           """
   
           when:
           def result = runTaskWithFailure('check')
   
           then:
           result.task(":readmeCheck").outcome == TaskOutcome.FAILED
           result.output.contains('README should contain section: ^## API$')
       }
   
       def "fails when README does not have Changelog section"() {
           given:
           new File(testProjectDir, 'README.md') << """
   ## API
   public API description
           """
   
           when:
           def result = runTaskWithFailure('check')
   
           then:
           result.task(":readmeCheck").outcome == TaskOutcome.FAILED
           result.output.contains('README should contain section: ^## Changelog')
       }
   
       private def readmeContainingMandatorySectionsExists() {
           new File(testProjectDir, 'README.md') << """
   ## API
   public API description
   
   ## Changelog
   - change 1
   - change 2
           """
       }
   }

samples/incubating/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/test/groovy/com/myorg/PluginTest.groovy

.. code-block::

   package com.myorg
   
   import org.gradle.testkit.runner.GradleRunner
   import spock.lang.Specification
   import spock.lang.TempDir
   
   abstract class PluginTest extends Specification {
       @TempDir
       File testProjectDir
       File settingsFile
       File buildFile
   
       def setup() {
           settingsFile = new File(testProjectDir, 'settings.gradle').tap { it << "rootProject.name = 'test'" }
           buildFile = new File(testProjectDir, 'build.gradle')
       }
   
       def runTask(String task) {
           return GradleRunner.create()
                   .withProjectDir(testProjectDir)
                   .withArguments(task, '--stacktrace')
                   .withPluginClasspath()
                   .build()
       }
   
       def runTaskWithFailure(String task) {
           return GradleRunner.create()
                   .withProjectDir(testProjectDir)
                   .withArguments(task, '--stacktrace')
                   .withPluginClasspath()
                   .buildAndFail()
       }
   }

samples/incubating/build-organization/publishing-convention-plugins/groovy/convention-plugins/src/test/groovy/com/myorg/ServicePluginTest.groovy

.. code-block::

   package com.myorg
   
   
   import org.gradle.testkit.runner.TaskOutcome
   
   class ServicePluginTest extends PluginTest {
   
       def setup() {
           buildFile << """
               plugins {
                   id 'com.myorg.service-conventions'
               }
           """
       }
   
       def "integrationTest and readmeCheck tasks run with check task"() {
           given:
           new File(testProjectDir, 'README.md') << """
   ## Service API
   
           """
   
           when:
           def result = runTask('check')
   
           then:
           result.task(":test").outcome == TaskOutcome.NO_SOURCE
           result.task(":integrationTest").outcome == TaskOutcome.NO_SOURCE
           result.task(":readmeCheck").outcome == TaskOutcome.SUCCESS
       }
   
       def "can use integrationTest configuration to define dependencies"() {
           given:
           buildFile << """
               dependencies {
                   integrationTestImplementation 'junit:junit:4.13'
               }
           """
   
           new File(testProjectDir, 'src/integrationTest/java/com/myorg').mkdirs()
           new File(testProjectDir, 'src/integrationTest/java/com/myorg/SomeIntegrationTest.java') << """
               package com.myorg;
   
               import org.junit.Test;
   
               public class SomeIntegrationTest {
                   @Test
                   public void sampleTest() {
                   }
               }
           """
   
           when:
           def result = runTask('integrationTest')
   
           then:
           result.task(":integrationTest").outcome == TaskOutcome.SUCCESS
       }
   
       def "fails when no README exists"() {
           when:
           def result = runTaskWithFailure('check')
   
           then:
           result.task(":readmeCheck").outcome == TaskOutcome.FAILED
       }
   
       def "fails when README does not have service API section"() {
           given:
           new File(testProjectDir, 'README.md') << """
   asdfadfsasf
           """
   
           when:
           def result = runTaskWithFailure('check')
   
           then:
           result.task(":readmeCheck").outcome == TaskOutcome.FAILED
           result.output.contains('README should contain section: ^## Service API$')
       }
   }

samples/incubating/build-organization/publishing-convention-plugins/groovy/settings.gradle

.. code-block::

   rootProject.name = 'convention-plugins'
   
   include 'convention-plugins'

samples/incubating/build-organization/publishing-convention-plugins/kotlin/convention-plugins/build.gradle.kts

.. code-block::

   // tag::apply[]
   // tag::publish[]
   plugins {
       `kotlin-dsl`
   // end::apply[]
       `maven-publish`
   // tag::apply[]
   }
   // end::apply[]
   
   group = "com.myorg.conventions"
   version = "1.0"
   
   publishing {
       repositories {
           maven {
               // change to point to your repo, e.g. http://my.org/repo
               url = uri(layout.buildDirectory.dir("repo"))
           }
       }
   }
   
   tasks.publish {
       dependsOn("check")
   }
   // end::publish[]
   
   
   testing {
       suites {
           val test by getting(JvmTestSuite::class) {
               useJUnit()
           }
       }
   }
   
   // tag::repositories-and-dependencies[]
   repositories {
       gradlePluginPortal() // so that external plugins can be resolved in dependencies section
   }
   
   dependencies {
       implementation("com.github.spotbugs.snom:spotbugs-gradle-plugin:5.2.1")
   }
   // end::repositories-and-dependencies[]

samples/incubating/build-organization/publishing-convention-plugins/kotlin/convention-plugins/settings.gradle.kts

.. code-block::

   rootProject.name="my-org-conventions"

samples/incubating/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/main/kotlin/com.myorg.java-conventions.gradle.kts

.. code-block::

   // Define Java conventions for this organization.
   // Projects need to use the Java, Checkstyle and Spotbugs plugins.
   
   // tag::apply-external-plugin[]
   plugins {
       java
       checkstyle
   
       // NOTE: external plugin version is specified in implementation dependency artifact of the project's build file
       id("com.github.spotbugs")
   }
   // end::apply-external-plugin[]
   
   // Projects should use Maven Central for external dependencies
   // This could be the organization's private repository
   repositories {
       mavenCentral()
   }
   
   // Use the Checkstyle rules provided by the convention plugin
   // Do not allow any warnings
   checkstyle {
       config = resources.text.fromString(com.example.CheckstyleUtil.getCheckstyleConfig("/checkstyle.xml"))
       maxWarnings = 0
   }
   
   // Enable deprecation messages when compiling Java code
   tasks.withType<JavaCompile>().configureEach {
       options.compilerArgs.add("-Xlint:deprecation")
   }

samples/incubating/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/main/kotlin/com.myorg.library-conventions.gradle.kts

.. code-block::

   // Define Java Library conventions for this organization.
   // Projects need to use the organization's Java conventions and publish using Maven Publish
   
   // tag::plugins[]
   plugins {
       `java-library`
       `maven-publish`
       id("com.myorg.java-conventions")
   }
   // end::plugins[]
   
   // Projects have the 'com.myorg' group by convention
   group = "com.myorg"
   
   publishing {
       publications {
           create<MavenPublication>("library") {
               from(components["java"])
           }
       }
       repositories {
           maven {
               name = "myOrgPrivateRepo"
               url = uri("build/my-repo")
           }
       }
   }
   
   // The project requires libraries to have a README containing sections configured below
   // tag::use-java-class[]
   val readmeCheck by tasks.registering(com.example.ReadmeVerificationTask::class) {
       readme = layout.projectDirectory.file("README.md")
       readmePatterns = listOf("^## API$", "^## Changelog$")
   }
   // end::use-java-class[]
   
   tasks.named("check") { dependsOn(readmeCheck) }

samples/incubating/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/main/kotlin/com.myorg.service-conventions.gradle.kts

.. code-block::

   // Define conventions for service projects this organization.
   // Service projects need to use the organization's Java conventions and pass some additional checks
   
   // tag::plugins[]
   plugins {
       id("com.myorg.java-conventions")
   }
   // end::plugins[]
   
   testing {
       suites {
           val test by getting(JvmTestSuite::class) {
               useJUnitJupiter("5.7.1")
           }
   
           val integrationTest by registering(JvmTestSuite::class) {
               dependencies {
                   implementation(project())
               }
   
               targets {
                   all {
                       testTask.configure {
                           shouldRunAfter(test)
                       }
                   }
               }
           }
       }
   }
   
   // The organization requires additional documentation in the README for this project
   // tag::use-java-class[]
   val readmeCheck by tasks.registering(com.example.ReadmeVerificationTask::class) {
       readme = layout.projectDirectory.file("README.md")
       readmePatterns = listOf("^## Service API$")
   }
   // end::use-java-class[]
   
   tasks.named("check") {
       dependsOn(testing.suites.named("integrationTest"), readmeCheck)
   }

samples/incubating/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/test/kotlin/com/myorg/JavaConventionPluginTest.kt

.. code-block::

   package com.myorg
   
   import org.gradle.testkit.runner.TaskOutcome
   import org.junit.Assert.assertEquals
   import org.junit.Assert.assertTrue
   import org.junit.Before
   import org.junit.Test
   
   class JavaConventionPluginTest : PluginTest() {
   
       @Before
       fun init() {
           buildFile.appendText("""
               plugins {
                   id("com.myorg.java-conventions")
               }
           """)
       }
   
       @Test
       fun `fails on checkstyle error`() {
           testProjectDir.newFolder("src", "main", "java", "com", "myorg")
           testProjectDir.newFile("src/main/java/com/myorg/Foo.java").appendText("""
               package com.myorg;
   
               import java.util.*;
   
               class Foo {
                   void bar() {
                   }
               }
           """)
   
           val result = runTaskWithFailure("build")
   
           assertEquals(TaskOutcome.FAILED, result.task(":checkstyleMain")?.outcome)
           assertTrue(result.output.contains("Checkstyle rule violations were found."))
           assertTrue(result.output.contains("Checkstyle violations by severity: [error:1]"))
       }
   
       @Test
       fun `fails on checkstyle warning`() {
           testProjectDir.newFolder("src", "main", "java", "com", "myorg")
           testProjectDir.newFile("src/main/java/com/myorg/Foo.java").writeText("""
               package com.myorg;
   
               class Foo {
                   final static public String FOO = "BAR";
   
                   void bar() {
                   }
               }
           """)
   
           val result = runTaskWithFailure("build")
   
           assertEquals(TaskOutcome.FAILED, result.task(":checkstyleMain")?.outcome)
           assertTrue(result.output.contains("Checkstyle rule violations were found."))
           assertTrue(result.output.contains("Checkstyle violations by severity: [warning:1]"))
       }
   
       @Test
       fun `fails on spotbugs error`() {
           testProjectDir.newFolder("src", "main", "java", "com", "myorg")
           testProjectDir.newFile("src/main/java/com/myorg/Foo.java").writeText("""
               package com.myorg;
   
               class Foo {
                   void bar() {
                       String s = null;
                       s.hashCode();
                   }
               }
           """)
   
           val result = runTaskWithFailure("build")
   
           assertEquals(TaskOutcome.FAILED, result.task(":spotbugsMain")?.outcome)
       }
   
       @Test
       fun `warns on deprecated API usage`() {
           testProjectDir.newFolder("src", "main", "java", "com", "myorg")
           testProjectDir.newFile("src/main/java/com/myorg/Foo.java").writeText("""
               package com.myorg;
   
               public class Foo {
                   @Deprecated
                   public void deprecatedMethod() {}
               }
           """)
   
           testProjectDir.newFile("src/main/java/com/myorg/Bar.java").writeText("""
               package com.myorg;
   
               public class Bar {
                   public void bar() {
                       new Foo().deprecatedMethod();
                   }
               }
           """)
   
           val result = runTask("build")
   
           assertEquals(TaskOutcome.SUCCESS, result.task(":build")?.outcome)
           assertTrue(result.output.contains("warning: [deprecation] deprecatedMethod()"))
       }
   }

samples/incubating/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/test/kotlin/com/myorg/LibraryPluginTest.kt

.. code-block::

   package com.myorg
   
   import org.gradle.testkit.runner.TaskOutcome
   import org.junit.Assert.assertEquals
   import org.junit.Assert.assertTrue
   import org.junit.Before
   import org.junit.Test
   import java.io.File
   
   class LibraryPluginTest : PluginTest() {
   
       @Before
       fun init() {
           buildFile.appendText("""
               plugins {
                   id("com.myorg.library-conventions")
               }
           """)
       }
   
       @Test
       fun `can declare api dependencies`() {
           readmeContainingMandatorySectionsExists()
           buildFile.appendText("""
               dependencies {
                   api("org.apache.commons:commons-lang3:3.4")
               }
           """)
   
           val result = runTask("build")
   
           assertEquals(TaskOutcome.SUCCESS, result.task(":build")?.outcome)
       }
   
       @Test
       fun `publishes library with versionin`() {
           readmeContainingMandatorySectionsExists()
           settingsFile.writeText("""
               rootProject.name = "my-library"
           """.trimIndent())
           buildFile.appendText("""
               version = "0.1.0"
   
               publishing {
                   repositories {
                       maven {
                           name = "testRepo"
                           url = uri("build/test-repo")
                       }
                   }
               }
           """)
   
           testProjectDir.newFolder("src", "main", "java", "com", "myorg")
           testProjectDir.newFile("src/main/java/com/myorg/Util.java").writeText("""
               package com.myorg;
   
               public class Util {
                   public static void someUtil() {
                   }
               }
           """)
   
           val result = runTask("publishLibraryPublicationToTestRepoRepository")
   
           assertEquals(TaskOutcome.SUCCESS, result.task(":jar")?.outcome)
           assertEquals(TaskOutcome.SUCCESS, result.task(":publishLibraryPublicationToTestRepoRepository")?.outcome)
           assertTrue(File(testProjectDir.getRoot(), "build/test-repo/com/myorg/my-library/0.1.0/my-library-0.1.0.jar").exists())
       }
   
       @Test
       fun `fails when no README exists`() {
           val result = runTaskWithFailure ("check")
   
           assertEquals(TaskOutcome.FAILED, result.task(":readmeCheck")?.outcome)
       }
   
       @Test
       fun `fails when README does not have API section`() {
           testProjectDir.newFile("README.md").writeText("""
               ## Changelog
               - change 1
               - change 2
           """.trimIndent())
   
           val result = runTaskWithFailure ("check")
   
           assertEquals(TaskOutcome.FAILED, result.task(":readmeCheck")?.outcome)
           assertTrue(result.output.contains("README should contain section: ^## API$"))
       }
   
       @Test
       fun `fails when README does not have Changelog section`() {
           testProjectDir.newFile("README.md").writeText("""
               ## API
               public API description
           """.trimIndent())
   
           val result = runTaskWithFailure ("check")
   
           assertEquals(TaskOutcome.FAILED, result.task(":readmeCheck")?.outcome)
           assertTrue(result.output.contains("README should contain section: ^## Changelog$"))
       }
   
       private fun readmeContainingMandatorySectionsExists() {
           testProjectDir.newFile("README.md").writeText("""
               ## API
               public API description
   
               ## Changelog
               - change 1
               - change 2
           """.trimIndent())
       }
   }

samples/incubating/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/test/kotlin/com/myorg/PluginTest.kt

.. code-block::

   package com.myorg
   
   import org.gradle.testkit.runner.BuildResult
   import org.gradle.testkit.runner.GradleRunner
   import org.junit.Before
   import org.junit.Rule
   import org.junit.rules.TemporaryFolder
   import java.io.File
   
   abstract class PluginTest {
   
       @Rule
       @JvmField
       val testProjectDir: TemporaryFolder = TemporaryFolder()
       protected lateinit var settingsFile: File
       protected lateinit var buildFile: File
   
       @Before
       fun setup() {
           settingsFile = testProjectDir.newFile("settings.gradle.kts")
           settingsFile.appendText("""
               rootProject.name = "test"
           """)
           buildFile = testProjectDir.newFile("build.gradle.kts")
       }
   
       fun runTask(task: String): BuildResult {
           return GradleRunner.create()
                   .withProjectDir(testProjectDir.root)
                   .withArguments(task, "--stacktrace")
                   .withPluginClasspath()
                   .build()
       }
   
       fun runTaskWithFailure(task: String): BuildResult {
           return GradleRunner.create()
                   .withProjectDir(testProjectDir.root)
                   .withArguments(task, "--stacktrace")
                   .withPluginClasspath()
                   .buildAndFail()
       }
   }

samples/incubating/build-organization/publishing-convention-plugins/kotlin/convention-plugins/src/test/kotlin/com/myorg/ServicePluginTest.kt

.. code-block::

   package com.myorg
   
   
   import org.gradle.testkit.runner.TaskOutcome
   import org.junit.Assert.assertEquals
   import org.junit.Assert.assertTrue
   import org.junit.Before
   import org.junit.Test
   
   class ServicePluginTest : PluginTest() {
   
       @Before
       fun init() {
           buildFile.appendText("""
               plugins {
                   id("com.myorg.service-conventions")
               }
           """)
       }
   
       @Test
       fun `integrationTest and readmeCheck tasks run with check task`() {
           testProjectDir.newFile("README.md").writeText("""
               ## Service API
   
           """.trimIndent())
   
           val result = runTask("check")
   
           assertEquals(TaskOutcome.NO_SOURCE, result.task(":test")?.outcome)
           assertEquals(TaskOutcome.NO_SOURCE, result.task(":integrationTest")?.outcome)
           assertEquals(TaskOutcome.SUCCESS, result.task(":readmeCheck")?.outcome)
       }
   
       @Test
       fun `can use integrationTest configuration to define dependencies`() {
           buildFile.appendText("""
               dependencies {
                   integrationTestImplementation("junit:junit:4.13")
               }
           """)
   
           testProjectDir.newFolder("src", "integrationTest", "java", "com", "myorg")
           testProjectDir.newFile("src/integrationTest/java/com/myorg/SomeIntegrationTest.java").writeText("""
               package com.myorg;
   
               import org.junit.Test;
   
               public class SomeIntegrationTest {
                   @Test
                   public void sampleTest() {
                   }
               }
           """)
   
           val result = runTask ("integrationTest")
   
           assertEquals(TaskOutcome.SUCCESS, result.task(":integrationTest")?.outcome)
       }
   
       @Test
       fun `fails when no README exists`() {
           val result = runTaskWithFailure ("check")
   
           assertEquals(TaskOutcome.FAILED, result.task(":readmeCheck")?.outcome)
       }
   
       @Test
       fun `fails when README does not have service API section`() {
           testProjectDir.newFile("README.md").writeText("""
               asdfadfsasf
           """.trimIndent())
   
           val result = runTaskWithFailure ("check")
   
           assertEquals(TaskOutcome.FAILED, result.task(":readmeCheck")?.outcome)
           assertTrue(result.output.contains("README should contain section: ^## Service API$"))
       }
   }

samples/incubating/build-organization/publishing-convention-plugins/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "convention-plugins"
   
   include("convention-plugins")

samples/incubating/build-organization/publishing-convention-plugins/tests/publish.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: publish
   }]

/Sample: 游릭 incubating/java/jvm-multi-project-with-additional-test-types
=====================================================================

samples/incubating/java/jvm-multi-project-with-additional-test-types/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how to add additional test types to a JVM project in Gradle. Your project may have many different kinds of tests--unit tests, integration tests, functional tests, etc. A JVM project in Gradle has a single `Test` task, but other tasks can be added to represent each of these test types using the link:{userManualPath}#jvm_test_suite_plugin[Test Suite Plugin].
   
   NOTE: This sample shows how to adopt an link:#[existing sample] for use with Test Suites.
   
   IMPORTANT: Test Suites are an link:{userManualPath}#feature_lifecycle-sec:incubating_state[incubating] feature, and the details described here may change.
   
   In this sample, we are testing Java projects with JUnit5; however, this applies to other JVM languages as well.
   
   Concretely, we add a _convention plugin_ in `buildSrc` to share the integration test setup between multiple subprojects:
   
   ====
   include::sample[dir="kotlin",files="buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts[]"]
   include::sample[dir="groovy",files="buildSrc/src/main/groovy/myproject.java-conventions.gradle[]"]
   ====
   
   And apply it in an application project:
   
   ====
   include::sample[dir="kotlin",files="application/build.gradle.kts[]"]
   include::sample[dir="groovy",files="application/build.gradle[]"]
   ====
   
   And in library projects:
   
   ====
   include::sample[dir="kotlin",files="utilities/build.gradle.kts[]"]
   include::sample[dir="groovy",files="utilities/build.gradle[]"]
   ====
   
   These additional tests can be executed with the `integrationTest` task or as part of lifecycle `check`:
   
   [listing.terminal.sample-command]
   ----
   $ ./gradlew check
   
   BUILD SUCCESSFUL
   14 actionable tasks: 14 executed
   ----
   
   For more information, see link:{userManualPath}#java_testing-sec:configuring_java_integration_tests[section Configuring integration tests in the Testing in Java project chapter].

samples/incubating/java/jvm-multi-project-with-additional-test-types/groovy/application/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'application'
   }
   
   dependencies {
       implementation project(':utilities')
   }
   
   application {
       mainClass = 'org.gradle.sample.app.Main'
   }

samples/incubating/java/jvm-multi-project-with-additional-test-types/groovy/buildSrc/build.gradle

.. code-block::

   plugins {
       id 'groovy-gradle-plugin'
   }

samples/incubating/java/jvm-multi-project-with-additional-test-types/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle

.. code-block::

   plugins {
       id 'java'
   }
   
   version = '1.0.2'
   group = 'org.gradle.sample'
   
   repositories {
       mavenCentral()
   }
   
   testing {
       suites {
           test {
               useJUnitJupiter('5.7.1')
           }
   
           integrationTest(JvmTestSuite) {
               dependencies {
                   implementation project()
               }
   
               targets {
                   all {
                       testTask.configure {
                           shouldRunAfter(test)
                       }
                   }
               }
           }
       }
   }
   
   tasks.named('check') {
       dependsOn(testing.suites.integrationTest)
   }

samples/incubating/java/jvm-multi-project-with-additional-test-types/groovy/list/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }

samples/incubating/java/jvm-multi-project-with-additional-test-types/groovy/settings.gradle

.. code-block::

   rootProject.name = 'multi-project-with-additional-test-types'
   include 'application', 'list', 'utilities'

samples/incubating/java/jvm-multi-project-with-additional-test-types/groovy/utilities/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }
   
   dependencies {
       api project(':list')
   }

samples/incubating/java/jvm-multi-project-with-additional-test-types/kotlin/application/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       application
   }
   
   dependencies {
       implementation(project(":list"))
       implementation(project(":utilities"))
   }
   
   application {
       mainClass = "org.gradle.sample.app.Main"
   }

samples/incubating/java/jvm-multi-project-with-additional-test-types/kotlin/buildSrc/build.gradle.kts

.. code-block::

   plugins {
       `kotlin-dsl`
   }
   
   repositories {
       mavenCentral()
   }

samples/incubating/java/jvm-multi-project-with-additional-test-types/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts

.. code-block::

   plugins {
       java
   }
   
   version = "1.0.2"
   group = "org.gradle.sample"
   
   repositories {
       mavenCentral()
   }
   
   testing {
       suites {
           val test by getting(JvmTestSuite::class) {
               useJUnitJupiter("5.7.1")
           }
   
           val integrationTest by registering(JvmTestSuite::class) {
               dependencies {
                   implementation(project())
               }
   
               targets {
                   all {
                       testTask.configure {
                           shouldRunAfter(test)
                       }
                   }
               }
           }
       }
   }
   
   tasks.named("check") {
       dependsOn(testing.suites.named("integrationTest"))
   }

samples/incubating/java/jvm-multi-project-with-additional-test-types/kotlin/list/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       `java-library`
   }

samples/incubating/java/jvm-multi-project-with-additional-test-types/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "multi-project-with-additional-test-types"
   include("application", "list", "utilities")

samples/incubating/java/jvm-multi-project-with-additional-test-types/kotlin/utilities/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       `java-library`
   }
   
   dependencies {
       api(project(":list"))
   }

samples/incubating/java/jvm-multi-project-with-additional-test-types/tests/checkTask.out

.. code-block::

   > Task :buildSrc:processResources
   > Task :buildSrc:pluginDescriptors
   > Task :buildSrc:classes
   > Task :buildSrc:jar
   > Task :list:compileJava
   > Task :utilities:compileJava
   > Task :application:compileJava
   > Task :application:processResources NO-SOURCE
   > Task :application:classes
   > Task :application:compileTestJava
   > Task :application:processTestResources NO-SOURCE
   > Task :application:testClasses
   > Task :list:processResources NO-SOURCE
   > Task :list:classes
   > Task :list:jar
   > Task :utilities:processResources NO-SOURCE
   > Task :utilities:classes
   > Task :utilities:jar
   > Task :application:test
   > Task :application:compileIntegrationTestJava
   > Task :application:processIntegrationTestResources NO-SOURCE
   > Task :application:integrationTestClasses
   > Task :application:integrationTest
   > Task :application:check
   > Task :list:compileTestJava
   > Task :list:processTestResources NO-SOURCE
   > Task :list:testClasses
   > Task :list:test
   > Task :list:compileIntegrationTestJava NO-SOURCE
   > Task :list:processIntegrationTestResources NO-SOURCE
   > Task :list:integrationTestClasses UP-TO-DATE
   > Task :list:integrationTest NO-SOURCE
   > Task :list:check
   > Task :utilities:compileTestJava NO-SOURCE
   > Task :utilities:processTestResources NO-SOURCE
   > Task :utilities:testClasses UP-TO-DATE
   > Task :utilities:test NO-SOURCE
   > Task :utilities:compileIntegrationTestJava
   > Task :utilities:processIntegrationTestResources NO-SOURCE
   > Task :utilities:integrationTestClasses
   > Task :utilities:integrationTest
   > Task :utilities:check
   
   BUILD SUCCESSFUL in 0s

samples/incubating/java/jvm-multi-project-with-additional-test-types/tests/checkTask.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: check
       expected-output-file: checkTask.out
       allow-additional-output: true
       allow-disordered-output: true
   }]

/Sample: 游릭 incubating/java/jvm-multi-project-with-code-coverage-distribution
==========================================================================

samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how to aggregate code coverage across multiple Java subprojects using link:https://www.jacoco.org/jacoco/[JaCoCo].  The link:{userManualPath}#jacoco_report_aggregation_plugin[jacoco-report-aggregation plugin] provides this ability when applied to the distribution project, such as an Android application or WAR subproject.
   
   The project in this example contains three projects: `application`, `list` and `utilities`.  All three projects apply the `jacoco` plugin, and `application` consumes both `list` and `utilities` on its implementation configuration.  The `application` subproject is the final distribution of this software project, and applies `jacoco-report-aggregation` to perform the code coverage aggregation.
   
   WARNING: The Test Report Aggregation plugin does not currently work with the ``com.android.application`` plugin.
   
   ====
   include::sample[dir="kotlin",files="application/build.gradle.kts[]"]
   include::sample[dir="groovy",files="application/build.gradle[]"]
   ====
   
   The `application` project requires no additional configuration if the `jvm-test-suite` plugin is present.
   
   <1> Apply the `jacoco-report-aggregation` plugin
   <2> Optional: make JaCoCo aggregate report generation part of the 'check' lifecycle phase
   
   The report aggregation logic does not automatically inspect all subprojects for coverage data to aggregate.  Instead, the direct and transitive <<declaring_dependencies.adoc#sub:project_dependencies,project dependencies>> of the distribution project's runtime classpath are selected for potential aggregation.
   
   For the default test suite named 'test', no additional configuration is necessary.  The aggregated reports and their backing tasks of type `JacocoReport` are synthesized based on the test suites existing in the `application` project.  Test suites having identical `testType` properties will be aggregated.
   
   Running the tests and generate the report:
   
   [listing.terminal.sample-command]
   ----
   $ ./gradlew testCodeCoverageReport
   
   BUILD SUCCESSFUL
   25 actionable tasks: 25 executed
   ----
   
   XML and HTML reports can now be found under `application/build/reports/jacoco/testCodeCoverageReport`.
   
   For more information, see link:{userManualPath}#java_testing[Testing in Java project chapter].

samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/groovy/application/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'application'
       id 'jacoco-report-aggregation' // <1>
   }
   
   dependencies {
       implementation project(':list')
       implementation project(':utilities')
   }
   
   application {
       mainClass = 'org.gradle.sample.Main'
   }
   
   tasks.named('check') {
       dependsOn tasks.named('testCodeCoverageReport', JacocoReport) // <2>
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/groovy/buildSrc/build.gradle

.. code-block::

   plugins {
       id 'groovy-gradle-plugin'
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle

.. code-block::

   plugins {
       id 'java'
       id 'jacoco'
   }
   
   version = '1.0.2'
   group = 'org.gradle.sample'
   
   repositories {
       mavenCentral()
   }
   
   testing {
       suites {
           test(JvmTestSuite) {
               useJUnitJupiter()
           }
       }
   }
   
   // Do not generate reports for individual projects
   tasks.named("jacocoTestReport") {
       enabled = false
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/groovy/list/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/groovy/settings.gradle

.. code-block::

   rootProject.name = 'jvm-multi-project-with-code-coverage-distribution'
   
   // production code projects
   include 'application', 'list', 'utilities'

samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/groovy/utilities/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }
   
   dependencies {
       implementation project(':list')
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/kotlin/application/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       application
       id("jacoco-report-aggregation") // <1>
   }
   
   dependencies {
       implementation(project(":list"))
       implementation(project(":utilities"))
   }
   
   application {
       mainClass = "org.gradle.sample.Main"
   }
   
   tasks.check {
       dependsOn(tasks.named<JacocoReport>("testCodeCoverageReport")) // <2>
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/kotlin/buildSrc/build.gradle.kts

.. code-block::

   plugins {
       `kotlin-dsl`
   }
   
   repositories {
       mavenCentral()
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts

.. code-block::

   plugins {
       java
       jacoco
   }
   
   version = "1.0.2"
   group = "org.gradle.sample"
   
   repositories {
       mavenCentral()
   }
   
   testing {
       suites {
           val test by getting(JvmTestSuite::class) {
               useJUnitJupiter()
           }
       }
   }
   
   // Do not generate reports for individual projects
   tasks.jacocoTestReport {
       enabled = false
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/kotlin/list/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       `java-library`
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "jvm-multi-project-with-code-coverage-distribution"
   
   // production code projects
   include("application", "list", "utilities")

samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/kotlin/utilities/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       `java-library`
   }
   
   dependencies {
       implementation(project(":list"))
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/tests/testTask.out

.. code-block::

   > Task :buildSrc:processResources
   > Task :buildSrc:pluginDescriptors
   > Task :buildSrc:classes
   > Task :buildSrc:jar
   > Task :list:compileJava
   > Task :utilities:compileJava
   > Task :application:compileJava
   > Task :application:processResources NO-SOURCE
   > Task :application:classes
   > Task :application:compileTestJava
   > Task :application:processTestResources NO-SOURCE
   > Task :application:testClasses
   > Task :list:processResources NO-SOURCE
   > Task :list:classes
   > Task :list:jar
   > Task :utilities:processResources NO-SOURCE
   > Task :utilities:classes
   > Task :utilities:jar
   > Task :application:test
   > Task :list:compileTestJava
   > Task :list:processTestResources NO-SOURCE
   > Task :list:testClasses
   > Task :list:test
   > Task :utilities:compileTestJava
   > Task :utilities:processTestResources NO-SOURCE
   > Task :utilities:testClasses
   > Task :utilities:test
   > Task :application:testCodeCoverageReport
   
   BUILD SUCCESSFUL in 0s

samples/incubating/java/jvm-multi-project-with-code-coverage-distribution/tests/testTask.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: testCodeCoverageReport
       expected-output-file: testTask.out
       allow-additional-output: true
       allow-disordered-output: true
   }]

/Sample: 游릭 incubating/java/jvm-multi-project-with-code-coverage-standalone
========================================================================

samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how to aggregate code coverage across multiple Java subprojects using link:https://www.jacoco.org/jacoco/[JaCoCo].  The link:{userManualPath}#jacoco_report_aggregation_plugin[jacoco-report-aggregation plugin] provides this ability via a standalone project used to specify _which_ subprojects to include for aggregation.
   
   The project in this example contains three "code" subprojects: `application`, `list` and `utilities`.  All three projects apply the `jacoco` plugin, and `application` consumes both `list` and `utilities` via its implementation configuration.  A fourth subproject `code-coverage-report` is the standalone utility project used to collect the coverage results.
   
   WARNING: The Test Report Aggregation plugin does not currently work with the ``com.android.application`` plugin.
   
   ====
   include::sample[dir="kotlin",files="code-coverage-report/build.gradle.kts[tag=**]"]
   include::sample[dir="groovy",files="code-coverage-report/build.gradle[tag=**]"]
   ====
   
   The standalone project applies `jacoco-report-aggregation`, but requires additional configuration if the `jvm-test-suite` plugin is not also present.
   
   In this scenario, two additional pieces of setup are necessary:
   
   <1> Declare dependencies using the `jacocoAggregation` configuration
   <2> Define a report of type `JacocoCoverageReport` which collects coverage data from unit test suites
   <3> Optional: make JaCoCo aggregate report generation part of the 'check' lifecycle phase
   
   The report aggregation logic does not automatically inspect all subprojects for coverage data to aggregate.  Instead, the direct and transitive <<declaring_dependencies.adoc#sub:project_dependencies,project dependencies>> of the `jacocoAggregation` configuration are selected for potential aggregation.
   
   The user must also declare one or more reports of type `JacocoCoverageReport`.  Each report instance specifies a `testType` property, used to match the test suite producing the coverage data.  A `JacocoReport` task is synthesized for each user-defined report and performs the aggregation.  Invoking this task will cause tests to be executed in the dependent projects of the `jacocoAggregation` configuration.
   
   Running the tests and generate the report:
   
   [listing.terminal.sample-command]
   ----
   $ ./gradlew testCodeCoverageReport
   
   BUILD SUCCESSFUL
   25 actionable tasks: 25 executed
   ----
   
   XML and HTML reports can now be found under `code-coverage-report/build/reports/jacoco/testCodeCoverageReport`.
   
   For more information, see link:{userManualPath}#java_testing[Testing in Java project chapter].

samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/groovy/application/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'application'
   }
   
   dependencies {
       implementation project(':list')
       implementation project(':utilities')
   }
   
   application {
       mainClass = 'org.gradle.sample.Main'
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/groovy/buildSrc/build.gradle

.. code-block::

   plugins {
       id 'groovy-gradle-plugin'
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle

.. code-block::

   plugins {
       id 'java'
       id 'jacoco'
   }
   
   version = '1.0.2'
   group = 'org.gradle.sample'
   
   repositories {
       mavenCentral()
   }
   
   testing {
       suites {
           test(JvmTestSuite) {
               useJUnitJupiter()
           }
       }
   }
   
   // Do not generate reports for individual projects
   tasks.named("jacocoTestReport") {
       enabled = false
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/groovy/code-coverage-report/build.gradle

.. code-block::

   plugins {
       id 'base'
       id 'jacoco-report-aggregation'
   }
   
   repositories {
       mavenCentral()
   }
   
   dependencies {
       jacocoAggregation project(':application') // <.>
   }
   
   // tag::create_report[]
   reporting {
       reports {
           testCodeCoverageReport(JacocoCoverageReport) { // <.>
               testType = TestSuiteType.UNIT_TEST
           }
       }
   }
   // end::create_report[]
   
   tasks.named('check') {
       dependsOn tasks.named('testCodeCoverageReport', JacocoReport) // <.>
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/groovy/list/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/groovy/settings.gradle

.. code-block::

   rootProject.name = 'jvm-multi-project-with-code-coverage'
   
   // production code projects
   include 'application', 'list', 'utilities'
   
   // reporting utility projects
   include 'code-coverage-report'

samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/groovy/utilities/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }
   
   dependencies {
       implementation project(':list')
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/kotlin/application/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       application
   }
   
   dependencies {
       implementation(project(":list"))
       implementation(project(":utilities"))
   }
   
   application {
       mainClass = "org.gradle.sample.Main"
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/kotlin/buildSrc/build.gradle.kts

.. code-block::

   plugins {
       `kotlin-dsl`
   }
   
   repositories {
       mavenCentral()
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts

.. code-block::

   plugins {
       java
       jacoco
   }
   
   version = "1.0.2"
   group = "org.gradle.sample"
   
   repositories {
       mavenCentral()
   }
   
   testing {
       suites {
           val test by getting(JvmTestSuite::class) {
               useJUnitJupiter()
           }
       }
   }
   
   // Do not generate reports for individual projects
   tasks.jacocoTestReport {
       enabled = false
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/kotlin/code-coverage-report/build.gradle.kts

.. code-block::

   plugins {
       base
       id("jacoco-report-aggregation")
   }
   
   repositories {
       mavenCentral()
   }
   
   dependencies {
       jacocoAggregation(project(":application")) // <.>
   }
   
   // tag::create_report[]
   reporting {
       reports {
           val testCodeCoverageReport by creating(JacocoCoverageReport::class) { // <.>
               testType = TestSuiteType.UNIT_TEST
           }
       }
   }
   // end::create_report[]
   
   tasks.check {
       dependsOn(tasks.named<JacocoReport>("testCodeCoverageReport")) // <.>
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/kotlin/list/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       `java-library`
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "jvm-multi-project-with-code-coverage"
   
   // production code projects
   include("application", "list", "utilities")
   
   // reporting utility projects
   include("code-coverage-report")

samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/kotlin/utilities/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       `java-library`
   }
   
   dependencies {
       implementation(project(":list"))
   }

samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/tests/testTask.out

.. code-block::

   > Task :buildSrc:processResources
   > Task :buildSrc:pluginDescriptors
   > Task :buildSrc:classes
   > Task :buildSrc:jar
   > Task :list:compileJava
   > Task :utilities:compileJava
   > Task :application:compileJava
   > Task :application:processResources NO-SOURCE
   > Task :application:classes
   > Task :application:compileTestJava
   > Task :application:processTestResources NO-SOURCE
   > Task :application:testClasses
   > Task :list:processResources NO-SOURCE
   > Task :list:classes
   > Task :list:jar
   > Task :utilities:processResources NO-SOURCE
   > Task :utilities:classes
   > Task :utilities:jar
   > Task :application:test
   > Task :list:compileTestJava
   > Task :list:processTestResources NO-SOURCE
   > Task :list:testClasses
   > Task :list:test
   > Task :utilities:compileTestJava
   > Task :utilities:processTestResources NO-SOURCE
   > Task :utilities:testClasses
   > Task :utilities:test
   > Task :code-coverage-report:testCodeCoverageReport
   
   BUILD SUCCESSFUL in 0s

samples/incubating/java/jvm-multi-project-with-code-coverage-standalone/tests/testTask.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: testCodeCoverageReport
       expected-output-file: testTask.out
       allow-additional-output: true
       allow-disordered-output: true
   }]

/Sample: 游릭 incubating/java/jvm-multi-project-with-test-aggregation-distribution
=============================================================================

samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how to aggregate test results across multiple Java subprojects.  The link:{userManualPath}#test_report_aggregation_plugin[test-report-aggregation plugin] provides this ability when applied to the distribution project, such as an Android application or WAR subproject.
   
   The project in this example contains three projects: `application`, `list` and `utilities`.  All three projects apply the `java` plugin, and `application` consumes both `list` and `utilities` on its implementation configuration.  The `application` subproject is the final distribution of this software project, and applies `test-report-aggregation` to perform the test result aggregation.
   
   WARNING: The Test Report Aggregation plugin does not currently work with the ``com.android.application`` plugin.
   
   ====
   include::sample[dir="kotlin",files="application/build.gradle.kts[]"]
   include::sample[dir="groovy",files="application/build.gradle[]"]
   ====
   
   The `application` project requires no additional configuration if the `jvm-test-suite` plugin is present.
   
   <1> Apply the `test-report-aggregation` plugin
   <2> Optional: make aggregate test report generation part of the 'check' lifecycle phase
   
   The aggregation logic does not automatically inspect all subprojects for test results.  Instead, the direct and transitive <<declaring_dependencies.adoc#sub:project_dependencies,project dependencies>> of the distribution project's runtime classpath are selected for potential aggregation.
   
   For the default test suite named 'test', no additional configuration is necessary.  The aggregated reports and their backing tasks of type `TestReport` are synthesized based on the test suites existing in the `application` project.  Test suites having identical `testType` properties will be aggregated.
   
   Running the tests and generate the report:
   
   [listing.terminal.sample-command]
   ----
   $ ./gradlew testAggregateTestReport
   
   BUILD SUCCESSFUL
   24 actionable tasks: 24 executed
   ----
   
   The aggregated HTML report can now be found under `application/build/reports/tests/unit-tests/aggregated-results`.
   
   For more information, see link:{userManualPath}#java_testing[Testing in Java project chapter].

samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/groovy/application/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'application'
       id 'test-report-aggregation' // <1>
   }
   
   dependencies {
       implementation project(':list')
       implementation project(':utilities')
   }
   
   application {
       mainClass = 'org.gradle.sample.Main'
   }
   
   tasks.named('check') {
       dependsOn tasks.named('testAggregateTestReport', TestReport) // <2>
   }

samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/groovy/buildSrc/build.gradle

.. code-block::

   plugins {
       id 'groovy-gradle-plugin'
   }

samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle

.. code-block::

   plugins {
       id 'java'
   }
   
   version = '1.0.2'
   group = 'org.gradle.sample'
   
   repositories {
       mavenCentral()
   }
   
   testing {
       suites {
           test(JvmTestSuite) {
               useJUnitJupiter()
           }
       }
   }

samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/groovy/list/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }

samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/groovy/settings.gradle

.. code-block::

   rootProject.name = 'jvm-multi-project-with-test-aggregation-distribution'
   
   // production code projects
   include 'application', 'list', 'utilities'

samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/groovy/utilities/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }
   
   dependencies {
       implementation project(':list')
   }

samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/kotlin/application/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       application
       id("test-report-aggregation") // <1>
   }
   
   dependencies {
       implementation(project(":list"))
       implementation(project(":utilities"))
   }
   
   application {
       mainClass = "org.gradle.sample.Main"
   }
   
   tasks.check {
       dependsOn(tasks.named<TestReport>("testAggregateTestReport")) // <2>
   }

samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/kotlin/buildSrc/build.gradle.kts

.. code-block::

   plugins {
       `kotlin-dsl`
   }
   
   repositories {
       mavenCentral()
   }

samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts

.. code-block::

   plugins {
       java
   }
   
   version = "1.0.2"
   group = "org.gradle.sample"
   
   repositories {
       mavenCentral()
   }
   
   testing {
       suites {
           val test by getting(JvmTestSuite::class) {
               useJUnitJupiter()
           }
       }
   }

samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/kotlin/list/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       `java-library`
   }

samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "jvm-multi-project-with-test-aggregation-distribution"
   
   // production code projects
   include("application", "list", "utilities")

samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/kotlin/utilities/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       `java-library`
   }
   
   dependencies {
       implementation(project(":list"))
   }

samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/tests/testTask.out

.. code-block::

   > Task :buildSrc:pluginDescriptors
   > Task :buildSrc:processResources
   > Task :buildSrc:classes
   > Task :buildSrc:jar
   > Task :list:compileJava
   > Task :utilities:compileJava
   > Task :application:compileJava
   > Task :application:processResources NO-SOURCE
   > Task :application:classes
   > Task :application:compileTestJava
   > Task :application:processTestResources NO-SOURCE
   > Task :application:testClasses
   > Task :list:processResources NO-SOURCE
   > Task :list:classes
   > Task :list:jar
   > Task :utilities:processResources NO-SOURCE
   > Task :utilities:classes
   > Task :utilities:jar
   > Task :application:test
   > Task :list:compileTestJava
   > Task :list:processTestResources NO-SOURCE
   > Task :list:testClasses
   > Task :list:test
   > Task :utilities:compileTestJava
   > Task :utilities:processTestResources NO-SOURCE
   > Task :utilities:testClasses
   > Task :utilities:test
   > Task :application:testAggregateTestReport
   
   BUILD SUCCESSFUL in 0s

samples/incubating/java/jvm-multi-project-with-test-aggregation-distribution/tests/testTask.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: testAggregateTestReport
       expected-output-file: testTask.out
       allow-additional-output: true
       allow-disordered-output: true
   }]

samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/groovy/application/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'application'
   }
   
   dependencies {
       implementation project(':list')
       implementation project(':utilities')
   }
   
   application {
       mainClass = 'org.gradle.sample.Main'
   }

/Sample: 游릭 incubating/java/jvm-multi-project-with-test-aggregation-standalone
===========================================================================

samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how to aggregate test results across multiple Java subprojects.  The link:{userManualPath}#test_report_aggregation_plugin[test-report-aggregation plugin] provides this ability via a standalone project used to specify _which_ subprojects to include for aggregation.
   
   The project in this example contains three "code" subprojects: `application`, `list` and `utilities`.  All three projects apply the `java` plugin, and `application` consumes both `list` and `utilities` via its implementation configuration.  A fourth subproject `test-results` is the standalone utility project used to collect the aggregated test results.
   
   WARNING: The Test Report Aggregation plugin does not currently work with the ``com.android.application`` plugin.
   
   ====
   include::sample[dir="kotlin",files="test-results/build.gradle.kts[tag=**]"]
   include::sample[dir="groovy",files="test-results/build.gradle[tag=**]"]
   ====
   
   The standalone project applies `test-report-aggregation`, but requires additional configuration if the `jvm-test-suite` plugin is not also present (it will be automatically applied by the `java` plugin).
   
   In this scenario, two additional pieces of setup are necessary:
   
   <1> Declare dependencies using the `testReportAggregation` configuration
   <2> Define a report of type `AggregateTestReport` which collects test data from unit test suites
   <3> Optional: make aggregate test report generation part of the 'check' lifecycle phase
   
   The report aggregation logic does not automatically inspect all subprojects for test results to aggregate.  Instead, the direct and transitive <<declaring_dependencies.adoc#sub:project_dependencies,project dependencies>> of the `testReportAggregation` configuration are selected for potential aggregation.
   
   The user must also declare one or more reports of type `AggregateTestReport`.  Each report instance specifies a `testType` property, used to match the test suite producing the test data.  A `TestReport` task is synthesized for each user-defined report and performs the aggregation.  Invoking this task will cause tests to be executed in the dependent projects of the `testReportAggregation` configuration.
   
   Run the tests and generate the report:
   
   [listing.terminal.sample-command]
   ----
   $ ./gradlew testAggregateTestReport
   
   BUILD SUCCESSFUL
   24 actionable tasks: 24 executed
   ----
   
   The aggregated HTML report can now be found under `test-results/build/reports/tests/unit-tests/aggregated-results`.
   
   For more information, see link:{userManualPath}#java_testing[Testing in Java project chapter].

samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/groovy/buildSrc/build.gradle

.. code-block::

   plugins {
       id 'groovy-gradle-plugin'
   }

samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle

.. code-block::

   plugins {
       id 'java'
   }
   
   version = '1.0.2'
   group = 'org.gradle.sample'
   
   repositories {
       mavenCentral()
   }
   
   testing {
       suites {
           test(JvmTestSuite) {
               useJUnitJupiter()
           }
       }
   }

samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/groovy/list/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }

samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/groovy/settings.gradle

.. code-block::

   rootProject.name = 'jvm-multi-project-with-test-aggregation-standalone'
   
   // production code projects
   include 'application', 'list', 'utilities'
   
   // reporting utility projects
   include 'test-results'

samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/groovy/test-results/build.gradle

.. code-block::

   plugins {
       id 'base'
       id 'test-report-aggregation'
   }
   
   dependencies {
       testReportAggregation project(':application') // <.>
   }
   
   // tag::create_report[]
   reporting {
       reports {
           testAggregateTestReport(AggregateTestReport) { // <.>
               testType = TestSuiteType.UNIT_TEST
           }
       }
   }
   // end::create_report[]
   
   tasks.named('check') {
       dependsOn tasks.named('testAggregateTestReport', TestReport) // <.>
   }

samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/groovy/utilities/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }
   
   dependencies {
       implementation project(':list')
   }

samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/kotlin/application/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       application
   }
   
   dependencies {
       implementation(project(":list"))
       implementation(project(":utilities"))
   }
   
   application {
       mainClass = "org.gradle.sample.Main"
   }

samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/kotlin/buildSrc/build.gradle.kts

.. code-block::

   plugins {
       `kotlin-dsl`
   }
   
   repositories {
       mavenCentral()
   }

samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts

.. code-block::

   plugins {
       java
   }
   
   version = "1.0.2"
   group = "org.gradle.sample"
   
   repositories {
       mavenCentral()
   }
   
   testing {
       suites {
           val test by getting(JvmTestSuite::class) {
               useJUnitJupiter()
           }
       }
   }

samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/kotlin/list/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       `java-library`
   }

samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "jvm-multi-project-with-test-aggregation-standalone"
   
   // production code projects
   include("application", "list", "utilities")
   
   // reporting utility projects
   include("test-results")

samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/kotlin/test-results/build.gradle.kts

.. code-block::

   plugins {
       base
       id("test-report-aggregation")
   }
   
   dependencies {
       testReportAggregation(project(":application")) // <.>
   }
   
   // tag::create_report[]
   reporting {
       reports {
           val testAggregateTestReport by creating(AggregateTestReport::class) { // <.>
               testType = TestSuiteType.UNIT_TEST
           }
       }
   }
   // end::create_report[]
   
   tasks.check {
       dependsOn(tasks.named<TestReport>("testAggregateTestReport")) // <.>
   }

samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/kotlin/utilities/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       `java-library`
   }
   
   dependencies {
       implementation(project(":list"))
   }

samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/tests/testTask.out

.. code-block::

   > Task :buildSrc:processResources
   > Task :buildSrc:pluginDescriptors
   > Task :buildSrc:classes
   > Task :buildSrc:jar
   > Task :list:compileJava
   > Task :utilities:compileJava
   > Task :application:compileJava
   > Task :application:processResources NO-SOURCE
   > Task :application:classes
   > Task :application:compileTestJava
   > Task :application:processTestResources NO-SOURCE
   > Task :application:testClasses
   > Task :list:processResources NO-SOURCE
   > Task :list:classes
   > Task :list:jar
   > Task :utilities:processResources NO-SOURCE
   > Task :utilities:classes
   > Task :utilities:jar
   > Task :application:test
   > Task :list:compileTestJava
   > Task :list:processTestResources NO-SOURCE
   > Task :list:testClasses
   > Task :list:test
   > Task :utilities:compileTestJava
   > Task :utilities:processTestResources NO-SOURCE
   > Task :utilities:testClasses
   > Task :utilities:test
   > Task :test-results:testAggregateTestReport
   
   BUILD SUCCESSFUL in 0s

samples/incubating/java/jvm-multi-project-with-test-aggregation-standalone/tests/testTask.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: testAggregateTestReport
       expected-output-file: testTask.out
       allow-additional-output: true
       allow-disordered-output: true
   }]

/Sample: 游릭 incubating/java/modules-multi-project-with-integration-tests/README
============================================================================

samples/incubating/java/modules-multi-project-with-integration-tests/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ's Gradle import].
   
   This is an link:#[extension of this sample] that adds blackbox integration tests.
   
   NOTE: This sample shows how to adopt an link:#[existing sample] for use with Test Suites.
   
   IMPORTANT: Test Suites are an link:{userManualPath}#feature_lifecycle-sec:incubating_state[incubating] feature, and the details described here may change.
   
   Here, the link:{userManualPath}#jvm_test_suite_plugin[Test Suite Plugin] creates an additional source set _integrationTest_ with a `module-info.java`.
   
   
   ```
   src
   較덕較 integrationTest
       較덕較 java
           較덕較 module-info.java
   ```
   
   We effectively declare a second module that is only used for testing.
   The module is `open`, which means that it allows reflective access to its classes at runtime as required by JUnit's test execution engine.
   
   ```
   open module org.gradle.sample.integtest.utilities {
       requires org.gradle.sample.utilities;
       requires org.junit.jupiter.api;
   }
   ```
   
   NOTE: This sample does **not** work in Eclipse when imported using https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   This is due to https://bugs.eclipse.org/bugs/show_bug.cgi?id=520667[a limitation in Eclipse] that does not allow more than one module in one project.
   It you want to do blackbox testing in Eclipse, you should move the integration tests to separate subprojects.
   
   For more information, see link:{userManualPath}#java_library_plugin-sec:java_library_modular[Java Module support in the Java Library Plugin],
   link:{userManualPath}#application_plugin-sec:application_modular[Java Module support in the Application Plugin] and
   link:{userManualPath}#java_testing-sec:java_testing_modular[testing Java Modules].

samples/incubating/java/modules-multi-project-with-integration-tests/groovy/application/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'application'
   }
   
   dependencies {
       implementation project(':utilities')
   }
   
   application {
       mainModule = 'org.gradle.sample.app'
       mainClass = 'org.gradle.sample.app.Main'
   }

samples/incubating/java/modules-multi-project-with-integration-tests/groovy/buildSrc/build.gradle

.. code-block::

   plugins {
       id 'groovy-gradle-plugin'
   }

samples/incubating/java/modules-multi-project-with-integration-tests/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle

.. code-block::

   plugins {
       id 'java'
   }
   
   version = '1.0.2'
   group = 'org.gradle.sample'
   
   repositories {
       mavenCentral()
   }
   
   testing {
       suites {
           test {
               useJUnitJupiter('5.7.1')
           }
   
           integrationTest(JvmTestSuite) {
               dependencies {
                   implementation project()
               }
   
               targets {
                   all {
                       testTask.configure {
                           shouldRunAfter(test)
                       }
                   }
               }
           }
       }
   }
   
   tasks.named('check') {
       dependsOn(testing.suites.integrationTest)
   }

samples/incubating/java/modules-multi-project-with-integration-tests/groovy/list/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }

samples/incubating/java/modules-multi-project-with-integration-tests/groovy/settings.gradle

.. code-block::

   rootProject.name = 'modules-multi-project-with-integration-tests'
   include 'application', 'list', 'utilities'

samples/incubating/java/modules-multi-project-with-integration-tests/groovy/utilities/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }
   
   dependencies {
       api project(':list')
   }

samples/incubating/java/modules-multi-project-with-integration-tests/kotlin/application/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       application
   }
   
   dependencies {
       implementation(project(":utilities"))
   }
   
   application {
       mainModule = "org.gradle.sample.app"
       mainClass = "org.gradle.sample.app.Main"
   }

samples/incubating/java/modules-multi-project-with-integration-tests/kotlin/buildSrc/build.gradle.kts

.. code-block::

   plugins {
       `kotlin-dsl`
   }
   
   repositories {
       mavenCentral()
   }

samples/incubating/java/modules-multi-project-with-integration-tests/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts

.. code-block::

   plugins {
       java
   }
   
   version = "1.0.2"
   group = "org.gradle.sample"
   
   repositories {
       mavenCentral()
   }
   
   testing {
       suites {
           val test by getting(JvmTestSuite::class) {
               useJUnitJupiter("5.7.1")
           }
   
           val integrationTest by registering(JvmTestSuite::class) {
               dependencies {
                   implementation(project())
               }
   
               targets {
                   all {
                       testTask.configure {
                           shouldRunAfter(test)
                       }
                   }
               }
           }
       }
   }
   
   tasks.named("check") {
       dependsOn(testing.suites.named("integrationTest"))
   }

samples/incubating/java/modules-multi-project-with-integration-tests/kotlin/list/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       `java-library`
   }

samples/incubating/java/modules-multi-project-with-integration-tests/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "modules-multi-project-with-integration-tests"
   include("application", "list", "utilities")

samples/incubating/java/modules-multi-project-with-integration-tests/kotlin/utilities/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       `java-library`
   }
   
   dependencies {
       api(project(":list"))
   }

samples/incubating/java/modules-multi-project-with-integration-tests/tests/checkTask.out

.. code-block::

   > Task :buildSrc:processResources
   > Task :buildSrc:classes
   > Task :buildSrc:jar
   > Task :list:compileJava
   > Task :list:processResources NO-SOURCE
   > Task :list:classes
   > Task :list:jar
   > Task :utilities:compileJava
   > Task :utilities:processResources NO-SOURCE
   > Task :utilities:classes
   > Task :utilities:jar
   > Task :application:compileJava
   > Task :application:processResources NO-SOURCE
   > Task :application:classes
   > Task :application:compileTestJava
   > Task :application:processTestResources NO-SOURCE
   > Task :application:testClasses
   > Task :application:test
   > Task :application:jar
   > Task :application:compileIntegrationTestJava
   > Task :application:processIntegrationTestResources NO-SOURCE
   > Task :application:integrationTestClasses
   > Task :application:integrationTest
   > Task :application:check
   > Task :list:compileTestJava
   > Task :list:processTestResources NO-SOURCE
   > Task :list:testClasses
   > Task :list:test
   > Task :list:compileIntegrationTestJava NO-SOURCE
   > Task :list:processIntegrationTestResources NO-SOURCE
   > Task :list:integrationTestClasses UP-TO-DATE
   > Task :list:integrationTest NO-SOURCE
   > Task :list:check
   > Task :utilities:compileTestJava NO-SOURCE
   > Task :utilities:processTestResources NO-SOURCE
   > Task :utilities:testClasses UP-TO-DATE
   > Task :utilities:test NO-SOURCE
   > Task :utilities:compileIntegrationTestJava
   > Task :utilities:processIntegrationTestResources NO-SOURCE
   > Task :utilities:integrationTestClasses
   > Task :utilities:integrationTest
   > Task :utilities:check
   
   BUILD SUCCESSFUL in 0s

samples/incubating/java/modules-multi-project-with-integration-tests/tests/runTask.out

.. code-block::

   > Task :buildSrc:jar UP-TO-DATE
   > Task :list:compileJava UP-TO-DATE
   > Task :list:processResources NO-SOURCE
   > Task :list:classes UP-TO-DATE
   > Task :list:jar UP-TO-DATE
   > Task :utilities:compileJava UP-TO-DATE
   > Task :utilities:processResources NO-SOURCE
   > Task :utilities:classes UP-TO-DATE
   > Task :utilities:jar UP-TO-DATE
   > Task :application:compileJava UP-TO-DATE
   > Task :application:processResources NO-SOURCE
   > Task :application:classes UP-TO-DATE
   > Task :application:jar UP-TO-DATE
   
   > Task :application:run
   Hello, World!
   
   BUILD SUCCESSFUL in 0s

samples/incubating/java/modules-multi-project-with-integration-tests/tests/testTask.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: check
       expected-output-file: checkTask.out
       allow-additional-output: true
       allow-disordered-output: true
   },{
       executable: gradle
       args: run
       expected-output-file: runTask.out
       allow-additional-output: true
       allow-disordered-output: true
   }]

/Sample: 游릭 java/jvm-multi-project-with-additional-test-types
==========================================================

samples/java/jvm-multi-project-with-additional-test-types/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how to add additional test types to a JVM project in Gradle. Your project may have many different kinds of tests--unit tests, integration tests, functional tests, etc. A JVM project in Gradle has a single `Test` task, but other tasks can be added to represent each of these test types.
   
   In this sample, we are testing Java projects with JUnit5; however, this applies to other JVM languages as well.
   
   Concretely, we add a _convention plugin_ in `buildSrc` to share the integration test setup between multiple subprojects:
   
   ====
   include::sample[dir="kotlin",files="buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts[]"]
   include::sample[dir="groovy",files="buildSrc/src/main/groovy/myproject.java-conventions.gradle[]"]
   ====
   
   And apply it in an application project:
   
   ====
   include::sample[dir="kotlin",files="application/build.gradle.kts[]"]
   include::sample[dir="groovy",files="application/build.gradle[]"]
   ====
   
   And in library projects:
   
   ====
   include::sample[dir="kotlin",files="utilities/build.gradle.kts[]"]
   include::sample[dir="groovy",files="utilities/build.gradle[]"]
   ====
   
   These additional tests can be executed with the `integrationTest` task or as part of lifecycle `check`:
   
   [listing.terminal.sample-command]
   ----
   $ ./gradlew check
   
   BUILD SUCCESSFUL
   14 actionable tasks: 14 executed
   ----
   
   For more information, see link:{userManualPath}#java_testing-sec:configuring_java_integration_tests[section Configuring integration tests in the Testing in Java project chapter].

samples/java/jvm-multi-project-with-additional-test-types/groovy/application/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'application'
   }
   
   dependencies {
       implementation project(':list')
       implementation project(':utilities')
   }
   
   application {
       mainClass = 'org.gradle.sample.app.Main'
   }

samples/java/jvm-multi-project-with-additional-test-types/groovy/buildSrc/build.gradle

.. code-block::

   plugins {
       id 'groovy-gradle-plugin'
   }

samples/java/jvm-multi-project-with-additional-test-types/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle

.. code-block::

   plugins {
       id 'java'
   }
   
   version = '1.0.2'
   group = 'org.gradle.sample'
   
   repositories {
       mavenCentral()
   }
   
   def integrationTest = sourceSets.create('integrationTest')
   
   configurations[integrationTest.implementationConfigurationName].extendsFrom(configurations.testImplementation)
   configurations[integrationTest.runtimeOnlyConfigurationName].extendsFrom(configurations.testRuntimeOnly)
   
   tasks.named('test') {
       useJUnitPlatform()
   }
   
   def integrationTestTask = tasks.register('integrationTest', Test) {
       description = 'Runs integration tests.'
       group = 'verification'
       useJUnitPlatform()
   
       testClassesDirs = integrationTest.output.classesDirs
       classpath = configurations[integrationTest.runtimeClasspathConfigurationName] + integrationTest.output
   
       shouldRunAfter(tasks.named('test'))
   }
   
   tasks.named('check') {
       dependsOn(integrationTestTask)
   }
   
   dependencies {
       testImplementation 'org.junit.jupiter:junit-jupiter:5.7.1'
       testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
   
       integrationTestImplementation project
   }

samples/java/jvm-multi-project-with-additional-test-types/groovy/list/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }

samples/java/jvm-multi-project-with-additional-test-types/groovy/settings.gradle

.. code-block::

   rootProject.name = 'multi-project-with-additional-test-types'
   include 'application', 'list', 'utilities'

samples/java/jvm-multi-project-with-additional-test-types/groovy/utilities/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }
   
   dependencies {
       implementation project(':list')
   }

samples/java/jvm-multi-project-with-additional-test-types/kotlin/application/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       application
   }
   
   dependencies {
       implementation(project(":list"))
       implementation(project(":utilities"))
   }
   
   application {
       mainClass = "org.gradle.sample.app.Main"
   }

samples/java/jvm-multi-project-with-additional-test-types/kotlin/buildSrc/build.gradle.kts

.. code-block::

   plugins {
       `kotlin-dsl`
   }
   
   repositories {
       mavenCentral()
   }

samples/java/jvm-multi-project-with-additional-test-types/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts

.. code-block::

   plugins {
       java
   }
   
   version = "1.0.2"
   group = "org.gradle.sample"
   
   repositories {
       mavenCentral()
   }
   
   val integrationTest by sourceSets.creating
   
   configurations[integrationTest.implementationConfigurationName].extendsFrom(configurations.testImplementation.get())
   configurations[integrationTest.runtimeOnlyConfigurationName].extendsFrom(configurations.testRuntimeOnly.get())
   
   tasks.test {
       useJUnitPlatform()
   }
   
   val integrationTestTask = tasks.register<Test>("integrationTest") {
       description = "Runs integration tests."
       group = "verification"
       useJUnitPlatform()
   
       testClassesDirs = integrationTest.output.classesDirs
       classpath = configurations[integrationTest.runtimeClasspathConfigurationName] + integrationTest.output
   
       shouldRunAfter(tasks.test)
   }
   
   tasks.check {
       dependsOn(integrationTestTask)
   }
   
   dependencies {
       testImplementation("org.junit.jupiter:junit-jupiter:5.7.1")
       testRuntimeOnly("org.junit.platform:junit-platform-launcher")
   
       "integrationTestImplementation"(project)
   }

samples/java/jvm-multi-project-with-additional-test-types/kotlin/list/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       `java-library`
   }

samples/java/jvm-multi-project-with-additional-test-types/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "multi-project-with-additional-test-types"
   include("application", "list", "utilities")

samples/java/jvm-multi-project-with-additional-test-types/kotlin/utilities/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       `java-library`
   }
   
   dependencies {
       implementation(project(":list"))
   }

samples/java/jvm-multi-project-with-additional-test-types/tests/checkTask.out

.. code-block::

   > Task :buildSrc:processResources
   > Task :buildSrc:pluginDescriptors
   > Task :buildSrc:classes
   > Task :buildSrc:jar
   > Task :list:compileJava
   > Task :utilities:compileJava
   > Task :application:compileJava
   > Task :application:processResources NO-SOURCE
   > Task :application:classes
   > Task :application:compileTestJava
   > Task :application:processTestResources NO-SOURCE
   > Task :application:testClasses
   > Task :list:processResources NO-SOURCE
   > Task :list:classes
   > Task :list:jar
   > Task :utilities:processResources NO-SOURCE
   > Task :utilities:classes
   > Task :utilities:jar
   > Task :application:test
   > Task :application:jar
   > Task :application:compileIntegrationTestJava
   > Task :application:processIntegrationTestResources NO-SOURCE
   > Task :application:integrationTestClasses
   > Task :application:integrationTest
   > Task :application:check
   > Task :list:compileTestJava
   > Task :list:processTestResources NO-SOURCE
   > Task :list:testClasses
   > Task :list:test
   > Task :list:compileIntegrationTestJava NO-SOURCE
   > Task :list:processIntegrationTestResources NO-SOURCE
   > Task :list:integrationTestClasses UP-TO-DATE
   > Task :list:integrationTest NO-SOURCE
   > Task :list:check
   > Task :utilities:compileTestJava NO-SOURCE
   > Task :utilities:processTestResources NO-SOURCE
   > Task :utilities:testClasses UP-TO-DATE
   > Task :utilities:test NO-SOURCE
   > Task :utilities:compileIntegrationTestJava
   > Task :utilities:processIntegrationTestResources NO-SOURCE
   > Task :utilities:integrationTestClasses
   > Task :utilities:integrationTest
   > Task :utilities:check
   
   BUILD SUCCESSFUL in 0s

samples/java/jvm-multi-project-with-additional-test-types/tests/checkTask.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: check
       expected-output-file: checkTask.out
       allow-additional-output: true
       allow-disordered-output: true
   }]

/Sample: 游릭 java/jvm-multi-project-with-toolchains
===============================================

samples/java/jvm-multi-project-with-toolchains/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how to configure a toolchain for a JVM project in Gradle.
   Your project usually targets a specific java version.
   Using toolchains, it is very simple to set the required java version while Gradle handles the setting up the tasks (e.g. compile and test) accordingly.
   
   Concretely, we add a _convention plugin_ in `buildSrc` to share the setup between multiple subprojects:
   
   ====
   include::sample[dir="kotlin",files="buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts[tags=toolchain]"]
   include::sample[dir="groovy",files="buildSrc/src/main/groovy/myproject.java-conventions.gradle[tags=toolchain]"]
   ====
   
   While most modules are fine with the defaults, the `list` subproject overrides the defaults as it has more specific requirements.
   
   ====
   include::sample[dir="kotlin",files="list/build.gradle.kts[tags=customToolchain]"]
   include::sample[dir="groovy",files="list/build.gradle[tags=customToolchain]"]
   ====
   
   [listing.terminal.sample-command]
   ----
   $ ./gradlew check
   
   BUILD SUCCESSFUL
   9 actionable tasks: 9 executed
   ----
   
   For more information, see link:{userManualPath}#toolchains[Toolchains chapter].

samples/java/jvm-multi-project-with-toolchains/groovy/application/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'application'
   }
   
   dependencies {
       implementation project(':list')
       implementation project(':utilities')
   }
   
   application {
       mainClass = 'org.gradle.sample.app.Main'
   }
   
   // tag::customExec[]
   task('runOn17', type: JavaExec) {
       javaLauncher = javaToolchains.launcherFor {
           languageVersion = JavaLanguageVersion.of(17)
       }
   
       classpath = sourceSets.main.runtimeClasspath
       mainClass = application.mainClass
   }
   // end::customExec[]

samples/java/jvm-multi-project-with-toolchains/groovy/buildSrc/build.gradle

.. code-block::

   plugins {
       id 'groovy-gradle-plugin'
   }

samples/java/jvm-multi-project-with-toolchains/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle

.. code-block::

   plugins {
       id 'java'
   }
   
   version = '1.0.2'
   group = 'com.example'
   
   repositories {
       mavenCentral()
   }
   
   // tag::toolchain[]
   java {
       toolchain {
           languageVersion = JavaLanguageVersion.of(11)
       }
   }
   // end::toolchain[]
   
   
   tasks.withType(Test).configureEach {
       useJUnitPlatform()
   }
   
   dependencies {
       testImplementation 'org.junit.jupiter:junit-jupiter:5.7.1'
       testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
   }

samples/java/jvm-multi-project-with-toolchains/groovy/list/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }
   
   // tag::customToolchain[]
   tasks.withType(JavaCompile).configureEach {
       javaCompiler = javaToolchains.compilerFor {
           languageVersion = JavaLanguageVersion.of(8)
       }
   }
   
   task('testsOn17', type: Test) {
       javaLauncher = javaToolchains.launcherFor {
           languageVersion = JavaLanguageVersion.of(17)
       }
   }
   // end::customToolchain[]

samples/java/jvm-multi-project-with-toolchains/groovy/settings.gradle

.. code-block::

   rootProject.name = 'multi-project-with-toolchains'
   include 'application', 'list', 'utilities'

samples/java/jvm-multi-project-with-toolchains/groovy/utilities/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }
   
   dependencies {
       implementation project(':list')
   }

samples/java/jvm-multi-project-with-toolchains/kotlin/application/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       application
   }
   
   dependencies {
       implementation(project(":list"))
       implementation(project(":utilities"))
   }
   
   application {
       mainClass = "org.gradle.sample.app.Main"
   }
   
   // tag::customExec[]
   tasks.register<JavaExec>("runOn17") {
       javaLauncher = javaToolchains.launcherFor {
           languageVersion = JavaLanguageVersion.of(17)
       }
   
       classpath = sourceSets["main"].runtimeClasspath
       mainClass = application.mainClass
   }
   // end::customExec[]

samples/java/jvm-multi-project-with-toolchains/kotlin/buildSrc/build.gradle.kts

.. code-block::

   plugins {
       `kotlin-dsl`
   }
   
   repositories {
       mavenCentral()
   }

samples/java/jvm-multi-project-with-toolchains/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts

.. code-block::

   plugins {
       java
   }
   
   version = "1.0.2"
   group = "com.example"
   
   repositories {
       mavenCentral()
   }
   
   // tag::toolchain[]
   java {
       toolchain {
           languageVersion = JavaLanguageVersion.of(11)
       }
   }
   // end::toolchain[]
   
   tasks.withType<Test>().configureEach {
       useJUnitPlatform()
   }
   
   dependencies {
       testImplementation("org.junit.jupiter:junit-jupiter:5.7.1")
       testRuntimeOnly("org.junit.platform:junit-platform-launcher")
   }

samples/java/jvm-multi-project-with-toolchains/kotlin/list/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       `java-library`
   }
   
   // tag::customToolchain[]
   tasks.withType<JavaCompile>().configureEach {
       javaCompiler = javaToolchains.compilerFor {
           languageVersion = JavaLanguageVersion.of(8)
       }
   }
   
   tasks.register<Test>("testsOn17") {
       javaLauncher = javaToolchains.launcherFor {
           languageVersion = JavaLanguageVersion.of(17)
       }
   }
   // end::customToolchain[]

samples/java/jvm-multi-project-with-toolchains/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "multi-project-with-toolchains"
   include("application", "list", "utilities")

samples/java/jvm-multi-project-with-toolchains/kotlin/utilities/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       `java-library`
   }
   
   dependencies {
       implementation(project(":list"))
   }

samples/java/jvm-multi-project-with-toolchains/tests/checkTask.out

.. code-block::

   > Task :buildSrc:processResources
   > Task :buildSrc:pluginDescriptors
   > Task :buildSrc:classes
   > Task :buildSrc:jar
   > Task :list:compileJava
   > Task :utilities:compileJava
   > Task :application:compileJava
   > Task :application:processResources NO-SOURCE
   > Task :application:classes
   > Task :application:compileTestJava
   > Task :application:processTestResources NO-SOURCE
   > Task :application:testClasses
   > Task :list:processResources NO-SOURCE
   > Task :list:classes
   > Task :list:jar
   > Task :utilities:processResources NO-SOURCE
   > Task :utilities:classes
   > Task :utilities:jar
   > Task :application:test
   > Task :application:check
   > Task :list:compileTestJava
   > Task :list:processTestResources NO-SOURCE
   > Task :list:testClasses
   > Task :list:test
   > Task :list:check
   > Task :utilities:compileTestJava NO-SOURCE
   > Task :utilities:processTestResources NO-SOURCE
   > Task :utilities:testClasses UP-TO-DATE
   > Task :utilities:test NO-SOURCE
   > Task :utilities:check UP-TO-DATE
   
   BUILD SUCCESSFUL in 0s

samples/java/jvm-multi-project-with-toolchains/tests/checkTask.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: check
       expected-output-file: checkTask.out
       allow-additional-output: true
       allow-disordered-output: true
   }]

/Sample: 游릭 java/library-publishing
================================

samples/java/library-publishing/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how to publish a Java library to a repository.
   The library has no dependencies and the build has minimal configuration.
   
   ====
   include::sample[dir="kotlin",files="my-library/build.gradle.kts[]"]
   include::sample[dir="groovy",files="my-library/build.gradle[]"]
   ====
   
   To publish the library:
   
   [listing.terminal.sample-command]
   ----
   $ ./gradlew publish
   
   BUILD SUCCESSFUL
   5 actionable tasks: 5 executed
   $ tree build/publishing-repository
   build/publishing-repository
   較덕較 org
       較덕較 gradle
           較덕較 sample
               較덕較 my-library
                   較럭較 1.0.2
                   較먝 較럭較 my-library-1.0.2.jar
                   較먝 較럭較 my-library-1.0.2.jar.md5
                   較먝 較럭較 my-library-1.0.2.jar.sha1
                   較먝 較럭較 my-library-1.0.2.jar.sha256
                   較먝 較럭較 my-library-1.0.2.jar.sha512
                   較먝 較럭較 my-library-1.0.2.module
                   較먝 較럭較 my-library-1.0.2.module.md5
                   較먝 較럭較 my-library-1.0.2.module.sha1
                   較먝 較럭較 my-library-1.0.2.module.sha256
                   較먝 較럭較 my-library-1.0.2.module.sha512
                   較먝 較럭較 my-library-1.0.2.pom
                   較먝 較럭較 my-library-1.0.2.pom.md5
                   較먝 較럭較 my-library-1.0.2.pom.sha1
                   較먝 較럭較 my-library-1.0.2.pom.sha256
                   較먝 較덕較 my-library-1.0.2.pom.sha512
                   較럭較 maven-metadata.xml
                   較럭較 maven-metadata.xml.md5
                   較럭較 maven-metadata.xml.sha1
                   較럭較 maven-metadata.xml.sha256
                   較덕較 maven-metadata.xml.sha512
   
   5 directories, 20 files
   ----
   
   For more information, see link:{userManualPath}#publishing_setup[Publishing Libraries].

samples/java/library-publishing/groovy/my-library/build.gradle

.. code-block::

   plugins {
       id 'java-library'
       id 'maven-publish'
   }
   
   version = '1.0.2'
   group = 'org.gradle.sample'
   
   publishing {
       publications {
           library(MavenPublication) {
               from components.java
           }
       }
       repositories {
           maven {
               url = layout.buildDirectory.dir("publishing-repository")
           }
       }
   }

samples/java/library-publishing/groovy/settings.gradle

.. code-block::

   rootProject.name = 'library-publishing'
   
   include 'my-library'

samples/java/library-publishing/kotlin/my-library/build.gradle.kts

.. code-block::

   plugins {
       `java-library`
       `maven-publish`
   }
   
   version = "1.0.2"
   group = "org.gradle.sample"
   
   publishing {
       publications {
           create<MavenPublication>("library") {
               from(components["java"])
           }
       }
       repositories {
           maven {
               url = uri(layout.buildDirectory.dir("publishing-repository"))
           }
       }
   }

samples/java/library-publishing/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "library-publishing"
   
   include("my-library")

samples/java/library-publishing/tests/publishTask.out

.. code-block::

   > Task :my-library:compileJava
   > Task :my-library:processResources NO-SOURCE
   > Task :my-library:classes
   > Task :my-library:jar
   > Task :my-library:generateMetadataFileForLibraryPublication
   > Task :my-library:generatePomFileForLibraryPublication
   > Task :my-library:publishLibraryPublicationToMavenRepository
   > Task :my-library:publish
   
   BUILD SUCCESSFUL in 0s
   5 actionable tasks: 5 executed

samples/java/library-publishing/tests/publishTask.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: publish
       expected-output-file: publishTask.out
       allow-disordered-output: true
   }]

/Sample: 游릭 java/modules-multi-project
===================================

samples/java/modules-multi-project/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ's Gradle import] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how to create a multi-project containing https://www.oracle.com/corporate/features/understanding-java-9-modules.html[Java Modules].
   Java Modules are a feature of Java itself, available since Java 9, that allows for better encapsulation.
   
   In Gradle, each _source set_ containing Java sources can be turned into a module by adding a `module-info.java` file.
   Typically, in a project with Java Modules like this one, the _main_ source set of a subproject represents a module.
   
   ```
   src
   較덕較 main
       較덕較 java
           較덕較 module-info.java
   ```
   
   In the `module-info.java` file you define dependencies to other modules using keywords like `requires` or `requires transitive`.
   These correspond to the `implementation` and `api` dependencies defined in the Gradle build file.
   In addition, a module `exports` packages that should be visible to consumers.
   Other packages are not visible outside of the module.
   
   ```
   module org.gradle.sample.utilities {
       requires transitive org.gradle.sample.list;
       exports org.gradle.sample.utilities;
   }
   ```
   
   Unit (whitebox) tests that need to access the internals of a module can be written in the traditional way by **not** adding a `module-info.java` to the test source set.
   In test execution, the modules are then treated as standard Java libraries with the encapsulation deactivated.
   
   Blackbox (e.g. integration) tests, which should also follow the encapsulation rules during test execution, can be written by turning the corresponding test sources set itself into a module by adding a `module-info.java`.
   This is shown in link:#[this extended sample].
   
   For more information, see link:{userManualPath}#java_library_plugin-sec:java_library_modular[Java Module support in the Java Library Plugin],
   link:{userManualPath}#application_plugin-sec:application_modular[Java Module support in the Application Plugin] and
   link:{userManualPath}#java_testing-sec:java_testing_modular[testing Java Modules].

samples/java/modules-multi-project/groovy/application/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'application'
   }
   
   dependencies {
       implementation project(':utilities')
   }
   
   application {
       mainModule = 'org.gradle.sample.app'
       mainClass = 'org.gradle.sample.app.Main'
   }

samples/java/modules-multi-project/groovy/buildSrc/build.gradle

.. code-block::

   plugins {
       id 'groovy-gradle-plugin'
   }

samples/java/modules-multi-project/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle

.. code-block::

   plugins {
       id 'java'
   }
   
   version = '1.0.2'
   group = 'org.gradle.sample'
   
   repositories {
       mavenCentral()
   }
   
   tasks.named("test") {
       useJUnitPlatform()
   }
   
   dependencies {
       testImplementation 'org.junit.jupiter:junit-jupiter:5.7.1'
       testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
   }

samples/java/modules-multi-project/groovy/list/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }

samples/java/modules-multi-project/groovy/settings.gradle

.. code-block::

   rootProject.name = 'modules-multi-project'
   include 'application', 'list', 'utilities'

samples/java/modules-multi-project/groovy/utilities/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }
   
   dependencies {
       api project(':list')
   }

samples/java/modules-multi-project/kotlin/application/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       application
   }
   
   dependencies {
       implementation(project(":utilities"))
   }
   
   application {
       mainModule = "org.gradle.sample.app"
       mainClass = "org.gradle.sample.app.Main"
   }

samples/java/modules-multi-project/kotlin/buildSrc/build.gradle.kts

.. code-block::

   plugins {
       `kotlin-dsl`
   }
   
   repositories {
       mavenCentral()
   }

samples/java/modules-multi-project/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts

.. code-block::

   plugins {
       java
   }
   
   version = "1.0.2"
   group = "org.gradle.sample"
   
   repositories {
       mavenCentral()
   }
   
   tasks.test {
       useJUnitPlatform()
   }
   
   dependencies {
       testImplementation("org.junit.jupiter:junit-jupiter:5.7.1")
       testRuntimeOnly("org.junit.platform:junit-platform-launcher")
   }

samples/java/modules-multi-project/kotlin/list/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       `java-library`
   }

samples/java/modules-multi-project/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "modules-multi-project"
   include("application", "list", "utilities")

samples/java/modules-multi-project/kotlin/utilities/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       `java-library`
   }
   
   dependencies {
       api(project(":list"))
   }

samples/java/modules-multi-project/tests/checkTask.out

.. code-block::

   > Task :buildSrc:processResources
   > Task :buildSrc:classes
   > Task :buildSrc:jar
   > Task :list:compileJava
   > Task :list:processResources NO-SOURCE
   > Task :list:classes
   > Task :list:jar
   > Task :utilities:compileJava
   > Task :utilities:processResources NO-SOURCE
   > Task :utilities:classes
   > Task :utilities:jar
   > Task :application:compileJava
   > Task :application:processResources NO-SOURCE
   > Task :application:classes
   > Task :application:compileTestJava
   > Task :application:processTestResources NO-SOURCE
   > Task :application:testClasses
   > Task :application:test
   > Task :application:check
   > Task :list:compileTestJava
   > Task :list:processTestResources NO-SOURCE
   > Task :list:testClasses
   > Task :list:test
   > Task :list:check
   > Task :utilities:compileTestJava NO-SOURCE
   > Task :utilities:processTestResources NO-SOURCE
   > Task :utilities:testClasses UP-TO-DATE
   > Task :utilities:test NO-SOURCE
   > Task :utilities:check UP-TO-DATE
   
   BUILD SUCCESSFUL in 0s

samples/java/modules-multi-project/tests/runTask.out

.. code-block::

   > Task :buildSrc:jar UP-TO-DATE
   > Task :list:compileJava UP-TO-DATE
   > Task :list:processResources NO-SOURCE
   > Task :list:classes UP-TO-DATE
   > Task :list:jar UP-TO-DATE
   > Task :utilities:compileJava UP-TO-DATE
   > Task :utilities:processResources NO-SOURCE
   > Task :utilities:classes UP-TO-DATE
   > Task :utilities:jar UP-TO-DATE
   > Task :application:compileJava UP-TO-DATE
   > Task :application:processResources NO-SOURCE
   > Task :application:classes UP-TO-DATE
   > Task :application:jar
   
   > Task :application:run
   Hello, World!
   
   BUILD SUCCESSFUL in 0s

samples/java/modules-multi-project/tests/testTask.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: check
       expected-output-file: checkTask.out
       allow-additional-output: true
       allow-disordered-output: true
   },{
       executable: gradle
       args: run
       expected-output-file: runTask.out
       allow-additional-output: true
       allow-disordered-output: true
   }]

/Sample: 游릭 java/modules-multi-project-with-integration-tests
==========================================================

samples/java/modules-multi-project-with-integration-tests/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ's Gradle import].
   
   This is an link:#[extension of this sample] that adds blackbox integration tests.
   
   NOTE: There is also a link:#[new sample] demonstrating how to use the link:{userManualPath}#feature_lifecycle-sec:incubating_state[incubating] link:{userManualPath}#jvm_test_suite_plugin[Test Suite Plugin] in this scenario.
   
   Here, we add an additional source set _integrationTest_ with a `module-info.java`.
   
   ```
   src
   較덕較 integrationTest
       較덕較 java
           較덕較 module-info.java
   ```
   
   We effectively declare a second module that is only used for testing.
   The module is `open`, which means that it allows reflective access to its classes at runtime as required by JUnit's test execution engine.
   
   ```
   open module org.gradle.sample.integtest.utilities {
       requires org.gradle.sample.utilities;
       requires org.junit.jupiter.api;
   }
   ```
   
   NOTE: This sample does **not** work in Eclipse when imported using https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   This is due to https://bugs.eclipse.org/bugs/show_bug.cgi?id=520667[a limitation in Eclipse] that does not allow more than one module in one project.
   It you want to do blackbox testing in Eclipse, you should move the integration tests to separate subprojects.
   
   For more information, see link:{userManualPath}#java_library_plugin-sec:java_library_modular[Java Module support in the Java Library Plugin],
   link:{userManualPath}#application_plugin-sec:application_modular[Java Module support in the Application Plugin] and
   link:{userManualPath}#java_testing-sec:java_testing_modular[testing Java Modules].

samples/java/modules-multi-project-with-integration-tests/groovy/application/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'application'
   }
   
   dependencies {
       implementation project(':utilities')
   }
   
   application {
       mainModule = 'org.gradle.sample.app'
       mainClass = 'org.gradle.sample.app.Main'
   }

samples/java/modules-multi-project-with-integration-tests/groovy/buildSrc/build.gradle

.. code-block::

   plugins {
       id 'groovy-gradle-plugin'
   }

samples/java/modules-multi-project-with-integration-tests/groovy/buildSrc/src/main/groovy/myproject.java-conventions.gradle

.. code-block::

   plugins {
       id 'java'
   }
   
   version = '1.0.2'
   group = 'org.gradle.sample'
   
   repositories {
       mavenCentral()
   }
   
   def integrationTest = sourceSets.create('integrationTest')
   
   configurations[integrationTest.implementationConfigurationName].extendsFrom(configurations.testImplementation)
   configurations[integrationTest.runtimeOnlyConfigurationName].extendsFrom(configurations.testRuntimeOnly)
   
   tasks.named("test") {
       useJUnitPlatform()
   }
   
   def integrationTestJarTask = tasks.register(sourceSets.integrationTest.jarTaskName, Jar) {
       archiveClassifier = 'integration-tests'
       from integrationTest.output
   }
   
   def integrationTestTask = tasks.register('integrationTest', Test) {
       description = 'Runs integration tests.'
       group = 'verification'
       useJUnitPlatform()
   
       testClassesDirs = integrationTest.output.classesDirs
       // Make sure we run the 'Jar' containing the tests (and not just the 'classes' folder) so that test resources are also part of the test module
       classpath = configurations[integrationTest.runtimeClasspathConfigurationName] + files(integrationTestJarTask)
   
       shouldRunAfter(tasks.named('test'))
   }
   
   tasks.named('check') {
       dependsOn(integrationTestTask)
   }
   
   dependencies {
       testImplementation 'org.junit.jupiter:junit-jupiter:5.7.1'
       testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
   
       integrationTestImplementation project
   }

samples/java/modules-multi-project-with-integration-tests/groovy/list/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }

samples/java/modules-multi-project-with-integration-tests/groovy/settings.gradle

.. code-block::

   rootProject.name = 'modules-multi-project-with-integration-tests'
   include 'application', 'list', 'utilities'

samples/java/modules-multi-project-with-integration-tests/groovy/utilities/build.gradle

.. code-block::

   plugins {
       id 'myproject.java-conventions'
       id 'java-library'
   }
   
   dependencies {
       api project(':list')
   }

samples/java/modules-multi-project-with-integration-tests/kotlin/application/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       application
   }
   
   dependencies {
       implementation(project(":utilities"))
   }
   
   application {
       mainModule = "org.gradle.sample.app"
       mainClass = "org.gradle.sample.app.Main"
   }

samples/java/modules-multi-project-with-integration-tests/kotlin/buildSrc/build.gradle.kts

.. code-block::

   plugins {
       `kotlin-dsl`
   }
   
   repositories {
       mavenCentral()
   }

samples/java/modules-multi-project-with-integration-tests/kotlin/buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts

.. code-block::

   plugins {
       java
   }
   
   version = "1.0.2"
   group = "org.gradle.sample"
   
   repositories {
       mavenCentral()
   }
   
   val integrationTest by sourceSets.creating
   
   configurations[integrationTest.implementationConfigurationName].extendsFrom(configurations.testImplementation.get())
   configurations[integrationTest.runtimeOnlyConfigurationName].extendsFrom(configurations.testRuntimeOnly.get())
   
   tasks.test {
       useJUnitPlatform()
   }
   
   val integrationTestJarTask = tasks.register<Jar>(integrationTest.jarTaskName) {
       archiveClassifier = "integration-tests"
       from(integrationTest.output)
   }
   
   val integrationTestTask = tasks.register<Test>("integrationTest") {
       description = "Runs integration tests."
       group = "verification"
       useJUnitPlatform()
   
       testClassesDirs = integrationTest.output.classesDirs
       // Make sure we run the 'Jar' containing the tests (and not just the 'classes' folder) so that test resources are also part of the test module
       classpath = configurations[integrationTest.runtimeClasspathConfigurationName] + files(integrationTestJarTask)
   
       shouldRunAfter(tasks.test)
   }
   
   tasks.check {
       dependsOn(integrationTestTask)
   }
   
   dependencies {
       testImplementation("org.junit.jupiter:junit-jupiter:5.7.1")
       testRuntimeOnly("org.junit.platform:junit-platform-launcher")
   
       "integrationTestImplementation"(project)
   }

samples/java/modules-multi-project-with-integration-tests/kotlin/list/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       `java-library`
   }

samples/java/modules-multi-project-with-integration-tests/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "modules-multi-project-with-integration-tests"
   include("application", "list", "utilities")

samples/java/modules-multi-project-with-integration-tests/kotlin/utilities/build.gradle.kts

.. code-block::

   plugins {
       id("myproject.java-conventions")
       `java-library`
   }
   
   dependencies {
       api(project(":list"))
   }

samples/java/modules-multi-project-with-integration-tests/tests/checkTask.out

.. code-block::

   > Task :buildSrc:processResources
   > Task :buildSrc:classes
   > Task :buildSrc:jar
   > Task :list:compileJava
   > Task :list:processResources NO-SOURCE
   > Task :list:classes
   > Task :list:jar
   > Task :utilities:compileJava
   > Task :utilities:processResources NO-SOURCE
   > Task :utilities:classes
   > Task :utilities:jar
   > Task :application:compileJava
   > Task :application:processResources NO-SOURCE
   > Task :application:classes
   > Task :application:compileTestJava
   > Task :application:processTestResources NO-SOURCE
   > Task :application:testClasses
   > Task :application:test
   > Task :application:jar
   > Task :application:compileIntegrationTestJava
   > Task :application:processIntegrationTestResources NO-SOURCE
   > Task :application:integrationTestClasses
   > Task :application:integrationTestJar
   > Task :application:integrationTest
   > Task :application:check
   > Task :list:compileTestJava
   > Task :list:processTestResources NO-SOURCE
   > Task :list:testClasses
   > Task :list:test
   > Task :list:compileIntegrationTestJava NO-SOURCE
   > Task :list:processIntegrationTestResources NO-SOURCE
   > Task :list:integrationTestClasses UP-TO-DATE
   > Task :list:integrationTestJar
   > Task :list:integrationTest NO-SOURCE
   > Task :list:check
   > Task :utilities:compileTestJava NO-SOURCE
   > Task :utilities:processTestResources NO-SOURCE
   > Task :utilities:testClasses UP-TO-DATE
   > Task :utilities:test NO-SOURCE
   > Task :utilities:compileIntegrationTestJava
   > Task :utilities:processIntegrationTestResources NO-SOURCE
   > Task :utilities:integrationTestClasses
   > Task :utilities:integrationTestJar
   > Task :utilities:integrationTest
   > Task :utilities:check
   
   BUILD SUCCESSFUL in 0s

samples/java/modules-multi-project-with-integration-tests/tests/runTask.out

.. code-block::

   > Task :buildSrc:jar UP-TO-DATE
   > Task :list:compileJava UP-TO-DATE
   > Task :list:processResources NO-SOURCE
   > Task :list:classes UP-TO-DATE
   > Task :list:jar UP-TO-DATE
   > Task :utilities:compileJava UP-TO-DATE
   > Task :utilities:processResources NO-SOURCE
   > Task :utilities:classes UP-TO-DATE
   > Task :utilities:jar UP-TO-DATE
   > Task :application:compileJava UP-TO-DATE
   > Task :application:processResources NO-SOURCE
   > Task :application:classes UP-TO-DATE
   > Task :application:jar UP-TO-DATE
   
   > Task :application:run
   Hello, World!
   
   BUILD SUCCESSFUL in 0s

samples/java/modules-multi-project-with-integration-tests/tests/testTask.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: check
       expected-output-file: checkTask.out
       allow-additional-output: true
       allow-disordered-output: true
   },{
       executable: gradle
       args: run
       expected-output-file: runTask.out
       allow-additional-output: true
       allow-disordered-output: true
   }]

/Sample: 游릭 java/modules-with-transform
====================================

samples/java/modules-with-transform/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ's Gradle import] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how link:{userManualPath}#artifact_transforms[artifact transforms] can be utilised to turn traditional Java libraries into Java Modules by adding additional information to the corresponding Jars.
   For that, a plugin called `extra-java-module-info` is defined in the `buildSrc` folder.
   This plugin can be copied into another project and adjusted as needed to solve use cases where it is desired to treat every dependency as a Java Module.
   
   The example defines an application that relies on libraries from Maven central where some of them are not available as modules.
   It uses `commons-cli` (not a module) to parse the command line arguments, which can contain a JSON String, and `gson` (a proper module) to parse the JSON string.
   It also utilises `commons-lang3` (an automatic module) and `commons-beanutils` (not a module) which brings in some additional dependencies that are also not modules.
   
   By configuring our own `extra-java-module-info` plugin, we add information to turn the legacy libraries into modules.
   
   ====
   include::sample[dir="kotlin",files="application/build.gradle.kts[tags=extraModuleInfo]"]
   include::sample[dir="groovy",files="application/build.gradle[tags=extraModuleInfo]"]
   ====
   
   You can run the example application like this:
   
   ```
   run --args='-json {"message":"Hello","receivers":["Lisa","John"]} -debug'
   ```
   
   For more information, see link:{userManualPath}#java_library_plugin-sec:java_library_modular[Java Module support in the Java Library Plugin] and link:{userManualPath}#application_plugin-sec:application_modular[Java Module support in the Application Plugin].

samples/java/modules-with-transform/groovy/application/build.gradle

.. code-block::

   plugins {
       id 'application'
       id 'extra-java-module-info' // apply my own plugin written in buildSrc
   }
   
   version = '1.0.2'
   group = 'org.gradle.sample'
   
   repositories {
       mavenCentral()
   }
   
   // tag::extraModuleInfo[]
   extraJavaModuleInfo {
       // This does not have to be a complete description (e.g. here 'org.apache.commons.collections' does not export anything here).
       // It only needs to be good enough to work in the context of this application we are building.
       module('commons-beanutils-1.9.4.jar', 'org.apache.commons.beanutils', '1.9.4') {
           exports('org.apache.commons.beanutils')
   
           requires('org.apache.commons.logging')
           requires('java.sql')
           requires('java.desktop')
       }
       module('commons-cli-1.4.jar', 'org.apache.commons.cli', '3.2.2') {
           exports('org.apache.commons.cli')
       }
       module('commons-collections-3.2.2.jar', 'org.apache.commons.collections', '3.2.2')
       automaticModule('commons-logging-1.2.jar', 'org.apache.commons.logging')
   }
   // end::extraModuleInfo[]
   
   tasks.named('compileJava') {
       options.javaModuleVersion = provider { version }
   }
   
   dependencies {
       implementation 'com.google.code.gson:gson:2.8.9'           // real module
       implementation 'org.apache.commons:commons-lang3:3.10'     // automatic module
       implementation 'commons-beanutils:commons-beanutils:1.9.4' // plain library (also brings in other libraries transitively)
       implementation 'commons-cli:commons-cli:1.4'               // plain library
   }
   
   application {
       mainModule = 'org.gradle.sample.app'
       mainClass = 'org.gradle.sample.app.Main'
   }
   
   

samples/java/modules-with-transform/groovy/buildSrc/build.gradle

.. code-block::

   plugins {
       id 'java-gradle-plugin' // so we can assign and ID to our plugin
   }
   
   dependencies {
       implementation 'org.ow2.asm:asm:8.0.1'
   }
   
   repositories {
       mavenCentral()
   }
   
   gradlePlugin {
       plugins {
           // here we register our plugin with an ID
           register("extra-java-module-info") {
               id = "extra-java-module-info"
               implementationClass = "org.gradle.sample.transform.javamodules.ExtraModuleInfoPlugin"
           }
       }
   }

samples/java/modules-with-transform/groovy/settings.gradle

.. code-block::

   rootProject.name = 'modules-with-transform'
   include 'application'

samples/java/modules-with-transform/kotlin/application/build.gradle.kts

.. code-block::

   plugins {
       application
       id("extra-java-module-info") // apply my own plugin written in buildSrc
   }
   
   version = "1.0.2"
   group = "org.gradle.sample"
   
   repositories {
       mavenCentral()
   }
   
   tasks.compileJava {
       options.javaModuleVersion = provider({ version as String })
   }
   
   // tag::extraModuleInfo[]
   extraJavaModuleInfo {
       // This does not have to be a complete description (e.g. here 'org.apache.commons.collections' does not export anything here).
       // It only needs to be good enough to work in the context of this application we are building.
       module("commons-beanutils-1.9.4.jar", "org.apache.commons.beanutils", "1.9.4") {
           exports("org.apache.commons.beanutils")
   
           requires("org.apache.commons.logging")
           requires("java.sql")
           requires("java.desktop")
       }
       module("commons-cli-1.4.jar", "org.apache.commons.cli", "3.2.2") {
           exports("org.apache.commons.cli")
       }
       module("commons-collections-3.2.2.jar", "org.apache.commons.collections", "3.2.2")
       automaticModule("commons-logging-1.2.jar", "org.apache.commons.logging")
   }
   // end::extraModuleInfo[]
   
   dependencies {
       implementation("com.google.code.gson:gson:2.8.9")           // real module
       implementation("org.apache.commons:commons-lang3:3.10")     // automatic module
       implementation("commons-beanutils:commons-beanutils:1.9.4") // plain library (also brings in other libraries transitively)
       implementation("commons-cli:commons-cli:1.4")               // plain library
   }
   
   application {
       mainModule = "org.gradle.sample.app"
       mainClass = "org.gradle.sample.app.Main"
   }

samples/java/modules-with-transform/kotlin/buildSrc/build.gradle.kts

.. code-block::

   plugins {
       `java-gradle-plugin` // so we can assign and ID to our plugin
   }
   
   dependencies {
       implementation("org.ow2.asm:asm:8.0.1")
   }
   
   repositories {
       mavenCentral()
   }
   
   gradlePlugin {
       plugins {
           // here we register our plugin with an ID
           register("extra-java-module-info") {
               id = "extra-java-module-info"
               implementationClass = "org.gradle.sample.transform.javamodules.ExtraModuleInfoPlugin"
           }
       }
   }

samples/java/modules-with-transform/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "modules-with-transform"
   include("application")

samples/java/modules-with-transform/tests/runTask.out

.. code-block::

   org.gradle.sample.app - 1.0.2
   com.google.gson - 2.8.9
   org.apache.commons.lang3 - 3.10
   org.apache.commons.cli - 3.2.2
   org.apache.commons.beanutils - 1.9.4
   
   Original: Message{message='null', receivers=[]}
   Copy:     Message{message='null', receivers=[]}

samples/java/modules-with-transform/tests/runTask.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: run "--args=-debug" -q
       expected-output-file: runTask.out
   }]

/Sample: 游릭 spring-boot-web-application
====================================

samples/spring-boot-web-application/README.adoc

.. code-block::

   NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how a Spring Boot Web application can be built with Gradle.
   The application was generated using the https://start.spring.io/#!type=gradle-project[Spring Initializr].
   
   ====
   include::sample[dir="kotlin",files="app/build.gradle.kts[]"]
   include::sample[dir="groovy",files="app/build.gradle[]"]
   ====
   
   To build and run the application:
   
   [listing.terminal]
   ----
   $ ./gradlew bootRun
   
   > Task :app:bootRun
   
     .   ____          _            __ _ _
    /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
   ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
    \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
     '  |____| .__|_| |_|_| |_\__, | / / / /
    =========|_|==============|___/=/_/_/_/
    :: Spring Boot ::        (v2.2.1.RELEASE)
   
   2019-11-12 22:14:43.819  INFO 1389 --- [           main] o.g.samples.SpringBootDemoApplication    : Starting SpringBootDemoApplication on localhost with PID 1389 (/home/user/build/classes/java/main started by user in /home/user)
   2019-11-12 22:14:43.820  INFO 1389 --- [           main] o.g.samples.SpringBootDemoApplication    : No active profile set, falling back to default profiles: default
   2019-11-12 22:14:44.108  INFO 1389 --- [           main] o.g.samples.SpringBootDemoApplication    : Started SpringBootDemoApplication in 5.537 seconds (JVM running for 5.8)
   
   BUILD SUCCESSFUL
   3 actionable tasks: 3 executed
   ----
   
   For more information, we suggest reading link:{userManualPath}#getting_started[Getting Started with Gradle].
   You can also find https://spring.io/guides[Spring Boot related information inside the guides provided by the Spring team].
   
   // TODO:Finalize Upload Removal - Issue #21439

samples/spring-boot-web-application/groovy/app/build.gradle

.. code-block::

   plugins {
   	id 'org.springframework.boot' version '2.7.8'
   	id 'java'
   }
   
   version = '1.0.2'
   group = 'org.gradle.samples'
   
   java {
   	sourceCompatibility = JavaVersion.VERSION_1_8
   }
   
   repositories {
   	mavenCentral()
   }
   
   dependencies {
       implementation platform('org.springframework.boot:spring-boot-dependencies:2.7.8')
   
   	implementation 'org.springframework.boot:spring-boot-starter'
   	testImplementation('org.springframework.boot:spring-boot-starter-test') {
   		exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
   	}
       testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
   }
   
   tasks.named('test', Test) {
   	useJUnitPlatform()
   }

samples/spring-boot-web-application/groovy/settings.gradle

.. code-block::

   rootProject.name = 'spring-boot-demo'
   
   include 'app'

samples/spring-boot-web-application/kotlin/app/build.gradle.kts

.. code-block::

   plugins {
       id("org.springframework.boot") version("2.7.8")
       java
   }
   
   version = "1.0.2"
   group = "org.gradle.samples"
   
   java {
       sourceCompatibility = JavaVersion.VERSION_1_8
   }
   
   repositories {
       mavenCentral()
   }
   
   dependencies {
       implementation(platform("org.springframework.boot:spring-boot-dependencies:2.7.8"))
   
       implementation("org.springframework.boot:spring-boot-starter")
       testImplementation("org.springframework.boot:spring-boot-starter-test") {
           exclude(mapOf("group" to "org.junit.vintage", "module" to "junit-vintage-engine"))
       }
       testRuntimeOnly("org.junit.platform:junit-platform-launcher")
   }
   
   tasks.named<Test>("test") {
       useJUnitPlatform()
   }

samples/spring-boot-web-application/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "spring-boot-demo"
   
   include("app")

samples/spring-boot-web-application/tests/sanityCheck.sample.conf

.. code-block::

   executable: gradle
   args: tasks
   # Do not fail for deprecation warnings: Project.getConvention; Spring boot 3.0.2+ no longer uses that API
   flags: "--warning-mode=none"

samples/spring-boot-web-application/tests/testTask.out

.. code-block::

   > Task :app:compileJava
   > Task :app:processResources
   > Task :app:classes
   > Task :app:compileTestJava
   > Task :app:processTestResources NO-SOURCE
   > Task :app:testClasses
   > Task :app:test
   
   BUILD SUCCESSFUL in 0s
   4 actionable tasks: 4 executed

samples/spring-boot-web-application/tests/testTask.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: test
       expected-output-file: testTask.out
   # Do not fail for deprecation warnings: Project.getConvention; Spring boot 3.0.2+ no longer uses that API
       flags: "--warning-mode=none"
       allow-disordered-output: true
   }]

/Sample: 游릭 templates/build-src-plugin-java-module-transform
=========================================================

samples/templates/build-src-plugin-java-module-transform/application/src/main/java/module-info.java

.. code-block::

   module org.gradle.sample.app {
       exports org.gradle.sample.app;
       opens org.gradle.sample.app.data; // allow Gson to access via reflection
   
       requires com.google.gson;
       requires org.apache.commons.lang3;
       requires org.apache.commons.cli;
       requires org.apache.commons.beanutils;
   }

samples/templates/build-src-plugin-java-module-transform/application/src/main/java/org/gradle/sample/app/data/Message.java

.. code-block::

   package org.gradle.sample.app.data;
   
   import java.util.List;
   import java.util.ArrayList;
   
   public class Message {
       private String message;
       private List<String> receivers = new ArrayList<>();
   
       public String getMessage() {
           return message;
       }
   
       public void setMessage(String message) {
           this.message = message;
       }
   
       public List<String> getReceivers() {
           return receivers;
       }
   
       public void setReceivers(List<String> receivers) {
           this.receivers = receivers;
       }
   
       @Override
       public String toString() {
           return "Message{message='" + message + '\'' +
               ", receivers=" + receivers + '}';
       }
   }

samples/templates/build-src-plugin-java-module-transform/application/src/main/java/org/gradle/sample/app/Main.java

.. code-block::

   package org.gradle.sample.app;
   
   import com.google.gson.Gson;
   import org.apache.commons.beanutils.BeanUtils;
   import org.apache.commons.cli.CommandLine;
   import org.apache.commons.cli.CommandLineParser;
   import org.apache.commons.cli.DefaultParser;
   import org.apache.commons.cli.Options;
   import org.apache.commons.lang3.StringUtils;
   import org.gradle.sample.app.data.Message;
   
   public class Main {
   
       public static void main(String[] args) throws Exception {
           Options options = new Options();
           options.addOption("json", true, "data to parse");
           options.addOption("debug", false, "prints module infos");
           CommandLineParser parser = new DefaultParser();
           CommandLine cmd = parser.parse(options, args);
   
           if (cmd.hasOption("debug")) {
               printModuleDebug(Main.class);
               printModuleDebug(Gson.class);
               printModuleDebug(StringUtils.class);
               printModuleDebug(CommandLine.class);
               printModuleDebug(BeanUtils.class);
           }
   
           String json = cmd.getOptionValue("json");
           Message message = new Gson().fromJson(json == null ? "{}" : json, Message.class);
   
           Object copy = BeanUtils.cloneBean(message);
           System.out.println();
           System.out.println("Original: " + copy.toString());
           System.out.println("Copy:     " + copy.toString());
   
       }
   
       private static void printModuleDebug(Class<?> clazz) {
           System.out.println(clazz.getModule().getName() + " - " + clazz.getModule().getDescriptor().version().get());
       }
   
   }

samples/templates/build-src-plugin-java-module-transform/buildSrc/src/main/java/org/gradle/sample/transform/javamodules/ExtraModuleInfoPlugin.java

.. code-block::

   package org.gradle.sample.transform.javamodules;
   
   import org.gradle.api.Plugin;
   import org.gradle.api.Project;
   import org.gradle.api.artifacts.Configuration;
   import org.gradle.api.attributes.Attribute;
   import org.gradle.api.plugins.JavaPlugin;
   
   /**
    * Entry point of our plugin that should be applied in the root project.
    */
   public class ExtraModuleInfoPlugin implements Plugin<Project> {
   
       @Override
       public void apply(Project project) {
           // register the plugin extension as 'extraJavaModuleInfo {}' configuration block
           ExtraModuleInfoPluginExtension extension = project.getObjects().newInstance(ExtraModuleInfoPluginExtension.class);
           project.getExtensions().add(ExtraModuleInfoPluginExtension.class, "extraJavaModuleInfo", extension);
   
           // setup the transform for all projects in the build
           project.getPlugins().withType(JavaPlugin.class).configureEach(javaPlugin -> configureTransform(project, extension));
       }
   
       private void configureTransform(Project project, ExtraModuleInfoPluginExtension extension) {
           Attribute<String> artifactType = Attribute.of("artifactType", String.class);
           Attribute<Boolean> javaModule = Attribute.of("javaModule", Boolean.class);
   
           // compile and runtime classpath express that they only accept modules by requesting the javaModule=true attribute
           project.getConfigurations().matching(this::isResolvingJavaPluginConfiguration).all(
                   c -> c.getAttributes().attribute(javaModule, true));
   
           // all Jars have a javaModule=false attribute by default; the transform also recognizes modules and returns them without modification
           project.getDependencies().getArtifactTypes().getByName("jar").getAttributes().attribute(javaModule, false);
   
           // register the transform for Jars and "javaModule=false -> javaModule=true"; the plugin extension object fills the input parameter
           project.getDependencies().registerTransform(ExtraModuleInfoTransform.class, t -> {
               t.parameters(p -> {
                   p.setModuleInfo(extension.getModuleInfo());
                   p.setAutomaticModules(extension.getAutomaticModules());
               });
               t.getFrom().attribute(artifactType, "jar").attribute(javaModule, false);
               t.getTo().attribute(artifactType, "jar").attribute(javaModule, true);
           });
       }
   
       private boolean isResolvingJavaPluginConfiguration(Configuration configuration) {
           if (!configuration.isCanBeResolved()) {
               return false;
           }
           return configuration.getName().endsWith(JavaPlugin.COMPILE_CLASSPATH_CONFIGURATION_NAME.substring(1))
                   || configuration.getName().endsWith(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME.substring(1))
                   || configuration.getName().endsWith(JavaPlugin.ANNOTATION_PROCESSOR_CONFIGURATION_NAME.substring(1));
       }
   }

samples/templates/build-src-plugin-java-module-transform/buildSrc/src/main/java/org/gradle/sample/transform/javamodules/ExtraModuleInfoPluginExtension.java

.. code-block::

   package org.gradle.sample.transform.javamodules;
   
   
   import org.gradle.api.Action;
   
   import javax.annotation.Nullable;
   import java.util.HashMap;
   import java.util.Map;
   
   /**
    * A data class to collect all the module information we want to add.
    * Here the class is used as extension that can be configured in the build script
    * and as input to the ExtraModuleInfoTransform that add the information to Jars.
    */
   public class ExtraModuleInfoPluginExtension {
   
       private final Map<String, ModuleInfo> moduleInfo = new HashMap<>();
       private final Map<String, String> automaticModules = new HashMap<>();
   
       /**
        * Add full module information for a given Jar file.
        */
       public void module(String jarName, String moduleName, String moduleVersion) {
           module(jarName, moduleName, moduleVersion, null);
       }
   
       /**
        * Add full module information, including exported packages and dependencies, for a given Jar file.
        */
       public void module(String jarName, String moduleName, String moduleVersion, @Nullable Action<? super ModuleInfo> conf) {
           ModuleInfo moduleInfo = new ModuleInfo(moduleName, moduleVersion);
           if (conf != null) {
               conf.execute(moduleInfo);
           }
           this.moduleInfo.put(jarName, moduleInfo);
       }
   
       /**
        * Add only an automatic module name to a given jar file.
        */
       public void automaticModule(String jarName, String moduleName) {
           automaticModules.put(jarName, moduleName);
       }
   
       protected Map<String, ModuleInfo> getModuleInfo() {
           return moduleInfo;
       }
   
       protected Map<String, String> getAutomaticModules() {
           return automaticModules;
       }
   }

samples/templates/build-src-plugin-java-module-transform/buildSrc/src/main/java/org/gradle/sample/transform/javamodules/ExtraModuleInfoTransform.java

.. code-block::

   package org.gradle.sample.transform.javamodules;
   
   import org.gradle.api.artifacts.transform.InputArtifact;
   import org.gradle.api.artifacts.transform.TransformAction;
   import org.gradle.api.artifacts.transform.TransformOutputs;
   import org.gradle.api.artifacts.transform.TransformParameters;
   import org.gradle.api.file.FileSystemLocation;
   import org.gradle.api.provider.Provider;
   import org.gradle.api.tasks.Input;
   import org.objectweb.asm.ClassWriter;
   import org.objectweb.asm.ModuleVisitor;
   import org.objectweb.asm.Opcodes;
   
   import java.io.*;
   import java.util.Collections;
   import java.util.Map;
   import java.util.jar.*;
   import java.util.regex.Pattern;
   import java.util.zip.ZipEntry;
   
   /**
    * An artifact transform that applies additional information to Jars without module information.
    * The transformation fails the build if a Jar does not contain information and no extra information
    * was defined for it. This way we make sure that all Jars are turned into modules.
    */
   abstract public class ExtraModuleInfoTransform implements TransformAction<ExtraModuleInfoTransform.Parameter> {
   
       public static class Parameter implements TransformParameters, Serializable {
           private Map<String, ModuleInfo> moduleInfo = Collections.emptyMap();
           private Map<String, String> automaticModules = Collections.emptyMap();
   
           @Input
           public Map<String, ModuleInfo> getModuleInfo() {
               return moduleInfo;
           }
   
           @Input
           public Map<String, String> getAutomaticModules() {
               return automaticModules;
           }
   
           public void setModuleInfo(Map<String, ModuleInfo> moduleInfo) {
               this.moduleInfo = moduleInfo;
           }
   
           public void setAutomaticModules(Map<String, String> automaticModules) {
               this.automaticModules = automaticModules;
           }
       }
   
       @InputArtifact
       protected abstract Provider<FileSystemLocation> getInputArtifact();
   
       @Override
       public void transform(TransformOutputs outputs) {
           Map<String, ModuleInfo> moduleInfo = getParameters().moduleInfo;
           Map<String, String> automaticModules = getParameters().automaticModules;
           File originalJar = getInputArtifact().get().getAsFile();
           String originalJarName = originalJar.getName();
   
           if (isModule(originalJar)) {
               outputs.file(originalJar);
           } else if (moduleInfo.containsKey(originalJarName)) {
               addModuleDescriptor(originalJar, getModuleJar(outputs, originalJar), moduleInfo.get(originalJarName));
           } else if (isAutoModule(originalJar)) {
               outputs.file(originalJar);
           } else if (automaticModules.containsKey(originalJarName)) {
               addAutomaticModuleName(originalJar,  getModuleJar(outputs, originalJar), automaticModules.get(originalJarName));
           } else {
               throw new RuntimeException("Not a module and no mapping defined: " + originalJarName);
           }
       }
   
       private boolean isModule(File jar) {
           Pattern moduleInfoClassMrjarPath = Pattern.compile("META-INF/versions/\\d+/module-info.class");
           try (JarInputStream inputStream =  new JarInputStream(new FileInputStream(jar))) {
               boolean isMultiReleaseJar = containsMultiReleaseJarEntry(inputStream);
               ZipEntry next = inputStream.getNextEntry();
               while (next != null) {
                   if ("module-info.class".equals(next.getName())) {
                       return true;
                   }
                   if (isMultiReleaseJar && moduleInfoClassMrjarPath.matcher(next.getName()).matches()) {
                       return true;
                   }
                   next = inputStream.getNextEntry();
               }
           } catch (IOException e) {
               throw new RuntimeException(e);
           }
           return false;
       }
   
       private boolean containsMultiReleaseJarEntry(JarInputStream jarStream) {
           Manifest manifest = jarStream.getManifest();
           return manifest != null && Boolean.parseBoolean(manifest.getMainAttributes().getValue("Multi-Release"));
       }
   
       private boolean isAutoModule(File jar) {
           try (JarInputStream inputStream = new JarInputStream(new FileInputStream(jar))) {
               return inputStream.getManifest().getMainAttributes().getValue("Automatic-Module-Name") != null;
           } catch (IOException e) {
               throw new RuntimeException(e);
           }
       }
   
       private File getModuleJar(TransformOutputs outputs, File originalJar) {
           return outputs.file(originalJar.getName().substring(0, originalJar.getName().lastIndexOf('.')) + "-module.jar");
       }
   
       private static void addAutomaticModuleName(File originalJar, File moduleJar, String moduleName) {
           try (JarInputStream inputStream = new JarInputStream(new FileInputStream(originalJar))) {
               Manifest manifest = inputStream.getManifest();
               manifest.getMainAttributes().put(new Attributes.Name("Automatic-Module-Name"), moduleName);
               try (JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(moduleJar), inputStream.getManifest())) {
                   copyEntries(inputStream, outputStream);
               }
           } catch (IOException e) {
               throw new RuntimeException(e);
           }
       }
   
       private static void addModuleDescriptor(File originalJar, File moduleJar, ModuleInfo moduleInfo) {
           try (JarInputStream inputStream = new JarInputStream(new FileInputStream(originalJar))) {
               try (JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(moduleJar), inputStream.getManifest())) {
                   copyEntries(inputStream, outputStream);
                   outputStream.putNextEntry(new JarEntry("module-info.class"));
                   outputStream.write(addModuleInfo(moduleInfo));
                   outputStream.closeEntry();
               }
           } catch (IOException e) {
               throw new RuntimeException(e);
           }
       }
   
       private static void copyEntries(JarInputStream inputStream, JarOutputStream outputStream) throws IOException {
           JarEntry jarEntry = inputStream.getNextJarEntry();
           while (jarEntry != null) {
               outputStream.putNextEntry(jarEntry);
               outputStream.write(inputStream.readAllBytes());
               outputStream.closeEntry();
               jarEntry = inputStream.getNextJarEntry();
           }
       }
   
       private static byte[] addModuleInfo(ModuleInfo moduleInfo) {
           ClassWriter classWriter = new ClassWriter(0);
           classWriter.visit(Opcodes.V9, Opcodes.ACC_MODULE, "module-info", null, null, null);
           ModuleVisitor moduleVisitor = classWriter.visitModule(moduleInfo.getModuleName(), Opcodes.ACC_OPEN, moduleInfo.getModuleVersion());
           for (String packageName : moduleInfo.getExports()) {
               moduleVisitor.visitExport(packageName.replace('.', '/'), 0);
           }
           moduleVisitor.visitRequire("java.base", 0, null);
           for (String requireName : moduleInfo.getRequires()) {
               moduleVisitor.visitRequire(requireName, 0, null);
           }
           for (String requireName : moduleInfo.getRequiresTransitive()) {
               moduleVisitor.visitRequire(requireName, Opcodes.ACC_TRANSITIVE, null);
           }
           moduleVisitor.visitEnd();
           classWriter.visitEnd();
           return classWriter.toByteArray();
       }
   }

samples/templates/build-src-plugin-java-module-transform/buildSrc/src/main/java/org/gradle/sample/transform/javamodules/ModuleInfo.java

.. code-block::

   package org.gradle.sample.transform.javamodules;
   
   import java.io.Serializable;
   import java.util.ArrayList;
   import java.util.List;
   
   /**
    * Data class to hold the information that should be added as module-info.class to an existing Jar file.
    */
   public class ModuleInfo implements Serializable {
       private String moduleName;
       private String moduleVersion;
       private List<String> exports = new ArrayList<>();
       private List<String> requires = new ArrayList<>();
       private List<String> requiresTransitive = new ArrayList<>();
   
       ModuleInfo(String moduleName, String moduleVersion) {
           this.moduleName = moduleName;
           this.moduleVersion = moduleVersion;
       }
   
       public void exports(String exports) {
           this.exports.add(exports);
       }
   
       public void requires(String requires) {
           this.requires.add(requires);
       }
   
       public void requiresTransitive(String requiresTransitive) {
           this.requiresTransitive.add(requiresTransitive);
       }
   
       public String getModuleName() {
           return moduleName;
       }
   
       protected String getModuleVersion() {
           return moduleVersion;
       }
   
       protected List<String> getExports() {
           return exports;
       }
   
       protected List<String> getRequires() {
           return requires;
       }
   
       protected List<String> getRequiresTransitive() {
           return requiresTransitive;
       }
   }

/Sample: 游릭 templates/gradle-plugin-in-java
========================================

samples/templates/gradle-plugin-in-java/src/functionalTest/java/com/example/plugin/GreetingPluginFunctionalTest.java

.. code-block::

   package com.example.plugin;
   
   import org.gradle.testkit.runner.BuildResult;
   import org.gradle.testkit.runner.GradleRunner;
   import org.junit.Test;
   
   import java.io.File;
   import java.io.FileWriter;
   import java.io.IOException;
   import java.io.Writer;
   import java.nio.file.Files;
   
   import static org.junit.Assert.assertTrue;
   
   
   public class GreetingPluginFunctionalTest {
       @Test
       public void canRunTask() throws IOException {
           // Setup the test build
           File projectDir = new File("build/functionalTest");
           Files.createDirectories(projectDir.toPath());
           writeString(new File(projectDir, "settings.gradle"), "");
           writeString(new File(projectDir, "build.gradle"),
               "plugins {" +
                   "  id('com.example.plugin.greeting')" +
                   "}");
   
           // Run the build
           BuildResult result = GradleRunner.create()
               .forwardOutput()
               .withPluginClasspath()
               .withArguments("greet")
               .withProjectDir(projectDir)
               .build();
   
           // Verify the result
           assertTrue(result.getOutput().contains("Hello from plugin 'com.example.plugin.greeting'"));
       }
   
       private void writeString(File file, String string) throws IOException {
           try (Writer writer = new FileWriter(file)) {
               writer.write(string);
           }
       }
   }

samples/templates/gradle-plugin-in-java/src/main/java/com/example/plugin/GreetingPlugin.java

.. code-block::

   package com.example.plugin;
   
   import org.gradle.api.Plugin;
   import org.gradle.api.Project;
   
   public class GreetingPlugin implements Plugin<Project> {
       public void apply(Project project) {
           project.getTasks().register("greet", task -> {
               task.doLast(s -> System.out.println("Hello from plugin 'com.example.plugin.greeting'"));
           });
       }
   }

samples/templates/gradle-plugin-in-java/src/test/java/com/example/plugin/GreetingPluginTest.java

.. code-block::

   package com.example.plugin;
   
   import org.gradle.testfixtures.ProjectBuilder;
   import org.gradle.api.Project;
   import org.junit.Test;
   import static org.junit.Assert.assertNotNull;
   
   
   public class GreetingPluginTest {
       @Test
       public void pluginRegistersATask() {
           // Create a test project and apply the plugin
           Project project = ProjectBuilder.builder().build();
           project.getPlugins().apply("com.example.plugin.greeting");
   
           // Verify the result
           assertNotNull(project.getTasks().findByName("greet"));
       }
   }

/Sample: 游릭 templates/groovy-list-library/src/main/groovy/org/gradle/sample/list
=============================================================================

samples/templates/groovy-list-library/src/main/groovy/org/gradle/sample/list/LinkedList.groovy

.. code-block::

   package org.gradle.sample.list
   
   class LinkedList {
       private Node head
   
       void add(String element) {
           Node newNode = new Node(element)
   
           Node it = tail(head)
           if (it == null) {
               head = newNode
           } else {
               it.next = newNode
           }
       }
   
       private static Node tail(Node head) {
           Node it
   
           for (it = head; it != null && it.next != null; it = it.next) {}
   
           return it
       }
   
       boolean remove(String element) {
           boolean result = false
           Node previousIt = null
           Node it = null
           for (it = head; !result && it != null; it = it.next) {
               if (element <=> it.data == 0) {
                   result = true
                   unlink(previousIt, it)
                   break
               }
               previousIt = it
           }
   
           return result
       }
   
       private void unlink(Node previousIt, Node currentIt) {
           if (currentIt == head) {
               head = currentIt.next
           } else {
               previousIt.next = currentIt.next
           }
       }
   
       int size() {
           int size = 0
   
           for (Node it = head; it != null; it = it.next) {
               ++size
           }
   
           return size
       }
   
       String get(int index) {
           Node it = head
           while (index > 0 && it != null) {
               it = it.next
               index--
           }
   
           if (it == null) {
               throw new IndexOutOfBoundsException("Index is out of range")
           }
   
           return it.data
       }
   
       private static class Node {
           final String data
           Node next
   
           Node(String data) {
               this.data = data
           }
       }
   }

samples/templates/groovy-utilities-library/src/main/groovy/org/gradle/sample/utilities/JoinUtils.groovy

.. code-block::

   package org.gradle.sample.utilities
   
   import groovy.transform.PackageScope
   import org.gradle.sample.list.LinkedList
   
   @PackageScope
   class JoinUtils {
       static String join(LinkedList source) {
           StringBuilder result = new StringBuilder()
           for (int i = 0; i < source.size(); ++i) {
               if (result.length() > 0) {
                   result.append(' ')
               }
               result.append(source.get(i))
           }
   
           return result.toString()
       }
   }

samples/templates/groovy-utilities-library/src/main/groovy/org/gradle/sample/utilities/SplitUtils.groovy

.. code-block::

   package org.gradle.sample.utilities
   
   import groovy.transform.PackageScope
   import org.gradle.sample.list.LinkedList
   
   @PackageScope
   class SplitUtils {
       static LinkedList split(String source) {
           int lastFind = 0
           int currentFind = 0
           LinkedList result = new LinkedList()
   
           while ((currentFind = source.indexOf(' ', lastFind)) != -1) {
               String token = source.substring(lastFind)
               if (currentFind != -1) {
                   token = token.substring(0, currentFind - lastFind)
               }
   
               addIfValid(token, result)
               lastFind = currentFind + 1
           }
   
           String token = source.substring(lastFind)
           addIfValid(token, result)
   
           return result
       }
   
       private static void addIfValid(String token, LinkedList list) {
           if (isTokenValid(token)) {
               list.add(token)
           }
       }
   
       private static boolean isTokenValid(String token) {
           return !token.isEmpty()
       }
   }

samples/templates/groovy-utilities-library/src/main/groovy/org/gradle/sample/utilities/StringUtils.groovy

.. code-block::

   package org.gradle.sample.utilities
   
   import org.gradle.sample.list.LinkedList
   
   class StringUtils {
       static String join(LinkedList source) {
           return JoinUtils.join(source)
       }
   
       static LinkedList split(String source) {
           return SplitUtils.split(source)
       }
   }

/Sample: 游릭 templates/java-android-application
===========================================

samples/templates/java-android-application/gradle.properties

.. code-block::

   # Project-wide Gradle settings.
   # IDE (e.g. Android Studio) users:
   # Gradle settings configured through the IDE *will override*
   # any settings specified in this file.
   # For more details on how to configure your build environment visit
   # http://www.gradle.org/docs/current/userguide/build_environment.html
   # Specifies the JVM arguments used for the daemon process.
   # The setting is particularly useful for tweaking memory settings.
   org.gradle.jvmargs=-Xmx1536m
   # When configured, Gradle will run in incubating parallel mode.
   # This option should only be used with decoupled projects. More details, visit
   # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
   # org.gradle.parallel=true
   # AndroidX package structure to make it clearer which packages are bundled with the
   # Android operating system, and which are packaged with your app's APK
   # https://developer.android.com/topic/libraries/support-library/androidx-rn
   android.useAndroidX=true
   # Automatically convert third-party libraries to use AndroidX
   android.enableJetifier=true
   

samples/templates/java-android-application/proguard-rules.pro

.. code-block::

   # Add project specific ProGuard rules here.
   # You can control the set of applied configuration files using the
   # proguardFiles setting in build.gradle.
   #
   # For more details, see
   #   http://developer.android.com/guide/developing/tools/proguard.html
   
   # If your project uses WebView with JS, uncomment the following
   # and specify the fully qualified class name to the JavaScript interface
   # class:
   #-keepclassmembers class fqcn.of.javascript.interface.for.webview {
   #   public *;
   #}
   
   # Uncomment this to preserve the line number information for
   # debugging stack traces.
   #-keepattributes SourceFile,LineNumberTable
   
   # If you keep the line number information, uncomment this to
   # hide the original source file name.
   #-renamesourcefileattribute SourceFile

samples/templates/java-android-application/app/.gitignore

.. code-block::

   /build

samples/templates/java-android-application/app/proguard-rules.pro

.. code-block::

   # Add project specific ProGuard rules here.
   # You can control the set of applied configuration files using the
   # proguardFiles setting in build.gradle.
   #
   # For more details, see
   #   http://developer.android.com/guide/developing/tools/proguard.html
   
   # If your project uses WebView with JS, uncomment the following
   # and specify the fully qualified class name to the JavaScript interface
   # class:
   #-keepclassmembers class fqcn.of.javascript.interface.for.webview {
   #   public *;
   #}
   
   # Uncomment this to preserve the line number information for
   # debugging stack traces.
   #-keepattributes SourceFile,LineNumberTable
   
   # If you keep the line number information, uncomment this to
   # hide the original source file name.
   #-renamesourcefileattribute SourceFile

samples/templates/java-android-application/app/src/androidTest/java/org/gradle/samples/ExampleInstrumentedTest.java

.. code-block::

   package org.gradle.samples;
   
   import android.content.Context;
   
   import androidx.test.platform.app.InstrumentationRegistry;
   import androidx.test.ext.junit.runners.AndroidJUnit4;
   
   import org.junit.Test;
   import org.junit.runner.RunWith;
   
   import static org.junit.Assert.*;
   
   /**
    * Instrumented test, which will execute on an Android device.
    *
    * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
    */
   @RunWith(AndroidJUnit4.class)
   public class ExampleInstrumentedTest {
       @Test
       public void useAppContext() {
           // Context of the app under test.
           Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
   
           assertEquals("org.gradle.samples", appContext.getPackageName());
       }
   }

samples/templates/java-android-application/app/src/main/AndroidManifest.xml

.. code-block::

   <?xml version="1.0" encoding="utf-8"?>
   <manifest xmlns:android="http://schemas.android.com/apk/res/android"
       package="org.gradle.samples">
   
       <application
           android:allowBackup="true"
           android:icon="@mipmap/ic_launcher"
           android:label="@string/app_name"
           android:roundIcon="@mipmap/ic_launcher_round"
           android:supportsRtl="true"
           android:theme="@style/AppTheme">
           <activity android:name=".MainActivity">
               <intent-filter>
                   <action android:name="android.intent.action.MAIN" />
   
                   <category android:name="android.intent.category.LAUNCHER" />
               </intent-filter>
           </activity>
       </application>
   
   </manifest>samples/templates/java-android-application/app/src/main/java/org/gradle/samples/MainActivity.java

.. code-block::

   package org.gradle.samples;
   
   import androidx.appcompat.app.AppCompatActivity;
   
   import android.os.Bundle;
   
   public class MainActivity extends AppCompatActivity {
   
       @Override
       protected void onCreate(Bundle savedInstanceState) {
           super.onCreate(savedInstanceState);
           setContentView(R.layout.activity_main);
       }
   }

samples/templates/java-android-application/app/src/main/res/drawable/ic_launcher_background.xml

.. code-block::

   <?xml version="1.0" encoding="utf-8"?>
   <vector xmlns:android="http://schemas.android.com/apk/res/android"
       android:width="108dp"
       android:height="108dp"
       android:viewportWidth="108"
       android:viewportHeight="108">
       <path
           android:fillColor="#008577"
           android:pathData="M0,0h108v108h-108z" />
       <path
           android:fillColor="#00000000"
           android:pathData="M9,0L9,108"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M19,0L19,108"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M29,0L29,108"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M39,0L39,108"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M49,0L49,108"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M59,0L59,108"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M69,0L69,108"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M79,0L79,108"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M89,0L89,108"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M99,0L99,108"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M0,9L108,9"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M0,19L108,19"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M0,29L108,29"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M0,39L108,39"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M0,49L108,49"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M0,59L108,59"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M0,69L108,69"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M0,79L108,79"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M0,89L108,89"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M0,99L108,99"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M19,29L89,29"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M19,39L89,39"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M19,49L89,49"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M19,59L89,59"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M19,69L89,69"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M19,79L89,79"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M29,19L29,89"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M39,19L39,89"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M49,19L49,89"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M59,19L59,89"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M69,19L69,89"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M79,19L79,89"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
   </vector>

samples/templates/java-android-application/app/src/main/res/drawable-v24/ic_launcher_foreground.xml

.. code-block::

   <vector xmlns:android="http://schemas.android.com/apk/res/android"
       xmlns:aapt="http://schemas.android.com/aapt"
       android:width="108dp"
       android:height="108dp"
       android:viewportWidth="108"
       android:viewportHeight="108">
       <path
           android:fillType="evenOdd"
           android:pathData="M32,64C32,64 38.39,52.99 44.13,50.95C51.37,48.37 70.14,49.57 70.14,49.57L108.26,87.69L108,109.01L75.97,107.97L32,64Z"
           android:strokeWidth="1"
           android:strokeColor="#00000000">
           <aapt:attr name="android:fillColor">
               <gradient
                   android:endX="78.5885"
                   android:endY="90.9159"
                   android:startX="48.7653"
                   android:startY="61.0927"
                   android:type="linear">
                   <item
                       android:color="#44000000"
                       android:offset="0.0" />
                   <item
                       android:color="#00000000"
                       android:offset="1.0" />
               </gradient>
           </aapt:attr>
       </path>
       <path
           android:fillColor="#FFFFFF"
           android:fillType="nonZero"
           android:pathData="M66.94,46.02L66.94,46.02C72.44,50.07 76,56.61 76,64L32,64C32,56.61 35.56,50.11 40.98,46.06L36.18,41.19C35.45,40.45 35.45,39.3 36.18,38.56C36.91,37.81 38.05,37.81 38.78,38.56L44.25,44.05C47.18,42.57 50.48,41.71 54,41.71C57.48,41.71 60.78,42.57 63.68,44.05L69.11,38.56C69.84,37.81 70.98,37.81 71.71,38.56C72.44,39.3 72.44,40.45 71.71,41.19L66.94,46.02ZM62.94,56.92C64.08,56.92 65,56.01 65,54.88C65,53.76 64.08,52.85 62.94,52.85C61.8,52.85 60.88,53.76 60.88,54.88C60.88,56.01 61.8,56.92 62.94,56.92ZM45.06,56.92C46.2,56.92 47.13,56.01 47.13,54.88C47.13,53.76 46.2,52.85 45.06,52.85C43.92,52.85 43,53.76 43,54.88C43,56.01 43.92,56.92 45.06,56.92Z"
           android:strokeWidth="1"
           android:strokeColor="#00000000" />
   </vector>

samples/templates/java-android-application/app/src/main/res/layout/activity_main.xml

.. code-block::

   <?xml version="1.0" encoding="utf-8"?>
   <androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
       xmlns:app="http://schemas.android.com/apk/res-auto"
       xmlns:tools="http://schemas.android.com/tools"
       android:layout_width="match_parent"
       android:layout_height="match_parent"
       tools:context=".MainActivity">
   
       <TextView
           android:layout_width="wrap_content"
           android:layout_height="wrap_content"
           android:text="Hello World!"
           app:layout_constraintBottom_toBottomOf="parent"
           app:layout_constraintLeft_toLeftOf="parent"
           app:layout_constraintRight_toRightOf="parent"
           app:layout_constraintTop_toTopOf="parent" />
   
   </androidx.constraintlayout.widget.ConstraintLayout>samples/templates/java-android-application/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml

.. code-block::

   <?xml version="1.0" encoding="utf-8"?>
   <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
       <background android:drawable="@drawable/ic_launcher_background" />
       <foreground android:drawable="@drawable/ic_launcher_foreground" />
   </adaptive-icon>samples/templates/java-android-application/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml

.. code-block::

   <?xml version="1.0" encoding="utf-8"?>
   <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
       <background android:drawable="@drawable/ic_launcher_background" />
       <foreground android:drawable="@drawable/ic_launcher_foreground" />
   </adaptive-icon>samples/templates/java-android-application/app/src/main/res/values/colors.xml

.. code-block::

   <?xml version="1.0" encoding="utf-8"?>
   <resources>
       <color name="colorPrimary">#008577</color>
       <color name="colorPrimaryDark">#00574B</color>
       <color name="colorAccent">#D81B60</color>
   </resources>

samples/templates/java-android-application/app/src/main/res/values/strings.xml

.. code-block::

   <resources>
       <string name="app_name">My First App</string>
   </resources>

samples/templates/java-android-application/app/src/main/res/values/styles.xml

.. code-block::

   <resources>
   
       <!-- Base application theme. -->
       <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
           <!-- Customize your theme here. -->
           <item name="colorPrimary">@color/colorPrimary</item>
           <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
           <item name="colorAccent">@color/colorAccent</item>
       </style>
   
   </resources>

samples/templates/java-android-application/app/src/test/java/org/gradle/samples/ExampleUnitTest.java

.. code-block::

   package org.gradle.samples;
   
   import org.junit.Test;
   
   import static org.junit.Assert.*;
   
   /**
    * Example local unit test, which will execute on the development machine (host).
    *
    * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
    */
   public class ExampleUnitTest {
       @Test
       public void addition_isCorrect() {
           assertEquals(4, 2 + 2);
       }
   }

samples/templates/java-android-application/src/androidTest/java/org/gradle/samples/ExampleInstrumentedTest.java

.. code-block::

   package org.gradle.samples;
   
   import android.content.Context;
   
   import androidx.test.platform.app.InstrumentationRegistry;
   import androidx.test.ext.junit.runners.AndroidJUnit4;
   
   import org.junit.Test;
   import org.junit.runner.RunWith;
   
   import static org.junit.Assert.*;
   
   /**
    * Instrumented test, which will execute on an Android device.
    *
    * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
    */
   @RunWith(AndroidJUnit4.class)
   public class ExampleInstrumentedTest {
       @Test
       public void useAppContext() {
           // Context of the app under test.
           Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
   
           assertEquals("org.gradle.samples", appContext.getPackageName());
       }
   }

samples/templates/java-android-application/src/main/AndroidManifest.xml

.. code-block::

   <?xml version="1.0" encoding="utf-8"?>
   <manifest xmlns:android="http://schemas.android.com/apk/res/android"
       package="org.gradle.samples">
   
       <application
           android:allowBackup="true"
           android:icon="@mipmap/ic_launcher"
           android:label="@string/app_name"
           android:roundIcon="@mipmap/ic_launcher_round"
           android:supportsRtl="true"
           android:theme="@style/AppTheme">
           <activity android:name=".MainActivity">
               <intent-filter>
                   <action android:name="android.intent.action.MAIN" />
   
                   <category android:name="android.intent.category.LAUNCHER" />
               </intent-filter>
           </activity>
       </application>
   
   </manifest>samples/templates/java-android-application/src/main/java/org/gradle/samples/MainActivity.java

.. code-block::

   package org.gradle.samples;
   
   import androidx.appcompat.app.AppCompatActivity;
   
   import android.os.Bundle;
   
   public class MainActivity extends AppCompatActivity {
   
       @Override
       protected void onCreate(Bundle savedInstanceState) {
           super.onCreate(savedInstanceState);
           setContentView(R.layout.activity_main);
       }
   }

samples/templates/java-android-application/src/main/res/drawable/ic_launcher_background.xml

.. code-block::

   <?xml version="1.0" encoding="utf-8"?>
   <vector xmlns:android="http://schemas.android.com/apk/res/android"
       android:width="108dp"
       android:height="108dp"
       android:viewportWidth="108"
       android:viewportHeight="108">
       <path
           android:fillColor="#008577"
           android:pathData="M0,0h108v108h-108z" />
       <path
           android:fillColor="#00000000"
           android:pathData="M9,0L9,108"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M19,0L19,108"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M29,0L29,108"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M39,0L39,108"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M49,0L49,108"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M59,0L59,108"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M69,0L69,108"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M79,0L79,108"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M89,0L89,108"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M99,0L99,108"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M0,9L108,9"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M0,19L108,19"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M0,29L108,29"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M0,39L108,39"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M0,49L108,49"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M0,59L108,59"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M0,69L108,69"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M0,79L108,79"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M0,89L108,89"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M0,99L108,99"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M19,29L89,29"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M19,39L89,39"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M19,49L89,49"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M19,59L89,59"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M19,69L89,69"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M19,79L89,79"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M29,19L29,89"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M39,19L39,89"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M49,19L49,89"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M59,19L59,89"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M69,19L69,89"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
       <path
           android:fillColor="#00000000"
           android:pathData="M79,19L79,89"
           android:strokeWidth="0.8"
           android:strokeColor="#33FFFFFF" />
   </vector>

samples/templates/java-android-application/src/main/res/drawable-v24/ic_launcher_foreground.xml

.. code-block::

   <vector xmlns:android="http://schemas.android.com/apk/res/android"
       xmlns:aapt="http://schemas.android.com/aapt"
       android:width="108dp"
       android:height="108dp"
       android:viewportWidth="108"
       android:viewportHeight="108">
       <path
           android:fillType="evenOdd"
           android:pathData="M32,64C32,64 38.39,52.99 44.13,50.95C51.37,48.37 70.14,49.57 70.14,49.57L108.26,87.69L108,109.01L75.97,107.97L32,64Z"
           android:strokeWidth="1"
           android:strokeColor="#00000000">
           <aapt:attr name="android:fillColor">
               <gradient
                   android:endX="78.5885"
                   android:endY="90.9159"
                   android:startX="48.7653"
                   android:startY="61.0927"
                   android:type="linear">
                   <item
                       android:color="#44000000"
                       android:offset="0.0" />
                   <item
                       android:color="#00000000"
                       android:offset="1.0" />
               </gradient>
           </aapt:attr>
       </path>
       <path
           android:fillColor="#FFFFFF"
           android:fillType="nonZero"
           android:pathData="M66.94,46.02L66.94,46.02C72.44,50.07 76,56.61 76,64L32,64C32,56.61 35.56,50.11 40.98,46.06L36.18,41.19C35.45,40.45 35.45,39.3 36.18,38.56C36.91,37.81 38.05,37.81 38.78,38.56L44.25,44.05C47.18,42.57 50.48,41.71 54,41.71C57.48,41.71 60.78,42.57 63.68,44.05L69.11,38.56C69.84,37.81 70.98,37.81 71.71,38.56C72.44,39.3 72.44,40.45 71.71,41.19L66.94,46.02ZM62.94,56.92C64.08,56.92 65,56.01 65,54.88C65,53.76 64.08,52.85 62.94,52.85C61.8,52.85 60.88,53.76 60.88,54.88C60.88,56.01 61.8,56.92 62.94,56.92ZM45.06,56.92C46.2,56.92 47.13,56.01 47.13,54.88C47.13,53.76 46.2,52.85 45.06,52.85C43.92,52.85 43,53.76 43,54.88C43,56.01 43.92,56.92 45.06,56.92Z"
           android:strokeWidth="1"
           android:strokeColor="#00000000" />
   </vector>

samples/templates/java-android-application/src/main/res/layout/activity_main.xml

.. code-block::

   <?xml version="1.0" encoding="utf-8"?>
   <androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
       xmlns:app="http://schemas.android.com/apk/res-auto"
       xmlns:tools="http://schemas.android.com/tools"
       android:layout_width="match_parent"
       android:layout_height="match_parent"
       tools:context=".MainActivity">
   
       <TextView
           android:layout_width="wrap_content"
           android:layout_height="wrap_content"
           android:text="Hello World!"
           app:layout_constraintBottom_toBottomOf="parent"
           app:layout_constraintLeft_toLeftOf="parent"
           app:layout_constraintRight_toRightOf="parent"
           app:layout_constraintTop_toTopOf="parent" />
   
   </androidx.constraintlayout.widget.ConstraintLayout>samples/templates/java-android-application/src/main/res/mipmap-anydpi-v26/ic_launcher.xml

.. code-block::

   <?xml version="1.0" encoding="utf-8"?>
   <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
       <background android:drawable="@drawable/ic_launcher_background" />
       <foreground android:drawable="@drawable/ic_launcher_foreground" />
   </adaptive-icon>samples/templates/java-android-application/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml

.. code-block::

   <?xml version="1.0" encoding="utf-8"?>
   <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
       <background android:drawable="@drawable/ic_launcher_background" />
       <foreground android:drawable="@drawable/ic_launcher_foreground" />
   </adaptive-icon>samples/templates/java-android-application/src/main/res/values/colors.xml

.. code-block::

   <?xml version="1.0" encoding="utf-8"?>
   <resources>
       <color name="colorPrimary">#008577</color>
       <color name="colorPrimaryDark">#00574B</color>
       <color name="colorAccent">#D81B60</color>
   </resources>

samples/templates/java-android-application/src/main/res/values/strings.xml

.. code-block::

   <resources>
       <string name="app_name">My First App</string>
   </resources>

samples/templates/java-android-application/src/main/res/values/styles.xml

.. code-block::

   <resources>
   
       <!-- Base application theme. -->
       <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
           <!-- Customize your theme here. -->
           <item name="colorPrimary">@color/colorPrimary</item>
           <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
           <item name="colorAccent">@color/colorAccent</item>
       </style>
   
   </resources>

samples/templates/java-android-application/src/test/java/org/gradle/samples/ExampleUnitTest.java

.. code-block::

   package org.gradle.samples;
   
   import org.junit.Test;
   
   import static org.junit.Assert.*;
   
   /**
    * Example local unit test, which will execute on the development machine (host).
    *
    * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
    */
   public class ExampleUnitTest {
       @Test
       public void addition_isCorrect() {
           assertEquals(4, 2 + 2);
       }
   }

/Sample: 游릭 templates/java-application
===================================

samples/templates/java-application/src/main/java/org/gradle/sample/app/Main.java

.. code-block::

   package org.gradle.sample.app;
   
   import org.gradle.sample.list.LinkedList;
   
   import static org.gradle.sample.utilities.StringUtils.join;
   import static org.gradle.sample.utilities.StringUtils.split;
   import static org.gradle.sample.app.MessageUtils.getMessage;
   
   public class Main {
       public static void main(String[] args) {
           LinkedList tokens;
           tokens = split(getMessage());
           System.out.println(join(tokens));
       }
   }

samples/templates/java-application/src/main/java/org/gradle/sample/app/MessageUtils.java

.. code-block::

   package org.gradle.sample.app;
   
   class MessageUtils {
       public static String getMessage() {
           return "Hello,      World!";
       }
   }

/Sample: 游릭 templates/java-junit5-integration-test-for-application
===============================================================

samples/templates/java-junit5-integration-test-for-application/src/integrationTest/java/org/gradle/sample/integtest/app/MainIntegrationTest.java

.. code-block::

   package org.gradle.sample.integtest.app;
   
   import org.junit.jupiter.api.Test;
   
   import java.io.ByteArrayOutputStream;
   import java.io.PrintStream;
   import java.io.PrintWriter;
   import java.io.StringWriter;
   
   import org.gradle.sample.app.Main;
   
   import static org.junit.jupiter.api.Assertions.assertEquals;
   
   
   public class MainIntegrationTest {
       @Test
       public void testMain() {
           PrintStream savedOut = System.out;
           try {
               ByteArrayOutputStream outStreamForTesting = new ByteArrayOutputStream();
               System.setOut(new PrintStream(outStreamForTesting));
   
               Main.main(new String[0]);
   
               StringWriter sw = new StringWriter();
               PrintWriter pw = new PrintWriter(sw);
               pw.println("Hello, World!");
               pw.close();
   
               assertEquals(sw.toString(), outStreamForTesting.toString());
           } finally {
               System.setOut(savedOut);
           }
       }
   }

samples/templates/java-junit5-integration-test-for-utilities-library/src/integrationTest/java/org/gradle/sample/integtest/utilities/StringUtilsIntegrationTest.java

.. code-block::

   package org.gradle.sample.integtest.utilities;
   
   import org.junit.jupiter.api.Test;
   
   import org.gradle.sample.list.LinkedList;
   import org.gradle.sample.utilities.StringUtils;
   
   import static org.junit.jupiter.api.Assertions.assertEquals;
   
   public class StringUtilsIntegrationTest {
       @Test public void testSplit() {
           LinkedList list = StringUtils.split("The dog is green");
           assertEquals(4, list.size());
           assertEquals("The", list.get(0));
           assertEquals("dog", list.get(1));
           assertEquals("is", list.get(2));
           assertEquals("green", list.get(3));
       }
   }

samples/templates/java-junit5-module-info-for-application/src/integrationTest/java/module-info.java

.. code-block::

   open module org.gradle.sample.integtest.app {
       requires org.gradle.sample.app;
       requires org.junit.jupiter.api;
   }

samples/templates/java-junit5-module-info-for-utilities-library/src/integrationTest/java/module-info.java

.. code-block::

   open module org.gradle.sample.integtest.utilities {
       requires org.gradle.sample.utilities;
       requires org.junit.jupiter.api;
   }

samples/templates/java-junit5-test-for-application/src/test/java/org/gradle/sample/app/MessageUtilsTest.java

.. code-block::

   package org.gradle.sample.app;
   
   import org.junit.jupiter.api.Test;
   
   import static org.junit.jupiter.api.Assertions.assertEquals;
   
   public class MessageUtilsTest {
       @Test public void testGetMessage() {
           assertEquals("Hello,      World!", MessageUtils.getMessage());
       }
   }

samples/templates/java-junit5-test-for-list-library/src/test/java/org/gradle/sample/list/LinkedListTest.java

.. code-block::

   package org.gradle.sample.list;
   
   import org.junit.jupiter.api.Test;
   
   import static org.junit.jupiter.api.Assertions.*;
   
   public class LinkedListTest {
       @Test public void testConstructor() {
           LinkedList list = new LinkedList();
           assertEquals(0, list.size());
       }
   
       @Test public void testAdd() {
           LinkedList list = new LinkedList();
   
           list.add("one");
           assertEquals(1, list.size());
           assertEquals("one", list.get(0));
   
           list.add("two");
           assertEquals(2, list.size());
           assertEquals("two", list.get(1));
       }
   
       @Test public void testRemove() {
           LinkedList list = new LinkedList();
   
           list.add("one");
           list.add("two");
           assertTrue(list.remove("one"));
   
           assertEquals(1, list.size());
           assertEquals("two", list.get(0));
   
           assertTrue(list.remove("two"));
           assertEquals(0, list.size());
       }
   
       @Test public void testRemoveMissing() {
           LinkedList list = new LinkedList();
   
           list.add("one");
           list.add("two");
           assertFalse(list.remove("three"));
           assertEquals(2, list.size());
       }
   }

samples/templates/java-junit5-test-for-utilities-library/src/test/java/org/gradle/sample/utilities/JoinUtilsTest.java

.. code-block::

   package org.gradle.sample.utilities;
   
   import org.junit.jupiter.api.Test;
   
   import org.gradle.sample.list.LinkedList;
   import org.gradle.sample.utilities.JoinUtils;
   
   import static org.junit.jupiter.api.Assertions.assertEquals;
   
   public class JoinUtilsTest {
       @Test public void testJoin() {
           LinkedList list = StringUtils.split("The dog is green");
           assertEquals("The dog is green", JoinUtils.join(list));
       }
   }

samples/templates/java-junit5-test-for-utilities-library/src/test/java/org/gradle/sample/utilities/StringUtilsTest.java

.. code-block::

   package org.gradle.sample.utilities;
   
   import org.junit.jupiter.api.Test;
   
   import org.gradle.sample.list.LinkedList;
   import org.gradle.sample.utilities.StringUtils;
   
   import static org.junit.jupiter.api.Assertions.assertEquals;
   
   public class StringUtilsTest {
       @Test public void testSplit() {
           LinkedList list = StringUtils.split("The dog is green");
           assertEquals(4, list.size());
           assertEquals("The", list.get(0));
           assertEquals("dog", list.get(1));
           assertEquals("is", list.get(2));
           assertEquals("green", list.get(3));
       }
   }

/Sample: 游릭 templates/java-list-library
====================================

samples/templates/java-list-library/src/main/java/org/gradle/sample/list/LinkedList.java

.. code-block::

   package org.gradle.sample.list;
   
   public class LinkedList {
       private Node head;
   
       public void add(String element) {
           Node newNode = new Node(element);
   
           Node it = tail(head);
           if (it == null) {
               head = newNode;
           } else {
               it.next = newNode;
           }
       }
   
       private static Node tail(Node head) {
           Node it;
   
           for (it = head; it != null && it.next != null; it = it.next) {}
   
           return it;
       }
   
       public boolean remove(String element) {
           boolean result = false;
           Node previousIt = null;
           Node it = null;
           for (it = head; !result && it != null; previousIt = it, it = it.next) {
               if (0 == element.compareTo(it.data)) {
                   result = true;
                   unlink(previousIt, it);
                   break;
               }
           }
   
           return result;
       }
   
       private void unlink(Node previousIt, Node currentIt) {
           if (currentIt == head) {
               head = currentIt.next;
           } else {
               previousIt.next = currentIt.next;
           }
       }
   
       public int size() {
           int size = 0;
   
           for (Node it = head; it != null; ++size, it = it.next) {}
   
           return size;
       }
   
       public String get(int index) {
           Node it = head;
           while (index > 0 && it != null) {
               it = it.next;
               index--;
           }
   
           if (it == null) {
               throw new IndexOutOfBoundsException("Index is out of range");
           }
   
           return it.data;
       }
   
       private static class Node {
           final String data;
           Node next;
   
           Node(String data) {
               this.data = data;
           }
       }
   }

/Sample: 游릭 templates/java-module-info-for-application
===================================================

samples/templates/java-module-info-for-application/src/main/java/module-info.java

.. code-block::

   module org.gradle.sample.app {
       exports org.gradle.sample.app;
       requires org.gradle.sample.utilities;
   }

samples/templates/java-module-info-for-list-library/src/main/java/module-info.java

.. code-block::

   module org.gradle.sample.list {
       exports org.gradle.sample.list;
   }

samples/templates/java-module-info-for-utilities-library/src/main/java/module-info.java

.. code-block::

   module org.gradle.sample.utilities {
       requires transitive org.gradle.sample.list;
       exports org.gradle.sample.utilities;
   }

/Sample: 游릭 templates/java-utilities-library
=========================================

samples/templates/java-utilities-library/src/main/java/org/gradle/sample/utilities/JoinUtils.java

.. code-block::

   package org.gradle.sample.utilities;
   
   import org.gradle.sample.list.LinkedList;
   
   class JoinUtils {
       public static String join(LinkedList source) {
           StringBuilder result = new StringBuilder();
           for (int i = 0; i < source.size(); ++i) {
               if (result.length() > 0) {
                   result.append(" ");
               }
               result.append(source.get(i));
           }
   
           return result.toString();
       }
   }

samples/templates/java-utilities-library/src/main/java/org/gradle/sample/utilities/SplitUtils.java

.. code-block::

   package org.gradle.sample.utilities;
   
   import org.gradle.sample.list.LinkedList;
   
   class SplitUtils {
       public static LinkedList split(String source) {
           int lastFind = 0;
           int currentFind = 0;
           LinkedList result = new LinkedList();
   
           while ((currentFind = source.indexOf(" ", lastFind)) != -1) {
               String token = source.substring(lastFind);
               if (currentFind != -1) {
                   token = token.substring(0, currentFind - lastFind);
               }
   
               addIfValid(token, result);
               lastFind = currentFind + 1;
           }
   
           String token = source.substring(lastFind);
           addIfValid(token, result);
   
           return result;
       }
   
       private static void addIfValid(String token, LinkedList list) {
           if (isTokenValid(token)) {
               list.add(token);
           }
       }
   
       private static boolean isTokenValid(String token) {
           return !token.isEmpty();
       }
   }

samples/templates/java-utilities-library/src/main/java/org/gradle/sample/utilities/StringUtils.java

.. code-block::

   package org.gradle.sample.utilities;
   
   import org.gradle.sample.list.LinkedList;
   
   public class StringUtils {
       public static String join(LinkedList source) {
           return JoinUtils.join(source);
       }
   
       public static LinkedList split(String source) {
           return SplitUtils.split(source);
       }
   }

/Sample: 游릭 templates/precompiled-script-plugin-utils
==================================================

samples/templates/precompiled-script-plugin-utils/src/main/java/com/example/CheckstyleUtil.java

.. code-block::

   package com.example;
   
   import java.io.BufferedReader;
   import java.io.IOException;
   import java.io.InputStream;
   import java.io.InputStreamReader;
   import java.io.Reader;
   import java.nio.charset.StandardCharsets;
   
   /**
    * Utility class for extracting the checkstyle.xml used by other plugins
    */
   public abstract class CheckstyleUtil {
       public static String getCheckstyleConfig(String resourcePath) throws IOException {
           InputStream in = CheckstyleUtil.class.getResourceAsStream(resourcePath);
   
           StringBuilder sb = new StringBuilder();
           try (Reader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8))) {
               int c;
               while ((c = reader.read()) != -1) {
                   sb.append((char) c);
               }
           }
           return sb.toString();
       }
   }

samples/templates/precompiled-script-plugin-utils/src/main/java/com/example/ReadmeVerificationTask.java

.. code-block::

   package com.example;
   
   import org.gradle.api.DefaultTask;
   import org.gradle.api.file.RegularFileProperty;
   import org.gradle.api.provider.ListProperty;
   import org.gradle.api.tasks.InputFile;
   import org.gradle.api.tasks.Internal;
   import org.gradle.api.tasks.PathSensitive;
   import org.gradle.api.tasks.PathSensitivity;
   import org.gradle.api.tasks.TaskAction;
   
   import java.io.IOException;
   import java.nio.file.Files;
   import java.util.regex.Pattern;
   
   /**
    * Verifies that the given readme file contains the desired patterns.
    */
   public abstract class ReadmeVerificationTask extends DefaultTask {
   
       @PathSensitive(PathSensitivity.RELATIVE)
       @InputFile
       public abstract RegularFileProperty getReadme();
   
       @Internal
       public abstract ListProperty<String> getReadmePatterns();
   
       @TaskAction
       void verifyServiceReadme() throws IOException {
           String readmeContents = new String (Files.readAllBytes(getReadme().getAsFile().get().toPath()));
           for (String requiredSection : getReadmePatterns().get()) {
               Pattern pattern = Pattern.compile(requiredSection, Pattern.MULTILINE);
               if (!pattern.matcher(readmeContents).find()) {
                   throw new RuntimeException("README should contain section: " + pattern.pattern());
               }
           }
       }
   }

samples/templates/precompiled-script-plugin-utils/src/main/resources/checkstyle.xml

.. code-block::

   <?xml version="1.0" encoding="UTF-8"?>
   <!DOCTYPE module PUBLIC "-//Checkstyle//DTD Checkstyle Configuration 1.3//EN" "https://checkstyle.org/dtds/configuration_1_3.dtd">
   <module name="Checker">
       <module name="TreeWalker">
           <module name="UnusedImports" />
           <module name="AvoidStarImport" />
           <module name="ConstantName" />
           <module name="NeedBraces" />
           <module name="RightCurly" />
           <module name="ModifierOrder">
               <property name="severity" value="warning"/>
           </module>
       </module>
   </module>
   /Sample: templates/problems-api-usage
=====================================

samples/templates/problems-api-usage/reporters/model-builder-plugin/src/main/java/reporters/DefaultDemoModel.java

.. code-block::

   package reporters;
   
   public class DefaultDemoModel implements DemoModel {
   }

samples/templates/problems-api-usage/reporters/model-builder-plugin/src/main/java/reporters/DemoModel.java

.. code-block::

   package reporters;
   
   import java.io.Serializable;
   
   public interface DemoModel extends Serializable {
   }

samples/templates/problems-api-usage/reporters/model-builder-plugin/src/main/java/reporters/ModelBuilder.java

.. code-block::

   package reporters;
   
   import org.gradle.api.Project;
   import org.gradle.api.problems.Problems;
   import org.gradle.api.problems.Severity;
   import org.gradle.tooling.provider.model.ToolingModelBuilder;
   
   import javax.inject.Inject;
   
   public class ModelBuilder implements ToolingModelBuilder {
   
       private final Problems problems;
   
       @Inject
       public ModelBuilder(Problems problems) {
           this.problems = problems;
       }
   
       @Override
       public boolean canBuild(String modelName) {
           return DemoModel.class.getName().equals(modelName);
       }
   
       @Override
       public Object buildAll(String modelName, Project project) {
           problems.forNamespace("reporters.model.builder").reporting(problem -> problem
               .label("Demo model")
               .category("unused")
               .severity(Severity.WARNING)
               .details("This is a demo model and doesn't do anything useful")
           );
           return new DefaultDemoModel();
       }
   }

samples/templates/problems-api-usage/reporters/model-builder-plugin/src/main/java/reporters/ModelBuilderPlugin.java

.. code-block::

   package reporters;
   
   import org.gradle.api.Plugin;
   import org.gradle.api.Project;
   import org.gradle.api.model.ObjectFactory;
   import org.gradle.tooling.provider.model.ToolingModelBuilderRegistry;
   
   import javax.inject.Inject;
   
   public class ModelBuilderPlugin implements Plugin<Project> {
   
       private final ToolingModelBuilderRegistry registry;
   
       @Inject
       public ModelBuilderPlugin(ObjectFactory factory, ToolingModelBuilderRegistry registry) {
           this.registry = registry;
       }
   
       @Override
       public void apply(Project target) {
           ModelBuilder modelBuilder = target.getObjects().newInstance(ModelBuilder.class);
           registry.register(modelBuilder);
       }
   }

samples/templates/problems-api-usage/reporters/standard-plugin/src/main/java/reporters/StandardPlugin.java

.. code-block::

   package reporters;
   
   import org.gradle.api.Plugin;
   import org.gradle.api.Project;
   import org.gradle.api.problems.Problems;
   import org.gradle.api.problems.Severity;
   
   import javax.inject.Inject;
   
   /**
    * This is a simple, standard Gradle plugin that is applied to a project.
    */
   public class StandardPlugin implements Plugin<Project> {
   
       private final Problems problems;
   
       @Inject
       public StandardPlugin(Problems problems) {
           this.problems = problems;
       }
   
       @Override
       public void apply(Project target) {
           // tag::problems-api-report[]
           problems.forNamespace("reporters.standard.plugin").reporting(problem -> problem
                   .label("The 'standard-plugin' is deprecated")
                   .documentedAt("https://github.com/gradle/gradle/README.md")
                   .category("deprecation", "plugin")
                   .severity(Severity.WARNING)
                   .solution("Please use a more recent plugin version")
           );
           // end::problems-api-report[]
       }
   }

samples/templates/problems-api-usage/sample-ide/src/main/java/org/gradle/sample/SampleIde.java

.. code-block::

   package org.gradle.sample;
   
   import org.gradle.api.logging.Logging;
   import org.gradle.tooling.*;
   import org.gradle.tooling.ModelBuilder;
   import org.gradle.tooling.events.OperationType;
   import org.gradle.tooling.events.ProgressEvent;
   import org.gradle.tooling.events.ProgressListener;
   import org.gradle.tooling.events.problems.*;
   import org.slf4j.Logger;
   import reporters.DemoModel;
   
   import java.io.File;
   import java.nio.file.Path;
   import java.util.List;
   
   public class SampleIde {
   
       private static final Logger LOGGER = Logging.getLogger(SampleIde.class);
       private final String workingDir;
       private final String taskPath;
   
       public SampleIde(String workingDir, String taskPath) {
           this.workingDir = workingDir;
           this.taskPath = taskPath;
       }
   
       private ProjectConnection createGradleConnection() {
           // Get current working directory
           Path projectPath = Path.of(workingDir);
           File projectDir = projectPath.toFile();
   
           // Initialize the Tooling API
           return GradleConnector.newConnector().forProjectDirectory(projectDir).connect();
       }
   
       public void buildModel() {
           try (ProjectConnection connection = createGradleConnection()) {
               ModelBuilder<DemoModel> modelBuilder = connection.model(DemoModel.class).addArguments("--quiet");
               ProblemListener.createAndRegister(modelBuilder);
               modelBuilder.get();
           }
       }
   
       public void runBuild() {
           try (ProjectConnection connection = createGradleConnection()) {
               // Load the project
               BuildLauncher buildLauncher = connection.newBuild();
               buildLauncher.addArguments("--quiet");
               buildLauncher.setStandardOutput(System.err);
               buildLauncher.setStandardError(System.err);
   
               // Add a problem listener
               ProblemListener.createAndRegister(buildLauncher);
               // Configure the task to be executed
               BuildLauncher launcher = buildLauncher.forTasks(taskPath);
               // Execute the task
               launcher.run();
           } catch (GradleConnectionException e) {
               LOGGER.error("Error connecting to Gradle.", e);
           } catch (Exception e) {
               LOGGER.error("Error executing Gradle task.", e);
           }
       }
   
       public static void main(String[] args) {
           String workingDir = args.length > 0 ? args[0] : System.getProperty("user.dir");
           String taskPath = args.length > 1 ? args[1] : ":sample-project:assemble";
   
           System.out.println("=== Importing project from " + workingDir + " ===");
           SampleIde main = new SampleIde(workingDir, taskPath);
   
           System.out.println("=== Running task " + taskPath + " on imported project ===");
           main.runBuild();
   
           System.out.println("=== Retrieving Gradle configuration with logic implemented in the 'reporters.model.builder' plugin ===");
           main.buildModel();
       }
   
       private static class ProblemListener implements ProgressListener {
   
           static void createAndRegister(LongRunningOperation operation) {
               operation.addProgressListener(new ProblemListener(), OperationType.PROBLEMS);
           }
   
           // tag::problems-tapi-event[]
           @Override
           public void statusChanged(ProgressEvent progressEvent) {
               prettyPrint(((ProblemDescriptor) progressEvent.getDescriptor()));
           }
           // end::problems-tapi-event[]
   
           static void prettyPrint(ProblemDescriptor problem) {
               System.out.println("Problem:");
               System.out.println(" - category: " + toString(problem.getCategory()));
               System.out.println(" - label: " + problem.getLabel().getLabel());
               System.out.println(" - details: " + problem.getDetails().getDetails());
               System.out.println(" - severity: " + toString(problem.getSeverity()));
               for (Location location : problem.getLocations()) {
                   if (location instanceof PluginIdLocation) {
                       System.out.println(" - plugin ID: " + ((PluginIdLocation) location).getPluginId());
                   } else {
                       System.out.println(" - location: " + location);
                   }
               }
               RuntimeException exception = problem.getException().getException();
               if (exception != null) {
                   System.out.println(" - exception: " + exception.getMessage());
               }
               String url = problem.getDocumentationLink().getUrl();
               if (url != null) {
                   System.out.println(" - documentation: " + url);
               }
   
               List<Solution> solutions = problem.getSolutions();
               if (!solutions.isEmpty()) {
                   System.out.println(" - solutions: ");
                   for (Solution solution : solutions) {
                       System.out.println("   - " + solution.getSolution());
                   }
               }
           }
   
           static String toString(ProblemCategory category) {
               StringBuilder sb = new StringBuilder();
               sb.append(category.getNamespace());
               sb.append(":");
               sb.append(category.getCategory());
               for (String sc : category.getSubcategories()) {
                   sb.append(":");
                   sb.append(sc);
               }
               return sb.toString();
           }
   
           static String toString(Severity severity) {
               int code = severity.getSeverity();
               switch (code) {
                   case 0: return "ADVICE";
                   case 1: return "WARNING";
                   case 2: return "ERROR";
                   default: return "UNKNOWN";
               }
           }
       }
   }

/Sample: 游릭 templates/spring-boot-web-application
==============================================

samples/templates/spring-boot-web-application/HELP.md

    Getting Started
    ===============

    Reference Documentation
    ~~~~~~~~~~~~~~~~~~~~~~~

    For further reference, please consider the following sections:

    -  `Official Gradle documentation <https://docs.gradle.org>`__
    -  `Spring Boot Gradle Plugin Reference Guide <https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/gradle-plugin/reference/html/>`__

    Additional Links
    ~~~~~~~~~~~~~~~~

    These additional references should also help you:

    -  `Gradle Build Scans  insights for your project뗩 build <https://scans.gradle.com#gradle>`__

samples/templates/spring-boot-web-application/src/main/java/org/gradle/samples/SpringBootDemoApplication.java

.. code-block::

   package org.gradle.samples;
   
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   
   @SpringBootApplication
   public class SpringBootDemoApplication {
   
   	public static void main(String[] args) {
   		SpringApplication.run(SpringBootDemoApplication.class, args);
   	}
   
   }

samples/templates/spring-boot-web-application/src/main/resources/application.properties

.. code-block::

   
samples/templates/spring-boot-web-application/src/test/java/org/gradle/samples/SpringBootDemoApplicationTests.java

.. code-block::

   package org.gradle.samples;
   
   import org.junit.jupiter.api.Test;
   import org.springframework.boot.test.context.SpringBootTest;
   
   @SpringBootTest
   class SpringBootDemoApplicationTests {
   
   	@Test
   	void contextLoads() {
   	}
   
   }

/Sample: 游릭 templates/structuring-software-projects
================================================

samples/templates/structuring-software-projects/admin-feature/config/src/main/kotlin/com/example/myproduct/admin/config/AdminController.kt

.. code-block::

   package com.example.myproduct.admin.config
   
   import com.example.myproduct.admin.state.ConfigurationState
   
   object AdminController {
   
       fun update(versionRange: VersionRange) {
           ConfigurationState.rangeSetting.minVersion = versionRange.fromVersion
           ConfigurationState.rangeSetting.maxVersion = versionRange.toVersion
       }
   }

samples/templates/structuring-software-projects/admin-feature/config/src/main/kotlin/com/example/myproduct/admin/config/VersionRange.kt

.. code-block::

   package com.example.myproduct.admin.config
   
   data class VersionRange(
           var fromVersion: String = "",
           var toVersion: String = ""
   )

samples/templates/structuring-software-projects/admin-feature/config/src/test/kotlin/com/example/myproduct/admin/config/AdminControllerTest.kt

.. code-block::

   package com.example.myproduct.admin.config
   
   import com.example.myproduct.admin.state.ConfigurationState
   import com.example.myproduct.admin.state.VersionRangeSetting
   import org.junit.jupiter.api.Assertions.assertEquals
   import org.junit.jupiter.api.Test
   
   class AdminControllerTest {
       @Test fun updatesState() {
           AdminController.update(VersionRange("1", "2"))
           assertEquals(VersionRangeSetting("1", "2"), ConfigurationState.rangeSetting)
       }
   }samples/templates/structuring-software-projects/android-app/app/src/main/AndroidManifest.xml

.. code-block::

   <?xml version="1.0" encoding="utf-8"?>
   <manifest xmlns:android="http://schemas.android.com/apk/res/android"
             package="com.example.myproduct.app">
   
       <uses-permission android:name="android.permission.INTERNET" />
   
       <application>
           <activity android:name=".MyProductAppActivity" android:label="My Product">
               <intent-filter>
                   <action android:name="android.intent.action.MAIN" />
                   <category android:name="android.intent.category.LAUNCHER" />
               </intent-filter>
           </activity>
       </application>
   
   </manifest>

samples/templates/structuring-software-projects/android-app/app/src/main/java/com/example/myproduct/app/MyProductAppActivity.kt

.. code-block::

   package com.example.myproduct.app
   
   import android.app.Activity
   import android.os.AsyncTask
   import android.os.Bundle
   import android.text.Html
   import android.text.method.LinkMovementMethod
   import android.widget.ScrollView
   import android.widget.TableLayout
   import android.widget.TableRow
   import android.widget.TextView
   import com.example.myproduct.user.table.TableBuilder
   
   
   class MyProductAppActivity : Activity() {
   
       class DownloadTask: AsyncTask<Void, Void, List<MutableList<String>>>() {
           override fun doInBackground(vararg params: Void): List<MutableList<String>> {
               return TableBuilder.build()
           }
   
           override fun onPostExecute(result: List<MutableList<String>>) { }
       }
   
       override fun onCreate(savedInstanceState: Bundle?) {
           super.onCreate(savedInstanceState)
   
           val data = DownloadTask().execute().get()
   
           val scrollView = ScrollView(this)
           val table = TableLayout(this)
           scrollView.addView(table);
   
           data.forEach { rowData ->
               val row = TableRow(this@MyProductAppActivity)
               rowData.forEach { cellData ->
                   row.addView(TextView(this@MyProductAppActivity).apply {
                       setPadding(6, 6, 6, 6)
                       if (cellData.contains("https://")) {
                           movementMethod = LinkMovementMethod.getInstance()
                           text = Html.fromHtml("<a href='$cellData'>$cellData</a>", Html.FROM_HTML_MODE_LEGACY)
                       } else {
                           text = cellData
                       }
                   })
               }
               table.addView(row)
           }
   
           setContentView(scrollView)
       }
   }

samples/templates/structuring-software-projects/domain-model/release/src/main/kotlin/com/example/myproduct/model/MyProductRelease.kt

.. code-block::

   package com.example.myproduct.model
   
   data class MyProductRelease(
           val version: String,
           val releaseNotes: String
   )

samples/templates/structuring-software-projects/domain-model/release/src/main/kotlin/com/example/myproduct/model/MyProductReleaseList.kt

.. code-block::

   package com.example.myproduct.model
   
   data class MyProductReleaseList(val releases: List<MyProductRelease>)

samples/templates/structuring-software-projects/server-application/app/src/main/java/com/example/myproduct/server/MyProductAdminController.java

.. code-block::

   package com.example.myproduct.server;
   
   import com.example.myproduct.admin.config.AdminController;
   import com.example.myproduct.admin.config.VersionRange;
   
   import org.springframework.stereotype.Controller;
   import org.springframework.ui.Model;
   import org.springframework.web.bind.annotation.GetMapping;
   import org.springframework.web.bind.annotation.ModelAttribute;
   import org.springframework.web.bind.annotation.PostMapping;
   
   @Controller
   public class MyProductAdminController {
   
       @GetMapping("/admin")
       public String adminForm(Model model) {
           model.addAttribute("versionRange", new VersionRange());
           return "admin";
       }
   
       @PostMapping("/admin")
       public String adminSubmit(@ModelAttribute VersionRange versionRange, Model model) {
           AdminController.INSTANCE.update(versionRange);
           model.addAttribute("versionRange", versionRange);
           return "admin";
       }
   
   }

samples/templates/structuring-software-projects/server-application/app/src/main/java/com/example/myproduct/server/MyProductApplication.java

.. code-block::

   package com.example.myproduct.server;
   
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   
   @SpringBootApplication
   public class MyProductApplication {
       public static void main(String[] args) {
           SpringApplication.run(MyProductApplication.class, args);
       }
   }

samples/templates/structuring-software-projects/server-application/app/src/main/java/com/example/myproduct/server/MyProductController.java

.. code-block::

   package com.example.myproduct.server;
   
   import com.example.myproduct.user.table.TableBuilder;
   import org.apache.juneau.html.HtmlSerializer;
   import org.apache.juneau.serializer.SerializeException;
   import org.springframework.web.bind.annotation.RequestMapping;
   import org.springframework.web.bind.annotation.RestController;
   
   @RestController
   public class MyProductController {
   
       @RequestMapping("/")
       public String index() throws SerializeException {
           return HtmlSerializer.DEFAULT.serialize(TableBuilder.build());
       }
   
   }

samples/templates/structuring-software-projects/server-application/app/src/main/java/com/example/myproduct/server/MyProductJsonController.java

.. code-block::

   package com.example.myproduct.server;
   
   import com.example.myproduct.user.table.TableBuilder;
   
   import org.springframework.http.MediaType;
   import org.springframework.web.bind.annotation.RequestMapping;
   import org.springframework.web.bind.annotation.RestController;
   
   import java.util.List;
   
   @RestController
   public class MyProductJsonController {
   
       @RequestMapping(value = "/json", produces = MediaType.APPLICATION_JSON_VALUE)
       public List<List<String>> json() {
           return TableBuilder.build();
       }
   
   }

samples/templates/structuring-software-projects/server-application/app/src/main/resources/templates/admin.html

.. code-block::

   <!DOCTYPE HTML>
   <html xmlns:th='https://www.thymeleaf.org'>
   <head>
     <title>My Product Configurator</title>
     <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
   </head>
   <body>
     <form action='#' th:action='@{/admin}' th:object='${versionRange}' method='post'>
       <p>From Version: <input type='text' th:field='*{fromVersion}'/></p>
       <p>To Version:   <input type='text' th:field='*{toVersion}'/></p>
       <p><input type='submit' value='Submit'/></p>
     </form>
   </body>
   </html>samples/templates/structuring-software-projects/state/application-state/src/main/kotlin/com/example/myproduct/admin/state/ConfigurationState.kt

.. code-block::

   package com.example.myproduct.admin.state
   
   object ConfigurationState {
       val rangeSetting = VersionRangeSetting()
   }

samples/templates/structuring-software-projects/state/application-state/src/main/kotlin/com/example/myproduct/admin/state/VersionRangeSetting.kt

.. code-block::

   package com.example.myproduct.admin.state
   
   data class VersionRangeSetting(
           var minVersion: String = "",
           var maxVersion: String = ""
   )

samples/templates/structuring-software-projects/user-feature/data/src/main/java/com/example/myproduct/user/data/DataRetriever.java

.. code-block::

   package com.example.myproduct.user.data;
   
   import com.fasterxml.jackson.databind.ObjectMapper;
   import com.example.myproduct.model.MyProductRelease;
   import com.example.myproduct.model.MyProductReleaseList;
   
   import java.net.URL;
   import java.util.Arrays;
   import java.util.stream.Collectors;
   
   public class DataRetriever {
   
       static public class Version {
           public String version;
           public String buildTime;
           public boolean current;
           public boolean snapshot;
           public boolean nightly;
           public boolean releaseNightly;
           public boolean activeRc;
           public String rcFor;
           public String milestoneFor;
           public boolean broken;
           public String downloadUrl;
           public String checksumUrl;
           public String wrapperChecksumUrl;
       }
   
       public static MyProductReleaseList retrieve() {
           ObjectMapper objectMapper = new ObjectMapper();
           try {
               URL url = new URL("https://services.gradle.org/versions/all");
               Version[] versions = objectMapper.readValue(url, Version[].class);
               return new MyProductReleaseList(Arrays.stream(versions).map(r -> new MyProductRelease(
                   r.version, releaseNotesURL(r.version))).collect(Collectors.toList()));
           } catch (Exception e) {
               throw new RuntimeException(e);
           }
       }
   
       private static String releaseNotesURL(String version) {
           if (version.contains("+")) {
               version = "nightly";
           }
           return "https://docs.gradle.org/" + version + "/release-notes.html";
       }
   }

samples/templates/structuring-software-projects/user-feature/table/src/main/java/com/example/myproduct/user/table/TableBuilder.java

.. code-block::

   package com.example.myproduct.user.table;
   
   import com.example.myproduct.admin.state.ConfigurationState;
   import com.example.myproduct.model.MyProductRelease;
   import com.example.myproduct.user.data.DataRetriever;
   
   import java.util.Arrays;
   import java.util.List;
   import java.util.stream.Collectors;
   
   public class TableBuilder {
   
       public static List<List<String>> build() {
           List<MyProductRelease> releases = DataRetriever.retrieve().getReleases();
           return build(releases);
       }
   
       protected static List<List<String>> build(List<MyProductRelease> releases) {
           return releases.stream().filter(TableBuilder::isInRange).map(r ->
                   Arrays.asList(r.getVersion(), r.getReleaseNotes())).collect(Collectors.toList());
       }
   
       protected static boolean isInRange(MyProductRelease release) {
           String current = release.getVersion();
           String min = ConfigurationState.INSTANCE.getRangeSetting().getMinVersion();
           String max = ConfigurationState.INSTANCE.getRangeSetting().getMaxVersion();
           return (min.compareTo(current) <= 0 || min.isEmpty()) && (max.compareTo(current) >= 0 || max.isEmpty());
       }
   
   }

samples/templates/structuring-software-projects/user-feature/table/src/test/java/com/example/myproduct/user/table/TableBuilderTest.java

.. code-block::

   package com.example.myproduct.user.table;
   
   import com.example.myproduct.model.MyProductRelease;
   import org.junit.jupiter.api.Test;
   
   import java.util.Arrays;
   import java.util.List;
   
   import static org.junit.jupiter.api.Assertions.assertEquals;
   
   public class TableBuilderTest {
       @Test
       public void testTableBuilding() {
           List<MyProductRelease> testData = Arrays.asList(
                   new MyProductRelease("1.0", "https://example.com/release1"),
                   new MyProductRelease("2.0", "https://example.com/release2"));
   
           assertEquals(Arrays.asList(
                   Arrays.asList("1.0", "https://example.com/release1"),
                   Arrays.asList("2.0", "https://example.com/release2")),
                   TableBuilder.build(testData));
       }
   }

/Sample: 游릭 writing-tasks/task-with-arguments
==========================================

samples/writing-tasks/task-with-arguments/README.adoc

.. code-block::

   NOTE: You can open the samples inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how to create a plugin with a task that accepts arguments.
   The plugin is packaged via an included build.
   
   ====
   include::sample[dir="kotlin",files="build.gradle.kts[];settings.gradle.kts[]"]
   include::sample[dir="groovy",files="build.gradle[];settings.gradle[]"]
   ====
   
   To execute the sample task:
   
   ====
   [.testable-sample,dir="groovy"]
   =====
   [.sample-command]
   ----
   $ ./gradlew projectInfo --format json
   {
       "projectName": "task-with-arguments"
       "version": "1.0.2"
   }
   
   BUILD SUCCESSFUL in 1s
   1 actionable task: 1 executed
   ----
   =====
   ====
   
   For more information, see link:{userManualPath}#custom_plugins[Gradle Plugins reference chapter].
   You can also get started quickly using the link:{userManualPath}#build_init_plugin-sec:java_library[Build Init Plugin].

samples/writing-tasks/task-with-arguments/groovy/build.gradle

.. code-block::

   plugins {
       id 'com.example.project-info'
   }
   
   version = '1.0.2'

samples/writing-tasks/task-with-arguments/groovy/settings.gradle

.. code-block::

   rootProject.name = 'task-with-arguments'
   includeBuild('project-info')

samples/writing-tasks/task-with-arguments/groovy/project-info/build.gradle

.. code-block::

   plugins {
       id 'java-gradle-plugin'
   }
   
   gradlePlugin {
       plugins {
           projectInfo {
               id = 'com.example.project-info'
               implementationClass = 'com.example.ProjectInfoPlugin'
           }
       }
   }

samples/writing-tasks/task-with-arguments/groovy/project-info/settings.gradle

.. code-block::

   rootProject.name = 'project-info'

samples/writing-tasks/task-with-arguments/common/project-info/src/main/java/com/example/ProjectInfoPlugin.java

.. code-block::

   package com.example;
   
   import org.gradle.api.Plugin;
   import org.gradle.api.Project;
   
   class ProjectInfoPlugin implements Plugin<Project> {
       public void apply(Project project) {
           project.getTasks().register("projectInfo", ProjectInfoTask.class, task -> {
               task.setGroup("help");
               task.setDescription("Displays current project info");
           });
       }
   }

samples/writing-tasks/task-with-arguments/common/project-info/src/main/java/com/example/ProjectInfoTask.java

.. code-block::

   package com.example;
   
   import org.gradle.api.DefaultTask;
   import org.gradle.api.tasks.TaskAction;
   import org.gradle.api.tasks.options.Option;
   import org.gradle.api.tasks.options.OptionValues;
   import java.util.EnumSet;
   import java.util.Collection;
   
   class ProjectInfoTask extends DefaultTask {
   
       enum Format {
           PLAIN, JSON
       }
   
       private Format format = Format.PLAIN;
   
       private final String projectName = getProject().getName();
       private final String projectVersion = getProject().getVersion().toString();
   
       public ProjectInfoTask() {
       }
   
       @Option(option = "format", description = "Output format of the project information.")
       void setFormat(Format format) {
           this.format = format;
       }
   
       @OptionValues("format")
       Collection<Format> getSupportedFormats() {
           return EnumSet.allOf(Format.class);
       }
   
       @TaskAction
       void projectInfo() {
           switch (format) {
               case PLAIN:
                   System.out.println(projectName + ":" + projectVersion);
                   break;
               case JSON:
                   System.out.println("{\n" +
                       "    \"projectName\": \"" + projectName + "\"\n" +
                       "    \"version\": \"" + projectVersion + "\"\n}");
                   break;
               default:
                   throw new IllegalArgumentException("Unsupported format: " + format);
           }
       }
   
   }

samples/writing-tasks/task-with-arguments/kotlin/build.gradle.kts

.. code-block::

   plugins {
       id("com.example.project-info")
   }
   
   version = "1.0.2"

samples/writing-tasks/task-with-arguments/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "task-with-arguments"
   includeBuild("project-info")

samples/writing-tasks/task-with-arguments/kotlin/project-info/build.gradle.kts

.. code-block::

   plugins {
       `java-gradle-plugin`
   }
   
   gradlePlugin {
       plugins {
           create("projectInfo") {
               id = "com.example.project-info"
               implementationClass = "com.example.ProjectInfoPlugin"
           }
       }
   }

samples/writing-tasks/task-with-arguments/kotlin/project-info/settings.gradle.kts

.. code-block::

   rootProject.name = "project-info"

samples/writing-tasks/task-with-arguments/tests/help.out

.. code-block::

   Detailed task information for projectInfo
   
   Path
        :projectInfo
   
   Type
        ProjectInfoTask (com.example.ProjectInfoTask)
   
   Options
        --format     Output format of the project information.
                     Available values are:
                          JSON
                          PLAIN
   
        --rerun     Causes the task to be re-run even if up-to-date.
   
   Description
        Displays current project info
   
   Group
        help

samples/writing-tasks/task-with-arguments/tests/json.out

.. code-block::

   {
       "projectName": "task-with-arguments"
       "version": "1.0.2"
   }

samples/writing-tasks/task-with-arguments/tests/plain.out

.. code-block::

   task-with-arguments:1.0.2

samples/writing-tasks/task-with-arguments/tests/projectInfoTask.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: -q projectInfo --format plain
       expected-output-file: plain.out
   },
   {
       executable: gradle
       args: -q projectInfo --format json
       expected-output-file: json.out
   },
   {
       executable: gradle
       args: -q help --task projectInfo
       expected-output-file: help.out
   }]

/Sample: 游릭 writing-tasks/tasks-with-dependency-resolution-result-inputs
=====================================================================

samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/README.adoc

.. code-block::

   NOTE: You can open the samples inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].
   
   This sample shows how to create a plugin with tasks that have dependency resolution results as inputs.
   The plugin is packaged via an included build and is demonstrated on a multi-project build for a Java application.
   
   ====
   include::sample[dir="kotlin",files="settings.gradle.kts[tag=includes];list/build.gradle.kts[];utilities/build.gradle.kts[];build.gradle.kts[]"]
   include::sample[dir="groovy",files="settings.gradle[tag=includes];list/build.gradle[];utilities/build.gradle[];build.gradle[]"]
   ====
   
   To execute the sample tasks:
   
   ====
   [.testable-sample,dir="groovy"]
   =====
   [.sample-command]
   ----
   > ./gradlew -q listResolvedArtifacts
   include::{samplesPath}/writing-tasks/tasks-with-dependency-resolution-result-inputs/tests/listResolvedArtifacts.out[]
   
   BUILD SUCCESSFUL in 1s
   1 actionable task: 1 executed
   ----
   =====
   =====
   [.sample-command]
   ----
   > ./gradlew -q graphResolvedComponents
   include::{samplesPath}/writing-tasks/tasks-with-dependency-resolution-result-inputs/tests/graphResolvedComponents.out[]
   
   BUILD SUCCESSFUL in 1s
   1 actionable task: 1 executed
   ----
   =====
   =====
   [.sample-command]
   ----
   > ./gradlew -q graphResolvedComponentsAndFiles
   include::{samplesPath}/writing-tasks/tasks-with-dependency-resolution-result-inputs/tests/graphResolvedComponentsAndFiles.out[]
   
   BUILD SUCCESSFUL in 1s
   1 actionable task: 1 executed
   ----
   =====
   ====
   
   For more information, see link:{userManualPath}#more_about_tasks[Authoring Tasks reference chapter].
   Additionally, see the link:{userManualPath}#incremental_build[Incremental Build] chapter and its link:{userManualPath}#incremental_build-sec:task_input_using_classpath_annotations[Using dependency resolution results] section.

samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/common/dependency-reports/src/main/java/com/example/DependencyReportsPlugin.java

.. code-block::

   package com.example;
   
   import org.gradle.api.Plugin;
   import org.gradle.api.Project;
   import org.gradle.api.Transformer;
   import org.gradle.api.artifacts.Configuration;
   import org.gradle.api.artifacts.ConfigurationContainer;
   import org.gradle.api.artifacts.ResolvableDependencies;
   import org.gradle.api.artifacts.component.ComponentArtifactIdentifier;
   import org.gradle.api.artifacts.result.ResolvedArtifactResult;
   import org.gradle.api.artifacts.result.ResolvedVariantResult;
   import org.gradle.api.file.Directory;
   import org.gradle.api.file.ProjectLayout;
   import org.gradle.api.file.RegularFile;
   import org.gradle.api.provider.Provider;
   import org.gradle.api.tasks.TaskContainer;
   
   import java.util.Collection;
   import java.util.List;
   import java.util.Set;
   import java.util.stream.Collectors;
   
   import static java.util.stream.Collectors.toList;
   
   public abstract class DependencyReportsPlugin implements Plugin<Project> {
   
       @Override
       public void apply(Project project) {
   
           project.getPluginManager().withPlugin("java-base", plugin -> {
   
               ProjectLayout layout = project.getLayout();
               ConfigurationContainer configurations = project.getConfigurations();
               TaskContainer tasks = project.getTasks();
   
               tasks.register("listResolvedArtifacts", ListResolvedArtifacts.class, task -> {
   
   // tag::listResolvedArtifacts[]
   Configuration runtimeClasspath = configurations.getByName("runtimeClasspath");
   Provider<Set<ResolvedArtifactResult>> artifacts = runtimeClasspath.getIncoming().getArtifacts().getResolvedArtifacts();
   
   task.getArtifactIds().set(artifacts.map(new IdExtractor()));
   
   // end::listResolvedArtifacts[]
   
                   task.getArtifactVariants().set(artifacts.map(new VariantExtractor()));
                   task.getArtifactFiles().set(artifacts.map(new FileExtractor(layout)));
   
                   task.getOutputFile().set(layout.getBuildDirectory().file(task.getName() + "/report.txt"));
               });
   
               tasks.register("graphResolvedComponents", GraphResolvedComponents.class, task -> {
   
   // tag::graphResolvedComponents[]
   Configuration runtimeClasspath = configurations.getByName("runtimeClasspath");
   
   task.getRootComponent().set(
       runtimeClasspath.getIncoming().getResolutionResult().getRootComponent()
   );
   // end::graphResolvedComponents[]
   
                   task.getOutputFile().set(layout.getBuildDirectory().file(task.getName() + "/report.txt"));
               });
   
               tasks.register("graphResolvedComponentsAndFiles", GraphResolvedComponentsAndFiles.class, task -> {
   
                   ResolvableDependencies resolvableDependencies = configurations.getByName("runtimeClasspath").getIncoming();
                   Provider<Set<ResolvedArtifactResult>> resolvedArtifacts = resolvableDependencies.getArtifacts().getResolvedArtifacts();
   
                   task.getArtifactFiles().from(resolvableDependencies.getArtifacts().getArtifactFiles());
                   task.getArtifactIdentifiers().set(resolvedArtifacts.map(result -> result.stream().map(ResolvedArtifactResult::getId).collect(toList())));
                   task.getRootComponent().set(resolvableDependencies.getResolutionResult().getRootComponent());
   
                   task.getOutputFile().set(layout.getBuildDirectory().file(task.getName() + "/report.txt"));
               });
           });
       }
   
   // tag::listResolvedArtifacts[]
   static class IdExtractor
       implements Transformer<List<ComponentArtifactIdentifier>, Collection<ResolvedArtifactResult>> {
       @Override
       public List<ComponentArtifactIdentifier> transform(Collection<ResolvedArtifactResult> artifacts) {
           return artifacts.stream().map(ResolvedArtifactResult::getId).collect(Collectors.toList());
       }
   }
   // end::listResolvedArtifacts[]
   
       static class VariantExtractor implements Transformer<List<ResolvedVariantResult>, Collection<ResolvedArtifactResult>> {
           @Override
           public List<ResolvedVariantResult> transform(Collection<ResolvedArtifactResult> artifacts) {
               return artifacts.stream().map(ResolvedArtifactResult::getVariant).collect(Collectors.toList());
           }
       }
   
       static class FileExtractor implements Transformer<List<RegularFile>, Collection<ResolvedArtifactResult>> {
           private final ProjectLayout projectLayout;
   
           public FileExtractor(ProjectLayout projectLayout) {
               this.projectLayout = projectLayout;
           }
   
           @Override
           public List<RegularFile> transform(Collection<ResolvedArtifactResult> artifacts) {
               Directory projectDirectory = projectLayout.getProjectDirectory();
               return artifacts.stream().map(a -> projectDirectory.file(a.getFile().getAbsolutePath())).collect(Collectors.toList());
           }
       }
   }

samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/common/dependency-reports/src/main/java/com/example/GraphResolvedComponents.java

.. code-block::

   package com.example;
   
   import org.gradle.api.DefaultTask;
   import org.gradle.api.artifacts.result.DependencyResult;
   import org.gradle.api.artifacts.result.ResolvedComponentResult;
   import org.gradle.api.artifacts.result.ResolvedDependencyResult;
   import org.gradle.api.file.RegularFileProperty;
   import org.gradle.api.provider.Property;
   import org.gradle.api.tasks.Input;
   import org.gradle.api.tasks.OutputFile;
   import org.gradle.api.tasks.TaskAction;
   
   import java.io.File;
   import java.io.IOException;
   import java.io.PrintWriter;
   import java.nio.file.Files;
   import java.util.HashSet;
   import java.util.Set;
   import java.util.stream.Stream;
   
   public abstract class GraphResolvedComponents extends DefaultTask {
   
   // tag::inputs[]
   @Input
   public abstract Property<ResolvedComponentResult> getRootComponent();
   // end::inputs[]
   
       @OutputFile
       public abstract RegularFileProperty getOutputFile();
   
       @TaskAction
       public void action() throws IOException {
           File outputFile = getOutputFile().get().getAsFile();
           try (PrintWriter writer = new PrintWriter(outputFile)) {
               Set<ResolvedComponentResult> seen = new HashSet<>();
               reportComponent(getRootComponent().get(), writer, seen, "");
           }
           try (Stream<String> stream = Files.lines(outputFile.toPath())) {
               stream.forEach(System.out::println);
           }
       }
   
       private void reportComponent(
           ResolvedComponentResult component,
           PrintWriter writer,
           Set<ResolvedComponentResult> seen,
           String indent
       ) {
           writer.print(component.getId().getDisplayName());
           if (seen.add(component)) {
               writer.println();
               String newIndent = indent + "  ";
               for (DependencyResult dependency : component.getDependencies()) {
                   writer.print(newIndent);
                   writer.print(dependency.getRequested().getDisplayName());
                   writer.print(" -> ");
                   if (dependency instanceof ResolvedDependencyResult) {
                       ResolvedDependencyResult resolvedDependency = (ResolvedDependencyResult) dependency;
                       reportComponent(resolvedDependency.getSelected(), writer, seen, newIndent);
                   } else {
                       writer.println(" -> not found");
                   }
               }
           } else {
               writer.println(" (already seen)");
           }
       }
   }

samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/common/dependency-reports/src/main/java/com/example/GraphResolvedComponentsAndFiles.java

.. code-block::

   package com.example;
   
   import org.gradle.api.DefaultTask;
   import org.gradle.api.artifacts.component.ComponentArtifactIdentifier;
   import org.gradle.api.artifacts.component.ComponentIdentifier;
   import org.gradle.api.artifacts.result.DependencyResult;
   import org.gradle.api.artifacts.result.ResolvedComponentResult;
   import org.gradle.api.artifacts.result.ResolvedDependencyResult;
   import org.gradle.api.file.ConfigurableFileCollection;
   import org.gradle.api.file.RegularFileProperty;
   import org.gradle.api.provider.ListProperty;
   import org.gradle.api.provider.Property;
   import org.gradle.api.tasks.Input;
   import org.gradle.api.tasks.InputFiles;
   import org.gradle.api.tasks.OutputFile;
   import org.gradle.api.tasks.TaskAction;
   
   import java.io.File;
   import java.io.IOException;
   import java.io.PrintWriter;
   import java.nio.file.Files;
   import java.util.*;
   import java.util.stream.Stream;
   
   public abstract class GraphResolvedComponentsAndFiles extends DefaultTask {
   
       @Input
       public abstract ListProperty<ComponentArtifactIdentifier> getArtifactIdentifiers();
   
       @InputFiles
       public abstract ConfigurableFileCollection getArtifactFiles();
   
       @Input
       public abstract Property<ResolvedComponentResult> getRootComponent();
   
       @OutputFile
       public abstract RegularFileProperty getOutputFile();
   
       @TaskAction
       public void action() throws IOException {
           Map<ComponentIdentifier, File> filesByIdentifiers = filesByIdentifiers();
           File outputFile = getOutputFile().get().getAsFile();
           try (PrintWriter writer = new PrintWriter(outputFile)) {
               Set<ResolvedComponentResult> seen = new HashSet<>();
               reportComponent(getRootComponent().get(), writer, seen, filesByIdentifiers, "");
           }
           try (Stream<String> stream = Files.lines(outputFile.toPath())) {
               stream.forEach(System.out::println);
           }
       }
   
       private void reportComponent(
           ResolvedComponentResult component,
           PrintWriter writer,
           Set<ResolvedComponentResult> seen,
           Map<ComponentIdentifier, File> filesByIdentifiers,
           String indent
       ) {
           writer.print(component.getId().getDisplayName());
           File file = filesByIdentifiers.get(component.getId());
           if (file != null) {
               writer.print(" => ");
               writer.print(file.getName());
           }
           if (seen.add(component)) {
               writer.println();
               String newIndent = indent + "  ";
               for (DependencyResult dependency : component.getDependencies()) {
                   writer.print(newIndent);
                   writer.print(dependency.getRequested().getDisplayName());
                   writer.print(" -> ");
                   if (dependency instanceof ResolvedDependencyResult) {
                       ResolvedDependencyResult resolvedDependency = (ResolvedDependencyResult) dependency;
                       reportComponent(resolvedDependency.getSelected(), writer, seen, filesByIdentifiers, newIndent);
                   } else {
                       writer.println(" -> not found");
                   }
               }
           } else {
               writer.println(" (already seen)");
           }
       }
   
       private Map<ComponentIdentifier, File> filesByIdentifiers() {
           Map<ComponentIdentifier, File> map = new HashMap<>();
           List<ComponentArtifactIdentifier> identifiers = getArtifactIdentifiers().get();
           List<File> files = new ArrayList<>(getArtifactFiles().getFiles());
           for (int index = 0; index < identifiers.size(); index++) {
               map.put(identifiers.get(index).getComponentIdentifier(), files.get(index));
           }
           return map;
       }
   }

samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/common/dependency-reports/src/main/java/com/example/ListResolvedArtifacts.java

.. code-block::

   package com.example;
   
   import org.gradle.api.DefaultTask;
   import org.gradle.api.artifacts.component.ComponentArtifactIdentifier;
   import org.gradle.api.artifacts.result.ResolvedVariantResult;
   import org.gradle.api.file.RegularFile;
   import org.gradle.api.file.RegularFileProperty;
   import org.gradle.api.provider.ListProperty;
   import org.gradle.api.tasks.Input;
   import org.gradle.api.tasks.InputFiles;
   import org.gradle.api.tasks.OutputFile;
   import org.gradle.api.tasks.TaskAction;
   
   import java.io.File;
   import java.io.FileWriter;
   import java.io.IOException;
   import java.io.PrintWriter;
   import java.nio.file.Files;
   import java.util.List;
   import java.util.stream.Stream;
   
   public abstract class ListResolvedArtifacts extends DefaultTask {
   
   // tag::inputs[]
   @Input
   public abstract ListProperty<ComponentArtifactIdentifier> getArtifactIds();
   // end::inputs[]
   
       @Input
       public abstract ListProperty<ResolvedVariantResult> getArtifactVariants();
   
       @InputFiles
       public abstract ListProperty<RegularFile> getArtifactFiles();
   
       @OutputFile
       public abstract RegularFileProperty getOutputFile();
   
       @TaskAction
       public void action() throws IOException {
           File outputFile = getOutputFile().getAsFile().get();
           try (PrintWriter writer = new PrintWriter(new FileWriter(outputFile))) {
               List<ComponentArtifactIdentifier> ids = getArtifactIds().get();
               List<ResolvedVariantResult> variants = getArtifactVariants().get();
               List<RegularFile> files = getArtifactFiles().get();
               for (int index = 0; index < ids.size(); index++) {
                   ComponentArtifactIdentifier id = ids.get(index);
                   ResolvedVariantResult variant = variants.get(index);
                   RegularFile file = files.get(index);
                   writer.print("FILE ");
                   writer.println(file.getAsFile().getName());
                   writer.print("  id: ");
                   writer.println(id.getDisplayName());
                   writer.print("  variant: ");
                   writer.println(variant.getDisplayName());
                   writer.print("  size: ");
                   writer.println(file.getAsFile().length());
                   writer.println();
               }
           }
           try (Stream<String> stream = Files.lines(outputFile.toPath())) {
               stream.forEach(System.out::println);
           }
       }
   }

samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/groovy/build.gradle

.. code-block::

   plugins {
       id "application"
       id "com.example.dependency-reports"
   }
   
   dependencies {
       constraints {
           implementation "org.apache.commons:commons-text:1.9"
       }
       implementation "org.apache.commons:commons-text"
       implementation project(":utilities")
   }

samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/groovy/dependency-reports/build.gradle

.. code-block::

   plugins {
       id "java-gradle-plugin"
   }
   
   gradlePlugin {
       plugins {
           dependencyReports {
               id = "com.example.dependency-reports"
               implementationClass = "com.example.DependencyReportsPlugin"
           }
       }
   }

samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/groovy/dependency-reports/settings.gradle

.. code-block::

   rootProject.name = "dependency-reports"

samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/groovy/list/build.gradle

.. code-block::

   plugins {
       id "java-library"
   }

samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/groovy/settings.gradle

.. code-block::

   rootProject.name = "tasks-with-dependency-resolution-result-inputs"
   // tag::includes[]
   includeBuild "dependency-reports"
   
   include "utilities"
   include "list"
   // end::includes[]
   
   dependencyResolutionManagement {
       repositories {
           mavenCentral()
       }
   }

samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/groovy/utilities/build.gradle

.. code-block::

   plugins {
       id "java-library"
   }
   
   dependencies {
       api project(":list")
   }

samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/kotlin/build.gradle.kts

.. code-block::

   plugins {
       id("application")
       id("com.example.dependency-reports")
   }
   
   dependencies {
       constraints {
           implementation("org.apache.commons:commons-text:1.9")
       }
       implementation("org.apache.commons:commons-text")
       implementation(project(":utilities"))
   }

samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/kotlin/settings.gradle.kts

.. code-block::

   rootProject.name = "tasks-with-dependency-resolution-result-inputs"
   // tag::includes[]
   includeBuild("dependency-reports")
   
   include("utilities")
   include("list")
   // end::includes[]
   
   dependencyResolutionManagement {
       repositories {
           mavenCentral()
       }
   }

samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/kotlin/dependency-reports/build.gradle.kts

.. code-block::

   plugins {
       id("java-gradle-plugin")
   }
   
   gradlePlugin {
       plugins {
           create("dependencyReports") {
               id = "com.example.dependency-reports"
               implementationClass = "com.example.DependencyReportsPlugin"
           }
       }
   }

samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/kotlin/dependency-reports/settings.gradle.kts

.. code-block::

   rootProject.name = "dependency-reports"

samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/kotlin/list/build.gradle.kts

.. code-block::

   plugins {
       id("java-library")
   }

samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/kotlin/utilities/build.gradle.kts

.. code-block::

   plugins {
       id("java-library")
   }
   
   dependencies {
       api(project(":list"))
   }

samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/tests/dependencyReports.sample.conf

.. code-block::

   commands: [{
       executable: gradle
       args: "-q :listResolvedArtifacts"
       expected-output-file: listResolvedArtifacts.out
   },
   {
       executable: gradle
       args: "-q :graphResolvedComponents"
       expected-output-file: graphResolvedComponents.out
   },
   {
       executable: gradle
       args: "-q :graphResolvedComponentsAndFiles"
       expected-output-file: graphResolvedComponentsAndFiles.out
   }]

samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/tests/graphResolvedComponents.out

.. code-block::

   project :
     org.apache.commons:commons-text -> org.apache.commons:commons-text:1.9
       org.apache.commons:commons-lang3:3.11 -> org.apache.commons:commons-lang3:3.11
     project :utilities -> project :utilities
       project :list -> project :list
     org.apache.commons:commons-text:1.9 -> org.apache.commons:commons-text:1.9 (already seen)

samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/tests/graphResolvedComponentsAndFiles.out

.. code-block::

   project :
     org.apache.commons:commons-text -> org.apache.commons:commons-text:1.9 => commons-text-1.9.jar
       org.apache.commons:commons-lang3:3.11 -> org.apache.commons:commons-lang3:3.11 => commons-lang3-3.11.jar
     project :utilities -> project :utilities => utilities.jar
       project :list -> project :list => list.jar
     org.apache.commons:commons-text:1.9 -> org.apache.commons:commons-text:1.9 => commons-text-1.9.jar (already seen)

samples/writing-tasks/tasks-with-dependency-resolution-result-inputs/tests/listResolvedArtifacts.out

.. code-block::

   FILE commons-text-1.9.jar
     id: commons-text-1.9.jar (org.apache.commons:commons-text:1.9)
     variant: org.apache.commons:commons-text:1.9 configuration runtime
     size: 216211
   
   FILE utilities.jar
     id: utilities.jar (project :utilities)
     variant: configuration ':utilities:runtimeElements'
     size: 261
   
   FILE commons-lang3-3.11.jar
     id: commons-lang3-3.11.jar (org.apache.commons:commons-lang3:3.11)
     variant: org.apache.commons:commons-lang3:3.11 configuration runtime
     size: 577742
   
   FILE list.jar
     id: list.jar (project :list)
     variant: configuration ':list:runtimeElements'
     size: 261
