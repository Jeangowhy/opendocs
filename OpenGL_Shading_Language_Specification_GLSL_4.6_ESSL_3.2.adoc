// Copyright 2022-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0
// /antora/pageHeaders-spec.adoc
// Boilerplate to include in spec pages.

// include::{config}/headerattribs.adoc[]
// include::{config}/attribs.adoc[]


// Copyright 2015-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0
// /config/headerattribs.adoc
= Header Attributes Settinigs
:GLSL:
:ESSL:
:icons: font
:doctype: book

pass:a,q[<style>
    #openglessl,
    .openglessl.listingblock
        { border: 3px solid #cc880950; background: #cc880910;}
    .openglessl.exampleblock .content
        { /*border: 3px solid #cc880950;*/; background:#cc880910;}
    #openglsl,
    .openglsl.listingblock
        { border: 3px solid #2c9adb50; background:#2c9adb10;}
    .openglsl.exampleblock .content
        { /*border: 3px solid #2c9adb50;*/; background:#2c9adb10;}
    .myrole { border: 3px solid #333333;}
    .ESSL { color:#2c9adb;;}
    .ESSL::after{content:"ESSL";font-size:0.5em;
                position:relative;top:-0.5em;}
    .GLSL { color:#cc8809;}
    .GLSL::after{content:"GLSL";font-size:0.5em;
                position:relative;top:-0.5em;}</style>]

// The remainder of this file is used in the Antora build, and corresponds
// directly to attributes set in the specification title file, core.adoc.

// {GLSL} or {ESSL} must be set in the invoking command line to generate
// the corresponding specification
//
// {apiname} - API name, OpenGL or OpenGL ES
// {apispec} - API specification name
// {apiversion} - API version number (major.minor)
// {slname} - shading language name
// {version} - shading language __VERSION__ string (majorminor)
// {minor} - shading language version number (major.minor)
// {revision} - shading language revision number
// {revnumber} - full major.minor.revision number
// {authors} - shading language spec authors (for title page)

ifdef::GLSL[]
:apiname: OpenGL
:apiversion: 4.6
:slabbrev: GLSL
:version: 460
:minor: 4.60
:authors: Graeme Leese, Broadcom (Editor) ; John Kessenich (Author) ; Dave Baldwin and Randi Rost (Version 1.1 Authors)
:compiletimeerror: a compile-time error
:highp:
:mediump:
:lowp:
endif::GLSL[]

:revision: 9

:GLapiname: OpenGL
:GLapispec: {apiname} Specification
:GLslname: {apiname} Shading Language
:GLrevnumber: {minor}.{revision}

ifdef::ESSL[]
:apiname: OpenGL ES
:apiversion: 3.2
:slabbrev: GLSL ES
:version: 320
:minor: 3.20
:authors: Graeme Leese, Broadcom (Editor) ; Robert J. Simpson, Qualcomm ; John Kessenich ; Dave Baldwin and Randi Rost (Version 1.1 Authors)
:compiletimeerror: an error
:highp: highp
:mediump: mediump
:lowp: lowp
endif::ESSL[]

:regtitle: pass:q,r[^®^]
:apispec: {apiname} Specification
:slname: {apiname} Shading Language
:revnumber: {minor}.{revision}


// Copyright 2015-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0
// /config/attribs.adoc

// Various special / math symbols, matching LaTeX names.
// The pass:[+ ] notation avoids asciidoctor EOL treatment of the attribute.

// Special symbols - not used in [eq] spans
:sym1: ✓
:sym2: †
:sym3: ‡
:sym4: §
:reg: ®
:trade: ™
:harr: ↔

// Math operators and logic symbols
:times: ×
:cdot: ⋅
:plus: pass:[+ ]
:minus: pass:[- ]
:geq: ≥
:leq: ≤
:neq: ≠
:leftarrow: ←
:uparrow: ↑
:rightarrow: →
:downarrow: ↓
:elem: ∈
:lnot: ¬
:land: ∧
:lor: ∨
:oplus: ⊕
:lceil: ⌈
:rceil: ⌉
:lfloor: ⌊
:rfloor: ⌋
:vert: |
:partial: ∂
:onehalf: ½
:onequarter: ¼
:ldots: …
:forall: ∀
:sqrt: √
:inf: ∞
:plusmn: ±

// Greek letters
:alpha: α
:beta: β
:gamma: γ
:DeltaUpper: Δ
:delta: δ
:epsilon: ε
:eta: η
:theta: θ
:lambda: λ
:pi: π
:rho: ρ
:sigma: σ
:tau: τ
:phi: ϕ

// Word break opportunity tag for HTML
ifdef::backend-html5[]
:wbro: pass:[<wbr>]
endif::backend-html5[]
ifndef::backend-html5[]
:wbro:
endif::backend-html5[]


= The OpenGL® Shading Language Specification, GLSL 4.60.9 and ESSL 3.20.8
:url-repo: https://vscode.dev/github/KhronosGroup/OpenGL-GLSL
:doctype: book
:toc:
:toclevels: 1
:partnums:  
:sectnums: |,all|
:chapter-number: 1
:chapter-signifier: Sect.

此文档包含 OpenGL 着色器语言规范文档 GLSL 4.60.9 与 ESSL 3.20.9，两个规范差别内容通过
AsciiDoc 文档配置来选择，分别是 `:GLSL:` 以及 `:ESSL:`，并且 `:ESSL:` 配置数据靠后，
启用它会覆盖 `:GLSL:` 文档配置。此文档同时开启了 GLSL 和 ESSL 配置，也就是所有内容都会呈现，
但是版本号会覆盖为 ESSL 3.20.9，应该对照文档源文来差别哪些是 GLSL 或者 ESSL 专属的内容。
Khrnos 官方网站上发布的 PDF 或者 HTML 格式都按此 AsciiDoc 文档的不同配置生成。

阅读 AsciiDoc 源文档时，只需要将 `{version}` 或 `{version} es` 脑补为相应的版本号。
`:apispec:` 或者 `:slname:` 脑补为 OpenGL/ES Specification 或者
OpenGL/ES Shading Language。此外，还有文档中定义的其它替换符号。此文档对内容进行颜色标记，
对两个规范的文档内容分别以两个主题颜色进行区分，同时对于大块的内容使用同色系的淡背景色进行区别：

[source,asciidoc,role=openglsl]
=============================
* [.GLSL]##{GLapiname}{regtitle}: {GLslname} {GLrevnumber}##
=============================

[source,asciidoc,"role=openglessl"]
=============================
* [.ESSL]##{apiname}{regtitle}: {slname} {revnumber}##
=============================

OpenGL 规范文档主要是着色器语言规范和 API 接口规范两部分，前者源文件使用 AsciiDoc 格式编辑，
对应代码仓库是 OpenGL-GLSL。后者使用 XML 格式，因为涉及硬件厂商需要实现的编程接口，使用了 XML
描述各个 API 的功能信息，参考手册对应的代码仓库是 OpenGL-Refpages。源文件编译生成 PDF 或 HTML，
这些规范文档又发布到 OpenGL-Registry 仓库。发布的 API 规范文档双有两个 PDF 格式版本，其中
标注为 with changes marked 的版本会给 PDF 中不适用的内容添加删除线或紫色字体标注变动内容。
OpenGL API 新规范与 OpenGL ES 差别在于前者有 Core Profile 和 Compatibility 两种配置，
因此文档内容更多，文档源文件组织也更复杂，包括数十家硬件厂商的扩展、API 原型声明文件等等。

OpenGL 规范文档及 AsciiDoc 文档格式语法参考::
    https://github.khronos.org[Khronos Group GitHub Directory] +
    https://registry.khronos.org/OpenGL/index_gl.php[Khronos OpenGL® Registry] +
    https://registry.khronos.org/OpenGL/index_es.php[Khronos OpenGL ES Registry] +
    https://registry.khronos.org/OpenGL/index_sc.php[Khronos OpenGL SC Registry] +
    https://github.com/KhronosGroup/OpenGL-Registry[OpenGL-Registry] +
    https://vscode.dev/github/KhronosGroup/OpenGL-Refpages[OpenGL® and OpenGL ES reference page sources] +
    https://vscode.dev/github/KhronosGroup/OpenGL-GLSL[Source of GLSL Specification and GLSL extensions] +
    https://docs.asciidoctor.org/asciidoc/latest/asciidoc-vs-markdown/[Compare AsciiDoc to Markdown] +
    https://docs.asciidoctor.org/asciidoc/latest/syntax-quick-reference/[AsciiDoc Syntax Quick Reference] + 

*OpenGL ES 3.2 Specifications and Documentation*

-   OpenGL ES 3.2 Specification (May 5, 2022)
    https://registry.khronos.org/OpenGL/specs/es/3.2/es_spec_3.2.pdf[without changes marked] and 
    https://registry.khronos.org/OpenGL/specs/es/3.2/es_spec_3.2.withchanges.pdf[with changes marked] .
-   OpenGL ES Shading Language 3.20 Specification (August 14, 2023) 
    https://registry.khronos.org/OpenGL/specs/es/3.2/GLSL_ES_Specification_3.20.html[(HTML)] 
    https://registry.khronos.org/OpenGL/specs/es/3.2/GLSL_ES_Specification_3.20.pdf[(PDF)]
-   http://www.khronos.org/registry/OpenGL-Refpages/es3/[OpenGL ES 3.2 Online Reference Pages.]
-   OpenGL ES Quick Reference Card (available for different API versions).
    https://www.khronos.org/developers/reference-cards[(Lists)]
    https://www.khronos.org/files/opengles32-quick-reference-card.pdf[(ESSL 3.20 Reference Card)]

*OpenGL API, OpenGL Shading Language and GLX Specifications and Reference Pages*

-   OpenGL 4.6 API Specification (May 5, 2022)
**  https://registry.khronos.org/OpenGL/specs/gl/glspec46.core.pdf[Core Profile Specification]
**  https://registry.khronos.org/OpenGL/specs/gl/glspec46.core.withchanges.pdf[Core Profile Specification with changes marked]
**  https://registry.khronos.org/OpenGL/specs/gl/glspec46.compatibility.pdf[Compatibility Profile Specification]
**  https://registry.khronos.org/OpenGL/specs/gl/glspec46.compatibility.withchanges.pdf[Compatibility Profile Specification with changes marked]
-   OpenGL Shading Language 4.60 Specification (August 14, 2023) 
    https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.60.html[(HTML)] 
    https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.60.pdf[(PDF)]
-   OpenGL 4.5 API and Shading Language Reference Pages (not yet updated)
    http://www.khronos.org/registry/OpenGL-Refpages/gl4/[(HTML)]
-   OpenGL X Window System Binding (GLX 1.4) Specification
-   GLX 1.4 Specification
    https://registry.khronos.org/OpenGL/specs/gl/glx1.4.pdf[(PDF)]
-   OpenGL Quick Reference Card (available for different API versions).
    https://www.khronos.org/developers/reference-cards[(Lists)]
    https://www.khronos.org/files/opengl46-quick-reference-card.pdf[(GLSL 4.60 Reference Card)]


// Copyright 2008-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0
// config/README.adoc
= GLSL Asciidoc Configuration Files

== Macros

The macros in `vulkan-macros.rb` and `vulkan-macros/extension.rb` are
described in the "`Vulkan Documentation and Extensions: Procedures and
Conventions`" document in the
link:https://registry.khronos.org/vulkan/[Vulkan Registry].
They are not currently used, but included as examples.

== Support for Math

Asciidoctor is customized to insert KaTeX `<script>` tags from
`math.js` for HTML5, and properly pass through math which has
`\begin{}\/end{}` delimiters instead of $$\[\]\(\).

For PDF builds, asciidoctor-mathematical is used to generate
images.

// == Stylesheets
//
// `khronos.css` is the stylesheet used for HTML output.
// It is a slightly tweaked version of the Asciidoctor 'Colony' theme.

// == Title Page Images
//
// Asciidoctor requires use of `docinfo` files to get logos onto the title
// page, and has very restrictive naming conventions forcing the
// subdirectories:
//
// * `vulkan/docinfo-header.html` - Vulkan logo in docinfo HTML form
// * `vulkansc/docinfo-header.html` - Vulkan SC logo in docinfo HTML form
// * `makedocinfologo` - script to convert SVG file to docinfo HTML file

== Asciidoctor Extensions

We use a number of Asciidoctor customizations written in Ruby, described
briefly below.

// * `asciidoctor-mathematical-ext.rb` - make latexmath: blocks work in table cells
// * `extension-highlighter.rb` - one way of constructing a diff HTML document
* `katex_replace.rb` - substitute KaTeX for MathJax in output HTML
// * `loadable_html.rb` - add some status messages for slow-loading documents
// * `rouge-extend-css.rb` - override parts of the 'rouge' highlighter CSS
// * `spec-macros.rb` - custom asciidoctor macros used in spec markup
// * `open_listing_block.rb` - allow '----' as a nested open block delimiter when tagged by '[open]'
// * `vuid-expander.rb` - add anchors to valid usage ID tags
// * `vu-to-json.rb` - extract valid usage statements to JSON as part of a dummy spec build

// == CI support files
//
// These files are auxiliary data supplied to CI scripts
//
// * CI/contractions - disallowed contractions
// * CI/contractions-allowed - regular expressions matching filenames allowed
//   to have contractions


// Copyright 2022-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0
// antora/modules/ROOT/pages/index.adoc
= OpenGL Shading Language Documentation
link:#toc[💨]

// include::{config}/headerattribs.adoc[]
// include::{config}/attribs.adoc[]


== About

This site includes the {slname}, Version {revnumber} specification.


== Navigation

The site is organized in "`components`" (Antora terminology for
specifications and other documents), each containing many "`pages`" (Antora
terminology for a chapter of a specification, or other distinct piece of
content for other components).

The left navigation sidebar links to pages in the current component.

The right navigation sidebar links to sections in the current page.

The bottom-left button switches between components.

The top navigation bar contains a text searchbox.
If the "`In this component`" box is checked, search will be restricted to
the current component.
Otherwise, all components of the site are searched.


== Site Information

link:https://docs.vulkan.org/[This site] is generated using the
link:https://docs.antora.org/[Antora] static site generator.

If you need to report a problem or build the site yourself, start with the
link:https://github.com/KhronosGroup/Vulkan-Site/[Vulkan-Site] repository on
GitHub.

// Copyright 2022-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0
// antora/modules/ROOT/nav.adoc
// Navigation page for GLSL spec in Antora
[[toc,~💨~]]
= Contents
// This corresponds to ../core.adoc - each top-level chapter is referenced
// below in the same order

// * xref:chapters/preamble.adoc[]
// * xref:chapters/introduction.adoc[]
// * xref:chapters/overview.adoc[]
// * xref:chapters/basics.adoc[]
// * xref:chapters/variables.adoc[]
// * xref:chapters/operators.adoc[]
// * xref:chapters/statements.adoc[]
// * xref:chapters/builtins.adoc[]
// * xref:chapters/builtinfunctions.adoc[]
// ifdef::ESSL[]
// * xref:chapters/interfacematching.adoc[]
// endif::ESSL[]
// * xref:chapters/grammar.adoc[]
// ifdef::ESSL[]
// * xref:chapters/iocounting.adoc[]
// endif::ESSL[]
// * xref:chapters/acknowledgements.adoc[]
// * xref:chapters/references.adoc[]
// * xref:chapters/spirvmappings.adoc[]


* <<preamble>>
* <<introduction>>
* <<overview>>
* <<basics>>
* <<variables-and-types>>
* <<operators>>
* <<statements>>
* <<builtins>>
* <<builtinfunctions>>
ifdef::ESSL[]
* <<interfacematching>> ^+ESSL Only+^
endif::ESSL[]
* <<grammar>>
ifdef::ESSL[]
* <<iocounting>> ^+ESSL Only+^
endif::ESSL[]
* <<acknowledgements>>
* <<references>>
* <<spirvmappings>>

// Copyright 2008-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0
// chapters/preamble.adoc
// Note that this file is used to pull the Khronos Specification Copyright
// into the output documents generated by Khronos. This file itself is under
// CC-BY-4.0, but the output specifications are not.


[[preamble]]
= Preamble
<<toc>>


// include::{config}/copyright-spec.adoc[]
// config/copyright-spec.adoc

// This is version V10_Feb23 of the Khronos Specification Copyright License
// Header, reformatted for asciidoc markup and for expository purposes in
// the Khronos Sample Specification repository.

// Some sections of this license are optional and are selected by
// asciidoc attributes set when building specifications including this
// file.
// Comments starting with NOTE: indicate that the following paragraph(s)
// need to be modified to incorporate language suitable to the specification
// being generated.
//
// Optional sections include:
//
// - The "Ratified Specifications" section includes one of two mutually
//   exclusive paragraphs.
//   Set the :ratified_spec: attribute when generating a specification
//   containing no non-ratified extensions.
//   Do not set this attribute otherwise.
// - The "Successor Specification" section is included when generating a
//   specification derived from a differently named specification (for
//   example, Vulkan is a Successor of OpenGL).
//   Set the :successor_spec: attribute and modify this section as described
//   below if needed.
// - The "Normative Wording" section is included if the Working Group
//   explicitly requests restating of the Khronos Intellectual Property
//   Rights Policy.
//   Set the :normative_spec_wording: attribute and modify this section as
//   described below if needed.
// - The "Normative References" section is included if a specification
//   contains normative references to other specification that are created
//   externally to Khronos.
//   Set the :normative_spec_references: attribute and modify this section
//   as described below if needed.

// NOTE: asciidoc attributes controlling inclusion of sections can be set
// here by uncommenting the appropriate lines, or on the asciidoctor command
// line.

:ratified_spec:
// :successor_spec:
// :normative_spec_wording:
:normative_spec_references:


// NOTE: The Copyright statement should include the year of the
// Specification's release.
// If this is a new version of an existing Specification, include a range of
// dates starting from the year that the initial version of the
// Specification was released.
// E.g. if this is version 4.0 of a Specification released in 2023, and V1.0
// of the Specification was released in 2012, then the first line should
// replace "[insert date(s)]" with "2012-2023".

Copyright 2008-2024 The Khronos Group Inc.

This Specification is protected by copyright laws and contains material
proprietary to Khronos.
Except as described by these terms, it or any components may not be
reproduced, republished, distributed, transmitted, displayed, broadcast or
otherwise exploited in any manner without the express prior written
permission of Khronos.

Khronos grants a conditional copyright license to use and reproduce the
unmodified Specification for any purpose, without fee or royalty, EXCEPT no
licenses to any patent, trademark or other intellectual property rights are
granted under these terms.

Khronos makes no, and expressly disclaims any, representations or
warranties, express or implied, regarding this Specification, including,
without limitation: merchantability, fitness for a particular purpose,
non-infringement of any intellectual property, correctness, accuracy,
completeness, timeliness, and reliability.
Under no circumstances will Khronos, or any of its Promoters, Contributors
or Members, or their respective partners, officers, directors, employees,
agents or representatives be liable for any damages, whether direct,
indirect, special or consequential damages for lost revenues, lost profits,
or otherwise, arising from or in connection with these materials.

// "Ratified Specifications" section (two mutually exclusive paragraphs)

// Specifications that contain no non-ratified extensions
ifdef::ratified_spec[]

This Specification has been created under the Khronos Intellectual Property
Rights Policy, which is Attachment A of the Khronos Group Membership
Agreement available at https://www.khronos.org/files/member_agreement.pdf.
Parties desiring to implement the Specification and make use of Khronos
trademarks in relation to that implementation, and receive reciprocal patent
license protection under the Khronos Intellectual Property Rights Policy
must become Adopters and confirm the implementation as conformant under the
process defined by Khronos for this Specification; see
https://www.khronos.org/adopters .

endif::ratified_spec[]

// Specifications that contain non-ratified extensions
// NOTE: fill in the API name and a link to where it is published below.

ifndef::ratified_spec[]

This document contains extensions which are not ratified by Khronos, and as
such is not a ratified Specification, though it contains text from (and is a
superset of) the ratified [API name] Specification that can be found at
[API link].

endif::ratified_spec[]


// Optional "Successor Specification" section
// NOTE: fill in [insert successor specifications here] below

ifdef::successor_spec[]

This Specification contains substantially unmodified functionality from, and
is a successor to, Khronos specifications including [insert successor
specifications here].

endif::successor_spec[]


// Optional "Normative Wording" section

ifdef::normative_spec_wording[]

The Khronos Intellectual Property Rights Policy defines the terms 'Scope',
'Compliant Portion', and 'Necessary Patent Claims'.

// NOTE: Replace the asciidoc "xref-informative" xref below with the anchor
// within this spec, and name of the section discussing informative
// language.

Some parts of this Specification are purely informative and so are EXCLUDED
from the Scope of this Specification.
The <<xref-informative, document conventions section of the Introduction>>
defines how these parts of the Specification are identified.

// NOTE: If this specification has an introductory section discussing
// "technical terminology", and/or a Glossary, replace the corresponding
// terms below with xrefs to those sections.

Where this Specification uses technical terminology, defined in the Glossary
or otherwise, that refer to enabling technologies that are not expressly set
forth in this Specification, those enabling technologies are EXCLUDED from
the Scope of this Specification.
For clarity, enabling technologies not disclosed with particularity in this
Specification (e.g. semiconductor manufacturing technology, hardware
architecture, processor architecture or microarchitecture, memory
architecture, compiler technology, object oriented technology, basic
operating system technology, compression technology, algorithms, and so on)
are NOT to be considered expressly set forth; only those application program
interfaces and data structures disclosed with particularity are included in
the Scope of this Specification.

For purposes of the Khronos Intellectual Property Rights Policy as it
relates to the definition of Necessary Patent Claims, all recommended or
optional features, behaviors and functionality set forth in this
Specification, if implemented, are considered to be included as Compliant
Portions.

endif::normative_spec_wording[]


// Optional "Normative References" section

ifdef::normative_spec_references[]

Where this Specification identifies specific sections of external
references, only those specifically identified sections define normative
functionality.
The Khronos Intellectual Property Rights Policy excludes external references
to materials and associated enabling technology not created by Khronos from
the Scope of this Specification, and any licenses that may be required to
implement such referenced materials and associated technologies must be
obtained separately and may involve royalty payments.

endif::normative_spec_references[]


// Trademark section
// NOTE: make sure that all relevant marks are included, since this list
// grows over time. Trademarks that are not referenced by this Specification
// can be removed.

Khronos and Vulkan are registered trademarks, and
SPIR-V is a trademark of The Khronos Group Inc.
OpenGL is a registered trademark and the OpenGL ES and OpenGL SC logos are
trademarks of Hewlett Packard Enterprise used under license by Khronos.
All other product names, trademarks, and/or company names are used solely
for identification and belong to their respective owners.


// Copyright 2008-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0
// chapters/introduction.adoc
[[introduction]]
= Introduction
<<toc>>

This document specifies only version {minor} of the {slname} ({slabbrev}).
It requires +__VERSION__+ to substitute {version}, and requires
*#version* to accept only
ifdef::GLSL[`{version}`.]
ifdef::ESSL[`{version} es`.]
If *#version* is declared with a smaller number, the language accepted is a
previous version of the shading language, which will be supported depending
on the version and type of context in the API.
See the <<references, normative references>> for details on what language
versions are supported.

ifdef::GLSL[]
Previous versions of the {slname}, as well as the OpenGL ES Shading Language,
are not strict subsets of the version specified here, particularly with
respect to precision, name-hiding rules, and treatment of interface
variables.
See the specification corresponding to a particular language version for
details specific to that version of the language.
endif::GLSL[]

Throughout, when generating SPIR-V for consumption by the Vulkan API
(see <<references, normative references>>), this will be said to be
_targeting Vulkan_.

While this specification and the {apispec} are normative for {slname}, for
SPIR-V generation it is still the SPIR-V specification and the SPIR-V client
API specification that are normative for the generated SPIR-V.
See the <<references, normative references>> for further detail.

For SPIR-V generation, the SPIR-V client API specifies the commands used to
manipulate SPIR-V shaders.

Independent offline tool chains will compile {slabbrev} down to the SPIR-V
intermediate language.
SPIR-V generation is not enabled with a *#extension*, *#version*, or a
profile.
Instead, use of {slabbrev} for SPIR-V is determined by offline tool-chain use.
See the documentation of such tools to see how to request generation of
SPIR-V for its client API.

{slabbrev} -> SPIR-V compilers must be directed as to what SPIR-V *Capabilities*
are legal at run-time and give errors for {slabbrev} feature use outside those
capabilities.
This is also true for implementation-dependent limits that can be error
checked by the front-end against built-in constants present in the {slabbrev}
source: the front-end can be informed of such limits, and report errors when
they are exceeded.

ifdef::GLSL[]
SPIR-V features that are not controlled by a SPIR-V capability, but do have an
equivalent GLSL counterpart (stages, built-in functions, types, limits, etc.)
are only expected to work on OpenGL drivers that support the GLSL counterpart.
endif::GLSL[]

All references in this specification to the <<references,{apispec}>> are to
ifdef::GLSL[]
the Core profile of version {apiversion}, unless a different profile is
specified.
endif::GLSL[]
ifdef::ESSL[]
version {apiversion}.
endif::ESSL[]


[[changes]]
== Changes


=== Changes from {slabbrev} {apiversion} revision 8

 * Public GLSL issue #198: Clarify that logical operators operate only on scalars.
 * Private GLSL issue #59: Fix incorrect domain of *atanh* function.
 * Private GLSL issue #66: Add a note clarifying that uninitialized *out* parameters
   will be copied, causing function arguments to become undefined.
 * Private GLSL issue #68: Clarifying changes to the "`<<arrays,Arrays>>`" section.
   The section is reorganised for ease of editing and certain rules are clarified.
   The rules for unsized arrays are included for ES even though they cannot be
   declared because they apply to certain pre-declared uses.


ifdef::GLSL[]
=== Changes from {slabbrev} {apiversion} revision 7

 * Private GLSL issue #57: Clarify that *imageLoad* precision is determined (where
   applicable) only by the precision of the image argument.
 * Public GLSL issue #164: Clarify the precision expected from *mod*.
 * Public GLSL issue #8: Clarify when compute-shader variables may be accessed.
 * Public GLSL issue #13: Clarify bit-width requirements for location aliasing.
 * Public GLSL issue #161: Fix incorrect layout qualifier example.
 * Private GLSL issue #30: Clarify that struct members' precision is always fixed
   as part of the struct type declaration.
 * Private GLSL issue #49: Clarify support for unary *+*.
 * Private GLSL issue #43: Clarify precisions of constructors.
 * Private GLSL issue #53: Clarify which qualifiers are allowed on
   <<interface-blocks,Interface Blocks>>.
 * Private GLSL issue #31: Removed incorrect example of 'invariant' applied to
   'in' variable.
 * Fix public GLSL issue #83: It is only opaque-type variables that are
   required to keep their memory qualifiers (e.g., *readonly*) when
   passed to a user-defined function.
 * Clarify error conditions when declaring atomic counters.
 * Subnormal values might be flushed to 0.0 by *intBitsToFloat*().
 * Clarified that 'precise' cannot qualify structure definitions.
 * Private Bugzilla #15755: Clarify storage size of precision qualified
   <<interface-blocks,interface block>> members in application visible memory.

=== Changes from {slabbrev} {apiversion} revision 6

  * Incorporated the GL_KHR_vulkan_glsl specification.
  * Add note in the introduction about presence in drivers of SPIR-V features,
    as they relate to GLSL features.
  * Clarify it is same location that triggers default-uniform block matching
    rules.
    See <<uniform-variable-layout-qualifiers, Uniform Variable Layout Qualifiers>>.

=== Changes from {slabbrev} {apiversion} revision 5

  * Private GLSL issue #34: Clarify/consolidate implicit conversion rules from int -> uint
    to be the same as explicit construction.

  * Private GLSL issue #24: Clarify that *barrier*() by itself is enough to synchronize
    both control flow and memory accesses to *shared* variables and tessellation
    control output variables. For other memory accesses an additional memory
    barrier is still required.

  * Normatively reference IEEE-754 for definitions of floating-point formats.

  * Private GLSL issue 36: *refract* function on *double* types requires eta
    argument to have type *double*.

  * Clarify restrictions on input variables in tessellation and geometry stages.

  * Private GLSL issue 15: Clarify the ordering of bindings for arrays of arrays.

  * Private GLSL issue 14: Uniform variables need only match at link time if they
    are statically used.

  * For *precise* computations, the controlling expressions for
    control flow and ternary operators (*?:*) are not included.

=== Changes from {slabbrev} {apiversion} revision 4

  * Private bug 13012: Clarified that builtin uniform variables might only
    be available in the fragment stage.

  * Private bug 13837: Ternary and sequence operators may operate on *void* types.

  * Clarified that errors arising from preprocessing must be returned at compile time.

  * Clarified that access to any part of a variable constitutes a static use.

  * Private GLSL issue 19: A statement is required following any label at the end of a *switch*.

  * Private GLSL issue 26: *noise* is not valid when compiling for SPIR-V.

  * Private GLSL issue 20: *length*() expressions returning a constant value may not
    contain side effects.

  * Public OpenGL-API issue 7: Variables can be declared as both *readonly*
    and *writeonly*.

  * Private GLSL issue 16: Use of constant expressions within *#line* directives is undefined.

  * Corrected return type of *imageAtomicExchange* on *float* images.

  * Private GLSL issue 32: Remove *length*() method contradiction:
    Non runtime-sized arrays only support *length*() on explicitly
    sized arrays.

  * Private GLSL issue 21: Clarified the l-value restriction on *interpolateAt*.

  * Private OpenGL-API issue 53: Clarified bit-width requirements for location aliasing.

  * Public GLSL issue 15: *gl_in* can be redeclared using unsized-array syntax.

  * Clarification of the formats needed for DEPTH_COMPONENT and
    STENCIL_COMPONENT for depth/stencil textures.

  * Added image formats to the layout-qualifier table in the
    <<layout-qualifiers, Layout Qualifiers>> section.

=== Changes from {slabbrev} {apiversion} revision 3

  * Private GLSL issue 13: Fix misspelling of *allInvocationsEqual*().
    (The one in the table was incorrectly listed as *anyInvocationsEqual*(),
    other spellings were correct.)


=== Summary of Changes from Revision 7 of GLSL Version 4.50

  * Incorporated the GL_ARB_shader_atomic_counter_ops extension.
  * Incorporated the GL_ARB_shader_draw_parameters extension.
  * Incorporated the GL_ARB_shader_group_vote extension.
  * Incorporated the GL_ARB_gl_spirv extension.
  * Private Bug 16070: Allow extra semi-colons at global scope.
  * Private GLSL Issue 5: Be explicit that "`fail to link`" is really
    "`compile-time or link-time error`", for some forms of error.
  * Private GLSL Issue 7: Change _gl_MaxComputeUniformComponents_ to 1024.
  * Private OpenGL API Issue 35: Require location on transparent individual
    uniform variables for SPIR-V.
  * Private GLSL Issue 8: Be more clear an *interpolateAt*() interpolant can
    be a structure member.
  * Private GLSL Issue 9: Specify how *xfb_buffer* interacts with a block
    array: the capturing buffer increments for each block array element.
endif::GLSL[]
ifdef::ESSL[]
=== Changes from {slabbrev} {apiversion} revision 7

There are no changes between revision 7 and revision 8.

=== Changes from {slabbrev} {apiversion} revision 6

 * Private OpenGL issue #156: Clarify that per-vertex arrays of arrays of
   blocks are allowed in the geometry stage.
 * Private GLSL issue #57: Clarify that *imageLoad* precision is determined
   only by the precision of the image argument.
 * Public GLSL issue #164: Clarify the precision expected from *mod*.
 * Public GLSL issue #8: Clarify when compute-shader variables may be accessed.
 * Public GLSL Issue #159: Remove incorrect vertex input example.
 * Private GLSL issue #30: Clarify that struct members' precision is always fixed
   as part of the struct type declaration.
 * Private GLSL issue #49: Clarify support for unary *+*.
 * Private GLSL issue #43: Clarify precisions of constructors.
 * Private GLSL issue #53: Clarify which qualifiers are allowed on
   <<interface-blocks,Interface Blocks>>.
 * Private GLSL issue #55: Clarify which expressions are valid interpolants for
   <<interpolation-functions,interpolation functions>>.
 * Fix public GLSL issue #83: It is only opaque-type variables that are
   required to keep their memory qualifiers (e.g., *readonly*) when
   passed to a user-defined function.
 * Subnormal values might be flushed to 0.0 by *intBitsToFloat*().
 * Clarify error conditions when declaring atomic counters.
 * Clarified that 'precise' cannot qualify structure definitions.
 * Private Bugzilla #15755: Clarify storage size of precision qualified
   <<interface-blocks,interface block>> members in application visible memory.

=== Changes from {slabbrev} {apiversion} revision 5

  * Incorporated the GL_KHR_vulkan_glsl specification.
  * Clarify it is same location that triggers default-uniform block matching
    rules.
    See <<uniform-variable-layout-qualifiers, Uniform Variable Layout Qualifiers>>.

[[changes-from-glsl-es-3.2-revision-4]]
=== Changes from {slabbrev} {apiversion} revision 4

  * Clarified that this specification completely defines the {slname}.
    Normatively reference C++ only for the preprocessor.

  * Private GLSL issues 7, 38: Corrected the values of some builtin constants.
    The values were given correctly in the {apispec}.

  * Private GLSL issue 30: Clarify that output packing rules apply to the last
    vertex pipeline stage, not necessarily the vertex stage.

  * Private GLSL issue 15: Clarify the ordering of bindings for arrays of arrays.

  * Private GLSL issue 14: Uniform variables need only match at link time if they
    are statically used.

  * For *precise* computations, the controlling expressions for
    control flow and ternary operators (*?:*) are not included.

[[changes-from-glsl-es-3.2-revision-3]]
=== Changes from {slabbrev} {apiversion} revision 3

  * Matching of default uniforms when shaders are linked.
  * _gl_DepthRange_ is only guaranteed to be available in the fragment
    stage.
  * Clarification of definition of static use.
  * Sampling behavior in the absence of *sample* and *centroid*.
  * Clarified the requirements when the specification uses the terms
    _should_/_should not_ and _undefined behavior_.
  * Arrayed blocks cannot have layout location qualifiers on members
  * *barrier*() defines a partial order which includes tessellation control
    shader outputs.
  * Vertex shader integer output qualification.
  * Incorrect use of predefined pragmas.
  * Clarified use of *readonly* and *writeonly* qualifiers.
  * USAMPLERBUFFER added to grammar.
  * Clarified precision qualifiers can be used in interface blocks.
  * Clarified *memoryBarrierShared* only applies to the current workgroup.
  * The layout qualifier _invocations_ must not be zero.
  * The layout qualifier _local_size_ must not be zero.
  * Clarified the definition of static assignment.
  * Removed list of types with no default precision.
  * Removed scoping rules from the grammar. Refer instead to the <<scoping,scoping>> section.
  * Require a statement after the final label of a switch.
  * Define *gl_BoundingBox*.
  * *length*() expressions returning a constant-value may not include side effects.
  * Clarified that variables may be declared *readonly writeonly*.
  * Use of constant expressions within *#line* directives is undefined.
  * *gl_in* can be redeclared using unsized-array syntax.
  * Clarified which sampler types may be used for depth and stencil textures.
  * Added order-of-operation and other explanations to the
    <<the-precise-qualifier, Precise Qualifier>> section.
  * The *precise* qualifier applied to a block/struct applies recursively to the members.


[[changes-from-glsl-es-3.2-revision-2]]
=== Changes from {slabbrev} {apiversion} revision 2

  * Updated value for _gl_MaxTessControlTotalOutputComponents_
  * Clarified the allowed character set for pre-processing
  * Integer division wrapping behavior
  * Clarified pre-processor expressions (_pp-constant-expression_)
  * UBO and SSBO precisions do not need to match for linked shaders
    (consistent with GLSL ES 3.1)
  * *modf* function
  * Sequence and ternary operators with *void* type
  * Sequence and ternary operators with array types

[[changes-from-glsl-es-3.2-revision-1]]
=== Changes from {slabbrev} {apiversion} revision 1

  * Signed zeros must be supported
  * Layout qualifier table
  * Allowed optimizations when evaluating expressions
  * Updated value for _gl_MaxTessControlInputComponents_
  * Updated value for _gl_MaxTessControlOutputComponents_
  * Updated value for _gl_MaxTessEvaluationInputComponents_
  * Updated value for _gl_MaxTessEvaluationOutputComponents_
  * Updated value for _gl_MaxGeometryOutputComponents_
  * Require precisions in blocks to match when linking
  * Updated conclusions in issues section

[[changes-from-glsl-es-3.1-revision-4]]
=== Changes from GLSL ES 3.1 revision 4

  * Added the following extensions:
  ** https://www.opengl.org/registry/specs/KHR/blend_equation_advanced.txt[KHR_blend_equation_advanced]
  ** https://www.khronos.org/registry/gles/extensions/OES/OES_sample_variables.txt[OES_sample_variables]
  ** https://www.khronos.org/registry/gles/extensions/OES/OES_shader_image_atomic.txt[OES_shader_image_atomic]
  ** https://www.khronos.org/registry/gles/extensions/OES/OES_shader_multisample_interpolation.txt[OES_shader_multisample_interpolation]
  ** https://www.khronos.org/registry/gles/extensions/OES/OES_texture_storage_multisample_2d_array.txt[OES_texture_storage_multisample_2d_array]
  ** https://www.khronos.org/registry/gles/extensions/OES/OES_geometry_shader.txt[OES_geometry_shader]
  ** https://www.khronos.org/registry/gles/extensions/OES/OES_gpu_shader5.txt[OES_gpu_shader5]
  ** https://www.khronos.org/registry/gles/extensions/OES/OES_primitive_bounding_box.txt[OES_primitive_bounding_box]
  ** https://www.khronos.org/registry/gles/extensions/OES/OES_shader_io_blocks.txt[OES_shader_io_blocks]
  ** https://www.khronos.org/registry/gles/extensions/OES/OES_tessellation_shader.txt[OES_tessellation_shader]
  ** https://www.khronos.org/registry/gles/extensions/OES/OES_texture_buffer.txt[OES_texture_buffer]
  ** https://www.khronos.org/registry/gles/extensions/OES/OES_texture_cube_map_array.txt[OES_texture_cube_map_array]
  ** https://www.opengl.org/registry/specs/KHR/robustness.txt[KHR_robustness]
endif::ESSL[]


[[overview]]
== Overview
<<toc>>

This document describes _The {slname}, version {minor}_.

Independent compilation units written in this language are called _shaders_.
A _program_ is a set of shaders that are compiled and linked
ifdef::GLSL[]
together,
completely creating one or more of the programmable stages of the
API pipeline.
All the shaders for a single programmable stage must be within the same
program.
A complete set of programmable stages can be put into a single program or
the stages can be partitioned across multiple programs.
endif::GLSL[]
ifdef::ESSL[together.]
The aim of this document is to thoroughly specify the programming language.
The <<references, normative references>> will specify the API entry points
used to manipulate and communicate with programs and shaders.


[[error-handling]]
== Error Handling

Compilers, in general, accept programs that are ill-formed, due to the
impossibility of detecting all ill-formed programs.
Portability is only ensured for well-formed programs, which this
specification describes.
Compilers are encouraged to detect ill-formed programs and issue diagnostic
messages, but are not required to do so for all cases.
ifdef::GLSL[]
Compile-time errors must be returned for lexically or grammatically
incorrect shaders.
Other errors are reported at compile time or link time as indicated.
Code that is "`dead`" must still be error checked.
For example:

[source,glsl]
----
if (false)     // changing false to true cannot uncover additional errors
    statement; // statement must be error checked regardless
----
endif::GLSL[]
ifdef::ESSL[]
The compilation process is implementation-dependent but is generally split
into a number of stages, each of which occurs at one of the following times:

  * A call to _glCompileShader_
  * A call to _glLinkProgram_
  * A draw call or a call to _glValidateProgram_

The implementation should report errors as early a possible but in any case
must satisfy the following:

  * All lexical, grammatical and semantic errors must have been detected
    following a call to _glLinkProgram_
  * Errors due to mismatch between the shaders (link-time errors) must have
    been detected following a call to _glLinkProgram_
  * Errors due to exceeding resource limits must have been detected
    following any draw call or a call to _glValidateProgram_
  * A call to _glValidateProgram_ must report all errors associated with a
    program object given the current GL state.

Where the specification uses the terms _required_, _must_/_must_ _not_,
_does_/_does_ _not_, _disallowed_, or _not_ _supported_, the compiler or
linker is required to detect and report any violations.
Similarly when a condition or situation is an *error*, it must be reported.
Use of any feature marked as _reserved_ is an error.
Where the specification uses the terms _should_/_should_ _not_, _undefined_
_behavior_, _undefined_ _value_ or _undefined_ _*results*_, implementations
will not produce a compile-time error but are encouraged to issue a warning
for violations.
The run-time behavior of the program in these cases is not constrained (and
so may include termination or system instability).
It is expected that systems will be designed to handle these cases
gracefully but specification of this is outside the scope of this
specification.

Implementations may not in general support functionality beyond the mandated
parts of the specification without use of the relevant extension.
The only exceptions are:

  . If a feature is marked as optional.
  . Where a maximum value is stated (e.g. the maximum number of vertex
    outputs), the implementation may support a higher value than that
    specified.

Where the implementation supports more than the mandated specification,
off-target compilers are encouraged to issue warnings if these features are
used.

The compilation process is split between the compiler and linker.
The allocation of tasks between the compiler and linker is implementation
dependent.
Consequently there are many errors which may be detected either at compile
or link time, depending on the implementation.
endif::ESSL[]


[[typographical-conventions]]
== Typographical Conventions

Italic, bold, and font choices have been used in this specification
primarily to improve readability.
Code fragments use a fixed width font.
Identifiers embedded in text are italicized.
Keywords embedded in text are bold.
Operators are called by their name, followed by their symbol in bold in
parentheses.
The clarifying grammar fragments in the text use bold for literals and
italics for non-terminals.
The official grammar in "`<<shading-language-grammar,Shading Language
Grammar>>`" uses all capitals for terminals and lower case for
non-terminals.


ifdef::GLSL[]
[[deprecation]]
== Deprecation

The {slname} has deprecated some features.
These are clearly called out in this specification as "`deprecated`".
They are still present in this version of the language, but are targeted for
potential removal in a future version of the shading language.
The {apiname} API has a forward compatibility mode that will disallow use of
deprecated features.
If compiling in a mode where use of deprecated features is disallowed, their
use causes compile-time or link-time errors.
See the <<references,{apispec}>> for details on what causes deprecated
language features to be accepted or to return an error.
endif::GLSL[]


ifdef::ESSL[]
[[compatibility]]
== Compatibility

The {apiname} {apiversion} API is designed to work with GLSL ES v1.00,
GLSL ES 3.00, GLSL ES 3.10 and GLSL ES {minor}.
In general a shader written for versions prior to {apiname} {apiversion}
should work without modification in {apiname} {apiversion}.

When porting applications from an earlier to later version of the {slabbrev},
the following points should be noted:

  * Not all language constructs present in earlier versions of the language
    are available in later versions e.g. attribute and varying qualifiers
    are present in v1.00 but not v3.00.
    However, the functionality of GLSL ES {minor} is a super-set of
    GLSL ES 3.10.
  * Some features of later versions of the API require language features
    that are not present in earlier version of the language.
  * It is an error to link shaders if they are written in different versions
    of the language.
  * The {apiname} 2.0 and 3.0 APIs do not support shaders written in GLSL ES
    3.20.
  * Using GLSL ES 1.00 shaders within {apiname} 3.x may extend the resources
    available beyond the minima specified in GLSL ES 1.0.
    Shaders which make use of this will not necessarily run on an {apiname}
    2.0 implementation: Similarly for GLSL ES 3.00 shaders running within
    {apiname} 3.2.
  * Support of line continuation and support of UTF-8 characters within
    comments is optional in GLSL ES 1.00 when used with the {apiname} 2.0
    API.
    However, support is mandated for both of these when a GLSL ES 1.00
    shader is used with the {apiname} 3.x APIs.
endif::ESSL[]



// Copyright 2008-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0
// chapters/overview.adoc
[[overview-of-opengl-shading]]
= Overview of Shading
<<toc>>

The {slname} is actually several closely related languages.
These languages are used to create shaders for each of the programmable
processors contained in the API's processing pipeline.
Currently, these processors are the vertex, tessellation control,
tessellation evaluation, geometry, fragment, and compute processors.

ifdef::ESSL[]
Compilation units for these processors are referred to as _shaders_ and the
processors themselves are also referred to as _shader stages_.
Only one shader can be run on a processor at any one time; there is no
support for linking multiple compilation units together for a single shader
stage.
One or more shaders are linked together to form a single program and each
program contains shader _executables_ for one or more consecutive shader
stages.
endif::ESSL[]

Unless otherwise noted in this paper, a language feature applies to all
languages, and common usage will refer to these languages as a single
language.
The specific languages will be referred to by the name of the processor they
target: vertex, tessellation control, tessellation evaluation, geometry,
fragment, or compute.

Most API state is not tracked or made available to shaders.
Typically, user-defined variables will be used for communicating between
different stages of the API pipeline.
However, a small amount of state is still tracked and automatically made
available to shaders, and there are a few built-in variables for interfaces
between different stages of the API pipeline.


[[vertex-processor]]
== Vertex Processor

The _vertex processor_ is a programmable unit that operates on incoming
vertices and their associated data.
Compilation units written in the {slname} to run on this processor are called
_vertex shaders_.
ifdef::GLSL[]
When a set of vertex shaders are successfully compiled and linked, they
result in a _vertex shader executable_ that runs on the vertex processor.
endif::GLSL[]

The vertex processor operates on one vertex at a time.
It does not replace graphics operations that require knowledge of several
vertices at a time.


[[tessellation-control-processor]]
== Tessellation Control Processor

The _tessellation control processor_ is a programmable unit that operates on
a patch of incoming vertices and their associated data, emitting a new
output patch.
Compilation units written in the {slname} to run on this processor are called
tessellation control shaders.
ifdef::GLSL[]
When a set of tessellation control shaders are successfully compiled and
linked, they result in a _tessellation control shader executable_ that runs
on the tessellation control processor.
endif::GLSL[]

The tessellation control shader is invoked for each vertex of the output
patch.
Each invocation can read the attributes of any vertex in the input or output
patches, but can only write per-vertex attributes for the corresponding
output patch vertex.
The shader invocations collectively produce a set of per-patch attributes
for the output patch.

After all tessellation control shader invocations have completed, the output
vertices and per-patch attributes are assembled to form a patch to be used
by subsequent pipeline stages.

Tessellation control shader invocations run mostly independently, with
undefined relative execution order.
However, the built-in function *barrier*() can be used to control execution
order by synchronizing invocations, effectively dividing tessellation
control shader execution into a set of phases.
Tessellation control shaders will get undefined results if one invocation
reads from a per-vertex or per-patch attribute written by another invocation
at any point during the same phase, or if two invocations attempt to write
different values to the same per-patch output
ifdef::GLSL[32-bit component]
in a single phase.


[[tessellation-evaluation-processor]]
== Tessellation Evaluation Processor

The _tessellation evaluation processor_ is a programmable unit that
evaluates the position and other attributes of a vertex generated by the
tessellation primitive generator, using a patch of incoming vertices and
their associated data.
Compilation units written in the {slname} to run on this processor are called
tessellation evaluation shaders.
ifdef::GLSL[]
When a set of tessellation evaluation shaders are successfully compiled and
linked, they result in a _tessellation evaluation shader executable_ that
runs on the tessellation evaluation processor.
endif::GLSL[]

Each invocation of the tessellation evaluation executable computes the
position and attributes of a single vertex generated by the tessellation
primitive generator.
The executable can read the attributes of any vertex in the input patch,
plus the tessellation coordinate, which is the relative location of the
vertex in the primitive being tessellated.
The executable writes the position and other attributes of the vertex.


[[geometry-processor]]
== Geometry Processor

The _geometry processor_ is a programmable unit that operates on data for
incoming vertices for a primitive assembled after vertex processing and
outputs a sequence of vertices forming output primitives.
Compilation units written in the {slname} to run on this processor are called
_geometry shaders_.
ifdef::GLSL[]
When a set of geometry shaders are successfully compiled and linked, they
result in a _geometry shader executable_ that runs on the geometry
processor.
endif::GLSL[]

A single invocation of the geometry shader executable on the geometry
processor will operate on a declared input primitive with a fixed number of
vertices.
This single invocation can emit a variable number of vertices that are
assembled into primitives of a declared output primitive type and passed to
subsequent pipeline stages.


[[fragment-processor]]
== Fragment Processor

The _fragment processor_ is a programmable unit that operates on fragment
values and their associated data.
Compilation units written in the {slname} to run on this processor are called
_fragment shaders_.
ifdef::GLSL[]
When a set of fragment shaders are successfully compiled and linked, they
result in a _fragment shader executable_ that runs on the fragment
processor.
endif::GLSL[]

A fragment shader cannot change a fragment's (_x_, _y_) position.
Access to neighboring fragments is not allowed.
The values computed by the fragment shader are ultimately used to update
framebuffer memory or texture memory, depending on the current API
state and the API command that caused the fragments to be generated.


[[compute-processor]]

== Compute Processor

The _compute processor_ is a programmable unit that operates independently
from the other shader processors.
Compilation units written in the {slname} to run on this processor are called
_compute shaders_.
ifdef::GLSL[]
When a set of compute shaders are successfully compiled and linked, they
result in a _compute shader executable_ that runs on the compute processor.
endif::GLSL[]

A compute shader has access to many of the same resources as fragment and
other shader processors, such as textures, buffers, image variables, and
atomic counters.
It does not have fixed-function outputs.
It is not part of the graphics pipeline and its visible side effects are
through changes to images, storage buffers, and atomic counters.

A compute shader operates on a group of work items called a _workgroup_.
A workgroup is a collection of shader invocations that execute the same
code, potentially in parallel.
An invocation within a workgroup may share data with other members of the
same workgroup through shared variables and issue memory and control flow
barriers to synchronize with other members of the same workgroup.


// Copyright 2008-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0
// chapters/basics.adoc
[[basics]]
= Basics
<<toc>>


[[character-set]]
ifdef::GLSL[]
== Character Set and Phases of Compilation
endif::GLSL[]
ifdef::ESSL[]
== Character Set
endif::ESSL[]

The source character set used for the {slname} is Unicode in the UTF-8
encoding scheme.
ifdef::ESSL[]
Invalid UTF-8 characters are ignored.
During pre-processing, the following applies:

  * A byte with the value zero is always interpreted as the end of the
    string
  * Backslash ('\'), is used to indicate line continuation when immediately
    preceding a new-line.
  * White space consists of one or more of the following characters: the
    space character, horizontal tab, vertical tab, form feed,
    carriage-return, line-feed.
  * The number sign (*#*) is used for preprocessor directives
  * Macro names are restricted to:
  ** The letters *a-z*, *A-Z*, and the underscore (*_*).
  ** The numbers *0-9*, except for the first character of a macro name.
endif::ESSL[]

After preprocessing, only the following characters are allowed in the
resulting stream of {slabbrev} tokens:

  * The letters *a-z*, *A-Z*, and the underscore (*_*).
  * The numbers *0-9*.
  * The symbols period (*.*), plus (*+*), dash (*-*), slash (*/*), asterisk
    (***), percent (*%*), angled brackets (*<* and *>*), square brackets
    (*[* and *]*), parentheses (*(* and *)*), braces (*{* and *}*), caret
    (*^*), vertical bar (*|*), ampersand (*&*), tilde (*~*), equals (*=*),
    exclamation point (*!*), colon (*:*), semicolon (*;*), comma (*,*), and
    question mark (*?*).

ifdef::GLSL[]
A compile-time error will be given if any other character is used in a {slabbrev}
token.
endif::GLSL[]

There are no digraphs or trigraphs.
There are no escape sequences or other uses of the backslash beyond use as
the line-continuation character.

Lines are relevant for compiler diagnostic messages and the preprocessor.
They are terminated by carriage-return or line-feed.
If both are used together, it will count as only a single line termination.
For the remainder of this document, any of these combinations is simply
referred to as a new-line.
Lines may be of arbitrary length.

In general, the language's use of this character set is case sensitive.

There are no character or string data types, so no quoting characters are
included.

There is no end-of-file character.

ifdef::GLSL[]
More formally, compilation happens as if the following logical phases were
executed in order:

  . Source strings are concatenated to form a single input.
    All provided new-lines are retained.
  . Line numbering is noted, based on all present new-lines, and does not
    change when new-lines are later eliminated.
  . Wherever a backslash ('\') occurs immediately before a new-line, both
    are eliminated.
    (Note no white space is substituted, allowing a single token to span a
    new-line.) Any newly formed backslash followed by a new-line is not
    eliminated; only those pairs originally occurring after phase 1 are
    eliminated.
  . All comments are replaced with a single space.
    (Note that '//' style comments end before their terminating new-lines
    and white space is generally relevant to preprocessing.)
  . Preprocessing is done, resulting in a sequence of {slabbrev} tokens, formed
    from the character set stated above.
  . {slabbrev} processing is done on the sequence of {slabbrev} tokens.

Details that fully define source strings, comments, line numbering, new-line
elimination, and preprocessing are all discussed in upcoming sections.
Sections beyond those describe {slabbrev} processing.
endif::GLSL[]


[[source-strings]]
== Source Strings

The source for a single shader is an array of strings of characters from the
character set.
A single shader is made from the concatenation of these strings.
Each string can contain multiple lines, separated by new-lines.
No new-lines need be present in a string; a single line can be formed from
multiple strings.
No new-lines or other characters are inserted by the implementation when it
concatenates the strings to form a single shader.
ifdef::GLSL[]
Multiple shaders can be linked together to form a single program.
endif::GLSL[]

Diagnostic messages returned from compiling a shader must identify both the
line number within a string and which source string the message applies to.
Source strings are counted sequentially with the first string being string
0.
Line numbers are one more than the number of new-lines that have been
processed, including counting the new-lines that will be removed by the
line-continuation character (*+\+*).

Lines separated by the line-continuation character preceding a new-line are
concatenated together before either comment processing or preprocessing.
This means that no white space is substituted for the line-continuation
character.
That is, a single token could be formed by the concatenation by taking the
characters at the end of one line concatenating them with the characters at
the beginning of the next line.

[source,glsl]
----
float f\
oo;
// forms a single line equivalent to "float foo;"
// (assuming '\' is the last character before the new-line and "oo" are
// the first two characters of the next line)
----


ifdef::ESSL[]
[[version-declaration]]
== Version Declaration

Shaders must declare the version of the language they are written to.
The version is specified in the first line of a shader by a character
string:

[source,glsl]
----
#version number es
----

where _number_ must be a version of the language, following the same
convention as +__VERSION__+ above.
The directive "`*#version {version} es*`" is required in any shader that
uses version {minor} of the language.
Any _number_ representing a version of the language a compiler does not
support will cause an error to be generated.
Version 1.00 of the language does not require shaders to include this
directive, and shaders that do not include a *#version* directive will be
treated as targeting version 1.00.

Shaders declaring version {minor} of the shading language cannot be
linked with shaders declaring a previous version.

The *#version* directive must be present in the first line of a shader and
must be followed by a newline.
It may contain optional white-space as specified below but no other
characters are allowed.
The directive is only permitted in the first line of a shader.

Processing of the #version directive occurs before all other preprocessing,
including line concatenation and comment processing.

[role="bnf"]
--
_version-declaration_ : ::
    _whitespace~opt~_ POUND _whitespace~opt~_ VERSION _whitespace_ _number_
    _whitespace_ ES _whitespace~opt~_
--

Tokens:

{empty}:: POUND *#* +
          VERSION *version* +
          ES *es*
endif::ESSL[]


[[preprocessor]]
== Preprocessor

There is a preprocessor that processes the source strings as part of the
compilation process.
Except as noted below, it behaves as the C++ standard preprocessor (see
"`<<references,Normative References>>`").

The complete list of preprocessor directives is as follows.

{empty}:: # +
          #define +
          #undef +

{empty}:: #if +
          #ifdef +
          #ifndef +
          #else +
          #elif +
          #endif +

{empty}:: #error +
          #pragma +

{empty}:: #extension +
ifdef::GLSL[]
          #version +
endif::GLSL[]

{empty}:: #line

The following
ifdef::GLSL[operators are]
ifdef::ESSL[operator is]
also available:

{empty}:: defined +
ifdef::GLSL[]
          ##
endif::GLSL[]

ifdef::ESSL[]
Note that the version directive is not considered to be a preprocessor
directive and so is not listed here.
endif::ESSL[]

Each number sign (*#*) can be preceded in its line only by spaces or
horizontal tabs.
It may also be followed by spaces and horizontal tabs, preceding the
directive.
Each directive is terminated by a new-line.
Preprocessing does not change the number or relative location of new-lines
in a source string.
ifdef::GLSL[]
Preprocessing takes places after new-lines have been removed by the
line-continuation character.
endif::GLSL[]

The number sign (*#*) on a line by itself is ignored.
Any directive not listed above will cause {compiletimeerror}.

*#define* and *#undef* functionality are defined as is standard for C++
preprocessors for macro definitions both with and without macro parameters.

The following predefined macros are available:

{empty}:: +__LINE__+ +
          +__FILE__+ +
          +__VERSION__+ +
ifdef::ESSL[]
          +GL_ES+
endif::ESSL[]

ifdef::editing-notes[]
[NOTE]
.editing-note
====
(Jon) How to italicize the double-underscore markup?
====
endif::editing-notes[]

+__LINE__+ will substitute a decimal integer constant that is one more than
the number of preceding new-lines in the current source string.

+__FILE__+ will substitute a decimal integer constant that says which source
string number is currently being processed.

+__VERSION__+ will substitute a decimal integer reflecting the version
number of the {slname}.
The version of the shading language described in this document will have
+__VERSION__+ substitute the decimal integer {version}.

ifdef::ESSL[]
+GL_ES+ will be defined and set to 1.
This is not true for the non-ES OpenGL Shading Language, so it can be used
to do a compile time test to determine if a shader is compiling as an
GLSL ES shader.
endif::ESSL[]

By convention, all macro names containing two consecutive underscores (+__+)
are reserved for use by underlying software layers.
Defining
ifdef::GLSL[or undefining]
such a name in a shader does not itself result in an error, but may
result in unintended behaviors that stem from having multiple definitions of
the same name.
All macro names prefixed with "`GL_`" ("`GL`" followed by a single
underscore) are also reserved, and defining
ifdef::GLSL[or undefining]
such a name results in a compile-time error.

ifdef::ESSL[]
It is an error to undefine or to redefine a built-in (pre-defined) macro
name.
endif::ESSL[]

Implementations must support macro-name lengths of up to 1024 characters.
ifdef::GLSL[]
Implementations are allowed to generate an error for a macro name of length
greater than 1024 characters, but are also allowed to support lengths
greater than 1024.
endif::GLSL[]
ifdef::ESSL[It is an error to declare a name with a length greater than this.]

*#if*, *#ifdef*, *#ifndef*, *#else*, *#elif*, and *#endif* are defined to
operate as is standard for C++ preprocessors except for the following:

  * Expressions following *#if* and *#elif* are
ifdef::GLSL[]
    further restricted to
    expressions operating on literal integer constants, plus identifiers
    consumed by the *defined* operator.
endif::GLSL[]
ifdef::ESSL[]
    restricted to _pp-constant-expressions_ as defined below.
  * Undefined identifiers not consumed by the *defined* operator do not
    default to '0'.
    Use of such identifiers causes an error.
endif::ESSL[]
  * Character constants are not supported.

ifdef::GLSL[]
The operators available are as follows.
endif::GLSL[]
ifdef::ESSL[]
As in C++, a macro name defined with an empty replacement list does not
default to '0' when used in a preprocessor expression.

A _pp-constant-expression_ is an integral expression, evaluated at
compile-time during preprocessing and formed from literal integer constants
and the following operators:
endif::ESSL[]

[options="header"]
|====
| Precedence  | Operator class         | Operators  | Associativity
| 1 (highest) | parenthetical grouping | ( )        | NA
| 2           | unary                  | defined +
                                         + - ~ !    | Right to Left
| 3           | multiplicative         | * / %      | Left to Right
| 4           | additive               | + -        | Left to Right
| 5           | bit-wise shift         | << >>      | Left to Right
| 6           | relational             | < > \<= >= | Left to Right
| 7           | equality               | == !=      | Left to Right
| 8           | bit-wise and           | &          | Left to Right
| 9           | bit-wise exclusive or  | ^          | Left to Right
| 10          | bit-wise inclusive or  | \|         | Left to Right
| 11          | logical and            | &&         | Left to Right
| 12 (lowest) | logical inclusive or   | \|\|       | Left to Right
|====

The *defined* operator can be used in either of the following ways:

[source,glsl]
----
defined identifier
defined ( identifier )
----

ifdef::GLSL[]
Two tokens in a macro can be concatenated into one token using the token
pasting (*\##*) operator, as is standard for C++ preprocessors.
The result must be a valid single token, which will then be subject to macro
expansion.
That is, macro expansion happens only after token pasting.
There are no other number sign based operators (e.g. no *#* or *#@*), nor is
there a *sizeof* operator.

The semantics of applying operators to integer literals in the preprocessor
match those standard in the C++ preprocessor, not those in the {slname}.

Preprocessor expressions will be evaluated according to the behavior of the
host processor, not the processor targeted by the shader.
endif::GLSL[]
ifdef::ESSL[]
There are no number sign based operators (e.g. no *#* or *#@*), no *##*
operator, nor is there a *sizeof* operator.

The semantics of applying operators in the preprocessor match those standard
in the C++ preprocessor with the following exceptions:

  * The 2^nd^ operand in a logical and ('&&') operation is evaluated if and
    only if the 1^st^ operand evaluates to non-zero.
  * The 2^nd^ operand in a logical or ('||') operation is evaluated if and
    only if the 1^st^ operand evaluates to zero.
  * There is no boolean type and no boolean literals.
    A _true_ or _false_ result is returned as integer _one_ or _zero_
    respectively.
    Wherever a boolean operand is expected, any non-zero integer is
    interpreted as _true_ and a zero integer as _false_.

If an operand is not evaluated, the presence of undefined identifiers in the
operand will not cause an error.
endif::ESSL[]

*#error* will cause the implementation to put a compile-time diagnostic message
into the shader object's information log (see section 7.12 "`Shader, Program
and Program Pipeline Queries`" of the <<references,{apispec}>> for how to
access a shader object's information log).
The message will be the tokens following the *#error* directive, up to the
first new-line.
The implementation must treat the presence of a *#error* directive as a
compile-time error.

*#pragma* allows implementation-dependent compiler control.
Tokens following *#pragma* are not subject to preprocessor macro expansion.
If an implementation does not recognize the tokens following *#pragma*, then
it will ignore that pragma.
The following pragmas are defined as part of the language.

[source,glsl]
----
#pragma STDGL
----

The *STDGL* pragma is used to reserve pragmas for use by future revisions of
this language.
No implementation may use a pragma whose first token is *STDGL*.

[source,glsl]
----
#pragma optimize(on)
#pragma optimize(off)
----

can be used to turn off optimizations as an aid in developing and debugging
shaders.
It can only be used outside function definitions.
By default, optimization is turned on for all shaders.
The debug pragma

[source,glsl]
----
#pragma debug(on)
#pragma debug(off)
----

can be used to enable compiling and annotating a shader with debug
information, so that it can be used with a debugger.
It can only be used outside function definitions.
By default, debug is turned off.

ifdef::GLSL[]
Shaders should declare the version of the language they are written to.
The language version a shader is written to is specified by

[source,glsl]
----
#version number profile_opt
----

where _number_ must be a version of the language, following the same
convention as +__VERSION__+ above.
The directive "`*#version {version}*`" is required in any shader that
uses version {minor} of the language.
Any _number_ representing a version of the language a compiler does not
support will cause a compile-time error to be generated.
Version 1.10 of the language does not require shaders to include this
directive, and shaders that do not include a *#version* directive will be
treated as targeting version 1.10.
Shaders that specify *#version* 100 will be treated as targeting version
1.00 of the OpenGL ES Shading Language.
Shaders that specify *#version* 300 will be treated as targeting version
3.00 of the OpenGL ES Shading Language.
Shaders that specify *#version* 310 will be treated as targeting version
3.10 of the OpenGL ES Shading Language.

If the optional _profile_ argument is provided, it must be the name of an
{apiname} profile.
Currently, there are three choices:

[source,glsl]
----
core
compatibility
es
----

A _profile_ argument can only be used with version 150 or greater.
If no profile argument is provided and the version is 150 or greater, the
default is *core*.
If version 300 or 310 is specified, the profile argument is not optional and
must be *es*, or a compile-time error results.
The Language Specification for the *es* profile is specified in The OpenGL
ES Shading Language specification.

Shaders for the *core* or *compatibility* profiles that declare different
versions can be linked together.
However, *es* profile shaders cannot be linked with non-*es* profile shaders
or with *es* profile shaders of a different version, or a link-time error
will result.
When linking shaders of versions allowed by these rules, remaining link-time
errors will be given as per the linking rules in the {slabbrev} version
corresponding to the version of the context the shaders are linked under.
Shader compile-time errors must still be given strictly based on the version
declared (or defaulted to) within each shader.

Unless otherwise specified, this specification is documenting the core
profile, and everything specified for the core profile is also available in
the compatibility profile.
Features specified as belonging specifically to the compatibility profile
are not available in the core profile.
Compatibility-profile features are not available when generating SPIR-V.

There is a built-in macro definition for each profile the implementation
supports.
All implementations provide the following macro:

[source,glsl]
----
#define GL_core_profile 1
----

Implementations providing the *compatibility* profile provide the following
macro:

[source,glsl]
----
#define GL_compatibility_profile 1
----

Implementations providing the *es* profile provide the following macro:

[source,glsl]
----
#define GL_es_profile 1
----

The *#version* directive must occur in a shader before anything else, except
for comments and white space.
endif::GLSL[]
ifdef::ESSL[]
The scope as well as the effect of the optimize and debug pragmas is
implementation-dependent except that their use must not generate an error.
Incorrect use of predefined pragmas does not cause an error.
endif::ESSL[]

By default, compilers of this language must issue compile-time syntactic,
semantic, and grammatical errors for shaders that do not conform to this
specification.
Any extended behavior must first be enabled.
Directives to control the behavior of the compiler with respect to
extensions are declared with the *#extension* directive

[source,glsl]
----
#extension extension_name : behavior
#extension all : behavior
----

where _extension_name_ is the name of an extension.
Extension names are not documented in this specification.
The token *all* means the behavior applies to all extensions supported by
the compiler.
The _behavior_ can be one of the following:

[options="header"]
|====
| Behavior  | Effect
| *require* | Behave as specified by the extension _extension_name_. +
              Give a compile-time error on the *#extension* if the extension
              _extension_name_ is not supported, or if *all* is specified.
| *enable*  | Behave as specified by the extension _extension_name_. +
              Warn on the *#extension* if the extension _extension_name_ is
              not supported. +
              Give {compiletimeerror} on the *#extension* if *all* is
              specified.
| *warn*    | Behave as specified by the extension _extension_name_,
              except issue warnings on any detectable use of that extension,
              unless such use is supported by other enabled or required
              extensions. +
              If *all* is specified, then warn on all detectable uses of any
              extension used. +
              Warn on the *#extension* if the extension _extension_name_ is
              not supported.
| *disable* | Behave (including issuing errors and warnings) as if the
              extension _extension_name_ is not part of the language
              definition. +
              If *all* is specified, then behavior must revert back to that
              of the non-extended core version of the language being
              compiled to. +
              Warn on the *#extension* if the extension _extension_name_ is
              not supported.
|====

The *extension* directive is a simple, low-level mechanism to set the
behavior for each extension.
It does not define policies such as which combinations are appropriate,
those must be defined elsewhere.
Order of directives matters in setting the behavior for each extension:
Directives that occur later override those seen earlier.
The *all* variant sets the behavior for all extensions, overriding all
previously issued *extension* directives, but only for the _behaviors_
*warn* and *disable*.

The initial state of the compiler is as if the directive

[source,glsl]
----
#extension all : disable
----

was issued, telling the compiler that all error and warning reporting must
be done according to this specification, ignoring any extensions.

Each extension can define its allowed granularity of scope.
If nothing is said, the granularity is a shader (that is, a single
compilation unit), and the extension directives must occur before any
non-preprocessor tokens.
If necessary, the linker can enforce granularities larger than a single
compilation unit, in which case each involved shader will have to contain
the necessary extension directive.

Macro expansion is not done on lines containing *#extension* and *#version*
directives.

ifdef::ESSL[]
For each extension there is an associated macro.
The macro is always defined in an implementation that supports the
extension.
This allows the following construct to be used:

[source,glsl]
----
#ifdef OES_extension_name
    #extension OES_extension_name : enable
    // code that requires the extension
#else
    // alternative code
#endif
----
endif::ESSL[]

*#line* must have, after macro substitution, one of the following forms:

[source,glsl]
----
#line line
#line line source-string-number
----

where _line_ and _source-string-number_ are
ifdef::GLSL[constant integer expressions.]
ifdef::ESSL[_pp-constant-expressions_.]
If these constant expressions are not integer literals then behavior is undefined.
After processing this directive (including its new-line), the implementation
will behave as if it is compiling at line number _line_ and source string
number _source-string-number_.
Subsequent source strings will be numbered sequentially, until another
*#line* directive overrides that numbering.

[NOTE]
.Note
====
Some implementations have allowed constant expressions in #line directives and
some have not. Even where expressions are supported the grammar is ambiguous and so
results are implementation dependent. For example,
+ #line +2 +2               // Line number set to 4, or file to 2 and line to 2
====

ifdef::GLSL[]
When shaders are compiled for {apiname} SPIR-V, the following predefined
macro is available:

[source,glsl]
----
#define GL_SPIRV 100
----
endif::GLSL[]

When targeting Vulkan, the following predefined macro is available:

[source,glsl]
----
#define VULKAN 100
----

ifdef::ESSL[]
If during macro expansion a preprocessor directive is encountered, the
results are undefined; the compiler may or may not report an error in such
cases.
endif::ESSL[]


[[comments]]
== Comments

Comments are delimited by *+/*+* and *+*/+*, or by *//* and a new-line.
+//+ style comments include the initial +//+ marker and continue up to, but
not including, the terminating newline.
+/*...*/+ comments include both the start and end marker.
The begin comment delimiters (+/*+ or +//+) are not recognized as comment
delimiters inside of a comment, hence comments cannot be nested.
ifdef::ESSL[]
Comments are treated syntactically as a single space.
endif::ESSL[]

ifdef::GLSL[]
Inside comments, any byte values may be used, except a byte whose value is
0.
No errors will be given for the content of comments and no validation on the
content of comments need be done.

Removal of new-lines by the line-continuation character (*+\+*) logically
occurs before comments are processed.
That is, a single-line comment ending in the line-continuation character
(*+\+*) includes the next line in the comment.

[source,glsl]
----
// a single-line comment containing the next line \
a = b; // this is still in the first comment
----
endif::GLSL[]


[[tokens]]
== Tokens

The language, after preprocessing, is a sequence of tokens.
A token can be

[role="bnf"]
--
_token_ : ::
    _keyword_ +
    _identifier_ +
    _integer-constant_ +
    _floating-constant_ +
    _operator_ +
    *;* *{* *}*
--


[[keywords]]
== Keywords

The following are the keywords in the language and (after
preprocessing) can only be used as described in this specification,
or {compiletimeerror} results:

{empty}:: *const* *uniform* *buffer* *shared*
[.GLSL]##
          *attribute* *varying* ##
{empty}:: *coherent* *volatile* *restrict* *readonly* *writeonly*
{empty}:: *atomic_uint*
{empty}:: *layout*
{empty}:: *centroid* *flat* *smooth*
[.GLSL]##
          *noperspective* ##
{empty}:: *patch* *sample*
{empty}:: *invariant* *precise*
{empty}:: *break* *continue* *do* *for* *while* *switch* *case* *default*
{empty}:: *if* *else*
[.GLSL]##
          *subroutine* ##
{empty}:: *in* *out* *inout*
{empty}:: *int* *void* *bool* *true* *false* *float*
[.GLSL]##
          *double* ##
{empty}:: *discard* *return*
{empty}:: *vec2* *vec3* *vec4* *ivec2* *ivec3* *ivec4* *bvec2* *bvec3* *bvec4*
{empty}:: *uint* *uvec2* *uvec3* *uvec4*
[.GLSL]
=========
{empty}:: *dvec2* *dvec3* *dvec4*
=========
{empty}:: *mat2* *mat3* *mat4*
{empty}:: *mat2x2* *mat2x3* *mat2x4*
{empty}:: *mat3x2* *mat3x3* *mat3x4*
{empty}:: *mat4x2* *mat4x3* *mat4x4*
[.GLSL]
=========
{empty}:: *dmat2* *dmat3* *dmat4*
{empty}:: *dmat2x2* *dmat2x3* *dmat2x4*
{empty}:: *dmat3x2* *dmat3x3* *dmat3x4*
{empty}:: *dmat4x2* *dmat4x3* *dmat4x4*
=========
{empty}:: *lowp* *mediump* *highp* *precision*
[.GLSL]
=========
{empty}:: *sampler1D* *sampler1DShadow* *sampler1DArray* *sampler1DArrayShadow*
{empty}:: *isampler1D* *isampler1DArray* *usampler1D* *usampler1DArray*
=========
{empty}:: *sampler2D* *sampler2DShadow* *sampler2DArray* *sampler2DArrayShadow*
{empty}:: *isampler2D* *isampler2DArray* *usampler2D* *usampler2DArray*
[.GLSL]
=========
{empty}:: *sampler2DRect* *sampler2DRectShadow* *isampler2DRect* *usampler2DRect*
=========
{empty}:: *sampler2DMS* *isampler2DMS* *usampler2DMS*
{empty}:: *sampler2DMSArray* *isampler2DMSArray* *usampler2DMSArray*
{empty}:: *sampler3D* *isampler3D* *usampler3D*
{empty}:: *samplerCube* *samplerCubeShadow* *isamplerCube* *usamplerCube*
{empty}:: *samplerCubeArray* *samplerCubeArrayShadow*
{empty}:: *isamplerCubeArray* *usamplerCubeArray*
{empty}:: *samplerBuffer* *isamplerBuffer* *usamplerBuffer*
[.GLSL]
=========
{empty}:: *image1D* *iimage1D* *uimage1D*
{empty}:: *image1DArray* *iimage1DArray* *uimage1DArray*
=========
{empty}:: *image2D* *iimage2D* *uimage2D*
{empty}:: *image2DArray* *iimage2DArray* *uimage2DArray*
[.GLSL]
=========
{empty}:: *image2DRect* *iimage2DRect* *uimage2DRect*
{empty}:: *image2DMS* *iimage2DMS* *uimage2DMS*
{empty}:: *image2DMSArray* *iimage2DMSArray* *uimage2DMSArray*
=========
{empty}:: *image3D* *iimage3D* *uimage3D*
{empty}:: *imageCube* *iimageCube* *uimageCube*
{empty}:: *imageCubeArray* *iimageCubeArray* *uimageCubeArray*
{empty}:: *imageBuffer* *iimageBuffer* *uimageBuffer*
{empty}:: *struct*

In addition, when targeting Vulkan, the following keywords also exist:

[.GLSL]
=========
{empty}:: *texture1D* *texture1DArray*
{empty}:: *itexture1D* *itexture1DArray* *utexture1D* *utexture1DArray*
=========
{empty}:: *texture2D* *texture2DArray*
{empty}:: *itexture2D* *itexture2DArray* *utexture2D* *utexture2DArray*
[.GLSL]
=========
{empty}:: *texture2DRect* *itexture2DRect* *utexture2DRect*
=========
{empty}:: *texture2DMS* *itexture2DMS* *utexture2DMS*
{empty}:: *texture2DMSArray* *itexture2DMSArray* *utexture2DMSArray*
{empty}:: *texture3D* *itexture3D* *utexture3D*
{empty}:: *textureCube* *itextureCube* *utextureCube*
{empty}:: *textureCubeArray* *itextureCubeArray* *utextureCubeArray*
{empty}:: *textureBuffer* *itextureBuffer* *utextureBuffer*
{empty}:: *sampler* *samplerShadow*
{empty}:: *subpassInput* *isubpassInput* *usubpassInput*
{empty}:: *subpassInputMS* *isubpassInputMS* *usubpassInputMS*

The following are the keywords reserved for future use.
Using them will result in {compiletimeerror}:

[.ESSL]
=========
{empty}:: *attribute* *varying*
{empty}:: *noperspective*
{empty}:: *subroutine*
=========
{empty}:: *common* *partition* *active*
{empty}:: *asm*
{empty}:: *class* *union* *enum* *typedef* *template* *this*
{empty}:: *resource*
{empty}:: *goto*
{empty}:: *inline* *noinline* *public* *static* *extern* *external* *interface*
{empty}:: *long* *short* *half* *fixed* *unsigned* *superp*
[.ESSL]##
          *double* ##
{empty}:: *input* *output*
{empty}:: *hvec2* *hvec3* *hvec4* *fvec2* *fvec3* *fvec4*
[.ESSL]
=========
{empty}:: *dvec2*   *dvec3*   *dvec4*
{empty}:: *dmat2*   *dmat3*   *dmat4*
{empty}:: *dmat2x2* *dmat2x3* *dmat2x4*
{empty}:: *dmat3x2* *dmat3x3* *dmat3x4*
{empty}:: *dmat4x2* *dmat4x3* *dmat4x4*
=========
{empty}:: *filter*
{empty}:: *sizeof*    *cast*
{empty}:: *namespace* *using*
[.ESSL]
=========
{empty}:: *sampler1D*  *sampler1DShadow* *sampler1DArray* *sampler1DArrayShadow*
{empty}:: *isampler1D* *isampler1DArray* *usampler1D* *usampler1DArray*
{empty}:: *sampler2DRect* *sampler2DRectShadow* *isampler2DRect* *usampler2DRect*
=========
{empty}:: *sampler3DRect*
[.ESSL]
=========
{empty}:: *image1D* *iimage1D* *uimage1D*
{empty}:: *image1DArray* *iimage1DArray* *uimage1DArray*
{empty}:: *image2DRect* *iimage2DRect* *uimage2DRect*
{empty}:: *image2DMS* *iimage2DMS* *uimage2DMS*
{empty}:: *image2DMSArray* *iimage2DMSArray* *uimage2DMSArray*
=========

In addition, all identifiers containing two consecutive underscores (+__+)
are reserved for use by underlying software layers.
Defining such a name in a shader does not itself result in an error, but may
result in unintended behaviors that stem from having multiple definitions of
the same name.


[[identifiers]]
== Identifiers

Identifiers are used for variable names, function names, structure names,
and field selectors (field selectors select components of
`<<vector-components,vectors>>` and `<<matrix-components,matrices>>`,
similarly to structure members).
Identifiers have the form:

[role="bnf"]
--
_identifier_ : ::
    _nondigit_ +
    _identifier_ _nondigit_ +
    _identifier_ _digit_

_nondigit_ : one of ::
    *_* *a b c d e f g h i j k l m n o p q r s t u v w x y z* +
        *A B C D E F G H I J K L M N O P Q R S T U V W X Y Z*

_digit_ : one of ::
    *0 1 2 3 4 5 6 7 8 9*
--

Identifiers starting with "`gl_`" are reserved, and
in general, may not be declared in a shader;
this results in {compiletimeerror}.
However, as noted in the specification, there are some cases where
previously declared variables can be redeclared, and predeclared "`gl_`"
names are allowed to be redeclared in a shader only for these specific
purposes.

Implementations must support identifier lengths of up to 1024 characters.
[.GLSL]##Implementations are allowed to generate an error for an identifier 
of length greater than 1024 characters, but are also allowed to support lengths
greater than 1024.##
[.ESSL]##It is an error if the length exceeds this value. ##


[[definitions]]
== Definitions

Some language rules described below depend on the following definitions.


[[static-use]]
=== Static Use

A shader contains a _static use_ of a variable _x_ if, after preprocessing,
the shader contains a statement that would access any part of _x_,
whether or not flow of control will cause that statement to be executed.
Such a variable is referred to as being _statically used_. If the access is a
write then _x_ is further said to be _statically assigned_.


[[dynamically-uniform-expressions-and-uniform-control-flow]]
=== Dynamically Uniform Expressions and Uniform Control Flow

Some operations require an expression to be _dynamically uniform_, or that
it be located in _uniform control flow_.
These requirements are defined by the following set of definitions.

An _invocation_ is a single execution of _main()_ for a particular stage,
operating only on the amount of data explicitly exposed within that stage's
shaders.
(Any implicit operation on additional instances of data would comprise
additional invocations.) For example, in compute execution models, a single
invocation operates only on a single work item, or, in a vertex execution
model, a single invocation operates only on a single vertex.

An _invocation group_ is the complete set of invocations collectively
processing a particular compute workgroup or graphical operation, where the
scope of a "graphical operation" is implementation-dependent, but at least
as large as a single triangle or patch, and at most as large as a single
rendering command, as defined by the client API.

Within a single invocation, a single shader statement can be executed
multiple times, giving multiple _dynamic instances_ of that instruction.
This can happen when the instruction is executed in a loop, or in a function
called from multiple call sites, or combinations of multiple of these.
Different loop iterations and different dynamic function-call-site chains
yield different dynamic instances of such an instruction.
Dynamic instances are distinguished by their control-flow path within an
invocation, not by which invocation executed it.
That is, different invocations of _main()_ execute the same dynamic
instances of an instruction when they follow the same control-flow path.

An expression is _dynamically uniform_ for a dynamic instance consuming it
when its value is the same for all invocations (in the invocation group)
that execute that dynamic instance.

_Uniform control flow_ (or converged control flow) occurs when all
invocations in the invocation group execute the same control-flow path (and
hence the same sequence of dynamic instances of instructions).
Uniform control flow is the initial state at the entry into _main()_, and
lasts until a conditional branch takes different control paths for different
invocations (non-uniform or divergent control flow).
Such divergence can reconverge, with all the invocations once again
executing the same control-flow path, and this re-establishes the existence
of uniform control flow.
If control flow is uniform upon entry into a selection or loop, and all
invocations in the invocation group subsequently leave that selection or
loop, then control flow reconverges to be uniform.

For example:

[source,glsl]
----
main()
{
    float a = ...; // this is uniform control flow
    if (a < b) {   // this expression is true for some fragments, not all
        ...;       // non-uniform control flow
    } else {
        ...;       // non-uniform control flow
    }
    ...;           // uniform control flow again
}
----

Other examples of non-uniform control flow can occur within loops where some
invocations execute iterations that others do not, after conditional breaks,
continues, early returns, and after fragment discards, when the condition is
true for some fragments but not others.

Note that constant expressions are trivially dynamically uniform.
It follows that typical loop counters based on these are also dynamically
uniform.


ifdef::ESSL[]
[[logical-phases-of-compilation]]
== [.ESSL]##Logical Phases of Compilation##

The compilation units for the shader processors are processed separately
before optionally being linked together in the final stage of compilation.
The logical phases of compilation are:

  . Source strings are input as byte sequences.
    The value 'zero' is interpreted as a terminator.
  . Source strings are concatenated to form a single input.
    Zero bytes are discarded but all other values are retained.
  . Each string is interpreted according to the UTF-8 standard, with the
    exception that all invalid byte sequences are retained in their original
    form for subsequent processing.
  . Each {carriage-return, line-feed} and {line-feed, carriage return}
    sequence is replaced by a single newline.
    All remaining carriage-return and line-feed characters are then each
    replaced by a newline.
  . Line numbering for each character, which is equal to the number of
    preceding newlines plus one, is noted.
    Note this can only be subsequently changed by the #line directive and is
    not affected by the removal of newlines in phase 6 of compilation.
  . Wherever a backslash ('\') occurs immediately before a newline, both are
    deleted.
    Note that no whitespace is substituted, thereby allowing a single
    preprocessing token to span a newline.
    This operation is not recursive; any new {backslash newline} sequences
    generated are not removed.
  . All comments are replaced with a single space.
    All (non-zero) characters and invalid UTF-8 byte sequences are allowed
    within comments.
    '//' style comments include the initial '//' marker and continue up to,
    but not including, the terminating newline.
    '/*...*/' comments include both the start and end marker.
  . The source string is converted into a sequence of preprocessing tokens.
    These tokens include preprocessing numbers, identifiers and
    preprocessing operations.
    The line number associated with each token is copied from the line
    number of the first character of the token.
  . The preprocessor is run.
    Directives are executed and macro expansion is performed.
  . White space and newlines are discarded.
  . Preprocessing tokens are converted into tokens.
  . The syntax is analyzed according to the {slabbrev} grammar.
  . The result is checked according to the semantic rules of the language.
  . Optionally, the shaders are linked together to form one or more programs
    or separable programs.
    When a pair of shaders from consecutive stages are linked into the same
    program, any outputs and corresponding inputs not used in both shaders
    may be discarded.
  . The binary is generated.
endif::ESSL[]


// Copyright 2008-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0
// chapters/variables.adoc
[[variables-and-types]]
= Variables and Types
<<toc>>

All variables and functions must be declared before being used.
Variable and function names are identifiers.

There are no default types.
All variable and function declarations must have a declared type, and
optionally qualifiers.
A variable is declared by specifying its type followed by one or more names
separated by commas.
In many cases, a variable can be initialized as part of its declaration by
using the assignment operator (*=*).

User-defined types may be defined using *struct* to aggregate a list of
existing types into a single name.

The {slname} is type safe.
[.GLSL]##
There are some implicit conversions between types.
Exactly how and when this can occur is described in section
"`<<implicit-conversions,Implicit Conversions>>`" and as referenced by other
sections in this specification. ##
[.ESSL]##
There are no implicit conversions between types. ##


[[basic-types]]
== Basic Types

Definition::
A _basic type_ is a type defined by a keyword in the language.

The {slname} supports the following basic data types, grouped as follows.


*Transparent Types*

[cols="~,~"]
[options="header"]
|====
| Type      | Meaning
| *void*    | for functions that do not return a value
| *bool*    | a conditional type, taking on values of true or false
| *int*     | a signed integer
| *uint*    | an unsigned integer
| *float*   | a single-precision floating-point scalar
ifdef::GLSL[]
| *double*  | [.GLSL]## a double-precision floating-point scalar ##
endif::GLSL[]
| *vec2*    | two-component single-precision floating-point vector
| *vec3*    | three-component single-precision floating-point vector
| *vec4*    | four-component single-precision floating-point vector
ifdef::GLSL[]
| *dvec2*   | [.GLSL]## a two-component double-precision floating-point vector ##
| *dvec3*   | [.GLSL]## a three-component double-precision floating-point vector ##
| *dvec4*   | [.GLSL]## a four-component double-precision floating-point vector ##
endif::GLSL[]
| *bvec2*   | a two-component Boolean vector
| *bvec3*   | a three-component Boolean vector
| *bvec4*   | a four-component Boolean vector
| *ivec2*   | a two-component signed integer vector
| *ivec3*   | a three-component signed integer vector
| *ivec4*   | a four-component signed integer vector
| *uvec2*   | a two-component unsigned integer vector
| *uvec3*   | a three-component unsigned integer vector
| *uvec4*   | a four-component unsigned integer vector
| *mat2*    | a 2 {times} 2 single-precision floating-point matrix
| *mat3*    | a 3 {times} 3 single-precision floating-point matrix
| *mat4*    | a 4 {times} 4 single-precision floating-point matrix
| *mat2x2*  | same as a *mat2*
| *mat2x3*  | a single-precision floating-point matrix with 2 columns and 3 rows
| *mat2x4*  | a single-precision floating-point matrix with 2 columns and 4 rows
| *mat3x2*  | a single-precision floating-point matrix with 3 columns and 2 rows
| *mat3x3*  | same as a *mat3*
| *mat3x4*  | a single-precision floating-point matrix with 3 columns and 4 rows
| *mat4x2*  | a single-precision floating-point matrix with 4 columns and 2 rows
| *mat4x3*  | a single-precision floating-point matrix with 4 columns and 3 rows
| *mat4x4*  | same as a *mat4*
ifdef::GLSL[]
| *dmat2*   | [.GLSL]## a 2 {times} 2 double-precision floating-point matrix ##
| *dmat3*   | [.GLSL]## a 3 {times} 3 double-precision floating-point matrix ##
| *dmat4*   | [.GLSL]## a 4 {times} 4 double-precision floating-point matrix ##
| *dmat2x2* | [.GLSL]## same as a *dmat2* ##
| *dmat2x3* | [.GLSL]## a double-precision floating-point matrix with 2 columns and 3 rows ##
| *dmat2x4* | [.GLSL]## a double-precision floating-point matrix with 2 columns and 4 rows ##
| *dmat3x2* | [.GLSL]## a double-precision floating-point matrix with 3 columns and 2 rows ##
| *dmat3x3* | [.GLSL]## same as a *dmat3* ##
| *dmat3x4* | [.GLSL]## a double-precision floating-point matrix with 3 columns and 4 rows ##
| *dmat4x2* | [.GLSL]## a double-precision floating-point matrix with 4 columns and 2 rows ##
| *dmat4x3* | [.GLSL]## a double-precision floating-point matrix with 4 columns and 3 rows ##
| *dmat4x4* | [.GLSL]## same as a *dmat4* ##
endif::GLSL[]
|====

Note that where the following tables say "`accessing a texture`", the
*+sampler*+* opaque types access textures, and the *+image*+* opaque types
access images, of a specified type.


*Floating-Point Opaque Types*

[options="header"]
|====
| Type                      | Meaning
ifdef::GLSL[]
| [.GLSL]##*sampler1D*## +
  [.GLSL]##*texture1D*## +
  [.GLSL]##*image1D*##                 | a handle for accessing a 1D texture
| [.GLSL]##*sampler1DShadow*##         | a handle for accessing a 1D depth texture with comparison
| [.GLSL]##*sampler1DArray*## +
  [.GLSL]##*texture1DArray*## +
  [.GLSL]##*image1DArray*##            | a handle for accessing a 1D array texture
| [.GLSL]##*sampler1DArrayShadow*##    | a handle for accessing a 1D array depth texture with comparison
endif::GLSL[]
| *sampler2D* +
  *texture2D* +
  *image2D*                 | a handle for accessing a 2D texture
| *sampler2DShadow*         | a handle for accessing a 2D depth texture with comparison
| *sampler2DArray* +
  *texture2DArray* +
  *image2DArray*            | a handle for accessing a 2D array texture
| *sampler2DArrayShadow*    | a handle for accessing a 2D array depth texture with comparison
|
ifdef::GLSL[]
  [.GLSL]##*sampler2DMS*## +
  [.GLSL]##*texture2DMS*## +
  [.GLSL]##*image2DMS*## +
endif::GLSL[]
ifdef::ESSL[]
  [.ESSL]##*sampler2DMS*## +
  [.ESSL]##*texture2DMS*##
endif::ESSL[]
                            | a handle for accessing a 2D multisample texture
|
ifdef::GLSL[]
[.GLSL]##*sampler2DMSArray*## +
  [.GLSL]##*texture2DMSArray*## +
  [.GLSL]##*image2DMSArray*## +
endif::GLSL[]
ifdef::ESSL[]
  [.ESSL]##*sampler2DMSArray*##
endif::ESSL[]
                            | a handle for accessing a 2D multisample array texture
ifdef::GLSL[]
| [.GLSL]##*sampler2DRect*## +
  [.GLSL]##*texture2DRect*## +
  [.GLSL]##*image2DRect*##             | a handle for accessing a rectangle texture
| [.GLSL]##*sampler2DRectShadow*##     | a handle for accessing a rectangle texture with comparison
endif::GLSL[]
| *sampler3D* +
  *texture3D* +
  *image3D*                 | a handle for accessing a 3D texture
| *samplerCube* +
  *textureCube* +
  *imageCube*               | a handle for accessing a cube mapped texture
| *samplerCubeShadow*       | a handle for accessing a cube map depth texture with comparison
| *samplerCubeArray* +
  *textureCubeArray* +
  *imageCubeArray*          | a handle for accessing a cube map array texture
| *samplerCubeArrayShadow*  | a handle for accessing a cube map array depth texture with comparison
| *samplerBuffer* +
  *textureBuffer* +
  *imageBuffer*             | a handle for accessing a buffer texture
| *subpassInput*            | a handle for accessing a floating-point subpass input
| *subpassInputMS*          | a handle for accessing a multi-sampled floating-point subpass input
|====


*Signed Integer Opaque Types*

[options="header"]
|====
| Type                    | Meaning
ifdef::GLSL[]
| [.GLSL]##*isampler1D*## +
  [.GLSL]##*itexture1D*## +
  [.GLSL]##*iimage1D*##              | a handle for accessing an integer 1D texture
| [.GLSL]##*isampler1DArray*## +
  [.GLSL]##*itexture1DArray*## +
  [.GLSL]##*iimage1DArray*##         | a handle for accessing an integer 1D array texture
endif::GLSL[]
| *isampler2D* +
  *itexture2D* +
  *iimage2D*              | a handle for accessing an integer 2D texture
| *isampler2DArray* +
  *itexture2DArray* +
  *iimage2DArray*         | a handle for accessing an integer 2D array texture
|
ifdef::GLSL[]
  [.GLSL]##*isampler2DMS*## +
  [.GLSL]##*itexture2DMS*## +
  [.GLSL]##*iimage2DMS*## +
endif::GLSL[]
ifdef::ESSL[]
  [.ESSL]##*isampler2DMS*## +
  [.ESSL]##*itexture2DMS*##
endif::ESSL[]
                          | a handle for accessing an integer 2D multisample texture
|
ifdef::GLSL[]
  [.GLSL]##*isampler2DMSArray*## +
  [.GLSL]##*itexture2DMSArray*## +
  [.GLSL]##*iimage2DMSArray*##
endif::GLSL[]
ifdef::ESSL[]
  [.ESSL]##*isampler2DMSArray*## +
  [.ESSL]##*itexture2DMSArray*##
endif::ESSL[]
                          | a handle for accessing an integer 2D multisample array texture
ifdef::GLSL[]
| [.GLSL]##*isampler2DRect*## +
  [.GLSL]##*itexture2DRect*## +
  [.GLSL]##*iimage2DRect*##          | a handle for accessing an integer 2D rectangle texture
endif::GLSL[]
| *isampler3D* +
  *itexture3D* +
  *iimage3D*              | a handle for accessing an integer 3D texture
| *isamplerCube* +
  *itextureCube* +
  *iimageCube*            | a handle for accessing an integer cube mapped texture
| *isamplerCubeArray* +
  *itextureCubeArray* +
  *iimageCubeArray*       | a handle for accessing an integer cube map array texture
| *isamplerBuffer* +
  *itextureBuffer* +
  *iimageBuffer*          | a handle for accessing an integer buffer texture
| *isubpassInput*         | a handle for accessing an integer subpass input
| *isubpassInputMS*       | a handle for accessing a multi-sampled integer subpass input
|====


*Unsigned Integer Opaque Types*

[options="header"]
|====
| Type | Meaning
ifdef::GLSL[]
| [.GLSL]#*usampler1D*# +
  [.GLSL]#*utexture1D*# +
  [.GLSL]#*uimage1D*#
    | a handle for accessing an unsigned integer 1D texture
| [.GLSL]#*usampler1DArray*# +
  [.GLSL]#*utexture1DArray*# +
  [.GLSL]#*uimage1DArray*#
    | a handle for accessing an unsigned integer 1D array texture
endif::GLSL[]
| *usampler2D* +
  *utexture2D* +
  *uimage2D*
    | a handle for accessing an unsigned integer 2D texture
| *usampler2DArray* +
  *utexture2DArray* +
  *uimage2DArray*
    | a handle for accessing an unsigned integer 2D array texture
|
ifdef::GLSL[]
  [.GLSL]#*usampler2DMS*# +
  [.GLSL]#*utexture2DMS*# +
  [.GLSL]#*uimage2DMS*# +
endif::GLSL[]
ifdef::ESSL[]
  [.GLSL]#*usampler2DMS*# +
  [.GLSL]#*utexture2DMS*#
endif::ESSL[]
    | a handle for accessing an unsigned integer 2D multisample texture
|
ifdef::GLSL[]
  [.GLSL]#*usampler2DMSArray*# +
  [.GLSL]#*utexture2DMSArray*# +
  [.GLSL]#*uimage2DMSArray*# +
endif::GLSL[]
ifdef::ESSL[]
  [.ESSL]#*usampler2DMSArray*# +
  [.ESSL]#*utexture2DMSArray*#
endif::ESSL[]
    | a handle for accessing an unsigned integer 2D multisample array texture
ifdef::GLSL[]
| [.GLSL]#*usampler2DRect*# +
  [.GLSL]#*utexture2DRect*# +
  [.GLSL]#*uimage2DRect*#
    | a handle for accessing an unsigned integer rectangle texture
endif::GLSL[]
| *usampler3D* +
  *utexture3D* +
  *uimage3D*
    | a handle for accessing an unsigned integer 3D texture
| *usamplerCube* +
  *utextureCube* +
  *uimageCube*
    | a handle for accessing an unsigned integer cube mapped texture
| *usamplerCubeArray* +
  *utextureCubeArray* +
  *uimageCubeArray*
    | a handle for accessing an unsigned integer cube map array texture
| *usamplerBuffer* +
  *utextureBuffer* +
  *uimageBuffer*
    | a handle for accessing an unsigned integer buffer texture
| *atomic_uint*
    | a handle for accessing an unsigned integer atomic counter
| *usubpassInput*          | a handle for accessing an unsigned-integer subpass input
| *usubpassInputMS*        | a handle for accessing a multi-sampled unsigned-integer subpass input
|====

*Sampler Opaque Types*

[options="header"]
|====
| Type                    | Meaning
| *sampler*               | a handle for accessing state describing how to sample a texture
| *samplerShadow*         | a handle for accessing state describing how to sample a depth
                            texture with comparison
|====

In addition, a shader can aggregate these basic types using arrays and
structures to build more complex types.

There are no pointer types.

[.GLSL]##
In this specification, an _aggregate_ will mean a structure or array.
(Matrices and vectors are not by themselves aggregates.) Aggregates,
matrices, and vectors will collectively be referred to as _composites_.
##

[[void]]
=== Void

Functions that do not return a value must be declared as *void*.
There is no default function return type.
The keyword *void* cannot be used in any other declarations (except for
empty formal or actual parameter lists), or {compiletimeerror} results.


[[booleans]]
=== Booleans

Definition::
A _boolean type_ is any boolean scalar or vector type (*bool*, *bvec2*,
*bvec3*, *bvec4*)

To make conditional execution of code easier to express, the type *bool* is
supported.
There is no expectation that hardware directly supports variables of this
type.
It is a genuine Boolean type, holding only one of two values meaning either
true or false.
Two keywords *true* and *false* can be used as literal Boolean constants.
Booleans are declared and optionally initialized as in the follow example:

[source,glsl]
----
bool success;      // declare "success" to be a Boolean
bool done = false; // declare and initialize "done"
----

Expressions used for conditional jumps (*if*, *for*, *?:*, *while*,
*do*-*while*) must evaluate to the type *bool*.


[[integers]]
=== Integers

Definitions::
An _integral type_ is any signed or unsigned, scalar or vector integer type.
It excludes arrays and structures.

{empty}:: A _scalar integral type_ is a scalar signed or unsigned integer type:

{empty}:: A _vector integral type_ is a vector of signed or unsigned integers:

Signed and unsigned integer variables are fully supported.
In this document, the term _integer_ is meant to generally include both
signed and unsigned integers.

[.GLSL]#For OpenGL, unsigned integers have exactly 32 bits of precision.#
[.GLSL]#When targeting Vulkan, *highp*#
[.ESSL]#*highp*#
unsigned integers have exactly 32 bits of precision.

[.GLSL]#For OpenGL, signed integers use 32 bits, including a sign bit, in two's complement form.#
[.GLSL]#When targeting Vulkan, *highp*#
[.ESSL]#*highp*#
signed integers use 32 bits, including a sign bit, in two's complement form.

When targeting Vulkan, *mediump* and *lowp* integers are as defined by the
SPIR-V *RelaxedPrecision* decoration.
[.ESSL]##
Otherwise, *mediump* and *lowp* integers have implementation-defined numbers of bits.
See "`<<range-and-precision,Range and Precision>>`" for details.
##

[.ESSL]## For all precisions, addition, ##
[.GLSL]## Addition, ##
subtraction and multiplication resulting in overflow or
underflow will result in the low-order
[.GLSL]## 32 ##
[.ESSL]## n ##
bits of the correct result R, where
[.ESSL]## n is the size in bits of the integer and ##
R is computed with enough precision to avoid overflow or underflow.
Division resulting in overflow will result in an undefined value.

Integers are declared and optionally initialized with integer expressions,
as in the following example:

[source,glsl]
----
int i, j = 42; // default integer literal type is int
uint k = 3u;   // "u" establishes the type as uint
----

Literal integer constants can be expressed in decimal (base 10), octal (base
8), or hexadecimal (base 16) as follows.

[role="bnf"]
--
_integer-constant_ : ::
    _decimal-constant_ _integer-suffix~opt~_ +
    _octal-constant_ _integer-suffix~opt~_ +
    _hexadecimal-constant_ _integer-suffix~opt~_

_integer-suffix_ : one of ::
    *u* *U*

_decimal-constant_ : ::
    _nonzero-digit_ +
    _decimal-constant_ _digit_

_octal-constant_ : ::
    *0* +
    _octal-constant_ _octal-digit_

_hexadecimal-constant_ : ::
    *0x* _hexadecimal-digit_ +
    *0X* _hexadecimal-digit_ +
    _hexadecimal-constant_ _hexadecimal-digit_

_digit_ : ::
    *0* +
    _nonzero-digit_

_nonzero-digit_ : one of ::
    *1 2 3 4 5 6 7 8 9*

_octal-digit_ : one of ::
    *0 1 2 3 4 5 6 7*

_hexadecimal-digit_ : one of ::
    *0 1 2 3 4 5 6 7 8 9 +
    a b c d e f +
    A B C D E F*
--

No white space is allowed between the digits of an integer constant,
including after the leading *0* or after the leading *0x* or *0X* of a
constant, or before the suffix *u* or *U*.
[.GLSL]##
When tokenizing, the maximal token matching the above will be recognized
before a new token is started.
##
When the suffix *u* or *U* is present, the literal has type *uint*,
otherwise the type is *int*.
A leading unary minus sign (-) is interpreted as an arithmetic unary
negation, not as part of the constant.
Hence, literals themselves are always expressed with non-negative syntax,
though they could result in a negative value.

It is {compiletimeerror} to provide a literal integer whose bit pattern
cannot fit in 32 bits.
The bit pattern of the literal is always used unmodified.
So a signed literal whose bit pattern includes a set sign bit creates a
negative value.

For example,

[source,glsl]
----
1             // OK. Signed integer, value 1
1u            // OK. Unsigned integer, value 1
-1            // OK. Unary minus applied to signed integer.
              // result is a signed integer, value -1
-1u           // OK. Unary minus applies to unsigned integer.
              // Result is an unsigned integer, value 0xffffffff
0xA0000000    // OK. 32-bit signed hexadecimal
0xABcdEF00u   // OK. 32-bit unsigned hexadecimal
0xffffffff    // OK. Signed integer, value -1
0x80000000    // OK. Evaluates to -2147483648
0xffffffffu   // OK. Unsigned integer, value 0xffffffff
0xfffffffff   // Error: needs more than 32 bits
3000000000    // OK. A signed decimal literal taking 32 bits.
              // It evaluates to -1294967296
2147483648    // OK. Evaluates to -2147483648 (the literal set the sign bit)
5000000000    // Error: needs more than 32 bits
----


[[floats]]
=== Floats

[.GLSL]
*******
Single-precision and double-precision floating-point variables are available
for use in a variety of scalar calculations.
Generally, the term _floating-point_ will refer to both single- and
double-precision floating-point.
Floating-point variables are defined as in the following examples:

[source,glsl]
----
float a, b = 1.5;    // single-precision floating-point
double c, d = 2.0LF; // double-precision floating-point
----

As an input value to one of the processing units, a single-precision or
double-precision floating-point variable is expected to match the
corresponding IEEE 754 floating-point definition for precision and dynamic
range.
Floating-point variables within a shader are also encoded according to the
IEEE 754 specification for single-precision floating-point values
(logically, not necessarily physically).
*******

[.ESSL]
*******

Definition::
A _floating-point type_ is any floating-point scalar, vector or matrix type.
It excludes arrays and structures.

Floats are available for use in a variety of scalar calculations.
Floating-point variables are defined as in the following example:

[source,glsl]
----
float a, b = 1.5;
----

As an input value to one of the processing units, a floating-point variable
is expected to match the IEEE 754 single precision floating-point definition
for precision and dynamic range.
*highp* floating-point variables within a shader are encoded according to
the IEEE 754 specification for single-precision floating-point values
(logically, not necessarily physically).
*******

While encodings are logically IEEE 754, operations (addition,
multiplication, etc.) are not necessarily performed as required by IEEE 754.
See "`<<range-and-precision,Range and Precision>>`" for more details on
precision and usage of NaNs (Not a Number) and Infs (positive or negative
infinities).

Floating-point constants are defined as follows.

[role="bnf"]
--
_floating-constant_ : ::
    _fractional-constant_ _exponent-part~opt~_ _floating-suffix~opt~_ +
    _digit-sequence_ _exponent-part_ _floating-suffix~opt~_

_fractional-constant_ : ::
    _digit-sequence_ *.* _digit-sequence_ +
    _digit-sequence_ *.* +
    *.* _digit-sequence_

_exponent-part_ : ::
    *e* _sign~opt~_ _digit-sequence_ +
    *E* _sign~opt~_ _digit-sequence_

_sign_ : one of ::
    *+* *-*

_digit-sequence_ : ::
    _digit_ +
    _digit-sequence_ _digit_

_floating-suffix_ : one of ::
    *f* *F*
ifdef::GLSL[*lf* *LF*]
--

A decimal point (*.*) is not needed if the exponent part is present.
No white space may appear anywhere within a floating-point constant,
including before a suffix.
[.GLSL]##
When tokenizing, the maximal token matching the above will be recognized
before a new token is started.
When the suffix "lf" or "LF" is present, the literal has type *double*.
Otherwise, the literal has type *float*.
##
A leading unary minus sign (*-*) is interpreted as a unary operator and is
not part of the floating-point constant.

[.ESSL]##
There is no limit on the number of digits in any _digit-sequence_.
If the value of the floating-point number is too large (small) to be stored
as a single precision value, it is converted to positive (negative)
infinity.
A value with a magnitude too small to be represented as a mantissa and
exponent is converted to zero.
Implementations may also convert subnormal (denormalized) numbers to zero.
##


[[vectors]]
=== Vectors

The {slname} includes data types for generic 2-, 3-, and 4-component vectors
of floating-point values, integers, and Booleans.
Floating-point vector variables can be used to store colors, normals,
positions, texture coordinates, texture lookup results and the like.
Boolean vectors can be used for component-wise comparisons of numeric
vectors.
Some examples of vector declarations are:

[source,glsl]
----
vec2 texcoord1, texcoord2;
vec3 position;
vec4 myRGBA;
ivec2 textureLookup;
bvec3 less;
----

Initialization of vectors can be done with constructors.
See "`<<vector-and-matrix-constructors,Vector and Matrix Constructors>>`".


[[matrices]]
=== Matrices

The {slname} has built-in types for 2 {times} 2, 2 {times} 3, 2 {times} 4, 3
{times} 2, 3 {times} 3, 3 {times} 4, 4 {times} 2, 4 {times} 3, and 4 {times}
4 matrices of floating-point numbers.
[.GLSL]##
Matrix types beginning with "*mat*" have single-precision components while
matrix types beginning with "*dmat*" have double-precision components.
##
The first number in the type is the number of columns, the second is the
number of rows.
If there is only one number, the matrix is square.
Example matrix declarations:

[source,glsl]
----
mat2 mat2D;
mat3 optMatrix;
mat4 view, projection;
mat4x4 view; // an alternate way of declaring a mat4
mat3x2 m;    // a matrix with 3 columns and 2 rows
ifdef::GLSL[]
dmat4 highPrecisionMVP;
dmat2x4 dm;
endif::GLSL[]
----

Initialization of matrix values is done with constructors (described in
"`<<vector-and-matrix-constructors,Vector and Matrix Constructors>>`") in
column-major order.

[.ESSL]
*******
*mat2* is an alias for *mat2x2*, not a distinct type.
Similarly for *mat3* and *mat4.* The following is legal:

[source,glsl]
----
mat2 a;
mat2x2 b = a;
----
*******


[[opaque-types]]
=== Opaque Types

Definition::
An _opaque type_ is a type where the internal structure of the type is
hidden from the language.

The opaque types, as listed in the following sections, declare variables
that are effectively opaque handles to other objects.
These objects are accessed through built-in functions, not through direct
reading or writing of the declared variable.
They can only be declared as function parameters or in **uniform**-qualified
variables (see "`<<uniform-variables,Uniform Variables>>`").
The only opaque types that take memory qualifiers are the image types.
Except for array indexing, structure member selection, and parentheses,
opaque variables are not allowed to be operands in expressions; such use
results in a compile-time error.

When aggregated into arrays within a shader, opaque types can only be
indexed with a dynamically uniform integral expression (see "`Dynamically
Uniform Expressions`") unless otherwise noted; otherwise, results are
undefined.

Opaque variables cannot be treated as l-values; hence cannot be used as
*out* or *inout* function parameters, nor can they be assigned into.
Any such use results in a compile-time error.
However, they can be passed as *in* parameters with matching types and
memory qualifiers.
They cannot be declared with an initializer.

Because a single opaque type declaration effectively declares two objects,
the opaque handle itself and the object it is a handle to, there is room for
both a storage qualifier and a memory qualifier.
The storage qualifier will qualify the opaque handle, while the memory
qualifier will qualify the object it is a handle to.


[[samplers]]
==== Texture-Combined Samplers

Texture-combined sampler types (e.g. *sampler2D*) are the sampler types
described in the Basic Types tables as handles for accessing textures.
(They do not include *sampler* and *samplerShadow*.)
There are distinct texture-combined sampler types for each texture target,
and for each of float, integer, and unsigned integer data types.
Texture accesses are done through built-in texture functions (described in
"`<<texture-functions,Texture Functions>>`") and texture-combined samplers
are used to specify which texture to access and how it is to be filtered.

Texture-combined sampler types are opaque types,
declared and behaving as described above for opaque types.

[[images]]
==== Images

Image types are opaque types, declared and behaving as described above for
opaque types.
They can be further qualified with memory qualifiers.
[.GLSL]##When aggregated into arrays within a shader, images can only be 
indexed with a constant integral expression.##


Image variables are handles to [.ESSL]#one-#, two-, or three-dimensional images
corresponding to all or a portion of a single level of a texture image bound
to an image unit.
There are distinct image variable types for each texture target, and for
each of float, integer, and unsigned integer data types.
Image accesses should use an image type that matches the target of the
texture whose level is bound to the image unit, or for non-layered bindings
of 3D or array images should use the image type that matches the
dimensionality of the layer of the image (i.e., a layer of 3D, 2DArray,
Cube, or CubeArray should use 
[.ESSL]##*image2D*).##
[.GLSL]##*image2D*, a layer of 1DArray should use *image1D*, and a layer of 2
DMSArray should use *image2DMS*).##
If the image target type does not match the bound image in this manner, if
the data type does not match the bound image, or if the format layout
qualifier does not match the image unit format as described in section
[.GLSL]#8.25# [.ESSL]#8.22#
"`Texture Image Loads and Stores`" of the <<references,{apispec}>>, the
results of image accesses are undefined but cannot include program
termination.

Image variables are used in the image load, store, and atomic functions
described in "`<<image-functions,Image Functions>>`" to specify an image to
access.


[[atomic-counters]]
==== Atomic Counters

Atomic counter types (e.g. *atomic_uint*) are opaque handles to counters,
declared and behaving as described above for opaque types.
The variables they declare specify which counter to access when using the
built-in atomic counter functions as described in
"`<<atomic-counter-functions,Atomic Counter Functions>>`".
They are bound to buffers as described in
"`<<atomic-counter-layout-qualifiers,Atomic Counter Layout Qualifiers>>`".

Members of structures cannot be declared as atomic counter types.

[.ESSL]##
The default precision of all atomic types is *highp*.
It is an error to declare an atomic type with a different precision or to
specify the default precision for an atomic type to be *lowp* or *mediump*.
##

Atomic counter types are not available when targeting Vulkan.

==== Texture, *sampler*, and *samplerShadow* Types

Texture (e.g., *texture2D*), *sampler*, and *samplerShadow* types are opaque
types, declared and behaving as described above for opaque types.
These types are only available when targeting Vulkan.
Texture variables are handles to one-, two-, and three-dimensional textures,
cube maps, etc., as enumerated in the basic types tables.
There are distinct texture types for each texture target, and for each of
float, integer, and unsigned integer data types.
Textures can be combined with a variable of type *sampler* or *samplerShadow*
to create a texture-combined sampler type (e.g., sampler2D, or sampler2DShadow).
This is done with a constructor, e.g., `sampler2D(texture2D, sampler)`,
`sampler2DShadow(texture2D, sampler)`, `sampler2DShadow(texture2D, samplerShadow)`,
or `sampler2D(texture2D, samplerShadow)` and is described in more detail
in section 5.4 "Constructors".

==== Subpass Inputs

Subpass-input types are only available when targeting Vulkan.

Subpass-input types (e.g., *subpassInput*) are opaque types, declared
and behaving as described above for opaque types.

Subpass-input types are handles to two-dimensional single sampled or
multi-sampled images, with distinct types for each of float, integer,
and unsigned integer data types.

Subpass-input types are only available in fragment shaders.  It is
{compiletimeerror} to use them in any other stage.

[[structures]]
=== Structures

User-defined types can be created by aggregating other already defined types
into a structure using the *struct* keyword.
For example,

[source,glsl]
----
struct light {
    float intensity;
    vec3 position;
} lightVar;
----

In this example, _light_ becomes the name of the new type, and _lightVar_
becomes a variable of type _light_.
To declare variables of the new type, use its name (without the keyword
*struct*).

[source,glsl]
----
light lightVar2;
----

More formally, structures are declared as follows.
However, the definitive grammar is as given in
"`<<shading-language-grammar,Shading Language Grammar>>`".

[role="bnf"]
--
_struct-definition_ : ::
    _qualifier~opt~_ *struct* name~opt~_ *{* _member-list_ *}*
    _declarators~opt~_ *;*

_member-list_ : ::
    _member-declaration_ *;* +
    _member-declaration_ _member-list_ *;*

_member-declaration_ : ::
    _basic-type_ _declarators_ *;*
--

where _name_ becomes the user-defined type, and can be used to declare
variables to be of this new type.
The _name_ shares the same name space as other variables, types, and
functions.
All previously visible variables, types, constructors, or functions with
that name are hidden.
The optional _qualifier_ only applies to any _declarators_, and is not part
of the type being defined for _name_.

Structures must have at least one member declaration.
Bit fields are not supported.
Member types must be already defined (there are no forward references).

Member declarations may contain precision qualifiers, but use of any other
qualifier results in {compiletimeerror}. Where a member declaration does not
include a precision qualifier the member's precision is inferred as described
in <<default-precision-qualifiers, Default Precision Qualifiers>> at the point
of the struct type's declaration.

A compile-time error results if a member declaration contains an
initializer.
Member declarators can contain arrays.
Such arrays must have a size specified, and the size must be a constant
integral expression that's greater than zero (see
"`<<constant-expressions,Constant Expressions>>`").
Each level of structure has its own name space for names given in member
declarators; such names need only be unique within that name space.

Anonymous structures are not supported.
Embedded structure definitions are not supported.
[.GLSL]#These result in compile-time errors.#

[source,glsl]
----
struct S { float f; }; // Allowed: S is defined as a structure.

struct T {
    S;              // Error: anonymous structures disallowed
    struct { ... }; // Error: embedded structures disallowed
    S s;            // Allowed: nested structure with a name.
};
----

Structures can be initialized at declaration time using constructors, as
discussed in "`<<structure-constructors,Structure Constructors>>`".

Any restrictions on the usage of a type or qualifier also apply to any
structure that contains a member of that type or qualifier.
This also applies to structure members that are structures, recursively.

[.ESSL]
*******
Structures can contain variables of any type except:

* atomic_uint* (since there is no mechanism to specify the binding)
* types (since there is no mechanism to specify the format qualifier)
*******


[[arrays]]
=== Arrays

Variables of the same type can be aggregated into arrays by declaring a name
followed by brackets (*[ ]*) enclosing an optional size.
When present, the array size must be a constant integral expression (see
"`<<constant-expressions,Constant Expressions>>`") greater than zero.
The type of the size parameter can be a signed or unsigned integer and the
choice of type does not affect the type of the resulting array.
Arrays only have a single dimension (a single number within "`[ ]`"),
however, arrays of arrays can be declared.
Any type can be formed into an array.

There are 3 types of array objects:

  Explicitly Sized:: The number of elements in the array is explicitly given.
  Runtime Sized:: The number of elements is not given and the array is the
                  outermost dimension of the last declared member of a shader
                  storage block (see section "`<<interface-blocks,Interface
                  Blocks>>`"). The array size is inferred at run-time from the
                  size of the data store backing the shader storage block.
  Unsized:: The number of array elements is not given and the array
            is not runtime sized.

Unsized arrays may become explicitly sized following either an explicitly-sized
initializer or a redeclaration with an explicit size (Explicitly-sized and
runtime-sized arrays may not be redeclared).
It is a compile-time error to redeclare an array with a different underlying
member type.

[.GLSL]##
Note, however, unless noted otherwise, blocks cannot be redeclared; so an unsized
array member in a user-declared block cannot be sized by a block redeclaration.
##

It is {compiletimeerror} if, following any initializer, an array contains any type that
is or includes an unsized array.

[.ESSL]##
Unsized arrays are used for certain builtin variables but it is an error if a
user-declared array remains unsized following its initializer.
##

It is {compiletimeerror} if:

 * an unsized array is indexed with anything other than a constant integral expression.
 * an unsized array is declared as a formal parameter to a function.
 * an unsized array is declared as the return type of a function.
 * a runtime-sized or unsized array is passed as a function argument.
 * any array is indexed using a negative constant expression.
 * an explicitly sized array is indexed with a constant expression greater than
   or equal to the declared size.
 * an unsized array is redeclared with a size less than or equal to any
   constant index used earlier in the shader to index the array.

Undefined behavior results from indexing an array with a non-constant
expression that's greater than or equal to the array's size or less than 0.

[NOTE]
.Note
====
Some features outside the scope of GLSL, for example OpenGL or Vulkan's "Robust
Buffer Access" features, may further constrain what behaviors are valid here.
Typically these features will prevent out-of-bounds indexing causing program
termination and may determine which values must be returned.
====

[NOTE]
.Note
====
All arrays are inherently homogeneous; made of elements all having the same
type and size, with one exception.
An array of shader storage blocks whose last member is a runtime-sized array
allows the individual blocks to have different sizes and hence a different
number of elements in the trailing array.
====


Some examples of array declarations are:

[source,glsl]
----
float frequencies[3];
uniform vec4 lightPosition[4u];
light lights[];            // Unsized. Valid in GLSL, illegal in ESSL.
const int numLights = 2;
light lights[numLights];
vec4 a[3][2];

// a shader storage block, introduced in section 4.3.7 "Buffer Variables"
buffer b {
    float u[]; // an error, unless u gets statically sized by link time
    vec4 v[];  // okay, v will be sized dynamically, if not statically
} name[3];     // when the block is arrayed, all u will be the same size,
               // but not necessarily all v, if sized dynamically
----

An array type can be formed by specifying a non-array type
(<<type_specifier_nonarray>>) followed by an <<array_specifier>>.
Note that in this context the construct _type [size]_ does not always result in
an array of length _size_ of type _type_.
For example,

[source,glsl]
----
float[5]    // an array of size [5] of float
float[2][3] // an array of size [2] of array of size [3] of float,
            // not size [3] of float[2]
----

Such an array type can be used anywhere any other type can be used, including
as the return value from a function, as a constructor of an array and in
declarations.

[source,glsl]
----
// As a function return type
float[5] foo() { }
// As an array constructor
float[5](3.4, 4.2, 5.0, 5.2, 1.1)
// In declaring an unnamed parameter
void foo(float[5])
// In normal declarations
float[5] a;

// The following 3 declarations are equivalent:
vec4 a[3][2]; // size-3 array of size-2 array of vec4
vec4[2] a[3];
vec4[3][2] a;
----

If such an array type is unsized and used as a constructor then the size of the
array is inferred from the constructor arguments. For example,

[source,glsl]
----
float a[5] = float[5](3.4, 4.2, 5.0, 5.2, 1.1);
float a[5] = float[](3.4, 4.2, 5.0, 5.2, 1.1);  // Constructor also of type float[5]
----

It is {compiletimeerror} to assign either to or from a runtime-sized or unsized
array (rather than specific elements).

Note, this is a rare case that initializers and assignments appear to have
different semantics.

An initializer for an unsized array is valid and will size the array, but the
equivalent assigment is not valid.

For example,

[source,glsl]
----
float a[5];
float b[];
// An initializer sizes an array ...
float c[] = a;  // c is explicitly size 5
// ... but the equivalent assignment is not valid
float d[];
d = a;          // Error. Assignment to an unsized array
// It is never valid to assign from an unsized array
float e[] = b;  // Error. b is unsized so cannot be assigned
----

[.GLSL]
*******
Alternatively, the initializer-list syntax can be used to initialize an
array of arrays:

[source,glsl]
----
vec4 a[3][2] = { vec4[2](vec4(0.0), vec4(1.0)),
                 vec4[2](vec4(0.0), vec4(1.0)),
                 vec4[2](vec4(0.0), vec4(1.0)) };
----

For arrays of arrays, any unsized dimension is explicitly sized by the
initializer:

[source,glsl]
----
vec4 a[][] = { vec4[2](vec4(0.0), vec4(1.0)), // okay, size to a[3][2]
               vec4[2](vec4(0.0), vec4(1.0)),
               vec4[2](vec4(0.0), vec4(1.0)) };
----
*******


When in transparent memory (like in a uniform block), the layout is that the
inner-most (right-most in declaration) dimensions iterate faster than the
outer dimensions.

That is, for the above, the order in memory would be:

{empty}:: Low address : a[0][0] : a[0][1] : a[1][0] : a[1][1] : a[2][0] : a[2][1]
     : High address

[.ESSL]##
Any restrictions on the usage of a type also apply to arrays of that type.
This applies recursively.
##


==== The *length*() Method

The number of elements in an array can be obtained by using the *length*()
method:

[source,glsl]
----
float a[5];
a.length(); // returns 5

vec4 a[3][2];
a.length()    // returns 3
a[x].length() // returns 2
----

The return value has type *int*.

It is {compiletimeerror} to use the *length*() method on an unsized array.
The return value is a constant expression if and only if the array is
explicitly-sized.

When the *length*() method returns a compile-time constant, the expression the
*length*() method is applied to will be parsed and is subject to the normal
language rules but any arrays will not be dereferenced.
This means that the value returned is well-defined even if the indices are out
of bounds at runtime.
Note, however, that because indices which are constant expressions are still
checked, an error will still be generated for constant indexing out-of-bounds.

When the *length*() method returns a compile-time constant and the expression the
*length*() method is applied to contains any side effects (such as writes
to l-values within the expression, or function calls that themselves have side
effects), behavior is undefined.
A compile- or link-time error may be given by the implementation but this is
not required.

[source,glsl]
----
float a, b;
float[2](a=3.0, ++b).length(); // Behavior undefined. Illegal side effects

float c[5][3];
c[7].length(); // Error. Static indexing out of bounds.
c[i].length(); // Valid, returns 3 even if i < 0 or i >= 5 at runtime.

struct S {
    float a[3];
} s[5];
s[i+3].a.length(); // Valid. Returns 3 for all inputs i.
s[i++].a.length(); // Behavior undefined. Illegal side-effects.

buffer B {
    float x[3];
    float y[];
} b[5];
b[i++].x.length(); // Behaviour undefined. Illegal side-effects.
b[i++].y.length(); // Valid. i is incremented and b dereferenced. The runtime size
                   // of y is returned if 0 <= x < 5, behavior undefined if not.
----

The precision is determined using the same rules as for other cases where
there is no intrinsic precision.
See "`<<precision-qualifiers,Precision Qualifiers>>`".


// There is a gigantic block of GLSL/ESSL differences starting here
// and going down through the Storage Qualifiers section. Apparently
// there was a complete rewrite by one spec, probably ESSL, as virtually
// no language is shared

[[implicit-conversions]]
=== Implicit Conversions

[.GLSL]
*******
In some situations, an expression and its type will be implicitly converted
to a different type.
The following table shows all allowed implicit conversions:

[options="header"]
|====
| Type of expression | Can be implicitly converted to
| *int*              | *uint*
| *int* +
  *uint*             | *float*
| *int* +
  *uint* +
  *float*            | *double*
| *ivec2*            | *uvec2*
| *ivec3*            | *uvec3*
| *ivec4*            | *uvec4*
| *ivec2* +
  *uvec2*            | *vec2*
| *ivec3* +
  *uvec3*            | *vec3*
| *ivec4* +
  *uvec4*            | *vec4*
| *ivec2* +
  *uvec2* +
  *vec2*             | *dvec2*
| *ivec3* +
  *uvec3* +
  *vec3*             | *dvec3*
| *ivec4* +
  *uvec4* +
  *vec4*             | *dvec4*
| *mat2*             | *dmat2*
| *mat3*             | *dmat3*
| *mat4*             | *dmat4*
| *mat2x3*           | *dmat2x3*
| *mat2x4*           | *dmat2x4*
| *mat3x2*           | *dmat3x2*
| *mat3x4*           | *dmat3x4*
| *mat4x2*           | *dmat4x2*
| *mat4x3*           | *dmat4x3*
|====

There are no implicit array or structure conversions.
For example, an array of *int* cannot be implicitly converted to an array of
*float*.

When an implicit conversion is done, it is the same conversion that would be
done under explicit conversion, using a constructor.
The explicit conversions via constructors are described in
<<conversion-and-scalar-constructors, Conversion and Scalar Constructors>>.

When performing implicit conversion for binary operators, there may be
multiple data types to which the two operands can be converted.
For example, when adding an *int* value to a *uint* value, both values can
be implicitly converted to *uint*, *float*, and *double*.
In such cases, a floating-point type is chosen if either operand has a
floating-point type.
Otherwise, an unsigned integer type is chosen if either operand has an
unsigned integer type.
Otherwise, a signed integer type is chosen.
If operands can be implicitly converted to multiple data types deriving from
the same base data type, the type with the smallest component size is used.

The conversions in the table above are done only as indicated by other
sections of this specification.
*******

[[initializers]]
=== Initializers

[.GLSL]
*******
At declaration, an initial value for a variable may be provided, specified
as an equals (=) followed by an initializer.
The initializer is either an _assignment-expression_ or a list of
initializers enclosed in curly braces.
The grammar for the initializer is:

[role="bnf"]
--
_initializer_ : ::
    _assignment-expression_ +
    *{* _initializer-list_ *}* +
    *{* _initializer-list_ *,* *}*

_initializer-list_ : ::
    _initializer_ +
    _initializer-list_ , _initializer_
--

The _assignment-expression_ is a normal expression except that a comma (*,*)
outside parentheses is interpreted as the end of the initializer, not as the
sequence operator.
As explained in more detail below, this allows creation of nested
initializers: The variable type and its initializer must exactly match in
terms of nesting, number of components/elements/members present at each
level, and types of components/elements/members.
An _assignment-expression_ at global scope can include calls to user-defined
functions.

An _assignment-expression_ in an initializer must be either the same type as
the object it initializes or be a type that can be converted to the object's
type according to "`<<implicit-conversions,Implicit Conversions>>`".
Since these include constructors, a composite variable can be initialized by
either a constructor or an initializer list; and an element in an
initializer list can be a constructor.

If an initializer is a list of initializers enclosed in curly braces, the
variable being declared must be a vector, a matrix, an array, or a
structure.

[source,glsl]
----
int i = { 1 }; // illegal, i is not a composite
----

A list of initializers enclosed in a matching set of curly braces is applied
to one composite.
This may be the variable being declared or a composite contained in the
variable being declared.
Individual initializers from the initializer list are applied to the
elements/members of the composite, in order.

If the composite has a vector type, initializers from the list are applied
to the components of the vector, in order, starting with component 0.
The number of initializers must match the number of components.

If the composite has a matrix type, initializers from the list must be
vector initializers and are applied to the columns of the matrix, in order,
starting with column 0.
The number of initializers must match the number of columns.

If the composite has a structure type, initializers from the list are
applied to the members of the structure, in the order declared in the
structure, starting with the first member.
The number of initializers must match the number of members.

Applying these rules, the following matrix declarations are equivalent:

[source,glsl]
----
mat2x2 a = mat2(  vec2( 1.0, 0.0 ), vec2( 0.0, 1.0 ) );
mat2x2 b =      { vec2( 1.0, 0.0 ), vec2( 0.0, 1.0 ) };
mat2x2 c =      {     { 1.0, 0.0 },     { 0.0, 1.0 } };
----

All of the following declarations result in a compile-time error.

[source,glsl]
----
float a[2] = { 3.4, 4.2, 5.0 };         // illegal
vec2 b = { 1.0, 2.0, 3.0 };             // illegal
mat3x3 c = { vec3(0.0), vec3(1.0), vec3(2.0), vec3(3.0) }; // illegal
mat2x2 d = { 1.0, 0.0, 0.0, 1.0 };      // illegal, can't flatten nesting
struct {
    float a;
    int b;
} e = { 1.2, 2, 3 };                    // illegal
----

In all cases, the inner-most initializer (i.e., not a list of initializers
enclosed in curly braces) applied to an object must have the same type as
the object being initialized or be a type that can be converted to the
object's type according to "`<<implicit-conversions,Implicit
Conversions>>`".
In the latter case, an implicit conversion will be done on the initializer
before the assignment is done.

[source,glsl]
----
struct {
    float a;
    int b;
} e = { 1.2, 2 }; // legal, all types match
struct {
    float a;
    int b;
} e = { 1, 3 };   // legal, first initializer is converted
----

All of the following declarations result in a compile-time error.

[source,glsl]
----
int a = true;                         // illegal
vec4 b[2] = { vec4(0.0), 1.0 };       // illegal
mat4x2 c = { vec3(0.0), vec3(1.0) };  // illegal

struct S1 {
    vec4 a;
    vec4 b;
};

struct {
    float s;
    float t;
} d[] = { S1(vec4(0.0), vec4(1.1)) }; // illegal
----

If an initializer (of either form) is provided for an unsized array, the
size of the array is determined by the number of top-level (non-nested)
initializers within the initializer.
All of the following declarations create arrays explicitly sized with five
elements:

[source,glsl]
----
float a[] = float[](3.4, 4.2, 5.0, 5.2, 1.1);
float b[] = { 3.4, 4.2, 5.0, 5.2, 1.1 };
float c[] = a;                          // c is explicitly size 5
float d[5] = b;                         // means the same thing
----

It is a compile-time error to have too few or too many initializers in an
initializer list for the composite being initialized.
That is, all elements of an array, all members of a structure, all columns
of a matrix, and all components of a vector must have exactly one
initializer expression present, with no unconsumed initializers.
*******


[[scoping]]
== Scoping

[.GLSL]
*******
The scope of a variable is determined by where it is declared.
If it is declared outside all function definitions, it has global scope,
which starts from where it is declared and persists to the end of the shader
it is declared in.
If it is declared in a *while* test or a *for* statement, then it is scoped
to the end of the following sub-statement.
If it is declared in an *if* or *else* statement, it is scoped to the end of
that statement.
(See "`<<selection,Selection>>`" and "`<<iteration,Iteration>>`" for the
location of statements and sub-statements.) Otherwise, if it is declared as
a statement within a compound statement, it is scoped to the end of that
compound statement.
If it is declared as a parameter in a function definition, it is scoped
until the end of that function definition.
A function's parameter declarations and body together form a single scope
nested in the global scope.
The *if* statement's expression does not allow new variables to be declared,
hence does not form a new scope.

Within a declaration, the scope of a name starts immediately after the
initializer if present or immediately after the name being declared if not.
Several examples:

[source,glsl]
----
int x = 1;
{
    int x = 2, y = x; // y is initialized to 2
}

struct S
{
    int x;
};

{
    S S = S(0); // 'S' is only visible as a struct and constructor
    S;          // 'S' is now visible as a variable
}

int x = x; // Error if x has not been previously defined.
           // If the previous definition of x was in this
           // same scope, this causes a redeclaration error.

int f( /* nested scope begins here */ int k)
{
    int k = k + 3; // redeclaration error of the name k
    ...
}

int f(int k)
{
    {
        int k = k + 3; // 2nd k is parameter, initializing nested first k
        int m = k;     // use of new k, which is hiding the parameter
    }
}
----

For both *for* and *while* loops, the sub-statement itself does not
introduce a new scope for variable names, so the following has a
redeclaration compile-time error:

[source,glsl]
----
for ( /* nested scope begins here */ int i = 0; i < 10; i++) {
    int i; // redeclaration error
}
----

The body of a *do*-*while* loop introduces a new scope lasting only between
the *do* and *while* (not including the while test expression), whether or
not the body is simple or compound:

[source,glsl]
----
int i = 17;
do
    int i = 4;  // okay, in nested scope_
while (i == 0); // i is 17, scoped outside the do-while body
----

The statement following a *switch* (...) forms a nested scope.

All variable names, structure type names, and function names in a given
scope share the same name space.
Function names can be redeclared in the same scope, with the same or
different parameters, without error.
An implicitly-sized array can be redeclared in the same scope as an array of
the same base type.
Otherwise, within one compilation unit, a declared name cannot be redeclared
in the same scope; doing so results in a redeclaration compile-time error.
If a nested scope redeclares a name used in an outer scope, it hides all
existing uses of that name.
There is no way to access the hidden name or make it unhidden, without
exiting the scope that hid it.

The built-in functions are scoped in a scope outside the global scope that
users declare global variables in.
That is, a shader's global scope, available for user-defined functions and
global variables, is nested inside the scope containing the built-in
functions.
When a function name is redeclared in a nested scope, it hides all functions
declared with that name in the outer scope.
Function declarations (prototypes) cannot occur inside of functions; they
must be at global scope, or for the built-in functions, outside the global
scope, otherwise a compile-time error results.

Shared globals are global variables declared with the same name in
independently compiled units (shaders) within the same language (i.e., same
stage, e.g. vertex) that are linked together when making a single program.
(Globals forming the interface between two different shader languages are
discussed in other sections.) Shared globals share the same name space, and
must be declared with the same type.
They will share the same storage.

Shared global arrays must have the same base type and the same explicit
size.
An array implicitly sized in one shader can be explicitly sized by another
shader in the same stage.
If no shader in a stage has an explicit size for the array, the largest
implicit size (one more than the largest index used) in that stage is used.
There is no cross-stage array sizing.
If there is no static access to an implicitly sized array within the stage
declaring it, then the array is given a size of 1, which is relevant when
the array is declared within an interface block that is shared with other
stages or the application (other unused arrays might be eliminated by the
optimizer).

Shared global scalars must have exactly the same type name and type
definition.
Structures must have the same name, sequence of type names, and type
definitions, and member names to be considered the same type.
This rule applies recursively for nested or embedded types.
If a shared global has multiple initializers, the initializers must all be
constant expressions, and they must all have the same value.
Otherwise, a link-time error will result.
(A shared global having only one initializer does not require that
initializer to be a constant expression.)
*******



[[scoping]]
== Scoping

[.ESSL]
*******
The scope of a declaration determines where the declaration is visible.
{slabbrev} uses a system of statically nested scopes.
This allows names to be redefined within a shader.
*******

[[definition-of-terms]]
=== Definition of Terms

[.ESSL]
*******
The term _scope_ refers to a specified region of the program where names are
guaranteed to be visible.
For example, a _compound_statement_with_scope_ ('{' _statement_ _statement_
...
'}') defines a scope.

A _nested scope_ is a scope defined within an outer scope.

The terms '_same scope'_ and '_current scope_' are equivalent to the term
'_scope_' but used to emphasize that nested scopes are excluded.

The _scope of a declaration_ is the region or regions of the program where
that declaration is visible.

A _name space_ defines where names may be defined.
Within a single name space, a name has at most one entry, specifying it to
be one of: structure, variable, or function.

In general, each scope has an associated name space.
However, in certain cases e.g. for uniforms, multiple scopes share the same
name space.
In these cases, conflicting declarations are an error, even though the name
is only visible in the scopes where it is declared.
*******

[[types-of-scope]]
=== Types of Scope

[.ESSL]
*******
The scope of a variable is determined by where it is declared.
If it is declared outside all function definitions, it has global scope,
which starts from where it is declared and persists to the end of the shader
it is declared in.
If it is declared in a *while* test or a *for* statement, then it is scoped
to the end of the following sub-statement (specified as
_statement-no-new-scope_ in the grammar).
Otherwise, if it is declared as a statement within a compound statement, it
is scoped to the end of that compound statement.
If it is declared as a parameter in a function definition, it is scoped
until the end of that function definition.
A function's parameter declarations and body together form a single scope.

[source,glsl]
----
int f( /* nested scope begins here */ int k)
{
    int k = k + 3; // redeclaration error of the name k
    ...
}
int f(int k)
{
    {
       int k = k + 3; // 2nd k is parameter, initializing nested first k
       int m = k // use of new k, which is hiding the parameter
    }
}
----

For both for and while loops, the sub-statement itself does not introduce a
new scope for variable names, so the following has a redeclaration
compile-time error:

[source,glsl]
----
for ( /* nested scope begins here */ int i = 0; i < 10; i++)
{
    int i; // redeclaration error
}
----

The body of a *do*-*while* loop introduces a new scope lasting only between
the do and while (not including the while test expression), whether or not
the body is simple or compound:

[source,glsl]
----
int _i_ = 17;
do
    int i = 4; // okay, in nested scope
while (i == 0); // i is 17, scoped outside the do-while body
----

The statement following a *switch* (...) forms a nested scope.

Representing the if construct as:

*if* if-expression *then* if-statement *else* else-statement,

a variable declared in the if-statement is scoped to the end of the
if-statement.
A variable declared in the else-statement is scoped to the end of the
else-statement.
This applies both when these statements are simple statements and when they
are compound statements.
The if-expression does not allow new variables to be declared, hence does
not form a new scope.

Within a declaration, the scope of a name starts immediately after the
initializer if present or immediately after the name being declared if not.
Several examples:

[source,glsl]
----
int x = 1;
{
    int x = 2,/* 2nd x visible here */ y = x; // y is initialized to 2
    int z = z; // error if z not previously defined.
}
{
int x = x; // x is initialized to '1'
}
----

A structure name declaration is visible at the end of the _struct_specifier_
in which it was declared:

[source,glsl]
----
struct S
{
    int x;
};
{
    S S = S(0); // 'S' is only visible as a struct and constructor
    S; // 'S' is now visible as a variable
}
int x = x; // Error if x has not been previously defined.
----
*******

[[redeclaring-names]]
=== Redeclaring Names

[.ESSL]
*******
All variable names, structure type names, and function names in a given
scope share the same name space.
Function names can be redeclared in the same scope, with the same or
different parameters, without error.
Otherwise, within a shader, a declared name cannot be redeclared in the same
scope; doing so results in a redeclaration error.
If a nested scope redeclares a name used in an outer scope, it hides all
existing uses of that name.
There is no way to access the hidden name or make it unhidden, without
exiting the scope that hid it.

Names of built-in functions cannot be redeclared as functions.
Therefore overloading or redefining built-in functions is an error.

A _declaration_ is considered to be a statement that adds a name or
signature to the symbol table.
A _definition_ is a statement that fully defines that name or signature.
E.g.

[source,glsl]
----
int f();// declaration;
int f() {return 0;}// declaration and definition
int x; // declaration and definition
int a[4];// array declaration and definition
struct S {int x;};// structure declaration and definition
----

The determination of equivalence of two declarations depends on the type of
declaration.
For functions, the whole function signature must be considered (see
"`Function Definitions`").
For variables (including arrays) and structures only the names must match.

Within each scope, a name may be declared either as a variable declaration
_or_ as function declarations _or_ as a structure.

Examples of combinations that are allowed:

1.

--
[source,glsl]
----
void f(int) {...}
void f(float) {...}// function overloading allowed
----
--
2.

--
[source,glsl]
----
void f(int);// 1^st^ declaration (allowed)
void f(int);// repeated declaration (allowed)
void f(int) {...}// single definition (allowed)
----
--

Examples of combinations that are disallowed:

1.

--
[source,glsl]
----
void f(int) {...}
void f(int) {...}// Error: repeated definition
----
--
2.

--
[source,glsl]
----
void f(int);
struct f {int x;};// Error: type 'f' conflicts with function 'f'
----
--
3.

--
[source,glsl]
----
struct f {int x;};
int f;// Error: conflicts with the type 'f'
----
--
4.

--
[source,glsl]
----
int a[3];
int a[3];// Error: repeated array definition
----
--
5.

--
[source,glsl]
----
int x;
int x;// Error: repeated variable definition
----
--
*******


[[global-scope]]
=== Global Scope

[.ESSL]
*******
The built-in functions are scoped in the global scope users declare global
variables in.
That is, a shader's global scope, available for user-defined functions and
global variables, is the same as the scope containing the built-in
functions.
Function declarations (prototypes) cannot occur inside of functions; they
must be at global scope.
Hence it is not possible to hide a name with a function.
*******

[[shared-globals]]
=== Shared Globals

[.ESSL]
*******
Shared globals are variables that can be accessed by multiple compilation
units.
In {slabbrev} the only shared globals are uniforms.
Vertex shader outputs are not considered to be shared globals since they
must pass through the rasterization stage before they are used as input by
the fragment shader.

Shared globals share the same name space, and must be declared with the same
type and precision.
They will share the same storage.
Shared global arrays must have the same base type and the same explicit
size.
Scalars must have exactly the same precision, type name and type definition.
Structures must have the same name, sequence of type names, and type
definitions, and member names to be considered the same type.
This rule applies recursively for nested or embedded types.
*******


[[storage-qualifiers]]
== Storage Qualifiers

Variable declarations may have at most one storage qualifier specified in
front of the type.
These are summarized as

[options="header"]
|====
| Storage Qualifier | Meaning
| <none: default>   | local read/write memory, or an input parameter to a
                      function
| *const*           |
[.GLSL]##a variable whose value cannot be changed##
[.ESSL]##a compile-time constant##
| *in*              | linkage into a shader from a previous stage, variable
                      is copied in
| *out*             | linkage out of a shader to a subsequent stage,
                      variable is copied out
| *attribute*       | [.GLSL]##compatibility profile only and vertex language only;
                      same as *in* when in a vertex shader ##
| *uniform*         | value does not change across the primitive being
                      processed, uniforms form the linkage between a shader,
                      API, and the application
| *varying*         | [.GLSL]##compatibility profile only and vertex and fragment
                      languages only; same as *out* when in a vertex shader
                      and same as *in* when in a fragment shader ##
| *buffer*          | value is stored in a buffer object, and can be read or
                      written both by shader invocations and the API
| *shared*          | compute shader only; variable storage is shared across
                      all work items in a workgroup
|====

Some input and output qualified variables can be qualified with at most one
additional auxiliary storage qualifier:

[options="header"]
|====
| Auxiliary Storage Qualifier | Meaning
| *centroid*                  | centroid-based interpolation
| *sample*                    | per-sample interpolation
| *patch*                     | per-tessellation-patch attributes
|====

ifdef::GLSL[]
Not all combinations of qualification are allowed.
Auxiliary storage qualifiers can only be used with the *in* or *out* storage
qualifiers.
Additional qualifier rules are defined in upcoming sections.
endif::GLSL[]

Local variables can only use the *const* storage qualifier (or use no
storage qualifier).

Note that function parameters can use *const*, *in*, and *out* qualifiers,
but as _parameter qualifiers_.
Parameter qualifiers are discussed in
"`<<function-calling-conventions,Function Calling Conventions>>`".

Function return types and structure members do not use storage qualifiers.

ifdef::GLSL[]
Initializers in global declarations may only be used in declarations of
global variables with no storage qualifier, with a *const* qualifier, or
with a *uniform* qualifier.
endif::GLSL[]
ifdef::ESSL[]
Data types for communication from one run of a shader executable to its next
run (to communicate between fragments or between vertices) do not exist.
This would prevent parallel execution of the same shader executable on
multiple vertices or fragments.

In declarations of global variables with no storage qualifier or with a
const qualifier, any initializer must be a constant expression.
Declarations of global variables with other storage qualifiers may not
contain initializers.
endif::ESSL[]
Global variables without storage qualifiers that are not initialized in
their declaration or by the application will not be initialized,
but rather will enter _main()_ with undefined values.

ifdef::GLSL[]
When comparing an output from one shader stage to an input of a subsequent
shader stage, the input and output don't match if their auxiliary qualifiers
(or lack thereof) are not the same.
endif::GLSL[]


[[default-storage-qualifier]]
=== Default Storage Qualifier

If no qualifier is present on a global variable, then the variable has no
linkage to the application or shaders running on other pipeline stages.
For either global or local unqualified variables, the declaration will
appear to allocate memory associated with the processor it targets.
This variable will provide read/write access to this allocated memory.


[[constant-qualifier]]
=== Constant Qualifier

Named compile-time constants
ifdef::GLSL[or read-only variables]
can be declared using
the *const* qualifier.
ifdef::ESSL[]
Any variables qualified as constant are read-only variables for that shader.
Declaring variables as constant allows more descriptive shaders than using
hard-wired numerical constants.
endif::ESSL[]
The *const* qualifier can be used with any of the non-void transparent basic
data types, as well as with structures and arrays of these.
It is {compiletimeerror} to write to a *const* variable outside of its
declaration, so they must be initialized when declared.
For example,

ifdef::GLSL[]
[source,glsl]
----
const vec3 zAxis = vec3 (0.0, 0.0, 1.0);
const float ceiling = a + b; // a and b not necessarily constants
----
endif::GLSL[]
ifdef::ESSL[]
[source,glsl]
----
const vec3 zAxis = vec3 (0.0, 0.0, 1.0);
----
endif::ESSL[]

Structure members may not be qualified with *const*.
Structure variables can be declared as *const*, and initialized with a
structure
ifdef::GLSL[constructor or initializer.]
ifdef::ESSL[constructor.]

Initializers for *const* declarations
ifdef::GLSL[at global scope]
must be constant expressions, as defined in
"`<<constant-expressions,Constant Expressions>>`".


[[constant-expressions]]
=== Constant Expressions

SPIR-V specialization constants are expressed in {slabbrev} as *const* with the
layout qualifier *constant_id*, as described in
"`<<specialization-constant-qualifier, Specialization-Constant
Qualifier.>>`"

A _constant expression_ is one of

  * A literal value (e.g. *5* or *true*).
  * A variable declared with the *const* qualifier and an initializer, where
    the initializer is a constant expression.
    This includes both *const* declared with a specialization-constant
    layout qualifier, e.g. *layout*(*constant_id* = ...), and those declared
    without a specialization-constant layout qualifier.
  * Built-in variables qualified as *const*.
  * An expression formed by an operator on operands that are all constant
    expressions, including getting an element of a constant array, or a
    member of a constant structure, or components of a constant vector.
    However, the lowest precedence operators of the sequence operator (*,*)
    and the assignment operators (*=*, *+=*, *...*) are not included in the
    operators that can create a constant expression.
    Also, an array access with a specialization constant as an index does
    not result in a constant expression.
ifdef::GLSL[]
  * Valid use of the *length*() method on an explicitly sized object,
    whether or not the object itself is constant (implicitly sized or
    run-time sized arrays do not return a constant expression).
endif::GLSL[]
ifdef::ESSL[]
  * The *length*() method on a compile-time sized array, whether or not the
    object itself is constant.
endif::ESSL[]
  * A constructor whose arguments are all constant expressions.
ifdef::GLSL[]
  * For non-specialization constants only: The value returned by certain
    built-in function calls whose arguments are all constant expressions,
    including at least the list below.
    Any other built-in function that does not access memory (not the texture
    lookup functions, image access, atomic counter, etc.), that has a
    non-*void* return type, that has no *out* parameter, and is not a noise
    function might also be considered a constant.
    When a function is called with an argument that is a specialization
    constant, the result is not a constant expression.
  ** Angle and Trigonometric Functions
  *** *radians*
  *** *degrees*
  *** *sin*
  *** *cos*
  *** *asin*
  *** *acos*
  ** Exponential Functions
  *** *pow*
  *** *exp*
  *** *log*
  *** *exp2*
  *** *log2*
  *** *sqrt*
  *** *inversesqrt*
  ** Common Functions
  *** *abs*
  *** *sign*
  *** *floor*
  *** *trunc*
  *** *round*
  *** *ceil*
  *** *mod*
  *** *min*
  *** *max*
  *** *clamp*
  ** Geometric Functions
  *** *length*
  *** *dot*
  *** *normalize*
  * Function calls to user-defined functions (non-built-in functions) cannot
    be used to form constant expressions.
endif::GLSL[]
ifdef::ESSL[]
  * For non-specialization constants only:
    A built-in function call whose arguments are all constant expressions,
    with the exception of the texture lookup functions.
    This rule excludes functions with a *void* return or functions that have
    an *out* parameter.
    The built-in functions *dFdx*, *dFdy*, and *fwidth* must return 0 when
    evaluated inside an initializer with an argument that is a constant
    expression.

Function calls to user-defined functions (non-built-in functions) cannot be
used to form constant expressions.

Scalar, vector, matrix, array and structure variables are constant
expressions if qualified as *const*.
Opaque types cannot be constant expressions.
endif::ESSL[]

A _constant integral expression_ is a constant expression that evaluates to
a scalar signed or unsigned integer.

Constant expressions will be evaluated in an invariant way so as to create
the same value in multiple shaders when the same constant expressions appear
in those shaders.
See "`<<the-invariant-qualifier,The Invariant Qualifier>>`" for more details
on how to create invariant expressions and
"`<<precision-qualifiers,Precision Qualifiers>>`" for detail on how
expressions are evaluated.

Constant expressions respect the *precise* and *invariant* qualifiers but
will be always be evaluated in an invariant way, independent of the use of
such qualification, so as to create the same value in multiple shaders when
the same constant expressions appear in those shaders.
See "`<<the-invariant-qualifier,The Invariant Qualifier>>`" and
"`<<the-precise-qualifier,The Precise Qualifier>>`" for more details on how
to create invariant expressions.

Constant-expressions may be evaluated by a
host platform, and are therefore not required to compute the same value that
the same expression would evaluate to on the shader execution target.
However, the host must use the same or greater precision than the target
would use.
When the precision qualification cannot be determined, the expression is
evaluated at *highp*.
See "`<<default-precision-qualifiers, Default Precision Qualifiers>>`".

Specialization-constant expressions are never evaluated by the compiler
front end, but instead retain the expression's operations needed to evaluate
them later on the host.


[[input-variables]]
=== Input Variables

Shader input variables are declared with the *in* storage qualifier.
They form the input interface between previous stages of the API
pipeline and the declaring shader.
Input variables must be declared at global scope.
Values from the previous pipeline stage are copied into input variables at
the beginning of shader execution.
It is {compiletimeerror} to write to a variable declared as an input.

Only the input variables that are
ifdef::GLSL[statically]
ifdef::ESSL[actually]
read need to be written by the
previous stage; it is allowed to have superfluous declarations of input
variables.
ifdef::GLSL[]
This is shown in the following table.

// This is very tricky to specify with multiple column and row spans

[%autowidth,cols="5"]
|====
2.2+| Treatment of Mismatched Input Variables
                               3+| Consuming Shader (input variables)
                                 | No Declaration | Declared but no Static Use | Declared and Static Use
 .3+| Generating Shader (output variables)
    | No Declaration             | Allowed        | Allowed                    | Link-Time Error
    | Declared but no Static Use | Allowed        | Allowed                    | Allowed (values are undefined)
    | Declared and Static Use    | Allowed        | Allowed                    | Allowed (values are potentially undefined)
|====

Consumption errors are based on static use only.
Compilation may generate a warning, but not an error, for any dynamic use
the compiler can deduce that might cause consumption of undefined values.
endif::GLSL[]

See "`<<built-in-variables,Built-In Variables>>`" for a list of the built-in
input names.

Vertex shader input variables (or attributes) receive per-vertex data.
It is {compiletimeerror} to use auxiliary storage or interpolation qualifiers
on a vertex shader input.
The values copied in are established by the API or through the use
of the layout identifier *location*.

It is a compile-time error to declare a vertex shader input with, or that
contains, any of the following types:

  * A <<booleans, boolean type>>
  * An <<opaque-types, opaque type>>
ifdef::ESSL[]
  * An array
endif::ESSL[]
  * A structure

Example declarations in a vertex shader:

ifdef::GLSL[]
[source,glsl]
----
in vec4 position;
in vec3 normal;
in vec2 texCoord[4];
----
endif::GLSL[]
ifdef::ESSL[]
[source,glsl]
----
in vec4 position;
in vec3 normal;
----
endif::ESSL[]

It is expected that graphics hardware will have a small number of fixed
vector locations for passing vertex inputs.
Therefore, the {slname} defines each non-matrix input variable as taking up
one such vector location.
There is an implementation-dependent limit on the number of locations that
can be used, and if this is exceeded it will cause a link-time error.
(Declared input variables that are not statically used do not count against
this limit.) A scalar input counts the same amount against this limit as a
*vec4*, so applications may want to consider packing groups of four
unrelated float inputs together into a vector to better utilize the
capabilities of the underlying hardware.
A matrix input will use up multiple locations.
The number of locations used will equal the number of columns in the matrix.

Tessellation control, evaluation, and geometry shader input variables get
the per-vertex values written out by output variables of the same names in
the previous active shader stage.
For these inputs, *centroid* and interpolation qualifiers are allowed, but
have no effect.
Since tessellation control, tessellation evaluation, and geometry shaders
operate on a set of vertices, each input variable (or input block, see
<<interface-blocks,Interface Blocks>> below) needs to be declared as an array.
For example,

[source,glsl]
----
in float foo[]; // geometry shader input for vertex "out float foo"
----

Each element of such an array corresponds to one vertex of the primitive
being processed.
Each array can optionally have a size declared.
For geometry shaders, the array size will be set by, (or if provided must be
consistent with) the input *layout* declaration(s) establishing the type of
input primitive, as described later in "`<<input-layout-qualifiers,Input
Layout Qualifiers>>`".

Some inputs and outputs are _arrayed_, meaning that for an interface between
two shader stages either the input or output declaration requires an extra
level of array indexing for the declarations to match.
For example, with the interface between a vertex shader and a geometry
shader, vertex shader output variables and geometry shader input variables
of the same name must have matching types, except that the geometry shader
will have one more array dimension than the vertex shader, to allow for
vertex indexing.
If such an arrayed interface variable is not declared with the necessary
additional input or output array dimension, a link-time error will result.
Geometry shader inputs, tessellation control shader inputs and outputs, and
tessellation evaluation inputs all have an additional level of arrayness
relative to other shader inputs and outputs.
These inputs and outputs are known as _per-vertex-arrayed_ inputs and
outputs.
Component limits for arrayed interfaces (e.g.
_gl_MaxTessControlInputComponents_) are limits per vertex, not limits for
the entire interface.

For non-arrayed interfaces (meaning array dimensionally stays the same
between stages), it is a link-time error if the input variable is not
declared with the same type, including array dimensionality, as the matching
output variable.

The link-time type-matching rules apply to all declared input and output
variables, whether or not they are used.

Additionally, tessellation evaluation shaders support per-patch input
variables declared with the *patch* and *in* qualifiers.
Per-patch input variables are filled with the values of per-patch output
variables written by the tessellation control shader.
Per-patch inputs may be declared as one-dimensional arrays, but are not
indexed by vertex number.
Applying the *patch* qualifier to inputs can only be done in tessellation
evaluation shaders.
As with other input variables, per-patch inputs must be declared using the
same type and qualification as per-patch outputs from the previous
(tessellation control) shader stage.
It is a compile-time error to use *patch* with inputs in any other stage.

It is a compile-time error to declare a tessellation control, tessellation
evaluation or geometry shader input with, or that contains, any of the
following types:

  * A <<booleans, boolean type>>
  * An <<opaque-types, opaque type>>
ifdef::ESSL[]
  * A structure containing an array
  * A structure containing a structure
  * For per-vertex-arrayed variables:
  ** Per-vertex-arrayed arrays of arrays
  ** Per-vertex-arrayed arrays of structures
  * For non-per-vertex-arrayed variables:
  ** An array of arrays
  ** An array of structures
endif::ESSL[]

Fragment shader inputs get per-fragment values, typically interpolated from
a previous stage's outputs.
ifdef::GLSL[]
The auxiliary storage qualifiers *centroid* and *sample* can also be
applied, as well as the interpolation qualifiers *flat*, *noperspective*,
and *smooth.*
endif::GLSL[]

It is a compile-time error to declare a fragment shader input with, or that
contains, any of the following types:

  * A <<booleans, boolean type>>
  * An <<opaque-types, opaque type>>
ifdef::ESSL[]
  * An array of arrays
  * An array of structures
  * A structure containing an array
  * A structure containing a structure
endif::ESSL[]

Fragment shader inputs that are, or contain, integral
ifdef::GLSL[or double-precision floating-point]
types must be
qualified with the interpolation qualifier *flat*.

Fragment inputs are declared as in the following examples:

ifdef::GLSL[]
[source,glsl]
----
in vec3 normal;
centroid in vec2 TexCoord;
noperspective in float temperature;
flat in vec3 myColor;
noperspective centroid in vec2 myTexCoord;
----
endif::GLSL[]
ifdef::ESSL[]
[source,glsl]
----
in vec3 normal;
centroid in vec2 TexCoord;
flat in vec3 myColor;
----
endif::ESSL[]

The fragment shader inputs form an interface with the last active shader in
the vertex processing pipeline.
For this interface, the last active shader stage output variables and
fragment shader input variables of the same name must match in type and
qualification, with a few exceptions: The storage qualifiers must, of
course, differ (one is *in* and one is *out*).
Also,
ifdef::GLSL[interpolation qualification (e.g. *flat*) and]
auxiliary qualification (e.g. *centroid*) may differ.
ifdef::GLSL[]
These mismatches are allowed between any pair of stages.
endif::GLSL[]
When
ifdef::GLSL[interpolation or]
auxiliary qualifiers do not match, those provided in
the fragment shader supersede those provided in previous stages.
If any such qualifiers are completely missing in the fragment shaders, then
the default is used, rather than any qualifiers that may have been declared
in previous stages.
That is, what matters is what is declared in the fragment shaders, not what
is declared in shaders in previous stages.

When an interface between shader stages is formed using shaders from two
separate program objects, it is not possible to detect mismatches between
inputs and outputs when the programs are linked.
When there are mismatches between inputs and outputs on such interfaces,
ifdef::GLSL[]
the values passed across the interface will be partially or completely
undefined.
endif::GLSL[]
ifdef::ESSL[]
attempting to use the two programs in the same program pipeline will result
in program pipeline validation failures, as described in section 7.4.1
"`Shader Interface Matching`" of the <<references,{apispec}>>.
endif::ESSL[]

Shaders can ensure matches across such interfaces either by using input and
output layout qualifiers (sections "`<<input-layout-qualifiers,Input Layout
Qualifiers>>`" and "`<<output-layout-qualifiers,Output Layout
Qualifiers>>`") or by using identical input and output declarations of
blocks or variables.
Complete rules for interface matching are found in section 7.4.1 "`Shader
Interface Matching`" of the <<references,{apispec}>>.

Compute shaders do not permit user-defined input variables and do not form a
formal interface with any other shader stage.
See "`<<compute-shader-special-variables,Compute Shader Special
Variables>>`" for a description of built-in compute shader input variables.
All other input to a compute shader is retrieved explicitly through image
loads, texture fetches, loads from uniforms or uniform buffers, or other
user supplied code.
ifdef::GLSL[]
Redeclaration of built-in input variables in compute shaders is not
permitted.
endif::GLSL[]


[[uniform-variables]]
=== Uniform Variables

The *uniform* qualifier is used to declare global variables whose values are
the same across the entire primitive being processed.
ifdef::GLSL[]
All *uniform* variables are read-only and are initialized externally either
at link time or through the API.
The link-time initial value is either the value of the variable's
initializer, if present, or 0 if no initializer is present.
Opaque types cannot have initializers, or a compile-time error results.
endif::GLSL[]
ifdef::ESSL[]
All *uniform* variables are read-only.
Except for variables declared within a uniform block, all uniform variables
are initialized to 0 at link time and may be updated through the API.
endif::ESSL[]
When targeting Vulkan, it is {compiletimeerror} to declare *uniform*
variables outside a block.

Example declarations are:

ifdef::GLSL[]
[source,glsl]
----
uniform vec4 lightPosition;
uniform vec3 color = vec3(0.7, 0.7, 0.2); // value assigned at link time
----
endif::GLSL[]
ifdef::ESSL[]
[source,glsl]
----
uniform vec4 lightPosition;
----
endif::ESSL[]

The *uniform* qualifier can be used with any of the basic data types, or
when declaring a variable whose type is a structure, or an array of any of
these.

There is an implementation-dependent limit on the amount of storage for
uniforms that can be used for each type of shader and if this is exceeded it
will cause a compile-time or link-time error.
Uniform variables that are declared but not
ifdef::ESSL[statically]
used do not count against this limit.
The number of user-defined uniform variables and the number of built-in
uniform variables that are used within a shader are added together to
determine whether available uniform storage has been exceeded.

Uniforms in shaders all share a single global name space when linked into a
program or separable program.
Hence, the types,
ifdef::GLSL[initializers,]
ifdef::ESSL[precisions,]
and any location specifiers of all statically used uniform variables with the
same name must match across all shaders that are linked into a single program.
However it is not required to repeat the
ifdef::GLSL[initializer or]
location specifier in all the linked shaders.
While this single uniform name space is cross stage, a uniform variable
name's scope is per stage: If a uniform variable name is declared in one
stage (e.g. a vertex shader) but not in another (e.g. a fragment shader),
then that name is still available in the other stage for a different use.

ifdef::ESSL[]
A compile or link-time error is generated if any of the explicitly given or
compiler generated uniform locations is greater than the
implementation-defined maximum number of uniform locations minus one.

Unlike locations for inputs and outputs, uniform locations are logical
values, not register locations, and there is no concept of overlap.
For example:

[source,glsl]
----
layout(location = 2) uniform mat4 x;
layout(location = 3) uniform mat4 y; // No overlap with x
layout(location = 2) in mat4 x;
layout(location = 3) in mat4 y; // Error, locations conflict with x
----
endif::ESSL[]


[[output-variables]]
=== Output Variables

Shader output variables are declared with the *out* storage qualifier.
They form the output interface between the declaring shader and the
subsequent stages of the API pipeline.
Output variables must be declared at global scope.
During shader execution they will behave as normal unqualified global
variables.
Their values are copied out to the subsequent pipeline stage on shader exit.
Only output variables that are read by the subsequent pipeline stage need to
be written; it is allowed to have superfluous declarations of output
variables.

There is _not_ an *inout* storage qualifier for declaring a single variable
name as both input and output to a shader.
Also, a variable cannot be declared with both the *in* and the *out*
qualifiers, this will result in a compile-time or link-time error.
Output variables must be declared with different names than input variables.
However, nesting an input or output inside an interface block with an
instance name allows the same names with one referenced through a block
instance name.

Vertex, tessellation evaluation, and geometry output variables output
per-vertex data and are declared using the *out* storage qualifier.
Applying *patch* to an output can only be done in a tessellation control
shader.
It is a compile-time error to use *patch* on outputs in any other stage.

It is a compile-time error to declare a vertex, tessellation evaluation,
tessellation control, or geometry shader output with, or that contains, any
of the following types:

  * A <<booleans, boolean type>>
  * An <<opaque-types, opaque type>>
ifdef::ESSL[]
  * A structure containing an array
  * A structure containing a structure
  * For per-vertex-arrayed variables (applies to tessellation control,
    tessellation evaluation and geometry shaders):
  ** Per-vertex-arrayed arrays of arrays
  ** Per-vertex-arrayed arrays of structures
  * For non-per-vertex-arrayed variables:
  ** An array of arrays
  ** An array of structures

Vertex shader outputs may be qualified with the interpolation qualifier
*flat*^1^.

1::
    Unlike previous versions of the {slname}, there is no requirement for
    outputs containing integers to be qualified as *flat*, since the vertex
    shader may interface with the tessellation control shader.
    However, in all cases, the qualifier must match across interfaces.
endif::ESSL[]

Individual outputs are declared as in the following examples:

[source,glsl]
----
out vec3 normal;
centroid out vec2 TexCoord;
invariant centroid out vec4 Color;
flat out vec3 myColor;
sample out vec4 perSampleColor;
----

These can also appear in interface blocks, as described in
"`<<interface-blocks,Interface Blocks>>`".
Interface blocks allow simpler addition of arrays to the interface from
vertex to geometry shader.
They also allow a fragment shader to have the same input interface as a
geometry shader for a given vertex shader.

Tessellation control shader output variables are used to output
per-vertex and per-patch data.
Per-vertex output variables are arrayed (see _arrayed_ under
"`<<input-variables,Input Variables>>`") and declared using the *out*
qualifier without the *patch* qualifier.
Per-patch output variables are declared using the *patch* and *out*
qualifiers.

Since tessellation control shaders produce an arrayed primitive comprising
multiple vertices, each per-vertex output variable (or output block, see
<<interface-blocks,Interface Blocks>> below) needs to be declared as an array.
For example,

[source,glsl]
----
out float foo[]; // feeds next stage input "in float foo[]"
----

Each element of such an array corresponds to one vertex of the primitive
being produced.
Each array can optionally have a size declared.
The array size will be set by (or if provided must be consistent with) the
output layout declaration(s) establishing the number of vertices in the
output patch, as described later in
"`<<tessellation-control-outputs,Tessellation Control Outputs>>`".

Each tessellation control shader invocation has a corresponding output patch
vertex, and may assign values to per-vertex outputs only if they belong to
that corresponding vertex.
If a per-vertex output variable is used as an l-value, it is a compile-time
or link-time error if the expression indicating the vertex index is not the
identifier _gl_InvocationID_.

The order of execution of a tessellation control shader invocation relative
to the other invocations for the same input patch is undefined unless the
built-in function *barrier*() is used.
This provides some control over relative execution order.
When a shader invocation calls *barrier*(), its execution pauses until all
other invocations have reached the same point of execution.
Output variable assignments performed by any invocation executed prior to
calling *barrier*() will be visible to any other invocation after the call
to *barrier*() returns.

Because tessellation control shader invocations execute in undefined order
between barriers, the values of per-vertex or per-patch output variables
will sometimes be undefined.
Consider the beginning and end of shader execution and each call to
*barrier*() as synchronization points.
The value of an output variable will be undefined in any of the three
following cases:

  . At the beginning of execution.
  . At each synchronization point, unless
+
--
* the value was well-defined after the previous synchronization point and
  was not written by any invocation since, or
* the value was written by exactly one shader invocation since the previous
  synchronization point, or
* the value was written by multiple shader invocations since the previous
  synchronization point, and the last write performed by all such
  invocations wrote the same value.
--
  . When read by a shader invocation, if
+
--
* the value was undefined at the previous synchronization point and has not
  been written by the same shader invocation since, or
* the output variable is written to by any other shader invocation between
  the previous and next synchronization points, even if that assignment
  occurs in code following the read.
--

Fragment outputs output per-fragment data and are declared using the *out*
storage qualifier.
It is {compiletimeerror} to use auxiliary storage qualifiers or
interpolation qualifiers in a fragment shader output declaration.
It is a compile-time error to declare a fragment shader output with, or that
contains, any of the following types:

  * A <<booleans, boolean type>>
ifdef::GLSL[]
  * A double-precision scalar or vector (*double*, *dvec2*, *dvec3*,
    *dvec4*)
endif::GLSL[]
  * An <<opaque-types, opaque type>>
  * A matrix type
  * A structure
ifdef::ESSL[]
  * An array of arrays

Fragment shader outputs declared as arrays may only be indexed by a constant
integral expression.
endif::ESSL[]

Fragment outputs are declared as in the following examples:

[source,glsl]
----
out vec4 FragmentColor;
out uint Luminosity;
----

Compute shaders have no built-in output variables, do not support
user-defined output variables and do not form a formal interface with any
other shader stage.
All outputs from a compute shader take the form of the side effects such as
image stores and operations on atomic counters.


[[buffer-variables]]
=== Buffer Variables

The *buffer* qualifier is used to declare global variables whose values are
stored in the data store of a buffer object bound through the API.
Buffer variables can be read and written, with the underlying storage shared
among all active shader invocations.
Buffer variable memory reads and writes within a single shader invocation
are processed in order.
However, the order of reads and writes performed in one invocation relative
to those performed by another invocation is largely undefined.
Buffer variables may be qualified with memory qualifiers affecting how the
underlying memory is accessed, as described in "`<<memory-qualifiers,Memory
Qualifiers>>`".

The *buffer* qualifier can be used to declare interface blocks (see
"`<<interface-blocks,Interface Blocks>>`"), which are then referred to as
shader storage blocks.
It is a compile-time error to declare buffer variables outside a block.

[source,glsl]
----
// use buffer to create a buffer block (shader storage block)
buffer BufferName { // externally visible name of buffer
    int count;      // typed, shared memory...
    ...             // ...
    vec4 v[];       // last member may be an array that is not sized
                    // until after link time (dynamically sized)
} Name;             // name of block within the shader
----

There are implementation-dependent limits on the number of shader storage
blocks used for each type of shader, the combined number of shader storage
blocks used for a program, and the amount of storage required by each
individual shader storage block.
If any of these limits are exceeded, it will cause a compile-time or
link-time error.

If multiple shaders are linked together, then they will share a single
global buffer variable name space.
Hence, the types of all declared buffer variables with the same name must
match across all shaders that are linked into a single program.

ifdef::ESSL[]
Precision qualifiers for such variables need not match.
endif::ESSL[]

[[shared-variables]]
=== Shared Variables

The *shared* qualifier is used to declare global variables that have storage
shared between all work items in a compute shader workgroup.
Variables declared as *shared* may only be used in compute shaders (see
"`<<compute-processor,Compute Processor>>`").
Any other declaration of a *shared* variable is {compiletimeerror}.
Shared variables are implicitly coherent (see
"`<<memory-qualifiers,Memory Qualifiers>>`").

Variables declared as *shared* may not have initializers and their contents
are undefined at the beginning of shader execution.
Any data written to *shared* variables will be visible to other work items
(executing the same shader) within the same workgroup.

In the absence of synchronization, the order of reads and writes to the same
*shared* variable by different invocations of a shader is not defined.

In order to achieve ordering with respect to reads and writes to *shared*
variables, control flow barriers must be employed using the *barrier*() function
(see "`<<shader-invocation-control-functions,Shader Invocation Control
Functions>>`").

There is a limit to the total size of all variables declared as *shared* in a
single program.
This limit, expressed in units of basic machine units may be determined by
using the {apiname} API to query the value of
MAX_COMPUTE_SHARED_MEMORY_SIZE.


[[interface-blocks]]
=== Interface Blocks

Input, output, uniform, and buffer variable declarations can be grouped into
named interface blocks to provide coarser granularity backing than is
achievable with individual declarations.
They can have an optional instance name, used in the shader to reference
their members.
An output block of one programmable stage is backed by a corresponding input
block in the subsequent programmable stage.
A _uniform block_ is backed by the application with a buffer object.
A _buffer block_, also known as a _shader storage block_, is also backed
by the application with a buffer object.
It is a compile-time error to have an input block in a vertex shader or an
output block in a fragment shader.
These uses are reserved for future use.

An interface block declaration is defined in the grammar as follows:

[role="bnf"]
--
_interface-block_ : ::
    _type_qualifier_ _block-name_ *{* _member-list_ *}* _instance-name~opt~_ *;*

_block-name_ : ::
    _identifier_

_member-list_ : ::
    _member-declaration_ +
    _member-declaration_ _member-list_

_member-declaration_ : ::
    _layout-qualifier~opt~_ _qualifiers~opt~_ _type_ _declarators_ *;*

// Note: Qualifiers can be in any order.

_instance-name_ : ::
    _identifier_ +
    _identifier_ _array-specifier_ +
--

Each of the above elements is discussed below.

First, an example,

[source,glsl]
----
uniform Transform {
    mat4 ModelViewMatrix;
    mat4 ModelViewProjectionMatrix;
    uniform mat3 NormalMatrix;      // allowed restatement of qualifier
    float Deformation;
};
----

The above establishes a uniform block named "`Transform`" with four uniforms
grouped inside it.

_type-qualifier_ determines the interface of which the block will be a part
and, optionally, additional qualifiers that are applied to the block.
It is a compile-time error if it does not include one of the storage qualifiers
*in*, *out*, *uniform* or *buffer*.
It may optionally include <<layout-qualifiers,layout qualifiers>>, the
<<storage-qualifiers,auxiliary storage qualifier>> *patch*, and the
<<the-precise-qualifier,precise qualifier>>.
*buffer* blocks may additionally include <<memory-qualifiers>>.
It is a compile-time error to include any other qualifiers.

_member-list_ declares the variables that are to be grouped into the block.
Types and declarators are the same as for other input, output, uniform, and
buffer variable declarations outside blocks, with these exceptions:

  * Initializers are not allowed
  * Opaque types are not allowed
  * Structure definitions cannot be nested inside a block
ifdef::ESSL[]
  * Arrays of arrays of blocks are not allowed, except for the cases in the
    tessellation and geometry stages where the declaration is a
    per-vertex-array of arrays of blocks.
endif::ESSL[]

ifdef::GLSL[]
Any of these would result in a compile-time error.
endif::GLSL[]

If no optional qualifier is used in a member-declaration, the qualification
of the member includes all *in*, *out*, *patch*, *uniform*, or *buffer* as
determined by _interface-qualifier_.
If optional qualifiers are used, they can include interpolation qualifiers,
auxiliary storage qualifiers, precision qualifiers,
and storage qualifiers and they must declare
an input, output, or uniform member consistent with the interface qualifier
of the block: Input variables, output variables, uniform variables, and
*buffer* members can only be in *in* blocks, *out* blocks, *uniform* blocks,
and shader storage blocks, respectively.

Repeating the *in*, *out*, *patch*, *uniform*, or *buffer* interface
qualifier for a member's storage qualifier is optional.
For example,

[source,glsl]
----
in Material {
    smooth in vec4 Color1; // legal, input inside in block
    smooth vec4 Color2;    // legal, 'in' inherited from 'in Material'
    vec2 TexCoord;         // legal, TexCoord is an input
    uniform float Atten;   // illegal, mismatched storage qualifier
};
----

Members of *uniform* or *buffer* storage blocks are
always represented in memory as *highp*, regardless of any precision
qualifier associated with the declaration. When values are read from
or written to such variables they are converted to or from the declared
precision as described in
<<conversion-between-precisions,Conversion Between Precisions>>.
Operations on the values within the shader will take place using the declared
precision as normal.

A _shader interface_ is defined to be one of these:

  * All the uniform variables and uniform blocks declared in a program.
    This spans all compilation units linked together within one program.
  * All the *buffer* blocks declared in a program.
  * The boundary between adjacent programmable pipeline stages: This spans
    all the outputs declared in all compilation units of the first stage and
    all the inputs declared in all compilation units of the second stage.
    Note that for the purposes of this definition, the fragment shader and
    the preceding shader are considered to have a shared boundary even
    though in practice, all values passed to the fragment shader first pass
    through the rasterizer and interpolator.

The block name (_block-name_) is used to match within shader interfaces: an
output block of one pipeline stage will be matched to an input block with
the same name in the subsequent pipeline stage.
For uniform or shader storage blocks, the application uses the block name to
identify the block.
Block names have no other use within a shader beyond interface matching; it
is {compiletimeerror}
to use a block name at global scope for anything other than as a
block name (e.g. use of a block name for a global variable name or function
name is currently reserved).
It is a compile-time error to use the same block name for more than one
block declaration in the same shader interface (as defined above) within one
shader, even if the block contents are identical.

Matched block names within a shader interface (as defined above) must match
in terms of having the same number of declarations with the same sequence of
types and the same sequence of member names, as well as having matching
member-wise layout qualification
ifdef::GLSL[]
(see next section).
endif::GLSL[]
ifdef::ESSL[]
as defined in "`<<matching-of-qualifiers,Matching of Qualifiers>>`".
endif::ESSL[]
Matched uniform or shader storage block names (but not input or output block
names) must also either all be lacking an instance name or all having an
instance name, putting their members at the same scoping level.
When instance names are present on matched block names, it is allowed for
the instance names to differ; they need not match for the blocks to match.
Furthermore, if a matching block is declared as an array, then the array
sizes must also match (or follow array matching rules for the shader
interface between consecutive shader stages).
Any mismatch will generate a link-time error.
A block name is allowed to have different definitions in different shader
interfaces within the same shader, allowing, for example, an input block and
output block to have the same name.

If an instance name (_instance-name_) is not used, the names declared inside
the block are scoped at the global level and accessed as if they were
declared outside the block.
If an instance name (_instance-name_) is used, then it puts all the members
inside a scope within its own name space, accessed with the field selector
(*.*) operator (analogously to structures).
For example,

[source,glsl]
----
in Light {
    vec4 LightPos;
    vec3 LightColor;
};
in ColoredTexture {
    vec4 Color;
    vec2 TexCoord;
} Material;           // instance name
vec3 Color;           // different Color than Material.Color
vec4 LightPos;        // illegal, already defined
...
... = LightPos;       // accessing LightPos
... = Material.Color; // accessing Color in ColoredTexture block
----

Outside the shading language (i.e., in the API), members are similarly
identified except the block name is always used in place of the instance
name (API accesses are to shader interfaces, not to shaders).
If there is no instance name, then the API does not use the block name to
access a member, just the member name.

Within a shader interface, all declarations of the same global name must be
for the same object and must match in type and in whether they declare a
variable or member of a block with no instance name.
The API also needs this name to uniquely identify an object in the shader
interface.
It is a link-time error if any particular shader interface contains

  * two different blocks, each having no instance name, and each having a
    member of the same name, or
  * a variable outside a block, and a block with no instance name, where the
    variable has the same name as a member in the block.

[source,glsl]
----
out Vertex {
    vec4 Position;  // API transform/feedback will use "Vertex.Position"
    vec2 Texture;
} Coords;           // shader will use "Coords.Position"
out Vertex2 {
    vec4 Color;     // API will use "Color"
    float Color2;
};

// in same program as Vertex2 above:
out Vertex3 {
    float Intensity;
    vec4 Color;     // ERROR, name collision with Color in Vertex2
};
float Color2;       // ERROR, collides with Color2 in Vertex2
----

For blocks declared as arrays, the array index must also be included when
accessing members, as in this example

ifdef::GLSL[]
[source,glsl]
----
uniform Transform { // API uses "Transform[2]" to refer to instance 2
    mat4 ModelViewMatrix;
    mat4 ModelViewProjectionMatrix;
    vec4 a[]; // array will get implicitly sized
    float Deformation;
} transforms[4];
...
... = transforms[2].ModelViewMatrix; // shader access of instance 2
// API uses "Transform.ModelViewMatrix" to query an offset or other query
transforms[x].a.length(); // same length for 'a' for all x
Transform[x];             // illegal, must use 'transforms'
Transform.a.length();     // illegal, must use 'transforms'
...transforms[2].a[3]...  // if these are the only two dereferences of 'a',
...transforms[3].a[7]...  // then 'a' must be size 8, for all
transforms[x]
----
endif::GLSL[]
ifdef::ESSL[]
[source,glsl]
----
uniform Transform { // API uses "Transform[2]" to refer to instance 2
    mat4 ModelViewMatrix;
    mat4 ModelViewProjectionMatrix;
    float Deformation;
} transforms[4];
...
... = transforms[2].ModelViewMatrix; // shader access of instance 2
// API uses "Transform.ModelViewMatrix" to query an offset or other query
----
endif::ESSL[]

For uniform or shader storage blocks declared as an array, each individual
array element corresponds to a separate buffer object bind range, backing
one instance of the block.
As the array size indicates the number of buffer objects needed, uniform and
shader storage block array declarations must specify an array size.
ifdef::ESSL[]
All indices used to index a shader storage block array must be constant
integral expressions.
endif::ESSL[]
A uniform
ifdef::GLSL[or shader storage]
block array can only be indexed with a
dynamically uniform integral expression, otherwise results are undefined.

When using {apiname} API entry points to identify the name of an individual
block in an array of blocks, the name string may include an array index
(e.g. _Transform[2]_).
When using {apiname} API entry points to refer to offsets or other
characteristics of a block member, an array index must not be specified
(e.g. _Transform.ModelViewMatrix_).
ifdef::ESSL[]
See section 7.3.1 "`Program Interfaces`" of the <<references,{apispec}>> for
details.
endif::ESSL[]

Tessellation control, tessellation evaluation and geometry shader input
blocks must be declared as arrays and follow the array declaration and
linking rules for all shader inputs for the respective stages.
All other input and output block arrays must specify an array size.

There are implementation-dependent limits on the number of uniform blocks
and the number of shader storage blocks that can be used per stage.
If either limit is exceeded, it will cause a link-time error.


[[layout-qualifiers]]
== Layout Qualifiers

Layout qualifiers can appear in several forms of declaration.
They can appear as part of an interface block definition or block member, as
shown in the grammar in the previous section.
They can also appear with just an _interface-qualifier_ to establish layouts
of other declarations made with that qualifier:

[role="bnf"]
--
_layout-qualifier_ _interface-qualifier_ *;*
--

Or, they can appear with an individual variable declared with an interface
qualifier:

[role="bnf"]
--
_layout-qualifier_ _interface-qualifier_ _declaration_ *;*
--

Declarations of layouts can only be made at global scope or block members,
and only where indicated in the following subsections; their details are
specific to what the interface qualifier is, and are discussed individually.

The _layout-qualifier_ expands to:

[role="bnf"]
--
_layout-qualifier_ : ::
    *layout* *(* _layout-qualifier-id-list_ *)*

_layout-qualifier-id-list_ : ::
    _layout-qualifier-id_ +
    _layout-qualifier-id_ *,* _layout-qualifier-id-list_

_layout-qualifier-id_ : ::
    _layout-qualifier-name_ +
    _layout-qualifier-name_ *=* _layout-qualifier-value_ +
    *shared*
--

ifdef::GLSL[]
[role="bnf"]
--
_layout-qualifier-value_ : ::
    _integer-constant-expression_
--
endif::GLSL[]
ifdef::ESSL[]
[role="bnf"]
--
_layout-qualifier-value_ : ::
    _integer-constant_
--
endif::ESSL[]

The tokens used for _layout-qualifier-name_ are identifiers, not keywords,
however, the *shared* keyword is allowed as a _layout-qualifier-id_.
Generally, they can be listed in any order.
Order-dependent meanings exist only if explicitly called out below.
ifdef::GLSL[]
Similarly, these identifiers are not case sensitive, unless explicitly noted
otherwise.
endif::GLSL[]
ifdef::ESSL[]
As for other identifiers, they are case sensitive.
endif::ESSL[]

ifdef::GLSL[]
More than one layout qualifier may appear in a single declaration.
Additionally, the same _layout-qualifier-name_ can occur multiple times
within a layout qualifier or across multiple layout qualifiers in the same
declaration.
When the same _layout-qualifier-name_ occurs multiple times, in a single
declaration, the last occurrence overrides the former occurrence(s).
Further, if such a _layout-qualifier-name_ will affect subsequent
declarations or other observable behavior, it is only the last occurrence
that will have any effect, behaving as if the earlier occurrence(s) within
the declaration are not present.
This is also true for overriding _layout-qualifier-name_, where one
overrides the other (e.g. *row_major* vs.
*column_major*); only the last occurrence has any effect.
endif::GLSL[]
ifdef::ESSL[]
The set of allowed layout qualifiers depends on the shader, the interface
and the variable type as specified in the following sections.
For example, a sampler in the default uniform block in a fragment shader can
have *location* and *binding* layout qualifiers but no others.
Invalid use of layout qualifiers is an error.
endif::ESSL[]

ifdef::GLSL[]
_integer-constant-expression_ is defined in
"`<<constant-expressions, Constant Expressions>>`" as _constant integral
expression_, with it being a compile-time error for
_integer-constant-expression_ to be a specialization constant.
endif::GLSL[]

The following table summarizes the use of layout qualifiers.
It shows for each one what kinds of declarations it may be applied to.
These are all discussed in detail in the following sections.

[cols="<.^,^.^,^.^,^.^,^.^,<.^", options="header"]
|====
| Layout Qualifier        | Qualifier Only    | Individual Variable   | Block | Block Member  | Allowed Interfaces
| *shared* +
  *packed* +
  *std140* +
  *std430*                | X                 |                       | X     |            .5+| *uniform* / *buffer*
| *row_major* +
  *column_major*          | X                 |                       | X     | X
| *binding* =             |                   | opaque types only     | X     |
ifdef::GLSL[]
| *offset* =              |                   | atomic counters only  |       | X
| *align* =               |                   |                       | X     | X
endif::GLSL[]
ifdef::ESSL[]
| *offset* =              |                   | atomic counters only  |       | Vulkan only
| *align* =               |                   |                 | Vulkan only | Vulkan only
endif::ESSL[]
| *set* =                 |                   | opaque types only     | X     |               | *uniform* / *buffer* (Vulkan only)
| *push_constant*         |                   |                       | X     |               | *uniform* (Vulkan only)
| *input_attachment_index* = |                | subpass types only    |       |               | *uniform* (Vulkan only)
ifdef::GLSL[]
| *location* =            |                   | X                     |       |               | *uniform* / *buffer* and subroutine variables
| *location* =            |                   | X                     | X     | X^1^       .2+| all *in* / *out*, except for compute
| *component* =           |                   | X                     |       | X
| *index* =               |                   | X                     |       |               | fragment *out* and subroutine functions
endif::GLSL[]
ifdef::ESSL[]
| *location* =            |                   | X                     |       |               | *uniform* / *buffer*
| *location* =            |                   | X                     | X     | X^1^          | all *in* / *out*, except for compute
endif::ESSL[]
| *triangles* +
  *quads* +
  *isolines*              | X                 |                       |       |               | tessellation evaluation *in*
| *equal_spacing* +
  *fractional_even_spacing* +
  *fractional_odd_spacing*| X                 |                       |       |               | tessellation evaluation *in*
| *cw* +
  *ccw*                   | X                 |                       |       |               | tessellation evaluation *in*
| *point_mode*            | X                 |                       |       |               | tessellation evaluation *in*
| *points*                | X                 |                       |       |               | geometry *in*/*out*
| [ *points* ] +
  *lines* +
  *lines_adjacency* +
  *triangles* +
  *triangles_adjacency*   | X                 |                       |       |               | geometry *in*
| *invocations* =         | X                 |                       |       |               | geometry *in*
ifdef::GLSL[]
| *origin_upper_left* +
  *pixel_center_integer*  |                   | _gl_FragCoord_ only   |       |            .2+| fragment *in*
| *early_fragment_tests*  | X                 |                       |       |
endif::GLSL[]
ifdef::ESSL[]
| *early_fragment_tests*  | X                 |                       |       |               | fragment *in*
endif::ESSL[]
| *local_size_x* = +
  *local_size_y* = +
  *local_size_z* =        | X                 |                       |       |               | compute *in*
| *local_size_x_id* = +
  *local_size_y_id* = +
  *local_size_z_id* =     | X                 |                       |       |               | compute *in* (SPIR-V only)
ifdef::GLSL[]
| *xfb_buffer* = +
  *xfb_stride* =          | X                 | X                     | X     | X          .2+| vertex, tessellation, and geometry *out*
| *xfb_offset* =          |                   | X                     | X     | X
endif::GLSL[]
| *vertices* =            | X                 |                       |       |               | tessellation control *out*
| [ *points* ] +
  *line_strip* +
ifdef::GLSL[]
  *triangle_strip*        | X                 |                       |       |            .3+| geometry *out*
endif::GLSL[]

ifdef::ESSL[]
  *triangle_strip*        | X                 |                       |       |            .2+| geometry *out*
endif::ESSL[]
| *max_vertices* =        | X                 |                       |       |
ifdef::GLSL[]
| *stream* =              | X                 | X                     | X     | X
| *depth_any* +
  *depth_greater* +
  *depth_less* +
  *depth_unchanged*       |                   | _gl_FragDepth_ only   |       |               | fragment *out*
endif::GLSL[]

| *constant_id* =         |                   | scalar only           |       |               | *const* (SPIR-V only)
| *rgba32f* +
  *rgba16f* +
ifdef::GLSL[]
  *rg32f* +
  *rg16f* +
  *r11f_g11f_b10f* +
endif::GLSL[]
  *r32f* +
ifdef::GLSL[]
  *r16f* +
  *rgba16* +
  *rgb10_a2* +
endif::GLSL[]
  *rgba8* +
ifdef::GLSL[]
  *rg16* +
  *rg8* +
  *r16* +
  *r8* +
  *rgba16_snorm* +
endif::GLSL[]
  *rgba8_snorm* +
ifdef::GLSL[]
  *rg16_snorm* +
  *rg8_snorm* +
  *r16_snorm* +
  *r8_snorm* +
endif::GLSL[]
  *rgba32i* +
  *rgba16i* +
  *rgba8i* +
ifdef::GLSL[]
  *rg32i* +
  *rg16i* +
  *rg8i* +
endif::GLSL[]
  *r32i* +
ifdef::GLSL[]
  *r16i* +
  *r8i* +
endif::GLSL[]
  *rgba32ui* +
  *rgba16ui* +
ifdef::GLSL[*rgb10_a2ui* +]
  *rgba8ui* +
ifdef::GLSL[]
  *rg32ui* +
  *rg16ui* +
  *rg8ui* +
  *r32ui* +
  *r16ui* +
  *r8ui*                  |                   | image types only      |       |               | *uniform*
endif::GLSL[]
ifdef::ESSL[]
  *r32ui*                 |                   | image types only      |       |               | *uniform*
| *blend_support_multiply* +
  *blend_support_screen* +
  *blend_support_overlay* +
  *blend_support_darken* +
  *blend_support_lighten* +
  *blend_support_colordodge blend_support_colorburn* +
  *blend_support_hardlight* +
  *blend_support_softlight* +
  *blend_support_difference* +
  *blend_support_exclusion* +
  *blend_support_hsl_hue* +
  *blend_support_hsl_saturation* +
  *blend_support_hsl_color blend_support_hsl_luminosity* +
  *blend_support_all_equations*
                          | X                 |                       |       |               | fragment *out*
endif::ESSL[]
|====

1::
    Location qualifiers are not allowed for members of an arrayed block,
    except for per-vertex-arrays (see "`<<interface-blocks, Interface
    Blocks>>`").


[[input-layout-qualifiers]]
=== Input Layout Qualifiers

Layout qualifiers specific to a particular shader language are discussed in
separate sections below.

All shaders except compute shaders allow *location* layout qualifiers on
input variable declarations, input block declarations, and input block
member declarations.
ifdef::GLSL[]
Of these, variables and block members (but not blocks) additionally allow
the *component* layout qualifier.
endif::GLSL[]

ifdef::GLSL[]
[role="bnf"]
--
_layout-qualifier-id_ : ::
    *location* *=* _layout-qualifier-value_ +
    *component* *=* _layout-qualifier-value_
--
endif::GLSL[]
ifdef::ESSL[]
[role="bnf"]
--
_layout-qualifier-id_ : ::
    *location* *=* _layout-qualifier-value_
--
endif::ESSL[]

For example,

ifdef::GLSL[]
[source,glsl]
----
layout(location = 3) in vec4 normal;
const int start = 6;
layout(location = start + 2) in vec4 v;
----
endif::GLSL[]
ifdef::ESSL[]
[source,glsl]
----
layout(location = 3) in vec4 normal;
----
endif::ESSL[]

will establish that the shader input _normal_ is assigned to vector location
number
ifdef::ESSL[3.]
ifdef::GLSL[3 and _v_ is assigned location number 8.]
For vertex shader inputs, the location specifies the number of the
vertex attribute from which input values are taken.
For inputs of all other shader types, the location specifies a vector number
that can be used to match against outputs from a previous shader stage, even
if that shader is in a different program object.

The following language describes how many locations are consumed by a given
type.
However, geometry shader inputs, tessellation control shader inputs and
outputs, and tessellation evaluation inputs all have an additional level of
arrayness relative to other shader inputs and outputs.
This outer array level is removed from the type before considering how many
locations the type consumes.

ifdef::GLSL[]
Except when targeting Vulkan,
if a vertex shader input is any scalar or vector type, it will consume a
single location.
If a non-vertex shader input, or any stage input when targeting Vulkan,
is a scalar or vector type other than *dvec3*
or *dvec4*, it will consume a single location, while types *dvec3* or
*dvec4* will consume two consecutive locations.
endif::GLSL[]
ifdef::ESSL[]
If a shader input is any scalar or vector type, it will consume a single
location.
endif::ESSL[]

If the declared input (after potentially removing an outer array level as
just described above) is an array of size _n_ and each of the elements takes
_m_ locations, it will be assigned _m_ * _n_ consecutive locations starting
with the location specified.
For example,

[source,glsl]
----
layout(location = 6) in vec4 colors[3];
----

will establish that the shader input _colors_ is assigned to vector location
numbers 6, 7, and 8.

If the declared input is an _n_ {times} _m_
matrix, it will be assigned multiple locations starting with the location
specified.
The number of locations assigned for each matrix will be the same as for an
_n_-element array of _m_-component vectors.
For example,

[source,glsl]
----
layout(location = 9) in mat4 transforms[2];
----

will establish that shader input _transforms_ is assigned to vector
locations 9-16, with _transforms[0]_ being assigned to locations 9-12, and
_transforms[1]_ being assigned to locations 13-16.

If the declared input is a structure or block, its members will be assigned
consecutive locations in their order of declaration, with the first member
assigned the location provided in the layout qualifier.
For a structure, this process applies to the entire structure.
It is a compile-time error to use a *location* qualifier on a member of a
structure.
For a block, this process applies to the entire block, or until the first
member is reached that has a *location* layout qualifier.

When a block member is declared with a *location* qualifier, its location
comes from that qualifier; the member's *location* qualifier overrides the
block-level declaration.
Subsequent members are again assigned consecutive locations, based on the
newest location, until the next member declared with a *location* qualifier.
The values used for locations do not have to be declared in increasing
order.

If a block has no block-level *location* layout qualifier, it is required
that either all or none of its members have a *location* layout qualifier,
or a compile-time error results.
For some blocks declared as arrays, the *location* can only be applied at
the block level: When a block is declared as an array where additional
locations are needed for each member for each block array element, it is a
compile-time error to specify locations on the block members.
For _arrayed_ interfaces (those generally having an extra level of arrayness
due to interface expansion), the outer array is stripped before applying
this rule.

When generating SPIR-V, all *in* and *out* qualified user-declared (non
built-in) variables and blocks (or all their members) must have a
shader-specified *location*.
Otherwise, a compile-time error is generated.

The locations consumed by block and structure members are determined by
applying the rules above recursively as though the structure member were
declared as an input variable of the same type.
For example:

[source,glsl]
----
layout(location = 3) in struct S
{
    vec3 a;                      // gets location 3
    mat2 b;                      // gets locations 4 and 5
    vec4 c[2];                   // gets locations 6 and 7
    layout(location = 8) vec2 A; // ERROR, can't use on struct member
} s;
layout(location = 4) in block
{
    vec4 d;                      // gets location 4
    vec4 e;                      // gets location 5
    layout(location = 7) vec4 f; // gets location 7
    vec4 g;                      // gets location 8
    layout(location = 1) vec4 h; // gets location 1
    vec4 i;                      // gets location 2
    vec4 j;                      // gets location 3
    vec4 k;                      // ERROR, location 4 already used
};
----

The number of input locations available to a shader is limited.
For vertex shaders, the limit is the advertised number of vertex attributes.
For all other shaders, the limit is implementation-dependent and must be no
less than one fourth of the advertised maximum input component count.

A program will fail to link if any attached shader uses a location greater
than or equal to the number of supported locations, unless device-dependent
optimizations are able to make the program fit within available hardware
resources.

A program will fail to link if explicit location assignments leave the
linker unable to find space for other variables without explicit
assignments.

For the purposes of determining if a non-vertex input matches an output from
a previous shader stage, the *location* layout qualifier (if any) must
match.

If a vertex shader input variable with no location assigned in the shader
text has a location specified through the {apiname} API, the API-assigned
location will be used.
Otherwise, such variables will be assigned a location by the linker.
See section 11.1.1 "`Vertex Attributes`" of the <<references,{apispec}>> for
more details.
ifdef::GLSL[]
A link-time error will occur if an input variable is declared in multiple
shaders of the same language with conflicting locations.
endif::GLSL[]
ifdef::ESSL[]

It is an error if more than one input or element of a matrix input is bound
to the same location.
endif::ESSL[]

ifdef::GLSL[]
The *component* qualifier allows the location to be more finely specified
for scalars and vectors, down to the individual components within a location
that are consumed.
It is a compile-time error to use *component* without also specifying the
*location* qualifier (order does not matter).
The components within a location are 0, 1, 2, and 3.
A variable or block member starting at component _N_ will consume components
_N_, _N+1_, _N+2_, ...
up through its size.
It is a compile-time error if this sequence of components gets larger than
3.
A scalar *double* will consume two of these components, and a *dvec2* will
consume all four components available within a location.
A *dvec3* or *dvec4* can only be declared without specifying a *component*.
A *dvec3* will consume all four components of the first location and
components 0 and 1 of the second location.
This leaves components 2 and 3 available for other component-qualified
declarations.

For example:

[source,glsl]
----
// a consumes components 2 and 3 of location 4
layout(location = 4, component = 2) in vec2 a;

// b consumes component 1 of location 4
layout(location = 4, component = 1) in float b;

// ERROR: c overflows component 3
layout(location = 3, component = 2) in vec3 c;

// d consumes components 2 and 3 of location 5
layout(location = 5, component = 2) in double d;

// ERROR: e overflows component 3 of location 6
layout(location = 6, component = 2) in dvec2 e;

// ERROR: f overlaps with g
layout(location = 7, component = 0) in vec2 f;
layout(location = 7, component = 1) in float g;

layout(location = 8) in dvec3 h; // components 0,1,2 and 3 of location 8
                                 // and components 0 and 1 of location 9
layout(location = 9, component = 2) in double i; // okay, compts 2 and 3
----

If the variable is an array, each element of the array, in order, is
assigned to consecutive locations, but all at the same specified component
within each location.
For example:

[source,glsl]
----
// component 3 is consumed in each of 6 locations
layout(location = 2, component = 3) in float d[6];
----

That is, location 2 component 3 will hold _d[0]_, location 3 component 3
will hold _d[1]_, ..., up through location 7 component 3 holding _d[5]_.

This allows packing of two arrays into the same set of locations:

[source,glsl]
----
// e consumes beginning (components 0, 1 and 2) of each of 6 slots
layout(location = 0, component = 0) in vec3 e[6];

// f consumes last component of the same 6 slots
layout(location = 0, component = 3) in float f[6];
----

If applying this to an array of arrays, all levels of arrayness are removed
to get to the elements that are assigned per location to the specified
component.
These non-arrayed elements will fill the locations in the order specified
for arrays of arrays in "`<<arrays, Arrays>>`".

It is a compile-time error to apply the *component* qualifier to a matrix, a
structure, a block, or an array containing any of these.
It is a compile-time error to use *component* 1 or 3 as the beginning of a
*double* or *dvec2*.
It is a link-time error to specify different components for the same
variable within a program.

_Location aliasing_ is causing two variables or block members to have the
same location number.
_Component aliasing_ is assigning the same (or overlapping) component
numbers for two location aliases.
(Recall if *component* is not used, components are assigned starting with
0.)
With one exception, location aliasing is allowed only if it does not
cause component aliasing; it is a compile-time or link-time error to cause
component aliasing.
Further, when location aliasing, the aliases sharing the location must have
the same underlying numerical type and bit width  (floating-point or integer,
32-bit versus 64-bit, etc.) and the same
auxiliary storage and interpolation qualification.
The one exception where component aliasing is permitted is
when targeting {apiname} for two input
variables (not block members) to a vertex shader, which are allowed to have
component aliasing.
This vertex-variable component aliasing is intended only to support vertex
shaders where each execution path accesses at most one input per
aliased component.
Implementations are permitted, but not required, to generate link-time
errors if they detect that every path through the vertex shader executable
accesses multiple inputs aliased to any single component.
endif::GLSL[]


[[tessellation-evaluation-inputs]]
==== Tessellation Evaluation Inputs

Additional input layout qualifier identifiers allowed for tessellation
evaluation shaders are described below.

[role="bnf"]
--
_layout-qualifier-id_ : ::
    _primitive_mode_ +
    _vertex_spacing_ +
    _ordering_ +
    _point_mode_
--

The *primitive-mode* is used to specify a tessellation primitive mode to be
used by the tessellation primitive generator.

[role="bnf"]
--
_primitive-mode_: ::
    *triangles* +
    *quads* +
    *isolines*
--

If present, the _primitive-mode_ specifies that the tessellation primitive
generator should subdivide a triangle into smaller triangles, a quad into
triangles, or a quad into a collection of lines, respectively.

A second group of layout identifiers, _vertex spacing_, is used to specify
the spacing used by the tessellation primitive generator when subdividing an
edge.

[role="bnf"]
--
_vertex-spacing_: ::
    *equal_spacing* +
    *fractional_even_spacing* +
    *fractional_odd_spacing*
--

*equal_spacing* specifies that edges should be divided into a collection of
equal-sized segments;

*fractional_even_spacing* specifies that edges should be divided into an
even number of equal-length segments plus two additional shorter
"`fractional`" segments; or

*fractional_odd_spacing* specifies that edges should be divided into an odd
number of equal-length segments plus two additional shorter "`fractional`"
segments.

A third group of layout identifiers, _ordering_, specifies whether the
tessellation primitive generator produces triangles in clockwise or
counter-clockwise order, according to the coordinate system depicted in the
<<references,{apispec}>>.

[role="bnf"]
--
_ordering_: ::
    *cw* +
    *ccw*
--

The identifiers *cw* and *ccw* indicate clockwise and counter-clockwise
triangles, respectively.
If the tessellation primitive generator does not produce triangles, the
order is ignored.

Finally, _point mode_ indicates that the tessellation primitive generator
should produce one point for each distinct vertex in the subdivided
primitive, rather than generating lines or triangles.

[role="bnf"]
--
_point-mode_: ::
    *point_mode*
--

Any or all of these identifiers may be specified one or more times in a
single input layout declaration.
ifdef::GLSL[]
If primitive mode, vertex spacing, or ordering is declared more than once in
the tessellation evaluation shaders of a program, all such declarations must
use the same identifier.

At least one tessellation evaluation shader (compilation unit) in a program
must declare a primitive mode in its input layout.
endif::GLSL[]
ifdef::ESSL[]
The tessellation evaluation shader object in a program must declare a
primitive mode in its input layout.
endif::ESSL[]
Declaring vertex spacing, ordering, or point mode identifiers is optional.
ifdef::GLSL[]
It is not required that all tessellation evaluation shaders in a program
declare a primitive mode.
endif::GLSL[]
If spacing or vertex ordering declarations are omitted, the tessellation
primitive generator will use equal spacing or counter-clockwise vertex
ordering, respectively.
If a point mode declaration is omitted, the tessellation primitive generator
will produce lines or triangles according to the primitive mode.


[[geometry-shader-inputs]]
==== Geometry Shader Inputs

Additional layout qualifier identifiers for geometry shader inputs include
_primitive_ identifiers and an _invocation count_ identifier:

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *points* +
    *lines* +
    *lines_adjacency* +
    *triangles* +
    *triangles_adjacency* +
    *invocations* *=* _layout-qualifier-value_
--

The identifiers *points*, *lines*, *lines_adjacency*, *triangles*, and
*triangles_adjacency* are used to specify the type of input primitive
accepted by the geometry shader, and only one of these is accepted.
ifdef::GLSL[]
At least one geometry shader (compilation unit) in a program must declare
this input primitive layout, and all geometry shader input layout
declarations in a program must declare the same layout.
It is not required that all geometry shaders in a program declare an input
primitive layout.
endif::GLSL[]
ifdef::ESSL[]
The geometry shader must declare this input primitive layout.
endif::ESSL[]

The identifier *invocations* is used to specify the number of times the
geometry shader executable is invoked for each input primitive received.
Invocation count declarations are optional.
ifdef::GLSL[]
If no invocation count is declared in any geometry shader in a program, the
geometry shader will be run once for each input primitive.
endif::GLSL[]
ifdef::ESSL[]
If no invocation count is declared in the geometry shader, it will be run
once for each input primitive.
endif::ESSL[]
If an invocation count is declared, all such declarations must specify the
same count.
If a shader specifies an invocation count greater than the
implementation-dependent maximum, or less than or equal to zero,
a compile-time error results.

For example,

[source,glsl]
----
layout(triangles, invocations = 6) in;
----

will establish that all inputs to the geometry shader are triangles and that
the geometry shader executable is run six times for each triangle processed.

All geometry shader input unsized array declarations will be sized by an
earlier input primitive layout qualifier, when present, as per the following
table.

[options="header"]
|====
| Layout                | Size of Input Arrays
| *points*              | 1
| *lines*               | 2
| *lines_adjacency*     | 4
| *triangles*           | 3
| *triangles_adjacency* | 6
|====

The intrinsically declared input array _gl_in[]_ will also be sized by any
input primitive-layout declaration.
Hence, the expression

[source,glsl]
----
gl_in.length()
----

will return the value from the table above.

ifdef::GLSL[]
For inputs declared without an array size, including intrinsically declared
inputs (i.e., _gl_in_), a layout must be declared before any use of the
method *length*() or other any array use that requires the array size to be
known.
endif::GLSL[]
ifdef::ESSL[]
An input can be declared without an array size if there is a previous layout
which specifies the size.
For built-in inputs (e.g. _gl_in[]_), a layout must be declared before any
use.
endif::ESSL[]

It is a compile-time error if a layout declaration's array size (from the
table above) does not match all the explicit array sizes specified in
declarations of an input variables in the same shader.
The following includes examples of compile-time errors:

[source,glsl]
----
// code sequence within one shader...
ifdef::GLSL[]
in vec4 Color1[];     // legal, size still unknown
endif::GLSL[]
in vec4 Color2[2];    // legal, size is 2
in vec4 Color3[3];    // illegal, input sizes are inconsistent
layout(lines) in;     // legal for Color2, input size is 2, matching Color2
in vec4 Color4[3];    // illegal, contradicts layout of lines
layout(lines) in;     // legal, matches other layout() declaration
layout(triangles) in; // illegal, does not match earlier layout() declaration
----

It is a link-time error if not all provided sizes (sized input arrays and
ifdef::GLSL[layout size) match across all geometry shaders in a program.]
ifdef::ESSL[layout size) match in the geometry shader of a program.]


[[fragment-shader-inputs]]
==== Fragment Shader Inputs

ifdef::GLSL[]
Additional fragment layout qualifier identifiers include the following for
_gl_FragCoord_ :

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *origin_upper_left* +
    *pixel_center_integer*
--

By default, _gl_FragCoord_ in {apiname} assumes a lower-left origin for window
coordinates and assumes pixel centers are located at half-pixel coordinates.
For example, the (_x, y_) location (0.5, 0.5) is returned for the
lower-left-most pixel in a window.
The origin can be changed by redeclaring _gl_FragCoord_ with the
*origin_upper_left* qualifier, moving the origin of _gl_FragCoord_ to the
upper left of the window, with _y_ increasing in value toward the bottom of
the window.
The values returned can also be shifted by half a pixel in both _x_ and _y_
by *pixel_center_integer* so it appears the pixels are centered at whole
number pixel offsets.
This moves the (_x_, _y_) value returned by _gl_FragCoord_ of (0.5, 0.5) by
default, to (0.0, 0.0) with *pixel_center_integer*.

Targeting Vulkan will assume and require an upper-left origin for _gl_FragCoord_
with pixel centers located at half-pixel coordinates.
This origin can be explicitly set by redeclaring _gl_FragCoord_ with the
*origin_upper_left* identifier.

Redeclarations are done as follows

[source,glsl]
----
in vec4 gl_FragCoord; // redeclaration that changes nothing is allowed

// All the following are allowed redeclaration that change behavior
layout(origin_upper_left) in vec4 gl_FragCoord;
layout(pixel_center_integer) in vec4 gl_FragCoord;
layout(origin_upper_left, pixel_center_integer) in vec4 gl_FragCoord;
----

If _gl_FragCoord_ is redeclared in any fragment shader in a program, it must
be redeclared in all the fragment shaders in that program that have a static
use _gl_FragCoord_.
All redeclarations of _gl_FragCoord_ in all fragment shaders in a single
program must have the same set of qualifiers.
Within any shader, the first redeclarations of _gl_FragCoord_ must appear
before any use of _gl_FragCoord_.
The built-in _gl_FragCoord_ is only predeclared in fragment shaders, so
redeclaring it in any other shader language results in a compile-time error.

Redeclaring _glFragCoord_ with *origin_upper_left* and/or
*pixel_center_integer* qualifiers only affects _gl_FragCoord.x_ and
_gl_FragCoord.y_.
It has no effect on rasterization, transformation, or any other part of the
API pipeline or language features.
endif::GLSL[]

Fragment shaders allow the following layout qualifier on *in* only (not with
variable declarations):

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *early_fragment_tests*
--

to request that fragment tests be performed before fragment shader
ifdef::GLSL[]
execution, as described in section 15.2.4 "`Early Fragment Tests`" of the
endif::GLSL[]
ifdef::ESSL[]
execution, as described in section 13.8.4 "`Early Fragment Tests`" of the
endif::ESSL[]
<<references,{apispec}>>.

For example,

[source,glsl]
----
layout(early_fragment_tests) in;
----

Specifying this will make per-fragment tests be performed before fragment
shader execution.
ifdef::ESSL[]
In addition it is an error to statically write to _gl_FragDepth_ in the
fragment shader.
endif::ESSL[]
If this is not declared, per-fragment tests will be performed after fragment
shader execution.
ifdef::GLSL[]
Only one fragment shader (compilation unit) need declare this, though more
than one can.
If at least one declares this, then it is enabled.
endif::GLSL[]


[[compute-shader-inputs]]
==== Compute Shader Inputs

There are no layout location qualifiers for compute shader inputs.

Layout qualifier identifiers for compute shader inputs are the workgroup
size qualifiers:

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *local_size_x* *=* _layout-qualifier-value_ +
    *local_size_y* *=* _layout-qualifier-value_ +
    *local_size_z* *=* _layout-qualifier-value_
--

The *local_size_x*, *local_size_y*, and *local_size_z* qualifiers are used
to declare a fixed workgroup size by the compute shader in the first,
second, and third dimension, respectively.
If a shader does not specify a size for one of the dimensions, that
dimension will have a size of 1.

For example, the following declaration in a compute shader

[source,glsl]
----
layout(local_size_x = 32, local_size_y = 32) in;
----

is used to declare a two-dimensional compute shader with a workgroup size of 32
X 32 elements, which is equivalent to a three-dimensional compute shader
where the third dimension has size one.

As another example, the declaration

[source,glsl]
----
layout(local_size_x = 8) in;
----

effectively specifies that a one-dimensional compute shader is being
compiled, and its size is 8 elements.

If the fixed workgroup size of the shader in any dimension is less than
or equal to zero or greater than the maximum size supported by the
implementation for that dimension, a compile-time error results.
Also, if such a layout qualifier is declared more than once in the same
shader, all those declarations must set the same set of workgroup
sizes and set them to the same values; otherwise a compile-time error
results.
ifdef::GLSL[]
If multiple compute shaders attached to a single program object declare a
fixed workgroup size, the declarations must be identical; otherwise a
link-time error results.

Furthermore, if a program object contains any compute shaders, at least one
must contain an input layout qualifier specifying a fixed workgroup size
for the program, or a link-time error will occur.
endif::GLSL[]
ifdef::ESSL[]

Furthermore, if a program object contains a compute shader, that shader must
contain an input layout qualifier specifying a fixed workgroup size for
the program, or a link-time error will occur.
endif::ESSL[]


[[output-layout-qualifiers]]
=== Output Layout Qualifiers

Some output layout qualifiers apply to all shader stages and some apply only
to specific stages.
The latter are discussed in separate sections below.

As with input layout qualifiers, all shaders except compute shaders allow
*location* layout qualifiers on output variable declarations, output block
declarations, and output block member declarations.
ifdef::GLSL[]
Of these, variables and block members (but not blocks) additionally allow
the *component* layout qualifier.
endif::GLSL[]

ifdef::GLSL[]
[role="bnf"]
--
_layout-qualifier-id_ : ::
    *location* *=* _layout-qualifier-value_ +
    *component* *=* _layout-qualifier-value_
--
endif::GLSL[]
ifdef::ESSL[]
[role="bnf"]
--
_layout-qualifier-id_ : ::
    *location* *=* _layout-qualifier-value_
--
endif::ESSL[]

The usage and rules for applying the *location* qualifier
ifdef::GLSL[and the *component* qualifier]
to blocks and structures are exactly as described in
"`<<input-layout-qualifiers,Input Layout Qualifiers>>`".
ifdef::GLSL[]
No component aliasing of output variables or members is allowed.

Fragment shaders allow an additional *index* output layout qualifier:

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *index* *=* _layout-qualifier-value_
--

Each of these qualifiers may appear at most once.
If *index* is specified, *location* must also be specified.
If *index* is not specified, the value 0 is used.
endif::GLSL[]
ifdef::ESSL[]
The qualifier may appear at most once within a declaration.
endif::ESSL[]
For example, in a fragment shader,

[source,glsl]
----
layout(location = 3) out vec4 color;
----

will establish that the fragment shader output _color_ is assigned to
ifdef::GLSL[]
fragment color 3 as the first (index zero) input to the blend equation.
endif::GLSL[]
ifdef::ESSL[]
fragment color 3.
endif::ESSL[]
ifdef::GLSL[]
And,

[source,glsl]
----
layout(location = 3, index = 1) out vec4 factor;
----

will establish that the fragment shader output _factor_ is assigned to
fragment color 3 as the second (index one) input to the blend equation.
endif::GLSL[]

For fragment shader outputs, the location
ifdef::GLSL[and index specify]
ifdef::ESSL[specifies]
the color output number
ifdef::GLSL[and index]
receiving the values of the output.
For outputs of all other shader stages, the location specifies a vector
number that can be used to match against inputs in a subsequent shader
stage, even if that shader is in a different program object.

ifdef::GLSL[]
If a declared output is a scalar or vector type other than *dvec3* or
*dvec4*, it will consume a single location.
Outputs of type *dvec3* or *dvec4* will consume two consecutive locations.
Outputs of type *double* and *dvec2* will consume only a single location, in
all stages.
endif::GLSL[]
ifdef::ESSL[]
Declared outputs of scalar or vector type consume a single location.
endif::ESSL[]

If the declared output is an array, it will be assigned consecutive
locations starting with the location specified.
For example,

[source,glsl]
----
layout(location = 2) out vec4 colors[3];
----

will establish that _colors_ is assigned to vector location numbers 2, 3,
and 4.

If the declared output is an _n_ {times} _m_
matrix, it will be assigned multiple locations starting with the location
specified.
The number of locations assigned will be the same as for an _n_-element
array of _m_-component vectors.

If the declared output is a structure, its members will be assigned
consecutive locations in the order of declaration, with the first member
assigned the location specified for the structure.
The number of locations consumed by a structure member is determined by
applying the rules above recursively as though the structure member were
declared as an output variable of the same type.

*location* layout qualifiers may be used on output variables declared as
structures.
However, it is a compile-time error to use a *location* qualifier on a
structure member.
Location layout qualifiers may be used on output blocks and output block
members.

ifdef::ESSL[]
If an output is declared as an array of blocks, excluding per-vertex-arrays
as required for tessellation, it is an error to declare a member of the
block with a *location* qualifier.
endif::ESSL[]

The number of output locations available to a shader is limited.
For fragment shaders, the limit is the advertised number of draw buffers.

For all other shaders, the limit is implementation-dependent and must be no
less than one fourth of the advertised maximum output component count
(compute shaders have no outputs).
A program will fail to link if any attached shader uses a location greater
than or equal to the number of supported locations, unless device-dependent
optimizations are able to make the program fit within available hardware
resources.

Compile-time errors may also be given if at compile time it is known the
link will fail.
A negative output location will result in {compiletimeerror}.
ifdef::GLSL[]
It is also a compile-time error if a fragment shader sets a layout index to
less than 0 or greater than 1.
endif::GLSL[]

It is a compile-time or link-time error if any of the following occur:

  * any two fragment shader output variables are assigned to the same
ifdef::GLSL[]
    location and index.
endif::GLSL[]
ifdef::ESSL[]
    location.
endif::ESSL[]
  * if any two output variables from the same vertex, tessellation or
    geometry shader stage are assigned to the same location.

ifdef::GLSL[]
For fragment shader outputs, locations can be assigned using either a
*layout* qualifier or via the {apiname} API.
endif::GLSL[]

For all shader types, a program will fail to link if explicit location
assignments leave the linker unable to find space for other variables
without explicit assignments.

ifdef::GLSL[]
If an output variable with no location or index assigned in the shader text
has a location specified through the {apiname} API, the API-assigned
location will be used.
Otherwise, such variables will be assigned a location by the linker.
All such assignments will have a color index of zero.
See section 15.2 "`Shader Execution`" of the <<references,{apispec}>> for
more details.
A link-time error will occur if an output variable is declared in multiple
shaders of the same language with conflicting location or index values.
endif::GLSL[]
ifdef::ESSL[]
If an output variable has no location assigned in the shader text, it will
be assigned a location by the linker.
See section 11.1.3 "`Shader Execution`" of the <<references,{apispec}>> for
more details.

If there is only a single output, the location does not need to be
specified, in which case it defaults to zero.
This applies for all output types, including arrays.
If there is more than one fragment output, the location must be specified
for all outputs.
endif::ESSL[]

For the purposes of determining if a non-fragment output matches an input
from a subsequent shader stage, the *location* layout qualifier (if any)
must match.


ifdef::GLSL[]
[[transform-feedback-layout-qualifiers]]
==== Transform Feedback Layout Qualifiers

The vertex, tessellation, and geometry stages allow shaders to control
transform feedback.
When doing this, shaders will dictate which transform feedback buffers are
in use, which output variables will be written to which buffers, and how
each buffer is laid out.
To accomplish this, shaders allow the following layout qualifier identifiers
on output declarations:

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *xfb_buffer* *=* _layout-qualifier-value_ +
    *xfb_offset* *=* _layout-qualifier-value_ +
    *xfb_stride* *=* _layout-qualifier-value_
--

Any shader making any static use (after preprocessing) of any of these
*xfb_* qualifiers will cause the shader to be in a transform feedback
capturing mode and hence responsible for describing the transform feedback
setup.
This mode will capture any output selected by *xfb_offset*, directly or
indirectly, to a transform feedback buffer.

The *xfb_buffer* qualifier specifies which transform feedback buffer will
capture outputs selected with *xfb_offset*.
The *xfb_buffer* qualifier can be applied to the qualifier *out*, to output
variables, to output blocks, and to output block members.
Shaders in the transform feedback capturing mode have an initial global
default of

[source,glsl]
----
layout(xfb_buffer = 0) out;
----

This default can be changed by declaring a different buffer with
*xfb_buffer* on the interface qualifier *out*.
This is the only way the global default can be changed.
When a variable or output block is declared without an *xfb_buffer*
qualifier, it inherits the global default buffer.
When a variable or output block is declared with an *xfb_buffer* qualifier,
it has that declared buffer.
All members of a block inherit the block's buffer.
A member is allowed to declare an *xfb_buffer*, but it must match the buffer
inherited from its block, or a compile-time error results.

[source,glsl]
----
layout(xfb_buffer=2, xfb_offset=0) out block { // block's buffer is 2
    layout(xfb_buffer = 2) vec4 v; // okay, matches the inherited 2
    layout(xfb_buffer = 3) vec4 u; // ERROR, mismatched buffer
    vec4 w; // inherited
};
layout(xfb_offset=16) out vec4 t;  // initial default is buffer 0
layout(xfb_buffer=1) out;          // new global default of 1
out block {                        // block has buffer 1
    vec4 x;                        // x has buffer 1 (not captured)
    layout(xfb_buffer = 1) vec4 y; // okay (not captured)
    layout(xfb_buffer = 0) vec4 z; // ERROR, mismatched buffer
};
layout(xfb_offset=0) out vec4 g;   // g has buffer 1
layout(xfb_buffer=2) out vec4 h;   // does not change global default
layout(xfb_offset=16) out vec4 j;  // j has buffer 1
----

Note this means all members of a block that go to a transform feedback
buffer will go to the same buffer.

When a block is declared as an array, all members of block array-element 0
are captured, as previously described, by the declared or inherited
*xfb_buffer*.
Generally, an array of size _N_ of blocks is captured by _N_ consecutive
buffers, with all members of block array-element _E_ captured by buffer _B_,
where _B_ equals the declared or inherited *xfb_buffer* plus _E_.

It is a compile-time or link-time error to specify an *xfb_buffer*,
including any additional buffers needed to capture an arrays of blocks, that
is less than zero or greater than or equal to the implementation-dependent
constant _gl_MaxTransformFeedbackBuffers_.

The *xfb_offset* qualifier assigns a byte offset within a transform feedback
buffer.
Only variables, block members, or blocks can be qualified with *xfb_offset*.
If a block is qualified with *xfb_offset*, all its members are assigned
transform feedback buffer offsets.
If a block is not qualified with *xfb_offset*, any members of that block not
qualified with an *xfb_offset* will not be assigned transform feedback
buffer offsets.
Only variables and block members that are assigned offsets will be captured
(thus, a proper subset of a block can be captured).
Each time such a variable or block member is written in a shader, the
written value is captured at the assigned offset.
If such a block member or variable is not written during a shader
invocation, the buffer contents at the assigned offset will be undefined.
Even if there are no static writes to a variable or member that is assigned
a transform feedback offset, the space is still allocated in the buffer and
still affects the stride.

Variables and block members qualified with *xfb_offset* can be scalars,
vectors, matrices, structures, and (sized) arrays of these.
The offset must be a multiple of the size of the first component of the
first qualified variable or block member, or a compile-time error results.
Further, if applied to an aggregate containing a *double*, the offset must
also be a multiple of 8, and the space taken in the buffer will be a
multiple of 8.
The given offset applies to the first component of the first member of the
qualified entity.
Then, within the qualified entity, subsequent components are each assigned,
in order, to the next available offset aligned to a multiple of that
component's size.
Aggregate types are flattened down to the component level to get this
sequence of components.
It is a compile-time error to apply *xfb_offset* to the declaration of an
unsized array.

No aliasing in output buffers is allowed: It is a compile-time or link-time
error to specify variables with overlapping transform feedback offsets.

The *xfb_stride* qualifier specifies how many bytes are consumed by each
captured vertex.
It applies to the transform feedback buffer for that declaration, whether it
is inherited or explicitly declared.
It can be applied to variables, blocks, block members, or just the qualifier
*out*.
If the buffer is capturing any outputs with double-precision components, the
stride must be a multiple of 8, otherwise it must be a multiple of 4, or a
compile-time or link-time error results.
It is a compile-time or link-time error to have any *xfb_offset* that
overflows *xfb_stride*, whether stated on declarations before or after the
*xfb_stride*, or in different compilation units.
While *xfb_stride* can be declared multiple times for the same buffer, it is
a compile-time or link-time error to have different values specified for the
stride for the same buffer.

For example:

[source,glsl]
----
// buffer 1 has 32-byte stride
layout(xfb_buffer = 1, xfb_stride = 32) out;

// same as previous example; order within layout does not matter
layout(xfb_stride = 32, xfb_buffer = 1) out;

// everything in this block goes to buffer 0
layout(xfb_buffer = 0, xfb_stride = 32) out block1 {
    layout(xfb_offset = 0) vec4 a;  // a goes to byte offset 0 of buffer 0
    layout(xfb_offset = 16) vec4 b; // b goes to offset 16 of buffer 0
};

layout(xfb_buffer = 3, xfb_offset = 12) out block2 {
    vec4 v;  // v will be written to byte offsets 12 through 27 of buffer
    float u; // u will be written to offset 28
    layout(xfb_offset = 40) vec4 w;
    vec4 x;  // x will be written to offset 56, the next available offset
};

layout(xfb_buffer = 2, xfb_stride = 32) out block3 {
    layout(xfb_offset = 12) vec3 c;
    layout(xfb_offset = 24) vec3 d; // ERROR, requires stride of 36
    layout(xfb_offset = 0) vec3 g;  // okay, increasing order not required
};
----

When no *xfb_stride* is specified for a buffer, the stride of the buffer
will be the smallest needed to hold the variable placed at the highest
offset, including any required padding.
For example:

[source,glsl]
----
// if there no other declarations for buffer 3, it has stride 32
layout(xfb_buffer = 3) out block4 {
    layout(xfb_offset = 0) vec4 e;
    layout(xfb_offset = 16) vec4 f;
};
----

The resulting stride (implicit or explicit), when divided by 4, must be less
than or equal to the implementation-dependent constant
_gl_MaxTransformFeedbackInterleavedComponents_.
endif::GLSL[]


[[tessellation-control-outputs]]
==== Tessellation Control Outputs

ifdef::GLSL[]
Other than for the transform feedback layout qualifiers, tessellation
control shaders allow output layout qualifiers only on the interface
endif::GLSL[]
ifdef::ESSL[]
Tessellation control shaders allow output layout qualifiers only on the
interface
endif::ESSL[]
qualifier *out*, not on an output block, block member, or variable
declaration.
The output layout qualifier identifiers allowed for tessellation control
shaders are:

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *vertices* *=* _layout-qualifier-value_
--

The identifier *vertices* specifies the number of vertices in the output
patch produced by the tessellation control shader, which also specifies the
number of times the tessellation control shader is invoked.
It is a compile- or link-time error for the output vertex count to be less
than or equal to zero, or greater than the implementation-dependent maximum
patch size.

The intrinsically declared tessellation control output array _gl_out[]_ will
also be sized by any output layout declaration.
Hence, the expression

[source,glsl]
----
gl_out.length()
----

will return the output patch vertex count specified in a previous output
layout qualifier.
For outputs declared without an array size, including intrinsically declared
outputs (i.e., _gl_out_), a layout must be declared before any use of the
method *length*() or other array use that requires its size to be known.

It is a compile-time error if the output patch vertex count specified in an
output layout qualifier does not match the array size specified in any
output variable declaration in the same shader.

All tessellation control shader layout declarations in a program must
specify the same output patch vertex count.
There must be at least one layout qualifier specifying an output patch
ifdef::GLSL[]
vertex count in any program containing tessellation control shaders;
however, such a declaration is not required in all tessellation control
shaders.
endif::GLSL[]
ifdef::ESSL[]
vertex count in any program containing a tessellation control shader.
endif::ESSL[]


[[geometry-outputs]]
==== Geometry Outputs

ifdef::GLSL[]
Geometry shaders can have three additional types of output layout
identifiers: an output _primitive type_, a maximum output _vertex count_,
and per-output _stream_ numbers.
endif::GLSL[]
ifdef::ESSL[]
Geometry shaders can have two additional types of output layout identifiers:
an output primitive type and a maximum output vertex count.
endif::ESSL[]
The primitive type and vertex count identifiers are allowed only on the
interface qualifier *out*, not on an output block, block member, or variable
declaration.
ifdef::GLSL[]
The stream identifier is allowed on the interface qualifier *out*, on output
blocks, and on variable declarations.
endif::GLSL[]

The layout qualifier identifiers for geometry shader outputs are

ifdef::GLSL[]
[role="bnf"]
--
_layout-qualifier-id_ : ::
    *points* +
    *line_strip* +
    *triangle_strip* +
    *max_vertices* *=* _layout-qualifier-value_ +
    *stream* *=* _layout-qualifier-value_
--
endif::GLSL[]
ifdef::ESSL[]
[role="bnf"]
--
_layout-qualifier-id_ : ::
    *points* +
    *line_strip* +
    *triangle_strip* +
    *max_vertices* *=* _layout-qualifier-value_
--
endif::ESSL[]

The primitive type identifiers *points*, *line_strip*, and *triangle_strip*
are used to specify the type of output primitive produced by the geometry
shader, and only one of these is accepted.
ifdef::GLSL[]
At least one geometry shader (compilation unit) in a program must declare an
output primitive type, and all geometry shader output primitive type
declarations in a program must declare the same primitive type.
It is not required that all geometry shaders in a program declare an output
primitive type.
endif::GLSL[]
ifdef::ESSL[]
The geometry shader object in a program must declare an output primitive
type, and all geometry shader output primitive type declarations in a
program must declare the same primitive type.
endif::ESSL[]

The vertex count identifier *max_vertices* is used to specify the maximum
number of vertices the shader will ever emit in a single invocation.
ifdef::GLSL[]
At least one geometry shader (compilation unit) in a program must declare a
maximum output vertex count, and all geometry shader output vertex count
declarations in a program must declare the same count.
It is not required that all geometry shaders in a program declare a count.
endif::GLSL[]
ifdef::ESSL[]
The geometry shader object in a program must declare a maximum output vertex
count, and all geometry shader output vertex count declarations in a program
must declare the same count.
endif::ESSL[]

In this example,

[source,glsl]
----
layout(triangle_strip, max_vertices = 60) out; // order does not matter
layout(max_vertices = 60) out;  // redeclaration okay
layout(triangle_strip) out;     // redeclaration okay
layout(points) out;             // error, contradicts triangle_strip
layout(max_vertices = 30) out;  // error, contradicts 60
----

all outputs from the geometry shader are triangles and at most 60 vertices
will be emitted by the shader.
It is an error for the maximum number of vertices to be greater than
_gl_MaxGeometryOutputVertices_.

ifdef::GLSL[]
The identifier *stream* is used to specify that a geometry shader output
variable or block is associated with a particular vertex stream (numbered
beginning with zero).
A default stream number may be declared at global scope by qualifying
interface qualifier *out* as in this example:

[source,glsl]
----
layout(stream = 1) out;
----

The stream number specified in such a declaration replaces any previous
default and applies to all subsequent block and variable declarations until
a new default is established.
The initial default stream number is zero.

Each output block or non-block output variable is associated with a vertex
stream.
If the block or variable is declared with the stream identifier, it is
associated with the specified stream; otherwise, it is associated with the
current default stream.
A block member may be declared with a stream identifier, but the specified
stream must match the stream associated with the containing block.
One example:

[source,glsl]
----
layout(stream=1) out;           // default is now stream 1
out vec4 var1;                  // var1 gets default stream (1)
layout(stream=2) out Block1 {   // "Block1" belongs to stream 2
    layout(stream=2) vec4 var2; // redundant block member stream decl
    layout(stream=3) vec2 var3; // ILLEGAL (must match block stream)
    vec3 var4;                  // belongs to stream 2
};
layout(stream=0) out;           // default is now stream 0
out vec4 var5;                  // var5 gets default stream (0)
out Block2 {                    // "Block2" gets default stream (0)
    vec4 var6;
};
layout(stream=3) out vec4 var7; // var7 belongs to stream 3
----

Each vertex emitted by the geometry shader is assigned to a specific stream,
and the attributes of the emitted vertex are taken from the set of output
blocks and variables assigned to the targeted stream.
After each vertex is emitted, the values of all output variables become
undefined.
Additionally, the output variables associated with each vertex stream may
share storage.
Writing to an output variable associated with one stream may overwrite
output variables associated with any other stream.
When emitting each vertex, a geometry shader should write to all outputs
associated with the stream to which the vertex will be emitted and to no
outputs associated with any other stream.

If a geometry shader output block or variable is declared more than once,
all such declarations must associate the variable with the same vertex
stream.
If any stream declaration specifies a non-existent stream number, the shader
will fail to compile.

Built-in geometry shader outputs are always associated with vertex stream
zero.
endif::GLSL[]

All geometry shader output layout declarations in a program must declare the
same layout and same value for *max_vertices*.
If geometry shaders are in a program, there must be at least one geometry
output layout declaration somewhere in that
ifdef::GLSL[]
program, but not all geometry
shaders (compilation units) are required to declare it.
endif::GLSL[]
ifdef::ESSL[program.]


[[fragment-outputs]]
==== Fragment Outputs

ifdef::ESSL[]
Fragment shaders can have an output layout for redeclaring the built-in
variable _gl_FragDepth_:
endif::ESSL[]
ifdef::GLSL[]
The built-in fragment shader variable _gl_FragDepth_ may be redeclared using
one of the following layout qualifiers.

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *depth_any* +
    *depth_greater* +
    *depth_less* +
    *depth_unchanged*
--

The layout qualifier for _gl_FragDepth_ constrains intentions of the final
value of _gl_FragDepth_ written by any shader invocation.
GL implementations are allowed to perform optimizations assuming that the
depth test fails (or passes) for a given fragment if all values of
_gl_FragDepth_ consistent with the layout qualifier would fail (or pass).
This potentially includes skipping shader execution if the fragment is
discarded because it is occluded and the shader has no side effects.
If the final value of _gl_FragDepth_ is inconsistent with its layout
qualifier, the result of the depth test for the corresponding fragment is
undefined.
However, no error will be generated in this case.
If the depth test passes and depth writes are enabled, the value written to
the depth buffer is always the value of _gl_FragDepth_, whether or not it is
consistent with the layout qualifier.

By default, _gl_FragDepth_ is qualified as _depth_any_.
When the layout qualifier for _gl_FragDepth_ is _depth_any_, the shader
compiler will note any assignment to _gl_FragDepth_ modifying it in an
unknown way, and depth testing will always be performed after the shader has
executed.
When the layout qualifier is _depth_greater_, the GL can assume that the
final value of _gl_FragDepth_ is greater than or equal to the fragment's
interpolated depth value, as given by the _z_ component of _gl_FragCoord_.
When the layout qualifier is _depth_less_, the GL can assume that any
modification of _gl_FragDepth_ will only decrease its value.
When the layout qualifier is _depth_unchanged_, the shader compiler will
honor any modification to _gl_FragDepth_, but the rest of the GL can assume
that _gl_FragDepth_ is not assigned a new value.

Redeclarations of _gl_FragDepth_ are performed as follows:
endif::GLSL[]

ifdef::ESSL[]
[source,glsl]
----
// redeclaration that changes nothing is allowed
out float gl_FragDepth;
----
endif::ESSL[]
ifdef::GLSL[]
[source,glsl]
----
// redeclaration that changes nothing is allowed
out float gl_FragDepth;

// assume it may be modified in any way
layout(depth_any) out float gl_FragDepth;

// assume it may be modified such that its value will only increase
layout(depth_greater) out float gl_FragDepth;

// assume it may be modified such that its value will only decrease
layout(depth_less) out float gl_FragDepth;

// assume it will not be modified
layout(depth_unchanged) out float gl_FragDepth;
----

If _gl_FragDepth_ is redeclared in any fragment shader in a program, it must
be redeclared in all fragment shaders in that program that have static
assignments to _gl_FragDepth_.
All redeclarations of _gl_FragDepth_ in all fragment shaders in a single
program must have the same set of qualifiers.
Within any shader, the first redeclarations of _gl_FragDepth_ must appear
before any use of _gl_FragDepth_.
endif::GLSL[]
The built-in _gl_FragDepth_ is only predeclared in fragment shaders, so
redeclaring it in any other shader language results in {compiletimeerror}.

ifdef::ESSL[]
Fragment shaders additionally support layout qualifiers specifying a set of
advanced blend equations supported when the fragment shader is used.
These layout qualifiers are only permitted on the interface qualifier *out*,
and use the identifiers specified in the "`Layout Qualifier`" column of the
table below.

If a layout qualifier in the table below is specified in the fragment
shader, the fragment shader may be used with the corresponding advanced
blend equation in the "`Blend Equation(s) Supported`" column.
Additionally, the special qualifier *blend_support_all_equations* indicates
that the shader may be used with any advanced blending equation supported by
the <<references,{apispec}>>.
It is not an error to specify more than one of these identifiers in any
fragment shader.
Specifying more than one qualifier or *blend_support_all_equations* means
that the fragment shader may be used with multiple advanced blend equations.
Additionally, it is not an error to specify any single one of these layout
qualifiers more than once.

[cols="",]
|====
| Layout Qualifier                      | Blend Equations(s) Supported
| *blend_support_multiply*              | MULTIPLY
| *blend_support_screen*                | SCREEN
| *blend_support_overlay*               | OVERLAY
| *blend_support_darken*                | DARKEN
| *blend_support_lighten*               | LIGHTEN
| *blend_support_colordodge*            | COLORDODGE
| *blend_support_colorburn*             | COLORBURN
| *blend_support_hardlight*             | HARDLIGHT
| *blend_support_softlight*             | SOFTLIGHT
| *blend_support_difference*            | DIFFERENCE
| *blend_support_exclusion*             | EXCLUSION
| *blend_support_hsl_hue*               | HSL_HUE
| *blend_support_hsl_saturation*        | HSL_SATURATION
| *blend_support_hsl_color*             | HSL_COLOR
| *blend_support_hsl_luminosity*        | HSL_LUMINOSITY
| *blend_support_all_equations*         | all blend equations
|====
endif::ESSL[]


[[uniform-variable-layout-qualifiers]]
=== Uniform Variable Layout Qualifiers

ifdef::GLSL[]
Layout qualifiers can be used for uniform variables and subroutine uniforms.
The layout qualifier identifiers for uniform variables and subroutine
uniforms are:
endif::GLSL[]
ifdef::ESSL[]
The following layout qualifier can be used for all default-block uniform
variables but not for variables in uniform or shader storage blocks.
The layout qualifier identifier for uniform variables is:
endif::ESSL[]

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *location* *=* _layout-qualifier-value_
--

ifdef::GLSL[]
The location identifier can be used with default-block uniform variables and
subroutine uniforms.
endif::GLSL[]
The location specifies the location by which the API can reference
the uniform and update its value.
Individual elements of a uniform array are assigned consecutive locations
with the first element taking location *location*.
Default-block uniform variable declarations sharing the same location
linked in the program have to match by name, type, qualifiers and arrayness.
For arrays their array dimensionality and array sizes must match.
For structs this rule applies recursively to all members.
ifdef::GLSL[]
No two subroutine uniform variables can have the same location in the same
shader stage, otherwise a compile-time or link-time error will be generated.
endif::GLSL[]
Valid locations for default-block uniform variable locations are in the
range of 0 to the implementation-defined maximum number of uniform locations
minus one.
ifdef::GLSL[]
Valid locations for subroutine uniforms are in the range of 0 to the
implementation-defined per-stage maximum number of subroutine uniform
locations minus one.
endif::GLSL[]

Locations can be assigned to default-block uniform arrays and structures.
The first inner-most scalar, vector or matrix member or element takes the
specified *location* and the compiler assigns the next inner-most member or
element the next incremental location value.
Each subsequent inner-most member or element gets incremental locations for
the entire structure or array.
This rule applies to nested structures and arrays and gives each inner-most
scalar, vector, or matrix member a unique location.
ifdef::GLSL[]
For arrays without an explicit size, the size is calculated based on its
static usage.
endif::GLSL[]
When the linker generates locations for uniforms without an explicit
location, it assumes for all uniforms with an explicit location all their
array elements and structure members are used and the linker will not
generate a conflicting location, even if that element or member is deemed
unused.

ifdef::GLSL[]
When generating SPIR-V for API's that accept individual (default block)
non-opaque uniform variables, it is a compile-time error to not
include a location when declaring them.
endif::GLSL[]

When targeting Vulkan, the *push_constant* qualifier is used to
declare an entire block, and represents a set of _push constants_, as defined
by the Vulkan API.
It is {compiletimeerror} to apply this to anything other than a uniform block
declaration, or when not targeting Vulkan.
The values in the block will be initialized as per the Vulkan API specification.
A block declared with `layout(push_constant)` may optionally include an
_instance-name_.
There can be only one *push_constant* block per stage, or a compile-time or
link-time error will result.
A push-constant array can only be indexed with dynamically uniform indices.
Uniform blocks declared with *push_constant* use different resources
than those without; and are accounted for separately.

ifdef::GLSL[]
[[subroutine-function-layout-qualifiers]]
=== Subroutine Function Layout Qualifiers

Layout qualifiers can be used for subroutine functions.
The layout qualifier identifiers for subroutine functions are:

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *index* *=* _layout-qualifier-value_
--

Each subroutine with an index qualifier in the shader must be given a unique
index, otherwise a compile- or link-time error will be generated.
The indices must be in the range of 0 to the implementation defined maximum
number of subroutines minus one.
It is recommended, but not required, that the shader assigns a range of
tightly packed _index_ values starting from zero so that the {apiname}
subroutine function enumeration API returns a non-empty name for all active
indices.
endif::GLSL[]


[[uniform-and-shader-storage-block-layout-qualifiers]]
=== Uniform and Shader Storage Block Layout Qualifiers

Layout qualifiers can be used for uniform and shader storage blocks, but not
for non-block uniform declarations.
The layout qualifier identifiers (and *shared* keyword) for uniform and
shader storage blocks are:

ifdef::GLSL[]
[role="bnf"]
--
_layout-qualifier-id_ : ::
    *shared* +
    *packed* +
    *std140* +
    *std430* +
    *row_major* +
    *column_major* +
    *binding* *=* _layout-qualifier-value_ +
    *offset* *=* _layout-qualifier-value_ +
    *align* *=* _layout-qualifier-value_
--
endif::GLSL[]
ifdef::ESSL[]
[role="bnf"]
--
_layout-qualifier-id_ : ::
    *shared* +
    *packed* +
    *std140* +
    *std430* +
    *row_major* +
    *column_major* +
    *binding* *=* _layout-qualifier-value_ +
    *offset* *=* _layout-qualifier-value_   // Vulkan only +
    *align* *=* _layout-qualifier-value_    // Vulkan only
--
endif::ESSL[]

None of these have any semantic effect at all on the usage of the variables
being declared; they only describe how data is laid out in memory.
For example, matrix semantics are always column-based, as described in the
rest of this specification, no matter what layout qualifiers are being used.

Uniform and shader storage block layout qualifiers can be declared for
global scope, on a single uniform or shader storage block, or on a single
block member declaration.

Default layouts are established at global scope for uniform blocks as:

[source,glsl]
----
layout(layout-qualifier-id-list) uniform;
----

and for shader storage blocks as:

[source,glsl]
----
layout(layout-qualifier-id-list) buffer;
----

When this is done, the previous default qualification is first inherited and
then overridden as per the override rules listed below for each qualifier
listed in the declaration.
The result becomes the new default qualification scoped to subsequent
uniform or shader storage block definitions.

The initial state of compilation when generating SPIR-V is as if the
following were declared:

[source,glsl]
----
layout(std140, column_major) uniform;
layout(std430, column_major) buffer;
----

However, when *push_constant* is declared, the default layout of the
buffer will be *std430*. There is no method to globally set this default.

The initial state of compilation when not generating SPIR-V is as if the
following were declared:

[source,glsl]
----
layout(shared, column_major) uniform;
layout(shared, column_major) buffer;
----

Uniform and shader storage blocks can be declared with optional layout
qualifiers, and so can their individual member declarations.
Such block layout qualification is scoped only to the content of the block.
As with global layout declarations, block layout qualification first
inherits from the current default qualification and then overrides it.
Similarly, individual member layout qualification is scoped just to the
member declaration, and inherits from and overrides the block's
qualification.

The *shared* qualifier overrides only the *std140*, *std430*, and *packed*
qualifiers; other qualifiers are inherited.
The compiler/linker will ensure that multiple programs and programmable
stages containing this definition will share the same memory layout for this
ifdef::GLSL[]
block, as long as all arrays are declared with explicit sizes and all
matrices have matching *row_major* and/or *column_major* qualifications
(which may come from a declaration outside the block definition).
endif::GLSL[]
ifdef::ESSL[]
block, as long as they also matched in their *row_major* and/or
*column_major* qualifications.
endif::ESSL[]
This allows use of the same buffer to back the same block definition across
different programs.
It is a compile-time error to use the *shared* qualifier when generating
SPIR-V.

The *packed* qualifier overrides only *std140*, *std430*, and *shared*;
other qualifiers are inherited.
When *packed* is used, no shareable layout is guaranteed.
The compiler and linker can optimize memory use based on what variables
actively get used and on other criteria.
Offsets must be queried, as there is no other way of guaranteeing where (and
which) variables reside within the block.

It is a link-time error to access the same packed uniform or shader storage
block in multiple stages within a program.
Attempts to access the same packed uniform or shader storage block across
programs can result in conflicting member offsets and in undefined values
being read.
However, implementations may aid application management of packed blocks by
using canonical layouts for packed blocks.
It is a compile-time error to use the *packed* qualifier when generating
SPIR-V.

The *std140* and *std430* qualifiers override only the *packed*, *shared*,
*std140*, and *std430* qualifiers; other qualifiers are inherited.
The *std430* qualifier is supported only for shader storage blocks; a shader
using the *std430* qualifier on a uniform block will result in
{compiletimeerror}, unless it is also declared with *push_constant*.

The layout is explicitly determined by this, as described in section 7.6.2.2
"`Standard Uniform Block Layout`" of the <<references,{apispec}>>.
Hence, as in *shared* above, the resulting layout is shareable across
programs.

Layout qualifiers on member declarations cannot use the *shared*, *packed*,
*std140*, or *std430* qualifiers.
These can only be used at global scope (without an object) or on a block
declaration, or {compiletimeerror} results.

The *row_major* and *column_major* qualifiers only affect the layout of
matrices, including all matrices contained in structures and arrays they are
applied to, to all depths of nesting.
These qualifiers can be applied to other types, but will have no effect.

The *row_major* qualifier overrides only the *column_major* qualifier; other
qualifiers are inherited.
Elements within a matrix row will be contiguous in memory.

The *column_major* qualifier overrides only the *row_major* qualifier; other
qualifiers are inherited.
Elements within a matrix column will be contiguous in memory.

The *binding* qualifier specifies the uniform buffer binding point
corresponding to the uniform or shader storage block, which will be used to
obtain the values of the member variables of the block.
It is a compile-time error to specify the *binding* qualifier for the global
scope or for block member declarations.
Any uniform or shader storage block declared without a *binding* qualifier
is initially assigned to block binding point zero.
After a program is linked, the binding points used for uniform
ifdef::GLSL[and shader storage blocks]
ifdef::ESSL[(but not shader storage) blocks]
declared with or without a *binding* qualifier can be updated
by the API.

When used with {apiname},
if the *binding* qualifier is used with a uniform block or shader storage
block instanced as an array, the first element of the array takes the
specified block binding and each subsequent element takes the next
consecutive binding point.
For an array of arrays, each element (e.g. 6 elements for a[2][3]) gets a
binding point, and they are ordered per the array of array ordering
described in "`<<arrays, Arrays.>>`"

When targeting Vulkan,
if the *binding* qualifier is used with a uniform block or buffer block
instanced as an array, the entire array takes only the provided binding
number.
The next consecutive binding number is available for a different
object.
For an array of arrays, descriptor set array element numbers used
in descriptor set accesses are ordered per the array-of-array ordering
described in "`<<arrays,Arrays.>>`"

If the binding point for any uniform or shader storage block instance is
less than zero, or greater than or equal to the corresponding
implementation-dependent maximum number of buffer bindings, a compile-time
error will occur.
When the *binding* qualifier is used with a uniform or shader storage block
instanced as an array of size _N_, all elements of the array from *binding*
through _binding + N - 1_ must be within this range.
ifdef::GLSL[]
It is a compile-time or link-time error to use the same binding number for
more than one uniform block or for more than one buffer block.
endif::GLSL[]

The *set* qualifier is only available when targeting Vulkan.
It specifies the descriptor set this object belongs to.
It is {compiletimeerror} to apply *set* to a standalone qualifier, to
a member of a block, or when not targeting an API that supports descriptor sets.
It is {compiletimeerror} to apply *set* to a block qualified as *push_constant*.
By default, any non-push-constant uniform or shader storage block declared
without a *set* identifier is assigned to descriptor set 0.
Similarly, any sampler, texture, or subpass-input type declared as a uniform
without a *set* identifier is also assigned to descriptor set 0.

If applied to an object declared as an array, all elements of the array
belong to the specified *set*.

When generating SPIR-V, it is {compiletimeerror} for either the *set* or
*binding* value to exceed a front-end-configuration supplied maximum value.

When multiple arguments are listed in a *layout* declaration, the effect
will be the same as if they were declared one at a time, in order from left
to right, each in turn inheriting from and overriding the result from the
previous qualification.

For example

[source,glsl]
----
layout(row_major, column_major)
----

results in the qualification being *column_major*.
Other examples:

[source,glsl]
----
layout(shared, row_major) uniform; // default is now shared and row_major

layout(std140) uniform Transform { // layout of this block is std140
    mat4 M1;                       // row major
    layout(column_major) mat4 M2;  // column major
    mat3 N1;                       // row major
};

uniform T2 {                       // layout of this block is shared
    ...
};

layout(column_major) uniform T3 {  // shared and column major
    mat4 M3;                       // column major
    layout(row_major) mat4 m4;     // row major
    mat3 N2;                       // column major
};
----

When targeting Vulkan, the *offset* and *align* qualifiers for blocks and
block members can only be used with *uniform* and *buffer* blocks.
ifdef::GLSL[]
When not targeting Vulkan, they can only be used with blocks declared with
*std140* or *std430* layouts.
endif::GLSL[]
ifdef::ESSL[]
When not targeting Vulkan, they cannot be used with blocks or block members.
endif::ESSL[]

The *offset* qualifier can only be used on block members.
The *offset* qualifier forces the qualified member to start at or after the
specified _layout-qualifier-value_, which will be its byte offset from
the beginning of the buffer.
It is a compile-time error to have any offset, explicit or assigned, that
lies within another member of the block.
ifdef::GLSL[]
When not generating SPIR-V, it is a compile-time error to specify an offset
that is smaller than the offset of the previous member in the block.
endif::GLSL[]
Two blocks linked together in the same program with the same block name must
have the exact same set of members qualified with *offset* and their
_layout-qualifier-value_ values must be the same, or a link-time error
results.
The specified offset must be a multiple of the base alignment of the type of
the block member it qualifies, or a compile-time error results.

The *align* qualifier makes the start of each block member have a minimum
byte alignment.
It does not affect the internal layout within each member, which will still
follow the *std140* or *std430* rules.
The specified alignment must be greater than 0 and a power of 2, or a
compile-time error results.

The _actual alignment_ of a member will be the greater of the specified
*align* alignment and the standard (e.g. *std140*) base alignment for the
member's type.
The _actual offset_ of a member is computed as follows: If *offset* was
declared, start with that offset, otherwise start with the offset immediately
following the preceding member (in declaration order).
If the resulting offset is not a multiple of the _actual alignment_,
increase it to the first offset that is a multiple of the _actual
alignment_.
This results in the _actual offset_ the member will have.

When *align* is applied to an array, it affects only the start of the array,
not the array's internal stride.
Both an *offset* and an *align* qualifier can be specified on a declaration.

The *align* qualifier, when used on a block, has the same effect as
qualifying each member with the same *align* value as declared on the block,
and gets the same compile-time results and errors as if this had been done.
As described in general earlier, an individual member can specify its own
*align*, which overrides the block-level *align*, but just for that member.

Examples:

[source,glsl]
----
layout(std140) uniform block {
 vec4 a;                         // a takes offsets 0-15
 layout(offset = 32) vec3 b;     // b takes offsets 32-43
 layout(offset = 40) vec2 c;     // ERROR, lies within previous member
 layout(offset = 48) vec2 d;     // d takes offsets 48-55
 layout(align = 16) float e;     // e takes offsets 64-67
 layout(align = 2) double f;     // f takes offsets 72-79
 layout(align = 6) double g;     // ERROR, 6 is not a power of 2
 layout(offset = 80) float h;    // h takes offsets 80-83
 layout(align = 64) dvec3 i;     // i takes offsets 128-151
 layout(offset = 164, align = 8)
 float j;                        // j takes offsets 168-171
};
----


[[opaque-uniform-layout-qualifiers]]
=== Opaque Uniform Layout Qualifiers

Opaque uniform variables can take the uniform layout qualifier for binding:

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *binding* *=* _layout-qualifier-value_
--

The *binding* qualifier specifies the point where the variable will be bound.
Any opaque variable declared without a binding qualifier has a default binding
of zero.

When used with {apiname},
if the *binding* qualifier is used with an array, the first element of the
array takes the specified binding point and each subsequent element takes the
next consecutive binding point.
For an array of arrays, each element (e.g. 6 elements for a[2][3]) gets a
binding point, and they are ordered per the array of array ordering
described in "`<<arrays, Arrays.>>`"

When targeting Vulkan,
if the *binding* qualifier is used with an array, the entire array
takes only the provided binding number. The next consecutive binding
number is available for a different object.

If the *binding* is less than zero, or greater than or equal to the
implementation-dependent maximum supported number of binding points,
a compile-time error will occur.
When the *binding* qualifier is used with an array of size _N_, all elements
of the array from *binding* through _binding + N - 1_ must be within this
range.
ifdef::GLSL[]
It is a compile-time or link-time error to use the same *binding* number for
more than one atomic counter, unless the _offset_ for the atomic counters
sharing the same binding are all different.
endif::GLSL[]

A link-time error will result if two shaders in a program specify different
_layout-qualifier-value_ bindings for the same opaque-uniform name.
However, it is not an error to specify a binding on some but not all
declarations for the same name, as shown in the examples below.

[source,glsl]
----
// in one shader...
layout(binding=3) uniform sampler2D s; // s bound to point 3

// in another shader...
uniform sampler2D s;                   // okay, s still bound at 3

// in another shader...
layout(binding=4) uniform sampler2D s; // ERROR: contradictory bindings
----


[[atomic-counter-layout-qualifiers]]
=== Atomic Counter Layout Qualifiers

Atomic counters are not available when targeting Vulkan.

Atomic counter layout qualifiers can be used on atomic counter declarations or
at global scope to establish defaults.
The atomic counter qualifiers are:

[role="bnf"]
--
_layout-qualifier-id_ : ::
    *binding* *=* _layout-qualifier-value_ +
    *offset* *=* _layout-qualifier-value_
--

Each binding has a default offset that is initially 0 and is updated following
each declaration containing the type *atomic_uint*. If such a declaration does
not declare a variable then it establishes a default for the named binding. It
is a compile-time error if any such declaration does not include a _binding_
layout qualifier.

If a declaration contains an _offset_ qualifier then that offset is used in the
declaration, otherwise the default offset for the named binding is used. Each
atomic counter that is declared is assigned to the named buffer binding point,
at the current offset, and then the offset is increased by 4. Arrays of atomic
counters assign one such offset to each member, and if multiple variables are
declared in the same statement then they will have offsets assigned in order
from left to right. Having assigned offsets to variables, if any, the
binding's default offset will be set to the current offset value.

For example,

[source,glsl]
----
layout(binding = 2, offset = 4) uniform atomic_uint a;
----

will establish that the opaque handle to the atomic counter _a_ will be
bound to atomic counter buffer binding point 2 at an offset of 4 basic
machine units into that buffer.
The default _offset_ for binding point 2 will be post incremented by 4 (the
size of an atomic counter).

It is a compile-time error to bind an atomic counter with a binding value
greater than or equal to _gl_MaxAtomicCounterBindings_.
It is a compile-time error to declare an atomic counter whose offset is such
that the buffer containing it would be larger than _gl_MaxAtomicCounterBufferSize_.
It is a compile-time error to declare an atomic counter whose offset is not
aligned to a multiple of 4.
ifdef::GLSL[]
It is a compile-time error to declare an unsized array of *atomic_uint*.
endif::GLSL[]
It is a compile- or link-time error to declare two atomic counters with the same
binding and the same offset.

Examples of atomic declarations:

[source,glsl]
----
layout(binding = 2, offset = 4)  uniform atomic_uint;      // Sets binding's default
                                                           // offset = 4
layout(binding = 2)              uniform atomic_uint a;    // offset 4
layout(binding = 2)              uniform atomic_uint b;    // offset 8
layout(binding = 3)              uniform atomic_uint c[2]; // offsets 0, 4
layout(binding = 2)              uniform atomic_uint d;    // offset 12
layout(binding = 4, offset = 16) uniform atomic_uint e;    // offset 16
layout(binding = 4)              uniform atomic_uint f;    // offset 20

layout(offset = 8)              uniform atomic_uint ea;  // error, no binding
                                                         // specified
layout(binding = 2, offset = 6) uniform atomic_uint eb;  // error, offset not aligned
layout(binding = 3, offset = 4) uniform atomic_uint ec;  // error, overlaps c[1]
layout(binding = 3, offset = 4) uniform atomic_uint;     // OK, no counter declared
layout(binding = 3)             uniform atomic_uint ed;  // error, overlaps c[1]
----


[[format-layout-qualifiers]]
=== Format Layout Qualifiers

Format layout qualifiers can be used on image variable declarations (those
declared with a basic type having "`*image*`" in its keyword).
The format layout qualifier identifiers for image variable declarations are:

[role="bnf"]
--
_layout-qualifier-id_ : ::
    _float-image-format-qualifier_ +
    _int-image-format-qualifier_ +
    _uint-image-format-qualifier_ +
    *binding* *=* _layout-qualifier-value_
--

ifdef::GLSL[]
[role="bnf"]
--
_float-image-format-qualifier_ : ::
    *rgba32f* +
    *rgba16f* +
    *rg32f* +
    *rg16f* +
    *r11f_g11f_b10f* +
    *r32f* +
    *r16f* +
    *rgba16* +
    *rgb10_a2* +
    *rgba8* +
    *rg16* +
    *rg8* +
    *r16* +
    *r8* +
    *rgba16_snorm* +
    *rgba8_snorm* +
    *rg16_snorm* +
    *rg8_snorm* +
    *r16_snorm* +
    *r8_snorm*

_int-image-format-qualifier_ : ::
    *rgba32i* +
    *rgba16i* +
    *rgba8i* +
    *rg32i* +
    *rg16i* +
    *rg8i* +
    *r32i* +
    *r16i* +
    *r8i*

_uint-image-format-qualifier_ : ::
    *rgba32ui* +
    *rgba16ui* +
    *rgb10_a2ui* +
    *rgba8ui* +
    *rg32ui* +
    *rg16ui* +
    *rg8ui* +
    *r32ui* +
    *r16ui* +
    *r8ui*
--
endif::GLSL[]
ifdef::ESSL[]
[role="bnf"]
--
_float-image-format-qualifier_ : ::
    *rgba32f* +
    *rgba16f* +
    *r32f* +
    *rgba8* +
    *rgba8_snorm*

_int-image-format-qualifier_ : ::
    *rgba32i* +
    *rgba16i* +
    *rgba8i* +
    *r32i*

_uint-image-format-qualifier_ : ::
    *rgba32ui* +
    *rgba16ui* +
    *rgba8ui* +
    *r32ui*
--
endif::ESSL[]

A format layout qualifier specifies the image format associated with a
declared image variable.
Only one format qualifier may be specified for any image variable
declaration.
For image variables with floating-point component types (keywords starting
with "`*image*`"), signed integer component types (keywords starting with
"`*iimage*`"), or unsigned integer component types (keywords starting with
"`*uimage*`"), the format qualifier used must match the
_float-image-format-qualifier_, _int-image-format-qualifier_, or
_uint-image-format-qualifier_ grammar rules, respectively.
It is {compiletimeerror} to declare an image variable where the format
qualifier does not match the image variable type.

ifdef::GLSL[]
Any image variable used for image loads or atomic operations must specify a
format layout qualifier; it is a compile-time error to pass an image uniform
variable or function parameter declared without a format layout qualifier to
an image load or atomic function.

Uniforms not qualified with *writeonly* must have a format layout qualifier.
Note that an image variable passed to a function for read access cannot be
declared as *writeonly* and hence must have been declared with a format
layout qualifier.
endif::GLSL[]
ifdef::ESSL[]
Any image variable must specify a format layout qualifier.
endif::ESSL[]

The *binding* qualifier was described in
"`<<opaque-uniform-layout-qualifiers,Opaque Uniform Layout Qualifiers>>`".

=== Subpass Input Qualifier

Subpass inputs are only available when targeting Vulkan.

Subpass inputs are declared with the basic *subpassInput* types.
They must be declared with the layout qualifier
*input_attachment_index*, or {compiletimeerror} results.
For example:

[source,glsl]
----
layout(input_attachment_index = 2) uniform subpassInput t;
----

This selects which subpass input is being read from. The value assigned
to *input_attachment_index*, say _i_ (`input_attachment_index = i`), selects
that entry (_i_ th entry) in the input list for the pass.  See the API
documentation for more detail about passes and the input list.

If an array of size _N_ is declared, it consumes _N_ consecutive
*input_attachment_index* values, starting with the one provided.

It is a compile-time or link-time error to have different variables
declared with the same *input_attachment_index*.
This includes any overlap in the implicit *input_attachment_index* consumed by
array declarations.

It is {compiletimeerror} if the value assigned to an *input_attachment_index*
is greater than or equal to _gl_MaxInputAttachments_.

[[interpolation-qualifiers]]
== Interpolation Qualifiers

Inputs and outputs that could be interpolated can be further qualified by at
most one of the following interpolation qualifiers:

[options="header"]
|====
| Qualifier       | Meaning
| *smooth*        | perspective correct interpolation
| *flat*          | no interpolation
ifdef::GLSL[]
| *noperspective* | linear interpolation
endif::GLSL[]
|====

The presence of and type of interpolation is controlled by the above
interpolation qualifiers as well as the auxiliary storage qualifiers
*centroid* and *sample*.
When no interpolation qualifier is present, smooth interpolation is used.
It is a compile-time error to use more than one interpolation qualifier.
The auxiliary storage qualifier *patch* is not used for interpolation; it is
a compile-time error to use interpolation qualifiers with *patch*.

A variable qualified as *flat* will not be interpolated.
Instead, it will have the same value for every fragment within a primitive.
This value will come from a single provoking vertex, as described by the
<<references, API>>.
A variable qualified as *flat* may also be qualified as *centroid* or
*sample*, which will mean the same thing as qualifying it only as *flat*.

A variable qualified as *smooth* will be interpolated in a
perspective-correct manner over the primitive being rendered.
ifdef::GLSL[]
Interpolation in a perspective correct manner is specified in equation 14.7
of the <<references,{apispec}>>, section 14.5 "`Line Segments`".

A variable qualified as *noperspective* must be interpolated linearly in
screen space, as described in equation 3.7 of the <<references,{apispec}>>,
section 3.5 "`Line Segments`".
endif::GLSL[]
ifdef::ESSL[]
Interpolation in a perspective correct manner is specified in equations 13.4
of the <<references,{apispec}>>, section 13.4.1 "`Line Segments`" and
equation 13.7, section 13.5.1 "`Polygon Interpolation`".
endif::ESSL[]

When multisample rasterization is disabled, or for fragment shader input
variables qualified with neither *centroid* nor *sample*, the value of the
assigned variable may be interpolated anywhere within the pixel and a single
value may be assigned to each sample within the pixel, to the extent
permitted by the <<references,{apispec}>>.

When multisample rasterization is enabled, *centroid* and *sample* may be
used to control the location and frequency of the sampling of the qualified
fragment shader input.
If a fragment shader input is qualified with *centroid*, a single value may
be assigned to that variable for all samples in the pixel, but that value
must be interpolated at a location that lies in both the pixel and in the
primitive being rendered, including any of the pixel's samples covered by
the primitive.
Because the location at which the variable is interpolated may be different
in neighboring pixels, and derivatives may be computed by computing
differences between neighboring pixels, derivatives of centroid-sampled
inputs may be less accurate than those for non-centroid interpolated
variables.
If a fragment shader input is qualified with *sample*, a separate value must
be assigned to that variable for each covered sample in the pixel, and that
value must be sampled at the location of the individual sample.

ifdef::GLSL[]
It is a link-time error if, within the same stage, the interpolation
qualifiers of variables of the same name do not match.


[[redeclaring-built-in-interpolation-variables-in-the-compatibility-profile]]
=== Redeclaring Built-In Interpolation Variables in the Compatibility Profile

The following predeclared variables can be redeclared with an interpolation
qualifier when using the compatibility profile:

Vertex, tessellation control, tessellation evaluation, and geometry
languages:

[source,glsl]
----
gl_FrontColor
gl_BackColor
gl_FrontSecondaryColor
gl_BackSecondaryColor
----

Fragment language:

[source,glsl]
----
gl_Color
gl_SecondaryColor
----

For example,

[source,glsl]
----
in vec4 gl_Color;            // predeclared by the fragment language
flat in vec4 gl_Color;       // redeclared by user to be flat
flat in vec4 gl_FrontColor;  // input to geometry shader, no "gl_in[]"
flat out vec4 gl_FrontColor; // output from geometry shader
----

Ideally, these are redeclared as part of the redeclaration of an interface
block, as described in
"`<<compatibility-profile-built-in-language-variables,Compatibility Profile
Built-In Language Variables>>`".
However, for the above purpose, they can be redeclared as individual
variables at global scope, outside an interface block.
Such redeclarations also allow adding the transform-feedback qualifiers
*xfb_buffer*, *xfb_stride*, and *xfb_offset* to output variables.
(Using *xfb_buffer* on a variable does not change the global default
buffer.) A compile-time error will result if a shader has both an interface
block redeclaration and a separate redeclaration of a member of that
interface block outside the interface block redeclaration.

If _gl_Color_ is redeclared with an interpolation qualifier, then
_gl_FrontColor_ and _gl_BackColor_ (if they are written to) must also be
redeclared with the same interpolation qualifier, and vice versa.
If _gl_SecondaryColor_ is redeclared with an interpolation qualifier, then
_gl_FrontSecondaryColor_ and _gl_BackSecondaryColor _(if they are written
to) must also be redeclared with the same interpolation qualifier, and vice
versa.
This qualifier matching on predeclared variables is only required for
variables that are statically used within the shaders in a program.
endif::GLSL[]


[[parameter-qualifiers]]
== Parameter Qualifiers

In addition to precision qualifiers and memory qualifiers, parameters can
have these parameter qualifiers.

[options="header"]
|====
| Qualifier      | Meaning
|<none: default> | same as *in*
ifdef::GLSL[]
| *const*        | for function parameters that cannot be written to
endif::GLSL[]
| *in*           | for function parameters passed into a function
| *out*          | for function parameters passed back out of a function,
                   but not initialized for use when passed in
| *inout*        | for function parameters passed both into and out of a
                   function
|====

Parameter qualifiers are discussed in more detail in
"`<<function-calling-conventions,Function Calling Conventions>>`".


[[precision-and-precision-qualifiers]]
== Precision and Precision Qualifiers

ifdef::GLSL[]
When not targeting Vulkan:
Precision qualifiers are added for code portability with OpenGL ES, not for
functionality.
They have the same syntax as in OpenGL ES, as described below, but they have
no semantic meaning, which includes no effect on the precision used to store
or operate on variables.
If an extension adds in the same semantics and functionality in the OpenGL
ES 2.0 specification for precision qualifiers, then the extension is allowed
to reuse the keywords below for that purpose.
endif::GLSL[]

When targeting Vulkan:
For interface matching, uniform variables and uniform and buffer block
members must have the same precision qualification.
Global variables declared in different compilation units linked into the
same shader stage must be declared with the same precision qualification.

For the purposes of determining if an output from one shader stage matches
an input of the next stage, the precision qualifier need not match.

This specification only governs the minimum required precision for storage and
operations on values.
Implementations are free to calculate and/or store any results at higher
precisions.
If necessary, this variance can be controlled using the invariance qualifier.

[[range-and-precision]]
=== Range and Precision

The precision of *highp*
ifdef::GLSL[single- and double-precision]
floating-point variables is defined by the IEEE 754 standard for
32-bit
ifdef::GLSL[and 64-bit]
floating-point numbers.

This includes support for NaNs (Not a Number) and Infs (positive or negative
infinities) and positive and negative zeros.

The following rules apply to *highp*
ifdef::GLSL[for both single and double-precision]
operations:
Signed infinities and zeros are generated as dictated by IEEE, but subject
to the precisions allowed in the following table.
Any subnormal (denormalized) value input into a shader or potentially
generated by any operation in a shader can be flushed to 0.
The rounding mode cannot be set and is undefined but must not affect the
result by more than 1 ULP.
NaNs are not required to be generated.
Support for signaling NaNs is not required and exceptions are never raised.
Operations including built-in functions that operate on a NaN are not
required to return a NaN as the result.
However if NaNs are generated, *isnan*() must return the correct value.

Precisions are expressed in terms of maximum relative error in units of ULP
(units in the last place), unless otherwise noted.

For single precision operations, precisions are required as follows:

[options="header"]
|====
| Operation                       | Precision
| _a_ + _b_, _a_ - _b_, _a_ * _b_ | Correctly rounded.
| <, \<=, ==, >, >=               | Correct result.
| _a_ / _b_, 1.0 / _b_            | 2.5 ULP for [eq]#{vbar}b{vbar}# in the range [eq]#[2^-126^, 2^126^]#.
| _a_ * _b_ + _c_                 | Correctly rounded single operation or
                                    sequence of two correctly rounded operations.
| *fma*()                         | Inherited from _a_ * _b_ + _c_.
| *pow*(_x_, _y_)                 | Inherited from *exp2*(_y_ * *log2*(_x_)).
| *exp*(_x_), *exp2*(_x_)         | [eq]#(3 + 2 {cdot} {vert}x{vert})# ULP.
| *log*(), *log2*()               | 3 ULP outside the range [eq]#[0.5,2.0]#. +
                                    Absolute error < 2^-21^ inside the range
                                    [eq]#[0.5,2.0]#.
| *sqrt*()                        | Inherited from 1.0 / *inversesqrt*().
| *inversesqrt*()                 | 2 ULP.
| implicit and explicit
  conversions between types       | Correctly rounded.
|====

Built-in functions defined in the specification with an equation built from
the above operations inherit the above errors.
These include, for example, the geometric functions, the common functions,
and many of the matrix functions.
Built-in functions not listed above and not defined as equations of the
above have undefined precision.
These include, for example, the trigonometric functions and determinant.

ifdef::GLSL[]
The precision of double-precision operations is at least that of single
precision.
endif::GLSL[]
ifdef::ESSL[]
Storage requirements are declared through use of _precision qualifiers_.
The precision of operations must preserve the storage precisions of the
variables involved.

*highp* floating-point values are stored in IEEE 754 single precision
floating-point format.
*mediump* and *lowp* floating-point values have minimum range and precision
requirements as detailed below and have maximum range and precision as
defined by IEEE 754.

All integral types are assumed to be implemented as integers and so may not
be emulated by floating-point values.
*highp* signed integers are represented as twos-complement 32-bit signed
integers.
*highp* unsigned integers are represented as unsigned 32-bit integers.
*mediump* integers (signed and unsigned) must be represented as an integer
with between 16 and 32 bits inclusive.
*lowp* integers (signed and unsigned) must be represented as an integer with
between 9 and 32 bits inclusive.

The required ranges and precisions for precision qualifiers are:

[options="header"]
|====
| Qualifier | Floating-Point Range | Floating-Point Magnitude Range | Floating-Point Precision | Signed Integer Range | Unsigned Integer Range
| *highp*
    | Subset of IEEE-754 +
      [eq]#(-2^128^,2^128^)#
    | Subset of IEEE-754 +
      0.0, [eq]#[2^-126^,2^128^)#
    | Subset of IEEE-754 relative: +
      [eq]#2^-23^#
    | [eq]#[-2^31^,2^31^-1]#
    | [eq]#[0,2^32^-1]#
| *mediump* (minimum requirements)
    | [eq]#(-2^14^,2^14^)#
    | 0.0, [eq]#[2^-14^,2^14^)#
    | Relative: +
      [eq]#2^-10^#
    | [eq]#[-2^15^,2^15^-1]#
    | [eq]#[0,2^16^-1]#
| *lowp* (minimum requirements)
    | [eq]#(-2,2)#
    | [eq]#(2^-8^,2)#
    | Absolute: +
      [eq]#2^-8^#
    | [eq]#[-2^8^,2^8^-1]#
    | [eq]#[0,2^9^-1]#
|====

The semi-open interval notation used for the magnitude ranges means that the
lower end of the interval is included, but the upper end is excluded. Thus the
largest required magnitude is half of the relative precision less than the
value given. The largest required value for highp, for example, is [eq]#2^128^
{times} (1 - 2^-24^)#.

_Relative precision_ is defined as the worst case (i.e. largest) ratio of
the smallest step in relation to the value for all non-zero values in the
required ranges, above:

[latexmath]
++++
\begin{aligned}
    \mathit{Precision}_{relative} = {
        \left| {
            { \left| v_1 - v_2 \right| }_{min} } \over { v_1 }
        \right|
    }_{max}, &
    v_1,v_2 \neq 0, v_1 \neq v_2
\end{aligned}
++++

It is therefore twice the maximum rounding error when converting from a real
number.
Subnormal numbers may be supported and may have lower relative precision.

In addition, the range and precision of a *mediump* floating-point value
must be the same as or greater than the range and precision of a *lowp*
floating-point value.
The range and precision of a *highp* floating-point value must be the same
as or greater than the range and precision of a *mediump* floating-point
value.

The range of a *mediump* integer value must be the same as or greater than
the range of a *lowp* integer value.
The range of a *highp* integer value must be the same as or greater than the
range of a *mediump* integer value.

The actual ranges and precisions provided by an implementation can be
queried through the API.
See the <<references, normative references>> for details on how to do
this.
endif::ESSL[]


[[conversion-between-precisions]]
=== Conversion between precisions

Within the same type, conversion from a lower to a higher precision must be
exact.
When converting from a higher precision to a lower precision, if the value
is representable by the implementation of the target precision, the
conversion must also be exact.
If the value is not representable, the behavior is dependent on the type:

  * For signed and unsigned integers, the value is truncated; bits in
    positions not present in the target precision are set to zero.
    (Positions start at zero and the least significant bit is considered to
    be position zero for this purpose.)
  * For floating-point values, the value should either clamp to +Inf or
    -Inf, or to the maximum or minimum value that the implementation
    supports.
    While this behavior is implementation-dependent, it should be consistent
    for a given implementation.


[[precision-qualifiers]]
=== Precision Qualifiers

Any
ifdef::GLSL[single-precision]
floating-point, integer, or opaque-type declaration can have the type
preceded by one of these precision qualifiers:

ifdef::GLSL[]
[options="header"]
|====
| Qualifier | Meaning
| *highp*   | 32-bit two's complement for integers,
              32-bit IEEE 754 floating-point for *float*
| *mediump* | SPIR-V *RelaxedPrecision* when targeting Vulkan, otherwise none.
| *lowp*    | SPIR-V *RelaxedPrecision* when targeting Vulkan, otherwise none.
|====
endif::GLSL[]
ifdef::ESSL[]
[cols="",]
|====
| Qualifier | Meaning
| *highp*   | The variable satisfies the minimum requirements for *highp*
              described above. *highp* variables have the maximum range and
              precision available but may cause operations to run more
              slowly on some implementations.
| *mediump* | SPIR-V *RelaxedPrecision* when targeting Vulkan, otherwise
              the variable satisfies the minimum requirements for *mediump*
              described above. *mediump* variables may typically be used to
              store high dynamic range colors and low precision geometry.
| *lowp*    | SPIR-V *RelaxedPrecision* when targeting Vulkan, otherwise
              the variable satisfies the minimum requirements for *lowp*
              described above. *lowp* variables may typically be used to
              store 8-bit color values.
|====
endif::ESSL[]

For example:

[source,glsl]
----
lowp float color;
out mediump vec2 P;
lowp ivec2 foo(lowp mat3);
highp mat4 m;
----

Literal constants do not have precision qualifiers.
Neither do Boolean variables.

For this paragraph, "`operation`" includes operators, built-in functions,
and constructors, and "`operand`" includes function arguments and
constructor arguments.
The precision qualification associated with any operation is the highest
precision qualification of the operands consumed by the operation, if any
operand has an associated precision.
In cases where no operand has a precision qualifier, the precision
qualifications of the operands of the next consuming operation in the
expression will be used.
This rule can be applied recursively until a precision qualified operand is
found.
If necessary, it will also include the precision qualification of l-values
for assignments, of the declared variable for initializers, of formal
parameters for function call arguments, or of function return types for
function return values.
If the precision cannot be determined by this method e.g. if an entire
expression is composed only of operands with no precision qualifier, and the
result is not assigned or passed as an argument, then it is evaluated at the
default precision of the type or greater.
When this occurs in the fragment shader, the default precision must be
defined.

For example, consider the statements:

[source,glsl]
----
uniform highp float h1;
highp float h2 = 2.3 * 4.7; // operation and result are highp
precision
mediump float m;
m = 3.7 * h1 * h2; // all operations are highp precision
h2 = m * h1; // operation is highp precision
m = h2 - h1; // operation is highp precision
h2 = m + m; // addition and result at mediump precision
void f(highp float p);
f(3.3); // 3.3 will be passed in at highp precision
----

Precision qualifiers, as with other qualifiers, do not affect the basic type
of the variable.
In particular, there are no constructors for precision conversions;
constructors only convert types.
Similarly, precision qualifiers, as with other qualifiers, do not contribute
to function overloading based on parameter types.
As discussed in "`<<function-calling-conventions,Function Calling
Conventions>>`", function input and output is done through copies, and
therefore qualifiers do not have to match.

ifdef::ESSL[]
Precision qualifiers for outputs in one shader matched to inputs in another
shader need not match when both shaders are linked into the same program.
When both shaders are in separate programs, mismatched precision qualifiers
will result in a program interface mismatch that will result in program
pipeline validation failures, as described in section 7.4.1 "`Shader
Interface Matching`" of the <<references,{apispec}>>.
endif::ESSL[]

The precision of a variable is determined when the variable is declared and
cannot be subsequently changed.

Where the precision of a constant integral or constant floating-point
expression is not specified, evaluation is performed at *highp*.
This rule does not affect the precision qualification of the expression.

The evaluation of constant expressions must be invariant and will usually be
performed at compile time.


[[default-precision-qualifiers]]
=== Default Precision Qualifiers

The precision statement

[source,glsl]
----
precision precision-qualifier type;
----

can be used to establish a default precision qualifier.
The _type_ field can be either *int*, *float*, or any of the opaque types,
and the _precision-qualifier_ can be *lowp*, *mediump*, or *highp*.

Any other types or qualifiers will result in {compiletimeerror}.
If _type_ is *float*, the directive applies to non-precision-qualified
ifdef::GLSL[single-precision]
floating-point type (scalar, vector, and matrix) declarations.
If _type_ is *int*, the directive applies to all non-precision-qualified
integer type (scalar, vector, signed, and unsigned) declarations.
This includes global variable declarations, function return declarations,
function parameter declarations, and local variable declarations.

Non-precision qualified declarations will use the precision qualifier
specified in the most recent *precision* statement that is still in scope.
The *precision* statement has the same scoping rules as variable
declarations.
If it is declared inside a compound statement, its effect stops at the end
of the inner-most statement it was declared in.
Precision statements in nested scopes override precision statements in outer
scopes.
Multiple precision statements for the same basic type can appear inside the
same scope, with later statements overriding earlier statements within that
scope.


ifdef::GLSL[]
For any type that accepts a precision qualifier,
the default precision qualification will be *highp*.
Because all types requiring a precision qualifier have a default precision,
there are no errors for omission of a precision qualifier.
endif::GLSL[]
ifdef::ESSL[]
All languages except for the fragment language have the following
predeclared globally scoped default precision statements:

[source,glsl]
----
precision highp float;
precision highp int;
precision lowp sampler2D;
precision lowp samplerCube;
precision highp atomic_uint;
----

The fragment language has the following predeclared globally scoped default
precision statements:

[source,glsl]
----
precision mediump int;
precision lowp sampler2D;
precision lowp samplerCube;
precision highp atomic_uint;
----

The fragment language has no default precision qualifier for floating-point
types.
Hence for *float*, floating-point vector and matrix variable declarations,
either the declaration must include a precision qualifier or the default
float precision must have been previously declared.
Similarly, there is no default precision qualifier in any of the languages
for any type not listed above.
endif::ESSL[]

[[available-precision-qualifiers]]
=== Available Precision Qualifiers

The built-in macro GL_FRAGMENT_PRECISION_HIGH is defined to one:

[source,glsl]
----
#define GL_FRAGMENT_PRECISION_HIGH 1
----

This macro is available in all languages except compute.


[[variance-and-the-invariant-qualifier]]
== Variance and the Invariant Qualifier

In this section, _variance_ refers to the possibility of getting different
values from the same expression in different programs.
For example, consider the situation where two vertex shaders, in different
programs, each set _gl_Position_ with the same expression, and the input
values into that expression are the same when both shaders run.
It is possible, due to independent compilation of the two shaders, that the
values assigned to _gl_Position_ are not exactly the same when the two
shaders run.
In this example, this can cause problems with alignment of geometry in a
multi-pass algorithm.

In general, such variance between shaders is allowed.
When such variance does not exist for a particular output variable, that
variable is said to be _invariant_.


[[the-invariant-qualifier]]
=== The Invariant Qualifier

To ensure that a particular output variable is invariant, it is necessary to
use the *invariant* qualifier.
It can either be used to qualify a previously declared variable as being
invariant:

[source,glsl]
----
invariant gl_Position; // make existing gl_Position be invariant
out vec3 Color;
invariant Color;       // make existing Color be invariant
----

or as part of a declaration when a variable is declared:

[source,glsl]
----
invariant centroid out vec3 Color;
----

Only variables output from a shader can be candidates for invariance.
This includes user-defined output variables and the built-in output
variables.
As only outputs can be declared as invariant, an output from one shader
stage will still match an input of a subsequent stage without the input
being declared as invariant.

ifdef::GLSL[]
Input or output instance names on blocks are not used when redeclaring
built-in variables.
endif::GLSL[]

The *invariant* keyword can be followed by a comma separated list of
previously declared identifiers.
All uses of *invariant* must be at global scope or on block
members, and before any use of the variables being declared as invariant.

To guarantee invariance of a particular output variable across two programs,
the following must also be true:

  * The output variable is declared as invariant in both programs.
  * The same values must be input to all shader input variables consumed by
    expressions and control flow contributing to the value assigned to the
    output variable.
  * The texture formats, texel values, and texture filtering are set the
    same way for any texture function calls contributing to the value of the
    output variable.
  * All input values are all operated on in the same way.
    All operations in the consuming expressions and any intermediate
    expressions must be the same, with the same order of operands and same
    associativity, to give the same order of evaluation.
    Intermediate variables and functions must be declared as the same type
    with the same explicit or implicit precision
ifdef::GLSL[qualifiers.]
ifdef::ESSL[qualifiers and the same constant qualifiers.]
    Any control flow affecting the output value must be the same, and any
    expressions consumed to determine this control flow must also follow
    these invariance rules.
  * All the data flow and control flow leading to setting the invariant
    output variable reside in a single compilation unit.

Essentially, all the data flow and control flow leading to an invariant
output must match.

Initially, by default, all output variables are allowed to be variant.
To force all output variables to be invariant, use the pragma

[source,glsl]
----
#pragma STDGL invariant(all)
----

before all declarations in a shader.
If this pragma is used after the declaration of any variables or functions,
then the set of outputs that behave as invariant is undefined.

Generally, invariance is ensured at the cost of flexibility in optimization,
so performance can be degraded by use of invariance.
Hence, use of this pragma is intended as a debug aid, to avoid individually
declaring all output variables as invariant.


ifdef::ESSL[]
[[invariance-within-a-shader]]
=== Invariance Within a Shader

When a value is stored in a variable, it is usually assumed it will remain
constant unless explicitly changed.
However, during the process of optimization, it is possible that the
compiler may choose to recompute a value rather than store it in a register.
Since the precision of operations is not completely specified (e.g. a low
precision operation may be done at medium or high precision), it would be
possible for the recomputed value to be different from the original value.

Values are allowed to be variant within a shader.
To prevent this, the invariant qualifier or invariant pragma must be used.

Within a shader, there is no invariance for values generated by different
non-constant expressions, even if those expressions are identical.

Example 1:

[source,glsl]
----
precision mediump;
vec4 col;
vec2 a = ...
...
col = texture(tex, a);// a has a value _a1 _
...
col = texture(tex, a); // a has a value a2 where possibly a1 != a2
----

To enforce invariance in this example use:

[source,glsl]
----
#pragma STDGL invariant(all)
----

Example 2:

[source,glsl]
----
vec2 m = ...;
vec2 n = ...;
vec2 a = m + n;
vec2 b = m + n; // a and b are not guaranteed to be exactly equal
----

There is no mechanism to enforce invariance between a and b.
endif::ESSL[]


[[invariance-of-constant-expressions]]
=== Invariance of Constant Expressions

Invariance must be guaranteed for constant expressions.
A particular constant expression must evaluate to the same result if it
appears again in the same shader or a different shader.
This includes the same expression appearing in two shaders of the same
language or shaders of two different languages.

Constant expressions must evaluate to the same result when operated on as
already described above for invariant variables.
ifdef::ESSL[]
Constant expressions are not invariant with respect to equivalent
non-constant expressions, even when the *invariant* qualifier or pragma is
used.


[[invariance-of-undefined-values]]
=== Invariance of Undefined Values

Undefined values are not invariant nor can they be made invariant by use of
the invariant qualifier or pragma.
In some implementations, undefined values may cause unexpected behavior if
they are used in control-flow expressions e.g. in the following case, one,
both or neither functions may be executed and this may not be consistent
over multiple invocations of the shader:

[source,glsl]
----
int x; // undefined value
if (x == 1)
{
    f(); // Undefined whether f() is executed
}
if (x == 2)
{
    g(); // Undefined whether g() is executed.
}
----

Note that an undefined value is a value that has not been specified.
A value that has been specified but has a potentially large error due to,
for example, lack of precision in an expression, is not undefined and so can
be made invariant.
endif::ESSL[]


[[the-precise-qualifier]]
== The Precise Qualifier

Some algorithms require floating-point computations to exactly follow the
order of operations specified in the source code and to treat all operations
consistently, even if the implementation supports optimizations that could
produce nearly equivalent results with higher performance.
For example, many GL implementations support a "`multiply-add`" instruction
that can compute a floating-point expression such as

[source,glsl]
----
result = (a * b) + (c * d);
----

in two operations instead of three operations; one multiply and one
multiply-add instead of two multiplies and one add.
The result of a floating-point multiply-add might not always be identical to
first doing a multiply yielding a floating-point result and then doing a
floating-point add.
Hence, in this example, the two multiply operations would not be treated
consistently; the two multiplies could effectively appear to have differing
precisions.

The key computation that needs to be made consistent appears when
tessellating, where intermediate points for subdivision are synthesized in
different directions, yet need to yield the same result, as shown in the
diagram below.

[[img-precise]]
image::images/precise.svg[]

ifdef::ESSL[]
As stated in "`<<evaluation-of-expressions,Evaluation of Expressions>>`",
the compiler may transform expressions even if this changes the resulting
value.
endif::ESSL[]
Without any qualifiers, implementations are permitted to perform
optimizations that effectively modify the order or number of operations used
to evaluate an expression, even if those optimizations may produce slightly
different results relative to unoptimized code.

The *precise* qualifier ensures that operations contributing to a
variable's value are done in their stated order and with operator consistency.
The order is determined by operator precedence and parentheses, as described in
"`<<operators,Operators>>`".
Operator consistency means that for each operator, its result is always
computed with the same precision.
Specifically, values computed by compiler-generated code must adhere to the
following identities:

  . a + b = b + a
  . a * b = b * a
  . a * b + c * d = b * a + c* d = d * c + b * a = <any other mathematically
    valid combination>

While the following are prevented:

  . a + (b + c) is not allowed to become (a + b) + c
  . a * (b * c) is not allowed to become (a * b) * c
  . a * b + c is not allowed to become a single operation *fma*(a, b, c)

Where _a_, _b_, _c_, and _d_, are scalars or vectors, not matrices.
(Matrix multiplication generally does not commute.) It is the shader
writer's responsibility to express the computation in terms of these rules
and the compiler's responsibility to follow these rules.
See the description of _gl_TessCoord_ for the rules the tessellation stages
are responsible for following, which in conjunction with the above allow
avoiding cracking when subdividing.

For example,

[source,glsl]
----
precise out vec4 position;
----

declares that operations used to produce the value of _position_ must be
performed in exactly the order specified in the source code and with all
operators being treated consistently.
As with the *invariant* qualifier (see "`<<the-invariant-qualifier,The
Invariant Qualifier>>`"), the *precise* qualifier may be used to qualify a
built-in or previously declared user-defined variable as being precise:

[source,glsl]
----
out vec3 Color;
precise Color; // make existing Color be precise
----

When applied to a block or a variable of structure type,
*precise* applies to each contained member, recursively.

This qualifier will affect the evaluation of an r-value in a particular
function if and only if the result is eventually consumed in the same
function by an l-value qualified as *precise*.
Any other expressions within a function are not affected, including return
values and output parameters not declared as *precise* but that are
eventually consumed outside the function by a variable qualified as
*precise*. Unaffected expressions also include the controlling expressions
in selection and iteration statements and the condition in ternary
operators (*?:*).

Some examples of the use of *precise*:

[source,glsl]
----
in vec4 a, b, c, d;
precise out vec4 v;

float func(float e, float f, float g, float h)
{
    return (e*f) + (g*h); // no constraint on order or operator consistency
}

float func2(float e, float f, float g, float h)
{
    precise float result = (e*f) + (g*h); // ensures same precision for the two multiplies
    return result;
}

float func3(float i, float j, precise out float k)
{
    k = i * i + j;        // precise, due to <k> declaration
}

void main()
{
    vec3 r = vec3(a * b);             // precise, used to compute v.xyz
    vec3 s = vec3(c * d);             // precise, used to compute v.xyz
    v.xyz = r + s;                    // precise
    v.w = (a.w * b.w) + (c.w * d.w);  // precise
    v.x = func(a.x, b.x, c.x, d.x);   // values computed in func() are NOT precise
    v.x = func2(a.x, b.x, c.x, d.x);  // precise!
    func3(a.x * b.x, c.x * d.x, v.x); // precise!
}
----

For the purposes of determining if an output from one shader stage matches
an input of the next stage, the *precise* qualifier need not match between
the input and the output.

All constant expressions are evaluated as if *precise* was present, whether
or not it is present.
However, as described in "`<<constant-expressions,Constant Expressions>>`",
there is no requirement that a compile-time constant expression evaluates to
the same value as a corresponding non-constant expression.


[[memory-qualifiers]]
== Memory Qualifiers

Shader storage blocks, variables declared within shader storage blocks and
variables declared as image types (the basic opaque types with "`*image*`"
in their keyword), can be further qualified with one or more of the
following memory qualifiers:

[options="header"]
|====
| Qualifier   | Meaning
| *coherent*  | memory variable where reads and writes are coherent with
                reads and writes from other shader invocations
| *volatile*  | memory variable whose underlying value may be changed at any
                point during shader execution by some source other than the
                current shader invocation
| *restrict*  | memory variable where use of that variable is the only way
                to read and write the underlying memory in the relevant
                shader stage
| *readonly*  | memory variable that can be used to read the underlying
                memory, but cannot be used to write the underlying memory
| *writeonly* | memory variable that can be used to write the underlying
                memory, but cannot be used to read the underlying memory
|====

Memory accesses to image variables declared using the *coherent* qualifier
are performed coherently with accesses to the same location from other
shader invocations.
ifdef::GLSL[]
In particular, when reading a variable declared as *coherent*, the values
returned will reflect the results of previously completed writes performed
by other shader invocations.
When writing a variable declared as *coherent*, the values written will be
reflected in subsequent coherent reads performed by other shader
invocations.
endif::GLSL[]

As described in section
ifdef::GLSL[7.12]
ifdef::ESSL[7.11]
"`Shader Memory Access`" of the
<<references,{apispec}>>, shader memory reads and writes complete in a
largely undefined order.
The built-in function *memoryBarrier*() can be used if needed to guarantee
the completion and relative ordering of memory accesses performed by a
single shader invocation.

When accessing memory using variables not declared as *coherent*, the memory
accessed by a shader may be cached by the implementation to service future
accesses to the same address.
Memory stores may be cached in such a way that the values written may not be
visible to other shader invocations accessing the same memory.
The implementation may cache the values fetched by memory reads and return
the same values to any shader invocation accessing the same memory, even if
the underlying memory has been modified since the first memory read.
While variables not declared as *coherent* may not be useful for
communicating between shader invocations, using non-coherent accesses may
result in higher performance.

Memory accesses to image variables declared using the *volatile* qualifier
must treat the underlying memory as though it could be read or written at
any point during shader execution by some source other than the executing
shader invocation.
When a volatile variable is read, its value must be re-fetched from the
underlying memory, even if the shader invocation performing the read had
previously fetched its value from the same memory.
When a volatile variable is written, its value must be written to the
underlying memory, even if the compiler can conclusively determine that its
value will be overwritten by a subsequent write.
Since the external source reading or writing a *volatile* variable may be
another shader invocation, variables declared as *volatile* are
automatically treated as coherent.

Memory accesses to image variables declared using the *restrict* qualifier
may be compiled assuming that the variable used to perform the memory access
is the only way to access the underlying memory using the shader stage in
question.
This allows the compiler to coalesce or reorder loads and stores using
**restrict**-qualified image variables in ways that wouldn't be permitted
for image variables not so qualified, because the compiler can assume that
the underlying image won't be read or written by other code.
Applications are responsible for ensuring that image memory referenced by
variables qualified with *restrict* will not be referenced using other
variables in the same scope; otherwise, accesses to **restrict**-qualified
variables will have undefined results.

Memory accesses to image variables declared using the *readonly* qualifier
may only read the underlying memory, which is treated as read-only memory
and cannot be written to.
It is {compiletimeerror} to pass an image variable qualified with
*readonly* to *imageStore*() or other built-in functions that modify image
memory.

Memory accesses to image variables declared using the *writeonly* qualifier
may only write the underlying memory; the underlying memory cannot be read.
It is {compiletimeerror} to pass an image variable qualified with
*writeonly* to *imageLoad*() or other built-in functions that read image
memory.

A variable could be qualified as both *readonly* and *writeonly*, disallowing
both read and write. Such variables can still be used with some queries, for
example *imageSize*() and *.length*().

ifdef::ESSL[]
Except for image variables qualified with the format qualifiers *r32f*,
*r32i*, and *r32ui*, image variables must specify a memory qualifier
(*readonly*, *writeonly*, or both).
endif::ESSL[]

The memory qualifiers *coherent*, *volatile*, *restrict*, *readonly*, and
*writeonly* may be used in the declaration of buffer variables (i.e.,
members of shader storage blocks).
When a buffer variable is declared with a memory qualifier, the behavior
specified for memory accesses involving image variables described above
applies identically to memory accesses involving that buffer variable.
It is a compile-time error to assign to a buffer variable qualified with
*readonly* or to read from a buffer variable qualified with *writeonly*.
The combination *readonly* *writeonly* is allowed.

Additionally, memory qualifiers may be used at the block-level declaration
of a shader storage block, including the combination *readonly* *writeonly*.
When a block declaration is qualified with a memory qualifier, it is as if
all of its members were declared with the same memory qualifier.
For example, the block declaration

[source,glsl]
----
coherent buffer Block {
    readonly vec4 member1;
    vec4 member2;
};
----

is equivalent to

[source,glsl]
----
buffer Block {
    coherent readonly vec4 member1;
    coherent vec4 member2;
};
----

Memory qualifiers are only supported in the declarations of image variables,
buffer variables, and shader storage blocks; it is an error to use such
qualifiers in any other declarations.

When calling user-defined functions, opaque-type variables qualified with
*coherent*, *volatile*, *readonly*, or *writeonly* may not be passed to
functions whose formal parameters lack such qualifiers.
(See "`<<function-definitions,Function Definitions>>`" for more detail on
function calling.) It is legal to have any additional memory qualifiers on a
formal parameter, but only *restrict* can be taken away from an opaque-type
calling argument, by a formal parameter that lacks the *restrict* qualifier.
For non-opaque argument types, where the values operated on by the called
function are copied-in/copied-out, memory qualifiers are not required match.

When a built-in function is called, the code generated is to be based on the
actual qualification of the calling argument, not on the list of memory
qualifiers specified on the formal parameter in the prototype.

[source,glsl]
----
vec4 funcA(restrict image2D a) { ... }
vec4 funcB(image2D a) { ... }
layout(rgba32f) uniform image2D img1;
layout(rgba32f) coherent uniform image2D img2;

funcA(img1);        // OK, adding "restrict" is allowed
funcB(img2);        // illegal, stripping "coherent" is not
----

Layout qualifiers cannot be used on formal function parameters, and layout
qualification is not included in parameter matching.

Note that the use of *const* in an image variable declaration is qualifying
the const-ness of the variable being declared, not the image it refers to.
The qualifier *readonly* qualifies the image memory (as accessed through
that variable) while *const* qualifies the variable itself.


[[specialization-constant-qualifier]]
== Specialization-Constant Qualifier

Specialization constants are used only for SPIR-V and declared using the
*constant_id* layout qualifier.
For example:

[source,glsl]
----
layout(constant_id = 17) const int arraySize = 12;
----

The above makes a specialization constant with a default value of 12.
The number 17 is an example author-chosen id by which the API or other tools
can later refer to this specific specialization constant.
If it is never changed before final lowering, it will retain the value of
12.
It is a compile-time error to use the *constant_id* qualifier on anything
but SPIR-V generation of a scalar *bool*, *int*, *uint*, *float*, or
*double*.

Built-in constants can be declared to be specialization constants.
For example:

[source,glsl]
----
layout(constant_id = 31) gl_MaxClipDistances; // add specialization_id
----

The declaration uses just the name of the previously declared built-in
variable, with a *constant_id* layout-qualifier declaration.
It is a compile-time error to do this after the constant has been used:
Constants are strictly either non-specialization constants or specialization
constants, not both.

The built-in constant vector _gl_WorkGroupSize_ can be specialized using the
*local_size_\{xyz}_id* qualifiers, to individually give the components an id.
For example:

[source,glsl]
----
layout(local_size_x_id = 18, local_size_z_id = 19) in;
----

This leaves _gl_WorkGroupSize.y_ as a non-specialization constant, with
_gl_WorkGroupSize_ being a partially specialized vector.
Its _x_ and _z_ components can be later specialized, after generating
SPIR-V, using the ids 18 and 19.
These ids are declared independently from declaring the workgroup size:

[source,glsl]
----
layout(local_size_x = 32, local_size_y = 32) in;   // size is (32,32,1)
layout(local_size_x_id = 18) in;                   // constant_id for x
layout(local_size_z_id = 19) in;                   // constant_id for z
----

Existing rules for declaring *local_size_x*, *local_size_y*, and
*local_size_z* are not changed.
For the local-size ids, it is a compile-time error to provide different id
values for the same local-size id, or to provide them after any use.
Otherwise, order, placement, number of statements, and replication do not
cause errors.

Two arrays sized with specialization constants are the same type only if
sized with the same symbol, and involving no operations.
For example:

[source,glsl]
----
layout(constant_id = 51) const int aSize = 20;
const int pad = 2;
const int total = aSize + pad; // specialization constant
int a[total], b[total];        // a and b have the same type
int c[22];                     // different type than a or b
int d[aSize + pad];            // different type than a, b, or c
int e[aSize + 2];              // different type than a, b, c, or d
----

Types containing arrays sized with a specialization constant cannot be
compared, assigned as aggregates, declared with an initializer, or used as
an initializer.
They can, however, be passed as arguments to functions having formal
parameters of the same type.
Only the outer-most dimension of a variable declared as an array of arrays
can be a specialization constant, otherwise a compile-time error results.

Arrays inside a block may be sized with a specialization constant, but the
block will have a static layout.
Changing the specialized size will not re-layout the block.
In the absence of explicit offsets, the layout will be based on the default
size of the array.


[[order-of-qualification]]
== Order and Repetition of Qualification

When multiple qualifiers are present in a declaration, they may appear in
any order, but they must all appear before the type.
The *layout* qualifier is the only qualifier that can appear more than once.
Further, a declaration can have at most one storage qualifier, at most one
auxiliary storage qualifier, and at most one interpolation qualifier.
ifdef::GLSL[If *inout* is used, neither *in* nor *out* may be used.]
Multiple memory qualifiers can be used.
Any violation of these rules will cause a compile-time error.


[[empty-declarations]]
== Empty Declarations

_Empty declarations_ are declarations without a variable name, meaning no
object is instantiated by the declaration.
Generally, empty declarations are allowed.
Some are useful when declaring structures, while many others have no effect.
For example:

[source,glsl]
----
int;               // No effect
struct S {int x;}; // Defines a struct S
----

The combinations of qualifiers that cause compile-time or link-time errors
are the same whether or not the declaration is empty, for example:

[source,glsl]
----
invariant in float x; // Error. An input cannot be invariant.
invariant in float;   // Error even though no variable is declared.
----

// Copyright 2008-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0
// chapters/operators.adoc
[[operators-and-expressions]]
= Operators and Expressions
<<toc>>


[[operators]]
== Operators

The {slname} has the following operators.

[options="header"]
|====
| Precedence   | Operator Class                 | Operators     | Associativity
| 1 (highest)  | parenthetical grouping         | ( )           | NA
| 2            | array subscript +
                 function call and constructor structure +
                 field or method selector, swizzle +
                 post fix increment and decrement
                                                | [ ] +
                                                  ( ) +
                                                  . +
                                                  ++ pass:[--]  | Left to Right
| 3            | prefix increment and decrement +
                 unary                          | ++ pass:[--] +
                                                  + - ~ !       | Right to Left
| 4            | multiplicative                 | * / %         | Left to Right
| 5            | additive                       | + -           | Left to Right
| 6            | bit-wise shift                 | << >>         | Left to Right
| 7            | relational                     | < > \<= >=    | Left to Right
| 8            | equality                       | == !=         | Left to Right
| 9            | bit-wise and                   | &             | Left to Right
| 10           | bit-wise exclusive or          | ^             | Left to Right
| 11           | bit-wise inclusive or          | \|            | Left to Right
| 12           | logical and                    | &&            | Left to Right
| 13           | logical exclusive or           | ^^            | Left to Right
| 14           | logical inclusive or           | \|\|          | Left to Right
| 15           | selection                      | ? :           | Right to Left
| 16           | Assignment +
                 arithmetic assignments         | = +
                                                  += -= +
                                                  *= /= +
                                                  %= <\<= >>= +
                                                  &= ^= \|=     | Right to Left
| 17 (lowest)  | sequence                       | ,             | Left to Right
|====

There is no address-of operator nor a dereference operator.
There is no typecast operator; constructors are used instead.


[[array-operations]]
== Array Operations

These are now described in "`<<structure-and-array-operations,Structure and
Array Operations>>`".


[[function-calls]]
== Function Calls

If a function returns a value, then a call to that function may be used as
an expression, whose type will be the type that was used to declare or
define the function.

Function definitions and calling conventions are discussed in
"`<<function-definitions,Function Definitions>>`".


[[constructors]]
== Constructors

Constructors use the function call syntax, where the function name is a
type, and the call makes an object of that type.
Constructors are used the same way in both initializers and expressions.
(See "`<<shading-language-grammar,Shading Language Grammar>>`" for details.)
The parameters are used to initialize the constructed value.
Constructors can be used to request a data type conversion to change from
one scalar type to another scalar type, or to build larger types out of
smaller types, or to reduce a larger type to a smaller type.

In general, constructors are not built-in functions with predetermined
prototypes.
For arrays and structures, there must be exactly one argument in the
constructor for each element or member.
For the other types, the arguments must provide a sufficient number of
components to perform the initialization, and it is {compiletimeerror} to
include so many arguments that they cannot all be used.
Detailed rules follow.
The prototypes actually listed below are merely a subset of examples.


[[conversion-and-scalar-constructors]]
=== Conversion and Scalar Constructors

Converting between scalar types is done as the following prototypes
indicate:

ifdef::GLSL[]
[source,glsl]
----
int(uint)     // converts an unsigned integer to a signed integer
int(bool)     // converts a Boolean value to an int
int(float)    // converts a float value to an int
int(double)   // converts a double value to a signed integer
uint(int)     // converts a signed integer value to an unsigned integer
uint(bool)    // converts a Boolean value to an unsigned integer
uint(float)   // converts a float value to an unsigned integer
uint(double)  // converts a double value to an unsigned integer
bool(int)     // converts a signed integer value to a Boolean
bool(uint)    // converts an unsigned integer value to a Boolean value
bool(float)   // converts a float value to a Boolean
bool(double)  // converts a double value to a Boolean
float(int)    // converts a signed integer value to a float
float(uint)   // converts an unsigned integer value to a float value
float(bool)   // converts a Boolean value to a float
float(double) // converts a double value to a float
double(int)   // converts a signed integer value to a double
double(uint)  // converts an unsigned integer value to a double
double(bool)  // converts a Boolean value to a double
double(float) // converts a float value to a double
----
endif::GLSL[]
ifdef::ESSL[]
[source,glsl]
----
int(uint)     // converts an unsigned integer to a signed integer
int(bool)     // converts a Boolean value to an int
int(float)    // converts a float value to an int
uint(int)     // converts a signed integer value to an unsigned integer
uint(bool)    // converts a Boolean value to an unsigned integer
uint(float)   // converts a float value to an unsigned integer
bool(int)     // converts a signed integer value to a Boolean
bool(uint)    // converts an unsigned integer value to a Boolean value
bool(float)   // converts a float value to a Boolean
float(int)    // converts a signed integer value to a float
float(uint)   // converts an unsigned integer value to a float value
float(bool)   // converts a Boolean value to a float
----
endif::ESSL[]

When constructors are used to convert a floating-point type to an integer
type, the fractional part of the floating-point value is dropped.
It is undefined to convert a negative floating-point value to an *uint*.

Integer values having more bits of precision than a single-precision
floating-point mantissa will lose precision when converted to *float*.

When a constructor is used to convert any integer or floating-point type to
a *bool*, 0 and 0.0 are converted to *false*, and non-zero values are
converted to *true*.
When a constructor is used to convert a *bool* to any integer or
floating-point type, *false* is converted to 0 or 0.0, and *true* is
converted to 1 or 1.0.

The constructor *int*(*uint*) preserves the bit pattern in the argument,
which will change the argument's value if its sign bit is set.
The constructor *uint*(*int*) preserves the bit pattern in the argument,
which will change its value if it is negative.

Identity constructors, like *float*(*float*) are also legal, but of little
use.

Scalar constructors with non-scalar parameters can be used to take the first
element from a non-scalar.
For example, the constructor *float*(*vec3*) will select the first component
of the *vec3* parameter.


[[vector-and-matrix-constructors]]
=== Vector and Matrix Constructors

Constructors can be used to create vectors or matrices from a set of
scalars, vectors, or matrices.
This includes the ability to shorten vectors.

If there is a single scalar parameter to a vector constructor, it is used to
initialize all components of the constructed vector to that scalar's value.
If there is a single scalar parameter to a matrix constructor, it is used to
initialize all the components on the matrix's diagonal, with the remaining
components initialized to 0.0.

If a vector is constructed from multiple scalars, one or more vectors, or
one or more matrices, or a mixture of these, the vector's components will be
constructed in order from the components of the arguments.
The arguments will be consumed left to right, and each argument will have
all its components consumed, in order, before any components from the next
argument are consumed.
Similarly for constructing a matrix from multiple scalars or vectors, or a
mixture of these.
Matrix components will be constructed and consumed in column major order.
In these cases, there must be enough components provided in the arguments to
provide an initializer for every component in the constructed value.
It is {compiletimeerror} to provide extra arguments beyond this last used
argument.

If a matrix is constructed from a matrix, then each component (column _i_,
row _j_) in the result that has a corresponding component (column _i_, row
_j_) in the argument will be initialized from there.
All other components will be initialized to the identity matrix.
If a matrix argument is given to a matrix constructor, it is
{compiletimeerror} to have any other arguments.

If the basic type (*bool*, *int*,
ifdef::GLSL[*float*, or *double*)]
ifdef::ESSL[or *float*)]
of a parameter to a
constructor does not match the basic type of the object being constructed,
the scalar construction rules (above) are used to convert the parameters.

Some useful vector constructors are as follows:

[source,glsl]
----
vec3(float)          // initializes each component of the vec3 with the float
vec4(ivec4)          // makes a vec4 with component-wise conversion
vec4(mat2)           // the vec4 is column 0 followed by column 1
vec2(float, float)   // initializes a vec2 with 2 floats
ivec3(int, int, int) // initializes an ivec3 with 3 ints
bvec4(int, int, float, float) // uses 4 Boolean conversions
vec2(vec3)           // drops the third component of a vec3
vec3(vec4)           // drops the fourth component of a vec4
vec3(vec2, float)    // vec3.x = vec2.x, vec3.y = vec2.y, vec3.z = float
vec3(float, vec2)    // vec3.x = float, vec3.y = vec2.x, vec3.z = vec2.y
vec4(vec3, float)
vec4(float, vec3)
vec4(vec2, vec2)
----

Some examples of these are:

[source,glsl]
----
vec4 color = vec4(0.0, 1.0, 0.0, 1.0);
vec4 rgba = vec4(1.0);      // sets each component to 1.0
vec3 rgb = vec3(color);     // drop the 4th component
----

To initialize the diagonal of a matrix with all other elements set to zero:

[source,glsl]
----
mat2(float)
mat3(float)
mat4(float)
----

That is, _result[i][j]_ is set to the _float_ argument for all latexmath:[i
= j] and set to 0 for all latexmath:[i \neq j].

To initialize a matrix by specifying vectors or scalars, the components are
assigned to the matrix elements in column-major order.

[source,glsl]
----
mat2(vec2, vec2);                 // one column per argument
mat3(vec3, vec3, vec3);           // one column per argument
mat4(vec4, vec4, vec4, vec4);     // one column per argument
mat3x2(vec2, vec2, vec2);         // one column per argument
ifdef::GLSL[]
dmat2(dvec2, dvec2);
dmat3(dvec3, dvec3, dvec3);
dmat4(dvec4, dvec4, dvec4, dvec4);
endif::GLSL[]
mat2(float, float,                // first column
     float, float);               // second column
mat3(float, float, float,         // first column
     float, float, float,         // second column
     float, float, float);        // third column
mat4(float, float, float, float,  // first column
     float, float, float, float,  // second column
     float, float, float, float,  // third column
     float, float, float, float); // fourth column
mat2x3(vec2, float,               // first column
       vec2, float);              // second column
ifdef::GLSL[]
dmat2x4(dvec3, double,            // first column
        double, dvec3);           // second column
endif::GLSL[]
----

A wide range of other possibilities exist, to construct a matrix from
vectors and scalars, as long as enough components are present to initialize
the matrix.
To construct a matrix from a matrix:

[source,glsl]
----
mat3x3(mat4x4); // takes the upper-left 3x3 of the mat4x4
mat2x3(mat4x2); // takes the upper-left 2x2 of the mat4x4, last row is 0,0
mat4x4(mat3x3); // puts the mat3x3 in the upper-left, sets the lower right
                // component to 1, and the rest to 0
----


[[structure-constructors]]
=== Structure Constructors

Once a structure is defined, and its type is given a name, a constructor is
available with the same name to construct instances of that structure.
For example:

[source,glsl]
----
struct light {
    float intensity;
    vec3 position;
};

light lightVar = light(3.0, vec3(1.0, 2.0, 3.0));
----

The arguments to the constructor will be used to set the structure's
members, in order, using one argument per member.
Each argument must be the same type as the member it
ifdef::ESSL[sets.]
ifdef::GLSL[]
sets, or be a type that can be converted to the member's type according to
section "`<<implicit-conversions,Implicit Conversions>>`".
endif::GLSL[]

Structure constructors can be used as initializers or in expressions.


[[array-constructors]]
=== Array Constructors

Array types can also be used as constructor names, which can then be used in
expressions or initializers.
For example,

[source,glsl]
----
const float c[3] = float[3](5.0, 7.2, 1.1);
const float d[3] = float[](5.0, 7.2, 1.1);

float g;
...
float a[5] = float[5](g, 1, g, 2.3, g);
float b[3];

b = float[3](g, g + 1.0, g + 2.0);
----

There must be exactly the same number of arguments as the size of the array
being constructed.
If no size is present in the constructor, then the array is explicitly sized
to the number of arguments provided.
The arguments are assigned in order, starting at element 0, to the elements
of the constructed array.
Each argument must be the same type as the element type of the
ifdef::ESSL[array.]
ifdef::GLSL[]
array, or be
a type that can be converted to the element type of the array according to
"`<<implicit-conversions,Implicit Conversions>>`".
endif::GLSL[]

Arrays of arrays are similarly constructed, and the size for any dimension
is optional:

[source,glsl]
----
vec4 b[2] = ...;
vec4[3][2](b, b, b);    // constructor
vec4[][2](b, b, b);     // constructor, valid, size deduced
vec4[3][](b, b, b);     // constructor, valid, size deduced
vec4[][](b, b, b);      // constructor, valid, both sizes deduced
----

=== Texture-Combined Sampler Constructors

Texture-combined sampler constructors are only available when targeting Vulkan.

Texture-combined sampler types, like *sampler2D*, can be declared with an
initializer
that is a constructor of the same type, and consuming a texture and a
*sampler* or *samplerShadow*.
For example:

[source,glsl]
----
    layout(...) uniform sampler s;   // handle to filtering information
    layout(...) uniform texture2D t; // handle to a texture
    layout(...) in vec2 tCoord;
    ...
    texture(sampler2D(t, s), tCoord);
----

The result of a texture-combined sampler constructor cannot be assigned to a
variable:

[source,glsl]
----
    ... sampler2D sConstruct = sampler2D(t, s);  // ERROR
----

Texture-combined sampler constructors can only be consumed by a function parameter.

Texture-combined sampler constructors of arrays are illegal:

[source,glsl]
----
    layout(...) uniform texture2D tArray[6];
    ...
    ... sampler2D[](tArray, s) ...  // ERROR
----

Formally:

- every texture-combined sampler type can be used as a constructor
- the type of the constructor must match the type of the variable being declared
- the constructor's first argument must be a texture type
- the constructor's second argument must be a scalar of type *sampler*
  or *samplerShadow*
- the dimensionality (1D, 2D, 3D, Cube, Rect, Buffer, MS, and Array)
  of the texture type must match that of the constructed type
  (that is, the suffixes of the type of the first argument and the
  type of the constructor will be spelled the same way)
- there is no control flow construct (e.g., `?:`) that consumes any sampler type

Note: Shadow mismatches are allowed between constructors and the second argument.
Texture-combined non-shadow samplers can be constructed from *samplerShadow* and
texture-combined shadow samplers can be constructed from *sampler*.

[[vector-components]]
ifdef::GLSL[]
== Vector and Scalar Components and Length
endif::GLSL[]
ifdef::ESSL[]
== Vector Components
endif::ESSL[]

The names of the components of a vector
ifdef::GLSL[or scalar]
are denoted by a single letter.
As a notational convenience, several letters are associated with each
component based on common usage of position, color or texture coordinate
vectors.
The individual components can be selected by following the variable name
with period (*.*) and then the component name.

The component names supported are:

[%autowidth]
|====
| _{ x, y, z, w }_ |
    Useful when accessing vectors that represent points or normals
| _{ r, g, b, a }_ |
    Useful when accessing vectors that represent colors
| _{ s, t, p, q }_ |
    Useful when accessing vectors that represent texture coordinates
|====

The component names _x_, _r_, and _s_ are, for example, synonyms for the
same (first) component in a vector.
ifdef::GLSL[They are also the names of the only component in a scalar.]

Note that the third component of the texture coordinate set
has been renamed _p_ so as to avoid the confusion with _r_ (for
red) in a color.

Accessing components beyond those declared for the type is
{compiletimeerror} so, for example:

ifdef::GLSL[]
[source,glsl]
----
vec2 pos;
float height;
pos.x       // is legal
pos.z       // is illegal
height.x    // is legal
height.y    // is illegal
----
endif::GLSL[]
ifdef::ESSL[]
[source,glsl]
----
vec2 pos;
pos.x       // is legal
pos.z       // is illegal
----
endif::ESSL[]

The component selection syntax allows multiple components to be selected by
appending their names (from the same name set) after the period (*.*).

[source,glsl]
----
vec4 v4;
v4.rgba;    // is a vec4 and the same as just using v4,
v4.rgb;     // is a vec3,
v4.b;       // is a float,
v4.xy;      // is a vec2,
v4.xgba;    // is illegal - the component names do not come from the same set
----

No more than 4 components can be selected.

[source,glsl]
----
vec4 v4;
v4.xyzwxy;      // is illegal since it has 6 components
(v4.xyzwxy).xy; // is illegal since the intermediate value has 6
components
----

The order of the components can be different to swizzle them, or replicated:

[source,glsl]
----
vec4 pos = vec4(1.0, 2.0, 3.0, 4.0);
vec4 swiz = pos.wzyx;   // swiz = (4.0, 3.0, 2.0, 1.0)
vec4 dup = pos.xxyy;    // dup = (1.0, 1.0, 2.0, 2.0)
----

This notation is more concise than the constructor syntax.
To form an r-value, it can be applied to any expression that results in a
ifdef::GLSL[vector or scalar r-value.]
ifdef::ESSL[vector r-value.]

The component group notation can occur on the left hand side of an
expression.

[source,glsl]
----
vec4 pos = vec4(1.0, 2.0, 3.0, 4.0);
pos.xw = vec2(5.0, 6.0);        // pos = (5.0, 2.0, 3.0, 6.0)
pos.wx = vec2(7.0, 8.0);        // pos = (8.0, 2.0, 3.0, 7.0)
pos.xx = vec2(3.0, 4.0);        // illegal - 'x' used twice
pos.xy = vec3(1.0, 2.0, 3.0);   // illegal - mismatch between vec2 and vec3
----

To form an l-value, swizzling must further be applied to an l-value and
contain no duplicate components. It results in an l-value of scalar or
vector type, depending on number of components specified.

Array subscripting syntax can also be applied to vectors (but not to
scalars) to provide numeric indexing.
So in

[source,glsl]
----
vec4 pos;
----

_pos[2]_ refers to the third element of _pos_ and is equivalent to _pos.z_.
This allows variable indexing into a vector, as well as a generic way of
accessing components.
Any integer expression can be used as the subscript.
The first component is at index zero.
Reading from or writing to a vector using a constant integral expression
with a value that is negative or greater than or equal to the size of the
vector results in {compiletimeerror}.
When indexing with non-constant expressions, behavior is undefined if the
index is negative, or greater than or equal to the size of the vector.

ifdef::ESSL[]
Note that scalars are not considered to be single-component vectors and
therefore the use of component selection operators on scalars is illegal.
endif::ESSL[]

ifdef::GLSL[]
The *length*() method may be applied to vectors (but not scalars).
The result is the number of components in the vector.
For example,

[source,glsl]
----
vec3 v;
const int L = v.length();
----

sets the constant _L_ to 3.
The type returned by *.length*() on a vector is *int*, and the value
returned is a constant expression.
endif::GLSL[]


[[matrix-components]]
== Matrix Components

The components of a matrix can be accessed using array subscripting syntax.
Applying a single subscript to a matrix treats the matrix as an array of
column vectors, and selects a single column, whose type is a vector of the
same size as the (column size of the) matrix.
The leftmost column is column 0.
A second subscript would then operate on the resulting vector, as defined
earlier for vectors.
Hence, two subscripts select a column and then a row.

[source,glsl]
----
mat4 m;
m[1] = vec4(2.0);   // sets the second column to all 2.0
m[0][0] = 1.0;      // sets the upper left element to 1.0
m[2][3] = 2.0;      // sets the 4th element of the third column to 2.0
----

Behavior is undefined when accessing a component outside the bounds of a
matrix with a non-constant expression.
It is {compiletimeerror} to access a matrix with a constant expression
that is outside the bounds of the matrix.

ifdef::GLSL[]
The *length*() method may be applied to matrices.
The result is the number of columns of the matrix.
For example,

[source,glsl]
----
mat3x4 v;
const int L = v.length();
----

sets the constant _L_ to 3.
The type returned by *.length*() on a matrix is *int*, and the value
returned is a constant expression.
endif::GLSL[]


[[structure-and-array-operations]]
== Structure and Array Operations

The members of a structure and the *length*() method of an array are
selected using the period (*.*).

In total, only the following operators are allowed to operate on arrays and
structures as whole entities:

[%autowidth]
|====
| field selector         | *.*
| equality               | *==* *!=*
| assignment             | *=*
| Ternary operator       | *?:*
| Sequence operator      | *,*
| indexing (arrays only) | *[* *]*
|====

The equality operators and assignment operator are only allowed if the two
operands are same size and type.
The operands cannot contain any opaque types.
Structure types must be of the same declared structure.
Both array operands must be
ifdef::GLSL[explicitly]
ifdef::ESSL[compile-time]
sized.
When using the equality operators, two structures are equal if and only if
all the members are component-wise equal, and two arrays are equal if and
only if all the elements are element-wise equal.

Array elements are accessed using the array subscript operator (*[ ]*).
An example of accessing an array element is

[source,glsl]
----
diffuseColor += lightIntensity[3] * NdotL;
----

Array indices start at zero.
Array elements are accessed using an expression whose type is *int* or
*uint*.

Behavior is undefined if a shader subscripts an array with an index less
than 0 or greater than or equal to the size the array was declared with.

Arrays can also be accessed with the method operator (*.*) and the *length*
method to query the size of the array:

[source,glsl]
----
lightIntensity.length() // return the size of the array
----


[[assignments]]
== Assignments

Assignments of values to variable names are done with the assignment
operator (*=*):

{empty}:: _lvalue-expression_ = _rvalue-expression_

The _lvalue-expression_ evaluates to an l-value.
The assignment operator stores the value of _rvalue-expression_ into the
l-value and returns an r-value with the type and precision of
_lvalue-expression_.
The _lvalue-expression_ and _rvalue-expression_ must have the same
ifdef::GLSL[]
type, or the expression must have a type in the table in section
"`<<implicit-conversions,Implicit Conversions>>`" that converts to the type
of _lvalue-expression_, in which case an implicit conversion will be done on
the _rvalue-expression_ before the assignment is done.
Any other desired type-conversions must be specified explicitly via a
constructor.
endif::GLSL[]
ifdef::ESSL[]
type.
Any type-conversions must be specified explicitly via constructors.
endif::ESSL[]
It is {compiletimeerror} if the l-value is not writable.
Variables that are built-in types, entire structures or arrays, structure
members, l-values with the field selector (*.*) applied to select components
or swizzles without repeated fields, l-values within parentheses, and
l-values dereferenced with the array subscript operator (*[ ]*) are all
l-values.
Other binary or unary expressions, function names, swizzles with repeated
fields, and constants cannot be l-values.
The ternary operator (*?:*) is also not allowed as an l-value.
Using an incorrect expression as an l-value results in {compiletimeerror}.

Expressions on the left of an assignment are evaluated before expressions on
the right of the assignment.

The other assignment operators are

  * add into (*+=*)
  * subtract from (*-=*)
  * multiply into (**=*)
  * divide into (*/=*)
  * modulus into (*%=*)
  * left shift by (*<\<=*)
  * right shift by (*>>=*)
  * and into (*&=*)
  * inclusive-or into (*|=*)
  * exclusive-or into (*^=*)

where the general expression

{empty}:: _lvalue_ _op_= _expression_

is equivalent to

{empty}:: _lvalue_ = _lvalue_ _op_ _expression_

where _lvalue_ is the value returned by _lvalue-expression_, _op_ is as
described below, and the _lvalue-expression_ and _expression_ must satisfy
the semantic requirements of both _op_ and equals (*=*).

Reading a variable before writing (or initializing) it is legal, however the
value is undefined.


[[expressions]]
== Expressions

Expressions in the shading language are built from the following:

  * Constants of type *bool*, all integral types, all floating-point types,
    all vector types, and all matrix types.
  * Constructors of all types.
  * Variable names of all types.
ifdef::GLSL[]
  * An array, vector, or matrix expression with the *length*() method
    applied.
endif::GLSL[]
ifdef::ESSL[]
  * Arrays with the length method applied.
endif::ESSL[]
  * Subscripted arrays.
  * Function calls that return values.
    In some cases, function calls returning *void* are also allowed in
    expressions as specified below.
  * Component field selectors and array subscript results.
  * Parenthesized expressions.
    Any expression, including expressions with void type can be
    parenthesized.
    Parentheses can be used to group operations.
    Operations within parentheses are done before operations across
    parentheses.
  * The arithmetic binary operators add (*+*), subtract (*-*), multiply
    (***), and divide (*/*) operate on integer and floating-point scalars,
    vectors, and matrices.
ifdef::GLSL[]
    If the fundamental types in the operands do not match, then the
    conversions from "`<<implicit-conversions,Implicit Conversions>>`" are
    applied to create matching types.
endif::GLSL[]
ifdef::ESSL[]
    If the operands are integral types, they must both be signed or both be
    unsigned.
endif::ESSL[]
    All arithmetic binary operators result in the same fundamental type
ifdef::GLSL[]
    (signed integer, unsigned integer, single-precision floating-point, or
    double-precision floating-point) as the operands they operate on, after
    operand type conversion.
    After conversion, the following cases are valid
endif::GLSL[]
ifdef::ESSL[]
    (signed integer, unsigned integer, or floating-point) as the operands
    they operate on.
    The following cases are valid
endif::ESSL[]
  ** The two operands are scalars.
     In this case the operation is applied, resulting in a scalar.
  ** One operand is a scalar, and the other is a vector or matrix.
     In this case, the scalar operation is applied independently to each
     component of the vector or matrix, resulting in the same size vector or
     matrix.
  ** The two operands are vectors of the same size.
     In this case, the operation is done component-wise resulting in the
     same size vector.
  ** The operator is add (*+*), subtract (*-*), or divide (*/*), and the
     operands are matrices with the same number of rows and the same number
     of columns.
     In this case, the operation is done component-wise resulting in the
     same size matrix.
  ** The operator is multiply (*\**), where both operands are matrices or one
     operand is a vector and the other a matrix.
     A right vector operand is treated as a column vector and a left vector
     operand as a row vector.
     In all these cases, it is required that the number of columns of the
     left operand is equal to the number of rows of the right operand.
     Then, the multiply (***) operation does a linear algebraic multiply,
     yielding an object that has the same number of rows as the left operand
     and the same number of columns as the right operand.
     "`<<vector-and-matrix-operations,Vector and Matrix Operations>>`"
     explains in more detail how vectors and matrices are operated on.
+
--
All other cases result in {compiletimeerror}.

Use the built-in functions *dot*, *cross*, *matrixCompMult*, and
*outerProduct*, to get, respectively, vector dot product, vector cross
product, matrix component-wise multiplication, and the matrix product of a
column vector times a row vector.
--
  * The operator modulus (*%*) operates on signed or unsigned integers or
    integer vectors.
ifdef::GLSL[]
    If the fundamental types in the operands do not match, then the
    conversions from "`<<implicit-conversions,Implicit Conversions>>`" are
    applied to create matching types.
endif::GLSL[]
ifdef::ESSL[]
    The operand types must both be signed or both be unsigned.
endif::ESSL[]
    The operands cannot be vectors of differing size; this is
    {compiletimeerror}.
    If one operand is a scalar and the other vector, then the scalar is
    applied component-wise to the vector, resulting in the same type as the
    vector.
    If both are vectors of the same size, the result is computed
    component-wise.
    The resulting value is undefined for any component computed with a
    second operand that is zero, while results for other components with
    non-zero second operands remain defined.
    If both operands are non-negative, then the remainder is non-negative.
    Results are undefined if one or both operands are negative.
    The operator modulus (*%*) is not defined for any other data types
    (non-integer types).
  * The arithmetic unary operators plus (*pass:[+]*), negate (*-*), post-
    and pre-increment and decrement (*--* and *pass:[++]*) operate on
    integer or floating-point values (including vectors and matrices).
    All unary operators work component-wise on their operands.
    These result with the same type they operated on.
    For post- and pre-increment and decrement, the expression must be a writable
    l-value.
    Pre-increment and pre-decrement add or subtract 1 or 1.0 to the contents
    of the expression they operate on, and the value of the pre-increment or
    pre-decrement expression is the resulting value of that modification.
    Post-increment and post-decrement expressions add or subtract 1 or 1.0
    to the contents of the expression they operate on, but the resulting
    expression has the expression's value before the post-increment or
    post-decrement was executed.
  * The relational operators greater than (*>*), less than (*<*), greater
    than or equal (*>=*), and less than or equal (*\<=*) operate only on
    scalar integer and scalar floating-point expressions.
    The result is scalar Boolean.
ifdef::GLSL[]
    Either the operands' types must match, or the conversions from section
    "`<<implicit-conversions,Implicit Conversions>>`" will be applied to
    obtain matching types.
endif::GLSL[]
ifdef::ESSL[]
    The types of the operands must match.
endif::ESSL[]
    To do component-wise relational comparisons on vectors, use the built-in
    functions *lessThan*, *lessThanEqual*, *greaterThan*, and
    *greaterThanEqual.*
  * The equality operators equal (*==*), and not equal (*!=*) operate on
ifdef::GLSL[]
    all types except opaque types, aggregates that contain opaque types,
    subroutine uniforms, and aggregates that contain subroutine uniforms.
endif::GLSL[]
ifdef::ESSL[]
    all types except opaque types.
endif::ESSL[]
    They result in a scalar Boolean.
ifdef::GLSL[]
    If the operand types do not match, then there must be a conversion from
    "`<<implicit-conversions,Implicit Conversions>>`" applied to one operand
    that can make them match, in which case this conversion is done.
endif::GLSL[]
ifdef::ESSL[]
    The types of the operands must match.
endif::ESSL[]
    For vectors, matrices, structures, and arrays, all components, members,
    or elements of one operand must equal the corresponding components,
    members, or elements in the other operand for the operands to be
    considered equal.
    To get a vector of component-wise equality results for vectors, use the
    built-in functions *equal* and *notEqual*.
  * The logical binary operators and (*&&*), or (*||*), and exclusive or
    (*^^*) operate only on two scalar Boolean expressions. The result is a
    scalar Boolean.
    And (*&&*) will only evaluate the right hand operand if the left hand
    operand evaluated to *true*.
    Or (*||*) will only evaluate the right hand operand if the left hand
    operand evaluated to *false*.
    Exclusive or (*^^*) will always evaluate both operands.
  * The logical unary operator not (*!*).
    It operates only on a scalar Boolean expression. The result is a scalar
    Boolean.
    To operate on a vector, use the built-in function *not*.
  * The sequence (*,*) operator that operates on expressions by returning
    the type and value of the right-most expression in a comma separated
    list of expressions.
    All expressions are evaluated, in order, from left to right.
    The operands to the sequence operator may have *void* type.
    Opaque types cannot be used with the sequence (,) operator.
  * The ternary selection operator (*?:*).
    It operates on three expressions (_exp1_ *?* _exp2_ *:* _exp3_).
    This operator evaluates the first expression, which must result in a
    scalar Boolean.
    If the result is true, it selects to evaluate the second expression,
    otherwise it selects to evaluate the third expression.
    Only one of the second and third expressions is evaluated.
    The second and third expressions cannot be opaque types,
    or there will be {compiletimeerror}.
    Otherwise,
    the second and third expressions can be any type, including *void*, as
ifdef::GLSL[]
    long their types match, or there is a conversion in section
    "`<<implicit-conversions,Implicit Conversions>>`" that can be applied to
    one of the expressions to make their types match.
endif::GLSL[]
ifdef::ESSL[]
    long their types match.
endif::ESSL[]
    This resulting matching type is the type of the entire expression.
  * The one's complement operator (*~*).
    The operand must be of type signed or unsigned integer or integer
    vector, and the result is the one's complement of its operand; each bit
    of each component is complemented, including any sign bits.
  * The shift operators (*<<*) and (*>>*).
    For both operators, the operands must be signed or unsigned integers or
    integer vectors.
    One operand can be signed while the other is unsigned.
    In all cases, the resulting type will be the same type as the left
    operand.
    If the first operand is a scalar, the second operand has to be a scalar
    as well.
    If the first operand is a vector, the second operand must be a scalar or
    a vector with the same size as the first operand, and the result is
    computed component-wise.
    The result is undefined if the right operand is negative, or greater
    than or equal to the number of bits in the left expression's base type.
    The value of E1 << E2 is E1 (interpreted as a bit pattern) left-shifted
    by E2 bits.
    The value of E1 >> E2 is E1 right-shifted by E2 bit positions.
    If E1 is a signed integer, the right-shift will extend the sign bit.
    If E1 is an unsigned integer, the right-shift will zero-extend.
  * The bitwise operators and (*&*), exclusive-or (*^*), and inclusive-or
    (*|*).
    The operands must be of type signed or unsigned integers or integer
    vectors.
    The operands cannot be vectors of differing size; this is {compiletimeerror}.
    If one operand is a scalar and the other a vector, the scalar is applied
    component-wise to the vector, resulting in the same type as the vector.
ifdef::GLSL[]
    If the fundamental types in the operands do not match, then the
    conversions from "`<<implicit-conversions,Implicit Conversions>>`" are
    applied to create matching types, and this will be the resulting
    fundamental type.
endif::GLSL[]
ifdef::ESSL[]
    The fundamental types of the operands (signed or unsigned) must match,
    and will be the resulting fundamental type.
endif::ESSL[]
    For and (*&*), the result is the bitwise-and function of the operands.
    For exclusive-or (*^*), the result is the bitwise exclusive-or function
    of the operands.
    For inclusive-or (*|*), the result is the bitwise inclusive-or function
    of the operands.

For a complete specification of the syntax of expressions, see
"`<<shading-language-grammar,Shading Language Grammar>>`".


[[vector-and-matrix-operations]]
== Vector and Matrix Operations

With a few exceptions, operations are component-wise.
Usually, when an operator operates on a vector or matrix, it is operating
independently on each component of the vector or matrix, in a component-wise
fashion.
For example,

[source,glsl]
----
vec3 v, u;
float f;
v = u + f;
----

will be equivalent to

[source,glsl]
----
v.x = u.x + f;
v.y = u.y + f;
v.z = u.z + f;
----

And

[source,glsl]
----
vec3 v, u, w;
w = v + u;
----

will be equivalent to

[source,glsl]
----
w.x = v.x + u.x;
w.y = v.y + u.y;
w.z = v.z + u.z;
----

and likewise for most operators and all integer and floating-point vector
and matrix types.
The exceptions are matrix multiplied by vector, vector multiplied by matrix,
and matrix multiplied by matrix.
These do not operate component-wise, but rather perform the correct linear
algebraic multiply.

[source,glsl]
----
vec3 v, u;
mat3 m;
u = v * m;
----

is equivalent to

[source,glsl]
----
u.x = dot(v, m[0]); // m[0] is the left column of m
u.y = dot(v, m[1]); // dot(a,b) is the inner (dot) product of a and b
u.z = dot(v, m[2]);
----

And

[source,glsl]
----
u = m * v;
----

is equivalent to

[source,glsl]
----
u.x = m[0].x * v.x + m[1].x * v.y + m[2].x * v.z;
u.y = m[0].y * v.x + m[1].y * v.y + m[2].y * v.z;
u.z = m[0].z * v.x + m[1].z * v.y + m[2].z * v.z;
----

And

[source,glsl]
----
mat3 m, n, r;
r = m * n;
----

is equivalent to

[source,glsl]
----
r[0].x = m[0].x * n[0].x + m[1].x * n[0].y + m[2].x * n[0].z;
r[1].x = m[0].x * n[1].x + m[1].x * n[1].y + m[2].x * n[1].z;
r[2].x = m[0].x * n[2].x + m[1].x * n[2].y + m[2].x * n[2].z;
r[0].y = m[0].y * n[0].x + m[1].y * n[0].y + m[2].y * n[0].z;
r[1].y = m[0].y * n[1].x + m[1].y * n[1].y + m[2].y * n[1].z;
r[2].y = m[0].y * n[2].x + m[1].y * n[2].y + m[2].y * n[2].z;
r[0].z = m[0].z * n[0].x + m[1].z * n[0].y + m[2].z * n[0].z;
r[1].z = m[0].z * n[1].x + m[1].z * n[1].y + m[2].z * n[1].z;
r[2].z = m[0].z * n[2].x + m[1].z * n[2].y + m[2].z * n[2].z;
----

and similarly for other sizes of vectors and matrices.


ifdef::GLSL[]
[[out-of-bounds-accesses]]
== Out-of-Bounds Accesses

In the subsections described above for array, vector, matrix and structure
accesses, any out-of-bounds access produced undefined behavior.
However, if robust buffer access is enabled via the API, such
accesses will be bound within the memory extent of the active program.
It will not be possible to access memory from other programs, and accesses
will not result in abnormal program termination.
Out-of-bounds reads return undefined values, which include values from other
variables of the active program or zero.
Out-of-bounds writes may be discarded or overwrite other variables of the
active program, depending on the value of the computed index and how this
relates to the extent of the active program's memory.
Applications that require defined behavior for out-of-bounds accesses should
range check all computed indices before dereferencing an array.
endif::GLSL[]


[[specialization-constant-operations]]
== Specialization-Constant Operations

Specialization-constant operations are only available when targeting SPIR-V.

Only some operations discussed in this section may be applied to a
specialization constant and still yield a result that is a specialization
constant.
The operations that do so are listed below.
When a specialization constant is operated on with one of these operators
and with another constant or specialization constant, the result is
implicitly a specialization constant.

  * *int*(), *uint*(), and *bool*() constructors for type conversions from
    any of the following types to any of the following types:
  ** *int*
  ** *uint*
  ** *bool*
  * vector versions of the above conversion constructors
  * allowed implicit conversions of the above
  * swizzles (e.g. `foo.yx`)
  * the following when applied to integer or unsigned integer types:
  ** unary negative (*-*)
  ** binary operations (*+*, *-*, ***, */*, *%*)
  ** shift (*<<*, *>>*)
  ** bitwise operations (*&*, *|*, *^*)
  * the following when applied to integer or unsigned integer scalar types:
  ** comparison (*==*, *!=*, *>*, *>=*, *<*, *<=*)
  * The following when applied to the Boolean scalar type:
  ** not (*!*)
  ** logical operations (*&&*, *||*, *^^*)
  ** comparison (*==*, *!=*)
  * the ternary operator (*?:*)

ifdef::ESSL[]
[[evaluation-of-expressions]]
== Evaluation of Expressions

In general expressions must be evaluated in the order specified by the
precedence of operations and may only be regrouped if the result is the same or
where the result is undefined.
No other transforms may be applied that affect the result of an operation.
{slabbrev} relaxes these requirements for scalar operations in the following
ways:

  * Addition and multiplication are assumed to be associative.
  * Multiplication is assumed to be distributive over addition.
    Therefore expressions may be expanded and re-factored.
  * Floating-point division may be replaced by reciprocal and
    multiplication.
  * Multiplication may be replaced by repeated addition.
  * Within the constraints of invariance (where applicable), the precision
    used may vary.

These rules also apply to the built-in functions.
endif::ESSL[]


// Copyright 2008-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0
// chapters/statements.adoc
[[statements-and-structure]]
= Statements and Structure
<<toc>>

The fundamental building blocks of the {slname} are:

  * statements and declarations
  * function definitions
  * selection (*if*-*else* and *switch*-*case*-*default*)
  * iteration (*for*, *while*, and *do*-*while*)
  * jumps (*discard*, *return*, *break*, and *continue*)

The overall structure of a shader is as follows

[role="bnf"]
--
_translation-unit_ : ::
    _global-declaration_ +
    _translation-unit_ _global-declaration_

_global-declaration_ : ::
    _function-definition_ +
    _declaration_
--

That is, a shader is a sequence of declarations and function bodies.
Function bodies are defined as

[role="bnf"]
--
_function-definition_ : ::
    _function-prototype_ *{* _statement-list_ *}*

_statement-list_ : ::
    _statement_ +
    _statement-list_ _statement_

_statement_ : ::
    _compound-statement_ +
    _simple-statement_
--

Curly braces are used to group sequences of statements into compound
statements.

[role="bnf"]
--
_compound-statement_ : ::
    *{* _statement-list_ *}*

_simple-statement_ : ::
    _declaration-statement_ +
    _expression-statement_ +
    _selection-statement_ +
    _iteration-statement_ +
    _jump-statement_
--

Simple declaration, expression, and jump statements end in a semi-colon.

This above is slightly simplified, and the complete grammar specified in
"`<<shading-language-grammar,Shading Language Grammar>>`" should be used as
the definitive specification.

Declarations and expressions have already been discussed.


[[function-definitions]]
== Function Definitions

As indicated by the grammar above, a valid shader is a sequence of global
declarations and function definitions.
A function is declared as the following example shows:

[source,glsl]
----
// prototype
returnType functionName (type0 arg0, type1 arg1, ..., typen argn);
----

and a function is defined like

[source,glsl]
----
// definition
returnType functionName (type0 arg0, type1 arg1, ..., typen argn)
{
    // do some computation
    return returnValue;
}
----

where _returnType_ must be present and cannot be void, or:

[source,glsl]
----
void functionName (type0 arg0, type1 arg1, ..., typen argn)
{
    // do some computation
    return; // optional
}
----

ifdef::GLSL[]
If the type of _returnValue_ does not match _returnType_, there must be an
implicit conversion in "`<<implicit-conversions,Implicit Conversions>>`"
that converts the type of _returnValue_ to _returnType_, or a compile-time
error will result.

Each of the _typeN_ must include a type and can optionally include parameter
qualifiers.
The formal argument names (_args_ above) in the declarations are optional
for both the declaration and definition forms.
endif::GLSL[]
ifdef::ESSL[]
Each of the _typeN_ must include a type and can optionally include a
parameter qualifier and/or *const*.
endif::ESSL[]

A function is called by using its name followed by a list of arguments in
parentheses.

Arrays are allowed as arguments and as the return type.
In both cases, the array must be
ifdef::GLSL[explicitly]
ifdef::ESSL[compile-time]
sized.
An array is passed or returned by using just its name, without brackets, and
the size of the array must match the size specified in the function's
declaration.

Structures are also allowed as argument types.
The return type can also be a structure.

See "`<<shading-language-grammar,Shading Language Grammar>>`" for the
definitive reference on the syntax to declare and define functions.

All functions must be either declared with a prototype or defined with a
body before they are called.
For example:

[source,glsl]
----
float myfunc (float f,      // f is an input parameter
              out float g); // g is an output parameter
----

Functions that return no value must be declared as *void*.
A *void* function can only use *return* without a return argument, even if
the return argument has *void* type.
Return statements only accept values:

[source,glsl]
----
void func1() { }
void func2() { return func1(); } // illegal return statement
----

Only a precision qualifier is allowed on the return type of a function.
Formal parameters can have parameter, precision, and memory qualifiers, but
no other qualifiers.

Functions that accept no input arguments need not use *void* in the argument
list because prototypes (or definitions) are required and therefore there is
no ambiguity when an empty argument list "`( )`" is declared.
The idiom "`(*void*)`" as a parameter list is provided for convenience.

Function names can be overloaded.
The same function name can be used for multiple functions, as long as the
parameter types differ.
If a function name is declared twice with the same parameter types, then the
return types and all qualifiers must also match, and it is the same function
being declared.
ifdef::ESSL[]
When function calls are resolved, an exact type match for all the arguments
is required.
endif::ESSL[]

For example,

ifdef::GLSL[]
[source,glsl]
----
vec4 f(in vec4 x, out vec4 y);       // (A)
vec4 f(in vec4 x, out uvec4 y);      // (B) okay, different argument type
vec4 f(in ivec4 x, out dvec4 y);     // (C) okay, different argument type
int f(in vec4 x, out vec4 y);        // error, only return type differs
vec4 f(in vec4 x, in vec4 y);        // error, only qualifier differs
vec4 f(const in vec4 x, out vec4 y); // error, only qualifier differs
----
endif::GLSL[]
ifdef::ESSL[]
[source,glsl]
----
vec4 f(in vec4 x, out vec4 y);
vec4 f(in vec4 x, out uvec4 y);      // allowed, different argument type
int f(in vec4 x, out vec4 y);        // error, only return type differs
vec4 f(in vec4 x, in vec4 y);        // error, only qualifier differs
vec4 f(const in vec4 x, out vec4 y); // error, only qualifier differs
----
endif::ESSL[]

ifdef::ESSL[]
Calling the first two functions above with the following argument types
yields

[source,glsl]
----
f(vec4, vec4)   // exact match of vec4 f(in vec4 x, out vec4 y)
f(vec4, uvec4)  // exact match of vec4 f(in vec4 x, out uvec4 y)
f(ivec4, vec4)  // error, no exact match.
f(ivec4, uvec4) // error, no exact match.
----
endif::ESSL[]
ifdef::GLSL[]
When function calls are resolved, an exact type match for all the arguments
is sought.
If an exact match is found, all other functions are ignored, and the exact
match is used.
If no exact match is found, then the implicit conversions in section
"`<<implicit-conversions,Implicit Conversions>>`" will be applied to find a
match.
Mismatched types on input parameters (*in* or *inout* or default) *must*
have a conversion from the calling argument type to the formal parameter
type.
Mismatched types on output parameters (*out* or *inout*) must have a
conversion from the formal parameter type to the calling argument type.

If implicit conversions can be used to find more than one matching function,
a single best-matching function is sought.
To determine a best match, the conversions between calling argument and
formal parameter types are compared for each function argument and pair of
matching functions.
After these comparisons are performed, each pair of matching functions are
compared.
A function declaration _A_ is considered a better match than function
declaration _B_ if

  * for at least one function argument, the conversion for that argument in
    _A_ is better than the corresponding conversion in _B_; and
  * there is no function argument for which the conversion in _B_ is better
    than the corresponding conversion in _A_.

If a single function declaration is considered a better match than every
other matching function declaration, it will be used.
Otherwise, a compile-time semantic error for an ambiguous overloaded
function call occurs.

To determine whether the conversion for a single argument in one match is
better than that for another match, the following rules are applied, in
order:

  . An exact match is better than a match involving any implicit conversion.
  . A match involving an implicit conversion from *float* to *double* is
    better than a match involving any other implicit conversion.
  . A match involving an implicit conversion from either *int* or *uint* to
    *float* is better than a match involving an implicit conversion from
    either *int* or *uint* to *double*.

If none of the rules above apply to a particular pair of conversions,
neither conversion is considered better than the other.

For the example function prototypes (A), (B), and (C) above, the following
examples show how the rules apply to different sets of calling argument
types:

[source,glsl]
----
f(vec4, vec4)   // exact match of vec4 f(in vec4 x, out vec4 y)
f(vec4, uvec4)  // exact match of vec4 f(in vec4 x, out uvec4 y)
f(vec4, ivec4)  // matched to vec4 f(in vec4 x, out vec4 y)
                // (C) not relevant, can't convert vec4 to
                // ivec4. (A) better than (B) for 2nd
                // argument (rule 3), same on first argument.
f(ivec4, vec4); // NOT matched. All three match by implicit
                // conversion. (C) is better than (A) and (B)
                // on the first argument. (A) is better than
                // (B) and (C).
----
endif::GLSL[]

User-defined functions can have multiple declarations, but only one
definition.

ifdef::GLSL[]
A shader can redefine built-in functions.
If a built-in function is redeclared in a shader (i.e., a prototype is
visible) before a call to it, then the linker will only attempt to resolve
that call within the set of shaders that are linked with it.
endif::GLSL[]
ifdef::ESSL[]
A shader cannot redefine or overload built-in functions.
endif::ESSL[]

The function _main_ is used as the entry point to a shader executable.
ifdef::GLSL[]
A shader need not contain a function named _main_, but one shader in a set
of shaders linked together to form a single shader executable must, or a
link-time error results.
endif::GLSL[]
ifdef::ESSL[]
All shaders must define a function named _main_.
endif::ESSL[]
This function takes no arguments, returns no value, and must be declared as
type *void*:

[source,glsl]
----
void main()
{
    ...
}
----

The function _main_ can contain uses of *return*.
See "`<<jumps,Jumps>>`" for more details.

It is a compile-time or link-time error to declare or define a function
*main* with any other parameters or return type.


[[function-calling-conventions]]
=== Function Calling Conventions

Functions are called by value-return.
This means input arguments are copied into the function at call time, and
output arguments are copied back to the caller before function exit.
Because the function works with local copies of parameters, there are no
issues regarding aliasing of variables within a function.
To control what parameters are copied in and/or out through a function
definition or declaration:

  * The keyword *in* is used as a qualifier to denote a parameter is to be
    copied in, but not copied out.
  * The keyword *out* is used as a qualifier to denote a parameter is to be
    copied out, but not copied in.
    This should be used whenever possible to avoid unnecessarily copying
    parameters in.
  * The keyword *inout* is used as a qualifier to denote the parameter is to
    be both copied in and copied out.
    It means the same thing as specifying both *in* and *out*.
  * A function parameter declared with no such qualifier means the same
    thing as specifying *in*.

All arguments are evaluated at call time, exactly once, in order, from left
to right.
Evaluation of an *in* parameter results in a value that is copied to the
formal parameter.
Evaluation of an *out* parameter results in an l-value that is used to copy
out a value when the function returns.
Evaluation of an *inout* parameter results in both a value and an l-value;
the value is copied to the formal parameter at call time and the l-value is
used to copy out a value when the function returns.

[NOTE]
.Note
====
Because *out* parameters are not copied into a function, they begin the function
uninitialized. At the end of the function, the values are copied out to the
caller unconditionally which, if the value has not been set in the function,
will result in the passed argument becoming uninitialized in the caller.
====

The order in which output parameters are copied back to the caller is
undefined.

ifdef::GLSL[]
If the function matching described in the previous section required argument
type conversions, these conversions are applied at copy-in and copy-out
times.
endif::GLSL[]

In a function, writing to an input-only parameter is allowed.
Only the function's copy is modified.
This can be prevented by declaring a parameter with the *const* qualifier.

When calling a function, expressions that do not evaluate to l-values cannot
be passed to parameters declared as *out* or *inout*, or {compiletimeerror}
results.

The syntax for function prototypes can be informally expressed as:

[role="bnf"]
--
_function-prototype_ : ::
    _return-type_ _function-name_ *(* _parameter-qualifiers_
    _type-specifier_ _name_ _array-specifier_ *,* ...
    *)*

_return-type_ : ::
    _type-specifier_ +
    _precision-qualifier_ _type-specifier_

_parameter-qualifiers_ : ::
    _empty_ +
    _parameter-qualifiers_ _parameter-qualifier_

_parameter-qualifier_ : ::
    *const* +
    *in* +
    *out* +
    *inout* +
    *precise* +
    _memory-qualifier_ +
    _precision-qualifier_

_name_ : ::
    empty +
    _identifier_

_array-specifier_ : ::
    empty +
    *[* _integral-constant-expression_ *]*
--

The *const* qualifier cannot be used with *out* or *inout*, or
{compiletimeerror} results.
The above is used both for function declarations (i.e., prototypes) and for
function definitions.
Hence, function definitions can have unnamed arguments.

Static, and hence dynamic, recursion is not allowed.
Static recursion is present if the static function-call graph of a program
contains cycles.
ifdef::GLSL[]
This includes all potential function calls through variables declared as
*subroutine* *uniform* (described below).
It is a compile-time or link-time error if a single compilation unit
(shader) contains either static recursion or the potential for recursion
through subroutine variables.
endif::GLSL[]
Dynamic recursion occurs if at any time control flow has entered but not
exited a single function more than once.


ifdef::GLSL[]
[[subroutines]]
=== Subroutines

Subroutines provide a mechanism allowing shaders to be compiled in a manner
where the target of one or more function calls can be changed at run-time
without requiring any shader recompilation.
For example, a single shader may be compiled with support for multiple
illumination algorithms to handle different kinds of lights or surface
materials.
An application using such a shader may switch illumination algorithms by
changing the value of its subroutine uniforms.
To use subroutines, a subroutine type is declared, one or more functions are
associated with that subroutine type, and a subroutine variable of that type
is declared.
The function currently assigned to the variable function is then called by
using function calling syntax replacing a function name with the name of the
subroutine variable.
Subroutine variables are uniforms, and are assigned to specific functions
only through commands (*UniformSubroutinesuiv*) in the {apiname} API.

Subroutine functionality is not available when generating SPIR-V.

Subroutine types are declared using a statement similar to a function
declaration, with the *subroutine* keyword, as follows:

[source,glsl]
----
subroutine returnType subroutineTypeName(type0 arg0, type1 arg1,
                                         ..., typen argn);
----

As with function declarations, the formal argument names (_args_ above) are
optional.
Functions are associated with subroutine types of matching declarations by
defining the function with the *subroutine* keyword and a list of subroutine
types the function matches:

[source,glsl]
----
subroutine(subroutineTypeName0, ..., subroutineTypeNameN)
returnType functionName(type0 arg0, type1 arg1, ..., typen argn)
{ ... } // function body
----

It is a compile-time error if arguments and return type don't match between
the function and each associated subroutine type.

Functions declared with *subroutine* must include a body.
An overloaded function cannot be declared with *subroutine*; a program will
fail to compile or link if any shader or stage contains two or more
functions with the same name if the name is associated with a subroutine
type.

A function declared with *subroutine* can also be called directly with a
static use of _functionName_, as is done with non-subroutine function
declarations and calls.

Subroutine type variables are required to be _subroutine uniforms_, and are
declared with a specific subroutine type in a subroutine uniform variable
declaration:

[source,glsl]
----
subroutine uniform subroutineTypeName subroutineVarName;
----

Subroutine uniform variables are called the same way functions are called.
When a subroutine variable (or an element of a subroutine variable array) is
associated with a particular function, all function calls through that
variable will call that particular function.

Unlike other uniform variables, subroutine uniform variables are scoped to
the shader execution stage the variable is declared in.

Subroutine variables may be declared as explicitly-sized arrays, which can
be indexed only with dynamically uniform expressions.

It is a compile-time error to use the *subroutine* keyword in any places
other than (as shown above) to

  * declare a subroutine type at global scope,
  * declare a function as a subroutine, or
  * declare a subroutine variable at global scope.
endif::GLSL[]


[[selection]]
== Selection

Conditional control flow in the shading language is done by either *if*,
*if*-*else*, or *switch* statements:

[role="bnf"]
--
_selection-statement_ : ::
    *if* *(* _bool-expression_ *)* _statement_ +
    *if* *(* _bool-expression_ *)* _statement_ *else* _statement_ +
    *switch* *(* _init-expression_ *)* *{* _switch-statement-list~opt~_ *}*
--

Where _switch-statement-list_ is a nested scope containing a list of zero or
more _switch-statement_ and other statements defined by the language, where
_switch-statement_ adds some forms of labels.
That is

[role="bnf"]
--
_switch-statement-list_ : ::
    _switch-statement_ +
    _switch-statement-list_ _switch-statement_

_switch-statement_ : ::
    *case* _constant-expression_ *:* +
    *default* *:* _statement_
--

Note the above grammar's purpose is to aid discussion in this section; the
normative grammar is in "`<<shading-language-grammar,Shading Language
Grammar>>`".

If an *if*-expression evaluates to *true*, then the first _statement_ is
executed.
If it evaluates to *false* and there is an *else* part then the second
_statement_ is executed.

Any expression whose type evaluates to a Boolean can be used as the
conditional expression _bool-expression_.
Vector types are not accepted as the expression to *if*.

Conditionals can be nested.

The type of _init-expression_ in a *switch* statement must be a scalar
integer.
ifdef::GLSL[]
The type of the _constant-expression_ value in a case label also must be a
scalar integer.
When any pair of these values is tested for "`equal value`" and the types do
not match, an implicit conversion will be done to convert the *int* to a
*uint* (see "`<<implicit-conversions,Implicit Conversions>>`") before the
compare is done.
endif::GLSL[]
ifdef::ESSL[]
The type of _init-expression_ must match the type of the *case* labels
within each *switch* statement.
Either signed integers or unsigned integers are allowed but there is no
implicit type conversion between the two.
endif::ESSL[]
If a *case* label has a _constant-expression_ of equal value to
_init-expression_, execution will continue after that label.
Otherwise, if there is a *default* label, execution will continue after that
label.
Otherwise, execution skips the rest of the switch statement.
It is {compiletimeerror} to have more than one *default* or a replicated
_constant-expression_.
A *break* statement not nested in a loop or other switch statement (either
not nested or nested only in *if* or *if*-*else* statements) will also skip
the rest of the switch statement.
Fall through labels are allowed, but it is {compiletimeerror} to have no
statement between a label and the end of the switch statement.
No statements are allowed in a switch statement before the first *case*
statement.

The *case* and *default* labels can only appear within a *switch* statement.
No *case* or *default* labels can be nested inside other statements or
compound statements within their corresponding *switch*.


[[iteration]]
== Iteration

For, while, and do loops are allowed as follows:

[source,glsl]
----
for (init-expression; condition-expression; loop-expression)
    sub-statement
while (condition-expression)
    sub-statement
do
    statement
while (condition-expression)
----

See "`<<shading-language-grammar,Shading Language Grammar>>`" for the
definitive specification of loops.

The *for* loop first evaluates the _init-expression_, then the
_condition-expression_.
If the _condition-expression_ evaluates to *true*, then the body of the loop
is executed.
After the body is executed, a *for* loop will then evaluate the
_loop-expression_, and then loop back to evaluate the
_condition-expression_, repeating until the _condition-expression_ evaluates
to *false*.
The loop is then exited, skipping its body and skipping its
_loop-expression_.
Variables modified by the _loop-expression_ maintain their value after the
loop is exited, provided they are still in scope.
Variables declared in _init-expression_ or _condition-expression_ are only
in scope until the end of the sub-statement of the *for* loop.

The *while* loop first evaluates the _condition-expression_.
If *true*, then the body is executed.
This is then repeated, until the _condition-expression_ evaluates to
*false*, exiting the loop and skipping its body.
Variables declared in the _condition-expression_ are only in scope until the
end of the sub-statement of the *while* loop.

ifdef::ESSL[]
For both *for* and *while* loops, the sub-statement does not introduce a new
scope for variable names, so the following has a redeclaration error:

[source,glsl]
----
for (int i = 0; i < 10; i++) +
{
    int i; // redeclaration error +
}
----
endif::ESSL[]

The *do*-*while* loop first executes the body, then executes the
_condition-expression_.
This is repeated until _condition-expression_ evaluates to *false*, and then
the loop is exited.

Expressions for _condition-expression_ must evaluate to a Boolean.

Both the _condition-expression_ and the _init-expression_ can declare and
initialize a variable, except in the *do*-*while* loop, which cannot declare
a variable in its _condition-expression_.
The variable's scope lasts only until the end of the sub-statement that
forms the body of the loop.

Loops can be nested.

Non-terminating loops are allowed.
The consequences of very long or non-terminating loops are platform
dependent.


[[jumps]]
== Jumps

These are the jumps:

[role="bnf"]
--
_jump_statement_ : ::
    *continue* *;* +
    *break* *;* +
    *return* *;* +
    *return* _expression_ *;* +
    *discard* *;* // in the fragment shader language only
--

There is no "`goto`" or other non-structured flow of control.

The *continue* jump is used only in loops.
It skips the remainder of the body of the inner-most loop of which it is
inside.
For *while* and *do*-*while* loops, this jump is to the next evaluation of
the loop _condition-expression_ from which the loop continues as previously
defined.
For *for* loops, the jump is to the _loop-expression_, followed by the
_condition-expression_.

The *break* jump can also be used only in loops and *switch* statements.
It is simply an immediate exit of the inner-most loop or *switch* statements
containing the *break*.
No further execution of _condition-expression_, _loop-expression_, or
_switch-statement_ is done.

The *discard* keyword is only allowed within fragment shaders.
It can be used within a fragment shader to abandon the operation on the
current fragment.
This keyword causes the fragment to be discarded and no updates to any
buffers will occur.
Any prior writes to other buffers such as shader storage buffers are
unaffected.
Control flow exits the shader, and subsequent implicit or explicit
derivatives are undefined when this control flow is non-uniform (meaning
different fragments within the primitive take different control paths).
It would typically be used within a conditional statement, for example:

[source,glsl]
----
if (intensity < 0.0)
    discard;
----

A fragment shader may test a fragment's alpha value and discard the fragment
based on that test.
However, it should be noted that coverage testing occurs after the fragment
shader runs, and the coverage test can change the alpha value.

The *return* jump causes immediate exit of the current function.
If it has _expression_ then that is the return value for the function.

The function _main_ can use *return*.
This simply causes _main_ to exit in the same way as when the end of the
function had been reached.
It does not imply a use of *discard* in a fragment shader.
Using *return* in _main_ before defining outputs will have the same behavior
as reaching the end of _main_ before defining outputs.


// Copyright 2008-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0
// chapters/builtins.adoc
[[built-in-variables]]
= Built-In Variables
<<toc>>


[[built-in-language-variables]]
== Built-In Language Variables

Some operations occur outside shader functionality and need to provide
values to or receive values from shader executables.
Shaders communicate with fixed-function pipeline stages, and
optionally with other shader executables, through the use of built-in input
and output variables.


[[vertex-shader-special-variables]]
=== Vertex Shader Special Variables

The built-in vertex shader variables are intrinsically declared as follows:

ifdef::GLSL[]
[source,glsl]
----
in int gl_VertexID;       // only present when not targeting Vulkan
in int gl_InstanceID;     // only present when not targeting Vulkan
in int gl_VertexIndex;    // only present when targeting Vulkan
in int gl_InstanceIndex;  // only present when targeting Vulkan
in int gl_DrawID;
in int gl_BaseVertex;
in int gl_BaseInstance;

out gl_PerVertex {
    vec4 gl_Position;
    float gl_PointSize;
    float gl_ClipDistance[];
    float gl_CullDistance[];
};
----
endif::GLSL[]
ifdef::ESSL[]
[source,glsl]
----
in highp int gl_VertexID;      // only present when not targeting Vulkan
in highp int gl_InstanceID;    // only present when not targeting Vulkan
in highp int gl_VertexIndex;   // only present when targeting Vulkan
in highp int gl_InstanceIndex; // only present when targeting Vulkan

out gl_PerVertex {
    out highp vec4 gl_Position;
    out highp float gl_PointSize;
};
----
endif::ESSL[]

The variable _gl_Position_ is intended for writing the homogeneous vertex
position.
It can be written at any time during shader execution.
This value will be used by primitive assembly, clipping, culling, and other
fixed functionality operations, if present, that operate on primitives after
vertex processing has occurred.
Its value is undefined after the vertex processing stage if the vertex
shader executable does not write _gl_Position_.

The variable _gl_PointSize_ is intended for a shader to write the size of
the point to be rasterized.
It is measured in pixels.
If _gl_PointSize_ is not written to, its value is undefined in subsequent
pipe stages.

ifdef::GLSL[]
The variable _gl_ClipDistance_ is intended for writing clip distances, and
provides the forward compatible mechanism for controlling user clipping.
The element _gl_ClipDistance[i]_ specifies a clip distance for each half-space
_i_.
A distance of 0 means the vertex is on the boundary of the half-space, a positive distance means
the vertex is inside the clip volume, and a negative distance means the point
is outside the clip volume.
The clip distances will be linearly interpolated across the primitive and
the portion of the primitive with interpolated distances less than 0 will be
clipped.

The _gl_ClipDistance_ array is predeclared as unsized and must be either explicitly
sized by the shader redeclaring it with a size or implicitly sized by
indexing it only with constant integral expressions.
This needs to size the array to include all the clip half-spaces that are enabled
via the API; if the size does not include all enabled half-spaces,
results are undefined.
The size can be at most _gl_MaxClipDistances_.
The number of varying components (see _gl_MaxVaryingComponents)_ consumed by
_gl_ClipDistance_ will match the size of the array, no matter how many
half-spaces are enabled.
The shader must also set all values in _gl_ClipDistance_ that have been
enabled via the API, or results are undefined.
Values written into _gl_ClipDistance_ for half-spaces that are not enabled have
no effect.

The variable _gl_CullDistance_ provides a mechanism for controlling user
culling.
The element _gl_CullDistance[i]_ specifies a cull distance for half-space _i_.
A distance of 0 means the vertex is on the boundary of the half-space, a positive distance means
the vertex is inside the cull volume, and a negative distance means the
point is outside the cull volume.
Primitives whose vertices all have a negative cull distance for half-spaces _i_
will be discarded.

The _gl_CullDistance_ array is predeclared as unsized and must be either explicitly
sized by the shader redeclaring it with a size or implicitly sized by
indexing it only with constant integral expressions.
The size determines the number and set of enabled cull distances and can be
at most _gl_MaxCullDistances_.
The number of varying components (see _gl_MaxVaryingComponents_) consumed by
_gl_CullDistance_ will match the size of the array.
Shaders writing _gl_CullDistance_ must write all enabled distances, or
culling results are undefined.

As an output variable, _gl_CullDistance_ provides the place for the shader
to write these distances.
As an input in all but the fragment language, it reads the values written in
the previous shader stage.
In the fragment language, _gl_CullDistance_ array contains linearly
interpolated values for the vertex values written by a shader to the
_gl_CullDistance_ vertex output variable.

It is a compile-time or link-time error for the set of shaders forming a
program to have the sum of the sizes of the _gl_ClipDistance_ and
_gl_CullDistance_ arrays to be larger than
_gl_MaxCombinedClipAndCullDistances_.
endif::GLSL[]

The variable _gl_VertexID_ is a vertex shader input variable that holds an
integer index for the vertex, as defined under "`Shader Inputs`" in section
11.1.3.9 "`Shader Inputs`" of the <<references,{apispec}>>.
It is only present when not targeting Vulkan.
Even when present, the value of _gl_VertexID_ is not always defined.

The variable _gl_InstanceID_ is a vertex shader input variable that holds
the instance number of the current primitive in an instanced draw call (see
"`Shader Inputs`" in section 11.1.3.9 "`Shader Inputs`" of the
<<references,{apispec}>>).
It is only present when not targeting Vulkan.
If the current primitive does not come from an instanced draw call, the
value of _gl_InstanceID_ is zero.

The variable _gl_VertexIndex_ is a vertex language input variable that
holds an integer index for the vertex, relative to a base.
It is only present when targeting Vulkan.
Even when present, the value of _gl_VertexIndex_ is not always defined.

The variable _gl_InstanceIndex_ is a vertex language input variable that
holds the instance number of the current primitive in an instanced draw
call, relative to a base.
It is only present when targeting Vulkan.
If the current primitive does not come from an instanced draw call,
the value of gl_InstanceIndex is zero.

ifdef::GLSL[]
The variable _gl_DrawID_ is a vertex shader input variable that holds the
integer index of the drawing command to which the current vertex belongs
(see "`Shader Inputs`" in section 11.1.3.9 of the <<references,{apispec}>>).
If the vertex is not invoked by a *Multi** form of a draw command, then the
value of _gl_DrawID_ is zero.

The variable _gl_BaseVertex_ is a vertex shader input variable that holds
the integer value passed to the baseVertex parameter of the command that
resulted in the current shader invocation (see "`Shader Inputs`" in section
11.1.3.9 of the <<references,{apispec}>>).

The variable _gl_BaseInstance_ is a vertex shader input variable that holds
the integer value passed to the baseInstance parameter of the command that
resulted in the current shader invocation (see "`Shader Inputs`" in section
11.1.3.9 of the <<references,{apispec}>>).
endif::GLSL[]


[[tessellation-control-shader-special-variables]]
=== Tessellation Control Shader Special Variables

In the tessellation control shader, built-in variables are intrinsically
declared as:

ifdef::GLSL[]
[source,glsl]
----
in gl_PerVertex {
    vec4 gl_Position;
    float gl_PointSize;
    float gl_ClipDistance[];
    float gl_CullDistance[];
} gl_in[gl_MaxPatchVertices];

in int gl_PatchVerticesIn;
in int gl_PrimitiveID;
in int gl_InvocationID;

out gl_PerVertex {
    vec4 gl_Position;
    float gl_PointSize;
    float gl_ClipDistance[];
    float gl_CullDistance[];
} gl_out[];

patch out float gl_TessLevelOuter[4];
patch out float gl_TessLevelInner[2];
----
endif::GLSL[]
ifdef::ESSL[]
[source,glsl]
----
in gl_PerVertex {
    highp vec4 gl_Position;
} gl_in[gl_MaxPatchVertices];

in highp int gl_PatchVerticesIn;
in highp int gl_PrimitiveID;
in highp int gl_InvocationID;

out gl_PerVertex {
    highp vec4 gl_Position;
} gl_out[];

patch out highp float gl_TessLevelOuter[4];
patch out highp float gl_TessLevelInner[2];
patch out highp vec4 gl_BoundingBox[2];
----
endif::ESSL[]


[[tessellation-control-input-variables]]
==== Tessellation Control Input Variables

ifdef::GLSL[]
_gl_Position_, _gl_PointSize_, _gl_ClipDistance_, and _gl_CullDistance_
contain the values written in the previous shader stage to the corresponding
outputs.
endif::GLSL[]
ifdef::ESSL[]
_gl_Position_ contains the output written in the previous shader stage to
_gl_Position_.
endif::ESSL[]

_gl_PatchVerticesIn_ contains the number of vertices in the input patch
being processed by the shader.
A single shader can read patches of differing sizes, so the value of
_gl_PatchVerticesIn_ may differ between patches.

_gl_PrimitiveID_ contains the number of primitives processed by the shader
since the current set of rendering primitives was started.

_gl_InvocationID_ contains the number of the output patch vertex assigned to
the tessellation control shader invocation.
It is assigned integer values in the range [0, N-1], where N is the number
of output patch vertices per primitive.


[[tessellation-control-output-variables]]
==== Tessellation Control Output Variables

ifdef::GLSL[]
_gl_Position_, _gl_PointSize_, _gl_ClipDistance_, and _gl_CullDistance_ are
used in the same fashion as the corresponding output variables in the vertex
shader.
endif::GLSL[]
ifdef::ESSL[]
_gl_Position_ is used in the same fashion as the corresponding output
variable in the vertex shader.
endif::ESSL[]

The values written to _gl_TessLevelOuter_ and _gl_TessLevelInner_ are
assigned to the corresponding outer and inner tessellation levels of the
output patch.
They are used by the tessellation primitive generator to control primitive
tessellation and may be read by tessellation evaluation shaders.

ifdef::ESSL[]
The values written to _gl_BoundingBox_ specify the minimum and maximum
clip-space extents of a bounding box containing all primitives generated
from the patch by the primitive generator, geometry shader, and clipping.
Fragments may or may not be generated for portions of these primitives
that extend outside the window-coordinate projection of this bounding
box.
endif::ESSL[]


[[tessellation-evaluation-shader-special-variables]]
=== Tessellation Evaluation Shader Special Variables

In the tessellation evaluation shader, built-in variables are intrinsically
declared as:

ifdef::GLSL[]
[source,glsl]
----
in gl_PerVertex {
    vec4 gl_Position;
    float gl_PointSize;
    float gl_ClipDistance[];
    float gl_CullDistance[];
} gl_in[gl_MaxPatchVertices];

in int gl_PatchVerticesIn;
in int gl_PrimitiveID;
in vec3 gl_TessCoord;
patch in float gl_TessLevelOuter[4];
patch in float gl_TessLevelInner[2];

out gl_PerVertex {
    vec4 gl_Position;
    float gl_PointSize;
    float gl_ClipDistance[];
    float gl_CullDistance[];
};
----
endif::GLSL[]
ifdef::ESSL[]
[source,glsl]
----
in gl_PerVertex {
    highp vec4 gl_Position;
} gl_in[gl_MaxPatchVertices];

in highp int gl_PatchVerticesIn;
in highp int gl_PrimitiveID;
in highp vec3 gl_TessCoord;
patch in highp float gl_TessLevelOuter[4];
patch in highp float gl_TessLevelInner[2];

out gl_PerVertex {
    highp vec4 gl_Position;
};
----
endif::ESSL[]


[[tessellation-evaluation-input-variables]]
==== Tessellation Evaluation Input Variables

ifdef::GLSL[]
_gl_Position_, _gl_PointSize_, _gl_ClipDistance_, and _gl_CullDistance_
contain the values written in the previous shader stage to the corresponding
outputs.
endif::GLSL[]
ifdef::ESSL[]
_gl_Position_ contains the output written in the previous shader stage to
_gl_Position_.
endif::ESSL[]

_gl_PatchVerticesIn_ and _gl_PrimitiveID_ are defined in the same fashion as
the corresponding input variables in the tessellation control shader.

_gl_TessCoord_ specifies a three-component _(u,v,w)_ vector identifying the
position of the vertex being processed by the shader relative to the
primitive being tessellated.
Its values will obey the properties

[source,glsl]
----
gl_TessCoord.x == 1.0 - (1.0 - gl_TessCoord.x) // two operations performed
gl_TessCoord.y == 1.0 - (1.0 - gl_TessCoord.y) // two operations performed
gl_TessCoord.z == 1.0 - (1.0 - gl_TessCoord.z) // two operations performed
----

to aid in replicating subdivision computations.

ifdef::GLSL[If a tessellation control shader is active, the input variables]
_gl_TessLevelOuter_ and _gl_TessLevelInner_ are filled with the
ifdef::GLSL[]
corresponding outputs written by the tessellation control shader.
Otherwise, they are assigned with default tessellation levels specified in
section 11.2.3.3 "`Tessellation Evaluation Shader Inputs`" of the
<<references,{apispec}>>.
endif::GLSL[]
ifdef::ESSL[]
corresponding outputs written by the active tessellation control shader.
endif::ESSL[]


[[tessellation-evaluation-output-variables]]
==== Tessellation Evaluation Output Variables

ifdef::GLSL[]
_gl_Position_, _gl_PointSize_, _gl_ClipDistance_, and _gl_CullDistance_ are
used in the same fashion as the corresponding output variables in the vertex
shader.
endif::GLSL[]
ifdef::ESSL[]
_gl_Position_ is used in the same fashion as the corresponding output
variable in the vertex shader.
endif::ESSL[]


[[geometry-shader-special-variables]]
=== Geometry Shader Special Variables

In the geometry shader, built-in variables are intrinsically declared as:

ifdef::GLSL[]
[source,glsl]
----
in gl_PerVertex {
    vec4 gl_Position;
    float gl_PointSize;
    float gl_ClipDistance[];
    float gl_CullDistance[];
} gl_in[];

in int gl_PrimitiveIDIn;
in int gl_InvocationID;

out gl_PerVertex {
    vec4 gl_Position;
    float gl_PointSize;
    float gl_ClipDistance[];
    float gl_CullDistance[];
};

out int gl_PrimitiveID;
out int gl_Layer;
out int gl_ViewportIndex;
----
endif::GLSL[]
ifdef::ESSL[]
[source,glsl]
----
in gl_PerVertex {
    highp vec4 gl_Position;
} gl_in[];

in highp int gl_PrimitiveIDIn;
in highp int gl_InvocationID;

out gl_PerVertex {
    highp vec4 gl_Position;
};

out highp int gl_PrimitiveID;
out highp int gl_Layer;
----
endif::ESSL[]


[[geometry-shader-input-variables]]
==== Geometry Shader Input Variables

ifdef::GLSL[]
_gl_Position_, _gl_PointSize_, _gl_ClipDistance_, and _gl_CullDistance_
contain the values written in the previous shader stage to the corresponding
outputs.
endif::GLSL[]
ifdef::ESSL[]
_gl_Position_ contains the output written in the previous shader stage to
_gl_Position_.
endif::ESSL[]

_gl_PrimitiveIDIn_ contains the number of primitives processed by the shader
since the current set of rendering primitives was started.

_gl_InvocationID_ contains the invocation number assigned to the geometry
shader invocation.
It is assigned integer values in the range [0, N-1], where N is the number
of geometry shader invocations per primitive.


[[geometry-shader-output-variables]]
==== Geometry Shader Output Variables

ifdef::GLSL[]
_gl_Position_, _gl_PointSize_, _gl_ClipDistance_, and _gl_CullDistance_ are
used in the same fashion as the corresponding output variables in the vertex
shader.
endif::GLSL[]
ifdef::ESSL[]
_gl_Position_ is used in the same fashion as the corresponding output
variable in the vertex shader.
endif::ESSL[]

_gl_PrimitiveID_ is filled with a single integer that serves as a primitive
identifier to the fragment shader.
This is then available to fragment shaders, which will select the written
primitive ID from the provoking vertex of the primitive being shaded.
If a fragment shader using _gl_PrimitiveID_ is active and a geometry shader
is also active, the geometry shader must write to _gl_PrimitiveID_ or the
fragment shader input _gl_PrimitiveID_ is undefined.
ifdef::GLSL[See section 11.3.4.5 "`Geometry Shader Outputs`" of the]
ifdef::ESSL[See section 11.3.4.4 "`Geometry Shader Outputs`" of the]
<<references,{apispec}>> for more information.

_gl_Layer_ is used to select a specific layer (or face and layer of a cube
map) of a multi-layer framebuffer attachment.
The actual layer used will come from one of the vertices in the primitive
being shaded.
Which vertex the layer comes from is determined as discussed in section
ifdef::GLSL[]
11.3.4.6 "`Layer and Viewport Selection`" of the <<references,{apispec}>>
endif::GLSL[]
ifdef::ESSL[]
11.3.4.4 of the <<references,{apispec}>>
endif::ESSL[]
but may be undefined, so it is best to write the same layer value for all
vertices of a primitive.
If a shader statically assigns a value to _gl_Layer_, layered rendering mode
is enabled.
ifdef::GLSL[]
See section 11.3.4.5 "`Geometry Shader Outputs`" and section 9.4.9 "`Layered
endif::GLSL[]
ifdef::ESSL[]
See section 11.3.4.4 "`Geometry Shader Outputs`" and section 9.8 "`Layered
endif::ESSL[]
Framebuffers`" of the <<references,{apispec}>> for more information.
If a shader statically assigns a value to _gl_Layer_, and there is an
execution path through the shader that does not set _gl_Layer_, then the
value of _gl_Layer_ is undefined for executions of the shader that take that
path.

The output variable _gl_Layer_ takes on a special value when used with an
array of cube map textures.
Instead of only referring to the layer, it is used to select a cube map face
and a layer.
Setting _gl_Layer_ to the value _layer*6+face_ will render to face _face_ of
the cube defined in layer _layer_.
ifdef::GLSL[]
The face values are defined in table 9.3 of section 9.4.9 "`Layered
Framebuffers`" of the <<references,{apispec}>>,
endif::GLSL[]
ifdef::ESSL[]
The face values are defined in table 8.25 of the <<references,{apispec}>>,
endif::ESSL[]
but repeated below for clarity.

[options="header"]
|====
| Face Value | Resulting Target
| 0          | TEXTURE_CUBE_MAP_POSITIVE_X
| 1          | TEXTURE_CUBE_MAP_NEGATIVE_X
| 2          | TEXTURE_CUBE_MAP_POSITIVE_Y
| 3          | TEXTURE_CUBE_MAP_NEGATIVE_Y
| 4          | TEXTURE_CUBE_MAP_POSITIVE_Z
| 5          | TEXTURE_CUBE_MAP_NEGATIVE_Z
|====

For example, to render to the positive _y_ cube map face located in the 5th
layer of the cube map array, _gl_Layer_ should be set to _5 * 6 + 2_.

ifdef::GLSL[]
The output variable _gl_ViewportIndex_ provides the index of the viewport to
which the next primitive emitted from the geometry shader should be drawn.
Primitives generated by the geometry shader will undergo viewport
transformation and scissor testing using the viewport transformation and
scissor rectangle selected by the value of _gl_ViewportIndex_.
The viewport index used will come from one of the vertices in the primitive
being shaded.
However, which vertex the viewport index comes from is
implementation-dependent, so it is best to use the same viewport index for
all vertices of the primitive.
If a geometry shader does not assign a value to _gl_ViewportIndex_, viewport
transform and scissor rectangle zero will be used.
If a geometry shader statically assigns a value to _gl_ViewportIndex_ and
there is a path through the shader that does not assign a value to
_gl_ViewportIndex_, the value of _gl_ViewportIndex_ is undefined for
executions of the shader that take that path.
See section 11.3.4.6 "`Layer and Viewport Selection`" of the
<<references,{apispec}>> for more information.
endif::GLSL[]


[[fragment-shader-special-variables]]
=== Fragment Shader Special Variables

The built-in special variables that are accessible from a fragment shader
are intrinsically declared as follows:

ifdef::GLSL[]
[source,glsl]
----
in vec4 gl_FragCoord;
in bool gl_FrontFacing;
in float gl_ClipDistance[];
in float gl_CullDistance[];
in vec2 gl_PointCoord;
in int gl_PrimitiveID;
in int gl_SampleID;
in vec2 gl_SamplePosition;
in int gl_SampleMaskIn[];
in int gl_Layer;
in int gl_ViewportIndex;
in bool gl_HelperInvocation;

out float gl_FragDepth;
out int gl_SampleMask[];
----
endif::GLSL[]
ifdef::ESSL[]
[source,glsl]
----
in highp vec4 gl_FragCoord;
in bool gl_FrontFacing;
out highp float gl_FragDepth;
in mediump vec2 gl_PointCoord;
in bool gl_HelperInvocation;
in highp int gl_PrimitiveID;
in highp int gl_Layer;
in lowp int gl_SampleID;
in mediump vec2 gl_SamplePosition;
in highp int gl_SampleMaskIn[(gl_MaxSamples+31)/32];
out highp int gl_SampleMask[(gl_MaxSamples+31)/32];
----
endif::ESSL[]

The output of the fragment shader executable is processed by the fixed
function operations at the back end of the API pipeline.

The fixed functionality computed depth for a fragment may be obtained by
reading _gl_FragCoord.z_, described below.

Writing to _gl_FragDepth_ will establish the depth value for the fragment
being processed.
If depth buffering is enabled, and no shader writes _gl_FragDepth_, then the
fixed function value for depth will be used as the fragment's depth value.
If a shader statically assigns a value to _gl_FragDepth_, and there is an
execution path through the shader that does not set _gl_FragDepth_, then the
value of the fragment's depth may be undefined for executions of the shader
that take that path.
That is, if the set of linked fragment shaders statically contain a write to
_gl_FragDepth_, then it is responsible for always writing it.

If a shader executes the *discard* keyword, the fragment is discarded, and
the values of any user-defined fragment outputs, _gl_FragDepth_, and
_gl_SampleMask_ become irrelevant.

The variable _gl_FragCoord_ is available as an input variable from within
fragment shaders and it holds the window relative coordinates (_x_, _y_,
_z_, _1/w_) values for the fragment.
If multi-sampling, this value can be for any location within the pixel, or
one of the fragment samples.
The use of *centroid* does not further restrict this value to be inside the
current primitive.
This value is the result of the fixed functionality that interpolates
primitives after vertex processing to generate fragments.
The _z_ component is the depth value that would be used for the fragment's
depth if no shader contained any writes to _gl_FragDepth_.
This is useful for invariance if a shader conditionally computes
_gl_FragDepth_ but otherwise wants the fixed functionality fragment depth.

Fragment shaders have access to the input built-in variable
_gl_FrontFacing_, whose value is *true* if the fragment belongs to a
front-facing primitive.
One use of this is to emulate two-sided lighting by selecting one of two
colors calculated by a vertex or geometry shader.

The values in _gl_PointCoord_ are two-dimensional coordinates indicating
where within a point primitive the current fragment is located, when point
sprites are enabled.
They range from 0.0 to 1.0 across the point.
If the current primitive is not a point, or if point sprites are not
enabled, then the values read from _gl_PointCoord_ are undefined.

For both the input array _gl_SampleMaskIn[]_ and the output array
_gl_SampleMask[]_, bit _B_ of mask _M_ (_gl_SampleMaskIn[M]_ or
_gl_SampleMask[M]_) corresponds to sample _32*M+B_.
These arrays have *ceil*(_s_/32) elements, where _s_ is the maximum number
of color samples supported by the implementation.

The input variable _gl_SampleMaskIn_ indicates the set of samples covered by
the primitive generating the fragment during multisample rasterization.
It has a sample bit set if and only if the sample is considered covered for
this fragment shader invocation.

The output array _gl_SampleMask[]_ sets the sample mask for the fragment
being processed.
Coverage for the current fragment will become the logical AND of the
coverage mask and the output _gl_SampleMask_.
This array must be sized in the fragment shader either implicitly or
explicitly, to be no larger than the implementation-dependent maximum
sample-mask (as an array of 32bit elements), determined by the maximum
number of samples..
If the fragment shader statically assigns a value to _gl_SampleMask_, the
sample mask will be undefined for any array elements of any fragment shader
invocations that fail to assign a value.
If a shader does not statically assign a value to _gl_SampleMask_, the
sample mask has no effect on the processing of a fragment.

The input variable _gl_SampleID_ is filled with the sample number of the
sample currently being processed.
This variable is in the range _0_ to _gl_NumSamples-1_, where
_gl_NumSamples_ is the total number of samples in the framebuffer, or 1 if
rendering to a non-multisample framebuffer.
Any static use of this variable in a fragment shader causes the entire
shader to be evaluated per-sample.

The input variable _gl_SamplePosition_ contains the position of the current
sample within the multisample draw buffer.
The _x_ and _y_ components of _gl_SamplePosition_ contain the sub-pixel
coordinate of the current sample and will have values in the range 0.0 to
1.0.
Any static use of this variable in a fragment shader causes the entire
shader to be evaluated per sample.

The value _gl_HelperInvocation_ is *true* if the fragment shader invocation
is considered a _helper invocation_ and is *false* otherwise.
A helper invocation is a fragment shader invocation that is created solely
for the purposes of evaluating derivatives for use in non-helper fragment
shader invocations.
Such derivatives are computed implicitly in the built-in function
*texture*() (see "`<<texture-functions,Texture Functions>>`"), and
explicitly in the derivative functions in
"`<<derivative-functions,Derivative Functions>>`", for example *dFdx*() and
*dFdy*().

Fragment shader helper invocations execute the same shader code as
non-helper invocations, but will not have side effects that modify the
framebuffer or other shader-accessible memory.
In particular:

  * Fragments corresponding to helper invocations are discarded when shader
    execution is complete, without updating the framebuffer.
  * Stores to image and buffer variables performed by helper invocations
    have no effect on the underlying image or buffer memory.
  * Atomic operations to image, buffer, or atomic counter variables
    performed by helper invocations have no effect on the underlying image
    or buffer memory.
    The values returned by such atomic operations are undefined.

Helper invocations may be generated for pixels not covered by a primitive
being rendered.
While fragment shader inputs qualified with *centroid* are normally required
to be sampled in the intersection of the pixel and the primitive, the
requirement is ignored for such pixels since there is no intersection
between the pixel and primitive.

Helper invocations may also be generated for fragments that are covered by a
primitive being rendered when the fragment is killed by early fragment tests
(using the *early_fragment_tests* qualifier) or where the implementation is
able to determine that executing the fragment shader would have no effect
other than assisting in computing derivatives for other fragment shader
invocations.

The set of helper invocations generated when processing any set of
primitives is implementation-dependent.

ifdef::GLSL[]
_gl_ClipDistance_ contains linearly interpolated values for the vertex-
pipeline values written by a shader to the _gl_ClipDistance_ output
variable. Only elements in this array that have clipping enabled will
have defined values.

_gl_CullDistance_ contains linearly interpolated values for the vertex-
pipeline values written by a shader to the _gl_CullDistance_ output
variable.
endif::GLSL[]

The input variable _gl_PrimitiveID_ is filled with the value written to the
_gl_PrimitiveID_ geometry shader output, if a geometry shader is present.
Otherwise, it is filled with the number of primitives processed by the
shader since the current set of rendering primitives was started.

The input variable _gl_Layer_ is filled with the value written to the
_gl_Layer_ geometry shader output, if a geometry shader is present.
If the geometry stage does not dynamically assign a value to _gl_Layer_, the
value of _gl_Layer_ in the fragment stage will be undefined.
If the geometry stage makes no static assignment to _gl_Layer_, the input
value in the fragment stage will be zero.
Otherwise, the fragment stage will read the same value written by the
geometry stage, even if that value is out of range.
If a fragment shader contains a static access to _gl_Layer_, it will count
against the implementation defined limit for the maximum number of inputs to
the fragment stage.

ifdef::GLSL[]
The input variable _gl_ViewportIndex_ is filled with the value written to
the output variable _gl_ViewportIndex_ in the geometry stage, if a geometry
shader is present.
If the geometry stage does not dynamically assign a value to
_gl_ViewportIndex_, the value of _gl_ViewportIndex_ in the fragment shader
will be undefined.
If the geometry stage makes no static assignment to _gl_ViewportIndex_, the
fragment stage will read zero.
Otherwise, the fragment stage will read the same value written by the
geometry stage, even if that value is out of range.
If a fragment shader contains a static access to _gl_ViewportIndex_, it will
count against the implementation defined limit for the maximum number of
inputs to the fragment stage.
endif::GLSL[]


[[compute-shader-special-variables]]
=== Compute Shader Special Variables

In the compute shader, built-in variables are declared as follows:

[source,glsl]
----
// workgroup dimensions
in uvec3 gl_NumWorkGroups;
const uvec3 gl_WorkGroupSize;

// workgroup and invocation IDs
in uvec3 gl_WorkGroupID;
in uvec3 gl_LocalInvocationID;

// derived variables
in uvec3 gl_GlobalInvocationID;
in uint gl_LocalInvocationIndex;
----

The built-in variable _gl_NumWorkGroups_ is a compute-shader input variable
containing the number of workgroups in each dimension of the dispatch that
will execute the compute shader.
Its content is equal to the values specified in the _num_groups_x_,
_num_groups_y_, and _num_groups_z_ parameters passed to the
_DispatchCompute_ API entry point.

The built-in constant _gl_WorkGroupSize_ is a compute-shader constant
containing the workgroup size of the shader.
The size of the workgroup in the _X_, _Y_, and _Z_ dimensions is stored in
the _x_, _y_, and _z_ components.
The constant values in _gl_WorkGroupSize_ will match those specified in the
required *local_size_x*, *local_size_y*, and *local_size_z* layout
qualifiers for the current shader.
This is a constant so that it can be used to size arrays of memory that can
be shared within the workgroup.
It is a compile-time error to use _gl_WorkGroupSize_ in a shader that does
not declare a fixed workgroup size, or before that shader has declared a
fixed workgroup size, using *local_size_x*, *local_size_y*, and
*local_size_z*. Use of variables whose values are derived from
_gl_WorkGroupSize_, however, is not constrained to follow a declaration of the
fixed workgroup size.

The built-in variable _gl_WorkGroupID_ is a compute-shader input variable
containing the three-dimensional index of the workgroup that the
current invocation is executing in.
The possible values range across the parameters passed into
_DispatchCompute_, i.e., from (0, 0, 0) to (_gl_NumWorkGroups.x_ - 1,
_gl_NumWorkGroups.y_ - 1, _gl_NumWorkGroups.z_ -1).

The built-in variable _gl_LocalInvocationID_ is a compute-shader input
variable containing the three-dimensional index of the current work item
within the workgroup.
The possible values for this variable range across the workgroup
size, i.e., (0,0,0) to (_gl_WorkGroupSize.x_ - 1, _gl_WorkGroupSize.y_ - 1,
_gl_WorkGroupSize.z_ - 1). Use of _gl_LocalInvocationID_ is allowed
before declarations of *local_size_x*, *local_size_y*, and *local_size_z*.

The built-in variable _gl_GlobalInvocationID_ is a compute shader input
variable containing the global index of the current work item.
This value uniquely identifies this invocation from all other invocations
across all workgroups initiated by the current _DispatchCompute_ call.
This is computed as:

[source,glsl]
----
gl_GlobalInvocationID =
    gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;
----

The built-in variable _gl_LocalInvocationIndex_ is a compute shader input
variable that contains the one-dimensional representation of the
_gl_LocalInvocationID_.
This is computed as:

[source,glsl]
----
gl_LocalInvocationIndex =
    gl_LocalInvocationID.z * gl_WorkGroupSize.x * gl_WorkGroupSize.y +
    gl_LocalInvocationID.y * gl_WorkGroupSize.x +
    gl_LocalInvocationID.x;
----

Use of _gl_LocalInvocationIndex_ is allowed before declarations of
*local_size_x*, *local_size_y*, and *local_size_z*.

ifdef::GLSL[]
[[compatibility-profile-built-in-language-variables]]
=== Compatibility Profile Built-In Language Variables

When using the compatibility profile, the GL can provide fixed functionality
behavior for the vertex and fragment programmable pipeline stages.
For example, mixing a fixed functionality vertex stage with a programmable
fragment stage.

The following built-in vertex, tessellation control, tessellation
evaluation, and geometry output variables are available to specify inputs
for the subsequent programmable shader stage or the fixed functionality
fragment stage.
A particular one should be written to if any functionality in a
corresponding fragment shader or fixed pipeline uses it or state derived
from it.
Otherwise, behavior is undefined.
The following members are added to the output _gl_PerVertex_ block in these
languages:

[source,glsl]
----
out gl_PerVertex { // part of the gl_PerVertex block described in 7.1
    // in addition to other gl_PerVertex members...
    vec4  gl_ClipVertex;
    vec4  gl_FrontColor;
    vec4  gl_BackColor;
    vec4  gl_FrontSecondaryColor;
    vec4  gl_BackSecondaryColor;
    vec4  gl_TexCoord[];
    float gl_FogFragCoord;
};
----

The output variable _gl_ClipVertex_ provides a place for vertex and geometry
shaders to write the coordinate to be used with the user clipping half-spaces.
Writing to _gl_ClipDistance_ is the preferred method for user clipping.
It is a compile-time or link-time error for the set of shaders forming a
program to statically read or write both _gl_ClipVertex_ and either
_gl_ClipDistance_ or _gl_CullDistance_.
If neither _gl_ClipVertex_ nor _gl_ClipDistance_ is written, their values
are undefined and any clipping against user clip half-spaces is also undefined.

Similarly to what was previously described for the core profile, the
_gl_PerVertex_ block can be redeclared in a shader to explicitly include
these additional members.
For example:

[source,glsl]
----
out gl_PerVertex {
    vec4 gl_Position;    // will use gl_Position
    vec4 gl_FrontColor;  // will consume gl_color in the fragment shader
    vec4 gl_BackColor;
    vec4 gl_TexCoord[3]; // 3 elements of gl_TexCoord will be used
}; // no other aspects of the fixed interface will be used
----

The user must ensure the clip vertex and user clipping half-spaces are defined in
the same coordinate space.

The output variables _gl_FrontColor_, _glFrontSecondaryColor_,
_gl_BackColor_, and _glBackSecondaryColor_ assign primary and secondary
colors for front and back faces of primitives containing the vertex being
processed.
The output variable _gl_TexCoord_ assigns texture coordinates for the vertex
being processed.

For _gl_FogFragCoord_, the value written will be used as the "`c`" value in
section 16.4 "`Fog`" of the Compatibility profile of the
<<references,{apispec}>>, by the fixed functionality pipeline.
For example, if the z-coordinate of the fragment in eye space is desired as
"`c`", then that's what the vertex shader executable should write into
_gl_FogFragCoord_.

As with all arrays, indices used to subscript _gl_TexCoord_ must either be a
constant integral expressions, or this array must be redeclared by the
shader with a size.
The size can be at most _gl_MaxTextureCoords_.
Using indices close to 0 may aid the implementation in preserving varying
resources.
The redeclaration of _gl_TexCoord_ can also be done at global scope as, for
example:

[source,glsl]
----
in vec4 gl_TexCoord[3];
out vec4 gl_TexCoord[4];
----

(This treatment is a special case for _gl_TexCoord[]_, not a general method
for redeclaring members of blocks.) It is a compile-time error to redeclare
_gl_TexCoord[]_ at global scope if there is a redeclaration of the
corresponding built-in block; only one form of redeclaration is allowed
within a shader (and hence within a stage, as block redeclarations must
match across all shaders using it).

In the tessellation control, evaluation, and geometry shaders, the outputs
of the previous stage described above are also available in the input
_gl_PerVertex_ block in these languages.

[source,glsl]
----
in gl_PerVertex { // part of the gl_PerVertex block described in 7.1
    // in addition to other gl_PerVertex members...
    vec4  gl_ClipVertex;
    vec4  gl_FrontColor;
    vec4  gl_BackColor;
    vec4  gl_FrontSecondaryColor;
    vec4  gl_BackSecondaryColor;
    vec4  gl_TexCoord[];
    float gl_FogFragCoord;
} gl_in[];
----

These can be redeclared to establish an explicit pipeline interface, the
same way as described above for the output block _gl_PerVertex_, and the
input redeclaration must match the output redeclaration of the previous
stage.
However, when a built-in interface block with an instance name is redeclared
(e.g. _gl_in_), the instance name must be included in the redeclaration.
It is a compile-time error to not include the built-in instance name or to
change its name.
For example,

[source,glsl]
----
in gl_PerVertex {
    vec4 gl_ClipVertex;
    vec4 gl_FrontColor;
} gl_in[]; // must be present and must be "gl_in[]"
----

Built-in block arrays predeclared with a size can be redeclared with unsized syntax.
This keeps their size equal to the original predeclared size.

Treatment of _gl_TexCoord[]_ redeclaration is also identical to that
described for the output block _gl_TexCoord[]_ redeclaration.

The following fragment input block is also available in a fragment shader
when using the compatibility profile:

[source,glsl]
----
in gl_PerFragment {
    in float gl_FogFragCoord;
    in vec4  gl_TexCoord[];
    in vec4  gl_Color;
    in vec4  gl_SecondaryColor;
};
----

The values in _gl_Color_ and _gl_SecondaryColor_ will be derived
automatically by the system from _gl_FrontColor_, _gl_BackColor_,
_gl_FrontSecondaryColor_, and _gl_BackSecondaryColor_ based on which face is
visible in the primitive producing the fragment.
If fixed functionality is used for vertex processing, then _gl_FogFragCoord_
will either be the z-coordinate of the fragment in eye space, or the
interpolation of the fog coordinate, as described in section 16.4 "`Fog`" of
the Compatibility profile of the <<references,{apispec}>>.
The _gl_TexCoord[]_ values are the interpolated _gl_TexCoord[]_ values from
a vertex shader or the texture coordinates of any fixed pipeline based
vertex functionality.

Indices to the fragment shader _gl_TexCoord_ array are as described above in
the vertex shader text.

As described above for the input and output _gl_PerVertex_ blocks, the
_gl_PerFragment_ block can be redeclared to create an explicit interface to
another program.
When matching these interfaces between separate programs, members in the
_gl_PerVertex_ output block must be declared if and only if the
corresponding fragment shader members generated from them are present in the
_gl_PerFragment_ input block.
These matches are described in detail in section 7.4.1 "`Shader Interface
Matching`" of the <<references,{apispec}>>.
If they don't match within a program, a link-time error will result.
If the mismatch is between two programs, values passed between programs are
undefined.
Unlike with all other block matching, the order of declaration within
_gl_PerFragment_ does not have to match across shaders and does not have to
correspond with order of declaration in a matching _gl_PerVertex_
redeclaration.

The following fragment output variables are available in a fragment shader
when using the compatibility profile:

[source,glsl]
----
out vec4 gl_FragColor;
out vec4 gl_FragData[gl_MaxDrawBuffers];
----

Writing to _gl_FragColor_ specifies the fragment color that will be used by
the subsequent fixed functionality pipeline.
If subsequent fixed functionality consumes fragment color and an execution
of the fragment shader executable does not write a value to _gl_FragColor_
then the fragment color consumed is undefined.

The variable _gl_FragData_ is an array.
Writing to _gl_FragData[n]_ specifies the fragment data that will be used by
the subsequent fixed functionality pipeline for data _n_.
If subsequent fixed functionality consumes fragment data and an execution of
a fragment shader executable does not write a value to it, then the fragment
data consumed is undefined.

If a shader statically assigns a value to _gl_FragColor_, it may not assign
a value to any element of _gl_FragData_.
If a shader statically writes a value to any element of _gl_FragData_, it
may not assign a value to _gl_FragColor_.
That is, a shader may assign values to either _gl_FragColor_ or
_gl_FragData_, but not both.
Multiple shaders linked together must also consistently write just one of
these variables.
Similarly, if user-declared output variables are in use (statically assigned
to), then the built-in variables _gl_FragColor_ and _gl_FragData_ may not be
assigned to.
These incorrect usages all generate compile-time or link-time errors.

If a shader executes the *discard* keyword, the fragment is discarded, and
the values of _gl_FragDepth_ and _gl_FragColor_ become irrelevant.


[[compatibility-profile-vertex-shader-built-in-inputs]]
== Compatibility Profile Vertex Shader Built-In Inputs

The following predeclared input names can be used from within a vertex
shader to access the current values of {apiname} state when using the
compatibility profile.

[source,glsl]
----
in vec4 gl_Color;
in vec4 gl_SecondaryColor;
in vec3 gl_Normal;
in vec4 gl_Vertex;
in vec4 gl_MultiTexCoord0;
in vec4 gl_MultiTexCoord1;
in vec4 gl_MultiTexCoord2;
in vec4 gl_MultiTexCoord3;
in vec4 gl_MultiTexCoord4;
in vec4 gl_MultiTexCoord5;
in vec4 gl_MultiTexCoord6;
in vec4 gl_MultiTexCoord7;
in float gl_FogCoord;
----
endif::GLSL[]


[[built-in-constants]]
== Built-In Constants

The following built-in constants are declared in all shaders.
The actual values used are implementation-dependent, but must be at least
the value shown.

[source,glsl]
----
//
// Implementation-dependent constants. The example values below
// are the minimum values allowed for these maximums.
//

----

ifdef::GLSL[]
[source,glsl]
----
const int gl_MaxVertexAttribs = 16;
const int gl_MaxVertexUniformVectors = 256;
const int gl_MaxVertexUniformComponents = 1024;
const int gl_MaxVertexOutputComponents = 64;
const int gl_MaxVaryingComponents = 60;
const int gl_MaxVaryingVectors = 15;
const int gl_MaxVertexTextureImageUnits = 16;
const int gl_MaxVertexImageUniforms = 0;
const int gl_MaxVertexAtomicCounters = 0;
const int gl_MaxVertexAtomicCounterBuffers = 0;

const int gl_MaxTessPatchComponents = 120;
const int gl_MaxPatchVertices = 32;
const int gl_MaxTessGenLevel = 64;

const int gl_MaxTessControlInputComponents = 128;
const int gl_MaxTessControlOutputComponents = 128;
const int gl_MaxTessControlTextureImageUnits = 16;
const int gl_MaxTessControlUniformComponents = 1024;
const int gl_MaxTessControlTotalOutputComponents = 4096;
const int gl_MaxTessControlImageUniforms = 0;
const int gl_MaxTessControlAtomicCounters = 0;
const int gl_MaxTessControlAtomicCounterBuffers = 0;

const int gl_MaxTessEvaluationInputComponents = 128;
const int gl_MaxTessEvaluationOutputComponents = 128;
const int gl_MaxTessEvaluationTextureImageUnits = 16;
const int gl_MaxTessEvaluationUniformComponents = 1024;
const int gl_MaxTessEvaluationImageUniforms = 0;
const int gl_MaxTessEvaluationAtomicCounters = 0;
const int gl_MaxTessEvaluationAtomicCounterBuffers = 0;

const int gl_MaxGeometryInputComponents = 64;
const int gl_MaxGeometryOutputComponents = 128;
const int gl_MaxGeometryImageUniforms = 0;
const int gl_MaxGeometryTextureImageUnits = 16;
const int gl_MaxGeometryOutputVertices = 256;
const int gl_MaxGeometryTotalOutputComponents = 1024;
const int gl_MaxGeometryUniformComponents = 1024;
const int gl_MaxGeometryVaryingComponents = 64;            // deprecated
const int gl_MaxGeometryAtomicCounters = 0;
const int gl_MaxGeometryAtomicCounterBuffers = 0;

const int gl_MaxFragmentImageUniforms = 8;
const int gl_MaxFragmentInputComponents = 128;
const int gl_MaxFragmentUniformVectors = 256;
const int gl_MaxFragmentUniformComponents = 1024;
const int gl_MaxFragmentAtomicCounters = 8;
const int gl_MaxFragmentAtomicCounterBuffers = 1;

const int gl_MaxDrawBuffers = 8;
const int gl_MaxTextureImageUnits = 16;
const int gl_MinProgramTexelOffset = -8;
const int gl_MaxProgramTexelOffset = 7;
const int gl_MaxImageUnits = 8;
const int gl_MaxSamples = 4;
const int gl_MaxImageSamples = 0;
const int gl_MaxClipDistances = 8;
const int gl_MaxCullDistances = 8;
const int gl_MaxViewports = 16;

const int gl_MaxComputeImageUniforms = 8;
const ivec3 gl_MaxComputeWorkGroupCount = { 65535, 65535, 65535 };
const ivec3 gl_MaxComputeWorkGroupSize = { 1024, 1024, 64 };
const int gl_MaxComputeUniformComponents = 1024;
const int gl_MaxComputeTextureImageUnits = 16;
const int gl_MaxComputeAtomicCounters = 8;
const int gl_MaxComputeAtomicCounterBuffers = 8;

const int gl_MaxCombinedTextureImageUnits = 96;
const int gl_MaxCombinedImageUniforms = 48;
const int gl_MaxCombinedImageUnitsAndFragmentOutputs = 8;  // deprecated
const int gl_MaxCombinedShaderOutputResources = 16;
const int gl_MaxCombinedAtomicCounters = 8;
const int gl_MaxCombinedAtomicCounterBuffers = 1;
const int gl_MaxCombinedClipAndCullDistances = 8;
const int gl_MaxAtomicCounterBindings = 1;
const int gl_MaxAtomicCounterBufferSize = 32;

const int gl_MaxTransformFeedbackBuffers = 4;
const int gl_MaxTransformFeedbackInterleavedComponents = 64;

const highp int gl_MaxInputAttachments = 1;  // only present when targeting Vulkan
----
endif::GLSL[]

ifdef::ESSL[]
[source,glsl]
----
const mediump int gl_MaxVertexAttribs = 16;
const mediump int gl_MaxVertexUniformVectors = 256;
const mediump int gl_MaxVertexOutputVectors = 16;
const mediump int gl_MaxVertexTextureImageUnits = 16;
const mediump int gl_MaxVertexImageUniforms = 0;
const mediump int gl_MaxVertexAtomicCounters = 0;
const mediump int gl_MaxVertexAtomicCounterBuffers = 0;

const mediump int gl_MaxTessControlInputComponents = 64;
const mediump int gl_MaxTessControlOutputComponents = 64;
const mediump int gl_MaxTessControlTextureImageUnits = 16;
const mediump int gl_MaxTessControlUniformComponents = 1024;
const mediump int gl_MaxTessControlTotalOutputComponents = 2048;
const mediump int gl_MaxTessControlImageUniforms = 0;
const mediump int gl_MaxTessControlAtomicCounters = 0;
const mediump int gl_MaxTessControlAtomicCounterBuffers = 0;

const mediump int gl_MaxTessPatchComponents = 120;
const mediump int gl_MaxPatchVertices = 32;
const mediump int gl_MaxTessGenLevel = 64;

const mediump int gl_MaxTessEvaluationInputComponents = 64;
const mediump int gl_MaxTessEvaluationOutputComponents = 64;
const mediump int gl_MaxTessEvaluationTextureImageUnits = 16;
const mediump int gl_MaxTessEvaluationUniformComponents = 1024;
const mediump int gl_MaxTessEvaluationImageUniforms = 0;
const mediump int gl_MaxTessEvaluationAtomicCounters = 0;
const mediump int gl_MaxTessEvaluationAtomicCounterBuffers = 0;

const mediump int gl_MaxGeometryInputComponents = 64;
const mediump int gl_MaxGeometryOutputComponents = 64;
const mediump int gl_MaxGeometryImageUniforms = 0;
const mediump int gl_MaxGeometryTextureImageUnits = 16;
const mediump int gl_MaxGeometryOutputVertices = 256;
const mediump int gl_MaxGeometryTotalOutputComponents = 1024;
const mediump int gl_MaxGeometryUniformComponents = 1024;
const mediump int gl_MaxGeometryAtomicCounters = 0;
const mediump int gl_MaxGeometryAtomicCounterBuffers = 0;

const mediump int gl_MaxFragmentInputVectors = 15;
const mediump int gl_MaxFragmentImageUniforms = 4;
const mediump int gl_MaxFragmentUniformVectors = 256;
const mediump int gl_MaxFragmentAtomicCounters = 8;
const mediump int gl_MaxFragmentAtomicCounterBuffers = 1;

const mediump int gl_MaxDrawBuffers = 4;
const mediump int gl_MaxTextureImageUnits = 16;
const mediump int gl_MinProgramTexelOffset = -8;
const mediump int gl_MaxProgramTexelOffset = 7;
const mediump int gl_MaxImageUnits = 4;
const mediump int gl_MaxSamples = 4;

const mediump int gl_MaxComputeImageUniforms = 4;
const highp ivec3 gl_MaxComputeWorkGroupCount = ivec3(65535, 65535, 65535);
const highp ivec3 gl_MaxComputeWorkGroupSize = ivec3(128, 128, 64);
const mediump int gl_MaxComputeUniformComponents = 1024;
const mediump int gl_MaxComputeTextureImageUnits = 16;
const mediump int gl_MaxComputeAtomicCounters = 8;
const mediump int gl_MaxComputeAtomicCounterBuffers = 1;

const mediump int gl_MaxCombinedTextureImageUnits = 96;
const mediump int gl_MaxCombinedImageUniforms = 4;
const mediump int gl_MaxCombinedShaderOutputResources = 4;
const mediump int gl_MaxCombinedAtomicCounters = 8;
const mediump int gl_MaxCombinedAtomicCounterBuffers = 1;
const mediump int gl_MaxAtomicCounterBindings = 1;
const mediump int gl_MaxAtomicCounterBufferSize = 32;

const highp int gl_MaxInputAttachments = 1;  // only present when targeting Vulkan
----
endif::ESSL[]

ifdef::GLSL[]
The constant _gl_MaxVaryingFloats_ is removed in the core profile, use
_gl_MaxVaryingComponents_ instead.


[[compatibility-profile-built-in-constants]]
=== Compatibility Profile Built-In Constants

[source,glsl]
----
const int gl_MaxTextureUnits = 2;
const int gl_MaxTextureCoords = 8;
const int gl_MaxClipPlanes = 8;
const int gl_MaxVaryingFloats = 60;
----
endif::GLSL[]


[[built-in-uniform-state]]
== Built-In Uniform State

Built-in uniform state is not available when generating SPIR-V.
Otherwise, as an aid to accessing {apiname} processing state, the following
uniform variables are built into the {slname}.

ifdef::GLSL[]
[source,glsl]
----
//
// Depth range in window coordinates,
// section 13.6.1 "Controlling the Viewport" in the
// OpenGL Specification.
//
// Note: Depth-range state is only for viewport 0.
//
struct gl_DepthRangeParameters {
    float near; // n
    float far;  // f
    float diff; // f - n
};
uniform gl_DepthRangeParameters gl_DepthRange;
uniform int gl_NumSamples;
----
endif::GLSL[]
ifdef::ESSL[]
[source,glsl]
----
//
// Depth range in window coordinates,
// section 12.5.1 "Controlling the Viewport" in the
// OpenGL ES Specification.
//
struct gl_DepthRangeParameters {
    highp float near; // n
    highp float far;  // f
    highp float diff; // f - n
};
uniform gl_DepthRangeParameters gl_DepthRange;
uniform lowp int gl_NumSamples;
----
endif::ESSL[]

These variables are only guaranteed to be available in the fragment stage.
In other stages, their presence and function is implementation-defined.


ifdef::GLSL[]
[[compatibility-profile-state]]
=== Compatibility Profile State

These variables are present only in the compatibility profile.
They are not available to compute shaders, but are available to all other
shaders.

[source,glsl]
----
//
// compatibility profile only
//
uniform mat4 gl_ModelViewMatrix;
uniform mat4 gl_ProjectionMatrix;
uniform mat4 gl_ModelViewProjectionMatrix;
uniform mat4 gl_TextureMatrix[gl_MaxTextureCoords];

//
// compatibility profile only
//
uniform mat3 gl_NormalMatrix; // transpose of the inverse of the
                              // upper leftmost 3x3 of gl_ModelViewMatrix

uniform mat4 gl_ModelViewMatrixInverse;
uniform mat4 gl_ProjectionMatrixInverse;
uniform mat4 gl_ModelViewProjectionMatrixInverse;
uniform mat4 gl_TextureMatrixInverse[gl_MaxTextureCoords];

uniform mat4 gl_ModelViewMatrixTranspose;
uniform mat4 gl_ProjectionMatrixTranspose;
uniform mat4 gl_ModelViewProjectionMatrixTranspose;
uniform mat4 gl_TextureMatrixTranspose[gl_MaxTextureCoords];

uniform mat4 gl_ModelViewMatrixInverseTranspose;
uniform mat4 gl_ProjectionMatrixInverseTranspose;
uniform mat4 gl_ModelViewProjectionMatrixInverseTranspose;
uniform mat4 gl_TextureMatrixInverseTranspose[gl_MaxTextureCoords];

//
// compatibility profile only
//
uniform float gl_NormalScale;

//
// compatibility profile only
//
uniform vec4 gl_ClipPlane[gl_MaxClipPlanes];

//
// compatibility profile only
//
struct gl_PointParameters {
    float size;
    float sizeMin;
    float sizeMax;
    float fadeThresholdSize;
    float distanceConstantAttenuation;
    float distanceLinearAttenuation;
    float distanceQuadraticAttenuation;
};

uniform gl_PointParameters gl_Point;

//
// compatibility profile only
//
struct gl_MaterialParameters {
 vec4 emission;   // Ecm
 vec4 ambient;    // Acm
 vec4 diffuse;    // Dcm
 vec4 specular;   // Scm
 float shininess; // Srm
};
uniform gl_MaterialParameters gl_FrontMaterial;
uniform gl_MaterialParameters gl_BackMaterial;

//
// compatibility profile only
//
struct gl_LightSourceParameters {
    vec4 ambient;               // Acli
    vec4 diffuse;               // Dcli
    vec4 specular;              // Scli
    vec4 position;              // Ppli
    vec4 halfVector;            // Derived: Hi
    vec3 spotDirection;         // Sdli
    float spotExponent;         // Srli
    float spotCutoff;           // Crli
                                // (range: [0.0,90.0], 180.0)
    float spotCosCutoff;        // Derived: cos(Crli)
                                // (range: [1.0,0.0],-1.0)
    float constantAttenuation;  // K0
    float linearAttenuation;    // K1
    float quadraticAttenuation; // K2
};

uniform gl_LightSourceParameters gl_LightSource[gl_MaxLights];

struct gl_LightModelParameters {
    vec4 ambient;                  // Acs
};

uniform gl_LightModelParameters gl_LightModel;

//
// compatibility profile only
//
// Derived state from products of light and material.
//

struct gl_LightModelProducts {
    vec4 sceneColor; // Derived. Ecm + Acm * Acs
};

uniform gl_LightModelProducts gl_FrontLightModelProduct;
uniform gl_LightModelProducts gl_BackLightModelProduct;

struct gl_LightProducts {
    vec4 ambient; // Acm * Acli
    vec4 diffuse; // Dcm * Dcli
    vec4 specular; // Scm * Scli
};

uniform gl_LightProducts gl_FrontLightProduct[gl_MaxLights];
uniform gl_LightProducts gl_BackLightProduct[gl_MaxLights];

//
// compatibility profile only
//
uniform vec4 gl_TextureEnvColor[gl_MaxTextureUnits];
uniform vec4 gl_EyePlaneS[gl_MaxTextureCoords];
uniform vec4 gl_EyePlaneT[gl_MaxTextureCoords];
uniform vec4 gl_EyePlaneR[gl_MaxTextureCoords];
uniform vec4 gl_EyePlaneQ[gl_MaxTextureCoords];
uniform vec4 gl_ObjectPlaneS[gl_MaxTextureCoords];
uniform vec4 gl_ObjectPlaneT[gl_MaxTextureCoords];
uniform vec4 gl_ObjectPlaneR[gl_MaxTextureCoords];
uniform vec4 gl_ObjectPlaneQ[gl_MaxTextureCoords];

//
// compatibility profile only
//
struct gl_FogParameters {
    vec4 color;
    float density;
    float start;
    float end;
    float scale; // Derived: 1.0 / (end - start)
};

uniform gl_FogParameters gl_Fog;
----
endif::GLSL[]


[[redeclaring-built-in-blocks]]
== Redeclaring Built-In Blocks

The _gl_PerVertex_ block can be redeclared in a shader to explicitly
indicate what subset of the fixed pipeline interface will be used.
This is necessary to establish the interface between multiple programs.
ifdef::GLSL[]
For example:

[source,glsl]
----
out gl_PerVertex {
    vec4 gl_Position;   // will use gl_Position
    float gl_PointSize; // will use gl_PointSize
    vec4 t;             // error, only gl_PerVertex members allowed
}; // no other members of gl_PerVertex will be used
----

This establishes the output interface the shader will use with the
subsequent pipeline stage.
It must be a subset of the built-in members of _gl_PerVertex_.
Such a redeclaration can also add the *invariant* qualifier, interpolation
qualifiers, and the layout qualifiers *xfb_offset*, *xfb_buffer*, and
*xfb_stride*.
It can also add an array size for unsized arrays.
For example:

[source,glsl]
----
out layout(xfb_buffer = 1, xfb_stride = 16) gl_PerVertex {
    vec4 gl_Position;
    layout(xfb_offset = 0) float gl_ClipDistance[4];
};
----
endif::GLSL[]
ifdef::ESSL[]
If the _gl_PerVertex_ block is not redefined in a given program, the
intrinsically declared definition of that block is used for the program
interface.

For example:

[source,glsl]
----
out gl_PerVertex {
    highp vec4 gl_Position; // will use gl_Position
    highp vec4 t;           // error, only gl_PerVertex members allowed
}; // no other members of gl_PerVertex will be used
----

This establishes the output interface the shader will use with the
subsequent pipeline stage.
It must be a subset of the built-in members of _gl_PerVertex_.
Such a redeclaration can also add the *invariant* qualifier and
interpolation qualifiers.
endif::ESSL[]

Other layout qualifiers, like *location*, cannot be added to such a
redeclaration, unless specifically stated.

If a built-in interface block is redeclared, it must appear in the shader
before any use of any member included in the built-in declaration, or a
compile-time error will result.
It is also a compile-time error to redeclare the block more than once or to
redeclare a built-in block and then use a member from that built-in block
that was not included in the redeclaration.
Also, if a built-in interface block is redeclared, no member of the built-in
declaration can be redeclared outside the block redeclaration.
If multiple shaders using members of a built-in block belonging to the same
interface are linked together in the same program, they must all redeclare
the built-in block in the same way, as described in
"`<<interface-blocks,Interface Blocks>>`" for interface block matching, or a
link-time error will result.
It will also be a link-time error if some shaders in a program redeclare a
specific built-in interface block while another shader in that program does
not redeclare that interface block yet still uses a member of that interface
block.
If a built-in block interface is formed across shaders in different
programs, the shaders must all redeclare the built-in block in the same way
(as described for a single program), or the values passed along the
interface are undefined.

// Copyright 2008-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0
// chapters/builtinfunctions.adoc
[[built-in-functions]]
= Built-In Functions
<<toc>>


The {slname} defines an assortment of built-in convenience functions for
scalar and vector operations.
Many of these built-in functions can be used in more than one type of
shader, but some are intended to provide a direct mapping to hardware and so
are available only for a specific type of shader.

The built-in functions basically fall into three categories:

  * They expose some necessary hardware functionality in a convenient way
    such as accessing a texture map.
    There is no way in the language for these functions to be emulated by a
    shader.
  * They represent a trivial operation (clamp, mix, etc.) that is very
    simple for the user to write, but they are very common and may have
    direct hardware support.
    It is a very hard problem for the compiler to map expressions to complex
    assembler instructions.
  * They represent an operation graphics hardware is likely to accelerate at
    some point.
    The trigonometry functions fall into this category.

Many of the functions are similar to the same named ones in common C
libraries, but they support vector input as well as the more traditional
scalar input.

Applications should be encouraged to use the built-in functions rather than
do the equivalent computations in their own shader code since the built-in
functions are assumed to be optimal (e.g. perhaps supported directly in
hardware).

ifdef::GLSL[]
User code can replace built-in functions with their own if they choose, by
simply redeclaring and defining the same name and argument list.
Because built-in functions are in a more outer scope than user built-in
functions, doing this will hide all built-in functions with the same name as
the redeclared function.
endif::GLSL[]

When the built-in functions are specified below, where the input arguments
(and corresponding output) can be *float*, *vec2*, *vec3*, or *vec4*,
_genFType_ is used as the argument.
Where the input arguments (and corresponding output) can be *int*, *ivec2*,
*ivec3*, or *ivec4*, _genIType_ is used as the argument.
Where the input arguments (and corresponding output) can be *uint*, *uvec2*,
*uvec3*, or *uvec4*, _genUType_ is used as the argument.
Where the input arguments (or corresponding output) can be *bool*, *bvec2*,
*bvec3*, or *bvec4*, _genBType_ is used as the argument.
ifdef::GLSL[]
Where the input arguments (and corresponding output) can be *double*,
*dvec2*, *dvec3*, *dvec4*, _genDType_ is used as the argument.
endif::GLSL[]
For any specific use of a function, the actual types substituted for
_genFType_, _genIType_, _genUType_, or _genBType_ have to have the same
number of components for all arguments and for the return type.
Similarly, _mat_ is used for any matrix basic
ifdef::ESSL[type.]
ifdef::GLSL[]
type with single-precision
components and _dmat_ is used for any matrix basic type with
double-precision components.
endif::GLSL[]

Built-in functions have an effective precision qualification.
This qualification cannot be set explicitly and may be different from the
precision qualification of the result.

ifdef::GLSL[]
Note: In general, as has been noted, precision qualification is ignored
unless targeting Vulkan.
endif::GLSL[]

The precision qualification of the operation of a built-in function is based
on the precision qualification of its formal parameters and actual
parameters (input arguments): When a formal parameter specifies a precision
qualifier, that is used, otherwise, the precision qualification of the
actual (calling) argument is used.
The highest precision of these will be the precision of the operation of the
built-in function.
Generally, this is applied across all arguments to a built-in function, with
the exceptions being:

  * *bitfieldExtract* and *bitfieldInsert* ignore the _offset_ and _bits_
    arguments.
  * *interpolateAt* functions only look at the _interpolant_ argument.

The precision qualification of the result of a built-in function is
determined in one of the following ways:

For the texture sampling and image load functions, the
precision of the return type matches the precision of the
image or texture-combined sampler type:

[source,glsl]
----
uniform lowp sampler2D texSampler;
highp vec2 coord;
...
lowp vec4 col = texture (texSampler, coord); // texture() returns lowp
----

Otherwise:

  * For prototypes that do not specify a resulting precision qualifier, the
    precision will be the same as the precision of the operation (as defined
    earlier).
  * For prototypes that do specify a resulting precision qualifier, the
    specified precision qualifier is the precision qualification of the
    result.

Where the built-in functions in the following sections specify an equation,
the entire equation will be evaluated at the operation's precision.
This may lead to underflow or overflow in the result, even when the correct
result could be represented in the operation precision.


[[angle-and-trigonometry-functions]]
== Angle and Trigonometry Functions

Function parameters specified as _angle_ are assumed to be in units of
radians.
In no case will any of these functions result in a divide by zero error.
If the divisor of a ratio is 0, then results will be undefined.

These all operate component-wise.
The description is per component.

[options="header"]
|====
| Syntax | Description
| genFType *radians*(genFType _degrees_)
    | Converts _degrees_ to radians, i.e.,
      [eq]#({pi} / 180) {cdot} degrees#.
| genFType *degrees*(genFType _radians_)
    | Converts _radians_ to degrees, i.e.,
      [eq]#(180 / {pi}) {cdot} radians#.
| genFType *sin*(genFType _angle_)
    | The standard trigonometric sine function.
| genFType *cos*(genFType _angle_)
    | The standard trigonometric cosine function.
| genFType *tan*(genFType _angle_)
    | The standard trigonometric tangent.
| genFType *asin*(genFType _x_)
    | Arc sine.
      Returns an angle whose sine is _x_.
      The range of values returned by this function is
      [eq]#[-{pi} / 2, {pi} / 2]#.
      Results are undefined if [eq]#{vert}x{vert} > 1#.
| genFType *acos*(genFType _x_)
    | Arc cosine.
      Returns an angle whose cosine is _x_.
      The range of values returned by this function is [eq]#[0,{pi}]#.
      Results are undefined if [eq]#{vert}x{vert} > 1#.
| genFType *atan*(genFType _y_, genFType _x_)
    | Arc tangent.
      Returns an angle whose tangent is [eq]#y / x#.
      The signs of _x_ and _y_ are used to determine what quadrant the angle
      is in.
      The range of values returned by this function is [eq]#[-{pi}, {pi}]#.
      Results are undefined if _x_ and _y_ are both 0.
| genFType *atan*(genFType _y_over_x_)
    | Arc tangent.
      Returns an angle whose tangent is _y_over_x_.
      The range of values returned by this function is
      [eq]#[-{pi} / 2, {pi} / 2]#.
| genFType *sinh*(genFType _x_)
    | Returns the hyperbolic sine function [eq]#(e^x^ - e^-x^) / 2#.
| genFType *cosh*(genFType _x_)
    | Returns the hyperbolic cosine function [eq]#(e^x^ + e^-x^) / 2#.
| genFType *tanh*(genFType _x_)
    | Returns the hyperbolic tangent function [eq]#sinh(x) / cosh(x)#.
| genFType *asinh*(genFType _x_)
    | Arc hyperbolic sine; returns the inverse of *sinh*.
| genFType *acosh*(genFType _x_)
    | Arc hyperbolic cosine; returns the non-negative inverse of *cosh*.
      Results are undefined if [eq]#x < 1#.
| genFType *atanh*(genFType _x_)
    | Arc hyperbolic tangent; returns the inverse of *tanh*.
      Results are undefined if [eq]#{vert}x{vert} {geq} 1#.
|====


[[exponential-functions]]
== Exponential Functions

These all operate component-wise.
The description is per component.

[options="header"]
|====
| Syntax | Description
| genFType *pow*(genFType _x_, genFType _y_)
    | Returns _x_ raised to the _y_ power, i.e., [eq]#x^y^#.
      Results are undefined if [eq]#x < 0#.
      Results are undefined if [eq]#x = 0# and [eq]#y {leq} 0#.
| genFType *exp*(genFType _x_)
    | Returns the natural exponentiation of _x_, i.e., [eq]#e^x^#.
| genFType *log*(genFType _x_)
    | Returns the natural logarithm of _x_, i.e., returns the value _y_
      which satisfies the equation [eq]#x = e^y^#.
      Results are undefined if [eq]#x {leq} 0#.
| genFType *exp2*(genFType _x_)
    | Returns 2 raised to the _x_ power, i.e., [eq]#2^x^#.
| genFType *log2*(genFType _x_)
    | Returns the base 2 logarithm of _x_, i.e., returns the value _y_ which
      satisfies the equation [eq]#x = 2^y^#.
      Results are undefined if [eq]#x {leq} 0#.
ifdef::GLSL[]
| genFType *sqrt*(genFType _x_) +
  genDType *sqrt*(genDType _x_)
endif::GLSL[]
ifdef::ESSL[]
| genFType *sqrt*(genFType _x_)
endif::ESSL[]
    | Returns [eq]#sqrt(x)#.
      Results are undefined if [eq]#x < 0#.
ifdef::GLSL[]
| genFType *inversesqrt*(genFType _x_) +
  genDType *inversesqrt*(genDType _x_)
endif::GLSL[]
ifdef::ESSL[]
| genFType *inversesqrt*(genFType _x_)
endif::ESSL[]
    | Returns [eq]#1 / sqrt(x)#.
      Results are undefined if [eq]#x {leq} 0#.
|====


[[common-functions]]
== Common Functions

These all operate component-wise.
The description is per component.

[options="header"]
|====
| Syntax | Description
| genFType *abs*(genFType _x_) +
ifdef::GLSL[]
  genIType *abs*(genIType _x_) +
  genDType *abs*(genDType _x_)
endif::GLSL[]
ifdef::ESSL[]
  genIType *abs*(genIType _x_)
endif::ESSL[]
    | Returns _x_ if [eq]#x {geq} 0#; otherwise it returns -_x_.
| genFType *sign*(genFType _x_) +
ifdef::GLSL[]
  genIType *sign*(genIType _x_) +
  genDType *sign*(genDType _x_)
endif::GLSL[]
ifdef::ESSL[]
  genIType *sign*(genIType _x_)
endif::ESSL[]
    | Returns 1.0 if _x_ > 0, 0.0 if _x_ = 0, or -1.0 if _x_ < 0.
ifdef::GLSL[]
| genFType *floor*(genFType _x_) +
  genDType *floor*(genDType _x_)
endif::GLSL[]
ifdef::ESSL[]
| genFType *floor*(genFType _x_)
endif::ESSL[]
    | Returns a value equal to the nearest integer that is less than or
      equal to _x_.
ifdef::GLSL[]
| genFType *trunc*(genFType _x_) +
  genDType *trunc*(genDType _x_)
endif::GLSL[]
ifdef::ESSL[]
| genFType *trunc*(genFType _x_)
endif::ESSL[]
    | Returns a value equal to the nearest integer to _x_ whose absolute
      value is not larger than the absolute value of _x_.
ifdef::GLSL[]
| genFType *round*(genFType _x_) +
  genDType *round*(genDType _x_)
endif::GLSL[]
ifdef::ESSL[]
| genFType *round*(genFType _x_)
endif::ESSL[]
    | Returns a value equal to the nearest integer to _x_.
      The fraction 0.5 will round in a direction chosen by the
      implementation, presumably the direction that is fastest.
      This includes the possibility that *round*(_x_) returns the same value
      as *roundEven*(_x_) for all values of _x_.
ifdef::GLSL[]
| genFType *roundEven*(genFType _x_) +
  genDType *roundEven*(genDType _x_)
endif::GLSL[]
ifdef::ESSL[]
| genFType *roundEven*(genFType _x_)
endif::ESSL[]
    | Returns a value equal to the nearest integer to _x_.
      A fractional part of 0.5 will round toward the nearest even integer.
      (Both 3.5 and 4.5 for x will return 4.0.)
ifdef::GLSL[]
| genFType *ceil*(genFType _x_) +
  genDType *ceil*(genDType _x_)
endif::GLSL[]
ifdef::ESSL[]
| genFType *ceil*(genFType _x_)
endif::ESSL[]
    | Returns a value equal to the nearest integer that is greater than or
      equal to _x_.
ifdef::GLSL[]
| genFType *fract*(genFType _x_) +
  genDType *fract*(genDType _x_) +
endif::GLSL[]
ifdef::ESSL[]
| genFType *fract*(genFType _x_)
endif::ESSL[]
    | Returns _x_ - *floor*(_x_).
| genFType *mod*(genFType _x_, float _y_) +
ifdef::GLSL[]
  genFType *mod*(genFType _x_, genFType _y_) +
  genDType *mod*(genDType _x_, double _y_) +
  genDType *mod*(genDType _x_, genDType _y_) +
endif::GLSL[]
ifdef::ESSL[]
  genFType *mod*(genFType _x_, genFType _y_)
endif::ESSL[]
    | Modulus.
      Returns [eq]#x - y {cdot} *floor*(x / y)#.

      Note that implementations may use a cheap approximation to the remainder,
      and the error can be large due to the discontinuity in *floor*. This can
      produce mathematically unexpected results in some cases, such as
      *mod*(_x_,_x_) computing _x_ rather than 0, and can also cause the result
      to have a different sign than the infinitely precise result.
ifdef::GLSL[]
| genFType *modf*(genFType _x_, out genFType _i_) +
  genDType *modf*(genDType _x_, out genDType _i_)
endif::GLSL[]
ifdef::ESSL[]
| genFType *modf*(genFType _x_, out genFType _i_) +
endif::ESSL[]
   | Returns the fractional part of _x_ and sets _i_ to the integer part (as
      a whole number floating-point value).
      Both the return value and the output parameter will have the same sign
      as _x_.
ifdef::ESSL[]
      If _x_ has the value +/- Inf, the return value should be NaN and must
      be either NaN or 0.0.
      For *highp* non-constant expressions, the value returned must be
      consistent.
endif::ESSL[]
| genFType *min*(genFType _x_, genFType _y_) +
  genFType *min*(genFType _x_, float _y_) +
ifdef::GLSL[]
  genDType *min*(genDType _x_, genDType _y_) +
  genDType *min*(genDType _x_, double _y_) +
endif::GLSL[]
  genIType *min*(genIType _x_, genIType _y_) +
  genIType *min*(genIType _x_, int _y_) +
  genUType *min*(genUType _x_, genUType _y_) +
  genUType *min*(genUType _x_, uint _y_)
    | Returns _y_ if _y_ < _x;_ otherwise it returns _x_. Which operand is the result is undefined if one of the operands is a NaN.
| genFType *max*(genFType _x_, genFType _y_) +
  genFType *max*(genFType _x_, float _y_) +
ifdef::GLSL[]
  genDType *max*(genDType _x_, genDType _y_) +
  genDType *max*(genDType _x_, double _y_) +
endif::GLSL[]
  genIType *max*(genIType _x_, genIType _y_) +
  genIType *max*(genIType _x_, int _y_) +
  genUType *max*(genUType _x_, genUType _y_) +
  genUType *max*(genUType _x_, uint _y_)
    | Returns _y_ if _x_ < _y;_ otherwise it returns _x_. Which operand is the result is undefined if one of the operands is a NaN.
| genFType *clamp*(genFType _x_, genFType _minVal_, genFType _maxVal_) +
  genFType *clamp*(genFType _x_, float _minVal_, float _maxVal_) +
ifdef::GLSL[]
  genDType *clamp*(genDType _x_, genDType _minVal_, genDType _maxVal_) +
  genDType *clamp*(genDType _x_, double _minVal_, double _maxVal_) +
endif::GLSL[]
  genIType *clamp*(genIType _x_, genIType _minVal_, genIType _maxVal_) +
  genIType *clamp*(genIType _x_, int _minVal_, int _maxVal_) +
  genUType *clamp*(genUType _x_, genUType _minVal_, genUType _maxVal_) +
  genUType *clamp*(genUType _x_, uint _minVal_, uint _maxVal_)
    | Returns *min*(*max*(_x_, _minVal_), _maxVal_).
      Results are undefined if _minVal_ > _maxVal_.
| genFType *mix*(genFType _x_, genFType _y_, genFType _a_) +
  genFType *mix*(genFType _x_, genFType _y_, float _a_) +
ifdef::GLSL[]
  genDType *mix*(genDType _x_, genDType _y_, genDType _a_) +
  genDType *mix*(genDType _x_, genDType _y_, double _a_) +
endif::GLSL[]
    | Returns the linear blend of _x_ and _y_, i.e.,
      [eq]#x {cdot} (1 - a) + y {cdot} a#.
| genFType *mix*(genFType _x_, genFType _y_,  genBType _a_) +
ifdef::GLSL[]
  genDType *mix*(genDType _x_, genDType _y_, genBType _a_) +
endif::GLSL[]
  genIType *mix*(genIType _x_, genIType _y_, genBType _a_) +
  genUType *mix*(genUType _x_, genUType _y_, genBType _a_) +
  genBType *mix*(genBType _x_, genBType _y_, genBType _a_)
    | Selects which vector each returned component comes from.
      For a component of _a_ that is *false*, the corresponding component of
      _x_ is returned.
      For a component of _a_ that is *true*, the corresponding component of
      _y_ is returned.
      Components of _x_ and _y_ that are not selected are allowed to be
      invalid floating-point values and will have no effect on the results.
      Thus, this provides different functionality than, for example, +
      genFType *mix*(genFType _x_, genFType _y_, genFType(_a_)) +
      where _a_ is a Boolean vector.
| genFType *step*(genFType _edge_, genFType _x_) +
ifdef::GLSL[]
  genFType *step*(float _edge_, genFType _x_) +
  genDType *step*(genDType _edge_, genDType _x_) +
  genDType *step*(double _edge_, genDType _x_)
endif::GLSL[]
ifdef::ESSL[]
  genFType *step*(float _edge_, genFType _x_)
endif::ESSL[]
    | Returns 0.0 if _x_ < _edge;_ otherwise it returns 1.0.
| genFType *smoothstep*(genFType _edge0_, genFType _edge1_, genFType _x_) +
  genFType *smoothstep*(float _edge0_, float _edge1_, genFType _x_) +
ifdef::GLSL[]
  genDType *smoothstep*(genDType _edge0_, genDType _edge1_, genDType _x_) +
  genDType *smoothstep*(double _edge0_, double _edge1_, genDType _x_) +
endif::GLSL[]
   a| Returns 0.0 if [eq]#x {leq} edge0# and 1.0 if [eq]#x {geq} edge1#, and
      performs smooth Hermite interpolation between 0 and 1 when [eq]#edge0
      < x < edge1#.
      This is useful in cases where you would want a threshold function with
      a smooth transition.
      This is equivalent to:
--
[source,glsl]
----
genFType t;
t = clamp ((x - edge0) / (edge1 - edge0), 0, 1);
return t * t * (3 - 2 * t);
----

(And similarly for doubles.) Results are undefined if [eq]#edge0 {geq}
edge1#.
--
ifdef::GLSL[]
| genBType *isnan*(genFType _x_) +
  genBType *isnan*(genDType _x_)
endif::GLSL[]
ifdef::ESSL[]
| genBType *isnan*(genFType _x_)
endif::ESSL[]
    | Returns *true* if _x_ holds a NaN.
      Returns *false* otherwise.
      Always returns *false* if NaNs are not implemented.
ifdef::GLSL[]
| genBType *isinf*(genFType _x_) +
  genBType *isinf*(genDType _x_)
endif::GLSL[]
ifdef::ESSL[]
| genBType *isinf*(genFType _x_)
endif::ESSL[]
    | Returns *true* if _x_ holds a positive infinity or negative infinity.
      Returns *false* otherwise.
| genIType *floatBitsToInt*(highp genFType _value_) +
  genUType *floatBitsToUint*(highp genFType _value_)
    | Returns a signed or unsigned integer value representing the encoding
      of a floating-point value.
      The *float* value's bit-level representation is preserved.
| genFType *intBitsToFloat*(highp genIType _value_) +
  genFType *uintBitsToFloat*(highp genUType _value_)
    | Returns a floating-point value corresponding to a signed or unsigned
      integer encoding of a floating-point value.
ifdef::GLSL[]
      If a NaN is passed in, it will not signal, and the resulting value is
      unspecified.
      If an Inf is passed in, the resulting value is the corresponding Inf.
endif::GLSL[]
ifdef::ESSL[]
      If an Inf or NaN is passed in, it will not signal, and the resulting
      floating-point value is unspecified.
endif::ESSL[]
      If a subnormal number is passed in, the result might be flushed to 0.
      Otherwise, the bit-level representation is preserved.
| genFType *fma*(genFType _a_, genFType _b_, genFType _c_) +
ifdef::GLSL[]
  genDType *fma*(genDType _a_, genDType _b_, genDType _c_)
endif::GLSL[]
   a| Computes and returns `a * b + c`.
      In uses where the return value is eventually consumed by a variable
      declared as *precise*:
--
  * *fma*() is considered a single operation, whereas the expression `a * b
    + c` consumed by a variable declared *precise* is considered two
    operations.
  * The precision of *fma*() can differ from the precision of the expression
    `a * b + c`.
  * *fma*() will be computed with the same precision as any other *fma*()
    consumed by a precise variable, giving invariant results for the same
    input values of _a_, _b_, and _c_.

Otherwise, in the absence of *precise* consumption, there are no special
constraints on the number of operations or difference in precision between
*fma*() and the expression `a * b + c`.
--
| genFType *frexp*(highp genFType _x_, out highp genIType _exp_)
ifdef::GLSL[]
  genDType *frexp*(genDType _x_, out genIType _exp_) +
endif::GLSL[]
    | Splits _x_ into a floating-point significand in the range
      [eq]#[0.5,1.0]#, and an integral exponent of two, such that

      [eq]#x = significand {cdot} 2^exponent^#

      The significand is returned by the function and the exponent is
      returned in the parameter _exp_.
      For a floating-point value of zero, the significand and exponent are
      both zero.

      If an implementation supports signed zero, an input value of minus
      zero should return a significand of minus zero.
      For a floating-point value that is an infinity or is not a number, the
      results are undefined.

      If the input _x_ is a vector, this operation is performed in a
      component-wise manner; the value returned by the function and the
      value written to _exp_ are vectors with the same number of components
      as _x_.
| genFType *ldexp*(highp genFType _x_, highp genIType _exp_) +
ifdef::GLSL[]
  genDType *ldexp*(genDType _x_, genIType _exp_)
endif::GLSL[]
    | Builds a floating-point number from _x_ and the corresponding integral
      exponent of two in _exp_, returning:

      [eq]#significand {cdot} 2^exponent^#

      If this product is too large to be represented in the floating-point
      type, the result is undefined.

ifdef::GLSL[]
      If _exp_ is greater than +128 (single-precision) or +1024
      (double-precision), the value returned is undefined.
      If _exp_ is less than -126 (single-precision) or -1022
      (double-precision), the value returned may be flushed to zero.
endif::GLSL[]
ifdef::ESSL[]
      If _exp_ is greater than +128, the value returned is undefined.
      If _exp_ is less than -126, the value returned may be flushed to zero.
endif::ESSL[]
      Additionally, splitting the value into a significand and exponent
      using *frexp*() and then reconstructing a floating-point value using
      *ldexp*() should yield the original input for zero and all finite
      non-subnormal values. +
      If the input _x_ is a vector, this operation is performed in a
      component-wise manner; the value passed in _exp_ and returned by the
      function are vectors with the same number of components as _x_.
|====


[[floating-point-pack-and-unpack-functions]]
== Floating-Point Pack and Unpack Functions

These functions do not operate component-wise, rather, as described in each
case.

[options="header"]
|====
| Syntax | Description
| highp uint *packUnorm2x16*(vec2 _v_) +
  highp uint *packSnorm2x16*(vec2 _v_) +
  {highp} uint *packUnorm4x8*(vec4 _v_) +
  {highp} uint *packSnorm4x8*(vec4 _v_)
    | First, converts each component of the normalized floating-point value
      _v_ into 16-bit (*2x16*) or 8-bit (*4x8*) integer values.
      Then, the results are packed into the returned 32-bit unsigned
      integer.

      The conversion for component _c_ of _v_ to fixed point is done as
      follows:

      *packUnorm2x16*: *round*(*clamp*(_c_, 0, +1) * 65535.0) +
      *packSnorm2x16:* *round*(*clamp*(_c_, -1, +1) * 32767.0) +
      *packUnorm4x8*: *round*(*clamp*(_c_, 0, +1) * 255.0) +
      *packSnorm4x8*: *round*(*clamp*(_c_, -1, +1) * 127.0)

      The first component of the vector will be written to the least
      significant bits of the output; the last component will be written to
      the most significant bits.
| {highp} vec2 *unpackUnorm2x16*(highp uint _p_) +
  {highp} vec2 *unpackSnorm2x16*(highp uint _p_) +
  {mediump} vec4 *unpackUnorm4x8*(highp uint _p_) +
  {mediump} vec4 *unpackSnorm4x8*(highp uint _p_)
    | First, unpacks a single 32-bit unsigned integer _p_ into a pair of
      16-bit unsigned integers, a pair of 16-bit signed integers, four 8-bit
      unsigned integers, or four 8-bit signed integers, respectively.
      Then, each component is converted to a normalized floating-point value
      to generate the returned two- or four-component vector.

      The conversion for unpacked fixed-point value _f_ to floating-point is
      done as follows:

      *unpackUnorm2x16*: _f_ / 65535.0 +
      *unpackSnorm2x16*: *clamp*(_f_ / 32767.0, -1, +1) +
      *unpackUnorm4x8*: _f_ / 255.0 +
      *unpackSnorm4x8*: *clamp*(_f_ / 127.0, -1, +1)

      The first component of the returned vector will be extracted from the
      least significant bits of the input; the last component will be
      extracted from the most significant bits.
| {highp} uint *packHalf2x16*({mediump} vec2 _v_)
    | Returns an unsigned integer obtained by converting the components of a
      two-component floating-point vector to the 16-bit floating-point
      representation of the <<references, API>>, and
      then packing these two 16-bit integers into a 32-bit unsigned integer.

      The first vector component specifies the 16 least-significant bits of
      the result; the second component specifies the 16 most-significant
      bits.
| {mediump} vec2 *unpackHalf2x16*({highp} uint _v_)
    | Returns a two-component floating-point vector with components obtained
      by unpacking a 32-bit unsigned integer into a pair of 16-bit values,
      interpreting those values as 16-bit floating-point numbers according
      to the <<references, API>>, and converting them to
      32-bit floating-point values.

      The first component of the vector is obtained from the 16
      least-significant bits of _v_; the second component is obtained from
      the 16 most-significant bits of _v_.
ifdef::GLSL[]
| double *packDouble2x32*(uvec2 _v_) +
    | Returns a double-precision value obtained by packing the components of
      _v_ into a 64-bit value.
      If an IEEE 754 Inf or NaN is created, it will not signal, and the
      resulting floating-point value is unspecified.
      Otherwise, the bit-level representation of _v_ is preserved.
      The first vector component specifies the 32 least significant bits;
      the second component specifies the 32 most significant bits.
| uvec2 *unpackDouble2x32*(double _v_)
    | Returns a two-component unsigned integer vector representation of _v_.
      The bit-level representation of _v_ is preserved.
      The first component of the vector contains the 32 least significant
      bits of the double; the second component consists of the 32 most
      significant bits.
endif::GLSL[]
|====


[[geometric-functions]]
== Geometric Functions

These operate on vectors as vectors, not component-wise.

[options="header"]
|====
| Syntax | Description
ifdef::GLSL[]
| float *length*(genFType _x_) +
  double *length*(genDType _x_)
endif::GLSL[]
ifdef::ESSL[]
| float *length*(genFType _x_)
endif::ESSL[]
   a| Returns the length of vector _x_, i.e.,
      [eq]#sqrt( x~0~^2^ + x~1~^2^ + ... )#.
ifdef::GLSL[]
| float *distance*(genFType _p0_, genFType _p1_) +
  double *distance*(genDType _p0_, genDType _p1_)
endif::GLSL[]
ifdef::ESSL[]
| float *distance*(genFType _p0_, genFType _p1_)
endif::ESSL[]
    | Returns the distance between _p0_ and _p1_, i.e.,
      *length*(_p0_ - _p1_)
ifdef::GLSL[]
| float *dot*(genFType _x_, genFType _y_) +
  double *dot*(genDType _x_, genDType _y_)
endif::GLSL[]
ifdef::ESSL[]
| float *dot*(genFType _x_, genFType _y_)
endif::ESSL[]
    | Returns the dot product of _x_ and _y_, i.e.,
      [eq]#x~0~ {cdot} y~0~ + x~1~ {cdot} y~1~ + ...#
ifdef::GLSL[]
| vec3 *cross*(vec3 _x_, vec3 _y_) +
  dvec3 *cross*(dvec3 _x_, dvec3 _y_)
endif::GLSL[]
ifdef::ESSL[]
| vec3 *cross*(vec3 _x_, vec3 _y_)
endif::ESSL[]
   a| Returns the cross product of _x_ and _y_, i.e.,
      [eq]#(x~1~ {cdot} y~2~ - y~1~ {cdot} x~2~,
            x~2~ {cdot} y~0~ - y~2~ {cdot} x~0~,
            x~0~ {cdot} y~1~ - y~0~ {cdot} x~1~)#.
ifdef::GLSL[]
| genFType *normalize*(genFType _x_) +
  genDType *normalize*(genDType _x_)
endif::GLSL[]
ifdef::ESSL[]
| genFType *normalize*(genFType _x_)
endif::ESSL[]
    | Returns a vector in the same direction as _x_ but with a length of 1,
      i.e. _x_ / *length*(x).
ifdef::GLSL[]
| compatibility profile only +
  vec4 *ftransform*()
   a| Available only when using the compatibility profile.
      For core {apiname}, use *invariant*. +
      For vertex shaders only.
      This function will ensure that the incoming vertex value will be
      transformed in a way that produces exactly the same result as would be
      produced by {apiname}'s fixed functionality transform.
      It is intended to be used to compute _gl_Position_, e.g.
--
{empty}:: _gl_Position_ = *ftransform*()

This function should be used, for example, when an application is rendering
the same geometry in separate passes, and one pass uses the fixed
functionality path to render and another pass uses programmable shaders.
--
endif::GLSL[]
| genFType *faceforward*(genFType _N_, genFType _I_, genFType _Nref_) +
ifdef::GLSL[]
  genDType *faceforward*(genDType _N_, genDType _I_, genDType _Nref_)
endif::GLSL[]
    | If *dot*(_Nref_, _I_) < 0 return _N_, otherwise return -_N_.
ifdef::GLSL[]
| genFType *reflect*(genFType _I_, genFType _N_) +
  genDType *reflect*(genDType _I_, genDType _N_)
endif::GLSL[]
ifdef::ESSL[]
| genFType *reflect*(genFType _I_, genFType _N_)
endif::ESSL[]
    | For the incident vector _I_ and surface orientation _N_, returns the
      reflection direction: [eq]#I - 2 {cdot} *dot*(N, I) {cdot} N#.
      _N_ must already be normalized in order to achieve the desired result.
| genFType *refract*(genFType _I_, genFType _N_, float _eta_) +
ifdef::GLSL[]
  genDType *refract*(genDType _I_, genDType _N_, double _eta_)
endif::GLSL[]
   a| For the incident vector _I_ and surface normal _N_, and the ratio of
      indices of refraction _eta_, return the refraction vector.
      The result is computed by the <<refraction-equation,refraction
      equation>> shown below.

      The input parameters for the incident vector _I_ and the surface
      normal _N_ must already be normalized to get the desired results.
|====


[[refraction-equation]]
=== Refraction Equation

ifdef::editing-notes[]
[NOTE]
.editing-note
====
(Jon) Moved to new section from *refract* table entry above because
asciidoctor-mathematical doesn't support math blocks in table cells yet.
====
endif::editing-notes[]

[latexmath]
++++
k = 1.0 - eta * eta * (1.0 - \textbf{dot}(N,I) \cdot \textbf{dot}(N,I))
++++

[latexmath]
++++
\begin{aligned}
result &=
  \begin{cases}
    genFType(0.0), & k < 0.0 \\
    eta * I - (eta * \textbf{dot}(N,I) + \sqrt { k }) * N, & \textbf{otherwise}
  \end{cases}
\end{aligned}
++++


[[matrix-functions]]
== Matrix Functions

For each of the following built-in matrix functions, there is both a
single-precision floating-point version, where all arguments and return
values are single precision, and a double-precision floating-point version,
where all arguments and return values are double precision.
Only the single-precision floating-point version is shown.

[options="header"]
|====
| Syntax | Description
| mat *matrixCompMult*(mat _x_, mat _y_)
    | Multiply matrix _x_ by matrix _y_ component-wise, i.e., result[i][j]
      is the scalar product of _x_[i][j] and _y_[i][j]. +

      Note: to get linear algebraic matrix multiplication, use the multiply
      operator (***).
| mat2 *outerProduct*(vec2 _c_, vec2 _r_) +
  mat3 *outerProduct*(vec3 _c_, vec3 _r_) +
  mat4 *outerProduct*(vec4 _c_, vec4 _r_) +
  mat2x3 *outerProduct*(vec3 _c_, vec2 _r_) +
  mat3x2 *outerProduct*(vec2 _c_, vec3 _r_) +
  mat2x4 *outerProduct*(vec4 _c_, vec2 _r_) +
  mat4x2 *outerProduct*(vec2 _c_, vec4 _r_) +
  mat3x4 *outerProduct*(vec4 _c_, vec3 _r_) +
  mat4x3 *outerProduct*(vec3 _c_, vec4 _r_)
    | Treats the first parameter _c_ as a column vector (matrix with one
      column) and the second parameter _r_ as a row vector (matrix with one
      row) and does a linear algebraic matrix multiply _c_ * _r_, yielding a
      matrix whose number of rows is the number of components in _c_ and
      whose number of columns is the number of components in _r_.
| mat2 *transpose*(mat2 _m_) +
  mat3 *transpose*(mat3 _m_) +
  mat4 *transpose*(mat4 _m_) +
  mat2x3 *transpose*(mat3x2 _m_) +
  mat3x2 *transpose*(mat2x3 _m_) +
  mat2x4 *transpose*(mat4x2 _m_) +
  mat4x2 *transpose*(mat2x4 _m_) +
  mat3x4 *transpose*(mat4x3 _m_) +
  mat4x3 *transpose*(mat3x4 _m_)
    | Returns a matrix that is the transpose of _m_.
      The input matrix _m_ is not modified.
| float *determinant*(mat2 _m_) +
  float *determinant*(mat3 _m_) +
  float *determinant*(mat4 _m_)
    | Returns the determinant of _m_.
| mat2 *inverse*(mat2 _m_) +
  mat3 *inverse*(mat3 _m_) +
  mat4 *inverse*(mat4 _m_)
    | Returns a matrix that is the inverse of _m_.
      The input matrix _m_ is not modified.
      The values in the returned matrix are undefined if _m_ is singular or
      poorly-conditioned (nearly singular).
|====


[[vector-relational-functions]]
== Vector Relational Functions

Relational and equality operators (*<*, *\<=*, *>*, *>=*, *==*, *!=*) are
defined to operate on scalars and produce scalar Boolean results.
For vector results, use the following built-in functions.
Below, the following placeholders are used for the listed specific types:

[options="header"]
|====
| Placeholder | Specific Types Allowed
| bvec        | bvec2, bvec3, bvec4
| ivec        | ivec2, ivec3, ivec4
| uvec        | uvec2, uvec3, uvec4
ifdef::GLSL[]
| vec         | vec2, vec3, vec4, dvec2, dvec3, dvec4
endif::GLSL[]
ifdef::ESSL[]
| vec         | vec2, vec3, vec4
endif::ESSL[]
|====

In all cases, the sizes of all the input and return vectors for any
particular call must match.

[options="header"]
|====
| Syntax | Description
| bvec *lessThan*(vec x, vec y) +
  bvec *lessThan*(ivec x, ivec y) +
  bvec *lessThan*(uvec x, uvec y)
    | Returns the component-wise compare of [eq]#x < y#.
| bvec *lessThanEqual*(vec x, vec y) +
  bvec *lessThanEqual*(ivec x, ivec y) +
  bvec *lessThanEqual*(uvec x, uvec y)
    | Returns the component-wise compare of [eq]#x {leq} y#.
| bvec *greaterThan*(vec x, vec y) +
  bvec *greaterThan*(ivec x, ivec y) +
  bvec *greaterThan*(uvec x, uvec y)
    | Returns the component-wise compare of [eq]#x > y#.
| bvec *greaterThanEqual*(vec x, vec y) +
  bvec *greaterThanEqual*(ivec x, ivec y) +
  bvec *greaterThanEqual*(uvec x, uvec y)
    | Returns the component-wise compare of [eq]#x {geq} y#.
| bvec *equal*(vec x, vec y) +
  bvec *equal*(ivec x, ivec y) +
  bvec *equal*(uvec x, uvec y) +
  bvec *equal*(bvec x, bvec y)
    | Returns the component-wise compare of [eq]#x == y#.
| bvec *notEqual*(vec x, vec y) +
  bvec *notEqual*(ivec x, ivec y) +
  bvec *notEqual*(uvec x, uvec y) +
  bvec *notEqual*(bvec x, bvec y)
    | Returns the component-wise compare of [eq]#x {neq} y#.
| bool *any*(bvec x)
    | Returns *true* if any component of _x_ is *true*.
| bool *all*(bvec x)
    | Returns *true* only if all components of _x_ are *true*.
| bvec *not*(bvec x)
    | Returns the component-wise logical complement of _x_.
|====


[[integer-functions]]
== Integer Functions

These all operate component-wise.
The description is per component.
The notation [_a_, _b_] means the set of bits from bit-number _a_ through
bit-number _b_, inclusive.
The lowest-order bit is bit 0.
"`Bit number`" will always refer to counting up from the lowest-order bit as
bit 0.

[options="header"]
|====
| Syntax | Description
| genUType *uaddCarry*(highp genUType _x_, highp genUType _y_, out lowp genUType _carry_)
    | Adds 32-bit unsigned integers _x_ and _y_, returning the sum modulo
      2^32^.
      The value _carry_ is set to zero if the sum was less than 2^32^, or
      one otherwise.
| genUType *usubBorrow*(highp genUType _x_, highp genUType _y_, out lowp genUType _borrow_)
    | Subtracts the 32-bit unsigned integer _y_ from _x_, returning the
      difference if non-negative, or 2^32^ plus the difference otherwise.
      The value _borrow_ is set to zero if [eq]#x {geq} y#, or one
      otherwise.
| void *umulExtended*(highp genUType _x_, highp genUType _y_, out highp genUType _msb_, out highp genUType _lsb_) +
  void *imulExtended*(highp genIType _x_, highp genIType _y_, out highp genIType _msb_, out highp genIType _lsb_)
    | Multiplies 32-bit unsigned or signed integers _x_ and _y_, producing a
      64-bit result.
      The 32 least-significant bits are returned in _lsb_.
      The 32 most-significant bits are returned in _msb_.
| genIType *bitfieldExtract*(genIType _value_, int _offset_, int _bits_) +
  genUType *bitfieldExtract*(genUType _value_, int _offset_, int _bits_)
    | Extracts bits [eq]#[offset, offset + bits - 1]# from _value_,
      returning them in the least significant bits of the result. +

      For unsigned data types, the most significant bits of the result will
      be set to zero.
      For signed data types, the most significant bits will be set to the
      value of bit [eq]#offset + bits - 1#. +

      If _bits_ is zero, the result will be zero.
      The result will be undefined if _offset_ or _bits_ is negative, or if
      the sum of _offset_ and _bits_ is greater than the number of bits used
      to store the operand.
      Note that for vector versions of *bitfieldExtract*(), a single pair of
      _offset_ and _bits_ values is shared for all components.
| genIType *bitfieldInsert*(genIType _base_, genIType _insert_, int _offset_, int _bits_) +
  genUType *bitfieldInsert*(genUType _base_, genUType _insert_, int _offset_, int _bits_)
    | Inserts the _bits_ least significant bits of _insert_ into _base_.

      The result will have bits [eq]#[offset, offset + bits - 1]# taken from
      bits [eq]#[0, bits - 1]# of _insert_, and all other bits taken
      directly from the corresponding bits of _base_.
      If _bits_ is zero, the result will simply be _base_.
      The result will be undefined if _offset_ or _bits_ is negative, or if
      the sum of _offset_ and _bits_ is greater than the number of bits used
      to store the operand. +
      Note that for vector versions of *bitfieldInsert*(), a single pair of
      _offset_ and _bits_ values is shared for all components.
| genIType *bitfieldReverse*(highp genIType _value_) +
  genUType *bitfieldReverse*(highp genUType _value_)
    | Reverses the bits of _value_.
      The bit numbered _n_ of the result will be taken from bit [eq]#(bits -
      1) - n# of _value_, where _bits_ is the total number of bits used to
      represent _value_.
| {lowp} genIType *bitCount*(genIType _value_) +
  {lowp} genIType *bitCount*(genUType _value_)
    | Returns the number of one bits in the binary representation of
      _value_.
| {lowp} genIType *findLSB*(genIType _value_) +
  {lowp} genIType *findLSB*(genUType _value_)
    | Returns the bit number of the least significant one bit in the binary
      representation of _value_.
      If _value_ is zero, -1 will be returned.
| {lowp} genIType *findMSB*(highp genIType _value_) +
  {lowp} genIType *findMSB*(highp genUType _value_)
    | Returns the bit number of the most significant bit in the binary
      representation of _value_.

      For positive integers, the result will be the bit number of the most
      significant one bit.
      For negative integers, the result will be the bit number of the most
      significant zero bit.
      For a _value_ of zero or negative one, -1 will be returned.
|====


[[texture-functions]]
== Texture Functions

Texture lookup functions are available in all shading stages.
However, level-of-detail is implicitly computed only for fragment shaders.
Other shaders operate as though the base level-of-detail were computed as
zero.
The functions in the table below provide access to textures through
texture-combined samplers, as set up through the API.
Texture properties such as size, pixel format, number of dimensions,
filtering method, number of mipmap levels, depth comparison, and so on are
also defined by API calls.
Such properties are taken into account as the texture is accessed via the
built-in functions defined below.

Texture data can be stored by the GL as single-precision floating-point,
normalized integer, unsigned integer or signed integer data.
This is determined by the type of the internal format of the texture.

Texture lookup functions are provided that can return their result as
floating-point, unsigned integer or signed integer, depending on the sampler
type passed to the lookup function.
Care must be taken to use the right sampler type for texture access.
The following table lists the supported combinations of sampler types and
texture internal formats.
Blank entries are unsupported.
Doing a texture lookup will return undefined values for unsupported
combinations.

For depth/stencil textures, the internal texture format is determined by the
component being accessed as set through the API.
When the depth/stencil texture mode is set to DEPTH_COMPONENT, the internal
format of the depth component should be used.
When the depth/stencil texture mode is set to STENCIL_INDEX, the internal format
of the stencil component should be used.

[options="header"]
|====
| Internal Texture Format | Floating-Point Sampler Types | Signed Integer Sampler Types | Unsigned Integer Sampler Types
| Floating-point          | Supported                    |                              |
| Normalized Integer      | Supported                    |                              |
| Signed Integer          |                              | Supported                    |
| Unsigned Integer        |                              |                              | Supported
|====

If an integer sampler type is used, the result of a texture lookup is an
*ivec4*.
If an unsigned integer sampler type is used, the result of a texture lookup
is a *uvec4*.
If a floating-point sampler type is used, the result of a texture lookup is
a *vec4*.

In the prototypes below, the `g` in the return type `gvec4` is used
as a placeholder for either nothing, `i`, or `u` making a return type of
*vec4*, *ivec4*, or *uvec4*.
In these cases, the sampler argument type also starts with `g`,
indicating the same substitution done on the return type; it is either a
ifdef::GLSL[single-precision]
floating-point, signed integer, or unsigned integer sampler, matching the
basic type of the return type, as described above.

For shadow forms (the sampler parameter is a shadow-type), a depth
comparison lookup on the depth texture bound to _sampler_ is done as
described in section
ifdef::GLSL[8.23]
ifdef::ESSL[8.20]
"`Texture Comparison Modes`" of the
<<references,{apispec}>>.
See the table below for which component specifies _D~ref~_.
The texture bound to _sampler_ must be a depth texture, or results are
undefined.
If a non-shadow texture call is made to a sampler that represents a depth
texture with depth comparisons turned on, then results are undefined.
If a shadow texture call is made to a sampler that represents a depth
texture with depth comparisons turned off, then results are undefined.
If a shadow texture call is made to a sampler that does not represent a
depth texture, then results are undefined.

In all functions below, the _bias_ parameter is optional for fragment
shaders.
The _bias_ parameter is not accepted in any other shader stage.
For a fragment shader, if _bias_ is present, it is added to the implicit
level-of-detail prior to performing the texture access operation.
No _bias_ or _lod_ parameters for
ifdef::GLSL[rectangle textures,]
multisample textures, or texture buffers
are supported because mipmaps are not allowed for these types of textures.

The implicit level-of-detail is selected as follows: For a texture that is
not mipmapped, the texture is used directly.
If it is mipmapped and running in a fragment shader, the level-of-detail
computed by the implementation is used to do the texture lookup.
If it is mipmapped and running in a non-fragment shader, then the base
texture is used.

Some texture functions (non-"`*Lod*`" and non-"`*Grad*`" versions) may
require implicit derivatives.
Implicit derivatives are undefined within non-uniform control flow and for
non-fragment shader texture fetches.

For *Cube* forms, the direction of _P_ is used to select which face to do a
2-dimensional texture lookup in, as described in section 8.13 "`Cube Map
Texture Selection`" of the <<references,{apispec}>>.

For *Array* forms, the array layer used will be

latexmath:[\max(0,\min(d-1,\left\lfloor layer + 0.5\right\rfloor))]

where _d_ is the depth of the texture array and _layer_ comes from the
component indicated in the tables below.


[[texture-query-functions]]
=== Texture Query Functions

The *textureSize* functions query the dimensions of a specific texture level
for a texture-combined sampler.

ifdef::GLSL[]
The *textureQueryLod* functions are available only in a fragment shader.
They take the components of _P_ and compute the level-of-detail information
that the texture pipe would use to access that texture through a normal
texture lookup.
The level-of-detail latexmath:[\lambda^{'}] (equation 3.18 of the
<<references,{apispec}>>) is obtained after any level-of-detail bias, but
prior to clamping to [TEXTURE_MIN_LOD, TEXTURE_MAX_LOD].
The mipmap array(s) that would be accessed are also computed.
If a single level-of-detail would be accessed, the level-of-detail number
relative to the base level is returned.
If multiple levels-of-detail would be accessed, a floating-point number
between the two levels is returned, with the fractional part equal to the
fractional part of the computed and clamped level-of-detail.

The algorithm used is given by the following pseudo-code:

[source,glsl]
----
float ComputeAccessedLod(float computedLod)
{
    // Clamp the computed LOD according to the texture LOD clamps.
    if (computedLod < TEXTURE_MIN_LOD) computedLod = TEXTURE_MIN_LOD;
    if (computedLod > TEXTURE_MAX_LOD) computedLod = TEXTURE_MAX_LOD;

    // Clamp the computed LOD to the range of accessible levels.
    if (computedLod < 0.0)
        computedLod = 0.0;
    if (computedLod > (float) maxAccessibleLevel)
        computedLod = (float) maxAccessibleLevel;

    // Return a value according to the min filter.
    if (TEXTURE_MIN_FILTER is LINEAR or NEAREST) {
        return 0.0;
    } else if (TEXTURE_MIN_FILTER is NEAREST_MIPMAP_NEAREST
               or LINEAR_MIPMAP_NEAREST) {
        return ceil(computedLod + 0.5) - 1.0;
    } else {
        return computedLod;
    }
}
----

The value _maxAccessibleLevel_ is the level number of the smallest
accessible level of the mipmap array (the value _q_ in section 8.14.3
"`Mipmapping`" of the <<references,{apispec}>>) minus the base level.
endif::GLSL[]

[options="header"]
|====
| Syntax | Description
|
ifdef::GLSL[]
  {highp} int *textureSize*(gsampler1D _sampler_, int _lod_) +
endif::GLSL[]
  {highp} ivec2 *textureSize*(gsampler2D _sampler_, int _lod_) +
  {highp} ivec3 *textureSize*(gsampler3D _sampler_, int _lod_) +
  {highp} ivec2 *textureSize*(gsamplerCube _sampler_, int _lod_) +
ifdef::GLSL[]
  {highp} int *textureSize*(sampler1DShadow _sampler_, int _lod_) +
endif::GLSL[]
  {highp} ivec2 *textureSize*(sampler2DShadow _sampler_, int _lod_) +
  {highp} ivec2 *textureSize*(samplerCubeShadow _sampler_, int _lod_)
  {highp} ivec3 *textureSize*(gsamplerCubeArray _sampler_, int _lod_) +
  {highp} ivec3 *textureSize*(samplerCubeArrayShadow _sampler_, int _lod_) +
ifdef::GLSL[]
  {highp} ivec2 *textureSize*(gsampler2DRect _sampler_) +
  {highp} ivec2 *textureSize*(sampler2DRectShadow _sampler_) +
  {highp} ivec2 *textureSize*(gsampler1DArray _sampler_, int _lod_) +
  {highp} ivec2 *textureSize*(sampler1DArrayShadow _sampler_, int _lod_) +
endif::GLSL[]
  {highp} ivec3 *textureSize*(gsampler2DArray _sampler_, int _lod_) +
  {highp} ivec3 *textureSize*(sampler2DArrayShadow _sampler_, int _lod_) +
  {highp} int *textureSize*(gsamplerBuffer _sampler_) +
  {highp} ivec2 *textureSize*(gsampler2DMS _sampler_) +
  {highp} ivec3 *textureSize*(gsampler2DMSArray _sampler_)
    | Returns the dimensions of level _lod_ (if present) for the texture
      bound to _sampler_, as described in section
      11.1.3.4 "`Texture Queries`" of the <<references,{apispec}>>. +
      The components in the return value are filled in, in order, with the
      width, height, and depth of the texture.

      For the array forms, the last component of the return value is the
      number of layers in the texture array, or the number of cubes in the
      texture cube map array.
ifdef::GLSL[]
| vec2 *textureQueryLod*(gsampler1D _sampler_, float _P_) +
  vec2 *textureQueryLod*(gsampler2D _sampler_, vec2 _P_) +
  vec2 *textureQueryLod*(gsampler3D _sampler_, vec3 _P_) +
  vec2 *textureQueryLod*(gsamplerCube _sampler_, vec3 _P_) +
  vec2 *textureQueryLod*(gsampler1DArray _sampler_, float _P_) +
  vec2 *textureQueryLod*(gsampler2DArray _sampler_, vec2 _P_) +
  vec2 *textureQueryLod*(gsamplerCubeArray _sampler_, vec3 _P_) +
  vec2 *textureQueryLod*(sampler1DShadow _sampler_, float _P_) +
  vec2 *textureQueryLod*(sampler2DShadow _sampler_, vec2 _P_) +
  vec2 *textureQueryLod*(samplerCubeShadow _sampler_, vec3 _P_) +
  vec2 *textureQueryLod*(sampler1DArrayShadow _sampler_, float _P_) +
  vec2 *textureQueryLod*(sampler2DArrayShadow _sampler_, vec2 _P_) +
  vec2 *textureQueryLod*(samplerCubeArrayShadow _sampler_, vec3 _P_)
    | Returns the mipmap array(s) that would be accessed in the _x_
      component of the return value.

      Returns the computed level-of-detail relative to the base level in the
      _y_ component of the return value.

      If called on an incomplete texture, the results are undefined.
| int *textureQueryLevels*(gsampler1D _sampler_) +
  int *textureQueryLevels*(gsampler2D _sampler_) +
  int *textureQueryLevels*(gsampler3D _sampler_) +
  int *textureQueryLevels*(gsamplerCube _sampler_) +
  int *textureQueryLevels*(gsampler1DArray _sampler_) +
  int *textureQueryLevels*(gsampler2DArray _sampler_) +
  int *textureQueryLevels*(gsamplerCubeArray _sampler_) +
  int *textureQueryLevels*(sampler1DShadow _sampler_) +
  int *textureQueryLevels*(sampler2DShadow _sampler_) +
  int *textureQueryLevels*(samplerCubeShadow _sampler_) +
  int *textureQueryLevels*(sampler1DArrayShadow _sampler_) +
  int *textureQueryLevels*(sampler2DArrayShadow _sampler_) +
  int *textureQueryLevels*(samplerCubeArrayShadow _sampler_)
    | Returns the number of mipmap levels accessible in the texture
      associated with _sampler_, as defined in the <<references,{apispec}.>>

      The value zero will be returned if no texture or an incomplete texture
      is associated with _sampler_.

      Available in all shader stages.
| int *textureSamples*(gsampler2DMS _sampler_) +
  int *textureSamples*(gsampler2DMSArray _sampler_)
    | Returns the number of samples of the texture bound to _sampler_.
endif::GLSL[]
|====


[[texel-lookup-functions]]
=== Texel Lookup Functions

[options="header"]
|====
| Syntax | Description
|
ifdef::GLSL[]
  gvec4 *texture*(gsampler1D _sampler_, float _P_ [, float _bias_] ) +
endif::GLSL[]
  gvec4 *texture*(gsampler2D _sampler_, vec2 _P_ [, float _bias_] ) +
  gvec4 *texture*(gsampler3D _sampler_, vec3 _P_ [, float _bias_] ) +
  gvec4 *texture*(gsamplerCube _sampler_, vec3 _P_[, float _bias_] ) +
ifdef::GLSL[]
  float *texture*(sampler1DShadow _sampler_, vec3 _P_ [, float _bias_]) +
endif::GLSL[]
  float *texture*(sampler2DShadow _sampler_, vec3 _P_ [, float _bias_]) +
  float *texture*(samplerCubeShadow _sampler_, vec4 _P_ [, float _bias_] ) +
  gvec4 *texture*(gsampler2DArray _sampler_, vec3 _P_ [, float _bias_] ) +
  gvec4 *texture*(gsamplerCubeArray _sampler_, vec4 _P_ [, float _bias_] ) +
ifdef::GLSL[]
  gvec4 *texture*(gsampler1DArray _sampler_, vec2 _P_ [, float _bias_] ) +
  float *texture*(sampler1DArrayShadow _sampler_, vec3 _P_ [, float _bias_] ) +
endif::GLSL[]
  float *texture*(sampler2DArrayShadow _sampler_, vec4 _P_) +
ifdef::GLSL[]
  gvec4 *texture*(gsampler2DRect _sampler_, vec2 _P_) +
  float *texture*(sampler2DRectShadow _sampler_, vec3 _P_) +
endif::GLSL[]
  float *texture*(samplerCubeArrayShadow _sampler_, vec4 _P_, float _compare_)
    | Use the texture coordinate _P_ to do a texture lookup in the texture
      currently bound to _sampler_.

      For shadow forms: When _compare_ is present, it is used as _D~ref~_
      and the array layer comes from the last component of _P_.
      When _compare_ is not present, the last component of _P_ is used as
      _D~ref~_ and the array layer comes from the second to last component
      of _P_.
ifdef::GLSL[]
      (The second component of _P_ is unused for *1D* shadow lookups.)
endif::GLSL[]

      For non-shadow forms: the array layer comes from the last component of
      _P_.
|
ifdef::GLSL[]
  gvec4 *textureProj*(gsampler1D _sampler_, vec2 _P_ [, float _bias_] ) +
  gvec4 *textureProj*(gsampler1D _sampler_, vec4 _P_ [, float _bias_] ) +
endif::GLSL[]
  gvec4 *textureProj*(gsampler2D _sampler_, vec3 _P_ [, float _bias_] ) +
  gvec4 *textureProj*(gsampler2D _sampler_, vec4 _P_ [, float _bias_] ) +
  gvec4 *textureProj*(gsampler3D _sampler_, vec4 _P_ [, float _bias_] ) +
ifdef::GLSL[]
  float *textureProj*(sampler1DShadow _sampler_, vec4 _P_ [, float _bias_] ) +
endif::GLSL[]
  float *textureProj*(sampler2DShadow _sampler_, vec4 _P_ [, float _bias_] ) +
ifdef::GLSL[]
  gvec4 *textureProj*(gsampler2DRect _sampler_, vec3 _P_) +
  gvec4 *textureProj*(gsampler2DRect _sampler_, vec4 _P_) +
  float *textureProj*(sampler2DRectShadow _sampler_, vec4 _P_) +
endif::GLSL[]
    | Do a texture lookup with projection.
      The texture coordinates consumed from _P_, not including the last
      component of _P_, are divided by the last component of _P_ to
      form projected coordinates _P'_.
      The resulting third component of _P_ in the shadow forms is used as
      _D~ref~_.
      The third component of _P_ is ignored when _sampler_ has type
      *gsampler2D* and _P_ has type *vec4*.
      After these values are computed, texture lookup proceeds as in
      *texture*.
|
ifdef::GLSL[]
  gvec4 *textureLod*(gsampler1D _sampler_, float _P_, float _lod_) +
endif::GLSL[]
  gvec4 *textureLod*(gsampler2D _sampler_, vec2 _P_, float _lod_) +
  gvec4 *textureLod*(gsampler3D _sampler_, vec3 _P_, float _lod_) +
  gvec4 *textureLod*(gsamplerCube _sampler_, vec3 _P_, float _lod_) +
  float *textureLod*(sampler2DShadow _sampler_, vec3 _P_, float _lod_) +
ifdef::GLSL[]
  float *textureLod*(sampler1DShadow _sampler_, vec3 _P_, float _lod_) +
  gvec4 *textureLod*(gsampler1DArray _sampler_, vec2 _P_, float _lod_) +
  float *textureLod*(sampler1DArrayShadow _sampler_, vec3 _P_, float _lod_) +
endif::GLSL[]
  gvec4 *textureLod*(gsampler2DArray _sampler_, vec3 _P_, float _lod_) +
  gvec4 *textureLod*(gsamplerCubeArray _sampler_, vec4 _P_, float _lod_)
   a| Do a texture lookup as in *texture* but with explicit level-of-detail;
      _lod_ specifies [eq]#{lambda}~base~]# and sets the partial derivatives
      as follows: +
      (See section 8.14 "`Texture Minification`" and equations 8.4-8.6 of
      the <<references,{apispec}>>.) +
      +
      [eq]#{partial}u / {partial}x =
           {partial}v / {partial}x =
           {partial}w / {partial}x = 0#
      +
      [eq]#{partial}u / {partial}y =
           {partial}v / {partial}y =
           {partial}w / {partial}y = 0#
|
ifdef::GLSL[]
  gvec4 *textureOffset*(gsampler1D _sampler_, float _P_, int _offset_ [, float _bias_] ) +
endif::GLSL[]
  gvec4 *textureOffset*(gsampler2D _sampler_, vec2 _P_, ivec2 _offset_ [, float _bias_] ) +
  gvec4 *textureOffset*(gsampler3D _sampler_, vec3 _P_, ivec3 _offset_ [, float _bias_] ) +
  float *textureOffset*(sampler2DShadow _sampler_, vec3 _P_, ivec2 _offset_ [, float _bias_] ) +
ifdef::GLSL[]
  gvec4 *textureOffset*(gsampler2DRect _sampler_, vec2 _P_, ivec2 _offset_) +
  float *textureOffset*(sampler2DRectShadow _sampler_, vec3 _P_, ivec2 _offset_) +
  float *textureOffset*(sampler1DShadow _sampler_, vec3 _P_, int _offset_ [, float _bias_] ) +
  gvec4 *textureOffset*(gsampler1DArray _sampler_, vec2 _P_, int _offset_ [, float _bias_] ) +
endif::GLSL[]
  gvec4 *textureOffset*(gsampler2DArray _sampler_, vec3 _P_, ivec2 _offset_ [, float _bias_] ) +
ifdef::GLSL[]
  float *textureOffset*(sampler1DArrayShadow _sampler_, vec3 _P_, int _offset_ [, float _bias_] ) +
  float *textureOffset*(sampler2DArrayShadow _sampler_, vec4 _P_, ivec2 _offset_)
endif::GLSL[]
    | Do a texture lookup as in *texture* but with _offset_ added to the
      [eq]#(u,v,w)# texel coordinates before looking up each texel.
      The offset value must be a constant expression.
      A limited range of offset values are supported; the minimum and
      maximum offset values are implementation-dependent and given by
      _gl_MinProgramTexelOffset_ and _gl_MaxProgramTexelOffset_,
      respectively.

      Note that _offset_ does not apply to the layer coordinate for texture
      arrays.
      This is explained in detail in section 8.14.2 "`Coordinate Wrapping
      and Texel Selection`" of the <<references,{apispec}>>, where _offset_
      is [eq]#({delta}~u~, {delta}~v~, {delta}~w~)#. +
      Note that texel offsets are also not supported for cube maps.
|
ifdef::GLSL[]
  gvec4 *texelFetch*(gsampler1D _sampler_, int _P_, int _lod_) +
endif::GLSL[]
  gvec4 *texelFetch*(gsampler2D _sampler_, ivec2 _P_, int _lod_) +
  gvec4 *texelFetch*(gsampler3D _sampler_, ivec3 _P_, int _lod_)
ifdef::GLSL[]
  gvec4 *texelFetch*(gsampler2DRect _sampler_, ivec2 _P_) +
  gvec4 *texelFetch*(gsampler1DArray _sampler_, ivec2 _P_, int _lod_) +
endif::GLSL[]
  gvec4 *texelFetch*(gsampler2DArray _sampler_, ivec3 _P_, int _lod_) +
  gvec4 *texelFetch*(gsamplerBuffer _sampler_, int _P_) +
  gvec4 *texelFetch*(gsampler2DMS _sampler_, ivec2 _P_, int _sample_) +
  gvec4 *texelFetch*(gsampler2DMSArray _sampler_, ivec3 _P_, int _sample_)
    | Use integer texture coordinate _P_ to lookup a single texel from
      _sampler_.
      The array layer comes from the last component of _P_ for the array
      forms.
      The level-of-detail _lod_ (if present) is as described in sections
      11.1.3.2 "`Texel Fetches`" and 8.14.1 "`Scale Factor and Level of
      Detail`" of the <<references,{apispec}>>.
|
ifdef::GLSL[]
  gvec4 *texelFetchOffset*(gsampler1D _sampler_, int _P_, int _lod_, int _offset_) +
endif::GLSL[]
  gvec4 *texelFetchOffset*(gsampler2D _sampler_, ivec2 _P_, int _lod_, ivec2 _offset_) +
  gvec4 *texelFetchOffset*(gsampler3D _sampler_, ivec3 _P_, int _lod_, ivec3 _offset_) +
ifdef::GLSL[]
  gvec4 *texelFetchOffset*(gsampler2DRect _sampler_, ivec2 _P_, ivec2 _offset_) +
  gvec4 *texelFetchOffset*(gsampler1DArray _sampler_, ivec2 _P_, int _lod_, int _offset_) +
endif::GLSL[]
  gvec4 *texelFetchOffset*(gsampler2DArray _sampler_, ivec3 _P_, int _lod_, ivec2 _offset_)
    | Fetch a single texel as in *texelFetch*, offset by _offset_ as
      described in *textureOffset*.
|
ifdef::GLSL[]
  gvec4 *textureProjOffset*(gsampler1D _sampler_, vec2 _P_, int _offset_ [, float _bias_] ) +
  gvec4 *textureProjOffset*(gsampler1D _sampler_, vec4 _P_, int _offset_ [, float _bias_] ) +
endif::GLSL[]
  gvec4 *textureProjOffset*(gsampler2D _sampler_, vec3 _P_, ivec2 _offset_ [, float _bias_] ) +
  gvec4 *textureProjOffset*(gsampler2D _sampler_, vec4 _P_, ivec2 _offset_ [, float _bias_] ) +
  gvec4 *textureProjOffset*(gsampler3D _sampler_, vec4 _P_, ivec3 _offset_ [, float _bias_] ) +
ifdef::GLSL[]
  gvec4 *textureProjOffset*(gsampler2DRect _sampler_, vec3 _P_, ivec2 _offset_) +
  gvec4 *textureProjOffset*(gsampler2DRect _sampler_, vec4 _P_, ivec2 _offset_) +
  float *textureProjOffset*(sampler2DRectShadow _sampler_, vec4 _P_, ivec2 _offset_) +
  float *textureProjOffset*(sampler1DShadow _sampler_, vec4 _P_, int _offset_ [, float _bias_] ) +
endif::GLSL[]
  float *textureProjOffset*(sampler2DShadow _sampler_, vec4 _P_, ivec2 _offset_ [, float _bias_] )
    | Do a projective texture lookup as described in *textureProj*, offset
      by _offset_ as described in *textureOffset*.
|
ifdef::GLSL[]
  gvec4 *textureLodOffset*(gsampler1D _sampler_, float _P_, float _lod_, int _offset_) +
endif::GLSL[]
  gvec4 *textureLodOffset*(gsampler2D _sampler_, vec2 _P_, float _lod_, ivec2 _offset_) +
  gvec4 *textureLodOffset*(gsampler3D _sampler_, vec3 _P_, float _lod_, ivec3 _offset_) +
ifdef::GLSL[]
  float *textureLodOffset*(sampler1DShadow _sampler_, vec3 _P_, float _lod_, int _offset_) +
endif::GLSL[]
  float *textureLodOffset*(sampler2DShadow _sampler_,  vec3 _P_, float _lod_, ivec2 _offset_) +
ifdef::GLSL[]
  gvec4 *textureLodOffset*(gsampler1DArray _sampler_, vec2 _P_, float _lod_, int _offset_) +
endif::GLSL[]
  gvec4 *textureLodOffset*(gsampler2DArray _sampler_, vec3 _P_, float _lod_, ivec2 _offset_) +
ifdef::GLSL[]
  float *textureLodOffset*(sampler1DArrayShadow _sampler_, vec3 _P_, float _lod_, int _offset_)
endif::GLSL[]
    | Do an offset texture lookup with explicit level-of-detail.
      See *textureLod* and *textureOffset*.
|
ifdef::GLSL[]
  gvec4 *textureProjLod*(gsampler1D _sampler_, vec2 _P_, float _lod_) +
  gvec4 *textureProjLod*(gsampler1D _sampler_, vec4 _P_, float _lod_) +
endif::GLSL[]
  gvec4 *textureProjLod*(gsampler2D _sampler_, vec3 _P_, float _lod_) +
  gvec4 *textureProjLod*(gsampler2D _sampler_, vec4 _P_, float _lod_) +
  gvec4 *textureProjLod*(gsampler3D _sampler_, vec4 _P_, float _lod_) +
ifdef::GLSL[]
  float *textureProjLod*(sampler1DShadow _sampler_, vec4 _P_, float _lod_) +
endif::GLSL[]
  float *textureProjLod*(sampler2DShadow _sampler_, vec4 _P_, float _lod_)
    | Do a projective texture lookup with explicit level-of-detail.
      See *textureProj* and *textureLod*.
|
ifdef::GLSL[]
  gvec4 *textureProjLodOffset*(gsampler1D _sampler_, vec2 _P_, float _lod_, int _offset_) +
  gvec4 *textureProjLodOffset*(gsampler1D _sampler_, vec4 _P_, float _lod_, int _offset_) +
endif::GLSL[]
  gvec4 *textureProjLodOffset*(gsampler2D _sampler_, vec3 _P_, float _lod_, ivec2 _offset_) +
  gvec4 *textureProjLodOffset*(gsampler2D _sampler_, vec4 _P_, float _lod_, ivec2 _offset_) +
  gvec4 *textureProjLodOffset*(gsampler3D _sampler_, vec4 _P_, float _lod_, ivec3 _offset_) +
ifdef::GLSL[]
  float *textureProjLodOffset*(sampler1DShadow _sampler_, vec4 _P_, float _lod_, int _offset_) +
endif::GLSL[]
  float *textureProjLodOffset*(sampler2DShadow _sampler_, vec4 _P_, float _lod_, ivec2 _offset_)
    | Do an offset projective texture lookup with explicit level-of-detail.
      See *textureProj*, *textureLod*, and *textureOffset*.
|
ifdef::GLSL[]
  gvec4 *textureGrad*(gsampler1D _sampler_, float _P_, float _dPdx_, float _dPdy_) +
endif::GLSL[]
  gvec4 *textureGrad*(gsampler2D _sampler_, vec2 _P_, vec2 _dPdx_, vec2 _dPdy_) +
  gvec4 *textureGrad*(gsampler3D _sampler_, vec3 _P_, vec3 _dPdx_, vec3 _dPdy_) +
  gvec4 *textureGrad*(gsamplerCube _sampler_, vec3 _P_, vec3 _dPdx_, vec3 _dPdy_) +
ifdef::GLSL[]
  gvec4 *textureGrad*(gsampler2DRect _sampler_, vec2 _P_, vec2 _dPdx_, vec2 _dPdy_) +
  float *textureGrad*(sampler2DRectShadow _sampler_, vec3 _P_, vec2 _dPdx_, vec2 _dPdy_) +
  float *textureGrad*(sampler1DShadow _sampler_, vec3 _P_, float _dPdx_, float _dPdy_) +
  gvec4 *textureGrad*(gsampler1DArray _sampler_, vec2 _P_, float _dPdx_, float _dPdy_) +
  float *textureGrad*(sampler1DArrayShadow _sampler_, vec3 _P_, float _dPdx_, float _dPdy_) +
endif::GLSL[]
  float *textureGrad*(sampler2DShadow _sampler_, vec3 _P_, vec2 _dPdx_, vec2 _dPdy_) +
  float *textureGrad*(samplerCubeShadow _sampler_, vec4 _P_, vec3 _dPdx_, vec3 _dPdy_) +
  gvec4 *textureGrad*(gsampler2DArray _sampler_, vec3 _P_, vec2 _dPdx_, vec2 _dPdy_) +
  float *textureGrad*(sampler2DArrayShadow _sampler_, vec4 _P_, vec2 _dPdx_, vec2 _dPdy_) +
  gvec4 *textureGrad*(gsamplerCubeArray _sampler_, vec4 _P_, vec3 _dPdx_, vec3 _dPdy_) +
   a| Do a texture lookup as in *texture* but with <<explicit-gradients,
      explicit gradients>> as shown below.
      The partial derivatives of _P_ are with respect to window _x_ and
      window _y_.
      For the cube version, the partial derivatives of _P_ are assumed to be
      in the coordinate system used before texture coordinates are projected
      onto the appropriate cube face.
|
ifdef::GLSL[]
  gvec4 *textureGradOffset*(gsampler1D _sampler_, float _P_, float _dPdx_, float _dPdy_, int _offset_) +
endif::GLSL[]
  gvec4 *textureGradOffset*(gsampler2D _sampler_, vec2 _P_, vec2 _dPdx_, vec2 _dPdy_, ivec2 _offset_) +
  gvec4 *textureGradOffset*(gsampler3D _sampler_, vec3 _P_, vec3 _dPdx_, vec3 _dPdy_, ivec3 _offset_) +
ifdef::GLSL[]
  gvec4 *textureGradOffset*(gsampler2DRect _sampler_, vec2 _P_, vec2 _dPdx_, vec2 _dPdy_, ivec2 _offset_) +
  float *textureGradOffset*(sampler2DRectShadow _sampler_, vec3 _P_, vec2 _dPdx_, vec2 _dPdy_, ivec2 _offset_) +
  float *textureGradOffset*(sampler1DShadow _sampler_, vec3 _P_, float _dPdx_, float _dPdy_, int _offset_) +
endif::GLSL[]
  float *textureGradOffset*(sampler2DShadow _sampler_, vec3 _P_, vec2 _dPdx_, vec2 _dPdy_, ivec2 _offset_) +
  gvec4 *textureGradOffset*(gsampler2DArray _sampler_, vec3 _P_, vec2 _dPdx_, vec2 _dPdy_, ivec2 _offset_) +
ifdef::GLSL[]
  gvec4 *textureGradOffset*(gsampler1DArray _sampler_, vec2 _P_, float _dPdx_, float _dPdy_, int _offset_) +
  float *textureGradOffset*(sampler1DArrayShadow _sampler_, vec3 _P_, float _dPdx_, float _dPdy_, int _offset_) +
endif::GLSL[]
  float *textureGradOffset*(sampler2DArrayShadow _sampler_, vec4 _P_, vec2 _dPdx_, vec2 _dPdy_, ivec2 _offset_) +
    | Do a texture lookup with both explicit gradient and offset, as
      described in *textureGrad* and *textureOffset*.
|
ifdef::GLSL[]
  gvec4 *textureProjGrad*(gsampler1D _sampler_, vec2 _P_, float _dPdx_, float _dPdy_) +
  gvec4 *textureProjGrad*(gsampler1D _sampler_, vec4 _P_, float _dPdx_, float _dPdy_) +
endif::GLSL[]
  gvec4 *textureProjGrad*(gsampler2D _sampler_, vec3 _P_, vec2 _dPdx_, vec2 _dPdy_) +
  gvec4 *textureProjGrad*(gsampler2D _sampler_, vec4 _P_, vec2 _dPdx_, vec2 _dPdy_) +
  gvec4 *textureProjGrad*(gsampler3D _sampler_, vec4 _P_, vec3 _dPdx_, vec3 _dPdy_) +
ifdef::GLSL[]
  gvec4 *textureProjGrad*(gsampler2DRect _sampler_, vec3 _P_, vec2 _dPdx_, vec2 _dPdy_) +
  gvec4 *textureProjGrad*(gsampler2DRect _sampler_, vec4 _P_, vec2 _dPdx_, vec2 _dPdy_) +
  float *textureProjGrad*(sampler2DRectShadow _sampler_, vec4 _P_, vec2 _dPdx_, vec2 _dPdy_) +
  float *textureProjGrad*(sampler1DShadow _sampler_, vec4 _P_, float _dPdx_, float _dPdy_) +
endif::GLSL[]
  float *textureProjGrad*(sampler2DShadow _sampler_, vec4 _P_, vec2 _dPdx_, vec2 _dPdy_)
    | Do a texture lookup both projectively, as described in *textureProj*,
      and with explicit gradient as described in *textureGrad*.
      The partial derivatives _dPdx_ and _dPdy_ are assumed to be already
      projected.
|
ifdef::GLSL[]
  gvec4 *textureProjGradOffset*(gsampler1D _sampler_, vec2 _P_, float _dPdx_, float _dPdy_, int _offset_) +
  gvec4 *textureProjGradOffset*(gsampler1D _sampler_, vec4 _P_, float _dPdx_, float _dPdy_, int _offset_) +
endif::GLSL[]
  gvec4 *textureProjGradOffset*(gsampler2D _sampler_, vec3 _P_, vec2 _dPdx_, vec2 _dPdy_, ivec2 _offset_) +
  gvec4 *textureProjGradOffset*(gsampler2D _sampler_, vec4 _P_, vec2 _dPdx_, vec2 _dPdy_, ivec2 _offset_) +
  gvec4 *textureProjGradOffset*(gsampler3D _sampler_, vec4 _P_, vec3 _dPdx_, vec3 _dPdy_, ivec3 _offset_) +
ifdef::GLSL[]
  gvec4 *textureProjGradOffset*(gsampler2DRect _sampler_, vec3 _P_, vec2 _dPdx_, vec2 _dPdy_, ivec2 _offset_) +
  gvec4 *textureProjGradOffset*(gsampler2DRect _sampler_, vec4 _P_, vec2 _dPdx_, vec2 _dPdy_, ivec2 _offset_) +
  float *textureProjGradOffset*(sampler2DRectShadow _sampler_, vec4 _P_, vec2 _dPdx_, vec2 _dPdy_, ivec2 _offset_) +
  float *textureProjGradOffset*(sampler1DShadow _sampler_, vec4 _P_, float _dPdx_, float _dPdy_, int _offset_) +
endif::GLSL[]
  float *textureProjGradOffset*(sampler2DShadow _sampler_, vec4 _P_, vec2 _dPdx_, vec2 _dPdy_, ivec2 _offset_)
    | Do a texture lookup projectively and with explicit gradient as
      described in *textureProjGrad*, as well as with offset, as described in
      *textureOffset*.
|====


[[explicit-gradients]]
=== Explicit Gradients

ifdef::editing-notes[]
[NOTE]
.editing-note
====
(Jon) Moved to new section from *textureGrad* table entry above because
asciidoctor-mathematical doesn't support math blocks in table cells yet.
====
endif::editing-notes[]

In the *textureGrad* functions described above, explicit gradients control
texture lookups as follows:

ifdef::GLSL[]
[latexmath]
++++
\begin{aligned}
  \frac{\partial{s}}{\partial{x}} & =
    \begin{cases}
      \frac{\partial{P}}{\partial{x}}, & \text{for a 1D texture} \\[0.8em]
      \frac{\partial{P.s}}{\partial{x}}, & \text{otherwise}
    \end{cases} \\[2.5em]
  \frac{\partial{s}}{\partial{y}} & =
    \begin{cases}
      \frac{\partial{P}}{\partial{y}}, & \text{for a 1D texture} \\[0.8em]
      \frac{\partial{P.s}}{\partial{y}}, & \text{otherwise}
    \end{cases} \\[2.5em]
  \frac{\partial{t}}{\partial{x}} & =
    \begin{cases}
      0.0,                               & \text{for a 1D texture} \\[0.8em]
      \frac{\partial{P.t}}{\partial{x}}, & \text{otherwise}
    \end{cases} \\[2.5em]
  \frac{\partial{t}}{\partial{y}} & =
    \begin{cases}
      0.0,                               & \text{for a 1D texture} \\[0.8em]
      \frac{\partial{P.t}}{\partial{y}}, & \text{otherwise}
    \end{cases} \\[2.5em]
  \frac{\partial{r}}{\partial{x}} & =
    \begin{cases}
      0.0,                               & \text{for 1D or 2D} \\[0.8em]
      \frac{\partial{P.p}}{\partial{x}}, & \text{cube, other}
    \end{cases} \\[2.5em]
  \frac{\partial{r}}{\partial{y}} & =
    \begin{cases}
      0.0,                               & \text{for 1D or 2D} \\[0.8em]
      \frac{\partial{P.p}}{\partial{y}}, & \text{cube, other}
    \end{cases}
\end{aligned}
++++
endif::GLSL[]
ifdef::ESSL[]
[latexmath]
++++
\begin{aligned}
  \frac{\partial{s}}{\partial{x}} & = \frac{\partial{P.s}}{\partial{x}} \\[0.8em]
  \frac{\partial{s}}{\partial{y}} & = \frac{\partial{P.s}}{\partial{y}} \\[0.8em]
  \frac{\partial{t}}{\partial{x}} & = \frac{\partial{P.t}}{\partial{x}} \\[0.8em]
  \frac{\partial{t}}{\partial{y}} & = \frac{\partial{P.t}}{\partial{y}} \\[0.8em]
  \frac{\partial{r}}{\partial{x}} & =
    \begin{cases}
      0.0,                               & \text{for 2D} \\[0.8em]
      \frac{\partial{P.p}}{\partial{x}}, & \text{cube, other}
    \end{cases} \\[2.5em]
  \frac{\partial{r}}{\partial{y}} & =
    \begin{cases}
      0.0,                               & \text{for 2D} \\[0.8em]
      \frac{\partial{P.p}}{\partial{y}}, & \text{cube, other}
    \end{cases}
\end{aligned}
++++
endif::ESSL[]


[[texture-gather-functions]]
=== Texture Gather Functions

The texture gather functions take components of a single floating-point
vector operand as a texture coordinate, determine a set of four texels to
sample from the base level-of-detail of the specified texture image, and
return one component from each texel in a four-component result vector.

When performing a texture gather operation, the minification and
magnification filters are ignored, and the rules for LINEAR filtering in the
<<references,{apispec}>> are applied to the base level of the texture image
to identify the four texels _i~0~ j~1~_, _i~1~ j~1~_, _i~1~ j~0~_, and _i~0~
j~0~_.
The texels are then converted to texture base colors (_R~s~_, _G~s~_,
_B~s~_, _A~s~_) according to table 15.1, followed by application of the
texture swizzle as described in section 15.2.1 "`Texture Access`" of the
<<references,{apispec}>>.
A four-component vector is assembled by taking the selected component from
each of the post-swizzled texture source colors in the order (_i~0~ j~1~_,
_i~1~ j~1~_, _i~1~ j~0~_, _i~0~ j~0~_).

ifdef::ESSL[]
The selected component is identified by the optional _comp_ argument, where
the values zero, one, two, and three identify the _R~s~_, _G~s~_, _B~s~_, or
_A~s~_ component, respectively.
If _comp_ is omitted, it is treated as identifying the _R~s~_ component.

Incomplete textures (see section 8.16 "`Texture Completeness`" of the
<<references,{apispec}>>) return a texture source color of (0,0,0,1) for all
four source texels.

endif::ESSL[]
For texture gather functions using a texture-combined shadow sampler type,
each of the four
texel lookups perform a depth comparison against the depth reference value
passed in (_refZ_), and returns the result of that comparison in the
appropriate component of the result vector.

As with other texture lookup functions, the results of a texture gather are
undefined for shadow samplers if the texture referenced is not a depth
texture or has depth comparisons disabled; or for non-shadow samplers if the
texture referenced is a depth texture with depth comparisons enabled.

ifdef::ESSL[]
The *textureGatherOffset* built-in functions from the {slname} return a vector
derived from sampling four texels in the image array of level _level~base~_.
For each of the four texel offsets specified by the _offsets_ argument, the
rules for the LINEAR minification filter are applied to identify a 2 {times}
2 texel footprint, from which the single texel T~i0j0~ is selected.
A four-component vector is then assembled by taking a single component from
each of the four T~i0j0~ texels in the same manner as for the
*textureGather* function.
endif::ESSL[]

[options="header"]
|====
| Syntax | Description
| gvec4 *textureGather*(gsampler2D _sampler_, vec2 _P_ [, int _comp_]) +
  gvec4 *textureGather*(gsampler2DArray _sampler_, vec3 _P_ [, int _comp_]) +
  gvec4 *textureGather*(gsamplerCube _sampler_, vec3 _P_ [, int _comp_]) +
  gvec4 *textureGather*(gsamplerCubeArray _sampler_, vec4 _P_[, int _comp_]) +
ifdef::GLSL[]
  gvec4 *textureGather*(gsampler2DRect _sampler_, vec2 _P_[, int _comp_]) +
endif::GLSL[]
  vec4 *textureGather*(sampler2DShadow _sampler_, vec2 _P_, float _refZ_) +
  vec4 *textureGather*(sampler2DArrayShadow _sampler_, vec3 _P_, float _refZ_) +
  vec4 *textureGather*(samplerCubeShadow _sampler_, vec3 _P_, float _refZ_) +
  vec4 *textureGather*(samplerCubeArrayShadow _sampler_, vec4 _P_, float _refZ_) +
ifdef::GLSL[]
  vec4 *textureGather*(sampler2DRectShadow _sampler_, vec2 _P_, float _refZ_)
endif::GLSL[]
   a| Returns the value +
--
[source,glsl]
----
vec4(Sample_i0_j1(P, base).comp,
     Sample_i1_j1(P, base).comp,
     Sample_i1_j0(P, base).comp,
     Sample_i0_j0(P, base).comp)
----

If specified, the value of _comp_ must be a constant integer expression with
a value of 0, 1, 2, or 3, identifying the _x_, _y_, _z_, or _w_
post-swizzled component of the four-component vector lookup result for each
texel, respectively.
If _comp_ is not specified, it is treated as 0, selecting the _x_ component
of each texel to generate the result.
--
| gvec4 *textureGatherOffset*(gsampler2D _sampler_, vec2 _P_, ivec2 _offset_, [ int _comp_]) +
  gvec4 *textureGatherOffset*(gsampler2DArray _sampler_, vec3 _P_, ivec2 _offset_ [ int _comp_]) +
  vec4 *textureGatherOffset*(sampler2DShadow _sampler_, vec2 _P_, float _refZ_, ivec2 _offset_) +
  vec4 *textureGatherOffset*(sampler2DArrayShadow _sampler_, vec3 _P_, float _refZ_, ivec2 _offset_) +
ifdef::GLSL[]
  gvec4 *textureGatherOffset*(gsampler2DRect _sampler_, vec2 _P_, ivec2 _offset_ [ int _comp_]) +
  vec4 *textureGatherOffset*(sampler2DRectShadow _sampler_, vec2 _P_, float _refZ_, ivec2 _offset_)
endif::GLSL[]
    | Perform a texture gather operation as in *textureGather* by _offset_
      as described in *textureOffset* except that the _offset_ can be
      variable (non constant) and the implementation-dependent minimum and
      maximum offset values are given by MIN_PROGRAM_TEXTURE_GATHER_OFFSET
      and MAX_PROGRAM_TEXTURE_GATHER_OFFSET, respectively.
| gvec4 *textureGatherOffsets*(gsampler2D _sampler_, vec2 _P_, ivec2 _offsets_[4] [, int _comp_]) +
  gvec4 *textureGatherOffsets*(gsampler2DArray _sampler_, vec3 _P_, ivec2 _offsets_[4]   [, int _comp_]) +
  vec4 *textureGatherOffsets*(sampler2DShadow _sampler_, vec2 _P_, float _refZ_, ivec2 _offsets_[4]) +
  vec4 *textureGatherOffsets*(sampler2DArrayShadow _sampler_, vec3 _P_, float _refZ_, ivec2 _offsets_[4]) +
ifdef::GLSL[]
  gvec4 *textureGatherOffsets*(gsampler2DRect _sampler_, vec2 _P_, ivec2 _offsets_[4] [, int _comp_]) +
  vec4 *textureGatherOffsets*(sampler2DRectShadow _sampler_, vec2 _P_, float _refZ_, ivec2 _offsets_[4])
endif::GLSL[]
    | Operate identically to *textureGatherOffset* except that _offsets_ is
      used to determine the location of the four texels to sample.
      Each of the four texels is obtained by applying the corresponding
      offset in _offsets_ as a (_u_, _v_) coordinate offset to _P_,
      identifying the four-texel LINEAR footprint, and then selecting the
      texel _i~0~ j~0~_ of that footprint.
      The specified values in _offsets_ must be constant integral
      expressions.
|====


ifdef::GLSL[]
[[compatibility-profile-texture-functions]]
=== Compatibility Profile Texture Functions

The following texture functions are only in the compatibility profile.

[options="header"]
|====
| Syntax | Description
| vec4 *texture1D*(sampler1D _sampler_, float _coord_ [, float _bias_] ) +
  vec4 *texture1DProj*(sampler1D _sampler_, vec2 _coord_ [, float _bias_] ) +
  vec4 *texture1DProj*(sampler1D _sampler_, vec4 _coord_ [, float _bias_] ) +
  vec4 *texture1DLod*(sampler1D _sampler_, float _coord_, float _lod_) +
  vec4 *texture1DProjLod*(sampler1D _sampler_, vec2 _coord_, float _lod_) +
  vec4 *texture1DProjLod*(sampler1D _sampler_, vec4 _coord_, float _lod_)
    | See corresponding signature above without "`1D`" in the name.
| vec4 *texture2D*(sampler2D _sampler_, vec2 _coord_ [, float _bias_] ) +
  vec4 *texture2DProj*(sampler2D _sampler_, vec3 _coord_ [, float _bias_] ) +
  vec4 *texture2DProj*(sampler2D _sampler_, vec4 _coord_ [, float _bias_] ) +
  vec4 *texture2DLod*(sampler2D _sampler_, vec2 _coord_, float _lod_) +
  vec4 *texture2DProjLod*(sampler2D _sampler_, vec3 _coord_, float _lod_) +
  vec4 *texture2DProjLod*(sampler2D _sampler_, vec4 _coord_, float _lod_)
    | See corresponding signature above without "`2D`" in the name.
| vec4 *texture3D*(sampler3D _sampler_, vec3 _coord_ [, float _bias_] ) +
  vec4 *texture3DProj*(sampler3D _sampler_, vec4 _coord_ [, float _bias_] ) +
  vec4 *texture3DLod*(sampler3D _sampler_, vec3 _coord_, float _lod_) +
  vec4 *texture3DProjLod*(sampler3D _sampler_, vec4 _coord_, float _lod_)
    | See corresponding signature above without "`3D`" in the name. +
      Use the texture coordinate _coord_ to do a texture lookup in the 3D
      texture currently bound to _sampler_.
      For the projective ("`*Proj*`") versions, the texture coordinate is
      divided by _coord.q_.
| vec4 *textureCube*(samplerCube _sampler_, vec3 _coord_ [, float _bias_] ) +
  vec4 *textureCubeLod*(samplerCube _sampler_, vec3 _coord_, float _lod_)
    | See corresponding signature above without "`Cube`" in the name.
| vec4 *shadow1D*(sampler1DShadow _sampler_, vec3 _coord_ [, float _bias_] ) +
  vec4 *shadow2D*(sampler2DShadow _sampler_, vec3 _coord_ [, float _bias_] ) +
  vec4 *shadow1DProj*(sampler1DShadow _sampler_, vec4 _coord_ [, float _bias_] ) +
  vec4 *shadow2DProj*(sampler2DShadow _sampler_, vec4 _coord_ [, float _bias_] ) +
  vec4 *shadow1DLod*(sampler1DShadow _sampler_, vec3 _coord_, float _lod_) +
  vec4 *shadow2DLod*(sampler2DShadow _sampler_, vec3 _coord_, float _lod_) +
  vec4 *shadow1DProjLod*(sampler1DShadow _sampler_, vec4 _coord_, float _lod_) +
  vec4 *shadow2DProjLod*(sampler2DShadow _sampler_, vec4 coord, float _lod_)
    | Same functionality as the "`*texture*`" based names above with the
      same signature.
|====
endif::GLSL[]


[[atomic-counter-functions]]
== Atomic Counter Functions

The atomic-counter operations in this section operate atomically with
respect to each other.
They are atomic for any single counter, meaning any of these operations on a
specific counter in one shader instantiation will be indivisible by any of
these operations on the same counter from another shader instantiation.
There is no guarantee that these operations are atomic with respect to other
forms of access to the counter or that they are serialized when applied to
separate counters.
Such cases would require additional use of fences, barriers, or other forms
of synchronization, if atomicity or serialization is desired.

The underlying counter is a 32-bit unsigned integer.
The result of operations will wrap to [0, 2^32^-1].

[options="header"]
|====
| Syntax | Description
| uint *atomicCounterIncrement*(atomic_uint _c_)
    a| Atomically +
--
  . increments the counter for _c_, and
  . returns its value prior to the increment operation.

These two steps are done atomically with respect to the atomic counter
functions in this table.
--
| uint *atomicCounterDecrement*(atomic_uint _c_)
    a| Atomically +
--
  . decrements the counter for _c_, and
  . returns the value resulting from the decrement operation.

These two steps are done atomically with respect to the atomic counter
functions in this table.
--
| uint *atomicCounter*(atomic_uint _c_)
    | Returns the counter value for _c_.
ifdef::GLSL[]
| uint *atomicCounterAdd*(atomic_uint _c_, uint _data_)
    a| Atomically +
--
  . adds the value of _data_ to the counter for _c_, and
  . returns its value prior to the operation.

These two steps are done atomically with respect to the atomic counter
functions in this table.
--
| uint *atomicCounterSubtract*(atomic_uint _c_, uint _data_)
    a| Atomically +
--
  . subtracts the value of _data_ from the counter for _c_, and
  . returns its value prior to the operation.

These two steps are done atomically with respect to the atomic counter
functions in this table.
--
| uint *atomicCounterMin*(atomic_uint _c_, uint _data_)
    a| Atomically +
--
  . sets the counter for _c_ to the minimum of the value of the counter and
    the value of _data_, and
  . returns the value prior to the operation.

These two steps are done atomically with respect to the atomic counter
functions in this table.
--
| uint *atomicCounterMax*(atomic_uint _c_, uint _data_)
    a| Atomically +
--
  . sets the counter for _c_ to the maximum of the value of the counter and
    the value of _data_, and
  . returns the value prior to the operation.

These two steps are done atomically with respect to the atomic counter
functions in this table.
--
| uint *atomicCounterAnd*(atomic_uint _c_, uint _data_)
    a| Atomically +
--
  . sets the counter for _c_ to the bitwise AND of the value of the counter
    and the value of _data_, and
  . returns the value prior to the operation.

These two steps are done atomically with respect to the atomic counter
functions in this table.
--
| uint *atomicCounterOr*(atomic_uint _c_, uint _data_)
    a| Atomically +
--
  . sets the counter for _c_ to the bitwise OR of the value of the counter
    and the value of _data_, and
  . returns the value prior to the operation.

These two steps are done atomically with respect to the atomic counter
functions in this table.
--
| uint *atomicCounterXor*(atomic_uint _c_, uint _data_)
    a| Atomically +
--
  . sets the counter for _c_ to the bitwise XOR of the value of the counter
    and the value of _data_, and
  . returns the value prior to the operation.

These two steps are done atomically with respect to the atomic counter
functions in this table.
--
| uint *atomicCounterExchange*(atomic_uint _c_, uint _data_)
    a| Atomically +
--
  . sets the counter value for _c_ to the value of _data_, and
  . returns its value prior to the operation.

These two steps are done atomically with respect to the atomic counter
functions in this table.
--
| uint *atomicCounterCompSwap*(atomic_uint _c_, uint _compare_, uint _data_)
    a| Atomically +
--
  . compares the value of _compare_ and the counter value for _c_
  . if the values are equal, sets the counter value for _c_ to the value of
    _data_, and
  . returns its value prior to the operation.

These three steps are done atomically with respect to the atomic counter
functions in this table.
--
endif::GLSL[]
|====


[[atomic-memory-functions]]
== Atomic Memory Functions

Atomic memory functions perform atomic operations on an individual signed or
unsigned integer stored in buffer object or shared variable storage.  All of
the atomic memory operations read a value from memory, compute a new value
using one of the operations described below, write the new value to memory, and
return the original value read, converted to the precision declared in the
shader. Note that the operations are performed at the in-memory precision of
the storage, which may differ from the precision declared in the shader.

The contents of the memory being updated by the atomic operation are
guaranteed not to be modified by any other assignment or atomic memory
function in any shader invocation between the time the original value is
read and the time the new value is written.

Atomic memory functions are supported only for a limited set of variables.
A shader will fail to compile if the value passed to the _mem_ argument of
an atomic memory function does not correspond to a buffer or shared
variable.
It is acceptable to pass an element of an array or a single component of a
vector to the _mem_ argument of an atomic memory function, as long as the
underlying array or vector is a buffer or shared variable.

All the built-in functions in this section accept arguments with
combinations of *restrict*, *coherent*, and *volatile* memory qualification,
despite not having them listed in the prototypes.
The atomic operation will operate as required by the calling argument's
memory qualification, not by the built-in function's formal parameter memory
qualification.

[options="header"]
|====
| Syntax | Description
| uint *atomicAdd*(inout uint _mem_, uint _data_) +
  int *atomicAdd*(inout int _mem_, int _data_)
    | Computes a new value by adding the value of _data_ to the contents
      _mem_.
| uint *atomicMin*(inout uint _mem_, uint _data_) +
  int *atomicMin*(inout int _mem_, int _data_)
    | Computes a new value by taking the minimum of the value of _data_ and
      the contents of _mem_.
| uint *atomicMax*(inout uint _mem_, uint _data_) +
  int *atomicMax*(inout int _mem_, int _data_)
    | Computes a new value by taking the maximum of the value of _data_ and
      the contents of _mem_.
| uint *atomicAnd*(inout uint _mem_, uint _data_) +
  int *atomicAnd*(inout int _mem_, int _data_)
    | Computes a new value by performing a bit-wise AND of the value of
      _data_ and the contents of _mem_.
| uint *atomicOr*(inout uint _mem_, uint _data_) +
  int *atomicOr*(inout int _mem_, int _data_)
    | Computes a new value by performing a bit-wise OR of the value of
      _data_ and the contents of _mem_.
| uint *atomicXor*(inout uint _mem_, uint _data_) +
  int *atomicXor*(inout int _mem_, int _data_)
    | Computes a new value by performing a bit-wise EXCLUSIVE OR of the
      value of _data_ and the contents of _mem_.
| uint *atomicExchange*(inout uint _mem_, uint _data_) +
  int *atomicExchange*(inout int _mem_, int _data_)
    | Computes a new value by simply copying the value of _data_.
| uint *atomicCompSwap*(inout uint _mem_, uint _compare_, uint _data_) +
  int *atomicCompSwap*(inout int _mem_, int _compare_, int _data_)
    | Compares the value of _compare_ and the contents of _mem_.
      If the values are equal, the new value is given by _data_; otherwise,
      it is taken from the original contents of _mem_.
|====


[[image-functions]]
== Image Functions

Variables using one of the image basic types may be used by the built-in
shader image memory functions defined in this section to read and write
individual texels of a texture.
Each image variable references an image unit, which has a texture image
attached.

When image memory functions below access memory, an individual texel in the
image is identified using an (_i_), (_i, j_), or (_i, j, k_) coordinate
corresponding to the values of _P_.
ifdef::GLSL[]
For *image2DMS* and *image2DMSArray* variables (and the corresponding
int/unsigned int types) corresponding to multisample textures, each texel
may have multiple samples and an individual sample is identified using the
integer _sample_ parameter.
endif::GLSL[]
The coordinates
ifdef::GLSL[and sample number]
are used to select an individual texel in the manner described in section
ifdef::GLSL[8.26]
ifdef::ESSL[8.22]
"`Texture Image Loads and Stores`" of the <<references,{apispec}>>.

Loads and stores support float, integer, and unsigned integer types.
The data types below starting `gimage` serve as placeholders meaning
types starting either "`*image*`", "`*iimage*`", or "`*uimage*`" in the same
way as "*gvec*" or "*gsampler*" in earlier sections.

The _IMAGE_PARAMS_ in the prototypes below is a placeholder representing
ifdef::GLSL[33]
ifdef::ESSL[18]
separate functions, each for a different type of image variable.
The _IMAGE_PARAMS_ placeholder is replaced by one of the following parameter
lists:

{empty}:: gimage2D _image_, ivec2 _P_
{empty}:: gimage3D _image_, ivec3 _P_
{empty}:: gimageCube _image_, ivec3 _P_
{empty}:: gimageBuffer _image_, int _P_
{empty}:: gimage2DArray _image_, ivec3 _P_
{empty}:: gimageCubeArray _image_, ivec3 _P_
ifdef::GLSL[]
{empty}:: gimage1D _image_, int _P_
{empty}:: gimage1DArray _image_, ivec2 _P_
{empty}:: gimage2DRect _image_, ivec2 _P_
{empty}:: gimage2DMS _image_, ivec2 _P_, int _sample_
{empty}:: gimage2DMSArray _image_, ivec3 _P_, int _sample_
endif::GLSL[]

where each of the lines represents one of three different image variable
types, and _image_,
ifdef::GLSL[_P_, and _sample_]
ifdef::ESSL[_P_]
specify the individual texel to operate on.
The method for identifying the individual texel operated on from _image_,
_P_,
ifdef::GLSL[and _sample_,]
and the method for reading and writing the texel are specified in section
ifdef::GLSL[8.26]
ifdef::ESSL[8.22]
"`Texture Image Loads and Stores`" of the <<references,{apispec}>>.

The atomic functions perform operations on individual texels or samples of
an image variable.
Atomic memory operations read a value from the selected texel, compute a new
value using one of the operations described below, write the new value to
the selected texel, and return the original value read.
The contents of the texel being updated by the atomic operation are
guaranteed not to be modified by any other image store or atomic function
between the time the original value is read and the time the new value is
written.

Atomic memory operations are supported on only a subset of all image
variable types; _image_ must be either:

  * a signed integer image variable (type starts "`*iimage*`") and a format
    qualifier of *r32i*, used with a _data_ argument of type *int*, or
  * an unsigned integer image variable (type starts "`*uimage*`") and a
    format qualifier of *r32ui*, used with a _data_ argument of type *uint*,
    or
  * a float image variable (type starts "`*image*`") and a format qualifier
    of *r32f*, used with a _data_ argument of type *float*
    (*imageAtomicExchange* only).

All the built-in functions in this section accept arguments with
combinations of *restrict*, *coherent*, and *volatile* memory qualification,
despite not having them listed in the prototypes.
The image operation will operate as required by the calling argument's
memory qualification, not by the built-in function's formal parameter memory
qualification.

[options="header"]
|====
| Syntax | Description
|
ifdef::GLSL[]
  {highp}   int *imageSize*(readonly writeonly gimage1D _image_) +
endif::GLSL[]
  {highp} ivec2 *imageSize*(readonly writeonly gimage2D _image_) +
  {highp} ivec3 *imageSize*(readonly writeonly gimage3D _image_) +
  {highp} ivec2 *imageSize*(readonly writeonly gimageCube _image_) +
  {highp} ivec3 *imageSize*(readonly writeonly gimageCubeArray _image_) +
  {highp} ivec3 *imageSize*(readonly writeonly gimage2DArray _image_) +
ifdef::GLSL[]
  {highp} ivec2 *imageSize*(readonly writeonly gimage2DRect _image_) +
  {highp} ivec2 *imageSize*(readonly writeonly gimage1DArray _image_) +
  {highp} ivec2 *imageSize*(readonly writeonly gimage2DMS _image_) +
  {highp} ivec3 *imageSize*(readonly writeonly gimage2DMSArray _image_) +
endif::GLSL[]
  {highp}   int *imageSize*(readonly writeonly gimageBuffer _image_)
    | Returns the dimensions of the image bound to _image_.
      For arrayed images, the last component of the return value will hold
      the size of the array.
      Cube images only return the dimensions of one face, and the number of
      cubes in the cube map array, if arrayed. +
      Note: The qualification *readonly writeonly* accepts a variable
      qualified with *readonly*, *writeonly*, both, or neither.
      It means the formal argument will be used for neither reading nor
      writing to the underlying memory.
ifdef::GLSL[]
| int *imageSamples*(readonly writeonly gimage2DMS _image_) +
  int *imageSamples*(readonly writeonly gimage2DMSArray _image_)
    | Returns the number of samples of the image bound to _image_.
endif::GLSL[]
| gvec4 *imageLoad*(readonly _IMAGE_PARAMS_)
    | Loads the texel at the coordinate _P_ from the image unit _image_ (in
      _IMAGE_PARAMS_).
ifdef::GLSL[]
      For multisample loads, the sample number is given by _sample_.
      When _image_, _P_, and _sample_
endif::GLSL[]
ifdef::ESSL[]
      When _image_ and _P_
endif::ESSL[]
      identify a valid texel, the bits used to represent the selected texel in
      memory are converted to a *vec4*, *ivec4*, or *uvec4* in the manner
      described in section
ifdef::GLSL[8.26]
ifdef::ESSL[8.23]
      "`Texture Image Loads and Stores`" of the
      <<references,{apispec}>> and returned.
| void *imageStore*(writeonly _IMAGE_PARAMS_, gvec4 _data_)
    | Stores _data_ into the texel at the coordinate _P_ from the image
      specified by _image_.
ifdef::GLSL[]
      For multisample stores, the sample number is given by _sample_.
      When _image_, _P_, and _sample_
endif::GLSL[]
ifdef::ESSL[]
      When _image_ and _P_
endif::ESSL[]
      identify a valid texel, the bits used to represent _data_ are converted
      to the format of the image unit in the manner described in section
ifdef::GLSL[8.26]
ifdef::ESSL[8.23]
      "`Texture Image Loads and Stores`" of the <<references,{apispec}>>
      and stored to the specified texel.
| {highp} uint *imageAtomicAdd*(_IMAGE_PARAMS_, uint _data_) +
  {highp} int *imageAtomicAdd*(_IMAGE_PARAMS_, int _data_)
    | Computes a new value by adding the value of _data_ to the contents of
      the selected texel.
| {highp} uint *imageAtomicMin*(_IMAGE_PARAMS_, uint _data_) +
  {highp} int *imageAtomicMin*(_IMAGE_PARAMS_, int _data_)
    | Computes a new value by taking the minimum of the value of _data_ and
      the contents of the selected texel.
| {highp} uint *imageAtomicMax*(_IMAGE_PARAMS_, uint _data_) +
  {highp} int *imageAtomicMax*(_IMAGE_PARAMS_, int _data_)
    | Computes a new value by taking the maximum of the value _data_ and the
      contents of the selected texel.
| {highp} uint *imageAtomicAnd*(_IMAGE_PARAMS_, uint _data_) +
  {highp} int *imageAtomicAnd*(_IMAGE_PARAMS_, int _data_)
    | Computes a new value by performing a bit-wise AND of the value of
      _data_ and the contents of the selected texel.
| {highp} uint *imageAtomicOr*(_IMAGE_PARAMS_, uint _data_) +
  {highp} int *imageAtomicOr*(_IMAGE_PARAMS_, int _data_)
    | Computes a new value by performing a bit-wise OR of the value of
      _data_ and the contents of the selected texel.
| {highp} uint *imageAtomicXor*(_IMAGE_PARAMS_, uint _data_) +
  {highp} int *imageAtomicXor*(_IMAGE_PARAMS_, int _data_)
    | Computes a new value by performing a bit-wise EXCLUSIVE OR of the
      value of _data_ and the contents of the selected texel.
| {highp} uint *imageAtomicExchange*(_IMAGE_PARAMS_, uint _data_) +
  {highp} int *imageAtomicExchange*(_IMAGE_PARAMS_, int _data_) +
  {highp} float *imageAtomicExchange*(_IMAGE_PARAMS_, float _data_)
    | Computes a new value by simply copying the value of _data_.
| {highp} uint *imageAtomicCompSwap*(_IMAGE_PARAMS_, uint _compare_, uint _data_) +
  {highp} int *imageAtomicCompSwap*(_IMAGE_PARAMS_, int _compare_, int _data_)
    | Compares the value of _compare_ and the contents of the selected
      texel.
      If the values are equal, the new value is given by _data_; otherwise,
      it is taken from the original value loaded from the texel.
|====


[[geometry-shader-functions]]
== Geometry Shader Functions

These functions are only available in geometry shaders.
They are described in more depth following the table.

[options="header"]
|====
| Syntax | Description
ifdef::GLSL[]
| void *EmitStreamVertex*(int _stream_)
    | Emits the current values of output variables to the current output
      primitive on stream _stream_.
      The argument to _stream_ must be a constant integral expression.
      On return from this call, the values of all output variables are
      undefined. +
      Can only be used if multiple output streams are supported.
| void *EndStreamPrimitive*(int _stream_)
    | Completes the current output primitive on stream _stream_ and starts a
      new one.
      The argument to _stream_ must be a constant integral expression.
      No vertex is emitted. +
      Can only be used if multiple output streams are supported.
endif::GLSL[]
| void *EmitVertex*() +
    | Emits the current values of output variables to the current output
      primitive.
ifdef::GLSL[]
      When multiple output streams are supported, this is equivalent to
      calling *EmitStreamVertex*(0). +
endif::GLSL[]
      On return from this call, the values of output variables are
      undefined.
| void *EndPrimitive*()
    | Completes the current output primitive and starts a new one.
ifdef::GLSL[]
      When multiple output streams are supported, this is equivalent to
      calling *EndStreamPrimitive*(0). +
endif::GLSL[]
      No vertex is emitted.
|====

ifdef::GLSL[]
The function *EmitStreamVertex*() specifies that a vertex is completed.
A vertex is added to the current output primitive in vertex stream _stream_
using the current values of all built-in and user-defined output variables
associated with _stream_.
The values of all output variables for all output streams are undefined
after a call to *EmitStreamVertex*().
If a geometry shader invocation has emitted more vertices than permitted by
the output layout qualifier *max_vertices*, the results of calling
*EmitStreamVertex*() are undefined.

The function *EndStreamPrimitive*() specifies that the current output
primitive for vertex stream _stream_ is completed and a new output primitive
(of the same type) will be started by any subsequent *EmitStreamVertex*().
This function does not emit a vertex.
If the output layout is declared to be *points*, calling
*EndStreamPrimitive*() is optional.

A geometry shader starts with an output primitive containing no vertices for
each stream.
When a geometry shader terminates, the current output primitive for each
stream is automatically completed.
It is not necessary to call *EndStreamPrimitive*() if the geometry shader
writes only a single primitive.

Multiple output streams are supported only if the output primitive type is
declared to be *points*.
It is a compile-time or link-time error if a program contains a geometry
shader calling *EmitStreamVertex*() or *EndStreamPrimitive*() if its output
primitive type is not *points*.
endif::GLSL[]
ifdef::ESSL[]
The function *EmitVertex*() specifies that a vertex is completed.
A vertex is added to the current output primitive using the current values
of all built-in and user-defined output variables.
The values of all output variables are undefined after a call to
*EmitVertex*().
If a geometry shader invocation has emitted more vertices than permitted by
the output layout qualifier *max_vertices*, the results of calling
*EmitVertex*() are undefined.

The function *EndPrimitive*() specifies that the current output primitive is
completed and a new output primitive (of the same type) will be started by
any subsequent *EmitVertex*().
This function does not emit a vertex.
If the output layout is declared to be *points*, calling *EndPrimitive*() is
optional.

A geometry shader starts with an output primitive containing no vertices.
When a geometry shader terminates, the current output primitive is
automatically completed.
It is not necessary to call *EndPrimitive*() if the geometry shader writes
only a single primitive.
endif::ESSL[]


[[fragment-processing-functions]]
== Fragment Processing Functions

Fragment processing functions are only available in fragment shaders.


[[derivative-functions]]
=== Derivative Functions

Derivatives may be computationally expensive and/or numerically unstable.
Therefore, an implementation may approximate the true derivatives
by using a fast but not entirely accurate derivative computation.
Derivatives are undefined within non-uniform control flow.

The expected behavior of a derivative is specified using forward/backward
differencing.

Forward differencing:

latexmath:[F(x+dx) - F(x) \sim dFdx(x) \cdot dx (1a)]

latexmath:[dFdx(x) \sim \frac{F(x+dx) - F(x)}{dx} (1b)]

Backward differencing:

latexmath:[F(x-dx) - F(x) \sim -dFdx(x) \cdot dx (2a)]

latexmath:[dFdx(x) \sim \frac{F(x) - F(x-dx)}{dx} (2b)]

With single-sample rasterization, latexmath:[dx \leq 1.0] in equations 1b
and 2b.
For multisample rasterization, latexmath:[dx < 2.0] in equations 1b and 2b.

latexmath:[dFdy] is approximated similarly, with _y_ replacing _x_.

ifdef::GLSL[]
With multisample rasterization, for any given fragment or sample, either
neighboring fragments or samples may be considered.

It is typical to consider a 2x2 square of fragments or samples, and compute
independent *dFdxFine* per row and independent *dFdyFine* per column, while
computing only a single *dFdxCoarse* and a single *dFdyCoarse* for the
entire 2x2 square.
Thus, all second-order coarse derivatives, e.g.
*dFdxCoarse*(*dFdxCoarse*(_x_)), may be 0, even for non-linear arguments.
However, second-order fine derivatives, e.g. *dFdxFine*(*dFdyFine*(_x_))
will properly reflect the difference between the independent fine
derivatives computed within the 2x2 square.

The method may differ per fragment, subject to the constraint that the
method may vary by window coordinates, not screen coordinates.
The invariance requirement described in section 14.2 "`Invariance`" of the
<<references,{apispec}>>, is relaxed for derivative calculations, because
the method may be a function of fragment location.

In some implementations, varying degrees of derivative accuracy for *dFdx*
and *dFdy* may be obtained by providing GL hints (see section 21.4 "`Hints`"
of the <<references,{apispec}>>), allowing a user to make an image quality
versus speed trade off.
These hints have no effect on *dFdxCoarse*, *dFdyCoarse*, *dFdxFine* and
*dFdyFine*.

[options="header"]
|====
| Syntax | Description
| genFType *dFdx*(genFType _p_)
    | Returns either *dFdxFine*(_p_) or *dFdxCoarse*(_p_), based on
      implementation choice, presumably whichever is the faster, or by whichever
      is selected in the API through quality-versus-speed hints.
| genFType *dFdy*(genFType _p_)
    | Returns either *dFdyFine*(_p_) or *dFdyCoarse*(_p_), based on
      implementation choice, presumably whichever is the faster, or by
      whichever is selected in the API through quality-versus-speed hints.
| genFType *dFdxFine*(genFType _p_)
    | Returns the partial derivative of _p_ with respect to the window x
      coordinate.
      Will use local differencing based on the value of _p_ for the current
      fragment and its immediate neighbor(s).
| genFType *dFdyFine*(genFType _p_)
    | Returns the partial derivative of _p_ with respect to the window y
      coordinate.
      Will use local differencing based on the value of _p_ for the current
      fragment and its immediate neighbor(s).
| genFType *dFdxCoarse*(genFType _p_)
    | Returns the partial derivative of _p_ with respect to the window x
      coordinate.
      Will use local differencing based on the value of _p_ for the current
      fragment's neighbors, and will possibly, but not necessarily, include
      the value of _p_ for the current fragment.
      That is, over a given area, the implementation can x compute
      derivatives in fewer unique locations than would be allowed for
      *dFdxFine*(_p_).
| genFType *dFdyCoarse*(genFType _p_)
    | Returns the partial derivative of _p_ with respect to the window y
      coordinate.
      Will use local differencing based on the value of _p_ for the current
      fragment's neighbors, and will possibly, but not necessarily, include
      the value of _p_ for the current fragment.
      That is, over a given area, the implementation can compute y
      derivatives in fewer unique locations than would be allowed for
      *dFdyFine*(_p_).
| genFType *fwidth*(genFType _p_)
    | Returns *abs*(*dFdx*(_p_)) + *abs*(*dFdy*(_p_)).
| genFType *fwidthFine*(genFType _p_)
    | Returns *abs*(*dFdxFine*(_p_)) + *abs*(*dFdyFine*(_p_)).
| genFType *fwidthCoarse*(genFType _p_)
    | Returns *abs*(*dFdxCoarse*(_p_)) + *abs*(*dFdyCoarse*(_p_)).
|====
endif::GLSL[]
ifdef::ESSL[]
An implementation may use the above or other methods to perform
the calculation, subject to the following conditions:

  . The method may use piecewise linear approximations.
    Such linear approximations imply that higher order derivatives,
    *dFdx*(*dFdx*(_x_)) and above, are undefined.
  . The method may assume that the function evaluated is continuous.
    Therefore derivatives within the body of a non-uniform conditional are
    undefined.
  . The method may differ per fragment, subject to the constraint that the
    method may vary by window coordinates, not screen coordinates.
    The invariance requirement described in section 13.2 "`Invariance`" of
    the <<references,{apispec}>>, is relaxed for derivative calculations,
    because the method may be a function of fragment location.

Other properties that are desirable, but not required, are:

  . Functions should be evaluated within the interior of a primitive
    (interpolated, not extrapolated).
  . Functions for *dFdx* should be evaluated while holding _y_ constant.
    Functions for *dFdy* should be evaluated while holding _x_ constant.
    However, mixed higher order derivatives, like *dFdx*(*dFdy*(_y_)) and
    *dFdy*(*dFdx*(_x_)) are undefined.
  . Derivatives of constant arguments should be 0.

In some implementations, varying degrees of derivative accuracy may be
obtained by providing GL hints (see section 19.1 "`Hints`" of the
<<references,{apispec}>>), allowing a user to make an image quality versus
speed trade off.

[options="header"]
|====
| Syntax | Description
| genFType *dFdx*(genFType _p_)
    | Returns the derivative in x using local differencing for the input
      argument _p_.
| genFType *dFdy*(genFType _p_)
    | Returns the derivative in y using local differencing for the input
      argument _p_. +
       +
      These two functions are commonly used to estimate the filter width used
      to anti-alias procedural textures. We are assuming that the expression
      is being evaluated in parallel on a SIMD array so that at any given
      point in time the value of the function is known at the grid points
      represented by the SIMD array. Local differencing between SIMD array
      elements can therefore be used to derive *dFdx*, *dFdy*, etc.
| genFType *fwidth*(genFType _p_)
    | Returns the sum of the absolute derivative in x and y using local
      differencing for the input argument _p_, i.e., *abs*(*dFdx*(_p_))
      + *abs*(*dFdy*(_p_));

|====
endif::ESSL[]


[[interpolation-functions]]
=== Interpolation Functions

Built-in interpolation functions are available to compute an interpolated
value of a fragment shader input variable at a shader-specified (_x_, _y_)
location.
A separate (_x_, _y_) location may be used for each invocation of the
built-in function, and those locations may differ from the default (_x_,
_y_) location used to produce the default value of the input.

For all of the interpolation functions, _interpolant_ must be an l-value
from an *in* declaration;
this can include a variable,
ifdef::GLSL[a block or structure member,]
ifdef::ESSL[an anonymous block member,]
an array element, or some combination of these.
ifdef::GLSL[]
Additionally, component selection operators (e.g. *.xy*, *.xxz*) may be applied
to _interpolant_, in which case the interpolation function will return the
result of applying the component selection operator to the interpolated value
of _interpolant_ (for example, interpolateAt(v.xxz) is defined to return
interpolateAt(v).xxz).
endif::GLSL[]
ifdef::ESSL[]
Component selection operators (e.g. *.xy*), and field selection operators may
not be used when specifying _interpolant_.
endif::ESSL[]
Arrayed inputs can be indexed with general (nonuniform) integer expressions.

If _interpolant_ is declared with the *flat* qualifier, the interpolated
value will have the same value everywhere for a single primitive, so the
location used for interpolation has no effect and the functions just return
that same value.
If _interpolant_ is declared with the *centroid* qualifier, the value
returned by *interpolateAtSample*() and *interpolateAtOffset*() will be
evaluated at the specified location, ignoring the location normally used
with the *centroid* qualifier.
ifdef::GLSL[]
If _interpolant_ is declared with the *noperspective* qualifier, the
interpolated value will be computed without perspective correction.
endif::GLSL[]

[options="header"]
|====
| Syntax | Description
| float *interpolateAtCentroid*(float _interpolant_) +
  vec2 *interpolateAtCentroid*(vec2 _interpolant_) +
  vec3 *interpolateAtCentroid*(vec3 _interpolant_) +
  vec4 *interpolateAtCentroid*(vec4 _interpolant_)
    | Returns the value of the input _interpolant_ sampled at a location
      inside both the pixel and the primitive being processed.
      The value obtained would be the same value assigned to the input
      variable if declared with the *centroid* qualifier.
| float *interpolateAtSample*(float _interpolant_, int _sample_) +
  vec2 *interpolateAtSample*(vec2 _interpolant_, int _sample_) +
  vec3 *interpolateAtSample*(vec3 _interpolant_, int _sample_) +
  vec4 *interpolateAtSample*(vec4 _interpolant_, int _sample_)
    | Returns the value of the input _interpolant_ variable at the location
      of sample number _sample_.
      If multisample buffers are not available, the input variable will be
      evaluated at the center of the pixel.
      If sample _sample_ does not exist, the position used to interpolate
      the input variable is undefined.
| float *interpolateAtOffset*(float _interpolant_, vec2 offset) +
  vec2 *interpolateAtOffset*(vec2 _interpolant_, vec2 offset) +
  vec3 *interpolateAtOffset*(vec3 _interpolant_, vec2 offset) +
  vec4 *interpolateAtOffset*(vec4 _interpolant_, vec2 offset)
    | Returns the value of the input _interpolant_ variable sampled at an
      offset from the center of the pixel specified by _offset_.
      The two floating-point components of _offset_, give the offset in
      pixels in the _x_ and _y_ directions, respectively. +
      An offset of (0, 0) identifies the center of the pixel.
      The range and granularity of offsets supported by this function is
      implementation-dependent.
|====


ifdef::GLSL[]
[[noise-functions]]
== Noise Functions

The noise functions *noise1*, *noise2*, *noise3*, and *noise4* have been
deprecated starting with version 4.4 of GLSL.
When not generating SPIR-V they are defined to return the value 0.0 or a vector
whose components are all 0.0. When generating SPIR-V the noise functions are
not declared and may not be used.

As in previous releases, the noise functions are not semantically considered to
be compile-time constant expressions.

[options="header"]
|====
| Syntax (deprecated)         | Description (deprecated)
| float *noise1*(genFType _x_) | Returns a 1D noise value based on the input value _x_.
| vec2 *noise2*(genFType _x_)  | Returns a 2D noise value based on the input value _x_.
| vec3 *noise3*(genFType _x_)  | Returns a 3D noise value based on the input value _x_.
| vec4 *noise4*(genFType _x_)  | Returns a 4D noise value based on the input value _x_.
|====
endif::GLSL[]


[[shader-invocation-control-functions]]
== Shader Invocation Control Functions

The shader invocation control function is only available in tessellation
control and compute shaders.
It is used to control the relative execution order of multiple shader
invocations used to process a patch (in the case of tessellation control
shaders) or a workgroup (in the case of compute shaders), which are
otherwise executed with an undefined relative order.

[options="header"]
|====
| Syntax | Description
| void *barrier*()
    | For any given static instance of *barrier*(), all tessellation control
      shader invocations for a single input patch must enter it before any
      will be allowed to continue beyond it, or all compute shader
      invocations for a single workgroup must enter it before any will
      continue beyond it.
|====

The function *barrier*() provides a partially defined order of execution
between shader invocations.
The ensures that, for some types of memory accesses, values written by one
invocation prior to a given static instance of *barrier*() can be safely read
by other invocations after their call to the same static instance *barrier*().
Because invocations may execute in an undefined order between these barrier
calls, the values of a per-vertex or per-patch output variable for tessellation
control shaders, or the values of *shared* variables for compute shaders will be
undefined in a number of cases enumerated in
"`<<output-variables,Output Variables>>`" (for tessellation control shaders)
and "`<<shared-variables,Shared Variables>>`" (for compute shaders).

For tessellation control shaders, the *barrier*() function may only be
placed inside the function *main*() of the shader and may not be called
within any control flow.
Barriers are also disallowed after a return statement in the function
*main*().
Any such misplaced barriers result in a compile-time error.

A *barrier*() affects control flow but only synchronizes memory accesses
to *shared* variables and tessellation control output variables.
For other memory accesses, it does not ensure that values written by one invocation
prior to a given static instance of *barrier*() can be safely read by other
invocations after their call to the same static instance of *barrier*().
To achieve this requires the use of both *barrier*() and a memory barrier.

For compute shaders, the *barrier*() function may be placed within control
flow, but that control flow must be uniform control flow.
That is, all the controlling expressions that lead to execution of the
barrier must be dynamically uniform expressions.
This ensures that if any shader invocation enters a conditional statement,
then all invocations will enter it.
While compilers are encouraged to give warnings if they can detect this
might not happen, compilers cannot completely determine this.
Hence, it is the author's responsibility to ensure *barrier*() only exists
inside uniform control flow.
Otherwise, some shader invocations will stall indefinitely, waiting for a
barrier that is never reached by other invocations.

[[shader-memory-control-functions]]
== Shader Memory Control Functions

Within a single shader invocation, the visibility and order of writes made
by that invocation are well-defined.
However, the relative order of reads and writes to a single shared memory
address from multiple separate shader invocations is largely undefined.
Additionally, the order of accesses to multiple memory addresses performed
by a single shader invocation, as observed by other shader invocations, is
also undefined.

The following built-in functions can be used to control the ordering of
reads and writes:

[options="header"]
|====
| Syntax | Description
| void *memoryBarrier*()
    | Control the ordering of memory transactions issued by a single shader
      invocation.
| void *memoryBarrierAtomicCounter*()
    | Control the ordering of accesses to atomic-counter variables issued by
      a single shader invocation.
| void *memoryBarrierBuffer*()
    | Control the ordering of memory transactions to buffer variables issued
      within a single shader invocation.
| void *memoryBarrierShared*()
    | Control the ordering of memory transactions to shared variables issued
      within a single shader invocation, as viewed by other invocations in
      the same workgroup. +
      Only available in compute shaders.
| void *memoryBarrierImage*()
    | Control the ordering of memory transactions to images issued within a
      single shader invocation.
| void *groupMemoryBarrier*()
    | Control the ordering of all memory transactions issued within a single
      shader invocation, as viewed by other invocations in the same workgroup. +
      Only available in compute shaders.
|====

The memory barrier built-in functions can be used to order reads and writes
to variables stored in memory accessible to other shader invocations.
When called, these functions will wait for the completion of all reads and
writes previously performed by the caller that access selected variable
types, and then return with no other effect.
The built-in functions *memoryBarrierAtomicCounter*(),
*memoryBarrierBuffer*(), *memoryBarrierImage*(), and *memoryBarrierShared*()
wait for the completion of accesses to atomic counter, buffer, image, and
shared variables, respectively.
The built-in functions *memoryBarrier*() and *groupMemoryBarrier*() wait for
the completion of accesses to all of the above variable types.
The functions *memoryBarrierShared*() and *groupMemoryBarrier*() are
available only in compute shaders; the other functions are available in all
shader types.

When these functions return, the effects of any memory stores performed
using coherent variables prior to the call will be visible to any
future^1^ coherent access to the same memory performed by any other shader
invocation.
In particular, the values written this way in one shader stage are
guaranteed to be visible to coherent memory accesses performed by shader
invocations in subsequent stages when those invocations were triggered by
the execution of the original shader invocation (e.g. fragment shader
invocations for a primitive resulting from a particular geometry
shader invocation).

1::
    An access is only a _future_ access if a _happens-before_ relation can
    be established between the store and the load.

Additionally, memory barrier functions order stores performed by the calling
invocation, as observed by other shader invocations.
Without memory barriers, if one shader invocation performs two stores to
coherent variables, a second shader invocation might see the values written
by the second store prior to seeing those written by the first.
However, if the first shader invocation calls a memory barrier function
between the two stores, selected other shader invocations will never see the
results of the second store before seeing those of the first.
When using the functions *groupMemoryBarrier*() or *memoryBarrierShared*(),
this ordering guarantee applies only to other shader invocations in the same
compute shader workgroup; all other memory barrier functions provide the
guarantee to all other shader invocations.
No memory barrier is required to guarantee the order of memory stores as
observed by the invocation performing the stores; an invocation reading from
a variable that it previously wrote will always see the most recently
written value unless another shader invocation also wrote to the same
memory.

== Subpass-Input Functions

Subpass-input functions are only available when targeting a Vulkan fragment stage.

Subpass inputs are read through the built-in functions below. The `g` is again
a placeholder for either nothing, `i`, or `u`, indicating either a floating-point,
signed integer, or unsigned integer, and these must match between argument type
and return type.

[options="header"]
|====
| Syntax | Description
| gvec4 *subpassLoad*(gsubpassInput subpass) +
  gvec4 *subpassLoad*(gsubpassInputMS subpass, int sample)
    | Read from a subpass input, from the implicit location _(x, y, layer)_
      of the current fragment coordinate.
|====

ifdef::GLSL[]
[[shader-invocation-group-functions]]
== Shader Invocation Group Functions

Implementations of the {slname} may optionally group multiple shader
invocations for a single shader stage into a single SIMD invocation group,
where invocations are assigned to groups in an undefined,
implementation-dependent manner.
Shader algorithms on such implementations may benefit from being able to
evaluate a composite of Boolean values over all active invocations in a
group.

[options="header"]
|====
| Syntax | Description
| bool *anyInvocation*(bool _value_)
    | Returns *true* if and only if _value_ is *true* for at least one
      active invocation in the group.
| bool *allInvocations*(bool _value_)
    | Returns *true* if and only if _value_ is *true* for all active
      invocations in the group.
| bool *allInvocationsEqual*(bool _value_)
    | Returns *true* if _value_ is the same for all active invocations in
      the group.
|====

For all of these functions, the same result is returned to all active
invocations in the group.

These functions may be called within conditionally executed code.
In groups where some invocations do not execute the function call, the value
returned by the function is not affected by any invocation not calling the
function, even when value is well-defined for that invocation.

Because these functions depend on the values of _value_ in an undefined
group of invocations, the value returned by these functions is largely
undefined.
However, *anyInvocation*() is guaranteed to return *true* if _value_ is
*true*, and *allInvocations*() is guaranteed to return *false* if _value_ is
*false*.

Because implementations are not required to combine invocations into groups,
simply returning _value_ for *anyInvocation*() and *allInvocations*() and
returning true for *allInvocationsEqual*() is a legal implementation of
these functions.

For fragment shaders, invocations in a SIMD invocation group may include
invocations corresponding to pixels that are covered by a primitive being
rasterized, as well as invocations corresponding to neighboring pixels not
covered by the primitive.
_Helper invocations_ (see "`<<built-in-language-variables, Built-In Language
Variables>>`") may be created and the value of _value_ for such
helper-invocation pixels may affect the value returned by *anyInvocation*(),
*allInvocations*(), and *allInvocationsEqual*().
endif::GLSL[]


// Copyright 2008-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0
// chapters/interfacematching.adoc
ifdef::ESSL[]
[[shader-interface-matching]]
= Shader Interface Matching
<<toc>>


As described in chapter 7 of the <<references,{apispec}>>, shaders may be
linked together to form a _program object_ before being bound to the
pipeline or may be linked and bound individually as _separable program
objects_.

[NOTE]
.Note
====
These were previously known as separate shader objects (SSOs) but the
mechanism has been extended to support future versions of the specification
that have more than two shader stages.
It allows a subset of the shaders to be linked together.
====

Within a _program object_ or a _separable program object_, qualifiers for
matching variables must themselves match according to the rules specified in
this section.
There are also matching rules for qualifiers of matching variables between
separable program objects but only for variables across an input/output
boundary between shader stages.
For other shader interface variables such as uniforms, each program object
or separable program object has its own name space and so the same name can
refer to multiple independent variables.
Consequently, there are no matching rules for qualifiers in these cases.


[[input-output-matching-by-name-in-linked-programs]]
== Input Output Matching by Name in Linked Programs

When linking shaders, the type of declared vertex outputs and fragment
inputs with the same name must match, otherwise the link command will fail.
Only those fragment inputs statically used (i.e. read) in the fragment
shader must be declared as outputs in the vertex shader; declaring
superfluous vertex shader outputs is permissible.

The following table summarizes the rules for matching shader outputs to
shader inputs in consecutive stages when shaders are linked together.

// This is very tricky to specify with multiple column and row spans

[%autowidth,cols="5"]
|====
2.2+| Treatment of Mismatched Input Variables
                               3+| Consuming Shader (input variables)
                                 | No Declaration | Declared but no Static Use | Declared and Static Use
 .3+| Generating Shader (output variables)
    | No Declaration             | Allowed        | Allowed                    | error
    | Declares; no static Use    | Allowed        | Allowed                    | Allowed (values are undefined)
    | Declares and static Use    | Allowed        | Allowed                    | Allowed (values are potentially undefined)
|====

See "`<<static-use,Static Use>>`" for the definition of _static use_.

The precision of a vertex output does not need to match the precision of the
corresponding fragment input.
The minimum precision at which vertex outputs are interpolated is the
minimum of the vertex output precision and the fragment input precision,
with the exception that for *highp*, implementations do not have to support
full IEEE 754 precision.

The precision of values exported to a transform feedback buffer is the
precision of the outputs of the vertex shader.
However, they are converted to *highp* format before being written.


[[matching-of-qualifiers]]
== Matching of Qualifiers

The following tables summarize the requirements for matching of qualifiers.
It applies whenever there are two or more matching variables in a shader
interface.

Notes:

  . _Yes_ means the qualifiers must match.
  . _No_ means the qualifiers do not need to match.
  . _Consistent_ means qualifiers may be missing from a subset of
    declarations but they cannot conflict
  . If there are conflicting qualifiers, only the last of these is
    significant.
  . Matching is based only on the resulting qualification, not on the
    presence or otherwise of qualifiers.
  . The rules apply to all declared variables, irrespective of whether they
    are statically used, with the exception of inputs and outputs when
    shaders are linked (see
    "`<<input-output-matching-by-name-in-linked-programs, Input Output
    Matching by Name in Linked Programs>>`").
  . Errors are generated for any conflicts.


[[linked-shaders]]
=== Linked Shaders

[options="header"]
|====
| Qualifier Class | Qualifier         | *in*/*out* | Default Uniforms | *uniform* Block | *buffer* Block
| Storage^1^
                  | *in* +
                    *out* +
                    *uniform*         | N/A    | N/A        | N/A | N/A
.2+| Auxiliary
                  | *centroid* +
                    *sample*          | No     | N/A        | N/A | N/A
                  | *patch*           | Yes    | N/A        | N/A | N/A
.5+| Layout
                  | *location*        | Yes^2^ | Consistent | N/A | N/A
                  | Block layout^3,4^ | N/A    | N/A        | Yes | Yes
                  | *binding*         | N/A    | Consistent | Yes | Yes
                  | *offset*          | N/A    | Yes        | N/A | N/A
                  | format            | N/A    | Yes        | N/A | N/A
| Interpolation
                  | *smooth* +
                    *flat*            | Yes    | N/A        | N/A | N/A
| Precision
                  | *lowp* +
                    *mediump* +
                    *highp*           | No     | Yes        | No  | No
| Variance
                  | *invariant* +
                    *precise*         | No     | N/A        | N/A | N/A
| Memory
                  | all               | N/A    | Yes        | Yes | Yes
|====

1::
    Storage qualifiers determine _when_ variables match rather than being
    _required_ to match for matching variables.
    Note also that each shader interface has a separate name space so for
    example, it is possible to use the same name for a vertex output and
    fragment uniform.
2::
    If present, the *location* qualifier determines the matching of inputs
    and outputs.
    See section 7.4.1 "`Shader interface Matching`" of the
    <<references,{apispec}>> for details.]
3::
    The *row_major* and *column_major* layout qualifiers do not need to
    match when applied to non-matrix types.
4::
    In cases where a layout qualifier overrides a previous layout qualifier
    or a default, only the resulting qualification must match.


[[separable-programs]]
=== Separable Programs

[options="header"]
|====
| Qualifier Class | Qualifier     | *in*/*out*
| Storage         | *in* +
                    *out* +
                    *uniform*     | N/A
.2+| Auxiliary    | *centroid* +
                    *sample*      | No
                  | *patch*       | Yes
.5+| Layout       | *location*    | Yes
                  | Block layout  | N/A
                  | *binding*     | N/A
                  | *offset*      | N/A
                  | format        | N/A
| Interpolation   | *smooth* +
                    *flat*        | Yes
| Precision       | *lowp* +
                    *mediump* +
                    *highp*       | Yes
| Variance        | *invariant* +
                    *precise*     | No
| Memory          | all           | N/A

|====
endif::ESSL[]

// Copyright 2008-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0
// chapters/grammar.adoc
[[shading-language-grammar]]
= Shading Language Grammar
<<toc>>


The grammar is fed from the output of lexical analysis.
The tokens returned from lexical analysis are

[role="bnf"]
--
[cols="1,1"]
|===
| Token Name | GLSL

| CONST  | `const`
| BOOL   | `bool`
| FLOAT  | `float`
| INT    | `int`
| UINT   | `uint`
ifdef::GLSL[| DOUBLE  | `double`]
| |
| BVEC2 | `bvec2`
| BVEC3 | `bvec3`
| BVEC4 | `bvec4`
| IVEC2 | `ivec2`
| IVEC3 | `ivec3`
| IVEC4 | `ivec4`
| UVEC2 | `uvec2`
| UVEC3 | `uvec3`
| UVEC4 | `uvec4`
| VEC2  | `vec2`
| VEC3  | `vec3`
| VEC4  | `vec4`
| |
| MAT2 | `mat2`
| MAT3 | `mat3`
| MAT4 | `mat4`
| MAT2X2 | `mat2x2`
| MAT2X3 | `mat2x3`
| MAT2X4 | `mat2x4`
| MAT3X2 | `mat3x2`
| MAT3X3 | `mat3x3`
| MAT3X4 | `mat3x4`
| MAT4X2 | `mat4x2`
| MAT4X3 | `mat4x3`
| MAT4X4 | `mat4x4`
| |
ifdef::GLSL[]
| DVEC2 | `dvec2`
| DVEC3 | `dvec3`
| DVEC4 | `dvec4`
| DMAT2 | `dmat2`
| DMAT3 | `dmat3`
| DMAT4 | `dmat4`
| DMAT2X2 | `dmat2x2`
| DMAT2X3 | `dmat2x3`
| DMAT2X4 | `dmat2x4`
| DMAT3X2 | `dmat3x2`
| DMAT3X3 | `dmat3x3`
| DMAT3X4 | `dmat3x4`
| DMAT4X2 | `dmat4x2`
| DMAT4X3 | `dmat4x3`
| DMAT4X4 | `dmat4x4`
endif::GLSL[]
| |
| CENTROID | `centroid`
| IN | `in`
| OUT | `out`
| INOUT | `inout`
| UNIFORM | `uniform`
| PATCH | `patch`
| SAMPLE | `sample`
| BUFFER | `buffer`
| SHARED | `shared`
| COHERENT | `coherent`
| VOLATILE | `volatile`
| RESTRICT | `restrict`
| READONLY | `readonly`
| WRITEONLY | `writeonly`
ifdef::GLSL[| NOPERSPECTIVE | `noperspective` ]
| FLAT | `flat`
| SMOOTH | `smooth`
| LAYOUT | `layout`
| |
| ATOMIC_UINT | `atomic_uint`
| |
| SAMPLER2D | `sampler2D`
| SAMPLER3D | `sampler3D`
| SAMPLERCUBE | `samplerCube`
| SAMPLER2DSHADOW | `sampler2DShadow`
| SAMPLERCUBESHADOW | `samplerCubeShadow`
| SAMPLER2DARRAY | `sampler2DArray`
| SAMPLER2DARRAYSHADOW | `sampler2DArrayShadow`
| ISAMPLER2D | `isampler2D`
| ISAMPLER3D | `isampler3D`
| ISAMPLERCUBE | `isamplerCube`
| ISAMPLER2DARRAY | `isampler2DArray`
| USAMPLER2D | `usampler2D`
| USAMPLER3D | `usampler3D`
| USAMPLERCUBE | `usamplerCube`
| USAMPLER2DARRAY | `usampler2DArray`
| |
ifdef::GLSL[]
| SAMPLER1D | `sampler1D`
| SAMPLER1DSHADOW | `sampler1DShadow`
| SAMPLER1DARRAY | `sampler1DArray`
| SAMPLER1DARRAYSHADOW | `sampler1DArrayShadow`
| ISAMPLER1D | `isampler1D`
| ISAMPLER1DARRAY | `isampler1DArray`
| USAMPLER1D | `usampler1D`
| USAMPLER1DARRAY | `usampler1DArray`
| SAMPLER2DRECT | `sampler2DRect`
| SAMPLER2DRECTSHADOW | `sampler2DRectShadow`
| ISAMPLER2DRECT | `isampler2DRect`
| USAMPLER2DRECT | `usampler2DRect`
endif::GLSL[]
| |
| SAMPLERBUFFER | `samplerBuffer`
| ISAMPLERBUFFER | `isamplerBuffer`
| USAMPLERBUFFER | `usamplerBuffer`
| SAMPLERCUBEARRAY | `samplerCubeArray`
| SAMPLERCUBEARRAYSHADOW | `samplerCubeArrayShadow`
| ISAMPLERCUBEARRAY | `isamplerCubeArray`
| USAMPLERCUBEARRAY | `usamplerCubeArray`
| SAMPLER2DMS | `sampler2DMS`
| ISAMPLER2DMS | `isampler2DMS`
| USAMPLER2DMS | `usampler2DMS`
| SAMPLER2DMSARRAY | `sampler2DMSArray`
| ISAMPLER2DMSARRAY | `isampler2DMSArray`
| USAMPLER2DMSARRAY | `usampler2DMSArray`
| IMAGE2D | `image2D`
| IIMAGE2D | `iimage2D`
| UIMAGE2D | `uimage2D`
| IMAGE3D | `image3D`
| IIMAGE3D | `iimage3D`
| UIMAGE3D | `uimage3D`
| IMAGECUBE | `imageCube`
| IIMAGECUBE | `iimageCube`
| UIMAGECUBE | `uimageCube`
| IMAGEBUFFER | `imageBuffer`
| IIMAGEBUFFER | `iimageBuffer`
| UIMAGEBUFFER | `uimageBuffer`
| IMAGE2DARRAY | `image2DArray`
| IIMAGE2DARRAY | `iimage2DArray`
| UIMAGE2DARRAY | `uimage2DArray`
| IMAGECUBEARRAY | `imageCubeArray`
| IIMAGECUBEARRAY | `iimageCubeArray`
| UIMAGECUBEARRAY | `uimageCubeArray`
| |
ifdef::GLSL[]
| IMAGE1D | `image1D`
| IIMAGE1D | `iimage1D`
| UIMAGE1D | `uimage1D`
| IMAGE1DARRAY | `image1DArray`
| IIMAGE1DARRAY | `iimage1DArray`
| UIMAGE1DARRAY | `uimage1DArray`
| IMAGE2DRECT | `image2DRect`
| IIMAGE2DRECT | `iimage2DRect`
| UIMAGE2DRECT | `uimage2DRect`
| IMAGE2DMS | `image2DMS`
| IIMAGE2DMS | `iimage2DMS`
| UIMAGE2DMS | `uimage2DMS`
| IMAGE2DMSARRAY | `image2DMSArray`
| IIMAGE2DMSARRAY | `iimage2DMSArray`
| UIMAGE2DMSARRAY | `uimage2DMSArray`
endif::GLSL[]
| |
| STRUCT | `struct`
| VOID | `void`
| |
| WHILE | `while`
| BREAK | `break`
| CONTINUE | `continue`
| DO | `do`
| ELSE | `else`
| FOR | `for`
| IF | `if`
| DISCARD | `discard`
| RETURN | `return`
| SWITCH | `switch`
| CASE | `case`
| DEFAULT | `default`
ifdef::GLSL[| SUBROUTINE | `subroutine` ]
| |
| IDENTIFIER | <<identifiers>>
| TYPE_NAME | <<identifiers>>
| FLOATCONSTANT | <<floats>>
| INTCONSTANT | <<integers>>
| UINTCONSTANT | <<integers>>
| BOOLCONSTANT | <<booleans>>
ifdef::GLSL[| DOUBLECONSTANT | <<floats>> ]
| FIELD_SELECTION | <<identifiers>>
| |
| LEFT_OP | `<<`
| RIGHT_OP | `>>`
| INC_OP | `++`
| DEC_OP | `--`
| LE_OP | `\<=`
| GE_OP | `>=`
| EQ_OP | `==`
| NE_OP | `!=`
| AND_OP | `&&`
| OR_OP | `\|\|`
| XOR_OP | `^^`
| MUL_ASSIGN | `*=`
| DIV_ASSIGN | `/=`
| ADD_ASSIGN | `+=`
| MOD_ASSIGN | `%=`
| LEFT_ASSIGN | `<\<=`
| RIGHT_ASSIGN | `>>=`
| AND_ASSIGN | `&=`
| XOR_ASSIGN | `^=`
| OR_ASSIGN | `\|=`
| SUB_ASSIGN | `-=`
| LEFT_PAREN | `(`
| RIGHT_PAREN | `)`
| LEFT_BRACKET | `[`
| RIGHT_BRACKET | `]`
| LEFT_BRACE | `{`
| RIGHT_BRACE | `}`
| DOT | `.`
| COMMA | `,`
| COLON | `:`
| EQUAL | `=`
| SEMICOLON | `;`
| BANG | `!`
| DASH | `-`
| TILDE | `~`
| PLUS | `+`
| STAR | `*`
| SLASH | `/`
| PERCENT | `%`
| LEFT_ANGLE | `<`
| RIGHT_ANGLE | `>`
| VERTICAL_BAR | `\|`
| CARET | `^`
| AMPERSAND | `&`
| QUESTION | `?`
| |
| INVARIANT | `invariant`
| PRECISE | `precise`
| HIGH_PRECISION | `highp`
| MEDIUM_PRECISION | `mediump`
| LOW_PRECISION | `lowp`
| PRECISION | `precision`
|===
--

The following describes the grammar for the {slname} in terms of the above
tokens.
The starting rule is _translation_unit_.
ifdef::GLSL[]
An empty shader (one having no tokens to parse, after pre-processing) is
valid, resulting in no compile-time errors, even though the grammar below
does not have a rule to accept an empty token stream.
endif::GLSL[]

[role="bnf"]
--
_variable_identifier_ : ::
    _IDENTIFIER_

_primary_expression_ : ::
    _variable_identifier_ +
    _INTCONSTANT_ +
    _UINTCONSTANT_ +
    _FLOATCONSTANT_ +
    _BOOLCONSTANT_ +
ifdef::GLSL[]
    _DOUBLECONSTANT_ +
endif::GLSL[]
    _LEFT_PAREN_ _expression_ _RIGHT_PAREN_

_postfix_expression_ : ::
    _primary_expression_ +
    _postfix_expression_ _LEFT_BRACKET_ _integer_expression_ _RIGHT_BRACKET_ +
    _function_call_ +
    _postfix_expression_ _DOT_ _FIELD_SELECTION_ +
    _postfix_expression_ _INC_OP_ +
    _postfix_expression_ _DEC_OP_

[NOTE]
====
FIELD_SELECTION includes members in structures, component selection for
vectors and the 'length' identifier for the length() method
====

_integer_expression_ : ::
    _expression_

_function_call_ : ::
    _function_call_or_method_

_function_call_or_method_ : ::
    _function_call_generic_

_function_call_generic_ : ::
    _function_call_header_with_parameters_ _RIGHT_PAREN_ +
    _function_call_header_no_parameters_ _RIGHT_PAREN_

_function_call_header_no_parameters_ : ::
    _function_call_header_ _VOID_ +
    _function_call_header_

_function_call_header_with_parameters_ : ::
    _function_call_header_ _assignment_expression_ +
    _function_call_header_with_parameters_ _COMMA_ _assignment_expression_

_function_call_header_ : ::
    _function_identifier_ _LEFT_PAREN_

[NOTE]
====
Grammar Note: Constructors look like functions, but lexical analysis
recognized most of them as keywords.
They are now recognized through _type_specifier_.
====

[NOTE]
====
ifdef::GLSL[]
Methods (*.length*), subroutine array calls, and identifiers are recognized
through _postfix_expression_.
endif::GLSL[]
ifdef::ESSL[]
Methods (*.length*) and identifiers are recognized through
_postfix_expression_.
endif::ESSL[]
====

_function_identifier_ : ::
    _type_specifier_ +
    _postfix_expression_

_unary_expression_ : ::
    _postfix_expression_ +
    _INC_OP_ _unary_expression_ +
    _DEC_OP_ _unary_expression_ +
    _unary_operator_ _unary_expression_

[NOTE]
====
Grammar Note: No traditional style type casts.
====

_unary_operator_ : ::
    _PLUS_ +
    _DASH_ +
    _BANG_ +
    _TILDE_

[NOTE]
====
Grammar Note: No '*' or '&' unary ops.
Pointers are not supported.
====

_multiplicative_expression_ : ::
    _unary_expression_ +
    _multiplicative_expression_ _STAR_ _unary_expression_ +
    _multiplicative_expression_ _SLASH_ _unary_expression_ +
    _multiplicative_expression_ _PERCENT_ _unary_expression_

_additive_expression_ : ::
    _multiplicative_expression_ +
    _additive_expression_ _PLUS_ _multiplicative_expression_ +
    _additive_expression_ _DASH_ _multiplicative_expression_

_shift_expression_ : ::
    _additive_expression_ +
    _shift_expression_ _LEFT_OP_ _additive_expression_ +
    _shift_expression_ _RIGHT_OP_ _additive_expression_

_relational_expression_ : ::
    _shift_expression_ +
    _relational_expression_ _LEFT_ANGLE_ _shift_expression_ +
    _relational_expression_ _RIGHT_ANGLE_ _shift_expression_ +
    _relational_expression_ _LE_OP_ _shift_expression_ +
    _relational_expression_ _GE_OP_ _shift_expression_

_equality_expression_ : ::
    _relational_expression_ +
    _equality_expression_ _EQ_OP_ _relational_expression_ +
    _equality_expression_ _NE_OP_ _relational_expression_

_and_expression_ : ::
    _equality_expression_ +
    _and_expression_ _AMPERSAND_ _equality_expression_

_exclusive_or_expression_ : ::
    _and_expression_ +
    _exclusive_or_expression_ _CARET_ _and_expression_

_inclusive_or_expression_ : ::
    _exclusive_or_expression_ +
    _inclusive_or_expression_ _VERTICAL_BAR_ _exclusive_or_expression_

_logical_and_expression_ : ::
    _inclusive_or_expression_ +
    _logical_and_expression_ _AND_OP_ _inclusive_or_expression_

_logical_xor_expression_ : ::
    _logical_and_expression_ +
    _logical_xor_expression_ _XOR_OP_ _logical_and_expression_

_logical_or_expression_ : ::
    _logical_xor_expression_ +
    _logical_or_expression_ _OR_OP_ _logical_xor_expression_

_conditional_expression_ : ::
    _logical_or_expression_ +
    _logical_or_expression_ _QUESTION_ _expression_ _COLON_
    _assignment_expression_

_assignment_expression_ : ::
    _conditional_expression_ +
    _unary_expression_ _assignment_operator_ _assignment_expression_

_assignment_operator_ : ::
    _EQUAL_ +
    _MUL_ASSIGN_ +
    _DIV_ASSIGN_ +
    _MOD_ASSIGN_ +
    _ADD_ASSIGN_ +
    _SUB_ASSIGN_ +
    _LEFT_ASSIGN_ +
    _RIGHT_ASSIGN_ +
    _AND_ASSIGN_ +
    _XOR_ASSIGN_ +
    _OR_ASSIGN_

_expression_ : ::
    _assignment_expression_ +
    _expression_ _COMMA_ _assignment_expression_

_constant_expression_ : ::
    _conditional_expression_

_declaration_ : ::
    _function_prototype_ _SEMICOLON_ +
    _init_declarator_list_ _SEMICOLON_ +
    _PRECISION_ _precision_qualifier_ _type_specifier_ _SEMICOLON_ +
    _type_qualifier_ _IDENTIFIER_ _LEFT_BRACE_ _struct_declaration_list_
    _RIGHT_BRACE_ _SEMICOLON_ +
    _type_qualifier_ _IDENTIFIER_ _LEFT_BRACE_ _struct_declaration_list_
    _RIGHT_BRACE_ _IDENTIFIER_ _SEMICOLON_ +
    _type_qualifier_ _IDENTIFIER_ _LEFT_BRACE_ _struct_declaration_list_
    _RIGHT_BRACE_ _IDENTIFIER_ _array_specifier_ _SEMICOLON_ +
    _type_qualifier_ _SEMICOLON_ +
    _type_qualifier_ _identifier_list_ _SEMICOLON_

_identifier_list_ : ::
    _IDENTIFIER_ +
    _identifier_list_ _COMMA_ _IDENTIFIER_

_function_prototype_ : ::
    _function_declarator_ _RIGHT_PAREN_

_function_declarator_ : ::
    _function_header_ +
    _function_header_with_parameters_

_function_header_with_parameters_ : ::
    _function_header_ _parameter_declaration_ +
    _function_header_with_parameters_ _COMMA_ _parameter_declaration_

_function_header_ : ::
    _fully_specified_type_ _IDENTIFIER_ _LEFT_PAREN_

_parameter_declarator_ : ::
    _type_specifier_ _IDENTIFIER_ +
    _type_specifier_ _IDENTIFIER_ _array_specifier_

_parameter_declaration_ : ::
    _type_qualifier_ _parameter_declarator_ +
    _parameter_declarator_ +
    _type_qualifier_ _parameter_type_specifier_ +
    _parameter_type_specifier_

_parameter_type_specifier_ : ::
    _type_specifier_

_init_declarator_list_ : ::
    _single_declaration_ +
    _init_declarator_list_ _COMMA_ _IDENTIFIER_ +
    _init_declarator_list_ _COMMA_ _IDENTIFIER_ _array_specifier_ +
    _init_declarator_list_ _COMMA_ _IDENTIFIER_ _array_specifier_ _EQUAL_
    _initializer_ +
    _init_declarator_list_ _COMMA_ _IDENTIFIER_ _EQUAL_ _initializer_

_single_declaration_ : ::
    _fully_specified_type_ +
    _fully_specified_type_ _IDENTIFIER_ +
    _fully_specified_type_ _IDENTIFIER_ _array_specifier_ +
    _fully_specified_type_ _IDENTIFIER_ _array_specifier_ _EQUAL_
    _initializer_ +
    _fully_specified_type_ _IDENTIFIER_ _EQUAL_ _initializer_

[NOTE]
====
Grammar Note: No 'enum', or 'typedef'.
====

_fully_specified_type_ : ::
    _type_specifier_ +
    _type_qualifier_ _type_specifier_

_invariant_qualifier_ : ::
    _INVARIANT_

_interpolation_qualifier_ : ::
    _SMOOTH_ +
ifdef::GLSL[]
    _FLAT_ +
    _NOPERSPECTIVE_
endif::GLSL[]
ifdef::ESSL[]
    _FLAT_
endif::ESSL[]

_layout_qualifier_ : ::
    _LAYOUT_ _LEFT_PAREN_ _layout_qualifier_id_list_ _RIGHT_PAREN_

_layout_qualifier_id_list_ : ::
    _layout_qualifier_id_ +
    _layout_qualifier_id_list_ _COMMA_ _layout_qualifier_id_

_layout_qualifier_id_ : ::
    _IDENTIFIER_ +
ifdef::GLSL[]
    _IDENTIFIER_ _EQUAL_ _constant_expression_ +
endif::GLSL[]
ifdef::ESSL[]
    _IDENTIFIER_ _EQUAL_ _INTCONSTANT_ +
    _IDENTIFIER_ _EQUAL_ _UINTCONSTANT_ +
endif::ESSL[]
    _SHARED_

_precise_qualifier_ : ::
    _PRECISE_

_type_qualifier_ : ::
    _single_type_qualifier_ +
    _type_qualifier_ _single_type_qualifier_

_single_type_qualifier_ : ::
    _storage_qualifier_ +
    _layout_qualifier_ +
    _precision_qualifier_ +
    _interpolation_qualifier_ +
    _invariant_qualifier_ +
    _precise_qualifier_

_storage_qualifier_ : ::
    _CONST_ +
    _IN_ +
    _OUT_ +
    _INOUT_ +
    _CENTROID_ +
    _PATCH_ +
    _SAMPLE_ +
    _UNIFORM_ +
    _BUFFER_ +
    _SHARED_ +
    _COHERENT_ +
    _VOLATILE_ +
    _RESTRICT_ +
    _READONLY_ +
ifdef::ESSL[]
    _WRITEONLY_
endif::ESSL[]
ifdef::GLSL[]
    _WRITEONLY_ +
    _SUBROUTINE_ +
    _SUBROUTINE_ _LEFT_PAREN_ _type_name_list_ _RIGHT_PAREN_

_type_name_list_ : ::
    _TYPE_NAME_ +
    _type_name_list_ _COMMA_ _TYPE_NAME_
endif::GLSL[]

_type_specifier_ : ::
    _type_specifier_nonarray_ +
    _type_specifier_nonarray_ _array_specifier_

[[array_specifier]]
_array_specifier_ : ::
    _LEFT_BRACKET_ _RIGHT_BRACKET_ +
    _LEFT_BRACKET_ _conditional_expression_ _RIGHT_BRACKET_ +
    _array_specifier_ _LEFT_BRACKET_ _RIGHT_BRACKET_ +
    _array_specifier_ _LEFT_BRACKET_ _conditional_expression_ _RIGHT_BRACKET_

[[type_specifier_nonarray]]
_type_specifier_nonarray_ : ::
    _VOID_ +
    _FLOAT_ +
ifdef::GLSL[]
    _DOUBLE_ +
endif::GLSL[]
    _INT_ +
    _UINT_ +
    _BOOL_ +
    _VEC2_ +
    _VEC3_ +
    _VEC4_ +
ifdef::GLSL[]
    _DVEC2_ +
    _DVEC3_ +
    _DVEC4_ +
endif::GLSL[]
    _BVEC2_ +
    _BVEC3_ +
    _BVEC4_ +
    _IVEC2_ +
    _IVEC3_ +
    _IVEC4_ +
    _UVEC2_ +
    _UVEC3_ +
    _UVEC4_ +
    _MAT2_ +
    _MAT3_ +
    _MAT4_ +
    _MAT2X2_ +
    _MAT2X3_ +
    _MAT2X4_ +
    _MAT3X2_ +
    _MAT3X3_ +
    _MAT3X4_ +
    _MAT4X2_ +
    _MAT4X3_ +
    _MAT4X4_ +
ifdef::GLSL[]
    _DMAT2_ +
    _DMAT3_ +
    _DMAT4_ +
    _DMAT2X2_ +
    _DMAT2X3_ +
    _DMAT2X4_ +
    _DMAT3X2_ +
    _DMAT3X3_ +
    _DMAT3X4_ +
    _DMAT4X2_ +
    _DMAT4X3_ +
    _DMAT4X4_ +
endif::GLSL[]
    _ATOMIC_UINT_ +
    _SAMPLER2D_ +
    _SAMPLER3D_ +
    _SAMPLERCUBE_ +
    _SAMPLER2DSHADOW_ +
    _SAMPLERCUBESHADOW_ +
    _SAMPLER2DARRAY_ +
    _SAMPLER2DARRAYSHADOW_ +
    _SAMPLERCUBEARRAY_ +
    _SAMPLERCUBEARRAYSHADOW_ +
    _ISAMPLER2D_ +
    _ISAMPLER3D_ +
    _ISAMPLERCUBE_ +
    _ISAMPLER2DARRAY_ +
    _ISAMPLERCUBEARRAY_ +
    _USAMPLER2D_ +
    _USAMPLER3D_ +
    _USAMPLERCUBE_ +
    _USAMPLER2DARRAY_ +
    _USAMPLERCUBEARRAY_ +
ifdef::GLSL[]
    _SAMPLER1D_ +
    _SAMPLER1DSHADOW_ +
    _SAMPLER1DARRAY_ +
    _SAMPLER1DARRAYSHADOW_ +
    _ISAMPLER1D_ +
    _ISAMPLER1DARRAY_ +
    _USAMPLER1D_ +
    _USAMPLER1DARRAY_ +
    _SAMPLER2DRECT_ +
    _SAMPLER2DRECTSHADOW_ +
    _ISAMPLER2DRECT_ +
    _USAMPLER2DRECT_ +
endif::GLSL[]
    _SAMPLERBUFFER_ +
    _ISAMPLERBUFFER_ +
    _USAMPLERBUFFER_ +
    _SAMPLER2DMS_ +
    _ISAMPLER2DMS_ +
    _USAMPLER2DMS_ +
    _SAMPLER2DMSARRAY_ +
    _ISAMPLER2DMSARRAY_ +
    _USAMPLER2DMSARRAY_ +
    _IMAGE2D_ +
    _IIMAGE2D_ +
    _UIMAGE2D_ +
    _IMAGE3D_ +
    _IIMAGE3D_ +
    _UIMAGE3D_ +
    _IMAGECUBE_ +
    _IIMAGECUBE_ +
    _UIMAGECUBE_ +
    _IMAGEBUFFER_ +
    _IIMAGEBUFFER_ +
    _UIMAGEBUFFER_ +
ifdef::GLSL[]
    _IMAGE1D_ +
    _IIMAGE1D_ +
    _UIMAGE1D_ +
    _IMAGE1DARRAY_ +
    _IIMAGE1DARRAY_ +
    _UIMAGE1DARRAY_ +
    _IMAGE2DRECT_ +
    _IIMAGE2DRECT_ +
    _UIMAGE2DRECT_ +
endif::GLSL[]
    _IMAGE2DARRAY_ +
    _IIMAGE2DARRAY_ +
    _UIMAGE2DARRAY_ +
    _IMAGECUBEARRAY_ +
    _IIMAGECUBEARRAY_ +
    _UIMAGECUBEARRAY_ +
ifdef::GLSL[]
    _IMAGE2DMS_ +
    _IIMAGE2DMS_ +
    _UIMAGE2DMS_ +
    _IMAGE2DMSARRAY_ +
    _IIMAGE2DMSARRAY_ +
    _UIMAGE2DMSARRAY_ +
endif::GLSL[]
    _struct_specifier_ +
    _TYPE_NAME_

_precision_qualifier_ : ::
    _HIGH_PRECISION_ +
    _MEDIUM_PRECISION_ +
    _LOW_PRECISION_

_struct_specifier_ : ::
    _STRUCT_ _IDENTIFIER_ _LEFT_BRACE_ _struct_declaration_list_
    _RIGHT_BRACE_ +
    _STRUCT_ _LEFT_BRACE_ _struct_declaration_list_ _RIGHT_BRACE_

_struct_declaration_list_ : ::
    _struct_declaration_ +
    _struct_declaration_list_ _struct_declaration_

_struct_declaration_ : ::
    _type_specifier_ _struct_declarator_list_ _SEMICOLON_ +
    _type_qualifier_ _type_specifier_ _struct_declarator_list_ _SEMICOLON_

_struct_declarator_list_ : ::
    _struct_declarator_ +
    _struct_declarator_list_ _COMMA_ _struct_declarator_

_struct_declarator_ : ::
    _IDENTIFIER_ +
    _IDENTIFIER_ _array_specifier_

_initializer_ : ::
ifdef::GLSL[]
    _assignment_expression_ +
    _LEFT_BRACE_ _initializer_list_ _RIGHT_BRACE_ +
    _LEFT_BRACE_ _initializer_list_ _COMMA_ _RIGHT_BRACE_

_initializer_list_ : ::
    _initializer_ +
    _initializer_list_ _COMMA_ _initializer_
endif::GLSL[]
ifdef::ESSL[]
    _assignment_expression_
endif::ESSL[]

_declaration_statement_ : ::
    _declaration_

_statement_ : ::
    _compound_statement_ +
    _simple_statement_

[NOTE]
====
Grammar Note: labeled statements for SWITCH only; 'goto' is not supported.
====

_simple_statement_ : ::
    _declaration_statement_ +
    _expression_statement_ +
    _selection_statement_ +
    _switch_statement_ +
    _case_label_ +
    _iteration_statement_ +
    _jump_statement_

_compound_statement_ : ::
    _LEFT_BRACE_ _RIGHT_BRACE_ +
    _LEFT_BRACE_ _statement_list_ _RIGHT_BRACE_

_statement_no_new_scope_ : ::
    _compound_statement_no_new_scope_ +
    _simple_statement_

_compound_statement_no_new_scope_ : ::
    _LEFT_BRACE_ _RIGHT_BRACE_ +
    _LEFT_BRACE_ _statement_list_ _RIGHT_BRACE_

_statement_list_ : ::
    _statement_ +
    _statement_list_ _statement_

_expression_statement_ : ::
    _SEMICOLON_ +
    _expression_ _SEMICOLON_

_selection_statement_ : ::
    _IF_ _LEFT_PAREN_ _expression_ _RIGHT_PAREN_ _selection_rest_statement_

_selection_rest_statement_ : ::
    _statement_ _ELSE_ _statement_ +
    _statement_

_condition_ : ::
    _expression_ +
    _fully_specified_type_ _IDENTIFIER_ _EQUAL_ _initializer_

_switch_statement_ : ::
    _SWITCH_ _LEFT_PAREN_ _expression_ _RIGHT_PAREN_ _LEFT_BRACE_
    _switch_statement_list_ +
    _RIGHT_BRACE_

_switch_statement_list_ : ::
    /* _empty_ */ +
    _statement_list_

_case_label_ : ::
    _CASE_ _expression_ _COLON_ +
    _DEFAULT_ _COLON_

_iteration_statement_ : ::
    _WHILE_ _LEFT_PAREN_ _condition_ _RIGHT_PAREN_ _statement_no_new_scope_ +
    _DO_ _statement_ _WHILE_ _LEFT_PAREN_ _expression_ _RIGHT_PAREN_
    _SEMICOLON_ +
    _FOR_ _LEFT_PAREN_ _for_init_statement_ _for_rest_statement_
    _RIGHT_PAREN_ _statement_no_new_scope_

_for_init_statement_ : ::
    _expression_statement_ +
    _declaration_statement_

_conditionopt_ : ::
    /* _empty_ */ +
    _condition_

_for_rest_statement_ : ::
    _conditionopt_ _SEMICOLON_ +
    _conditionopt_ _SEMICOLON_ _expression_

_jump_statement_ : ::
    _CONTINUE_ _SEMICOLON_ +
    _BREAK_ _SEMICOLON_ +
    _RETURN_ _SEMICOLON_ +
    _RETURN_ _expression_ _SEMICOLON_ +
    _DISCARD_ _SEMICOLON_ // Fragment shader only.

[NOTE]
====
Grammar Note: No 'goto'.
Gotos are not supported.
====

_translation_unit_ : ::
    _external_declaration_ +
    _translation_unit_ _external_declaration_

_external_declaration_ : ::
    _function_definition_ +
ifdef::GLSL[]
    _declaration_ +
    _SEMICOLON_
endif::GLSL[]
ifdef::ESSL[]
    _declaration_
endif::ESSL[]

_function_definition_ : ::
    _function_prototype_ _compound_statement_no_new_scope_

--

In general the above grammar describes a super set of the {slname}.
Certain constructs that are valid purely in terms of the grammar are
disallowed by statements elsewhere in this specification.

// Copyright 2008-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0
// chapters/iocounting.adoc
ifdef::ESSL[]
[[counting-of-inputs-and-outputs]]
= Counting of Inputs and Outputs
<<toc>>


This section applies to outputs from the last active vertex processing stage
and inputs to the fragment stage.
GLSL ES {minor} specifies the storage available for such variables in terms of
an array of 4-vectors.
The assumption is that variables will be packed into these arrays without
wasting space.
This places significant burden on implementations since optimal packing is
computationally intensive.
Implementations may have more internal resources than exposed to the
application and so avoid the need to perform packing but this is also
considered an expensive solution.

GLSL ES {minor} therefore relaxes the requirements for packing by
specifying a simpler algorithm that may be used.
This algorithm specifies a minimum requirement for when a set of variables
must be supported by an implementation.
The implementation is allowed to support more than the minimum and so may
use a more efficient algorithm and/or may support more registers than the
virtual target machine.

Outputs from the last active vertex stage and inputs to the fragment stage are
counted separately.
If statically used in the fragment shader, the built-in special variables
(_gl_FragCoord_, _gl_FrontFacing_ and _gl_PointCoord_) are included when
calculating the storage requirements of fragment inputs.

If the last active vertex-pipeline shader and fragment shader are linked
together, inputs and outputs are only counted if they are statically used
within the shader.
If the shaders are each compiled into a separable program, all declared inputs
and outputs are counted.

[NOTE]
.Note
====
GLSL ES {minor} does not require the implementation to remove
outputs which are not statically used in the fragment shader.
====

For the algorithm used, failing resource allocation for a variable must
result in an error.

The resource allocation of variables must succeed for all cases where the
following packing algorithm succeeds:

  * The target architecture consists of a grid of registers, 16 rows by 4
    columns.
    Each register can contain a scalar value, i.e. a float, int or uint.
  * Variables with an explicit location are allocated first.
    When attempting to allocate a location for other variables, if there is
    a conflict, the search moves to the next available free location.
  * Structures are assumed to be flattened.
    Each data member is treated as if it were at global scope.
  * Variables are packed into the registers one at a time so that they each
    occupy a contiguous sub-rectangle.
    No splitting of variables is permitted.
  * The orientation of variables is fixed.
    Vectors always occupy registers in a single row.
    Elements of an array must be in different rows.
    E.g. *vec4* will always occupy one row; float[16] will occupy one
    column.
    Since it is not permitted to split a variable, large arrays e.g.
    float[32] will always fail with this algorithm.
  * Non-square matrices of type *matCxR* consume the same space as a square
    matrix of type *matN* where N is the greater of C and R.
    Variables of type *mat2* occupies 2 complete rows.
    These rules allow implementations more flexibility in how variables are
    stored.
    + Other variables consume only the minimum space required.
  * Arrays of size N are assumed to take N times the size of the base type.
  * Variables are packed in the following order:
  . *mat4* and arrays of *mat4*.
  . *mat2* and arrays of *mat2* (since they occupy full rows)
  . *vec4* and arrays of *vec4*
  . *mat3* and arrays of *mat3*
  . *vec3* and arrays of *vec3*
  . *vec2* and arrays of *vec2*
  . Scalar types and arrays of scalar types
  * For each of the above types, the arrays are processed in order of size,
    largest first.
    Arrays of size 1 and the base type are considered equivalent.
    The first type to be packed will be mat4[4], mat4[3], mat[2] followed by
    mat4, mat2[4]...mat2[2], mat2, vec4[8], vec4[7],...vec4[1], vec4,
    mat3[2], mat3 and so on.
    The last variables to be packed will be float (and float[1]).
  * For 2,3 and 4 component variables packing is started using the 1^st^
    column of the 1^st^ row.
    Variables are then allocated to successive rows, aligning them to the
    1^st^ column.
  * For 2 component variables, when there are no spare rows, the strategy is
    switched to using the highest numbered row and the lowest numbered
    column where the variable will fit.
    (In practice, this means they will be aligned to the x or z component.)
    Packing of any further 3 or 4 component variables will fail at this
    point.
  * 1 component variables (e.g. floats and arrays of floats) have their own
    packing rule.
    They are packed in order of size, largest first.
    Each variable is placed in the column that leaves the least amount of
    space in the column and aligned to the lowest available rows within that
    column.
    During this phase of packing, space will be available in up to 4
    columns.
    The space within each column is always contiguous in the case where no
    variables have explicit locations.
  * For each type, variables with the 'smooth' property are packed first,
    followed by variables with the 'flat' property.
  * Each row can contain either values with the 'smooth' property or the
    'flat' property but not both.
    If this situation is encountered during allocation, the algorithm skips
    the component location and continues with the next available location.
    These skipped locations may be used for other values later in the
    allocation process.
  * There is no backtracking.
    Once a value is assigned a location, it cannot be changed, even if such
    a change is required for a successful allocation.

Example: pack the following types:

[source,glsl]
----
out vec4 a;     // top left
out mat3 b;     // align to left, lowest numbered rows
out mat2x3 c;   // same size as mat3, align to left
out vec2 d[6];  // align to left, lowest numbered rows
out vec2 e[4];  // Cannot align to left so align to z column, highest
                // numbered rows
out vec2 f;     // Align to left, lowest numbered rows.
out float g[3]  // Column with minimum space
out float h[2]; // Column with minimum space (choice of 3, any
                // can be used)
out float i;    // Column with minimum space
----

In this example, the variables happen to be listed in the order in which
they are packed.
Packing is independent of the order of declaration.

[cols="",]
|====
|    | *x* | *y* | *z* | *w*
| 0  | *a* | *a* | *a* | *a*
| 1  | *b* | *b* | *b* |
| 2  | *b* | *b* | *b* |
| 3  | *b* | *b* | *b* |
| 4  | *c* | *c* | *c* |
| 5  | *c* | *c* | *c* |
| 6  | *c* | *c* | *c* |
| 7  | *d* | *d* | *g* |
| 8  | *d* | *d* | *g* |
| 9  | *d* | *d* | *g* |
| 10 | *d* | *d* |     |
| 11 | *d* | *d* |     |
| 12 | *d* | *d* | *e* | *e*
| 13 | *f* | *f* | *e* | *e*
| 14 | *h* | *i* | *e* | *e*
| 15 | *h* |     | *e* | *e*
|====

Some types e.g. mat4[8] will be too large to fit.
These always fail with this algorithm.
endif::ESSL[]


// Copyright 2008-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0
// chapters/acknowledgements.adoc
[[acknowledgements]]
= Acknowledgments
<<toc>>

This specification is based on the work of those who contributed to past
versions of the Open GL and Open GL ES Language Specifications and the
following contributors to this version:

ifdef::editing-notes[]
[NOTE]
.editing-note
====
(Jon) Would like to make multicolumnar, at least in PDF output.
====
endif::editing-notes[]

ifdef::GLSL[]
Jeff Bolz, NVIDIA +
Pierre Boudier, AMD +
Pat Brown, NVIDIA +
Frank Chen +
Piers Daniell, NVIDIA +
Chris Dodd, NVIDIA +
Jason Green, Transgaming +
Nick Haemel, NVIDIA +
Brent Insko, Intel +
Daniel Koch, NVIDIA +
Jon Leech +
Graeme Leese, Broadcom +
Bill Licea-Kane, Qualcomm +
Barthold Lichtenbelt, NVIDIA +
Bruce Merry, ARM +
Robert Ohannessian +
Tom Olson, ARM +
Brian Paul, VMware +
Acorn Pooley, NVIDIA +
Daniel Rakos, AMD +
Christophe Riccio, AMD +
Kevin Rogovin +
Ian Romanick, Intel +
Greg Roth, NVIDIA +
Jeremy Sandmel, Apple +
Graham Sellers, AMD +
Dave Shreiner, ARM +
Robert Simpson, Qualcomm +
Eric Werness, NVIDIA +
Mark Young, AMD
endif::GLSL[]
ifdef::ESSL[]
Acorn Pooley, NVIDIA +
Alberto Moreira, Qualcomm +
Aleksandra Krstic, Qualcomm +
Alon Or-bach, Nokia & Samsung +
Andrzej Kacprowski, Intel +
Arzhange Safdarzadeh, Intel +
Aske Simon Christensen, ARM +
Avi Shapira, Graphic Remedy +
Barthold Lichtenbelt, NVIDIA +
Ben Bowman, Imagination Technologies +
Ben Brierton, Broadcom +
Benj Lipchak, Apple +
Benson Tao, Vivante +
Bill Licea-Kane, Qualcomm +
Brent Insko, Intel +
Brian Murray, Freescale +
Bruce Merry, ARM +
Carlos Santa, TI +
Cass Everitt, Epic Games & NVIDIA +
Cemil Azizoglu, TI +
Chang-Hyo Yu, Samsung +
Chris Dodd, NVIDIA +
Chris Knox, NVIDIA +
Chris Tserng, TI +
Clay Montgomery, TI +
Daniel Kartch, NVIDIA +
Daniel Koch, Transgaming& NVIDIA +
Daoxiang Gong, Imagination Technologies +
Dave Shreiner, ARM +
David Garcia, AMD +
David Jarmon, Vivante +
Derek Cornish, Epic Games +
Dominick Witczak, Mobica +
Eben Upton, Broadcom +
Ed Plowman, ARM +
Eisaku Ohbuchi, DMP +
Elan Lennard, ARM +
Erik Faye-Lund, ARM +
Graeme Leese, Broadcom +
Graham Connor, Imagination Technologies +
Graham Sellers, AMD +
Greg Roth, NVIDIA +
Guillaume Portier, Hi Corporation +
Guofang Jiao, Qualcomm +
Hans-Martin Will, Vincent +
Hwanyong Lee, Huone +
I-Gene Leong, NVIDIA +
Ian Romanick, Intel +
Ian South-Dickinson, NVIDIA +
Ilan Aelion-Exch, Samsung +
Inkyun Lee, Huone +
Jacob Strm, Ericsson +
James Adams, Broadcom +
James Jones, Imagination Technologies +
James McCombe, Imagination Technologies +
Jamie Gennis, Google +
Jan-Harald Fredriksen, ARM +
Jani Vaisanen, Nokia +
Jarkko Kemppainen, Symbio +
Jeff Bolz, NVIDIA +
Jeff Leger, Qualcomm +
Jeff Vigil, Qualcomm +
Jeremy Sandmel, Apple +
Jeremy Thorne, Broadcom +
Jim Hauxwell, Broadcom +
Jinsung Kim, Huone +
Jiyoung Yoon, Huone +
John Kessenich, Google +
Jon Kennedy, 3DLabs +
Jon Leech, Khronos +
Jonathan Putsman, Imagination Technologies +
Joohoon Lee, Samsung +
JoukoKylmäoja, Symbio +
Jrn Nystad, ARM +
Jussi Rasanen, NVIDIA +
Kalle Raita, drawElements +
Kari Pulli, Nokia +
Keith Whitwell, VMware +
Kent Miller, Netlogic Microsystems +
Kimmo Nikkanen, Nokia +
Konsta Karsisto, Nokia +
Krzysztof Kaminski, Intel +
Larry Seiler, Intel +
Lars Remes, Symbio +
Lee Thomason, Adobe +
Lefan Zhong, Vivante +
Marcus Lorentzon, Ericsson +
Mark Butler, Imagination Technologies +
Mark Callow, Hi Corporation +
Mark Cresswell, Broadcom +
Mark Snyder, Alt Software +
Mark Young, AMD +
Mathieu Robart, STM +
Matt Netsch, Qualcomm +
Matt Russo, Matrox +
Maurice Ribble, Qualcomm +
Max Kazakov, DMP +
Mika Pesonen, Nokia +
Mike Cai, Vivante +
Mike Weiblen, Zebra Imaging & Qualcomm +
Mila Smith, AMD +
Nakhoon Baek, Kyungpook Univeristy +
Nate Huang, NVIDIA +
Neil Trevett, NVIDIA +
Nelson Kidd, Intel +
Nick Haemel, NVIDIA +
Nick Penwarden, Epic Games +
Niklas Smedberg, Epic Games +
Nizar Romdan, ARM +
Oliver Wohlmuth , Fujitsu +
Pat Brown, NVIDIA +
Paul Ruggieri, Qualcomm +
Per Wennersten, Ericsson +
Petri Talala, Symbio +
Phil Huxley, ZiiLabs +
Philip Hatcher, Freescale & Intel +
Piers Daniell, NVIDIA +
Pyry Haulos, drawElements +
Piotr Tomaszewski, Ericsson +
Piotr Uminski, Intel +
Rami Mayer, Samsung +
Rauli Laatikainen, RightWare +
Rob Barris, NVIDIA +
Rob Simpson, Qualcomm +
Roj Langhi, Vivante +
Rune Holm, ARM +
Sami Kyostila, Nokia +
Sean Ellis, ARM +
Shereef Shehata, TI +
Sila Kayo, Nokia +
Slawomir Cygan, Intel +
Slawomir Grajewski, Intel +
Steve Hill, STM & Broadcom +
Steven Olney, DMP +
Suman Sharma, Intel +
Tapani Palli, Nokia +
Teemu Laakso, Symbio +
Tero Karras, NVIDIA +
Timo Suoranta, Imagination Technologies & Broadcom +
Tom Cooksey, ARM +
Tom McReynolds, NVIDIA +
Tom Olson, TI & ARM +
Tomi Aarnio, Nokia +
Tommy Asano, Takumi +
Wes Bang, Nokia +
Yanjun Zhang, Vivante
endif::ESSL[]

// Copyright 2008-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0
// chapters/references.adoc
[[references]]
= Normative References
<<toc>>


  . International Standard ISO/IEC 14882:1998(E).
    Programming Languages - C++. Referenced for preprocessor only
  . "`OpenGL^R^ ES, Version 3.2`",
    https://www.khronos.org/registry/OpenGL/index_es.php, November 3, 2016.
  . "`The OpenGL^R^ Graphics System: A Specification, Version 4.6 (Core
    Profile)`", https://www.khronos.org/registry/OpenGL/index_gl.php, June
    1, 2016.
  . [.ESSL]##International Standard ISO/IEC 646:1991.
    Information technology - ISO 7-bit coded character set for information
    interchange ##
  . [.ESSL]##The Unicode Standard Version 6.0 - Core Specification. ##

  . IEEE 754-2008.
    _IEEE Standard for Floating-Point Arithmetic_
  . "`SPIR-V Specification, Version 1.6, Revision 2`" ,
    https://www.khronos.org/registry/spir-v/.
  . "`Vulkan^R^ 1.3.226 - A Specification`",
    https://www.khronos.org/registry/vulkan/,
    September 1, 2022.

// Copyright 2008-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0
// chapters/spirvmappings.adoc
[[spirvmappings]]
= Non-Normative SPIR-V Mappings
<<toc>>

This appendix includes:

- a comparison of feature differences with SPIR-V versus without, for both Vulkan and OpenGL
- a discussion of how GLSL features logically map to SPIR-V features.


== Feature Comparisons

The following features are removed for both OpenGL and Vulkan:

* subroutines
* shared and packed block layouts
* the already deprecated texturing functions (e.g., `texture2D()`)
* the already deprecated noise functions (e.g., `noise1()`)
* compatibility-profile features
* _gl_DepthRangeParameters_ and _gl_NumSamples_

Vulkan removed the following features, which are still present for OpenGL:

* Default uniforms, for non-opaque types:
  The *UniformConstant* storage class can be used on individual
  variables at global scope. (That is, uniforms don't have to be in a
  block, unless they are built-in members that are in block in GLSL
  version 4.5 or above.)
* GLSL atomic-counter bindings have the _offset_ layout qualifier ->
  SPIR-V *AtomicCounter* storage class using the *Offset* decoration
* GLSL _origin_lower_left_ -> SPIR-V *OriginLowerLeft*
* special rules for locations for input doubles in the vertex shader
* _gl_VertexID_ and _gl_InstanceID_ (more detail follows)

The following features are added for both OpenGL and Vulkan:

* specialization constants
* _offset_ can organize members in a different order than declaration order
* _offset_ and _align_ layout qualifiers for uniform/buffer blocks for
  versions that did not support them

Vulkan Only: The following features are added:

* push-constant buffers
* shader combining of separate textures and samplers (SPIR-V *OpTypeSampler*)
* descriptor sets (*DescriptorSet* must be 0, if present)
* _gl_VertexIndex_ and _gl_InstanceIndex_
* subpass-input targets and input attachments (_input_attachment_index_)

The following features are changed in both OpenGL and Vulkan:

* _gl_FragColor_ will no longer indicate an implicit broadcast

Vulkan Only: The following features are changed:

* precision qualifiers (*mediump* and *lowp*) will be respected for all
  versions, not dropped for desktop versions (default precision for
  desktop versions is *highp* for all types)
* arrays of uniforms and buffer blocks take only one binding number for
  the entire object, not one per array element
* the default origin is _origin_upper_left_ instead of _origin_lower_left_

Vulkan does not allow multi-dimensional arrays of resources like
UBOs and SSBOs in its SPIR-V environment spec. SPIR-V supports
it and OpenGL already allows this for GLSL shaders. SPIR-V
for OpenGL also allows it.


== Mapping from GLSL to SPIR-V


=== Specialization Constants

SPIR-V specialization constants, which can be set later by the client API,
can be declared using `layout(constant_id=...)`. For example, to make a
specialization constant with a default value of 12:

    layout(constant_id = 17) const int arraySize = 12;

Above, `17` is the ID by which the API or other tools can later refer to
this specific specialization constant.  The API or an intermediate tool can
then change its value to another constant integer before it is fully
lowered to executable code.  If it is never changed before final lowering,
it will retain the value of 12.

Specialization constants have const semantics, except they don't fold.
Hence, an array can be declared with `arraySize` from above:

    vec4 data[arraySize];  // legal, even though arraySize might change

Specialization constants can be in expressions:

    vec4 data2[arraySize + 2];

This will make `data2` be sized by 2 more than whatever constant value
`arraySize` has when it is time to lower the shader to executable code.

An expression formed with specialization constants also behaves in the
shader like a specialization constant, not a like a constant.

    arraySize + 2       // a specialization constant (with no constant_id)

Such expressions can be used in the same places as a constant.

The _constant_id_ can only be applied to a scalar integer, a scalar floating-point
or a scalar Boolean.

Only basic operators and constructors can be applied to a specialization
constant and still result in a specialization constant:

    layout(constant_id = 17) const int arraySize = 12;
    sin(float(arraySize));    // result is not a specialization constant

While SPIR-V specialization constants are only for scalars, a vector
can be made by operations on scalars:

    layout(constant_id = 18) const int scX = 1;
    layout(constant_id = 19) const int scZ = 1;
    const ivec3 scVec = ivec3(scX, 1, scZ);  // partially specialized vector

A built-in variable can have a _constant_id_ attached to it:

    layout(constant_id = 18) gl_MaxImageUnits;

This makes it behave as a specialization constant.  It is not a full
redeclaration; all other characteristics are left intact from the
original built-in declaration.

The built-in vector _gl_WorkGroupSize_ can be specialized using special
layout `local_size_\{xyz}_id` applied to the *in* qualifier.  For example:

    layout(local_size_x_id = 18, local_size_z_id = 19) in;

This leaves _gl_WorkGroupSize.y_ as a non-specialization constant, with
_gl_WorkGroupSize_ being a partially specialized vector.  Its _x_ and _z_
components can be later specialized using the ID's 18 and 19.


=== Vulkan Only: Push Constants

Push constants reside in a uniform block declared using the new
layout-qualifier-id _push_constant_ applied to a uniform-block declaration.
The API writes a set of constants to a push-constant buffer, and the shader
reads them from a _push_constant_ block:

    layout(push_constant) uniform BlockName {
        int member1;
        float member2;
        ...
    } InstanceName; // optional instance name
    ... = InstanceName.member2; // read a push constant

The memory accounting used for the _push_constant_ uniform block is different
than for other uniform blocks:  There is a separate small pool of memory
it must fit within.  By default, a _push_constant_ buffer follows the std430
packing rules.


=== Vulkan Only: Descriptor Sets

Each shader resource in a descriptor set is assigned a tuple of (set
number, binding number, array element) that defines its location within
a descriptor set layout.
In GLSL, the set number and binding number are assigned via the _set_
and _binding_ layout qualifiers respectively, and the array element is
implicitly assigned consecutively starting with index equal to zero for
the first element of an array (and array element is zero for non-array
variables):

    // Assign set number = M, binding number = N, array element = 0
    layout (set=M, binding=N) uniform sampler2D variableName;

    // Assign set number = M, binding number = N for all array elements,
    // and array element = i for the ith member of an array of size I.
    layout (set=M, binding=N) uniform sampler2D variableNameArray[I];

For example, two combined texture/sampler objects can be declared in two
different descriptor sets as follows

    layout(set = 0, binding = 0) uniform sampler2D ts3;
    layout(set = 1, binding = 0) uniform sampler2D ts4;

See the API documentation for more detail on the operation model of
descriptor sets.


=== Vulkan Only: Samplers, Images, Textures, and Buffers


==== Storage Images

Storage images are declared in GLSL shader source using uniform image
variables of the appropriate dimensionality as well as a format layout
qualifier (if necessary):

    layout (set=m, binding=n, r32f) uniform image2D myStorageImage;

Which maps to the following SPIR-V:

            ...
    %1 = OpExtInstImport "GLSL.std.450"
            ...
            OpName %9 "myStorageImage"
            OpDecorate %9 DescriptorSet m
            OpDecorate %9 Binding n
    %2 = OpTypeVoid
    %3 = OpTypeFunction %2
    %6 = OpTypeFloat 32
    %7 = OpTypeImage %6 2D 0 0 0 2 R32f
    %8 = OpTypePointer UniformConstant %7
    %9 = OpVariable %8 UniformConstant
            ...


==== Samplers

SPIR-V samplers are declared in GLSL shader source using uniform *sampler* and
*samplerShadow* types:

    layout (set=m, binding=n) uniform sampler mySampler;

Which maps to the following SPIR-V:

            ...
    %1 = OpExtInstImport "GLSL.std.450"
            ...
            OpName %8 "mySampler"
            OpDecorate %8 DescriptorSet m
            OpDecorate %8 Binding n
    %2 = OpTypeVoid
    %3 = OpTypeFunction %2
    %6 = OpTypeSampler
    %7 = OpTypePointer UniformConstant %6
    %8 = OpVariable %7 UniformConstant
            ...


==== Textures (Sampled Images)

Textures are declared in GLSL shader source using uniform texture
variables of the appropriate dimensionality:

    layout (set=m, binding=n) uniform texture2D mySampledImage;

Which maps to the following SPIR-V:

            ...
    %1 = OpExtInstImport "GLSL.std.450"
            ...
            OpName %9 "mySampledImage"
            OpDecorate %9 DescriptorSet m
            OpDecorate %9 Binding n
    %2 = OpTypeVoid
    %3 = OpTypeFunction %2
    %6 = OpTypeFloat 32
    %7 = OpTypeImage %6 2D 0 0 0 1 Unknown
    %8 = OpTypePointer UniformConstant %7
    %9 = OpVariable %8 UniformConstant
            ...


==== Combined Texture and Samplers

Combined textures and samplers are declared in GLSL shader source using
uniform texture-combined sampler variables of the appropriate dimensionality:

    layout (set=m, binding=n) uniform sampler2D myCombinedImageSampler;

Which maps to the following SPIR-V:

            ...
    %1 = OpExtInstImport "GLSL.std.450"
            ...
            OpName %10 "myCombinedImageSampler"
            OpDecorate %10 DescriptorSet m
            OpDecorate %10 Binding n
    %2 = OpTypeVoid
    %3 = OpTypeFunction %2
    %6 = OpTypeFloat 32
    %7 = OpTypeImage %6 2D 0 0 0 1 Unknown
    %8 = OpTypeSampledImage %7
    %9 = OpTypePointer UniformConstant %8
    %10 = OpVariable %9 UniformConstant
            ...

Note that a combined image sampler descriptor can be referred to as just
an image or sampler in the shader as per the above sections.


==== Combining Separate Samplers and Textures

A sampler, declared with the keyword *sampler*, contains just filtering
information, containing neither a texture nor an image:

    uniform sampler s;    // a handle to filtering information

A texture, declared with keywords like *texture2D*, contains just image
information, not filtering information:

    uniform texture2D t;  // a handle to a texture (an image in SPIR-V)

Constructors can then be used to combine a sampler and a texture at the
point of making a texture lookup call:

    texture(sampler2D(t, s), ...);

Note, `layout()` information is omitted above for clarity of this feature.


==== Texture Buffers (Uniform Texel Buffers)

Texture buffers are declared in GLSL shader source using uniform
textureBuffer variables:

    layout (set=m, binding=n) uniform textureBuffer myUniformTexelBuffer;

Which maps to the following SPIR-V:

            ...
    %1 = OpExtInstImport "GLSL.std.450"
            ...
            OpName %9 "myUniformTexelBuffer"
            OpDecorate %9 DescriptorSet m
            OpDecorate %9 Binding n
    %2 = OpTypeVoid
    %3 = OpTypeFunction %2
    %6 = OpTypeFloat 32
    %7 = OpTypeImage %6 Buffer 0 0 0 1 Unknown
    %8 = OpTypePointer UniformConstant %7
    %9 = OpVariable %8 UniformConstant
            ...


==== Image Buffers (Storage Texel Buffers)

Image buffers are declared in GLSL shader source using uniform
imageBuffer variables:

    layout (set=m, binding=n, r32f) uniform imageBuffer myStorageTexelBuffer;

Which maps to the following SPIR-V:

            ...
    %1 = OpExtInstImport "GLSL.std.450"
            ...
            OpName %9 "myStorageTexelBuffer"
            OpDecorate %9 DescriptorSet m
            OpDecorate %9 Binding n
    %2 = OpTypeVoid
    %3 = OpTypeFunction %2
    %6 = OpTypeFloat 32
    %7 = OpTypeImage %6 Buffer 0 0 0 2 R32f
    %8 = OpTypePointer UniformConstant %7
    %9 = OpVariable %8 UniformConstant
            ...


==== Storage Buffers

Storage buffers are declared in GLSL shader source using buffer storage
qualifier and block syntax:

    layout (set=m, binding=n) buffer myStorageBuffer
    {
        vec4 myElement[];
    };

Which maps to the following SPIR-V:

            ...
    %1 = OpExtInstImport "GLSL.std.450"
            ...
            OpName %9 "myStorageBuffer"
            OpMemberName %9 0 "myElement"
            OpName %11 ""
            OpDecorate %8 ArrayStride 16
            OpMemberDecorate %9 0 Offset 0
            OpDecorate %9 BufferBlock
            OpDecorate %11 DescriptorSet m
            OpDecorate %11 Binding n
    %2 = OpTypeVoid
    %3 = OpTypeFunction %2
    %6 = OpTypeFloat 32
    %7 = OpTypeVector %6 4
    %8 = OpTypeRuntimeArray %7
    %9 = OpTypeStruct %8
    %10 = OpTypePointer Uniform %9
    %11 = OpVariable %10 Uniform
            ...


==== Uniform Buffers

Uniform buffers are declared in GLSL shader source using the uniform storage
qualifier and block syntax:

    layout (set=m, binding=n) uniform myUniformBuffer
    {
        vec4 myElement[32];
    };

Which maps to the following SPIR-V:

            ...
    %1 = OpExtInstImport "GLSL.std.450"
            ...
            OpName %11 "myUniformBuffer"
            OpMemberName %11 0 "myElement"
            OpName %13 ""
            OpDecorate %10 ArrayStride 16
            OpMemberDecorate %11 0 Offset 0
            OpDecorate %11 Block
            OpDecorate %13 DescriptorSet m
            OpDecorate %13 Binding n
    %2 = OpTypeVoid
    %3 = OpTypeFunction %2
    %6 = OpTypeFloat 32
    %7 = OpTypeVector %6 4
    %8 = OpTypeInt 32 0
    %9 = OpConstant %8 32
    %10 = OpTypeArray %7 %9
    %11 = OpTypeStruct %10
    %12 = OpTypePointer Uniform %11
    %13 = OpVariable %12 Uniform
            ...


==== Subpass Inputs

Within a rendering pass, a subpass can write results to an output target
that can then be read by the next subpass as an input subpass.  The
"Subpass Input" feature regards the ability to read an output target.

Subpass inputs are read through a new set of types, available only
to fragment shaders:

    subpassInput
    subpassInputMS
    isubpassInput
    isubpassInputMS
    usubpassInput
    usubpassInputMS

Unlike sampler and image objects, subpass inputs are implicitly addressed
by the fragment's (_x_, _y_, _layer_) coordinate.

Input attachments are decorated with their input attachment index in
addition to descriptor set and binding numbers.

    layout (input_attachment_index=i, set=m, binding=n) uniform subpassInput myInputAttachment;

Which maps to the following SPIR-V:

            ...
    %1 = OpExtInstImport "GLSL.std.450"
            ...
            OpName %9 "myInputAttachment"
            OpDecorate %9 DescriptorSet m
            OpDecorate %9 Binding n
            OpDecorate %9 InputAttachmentIndex i
    %2 = OpTypeVoid
    %3 = OpTypeFunction %2
    %6 = OpTypeFloat 32
    %7 = OpTypeImage %6 SubpassData 0 0 0 2 Unknown
    %8 = OpTypePointer UniformConstant %7
    %9 = OpVariable %8 UniformConstant
            ...

An _input_attachment_index_ of i selects the ith entry in the input pass
list. (See API specification for more information.)

These objects support reading the subpass input through the following
functions:

    gvec4 subpassLoad(gsubpassInput   subpass);
    gvec4 subpassLoad(gsubpassInputMS subpass, int sample);


=== Mapping Variables


==== _gl_FragColor_

The fragment-stage built-in _gl_FragColor_, which implies a broadcast to all
outputs, is not present in SPIR-V. Shaders where writing to _gl_FragColor_
is allowed can still write to it, but it only means to write to an output:

- of the same type as _gl_FragColor_
- decorated with location 0
- not decorated as a built-in variable.

There is no implicit broadcast.


==== Vulkan _gl_VertexIndex_ and _gl_InstanceIndex_

Adds two new built-in variables, _gl_VertexIndex_ and _gl_InstanceIndex_ to
replace the existing built-in variables _gl_VertexID_ and _gl_InstanceID_.

In the situations where the indexing is relative to some base offset,
these built-in variables are defined, for Vulkan, to take on values as
follows:

    gl_VertexIndex             base, base+1, base+2, ...
    gl_InstanceIndex           base, base+1, base+2, ...

Where it depends on the situation what the base actually is.


==== Storage Classes:

    uniform sampler2D...;        -> UniformConstant
    uniform blockN { ... } ...;  -> Uniform, with Block decoration
    in / out variable            -> Input/Output, possibly with block (below)
    in / out block...            -> Input/Output, with Block decoration
    buffer  blockN { ... } ...;  -> Uniform, with BufferBlock decoration
    shared                       -> Workgroup
    <normal global>              -> Private

    Vulkan Only: buffer  blockN { ... } ...;  -> StorageBuffer, when requested
    OpenGL Only: uniform variable (non-block) -> UniformConstant
    OpenGL Only: ... uniform atomic_uint ...  -> AtomicCounter


==== Input/Output

Mapping of input/output blocks or variables is the same for all versions
of GLSL or ESSL. To the extent variables or members are available in a
version, its location is as follows:

These are mapped to SPIR-V individual variables, with similarly spelled
built-in decorations (except as noted):

Any stage:

    in gl_VertexIndex          (Vulkan only)
    in gl_VertexID             (OpenGL only)
    in gl_InstanceIndex        (Vulkan only)
    in gl_InstanceID           (OpenGL only)
    in gl_InvocationID
    in gl_PatchVerticesIn      (PatchVertices)
    in gl_PrimitiveIDIn        (PrimitiveID)
    in/out gl_PrimitiveID      (in/out based only on storage qualifier)
    in gl_TessCoord

    in/out gl_Layer
    in/out gl_ViewportIndex

    patch in/out gl_TessLevelOuter  (uses Patch decoration)
    patch in/out gl_TessLevelInner  (uses Patch decoration)

Compute stage only:

    in gl_NumWorkGroups
    in gl_WorkGroupSize
    in gl_WorkGroupID
    in gl_LocalInvocationID
    in gl_GlobalInvocationID
    in gl_LocalInvocationIndex

Fragment stage only:

    in gl_FragCoord
    in gl_FrontFacing
ifdef::GLSL[]
    in gl_ClipDistance
    in gl_CullDistance
endif::GLSL[]
    in gl_PointCoord
    in gl_SampleID
    in gl_SamplePosition
    in gl_HelperInvocation
    out gl_FragDepth
    in gl_SampleMaskIn        (SampleMask)
    out gl_SampleMask         (in/out based only on storage qualifier)

These are mapped to SPIR-V blocks, as implied by the pseudo code, with
the members decorated with similarly spelled built-in decorations:

Non-fragment stage:

    in/out gl_PerVertex {   // some subset of these members will be used
        gl_Position
        gl_PointSize
ifdef::GLSL[]
        gl_ClipDistance
        gl_CullDistance
endif::GLSL[]
    }                       // name of block is for debug only

There is at most one input and one output block per stage in SPIR-V.
The subset and order of members will match between stages sharing an
interface.


=== Vulkan Only: Mapping of Precision Qualifiers

    lowp     -> RelaxedPrecision, on storage variable and operation
    mediump  -> RelaxedPrecision, on storage variable and operation
    highp    -> 32-bit, same as int or float

    portability tool/mode  -> OpQuantizeToF16


=== Mapping of *precise*:

    precise -> NoContraction


=== OpenGL Mapping of *atomic_uint* _offset_ layout qualifier

    offset         ->  Offset (decoration)


=== Mapping of Images

    imageLoad()   -> OpImageRead
    imageStore()  -> OpImageWrite
    texelFetch()  -> OpImageFetch
    subpassInput  -> OpTypeImage with Dim of SubpassData (Vulkan only)
    subpassLoad() -> OpImageRead                         (Vulkan only)

    imageAtomicXXX(params, data)  -> %ptr = OpImageTexelPointer params
                                            OpAtomicXXX %ptr, data

    XXXQueryXXX(combined) -> %image = OpImage combined
                                    OpXXXQueryXXX %image


=== Mapping of Layouts

    std140/std430  ->  explicit Offset, ArrayStride, and MatrixStride
                        Decoration on struct members
    shared/packed  ->  not allowed
    <default>      ->  not shared, but std140 or std430
    xfb_offset     ->  Offset Decoration on the object or struct member
    xfb_buffer     ->  XfbBuffer Decoration on the object
    xfb_stride     ->  XfbStride Decoration on the object
    any xfb_*      ->  the Xfb Execution Mode is set
    captured XFB   ->  has both XfbBuffer and Offset
    non-captured   ->  lacking XfbBuffer or Offset

    max_vertices   ->  OutputVertices


=== Mapping of barriers

    barrier() (compute) -> OpControlBarrier(/*Execution*/Workgroup,
                                            /*Memory*/Workgroup,
                                            /*Semantics*/AcquireRelease |
                                                        WorkgroupMemory)

    barrier() (tess control) -> OpControlBarrier(/*Execution*/Workgroup,
                                                /*Memory*/Invocation,
                                                /*Semantics*/None)

    memoryBarrier() -> OpMemoryBarrier(/*Memory*/Device,
                                        /*Semantics*/AcquireRelease |
                                                    UniformMemory |
                                                    WorkgroupMemory |
                                                    ImageMemory)

    memoryBarrierBuffer() -> OpMemoryBarrier(/*Memory*/Device,
                                            /*Semantics*/AcquireRelease |
                                                        UniformMemory)

    memoryBarrierShared() -> OpMemoryBarrier(/*Memory*/Device,
                                            /*Semantics*/AcquireRelease |
                                                        WorkgroupMemory)

    memoryBarrierImage() -> OpMemoryBarrier(/*Memory*/Device,
                                            /*Semantics*/AcquireRelease |
                                                        ImageMemory)

    groupMemoryBarrier() -> OpMemoryBarrier(/*Memory*/Workgroup,
                                            /*Semantics*/AcquireRelease |
                                                        UniformMemory |
                                                        WorkgroupMemory |
                                                        ImageMemory)


=== Mapping of atomics

    all atomic builtin functions -> Semantics = None(Relaxed)

    atomicExchange()             -> OpAtomicExchange
    imageAtomicExchange()        -> OpAtomicExchange
    atomicCompSwap()             -> OpAtomicCompareExchange
    imageAtomicCompSwap()        -> OpAtomicCompareExchange
    N/A                          -> OpAtomicCompareExchangeWeak


=== OpenGL Only: Mapping of Atomics

    atomicCounterIncrement -> OpAtomicIIncrement
    atomicCounterDecrement -> OpAtomicIDecrement
    atomicCounter          -> OpAtomicLoad


=== Mapping of other instructions

    %     -> OpUMod/OpSMod
    mod() -> OpFMod
    N/A   -> OpSRem/OpFRem

    pack/unpack (conversion)    -> pack/unpack in GLSL extended instructions
    pack/unpack (no conversion) -> OpBitcast
