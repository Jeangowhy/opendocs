
# 🚩 参考
- [Blender Demo Reel 2013-2016 作品展示](https://www.bilibili.com/video/av20191243/)
- [PBR 核心知识体系总结与概览](https://blog.csdn.net/poem_qianmo/article/details/85239398)
- [《Physically Based Rendering: From Theory to Implementation, Third Edition》](http://www.pbr-book.org/3ed-2018/contents.html)
- [PHYSICALLY-BASED RENDERING, AND YOU CAN TOO!](https://marmoset.co/posts/physically-based-rendering-and-you-can-too/)


- [C4D 材质原理](https://www.jianshu.com/p/d0ae07f9a3ae)
- [Grease Pencil 绘制角色](https://www.bilibili.com/video/av40667466/)
- [How to simulate an Ocean in Blender](https://www.bilibili.com/video/av8084764/)
- [超写实皮肤材质纹理制作](https://www.bilibili.com/video/av77781302)
- [Blender Lazy Tutorials](https://www.bilibili.com/video/av66840467)
- [Gleb Alexandrov 教程](https://www.bilibili.com/video/av22713582/)
- [Unreal Engine Documentation](https://docs.unrealengine.com/zh-CN/index.html)


- [ZBrush 雕刻恶魔公主](https://www.bilibili.com/video/BV16K411W7B9)
- [Blender 2.9 制作绿色虫子](https://www.bilibili.com/video/BV1qC4y1H7cf)
- [Unreal Engine 5](https://www.bilibili.com/video/BV1BK411W75W)
- [女头像动态拓扑雕刻、倒模、动画](https://www.bilibili.com/video/BV1J541147ru)
- [Kallie Kaiser 比基尼试穿](https://www.bilibili.com/video/BV12s411v7xa)
- [Kallie Kaiser 超赞春季休闲比基尼收藏展示](https://www.bilibili.com/video/BV1EE411Y72P)
- [手机视频动作捕捉](https://www.bilibili.com/video/BV1dJ411x7Y8)
- [动作捕捉技术史：Vicon与Sire](https://www.bilibili.com/video/BV1ab411s7H3)
- [Blender 2.8 面部动作捕捉教程](https://www.bilibili.com/video/BV1f4411c7x4)
- [Blender 程序节点山水景观](https://www.bilibili.com/video/BV134411X7Pt)
- [Blender 程序化自然景观 沙漠 海滨 冰岛](https://www.bilibili.com/video/BV1EJ411776o/)

- [Jama Jurabaev Grease Pencil 教程](https://www.bilibili.com/video/BV1Za4y1x7iZ)
- [Low Poly 风格海上小火箭发射](https://www.bilibili.com/video/BV1Ux411p7V6)
- [Baby Hair](https://www.bilibili.com/video/BV1FW411T76m)
- [Cascadeur 角色动作绑定](https://www.bilibili.com/video/BV1xJ411C7Uc)
- [写实的云层效果](https://www.bilibili.com/video/av24171873)
- [Grease Pencil 制作 3D 模型](https://www.bilibili.com/video/av35432212)


- [How to Use Blender's New Ultimate Shader - Principled BSDF](https://www.bilibili.com/video/av27998058/)
- [The Secret Ingredient to Photorealism 照片级渲染](https://www.bilibili.com/read/cv1204504/)
- [Tracking & Mask 给酒杯贴幻彩](https://www.bilibili.com/video/BV1Cs411776k)
- [Tracking 掌上火球](https://www.bilibili.com/video/BV1KT4y137K5)
- [Tracking 风吸小球](https://www.bilibili.com/video/BV1bf4y1m78m)
- [Composite 合成器基础](https://www.bilibili.com/video/BV13J411u7md)
- [Blender 合成迷雾](https://zhuanlan.zhihu.com/p/103642042)
- [烟火 + Vortex](https://www.bilibili.com/video/BV16t411V7v9)
- [Blender 坠机爆炸](https://www.bilibili.com/video/av68691209)
- [Blender 烟火基础](https://www.bilibili.com/video/BV12Z4y1x7E2)
- [Blender 火焰特效教程](https://www.bilibili.com/video/av23177999)
- [Easy Fire & Smoke with Principled Volume](https://www.bilibili.com/video/BV1SW411o7po)
- [Blender 2.8 Tutorial- Cloth Animation in EEVEE](https://www.bilibili.com/video/BV1Jt411z7r2)

- [Cloth Brush - Blender 2.83 Alpha](https://www.bilibili.com/video/BV1ri4y1t7x4)
- [Blender Beginner Modeling Tutorial](https://www.bilibili.com/video/BV1ye411s7dY)
- [PureRef 参考图管理](https://www.bilibili.com/read/cv1900833/)
- [Sebastian Lague 建模](https://www.bilibili.com/video/av7795083)
- [Sebastian Lague 贴图](https://www.bilibili.com/video/av7795257)
- [Sebastian Lague 绑骨](https://www.bilibili.com/video/av7795361)
- [Sebastian Lague 蒙皮](https://www.bilibili.com/video/av7795612)
- [Sebastian Lague 动画](https://www.bilibili.com/video/av7795830)
- [Ukelele 尤克里里制作教程](https://www.bilibili.com/video/av4753811)
- [Blender 2.8 制作风格化幻想塔](https://www.bilibili.com/video/BV1c541147Ex)
- [The Cliff Tower Fantasy - Full course](https://www.bilibili.com/video/av8512900)
- [Unreal 4 Feudal Japan The Shognunate - Polygon Academy](https://www.bilibili.com/video/BV12i4y1t7BK)


- [Visceral Rocket Exhaust Flames without Particle 非粒子流体火箭尾焰](https://www.bilibili.com/video/BV184411j7ea)
- [Eevee Crystal](https://www.bilibili.com/video/BV1y4411M7dP)
- [Blender 粒子幻彩制作](https://www.bilibili.com/video/BV1sE411c7EX)
- [Shaderforge Clip Art](https://www.bilibili.com/video/BV19441137rq)
- [Shaderforge Gemstones & Ice 00](https://www.bilibili.com/video/BV1J4411P7f2)
- [Shaderforge Gemstones & Ice 01](https://www.bilibili.com/video/BV1e4411P7Bw)
- [Shaderforge Gemstones & Ice 02](https://www.bilibili.com/video/BV1Z4411P7Ps)
- [Shaderforge Gemstones & Ice 03](https://www.bilibili.com/video/BV1w4411N7fL)
- [Shaderforge Gemstones & Ice 04](https://www.bilibili.com/video/BV1r4411V72t)
- [Lotsalote - Create Your own Texutre in Blender](https://www.bilibili.com/video/BV1gb411j7mx)
- [Making a modern kitchen in Blender, in 15 minutes](https://www.bilibili.com/video/BV1qb411k7a8)
- [Blender Guru 甜饼圈教程](https://www.bilibili.com/video/av29742783/)


- [使用 Blender 渲染 Minecraft 3D 效果图](https://blog.phoenixlzx.com/2017/12/18/minecraft-3d-render-with-blender/)
- [Cycles 渲染加速要点](https://www.jianshu.com/p/16369ff0becc)
- [Animation Nodes 节点化动画编程插件](https://www.bilibili.com/video/BV1Dt411H7tL)
- [Bevel 倒角与模型真实感](https://www.jianshu.com/p/294237b121ec)
- [Cycles Smoke 烟雾模拟](https://www.bilibili.com/video/BV1NW411L7mz)
- [玩转 Blender 3D 动画角色创作](https://www.bilibili.com/video/BV1wW411i7nY)
- [36 Days of Type 2018](https://cloud.blender.org/p/gallery/5b06f95f8c85b351dcf5b3ef)
- [36 Days of Type 2017](https://cloud.blender.org/p/gallery/5900c18abb3ea119ae2d6352)



👉 爬树生物 - 作者: Daniel Bystedt
https://dbystedt.wordpress.com/
https://www.blendercn.org/blender-2-8专题
http://www.bgteach.com/open/course/47

Tree creature
June 6, 2018
 

I'm doing some testing of the upcoming REALTIME Eevee viewport for Blender 2.8, which is currently in development.

I’ve been waiting for the blender developers to finish up the job with porting the modifiers to Blender 2.8 so that I could test an animated scene. The sequence was rendered in Blender 2.8’s new realtime viewport Eevee. Comp was done in Blender 2.79

The creature was sculpted in Zbrush and the textures were done in Substance Designer and Substance Painter.

The voice actor in the video is my oldest daughter 🙂



# 🚩 Learning Blender: A Hands-On Guide to Creating 3D Animated Characters
玩转 Blender 3D动画角色创作（第二版）附机翻字幕版 https://www.bilibili.com/video/av18529027

Learning Blender: A Hands-On Guide to Creating 3D Animated Characters	Volume:
Author(s):	Oliver Villar
Publisher:	Addison-Wesley
Year:	2017
Edition:	2
Language:	English	Pages (biblio\tech):	368\0
ISBN:	0134663462, 9780134663463	ID:	1683541
Time added:	2017-05-15 00:19:45	Time modified:	2019-12-21 21:23:21
Size:	5 MB (4821277 bytes)
Extension:	epub
BibTeX	http://gen.lib.rus.ec/book/bibtex.php?md5=62195135A5F1B5258006BE2A8692F099
Desr. old vers.:	2017-05-15 04:19:47; 2017-05-15 09:04:28; 2017-05-15 09:04:29; >>	Edit record:	Libgen Librarian https://library.bz/main/edit/62195135A5F1B5258006BE2A8692F099
Tags:	Graphics & Design;Computers & Technology;>>

torrent: http://gen.lib.rus.ec/book/index.php?md5=62195135a5f1b5258006be2a8692f099&oftorrent=
Oliver Villar-Learning Blender_ A Hands-On Guide to Creating 3D Animated Characters-Addison-Wesley (2017).epub

Master the Newest Blender Techniques for Creating Amazing 3D Characters: From Design and Modeling to Video Compositing


Now fully updated for Blender 2.78b and beyond, Learning Blender, Second Edition, walks you through every step of creating an outstanding 3D animated character with Blender, and then compositing it in a real video using a professional workflow. This edition covers the powerful new selection and modeling tools, as well as high-efficiency improvements related to other parts of the project such as texture painting, shading, rigging, rendering, and compositing.
 
Still the only Blender tutorial to take you from preproduction to final result, this guide is perfect for both novices and those moving from other software to Blender (open source and free software). Author Oliver Villar provides full-color, hands-on chapters that cover every aspect of character creation: design, modeling, unwrapping, texturing, shading, rigging, animation, and rendering. He also walks you through integrating your animated character into a real-world video, using professional camera tracking, lighting, and compositing techniques.
 
The rich companion website (blendtuts.com/learning-blender-files) will help you quickly master even the most complex techniques with bonus contents like video tutorials. By the time you’re done, you’ll be ready to create outstanding characters for all media—and you’ll have up-to-date skills for any 3D project, whether it involves characters or not.

Learn Blender’s updated user interface, navigation, and selection techniques Create your first scene with Blender and the Blender Render and Cycles render engines Organize an efficient, step-by-step pipeline to streamline workflow in any project Master modeling, unwrapping, and texturing Bring your character to life with materials and shading Create your character’s skeleton and make it walk Use Camera Tracking to mix 3D objects into a real-world video Transform a raw rendered scene into the final result using Blender’s compositing nodes

Table of contents :

	Preface

	Acknowledgments

	About the Author

	Part I The Basics of Blender
	1 What You Need to Know About Blender
	2 Blender Basics: The User Interface
	3 Your First Scene in Blender

	Part II Beginning a Project
	4 Project Overview
	5 Character Design

	Part III Modeling in Blender
	6 Blender Modeling Tools
	7 Character Modeling

	Part IV Unwrapping, Painting, and Shading
	8 Unwrapping and UVs in Blender
	9 Painting Textures
	10 Materials and Shaders

	Part V Bringing Your Character to Life
	11 Character Rigging
	12 Animating Your Character

	Part VI Getting the Final Result
	13 Camera Tracking in Blender
	14 Lighting, Compositing, and Rendering

	Part VII Keep Learning
	15 Other Blender Features
	Index


# 🚩 Blender 3D 应用领域

👉 环境设计 ENVIRONMENT DESIGN

环境设计又称“环境艺术设计”，是一种新兴的艺术设计门类。包含的学科相当广泛，主要由：建筑设计、室内设计、公共艺术设计、景观设计等内容组成。在内容上几乎包含了除平面和广告艺术设计之外其他所有的艺术设计，环境设计以建筑学为基础，有其独特的侧重点。与建筑学相比，环境设计更注重建筑的室内外环境艺术气氛的营造；与城市规划设计相比，则环境设计更注重规划细节的落实与完善；与园林设计相比，则更注重局部与整体的关系。环境艺术设计是“文化”、“艺术”与“技术”的有机结合体。专业培养目标是通过建筑基础、装饰材料与建筑模型、室内设计、环境规划与设计、计算机辅助设计等专业或主干课程，培养具有现代环境艺术设计的基本理论、知识、和设计能力的专门人才。学生毕业后可从事室内外环境设计、建筑改造设计、展示设计等实践或研究、教学工作。

环境设计专业高度强调艺术意识、创意能力、动手能力、整合能力、沟通能力、国际视野，以较全面的设计课程教学来奠定坚实的专业基本功，以多元的专业课程设置来构建学生综合应用能力。艺术意识通过多方面课程进行培养：艺术哲学、艺术史、绘画、工艺美术史、田野考察与研究、摄影等；创意能力、动手能力、整合能力、沟通能力的培养则贯彻在设计基础课到设计专业课、实践课的各个环节，由浅入深、由小到大。该专业紧扣社会及科技发展的前沿，结合学校、学院的优势学科及实验条件，突出形成两大特色：体验设计、绿色设计。除了常规的专业课程，特别加强学生在体验设计理论、体验设计技术、绿色设计理论、绿色设计技术方面的知识，突出培养能从事主题体验设计、策划的人才，突出培养能从事城市更新设计的人才。加强实践环节的教学，安排较为充足的实习时间，紧密结合市场需求，强调学生在接触专业设计课程之后，有效地利用各种机会进行艺术设计的实践活动，学院建有稳定的实习基地，为学生实践实习活动提供保障。

👉 游戏开发

结合 Unity 或 Unreal Engine 等游戏引擎做开发，通过游戏引擎平台提供的打包能力，将作品打包成不同平台运行的程序。

👉 VR 娱乐体验

👉 工业设计

👉 商业包装

各种产品的宣传短片制作，如 KFC 的广告等。

👉 CG 电影制作

Blender 基金会支持的 Mango Open Movie 工程制作发布的开源 CG 电影，交由国际团队协同联合制作，没有任何好莱坞动画工作室参于，主要特点是完全使用免费开源的自由软件创作。比如，用 Blender 进行 3D 图形、合成和视频编辑任务，用 GIMP 和 Inkscape 作图和绘画，在 OpenEXR 中渲染输出，用 Python 写脚本，在 SVN 中储存数据等等。


更多参考：https://cloud.blender.org/open-projects

- Coffee Run

	This 2D-scroller-inspired short film will take you on the journey of a lifetime, as we sip on a cup of coffee.


- Spring

	Spring is the story of a shepherd girl and her dog, who face ancient spirits in order to continue the cycle of life. This poetic and visually stunning short film was written and directed by Andy Goralczyk, inspired by his childhood in the mountains of Germany.

	https://cloud.blender.org/p/spring/
	https://www.bilibili.com/video/av48363080/
	https://www.bilibili.com/video/av51565769?p=2
	https://www.bilibili.com/video/av48456590?p=2

- Hero

	Hero is a showcase for the upcoming Grease Pencil in Blender 2.8. Grease Pencil means 2D animation tools within a full 3D pipeline. In Blender. In Open Source. Free for everyone.

	Hero is directed by Daniel Martinez Lara, and it is the 6th short film funded by the Blender Cloud.

	https://www.bilibili.com/video/av50803715/

- The Daily Dweebs

	A fun animation concept featuring an adorable dog going though an emotional rollercoaster.
	https://www.bilibili.com/video/av50803215/

- Agent 327

	Operation Barbershop is the first animation test for the Agent 327 project, released in 2017.
	https://www.bilibili.com/video/av50801806/

- Caminandes: Llamigos

	Experience the Patagonian winter, where Koro has to struggle and fight to get one berry. But this time, he is not alone!
	https://www.bilibili.com/video/av50801242/

- Glass Half

	Exploring cartoon animation and rendering in Blender 2.6x viewport - this 2015 short film looks fantastic even in 4K.
	https://www.bilibili.com/video/av50786011

- Cosmos Laundromat: First Cycle

	Aimed at becoming a feature film, the first episode of Cosmos Laundromat became the biggest Blender Institute production so far.
	https://www.bilibili.com/video/av50768923
	https://cloud.blender.org/p/cosmos-laundromat/55f35f7f2beb3300960bb077

- Caminandes: Gran Dillama

	"Gran Dillama", the second Caminandes episode with Koro the stubborn llama was made in 2013.
	http://www.caminandes.com/
	https://www.bilibili.com/video/av50753323
	https://www.bilibili.com/video/av16482649
	搞笑羊驼 https://www.bilibili.com/video/av6702359
	making electric bolts https://www.bilibili.com/video/av6702359?p=11

- Tears of Steel

	In 2012 this film pushed the limits for motion tracking, masking and realistic rendering in Blender.

	Tears of Steel | Mango Open Movie Project https://mango.blender.org/
	https://www.bilibili.com/video/av50736782/

- Sintel

	This fantasy short film from 2010 pushed the Blender 2.5 project forward.
	正片 https://www.bilibili.com/video/av50733944/
	https://cloud.blender.org/open-projects
	幕后记录 https://www.bilibili.com/video/av19683035/

- Big Buck Bunny

	With millions of views all around the world, this 2008 film has become an open source legend.

	《Big Buck Bunny》 大雄兔，故事情节十分简明、有趣，适合全年龄阶层的观众。与《Elephants Dream》一样，《Big Buck Bunny》的制作也是全都由开源软件完成的。其中 Blender 作为主要的 3D 制作软件，GIMP 和 Inkscape 作为平面图绘制软件，Subversion 作为源代码控制软件，Python 语言则作为高效的脚本语言处理各种数据。至于系统平台是在 Ubuntu 平台上制作的，这个在影片结束的字幕上可以看到。这个开源电影内容很不错，画质也非常好！虽然没有对白，但一定会让你看得哈哈大笑。

	https://www.bilibili.com/video/av31767176


- Elephants Dream

	Released in 2006, this is widely known as the first open movie ever. Elephants Dream has put Blender on the radar for many pros.

	动画短片 大象之梦 《Elephants Dream》 前后制作了一年。全片将近11分钟。影片看上去更像是一部奇幻电影，科幻的场景，丰富的想象力。6位富有经验的艺术家和开发者齐聚荷兰首都阿姆斯特丹，用时7个月的时间利用开源三位软件Blender制作了一部令人激动的三维动画短片。在技术上，影片几乎挑不出什么破绽，值得您去细细品味。

	https://www.bilibili.com/video/av50719080


⚡ 钢铁之泪 Tears of Steel (2012)

	导演: Ian Hubert
	编剧: Ian Hubert
	主演: 塞尔吉奥·哈塞尔巴因克 Sergio Hasselbaink / 塞尔吉奥·哈塞尔巴因克 / 德雷克·德·林特 / Vanja Rukavina / Denise Rebergen / Rogier Schippers / Rogier Schippers
	类型: 科幻 / 短片
	官方网站: http://www.tearsofsteel.org/
	制片国家/地区: 荷兰 Netherlands
	语言: 英语
	上映日期: 2012-09-26(英国)
	片长: 12分钟
	又名: 钢铁泪痕 / 钢之殇
	IMDb链接: tt2285752

Tears of Steel 是 Blender 基金会所支持的开源电影，片长12分钟左右。Tears of Steel 的故事以科幻为主题，讲述了一群战士和科学家聚集在未来的阿姆斯特丹老教堂（Oude Kerk），试图从机器人手中拯救世界。科学家们尝试重现过去某一个时刻的场景，与机器人进行心灵上的交流，这个过程包含了更多感情上的意义……

这片的价值根本不在剧情或者画面，本短片牛逼之处在于这是 Blender 基金会支持的开源电影项目。

首先我们要说说什么是开源电影，所谓开源（OpenSouce），就是说，你可以任意查看、修改制作它的软件，甚至是作品本身。（当然，开源也并不意味着完全没有版权，相反地，在开源世界中，对于版权的定义往往十分清晰，想要详细了解的，可以自行搜索DMCA数字千年版权法）开源电影会在创作共用版权下发布，采用P2P传播，没有DRM，允许Remix和共享——我们经常在国产MP4或是家电商场的电视里看到播放的一部样片《Big Buck Bunny 大雄兔》，就是该基金会之前制作的另一部开源电影。因为版权上的宽容，所以被各种抠逼公司用来做自带示例视频。

对于开源电影来说，你可以免费下载到制作它所使用的全部软件乃至修改这些软件，看到制作的全部过程，或者是下载到电影制作的原始工程文件进行参考学习。


我们来看看本电影制作时所用的软件：

- 3D & 后期特效合成 & 剪辑：Blender； 
- 渲染引擎：Cycles（包含OpenShading, OpenColor 以及OpenImage）； 
- 镜头 & 运动跟踪：Libmv； 
- 图像处理 & 制作：GIMP，MyPaint，Krita，Inkscape； 
- 储存 & 渲染输出格式：OpenEXR format.； 
- 脚本：Python； 
- 数据库储存：SVN； 
- 工作站平台：Ubuntu Linux（64位）； 
- 渲染农场平台：Debian和Ubuntu； 

看到了吧，这些软件几乎全部都是开源/免费软件。所以开源电影项目意味着什么、目的是什么，想必大家也能猜到一二。

一方面来说，纯开源的项目证明了Linux Movie 的可行性，拓展了除了主流商业公司提供的商业软件以外的思路。毕竟，想想操作系统行业，我们如今的Android、Mac OS X以及各种商用服务器系统许多都是基于Unix/Linux的，百花齐放，百家争鸣会给行业带来更多发展。（事实上，真正顶级的很多电影后期特效软件，比如达芬奇、Flame、Smoke最早都是基于Linux平台发展起来的。）

另一方面，开源软件制作一部完整的电影，不同于大型商业公司的思路。在OpenSource（开源）这里，你可以需要什么功能，就很方便的加入一个功能。这样，一部电影下来，制作电影本身的工具也进步了，这就像是 一块磨刀石，Makes the blade of Linux more sharper.

Blender 基金会早前已经发布了另外三部开源动画电影，2006年的《Elephants Dream大象之梦》，2008年的《Big Buck Bunny大雄兔》，2010年的《Sintel辛特尔》，这些都能在Blenderfoundation的Youtube频道里看到。而且完整的制作流程、经验分享、素材都可以在网上找到，都是十分好的学习素材。

顺便一提，blender这个软件我曾经使用过，很是牛逼，只有几十兆的软件，但是别的好几个G的同类3D软件的基础功能几乎都有了，真的很厉害（同类软件一般需要2GB往上的安装包）。

但就这部短片来说，特效仔细看的话还是颇多破绽，尤其是实景3D接触的时候明显能看出并不贴合（穷啊，做不起实体模型啊）还有抠像的边缘做的也并不是很好。不过机械的细节和光效做的还是很棒的。

但是，瑕不掩瑜，这仍然是一部优秀的作品。值得佩服的不仅是这些制作人员的作品，更重要的是他们的精神。如果可以参与进这种开源项目的制作，真的也算是在人生理想主义道路上建了一座值得老了以后说给孙子听的丰碑。






# 🚩 CG 工具特点
- 相机标定之张正友标定法数学原理详解 https://zhuanlan.zhihu.com/p/94244568
- 结构光简史 https://zhuanlan.zhihu.com/p/29971801
- BundleFusion: Real-time Globally Consistent 3D Reconstruction https://github.com/niessner/BundleFusion
- http://graphics.stanford.edu/projects/bundlefusion/


3D Max 的强项代表是多边形建模，3D Max 的动力学效果其实还不够好，有更好的软件，如韩国出品专攻服装的 Marvelous Desingner 简称 MD。雕刻建模的代表是 Blender/Zbrush/Sculptis，曲面 NURBS 建模则是犀牛 Rhinoceros，流建模 RealFlow。

Zbrush 是建模雕刻软件，主要制作高面数的艺术模型，对于游戏则是烘焙法线贴图用；

Maya 是综合性三维软件，包含建模，材质，动画，渲染等，可以完成一个游戏或者电影动画制作流程。Maya 也具有雕刻功能，只是这不是他的强项，因为它无法流畅支持 Zbrush 那样几千万面的模型雕刻。和 Zbrush 类似并和 maya 搭配的雕刻软件是 Autodesk 自家的 MudBox。

Zbrush 的非常规操作，更适合艺术创作而不是团队流程。并且使用 Zbrush 需要配备数位板，否则效率很低。

比雕刻建模方式更先进的是基于测量学的 Photogrammetry 高精度照片阵列扫描建模，通过计算机视觉 CV 算法分析，从图像序列中生成模型，实现快速高度还原的模型。图像序列由角度差很小的差别，这样通过比较可以得到模型结构的变化特征信息，再通过计算还原模型的几何结构。

比如以最简单的一个立方体为例，通过斜方旋转的一组照片，就可以探测出其基本的表面特征，和旋转时产生对应效果的结构是可以通过计算来还原的。

SFM - Structure From Motion 是从一系列包含视觉运动信息的多幅二维图像序列中估计三维结构的技术。

通过照片生成的模型是近似的，而带有距离传感器的如深度相机、激光雷达扫描得到的图像可以在更高精密度还原模型。通过计算得到点云模型，同一空间中海量的点的集合。激光测量的点云包括三维坐标和激光反射强度，常用灰度模型表示，摄影测量的点云包含三维坐标和颜色信息。

深度相机有双目、结构光、飞行时间测距法（TOF）等不同种类。发射红外线、光脉冲等，并接收物体表面反射的信号，用算法计算出深度数据。

目前，流行的软件有 PhotoScan，123D，Memento 等 Photogrammetry 软件。

2017 年 Apple 收购了蒙特利尔的头戴设备公司 Vrvana，获得的一项技术专利，用户可通过 iPhone 等设备扫描实景物体快速建模。目前这项专利已经应用于苹果的 ARkit，此技术将极大提升模型构建能力，现在 Apple 已经发布专业激光扫描应用 Canvas，可以搭配 LIDAR 深度扫描仪实现快速建模。

iPhone X 有两个与此相关的传感器，分别是 Infrared camera 和 Dot projector，前者是深度相机，而后者是一个点阵投影仪。从数学上说，一部分投影仪是可以用逆向针孔相机模型描述的，也就是说如果我知道投影面上的某一个点，我就可以知道由这个点投影出的一条射线，这条射线遇到一个面，线面相交的点就会被投影仪点亮。

总结光学建模技术：

- 激光扫描建模：扫描的精度高，但成像不如摄影建模。有的物体还需要粘贴标志点。
- 深度相机建模：扫描的精度较高，但成像不如摄影建模。除了购买相机，还需要购买第三方软件。
- 摄影建模：成像质量依赖照片的分辨率、照片可拼接的程度、软件的拼接水平、拍摄者的拍摄水平等。
- 光场建模：成像质量很高，但硬件成本很大。

所有的扫描建模，都需要后期加工，才能变成人们可以看的模型。


# 🚩 Substance 纹理制作套件
- [Substance Designer & Painter](https://www.substance3d.com/products/substance-painter)
- [Substance Designer 界面介绍](https://www.jianshu.com/p/483801995768)
- [Substance for Cinema 4D](https://www.jianshu.com/p/f2dc5e39c7ee)
- [Substance Painter 头发纹理](https://www.bilibili.com/video/BV1yW411g7vD)
- [Substance Designer 丝绸布料](https://www.bilibili.com/video/BV1kJ411V7kA)
- [Substance Designer 鳞片纹理制作](https://www.bilibili.com/video/av65889004/)
- [Substance Designer 三维植物叶子教程](https://www.bilibili.com/video/BV1Dx41197ZE)
- [Substance Painter PBR 官方基础教程](https://www.jianshu.com/p/5d16a10acff5)

Substance 公司的四个产品核心就是 Designer 以及该软件的生成的材质包 SBSAR 文件。Substance 的产品，它们的目的就是制作材质的贴图文件，它能制作两种贴图文件。 Designer 用于设计程序纹理的软件，也可以用于设计各种滤镜和基本工具。Designer 为节点编辑程序，涉及图像合成计算知识、编程逻辑思维知识等等，靠右脑思维的 CG 人，有点费劲啊！你想得到的效果，不是用涂抹和绘制完成，而是由不同枯燥的节点逻辑连接和参数设定来实现的。因此，对于美术专业的学生来说不是很实用，出现了 Painter，前者创建资源库和工具包，并且可以持续的让 Painter 更加强大。

Designer 可以比作音乐中的合成器。合成器用于发出声音，它可以产生人们无法想象的声音。Painter 就像电子钢琴一样，它具有许多内置功能，并使用合成器创建许多声音用来演奏音乐。

Designer 的矢量化纹理解决了图片纹理，JPG\PNG\TIF等格式的三个问题：

- 分辨率固化，不方便迭代修改；
- 纹理固化为像素，不方便更正修改；
- 文件体积与效果成正比，好的效果纹理体积巨大；

Substance 自己独特生成的 SBSAR 材质包是程序纹理的集合，文件特别小，一般只有十几K啊！矢量化的纹理不存在分辨率调整问题，可以实时更改，1K、2K、4K、8K 质量随便用，文件大小不变。程序化提供自定义可控参数，需要修改纹理，随时调节颜色和纹理等样式。这些优点导致主流游戏引擎 UE4 和 U3D 以及主流三维动画软件支持！

Designer 制作 SBSAR 材质包（程序纹理）可以直接提供给游戏引擎使用，也可以提供给 Painter 充当调用绘制的材质。SBSAR 材质包还可以通过 Bitmap2Material 转换为所需的各种材质贴图图像文件，供给游戏引擎和三维软件使用，还可以给 Player 转换为所需的各种材质贴图图像文件。


Painter 在模型的辅助下，在 UV 的控制下，可以在模型上绘制各种贴图，最后输出的是固定分辨率的各种贴图文件（图像文件）。

和 Blender Texture Paint 模式相比，Painter 提供的各种纹理绘画工具更加强大，图层化管理，绘制纹理包含各种材质属性，可以导出凹凸贴图、粗糙贴图、法线贴图、金属光泽等：

- Grunges 大量脏斑效果；
- Procedurals 大量程序纹理；
- Hard Surfaces 大量硬表面；
- Skin 各种皮肤效果；
- Filters 各种滤镜效果；
- Brushes 几十种内置笔刷；
- Particles 各种粒子动画；
- Tools 提供现成的弹孔、羽毛、螺丝、焊斑等；
- Materials 各种材质效果；


Bitmap2Material 可以将 SBSAR 材质包生成固定分辨率的各种
贴图文件（图像文件）；还有一种功能就是把一张图像转换为各种贴图文件（颜色、
法线、凹凸、高度、AO等贴图）。

Substance player 是各种软件的桥梁。它可以直接读取SBSAR材质包，查看、转换
贴图，提供给三维软件或游戏引擎使用。

在游戏引擎 U3D 中使用 SBSAR 材质包，打开 U3D，把模型文件和
sbsar 材质文件拖进 ASSETS 资源文件夹，把材质拖到模型上。


在 C4DR18 中，内置了 Substance 引擎，就是 Substance player 以插件的形式放到 C4D 中。载入 sbsar，打开以后，自动形成各种贴图。

MDL - Material Definition language 是材质定义语言，描述了材质的物理属性。

新版 Substance Painter 可能因重度 GPU 运算触发 Windows TDR - Time Detection Recovery 机制导致宕机。

注册表修改位置 TdrDelay 和 TdrDdiDelay (REG_DWORD)，或 TdrLevel 设置为 0 禁用 TDR 机制：

	REG ADD HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Applets\Regedit /v LastKey /t REG_SZ /d HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\GraphicsDrivers

	Regedit






# 🚩 Marvelous Designer MD 服饰制作
MD 服装设计与模拟 https://www.cnblogs.com/guaishoudashu/p/9816624.html
MD 基础教程 https://www.bilibili.com/video/BV1qK4y1C7iz?p=5
MD 腰带窗帘床品帽子制作 https://www.bilibili.com/video/BV1hb411V7XZ/
如何评判概念艺术作品好坏 https://www.zhihu.com/question/37647771/answer/121548490
关于什么是Concept Art https://zhuanlan.zhihu.com/p/22239258

MD 这款优秀的服装设计与模拟软件依据真实世界的服装缝合样式生成衣服，软件的界面设计非常友好，非常容易上手，通过画服装设计图纸来建立服装模型的方法节省时间极大提升效率。

无论你是角色艺术家，还是视觉效果艺术家 VFX - Visual Effects，还是角色技术指导 TD - Technical Director，更或者是一位概念设计艺术家 Concept Artist，MD都是你最佳的设计工具，可以让你创作出非常真实自然的服装折痕和细节褶皱。它不但可以允许你建立自己的库，混合和匹配衣服，而且最重要的是节省你大量的时间。

MD 自带示例人体模型和服饰模型，可以导出 OBJ 文件，再导入到 Blender 中使用。注意导出是，设置 Object 为 Multiple Object 可以配合 Blender 的导入选项 Split by Group 导入模型为分离的对象。导出时注意选择正确的单位，比如在 Blender 使用，导出模型使用 m 单位，错误使用 cm 就匹配导致模型变大，而 Maya 默认使用的是 cm 单位。

MD 设计服装首先是制作衣服版图，并以 2D 矢量图来表示样板图 Pattern，可以在 Property Editor 设置面料纹理材质，还有模拟过程需要用到的参数 Simulation Properties。画好 2D 样板再定义缝制方法，Segment Sewing 边对边缝制，或 M:N 多边缝制，按住 Shift 就可以缝合到多条边，经过缝制得到的就是服饰的模型。非边线的的缝制使用 Internal Line 定义，或者使用省道 Dark，打开属性的弹性 Elastic 来模仿松紧带效果。至于服装穿上身的效果如何，就要通过模拟运算与人体模型进行合体，找到布料的受力点，结合重力作用使模拟布料的下垂效果。

在模拟合体前，快捷键 Space 执行，需要在 3D 视图中编排按样板摆放位置 3D Arrangement，这样样板对应生成的网格模型就会出现在指定的空间位置，缝合后就会与人体模型进行合体。模拟的结果可以通过 Reset 2D/3D Arrangement 重置，Ctrl-F。在 3D 视图中，可以使用大头针 Pin 工具来锚点布料，这个用来做一些宽松的服装有用，如汉服要正确裹到模特身上就需要它。

MD 提供了两类视图，2D 视图用来处理服饰的版式设计，3D 视图用来模拟缝制好的服饰效果，按住右键可以拖动视图角度。在 2D 视图添加的图样 Pattern 可以在 3D 视图中调整位置，也可以使用辅助点 Arrangement Points 来放置。选择图样，再点击辅助点即可以自动对其进行放置。还可在 3D 视图中对图样模型进行其它修改，比如通过右键菜单对网格三角形化或四角化 Triangulate/Quadrangulate、材料加强 Strengthen、冻结 Freeze。

3D 视图还可以对模特通过调整骨架进行造型，Shift-X 打开 X-Ray 显示骨架。

MD 提供了 5 种工作模式：

- Simulation 布料仿真
- Animation 记录仿真动画
- Modular 模型处理
- UV Editor 贴图坐标
- Sculpt 模型雕刻

名词参考：

- Fabric 布料
- Button 纽扣
- Buttonhole 纽扣洞
- edge stitch 间边线
- top stich 面线，较靠边


1、设计外观

	你不必非得是一个很专业的时尚设计师才看使用MD，但起码要懂得一点基本的设计，最重要的是要知道如何读懂缝制图纸。去图书馆，随便找一些缝制的书，学一点点基础的缝制知识。然后在纸上画一些衣服草图，它可以帮助你理解缝制样式和展开灵感。这里有三件重要的事情：创作服装的主图样，缝制接缝且如何把图样缝合在一起，最后是其他的细节，比如口袋、拉链、纽扣等等。

2、分解服装

	MD可以创建衣服库，每一个创建的服装都可以编辑并可以把它匹配到其他的角色身上。如果你要处理很复杂的衣服设计，你应该单独的处理每件服装，然后合并到一个文件中，再使用MD的层系统模拟它们。这个方法可以让你每次都专注于设计一件衣服，不会被场景中的其它衣服干扰而分心，这样可以让MD的模拟工作更高效，避免任何交叉。

3、描设计图

	在2D视图中使用Rectangle工具画图样，描设计图，从Object Browser中添加面料，然后从Property Editor贴上设计图片作为纹理。将面料应用到图样上，使用Edit Texture Tool来适应图样形状内的设计图。添加其他面料，变换颜色，改变下透明度大概到50左右，然后开始在设计图上画图样。

4、制图

	开始用Polygon工具画设计图样，在没有闭合图样前每个尖角上只有一个点，尽可能保持图样的简洁，点越少越好。这个过程需要垂直或横向上对齐一些点，选择点，点击右键选择对齐。使用Edit Curve Point工具弯曲所有的边直到对准图案。先对齐一半图样就行，剩下一半用Symmetric Paste功能复制黏贴就好了。

5、缝制

	对齐图样很容易理解，这一步其实与我们现实中的服装设计师的工作是相同的。在MD中有两种缝制类型：Segment Sewing可以允许从一个Segment Line与另一个缝合，而Free Sewing可以让你自由的让图样任何的部分与其他缝合。可以按住Shift键用一线段与N个数量的线段缝合，如果需要的话可以用Edit Sewing工具翻转缝合线进行编辑。

6、对齐点

	Arrangement Points在Avatar的身体上呈现蓝色的点，你可以从3D视图的侧面图标打开。这些点对于对齐图样到Avatar上非常有用，而且可以帮助你重置图样。在MD中使用Arrangement Points与Avatar结合是默认的设置，但是如果想要使用自己的角色，你就必须得创建你自己的Arrangement Points，载入自己的角色，然后使用Avatar Editor修改局部的Bounding Volumes和Arrangement Points。

7、排列图样

	打开Arrangement Points，然后在3D视图中使用Select/Move工具选择图样，也可以使用2D视图中的Transform Pattern工具，把图样放置到相对应的对齐点上。这个地方要仔细的移动调整，要让图样尽可能的与Avatar的身体贴近，防止在模拟的时候下落。你可以是用Property Editor中的Arrangement Offset让图样包主Avatar。如果没有任何对齐点，那只能通过手动控制了。

8、模拟

	在模拟前一定要保存下。在Avatar上双击，在Property Editor设置Skin Offset，让衣服与皮肤的距离尽可能的小，或者是1.00mm或者更小。点击模拟（空格键）然后衣服开始下落，并覆盖在Avatar的身体上。在模拟时，你可以在3D视图中拖拽图样调整折痕，或者改变衣服的局部，挑出你想要的效果。

9、测量

	测量工作可以在你编辑衣服图样时让它更好的适合角色的身体。在MD中有两个主要的测量工具：一个是Circumference Measurement，另一个是Length Measurement。使用基本的CM工具测量腰部、臀部、大腿、膝盖、小腿、踝关节、胸部、肘部以及手腕。使用高度测量工具测量胸部、臀肌、脖子、腰围以及腿的高度数据。然后使用Surface Tape Measurement工具得到裤子和T恤的长度。

10、试穿衣服

	你要确保衣服在角色身上合身，不能太紧，也不能太大。打开Strain Map解决局部问题，检查哪里非常的紧，然后在2D视图中编辑下此区域让它稍微大一点，然后从新模拟检修下。如果衣服过大，只要调整大小并切掉多余的布料。尽可能保持图样的干净，有助于你之后加细。如果Strain Map是黄色/绿色颜色的，证明是合适的。

11、设计面料

	在进入细节之前你要设计好你的面料，MD有很多很好的预设，你可以用它们开始入手。点击模拟然后实时的调整面料，开始像衬衫和裤子可以用棉料的，包、皮带和帽子什么用皮的，然后调整物理属性。有时候一件衣服需要各种不同的面料。

12、内部线

	使用Internal Lines作为衣服设计起始阶段的导向，标记腰部、膝盖、肘部并均分图样。之后你可以使用他们折叠衣服并添加细节，比如洞和松紧带。对于折叠使用Internal Polygon/Line画一条线，然后从Property Editor调整Fold Strength 和Fold Angle。如果需要一个卷起的折子，比如袖口和衣领，选择Internal Line然后使用Fold Arrangement工具并手动的改变折子角度。在处理聚集效果时，打开Elastic并调整Intensity和Ratio的值就可以了。

13、口袋的细节

	做衣服口袋的形体要使用Internal Lines或者Internal Rectangle工具。选择工具并右键，选择Copy As Pattern然后黏贴到衣服附近。使用Free Sewing工具把口袋缝在内部线上，多数情况你只需要缝制三个边就可以了，留上边为开口。在3D视图中在兜图样上右键选择Superimpose，然后开始模拟。如果你想在口袋上产生一些皱痕，只需要把口袋图样调稍微大一点即可。

14、洞和省道

	（省道指将衣料与人体体表之间的余量部分折叠并将其缝去处理，以作出衣片曲面状态或消除衣片浮起余量，增加服装的立体感。）衣服上作洞还是用Internal Lines在衣服上画一个闭合的形体。你可以使用Internal Circle然后再编辑，在Internal Lines上右键并选择Convert to Hole。你可以使用洞去创建省道图样，省道通常是很紧的图样，而且没有完全没有可调整的外边缘线。在MD中有一个单独的创建省道的工具，它的创建方法完全与洞一样。

15、包

	创建包并给它一个硬布面料。我通常使用S_Leather_Belt，在空间中钉住它防止在模拟的时候移动。添加并缝合边缘，底部和前部，预留顶部为开口。从180到90或270改变折叠角度，这里要依据布料的法线方向来作。应该在包里放一些织物，让它看起来像是里面装满东西的感觉，然后再添加口袋和一些额外的细节，最后添加顶部的盖。

16、设定Avatar的姿势

	使用MD内置的节点系统调整姿势。建立一个没有衣服的新场景，切换到X-Ray模式，我们可以看到节点，然后使用移动旋转工具调整它们，得到你想要的姿势。在这里你需要切换局部或者世界Gizmo来更好的旋转轴向。File>Save As>Pose把姿势保存到库中。把衣服载入到当前场景，然后到库中拖拽刚才的姿势赋给当前的角色，确保粒子距离设施为20。

17、变形目标

	如果使用你自己的角色，你要导入一个姿势的变形体应用到角色上。从File>Import >Obj，选择Morph文件，然后选择作为Morph Target载入。如果姿势特别的复杂，设定你的Morphing Frame Count高一些，大概250帧左右。在某些情况下你需要避免中间帧的交叉，载入第一个中间帧，让MD作衣服模拟，然后再载入下一个，以此类推。


18、混合和匹配衣服

	开始一个新文件并载入你的Avatar，File>Add>Garment。添加你的所有衣服到场景中，设置每个东西的Particle Distance为20。选择所有的衣服，右键选择Deactivate。从衣服的底部开始，激活它然后模拟。完成模拟之后，右键冻结衣服。然后去处理下一件衣服，激活并设置它所在的层为1，然后模拟，接着冻结。重复这个过程，直到所有的衣服都处理完毕。解冻所有物体，然后再重新模拟。现在提高粒子的密度，从20到4，增加衣服的质量并一次次模拟。


19、导出

	你应该问问自己导出的模型Mesh，是三角面还是四边面的？是一个物体还是多个物体？是一体还是拆分的？薄的还是厚的？通常情况，如果你要对导出的模型进行雕刻，最好转成四边面，如果你还要导入到其他软件进行模拟，最好保持三角面。在这里，我把他导成四边面的Mesh，在Export Options我选择Multiple Objects，Unweld，Thin并Unified UV。

20、在ZB中加细

	这步是MD额外的。在某些点上你需要对衣服进行细节的处理，把你的衣服一件一件的用OBJ格式导出然后载入到zbrush里面，翻转法线选择双面。确保Polygroup使用UVs，然后从Geometry Palette使用The Panel选项添加厚度，设置Polish为0，Bevel为0，Elevation为100。然后使用Standard Brush修饰褶皱，再使用MicroMesh和NoiseMaker加一些其他细节。



# 🚩 Add-ons 插件
- 2019 Blender 2.8 最好用的10大建模插件！ https://www.bilibili.com/video/BV18x411W7CE/

10. Pivot Transform 
9. By-Gen 
8. LoopTools 
7. Mira Tools 
7a. Bezier Mesh Shaper 用曲线编辑方式修改模型
6. Speed Sculpt 
5. Edge Flow 网格均匀布线 https://github.com/BenjaminSauder/EdgeFlow
4. BoxCutter 
3. Smart Fill 
2. HardOps
1. MESHmachine

- Curve

	Add-ons » Add Curve » Sapling Tree Gen 
	https://docs.blender.org/manual/en/3.3/addons/add_curve/sapling.html
	Add-ons » Add Curve » Ivy Gen 
	https://docs.blender.org/manual/en/3.3/addons/add_curve/ivy_gen.html

- Interface

	- 3D Viewport Pie Menus 将快捷菜单转换为饼图菜单插件
	- Align Tools 对齐排列，View3D - Sidebar - Item Tab
	- Dynamic Brush Menus
	- Dynamic Context Menu
	- Copy Attributes Menu
	- Modifier Tools

		When enabled and the object has modifiers the additional helpers appear above the modifier stack.

- Animation

	- Animall 对 mesh, lattice, curve and surface 生成动画
	- Bone Selection Sets
	- Corrective Shape Keys
	- Turnaround Camera 通过插件脚本让指定相机围绕任何特定对象旋转，3D View ‣ Sidebar ‣ Animate tab。

- Import & Export

	- Import Images as Planes 导入图片文件设置为 Plane。
	- BioVision Motion Capture (BVH)
	- Scalable Vector Graphics (SVG)
	- Stanford PLY
	- STL
	- UV Layout
	- Import & Export of Node Shaders
	- FBX
	- glTF 2.0
	- Wavefront OBJ
	- Web3D X3D/VRML2

- Node 节点编辑器插件

	- Node Arrange 节点排序 node editor ‣ Sidebar ‣ Trees
	- Node Wrangler 节点编辑辅助 

- Mesh 网格网点编辑插件

	- 3D Print Toolbox
	- Auto Mirror
	- Bsurfaces GPL Edition 高模拓扑插件
	- Edit Mesh Tools
	- F2
	- Inset Straight Skeleton
	- A.N.T. Landscape, Another Noise Tool
	- Relax
	- Snap Utilities Line
	- tinyCAD Mesh Tools
	- Tissue


- Lucas Falcao 的 AutoEye 制作角色的眼睛。 
	https://www.blendermarket.com/products/auto-eye?ref=2
	http://blog.lucasfalcao.com/2019/02/auto-eye-v02.html

## 👉 3D Viewport Pie Menus 插件

将快捷菜单转换为饼图菜单

- Shift-Spacebar	动画菜单
- Ctrl-A		应用变换菜单
- Alt-X			编辑对齐工具
- X				编辑模式删除操作方式菜单
- Ctrl-Alt-S	编辑器切换
- Ctrl-Tab		编辑器模式切换
- Alt-Spacebar	变换操作菜单
- Ctrl-Alt-X	物体中心设置
- Ctrl-S		Save Open Pie，Save, Open, Import files menus
- Alt-W			Sculpt Brush Pies
- A				Select Menu 选择方式
- Z				Shading Menu 视图渲染方式
- Alt-Q			视图切换
- Ctrl-Shift-Tab	吸附选择 Snap elements

## 👉 Node Wrangler 节点编辑辅助插件

- Lazy Connect Hotkey:	`Ctrl-RMB-drag`, `Shift-Ctrl-RMB`
- Lazy Mix Hotkey:	`Alt-RMB-drag`
- Merge Quickly add Mix, Math, Z-Combine, Alpha Over, Mix Shader or Add Shader nodes that will merge outputs of selected nodes.
- Merge with Automatic Type Detection

	- Add `Shift-Ctrl-=` Sets blend type or math operation to Add. 
	- Multiply `Shift-Ctrl-8` Multiply blend type or math operation.
	- Subtract Ctrl-Minus Subtract blend type or math operation.
	- Divide Ctrl-Slash Divide blend type or math operation.
	- Mix Ctrl-0 Mix blend type or when shaders are selected a Mix Shader node will be used.
	- Greater than `Shift-Ctrl-Comma` Greater than math operation.
	- Less than `Shift-Ctrl-Period`

- Merge Using Mix Node Hotkey:	`Shift-Ctrl-Alt-=`, Ctrl-Alt-Minus, `Shift-Ctrl-Alt-8`, Ctrl-Alt-Slash

- Merge Using Z-Combine Node Hotkey:	`Ctrl-NumpadPeriod`
- Merge Using Alpha Over Node Hotkey:	`Ctrl-Alt-0`
- Merge Using Math Node Hotkey:	`Shift-Ctrl-=`, `Shift-Ctrl-Minus`, `Shift-Ctrl-8`, `Shift-Ctrl-Slash`, `Shift-Ctrl-Comma`, `Shift-Ctrl-Period`
- Batch Change Blend Type / Math Operation Hotkey:	`Alt-Up`, `Alt-Down`, `Alt-0`, `Shift-Alt-=`, `Alt-Minus`, `Shift-Alt-8`, `Alt-Slash`, `Shift-Alt-Comma`, `Shift-Alt-Period`
- Change Mix Factor Hotkey:	`Alt-Left`, `Shift-Alt-Left`, `Alt-Right`, `Shift-Alt-Right`
- Change Factor of selected Mix nodes or Mix Shader nodes.

	- Use Alt-Right to increase it by 0.1.
	- Use Alt-Left to decrease it by 0.1.
	- Use `Shift-Alt-Right` to increase it by 0.01.
	- Use `Shift-Alt-Left` to decrease it by 0.01.
	- Use `Shift-Ctrl-Alt-Left` to set factor to 0.0. Additional shortcut is `Shift-Ctrl-Alt-0`.
	- Use `Shift-Ctrl-Alt-Right` to set factor to 1.0. Additional shortcut is `Shift-Ctrl-Alt-1`.

- Delete Unused Nodes Hotkey:	`Alt-X`
- Swap Links Hotkey:	`Alt-S`
- Reset Backdrop Hotkey:	`Z`
- Frame Selected Hotkey:	`Shift-P`
- Reload Images Hotkey:	`Alt-R`
- Switch Node Type Hotkey:	`Shift-S`
- Copy Settings Hotkey:	`Shift-C`
- Copy Label Hotkey:	`Shift-C`
- Clear Label Hotkey:	`Alt-L`
- Modify Label Hotkey:	`Shift-Alt-L`
- Add Texture Setup Hotkey:	`Ctrl-T`
- Add Reroutes to Outputs Hotkey:	`Slash`
- Link Active to Selected Hotkey:	`Backslash`, `K`, `Shift-K`, ', `Shift-'`, `;`, `Shift-;`
- Align Nodes Hotkey:	`Shift-=`
- Select within Frame (Parent/Children)
	- ] -- Select all nodes wrapped in selected Frame node.
	- [ -- Select frame node that selected nodes are wrapped in.
- Detach Outputs Hotkey:	`Shift-Alt-D`
- Link to Output Node Hotkey:	`O`

## 👉 BlenderGIS 地图地形

国内获取相应数据可能需要科学上网，安装后，在对象视图出现 GIS 菜单：

Web gisdata - Basemap 添加地图，地图来源 Google、OSM、Bing、Esri、OSM WMS，选择其中一种以支持卫星图 Statelite。

在 Map View 使用滚轮调整合适地图比例，选择需要的地理位置：

- G 键输入地图坐标。
- E 键固定地图区域。

设置一个合适的经纬度，如北京西站 116.327331,39.881931。

固定地图后，得到一个 EXPORT 地形模型，再获取 Get elevation (STRM) 地图高度信息，这个操作可以让地形模型具有立体高度，会设置相应的修改器，修改强度改变地形的高度差。

OSM - Open Street Map 是开放街景地图数据，这种地形图可以通过 Get OSM 获取道路、基础建筑模型，需要有数据的区域才可以使用。加载需要的街景数据，按 Shifit 多选，如 Building、Landuse 等，注意 Elevation from object 中选择前面生成的 EXPORT 地形模型。

可惜，获取到的建筑模型是按一栋栋组织的，如果需要对墙面、天台等分别赋予不同材质，就需要额外的调整工作。而且，不进行 UV 展开就不能默认完成材质贴图。

SRTM - Shuttle Radar Topography Mission 即航天飞机雷达地形测绘使命，数据主要是由美国航空航天局（NASA）和国防部国家测绘局（NIMA)联合测量的。数据用 16 bits 数值表示高程数值，最大的正高程 9000m，负高程海平面以下 12000m。

得到地图后，进行模型细分，使其高度细节更丰富。侧栏菜单，按 N 打开，Geoscene 提供地图设置。

可以通过点的挤压伸出的方式让地图带有一定厚度，在编辑模式下，选择顶点编辑，按 A 全选，E 挤压，Z 约束轴向，再调整合适厚度。


- BlenderGIS 插件 https://github.com/domlysz/BlenderGIS
- BlenderGIS 教程 https://www.bilibili.com/video/BV1iz4y1k7EN
- 拾取坐标系统 http://api.map.baidu.com/lbsapi/getpoint/index.html
- 优秀建设计规划参考：EPP和Echo Investment联合开发的华沙Towarowa 22 https://www.bilibili.com/video/BV1V54y1t7WQ/
- OpenStreetMap 插件来完成一座城市的俯瞰景观制作 https://www.bilibili.com/video/BV1sc411h7Ds
- 纹理库 https://www.textures.com/category/buildings/1926
- https://www.sketchuptextureclub.com/textures/architecture/bricks


## 👉 Hard Ops 

Hard Ops Overview - Hard-surface Modeling in Blender 2.80+

Blender 2.80 硬表面建模插件 Hard Ops 概述 https://www.bilibili.com/video/av76067952/
Blender 3d Hard Ops 9 官方超精细建模教程 https://www.bilibili.com/video/av77995834
https://masterxeon1001.com/2019/03/06/hard-ops-0098-release-notes/

用于硬表面建模的套件，具有强大的布尔建模功能，可以方便的制作复杂的机械模型，以类似工业建
模软件的流程完成 ploygon 模型的制作。

Hard Ops 9 与 BoxCutter 是一对完美的建模组件，俩者也有二合一的旗舰版，Hard Ops 为了
与 BoxCutter 的整合，具了解官方花了 5000 多个小时研究开发，当然单独的 Hard Ops 工具
也为我们提供了一流的建模体验。


在对象浏览模式下，无选中物体时 Q 键打开快捷菜单为选项菜单，选中物体时为编辑菜单，如 Array 直接添加修改器:

- (S) Sharpen
- (C) Sharpen
- (T) Thick
- Mirror	(Alt-X)
- Array
- Operations
- Add Modifier
- MeshTools
- Settings
- Quick Favorites	(Q)

在模型编辑模式下 Q 键打开快捷菜单：

- Set SSharp
- Bweight
- Add Modifier
- Clean SSharps
- Mirror	(Alt-X)
- Operations
	- Add Modifier
	- Set SSharp
	- Bweight
	- Clean SSharps
	- Clean Mesh
	- Spin
	- Circle		(E)
	- Circle (Nth)	(E)
	- Grate (Face)
	- Knurl (Face)
	- Panel (Face)
	- Panel (Edge)
	- Star Connect
	- M Disp
	- Plugin
	- Reset Axis / Flatten
	- Booleans
- Flatten
- Material	(Alt-M)
- Quick Favorites	(Q)



## 👉 Box Cuttter 切割建模

Box Cutter 是非常强大的收费插件，比 Booltool 和 Hard Ops 更强大，基于布尔运算修改器进行切割建模。

Alt-W 激活 Box Cutter，使用快捷键 D 呼叫 Box Cutter 环形菜单，Ctrl-D 呼叫助手菜单 Behavior Helper。侧栏面板提供动态帮助信息 Sidebar - Tool - Help。

在对象模式下拖动光标直接创建几何，并给相关对象添加 Boolean 修改器进行布尔运算建模，几何盒子处于隐藏状态，可以在大纲视图操作。Box Cutter 会自动获取光标所在对象的法线方向，创建几何体时会根据法线方向锁定操作方向。用作布尔运算的几何体可以是正四面体、 球体，也可以自行绘制多边形定义，或者指定现有的模型。

在编辑模式下，拖动光标既可以对选中模型的指定部分并修改，Box Cutter 自动为你创建网格保持模型未选择的网格状态，像极了 Blender 在雕刻模式下的动态拓扑功能。

功能特色：

- 对象被切割，自动更新，将创建的对象
- 一个对象
- 多个对象
- 切割两个对象或将“画笔”应用到所有对象上
- 更准确的布尔运算。
- 改变工具
- 允许移动切割
- 多边形切割的“线”工具
- 允许改变圆的细分
- 创建模式
- 画刷模式
- 层次结构的对象

提供运算模式：

- Cut		剪切模式 就是布尔减法运算，从模型中减去操作指定部分；
- Slice		切片模式 切片模式会保留切掉的部分；
- Inset		内插模式 内插模式剥去一定厚度的表皮；
- Join		合并模式 合并模式就是布尔并集运算
- Knife		切割模式 在物体模式下看不出切割模式的效果，进入编辑模式看到切割在模型的表面卡线。
- Extract	提取模式 提取模式用于复用一些结构，R键可以用于旋转结构样本。
- Make		生成模式
生成模式即生成几何体，有点类似MAX的操作方式。注意：如开头所说，如果不点选要布尔运算的物体，那么所有模式都会变成生成模式。


## 👉 LoopTools 建模
- Blender自带的最佳插件 https://www.bilibili.com/video/BV1nS4y1Q7pJ

其它好用内置插件：

- Add Curve: Extra Object 使用 Curve -> Knots -> Torus Knot Plus 创建绳子
- Add Mesh: Extra Object 使用 Torus Objects -> Twisted Torus 制作绳子
- Object: Real Snow 给物体添加积雪，通过侧栏工具访问。
- Lighting: Tri-Lighting 给选中的物体添加三点布光，这是电影场景中常用的照明方案：Key/Fill/Rim 主光源/辅助光/轮廓光，后者也叫背景光 Back light。


LoopTools 提供以下功能

- Bridge 桥接：选择两段封闭的环形线段或两个表面，应用该功能，即可自动创建中间的连接面
- Circle 圆圈：选择一个点，或者一段环形线段，应用该功能，即可将与选中点相邻的环形线段或选中的环形线段调整位置形成一个圆圈
- Curve 曲线 选择一个环形线段中的多个点，或多个封闭环形线段，应用该功能，即可按线段的曲率平滑调整环形线段之间的点
- Flatten 碾平 选择任意相邻的点、线或面，应用该功能，即可将选中的部分调整成一个平面
- Loft 放样 类似 Bridge，选择多个封闭环形线段或表面，应用该功能即可在这些线段或表面之间产生过度的表面
- Relax 松弛 调整选中的多个面或线段，使其变得平滑
- Space 调整选中的顶点位置，让它们之间的距离比较平均
- Gstretch 挤压变形

示范：圆圆表面做圆柱突起：

- 添加 Sphere 球体；
- 选择要做突起的顶点，按住 Ctrl 或 Shift 多选；
- 给选中的边做 Edge -> Subdivide 细分出更多的边；
- 给选择的顶点执行 LoopTools -> Circle 做圆形化； 
- 按 , 打开变换操作的 Orientations 选项，指定为 Normal 即按法线方向变换操作；
- 按 E 挤出选择的顶点或面，按需要调整距离；
- 给挤出的面做碾平 LoopTools -> Flatten，按 Normal 方向的平面，也可以按 Normal 方向缩放为 0；

示范：Bridge 桥接做圆形穿孔：

- 选择 Cube 对立面；
- 按 I 进行 Inset Faces 内插面；
- 再进行 Edge -> Subdivide 细分出更多的边；
- 执行 LoopTools -> Circle 给顶点做圆形化；
- 执行 LoopTools-> Bridge 将两个对立面的顶点桥接起来，完成圆形穿孔。

类似地，也可以通过 Bridge 将圆形做成圆环。

如果不使用 LoopTools，操作步骤：

- 添加 Circle 对象，并且使用 Deform -> ShrinkWrap 修改器，将圆环吸附到圆体表面；
- 应用修改器，使用圆环顶点固定在球面上；
- 选中待修改的对象，和 Circle，按 Ctrl-J 合并；
- 进入编辑模式，将原有对象上的顶点进行预处理，选择多余的顶点，按 M 使用 Merge -> Collapse 坍塌为一个顶点；
- 将多余的顶点处理后，最后在圆环周边的顶点和圆环的顶点数量一致；
- 选择圆环上的顶点，还有周边等数量的顶点，执行 Edge -> Bridge Edge Loops 桥接循环边。
- 如果圆环上的顶点与待连接的顶点距离够近，也可以使用 By Disntace 选项进行顶点合并。
- 完成桥接后，就可以对圆环上的面进行挤出等操作。

另一种方法是使用布尔运算修改器 Generate -> Boolean Modifier，执行 Operation -> Union 将模型二合为一，Box Cutter 就是利用布尔运算进行快捷建模的插件。


## 👉 BlenRig 绑定和蒙皮
- Blender2.8 官方教程 角色绑定 https://www.bilibili.com/video/BV1QZ4y1W7U3?p=34

blenrig 具有可调节的能力，能够改变比例以适应现有的模型，或者基于以前的绑定网格来创建新的角色。

blenrig 对于绑定控制能够展现出广泛的能力。用户能够在fk、ik、hinge和stretchy之间进行选择，每一种模式都能够被独立激活，以满足不同的身体部位需求。

blenrig绑定系统由armature和粗略模仿网格变形的身体晶格（strategically modeled mesh deform body cage）组成。通过这个系统，用户能够以绘制少量权重或根本不绘制权重就能蒙皮角色。

blenrig绑定使用blender默认的约束和驱动来构建，为了能够访问专门的用户界面，附加的blender addon可以被安装。在专门的用户界面上，你能够直接操作不同的绑定控制模式，以及一些额外的功能，例如绑定烘焙按钮。



# 🚩 Blender UI 界面基础操作
- https://docs.blender.org/manual/en/latest/editors/properties_editor.html

用户界面的提供在线帮助，右键任何界面元素，包括弹出菜单，点击 Online Manual。

勾选配置 System -> Memory & Limits -> Global Undo，否则创新三维对象时不能修改默认参数。

在笔记本上操作时，因为 Windows 系统有触摸板防误触功能，触摸板会在使用键盘时无法响应输入，这个功能
是避免在打字时误触操作。在 Windows 中，可以进入“电脑设置”→“电脑和设备”→“鼠标和触摸板”，修改 
*触摸板延时* 或 *触摸板敏感度*。如果打字为主，就需要降低敏感度，因为这个选项其实就是为触摸板增加了
一个“呆滞时间”，也就是说即使输入过程中误碰到了触摸板，只要用户仍处于高速打字状态，触摸板就会自动
忽略此次“误碰”，从而解决这个令人尴尬的小麻烦。

对于需要相互配合操作的 Blender 界面，则需要提高敏感度，以方便 3D 视图上的操作。偏好设置中，开启
模拟 3 键鼠标选项或数字小键盘，视图中按住 Alt-LMB 并拖动可模拟鼠标中键，方便使用笔记本操作。

	Input - Mouse - Emulate 3 Buttons Mouse ，Emulate Numpad

除了菜单，Blender 主要是通过各种编辑器提供的界面，可以分为四类：

- General
	- 3D Viewport
	- Image Editor
	- UV Editor
	- Compositor
	- Texture Nodes
	- Geometry Node Editor
	- Shader Editor
	- Video Sequencer
	- Movie Clip Editor
- Animation
	- Dope Sheet
	- Timeline
	- Graph Editor
	- Drivers Editor
	- Nonlinear Animation
 - Scripting
	- Text Editor
	- Python Console
	- Info Editor
 - Data
	- Outliner
	- Properties
	- File Browser
	- Asset Browser
	- Spreadsheet
	- Preferences


## 👉 Quick Favorites & Menu Search

Quick Favorites 和 Menu Search 是 Blender 提供的菜单快捷访问方式。

使用快捷键 F3 打开菜单搜索面板，输入菜单名称，可以进行模糊搜索。例如：View ▶ Frame Selected
菜单用于剧中显示当前选择的对象，就可以搜索 `fs.`，后面的句点是它的快捷键。

Quick Favorites	(Q) 用于记录用户喜好的快捷菜单列表，在不同工作模式下，使用独立的列表。
Menu Search 中搜索到的菜单命令可以添加到喜好列表中，通过右键菜单操作。

例如，Toggle Local View 用于切换对象的局部视图，将它添加到喜好列表中，需要使用时，
就可以按下 Q 键打开快捷菜单，比起通过菜单定位的方式更快捷。


## 👉 Annotations 标注线
- https://docs.blender.org/manual/en/latest/interface/annotate_tool.html

Annotation 工具用于多种编辑器视图中画标注线，这些标注线不会被渲染，只是一种提示功能，比如，
蜡笔绘画中给 Character turnaround sheet 标注比例线，方便确定人物比例的准度。

按住 Toolbar 标注线工具，会弹出多个子工具，即不同的标注线绘画方式：

01. **Annotate** - Draw free-hand strokes in the main area.
02. **Annotate Line** - Click and drag to create a line. 
	Optionally, you can select the arrow style for the start and end of the line.
03. **Annotate Polygon** - Click multiple times to create multiple connected lines,
	then press [RMB], [Return] or [Esc] to confirm.
04. **Annotate Eraser** - Click and drag to remove lines. 
	The eraser has a Radius setting found in Tool Settings.

使用 Annotate 自由画线工具也能画直接，先点击 [LMB] 再按 [Ctrl] 即临时切换为单方向画线模式，
如果先再按 [Ctrl] 点击 [LMB] 则是切换为擦除绘制模式。

在不同的编辑器视图下，根据标注对象的不同，标注线可以按不同的方式放置，**Placement** 设置为
**Surface**方式，绘画的线条就会贴近几何曲面上，如果没有在几何体表面上画线，就按**3D Cursor**
方式放置线条。

Blender 中可以有多标注线对象，它们使用图层的方式来记录线条数据，在侧栏面板**Annotation Layer**
中可以切换所使用的标注线对象，以及要使用的图层，这些图层可以在多个视图中共享，但是所画线条只在原先
绘画时的视图中才会显示。

除了使用擦除工具删除标注线，也可以使用直接删除关键帧来清除所有标注线，在标注图层面板中进行操作。

标注线图层面板还可以设置标注线的精细和透明度，以及洋葱皮功能，Sidebar ‣ View ‣ Annotations：

- **Opacity** - Adjusts the opacity of existing and new strokes.
- **Thickness** - Adjusts the thickness of existing and new strokes.
- **Onion Skin** Shows a ghosted image of strokes made in frames before and after the current frame. Onion skinning only works in the 3D Viewport and Sequencer.
	- Before/After - Color to use before and after the current frame on ghost frames.
	The number defines how many frames to show before and after the current frame.

使用稳定器，Stabilize Stroke 可以让线条更平滑，平滑半径和系数越大，线条越平滑。

侧栏面板提供了标注线工具的设置 Tool Settings：

01. **Color** - Adjust the color of existing and new strokes.
02. **Annotation Layer** - A pop-over menu, showing the name of the current layer, to access the Annotation Layers.
03. **Placement** - Determines where the annotations are drawn.
	- **3D Cursor** : Draw on an imaginary plane that goes through the 3D Cursor and is aligned to your view.
	- **Surface** : Draw onto the surface of the object under the mouse in 3D Viewport. If there is no surface, you get the same behavior as 3D Cursor.
	- **Image** : Only available in 2D editors such as the Image Editor. The annotations become part of the 2D space, meaning their position and size change as you pan and zoom in the editor.
	- **View** : The new annotations are 2D and get stuck to the screen. They keep the same position, rotation and size no matter how you pan, orbit or zoom in the editor.
01. **Stabilize Stroke** - Helps to reduce jitter of the strokes while drawing by delaying and correcting the location of points.
02. **Radius** - Minimum distance from the last point before the stroke continues.
03. **Factor** - A smooth factor, where higher values result in smoother strokes but the drawing sensation feels like as if you were pulling the stroke.





## 👉 User Library 用户资产管理
- https://docs.blender.org/manual/en/latest/files/index.html
- https://code.blender.org/2020/03/asset-manager/
https://code.blender.org/2021/06/asset-browser-project-update/
- Asset 资产即已固化数据块，方便重用，通常包含在资产库中。资产可以是图像、模型、材质等等有用的数据。
- Asset Catalog 资产分类，是用于管理资产的目录。
- Asset Library 资产库就是操作系统中用于存放资产数据文件的目录，可以在喜好配置中修改路径。
- Asset Metadata 资产相关的信息数据，如资产分类、描述、作者、预览图乖乖。

资产可以在两个位置进行管理：

- 用户系统目录 User Presets
- 当前工程文件 Project Assets data-blocks

![Database asset](https://code.blender.org/wp-content/uploads/2020/03/database-asset.png)

每一个 .blend 文件可以看作是一个数据库文件，它包含各种数据块，objects, textures, materials, … 

Blender 不支持往其它 blend 文件写入数据，而用户资产工具就提供了一个方便引用其它 blend 文件数据
的方法。如果要使用 User Library，就需要将包含有资产的 blend 文件放置在指定的资产库目录下，这样
就可以被其它 blend 读取并使用相关的资产数据。

资产管理的引入，是 Blender 发展过程中的一个里程碑，早期就开始用来做姿态管理：

- Asset Manager: An early, high-level introduction to some core ideas of the design.
- Pose Library v2.0: The new pose library design built on top of the Asset Browser.

在几何节点编辑器、材质编辑器中，在选择列表中使用右键菜单，Mark As Asset 将其标记为资产。


## 👉 Editor Areas 编辑器区块

编辑器左上角可以按需切换到不同的编辑器视图，比如3D视图、UV编辑器、材质节点、合成、动画摄影表......

每个编辑器视图有不同的标题菜单、左侧的快捷工具、右侧的属性面板。3D 视图中，根据不同的 2D 对象、 
Mesh 对象、 Nurbs 曲面、 Grase Pencil 蜡笔对象，标题栏提供有对应的各种模式，主要是编辑模式
 Edit Mode，对象选择模式 Object Mode 是常态模式。不同的模式有不同的工具、编辑菜单对应。

	- 区域的拐角上按下 Ctrl-LMB ，向目标区域拖动，然后释放鼠标，交换两个区域的内容。
	- 将鼠标放在编辑器面板交界处，按下鼠标左键可以左右或上下调整编辑器窗口的大小。
	- 编辑器的四个角上，按住鼠标左键往窗口内部拖动就会增加一个编辑器，按住 Shift 拖动可以开新窗口。
	- 如果在边角位往外部拖动就会合并掉不需要的编辑器.
	- 对于显示不全的菜单，可以通过鼠标滚动。

	- Ctrl-Spacebar	切换区域最大化 Toggle Maximize Area。
	- Ctrl-Alt-Spacebar	区域全屏切换 oggle Fullscreen Area
	- Ctrl-PageDown/PageUp 切换工作区
	- T 弹出编辑器快捷工具
	- N 弹出编辑器侧栏导航菜单
	- Z 弹出 3D Viewer 的着色选项
	- F2 重命名对象
	- F3 查找并执行命令

## 👉 Editors 编辑视图分类

- General

	- 3D Viewport		3D 视图 Shift-F5 用于与3D场景交互以用于各种目的，例如建模、动画、纹理绘制等。
	- Image Editor		图片编辑器 Shift-F10 可以查看/编辑图像或纹理等2D资源的地方。
	- UV Editor			UV 贴图坐标编辑器 Shift-F10 将图像/纹理等二维素材映射到三维物体，并编辑所谓的 UV。
	- Shader Editor		材质着色器 Shift-F3 编辑用于渲染的材质，着色器编辑器的主窗口是节点编辑器。
	- Texture Nodes		纹理编辑器 Shift-F3 将颜色、图案和其他纹理组合在一起来实现纹理创建，相当材质节点。
	- Compositor		合成器 Shift-F3 对一张图片或视频进行自由的组合和增强处理。
	- Video Sequencer	视频剪接编辑器 Shift-F8 编辑视频，视频序列编辑器(VSE)，有时也简称为序列编辑器，合成器也可以编辑视频。
	- Movie Clip Editor	影片剪辑编辑器 Shift-F2 做镜头追踪或制作遮罩影片，用于 3D 场景与视频的后期合成。

- Animation

	- Dope Sheet		摄影表编辑器 Shift-F12 提供关键帧的鸟瞰图，传统的手绘动画制作使用用曝光表或摄影表准确显示每个绘图，声音和相机移动的时间以及持续时间。
	- Timeline			时间轴编辑器 Shift-F12 由时钟图标标识，用于操作关键帧和擦除播放头，传输控制，播放，暂停和跳过动画序列。
	- Graph Editor		曲线图编辑器 Shift-F6 调整任何可动画化的属性的动画曲线，函数曲线。
	- Drivers Editor	曲线驱动编辑器 Shift-F6 允许用户使用另一个属性驱动一个属性，驱动器通过函数来控制属性值。
	- Nonlinear Animation	非线性编辑器

- Scripting

	- Text Editor		文本编辑器 Shift-F11 用来编写 Python 脚本、着色器脚本。
	- Python Console	脚本控制台 Shift-F4 执行 Python 命令的快速方法，可以访问完整的Python API、查询命令历史记录和自动补全。
	- Info Editor		记录执行的操作、警告和错误消息。

- Data

	- Outliner			场景大纲   Shift-F9 组织 blend 文件中各种数据的列表，场景数据、视频编辑器数据或存储在 blend-file 中的任何对象。
	- Properties Editor	属性编辑器 Shift-F7 编辑各种活动数据、对象属性，包括活动场景和物体。
	- File Browser		文件浏览器 Shift-F1 与文件相关的操作，如打开和保存 blend 文件，导入/导出其他文件格式，为现有的文件路径选择新的位置。
	- Preferences		偏好设置 更改 Blender 的默认配置，也可以通过编辑菜单操作。



## 👉 Viewport & Bizmo 视图漫游操作

- Ctrl-AccentGrave	切换 Gizmo 漫游操纵器

	Gizmo 可以在编辑器的右上角找到，提供 切换投影、 切换相机视图、 平移3D视图、 缩放3D视图操作按钮。
	将鼠标悬停在小控件上并拖动 LMB 将旋转视图。 单击任何轴标签将 对齐 到该视图。 再次单击同一轴标签
	将切换到同一轴的另一侧。

- Orbit 视轨

	菜单:	视图(View) ‣ 漫游(Navigation) ‣ 视轨(Orbit)
	快捷键:	MMB, Numpad2, Numpad4, Numpad6, Numpad8, Ctrl-Alt-Wheel, Shift-Alt-Wheel

	围绕着兴趣点旋转视图。在视图区域内单击并拖动 MMB，如果从区域的中间开始上下或左右移动，那么操作
	视轨，视图就会绕着区域中间旋转。

	要以以离散步长改变视角，请使用 Numpad8 和 Numpad2 或使用 Numpad4 和 Numpad6 从当前视角
	围绕全局 Z 轴旋转场景。 最后 Numpad9 切换到视图的另一侧。

- Pan 平移，对于那些没有鼠标中键的用户，开启模拟 3 键鼠标后，可以按住 Shift-Alt 同时拖动 LMB。

- Zoom 缩放

	菜单:	视图(View) ‣ 漫游(Navigation) ‣ 放大(Zoom In)/缩小(Zoom Out)
	快捷键:	Ctrl-MMB, Wheel, NumpadPlus, NumpadMinus

	前后移动相机，滚轮鼠标，也可以通过 Wheel 来缩放。可以按住 Ctrl 并拖动 MMB 来放大和缩小。
	开启模拟 3 键鼠标时可以 Ctrl-Alt-LMB 拖动进行缩放。

- Smooth Zoom 滑动缩放

	在大多数情况下，它足以缩放视图以仔细查看某些内容，但是，缩放到某一点时，无法更近距离地缩放。

	这是因为Blender存储了一个用于视轨和缩放的视角。 它在许多情况下运行良好，但有时会希望将视角
	移动到其他位置。 这是滑动缩放(Dolly Zoom)支持的，允许将视图从一个地方传输到另一个地方。

	可以通过按住 Shift-Ctrl 并拖动 MMB 来回滑动。

- Fly & Walk 飞行/行走模式

	- Shift-AccentGrave	Fly & Walk 飞行/行走模式，AccentGrave 即重音符，按键 Tab 上面那个。

	在某些情况下，最好使用第一人称控制视角漫游，尤其是对于大型环境，如建筑模型。 在这些情况下，围绕
	视图中心的视轨作用有限。 虽然可以使用缩放、平移和滑动，但这很不方便。

	使用行走/飞行模式，可以在场景中各处漫游，并会从相机位置旋转视角，常见用例包括：

	- 漫游 这可以是漫游大型场景的快捷方式。
	- 相机机位 当相机视图激活时，这也会移动摄像机。
	- 录制动画 移动具有自动关键帧和播放动画功能的相机将记录运动，允许记录走过的场景。

	激活行走模式时，鼠标指针会移动到视图的中心， 并且会出现十字准星标记，它结合使用键盘箭头键和鼠标移动。

	- 移动鼠标调整视角。
	- 箭头键或 W， S， A， D 前后移动和左右挪动。
	- 传送 Spacebar 会将相机移动到十字准线的位置(偏移值由 偏好设置 中设置的 视角高度 值确定)。
	- 使用 Tab 在 自由 和 重力 模式之间切换。
	- 重力模式可跳跃 V。
	- 自由模式可上下移动 Q  E 。
	- WheelUp 或 NumpadPlus 增加此次开启的会话中的移动速度。
	- WheelDown 或 NumpadMinus 减小此次开启的会话中的移动速度。
	- Shift (按住)——暂时加速运动。
	- Alt (按住)——暂时减速运动。

	激活飞行模式时，光标位于定义为安全区块的矩形中心。 当光标位于此区块之外时，视图将旋转/平移。

	- 将鼠标沿着想要查看的方向，移动到安全区块之外。
	- WheelUp 或 NumpadPlus 加速向前移动。
	- WheelDown 或 NumpadMinus 加速向后移动。
	- MMB 拖动平移视图相机。
	- Shift 刹车模式(减慢变动)。
	- Ctrl 乘客模式(视图相机转动不影响其运动方向)。
	
	当对新视图感到满意后，按 LMB 确认。按下 Esc 或 RMB ，返回初始位置。

- 四格视图切换 Ctrl-Alt-Q

	编辑器视图区域切换四格视图菜单， View - Area - Toggle Quad View
	侧栏区块显示切换四格视图 Sidebar region - Display - Toggle Quad View

	切换四格视图将把 3D 视图分成 4 个视图：3个 正交侧视图和一个摄像机/用户视图。该视图模式允许从
	多个视角立即查看模型。可以独立缩放和平移每个视图，但是无法旋转视图，它们共享相同的显示选项和图层。


滑动缩放 Dolly Zoom Shift-Ctrl-MMB 

在大多数情况下，它足以缩放视图以仔细查看某些内容，但是，缩放到某一点时，无法更近距离地缩放。 这是
因为 Blender 存储了一个用于视轨和缩放的视角。 它在许多情况下运行良好，但有时会希望将视角移动到
其他位置。 这是滑动缩放 Dolly Zoom 支持的，允许将视图从一个地方传输到另一个地方。

在调整场景的活动摄像机视图时注意，特别在那些模型距离超大的场景中，比如模拟比较真实的太阳系星系距离，
可能很难定位到目标对象。摄像机有一个基本的位置坐标，在 0 旋转的情况下是从 +Z 往下看的 Top 视图。
可以选择场景活动摄像机，然后给它指定到模型就近的坐标上再调整。

另一个方法是使用 3D Cursor 光标辅助定位，通过侧栏视图面板设定 View - Lock to 3D Cursor，
再设定 3D Cursor 的 Location，Rotation 可以定位后再调整。快捷键 Shift-S 快速设置 Cursor 位置。


## 👉 Camera View 相机视图
Object Modes https://docs.blender.org/manual/en/latest/editors/3dview/modes.html

3D View 默认的工作模式，Object Mode，其实图菜单提供了摄像机导航工具，Navigation Gizmo
是最基本的导航工具，提供通用的基础视角控制功能：

1.   Zoom the 3D Viewport
2.    Pan the 3D Viewport
3. Toggle the Camera View
4. Toggle the Projection
5. Viewpoint Switcher

另外，还提供了 Fly/Walk Navigation 两种运动导航，可以控制飞行速度和方向，视图锁定时不能使用。
以下是常用的视角切换功能：

01. Zoom Region (Shift B) 区域放大
02. Dolly View (Shift Ctrl Alt LMB) 推拉视图。
03. Frame All 切换到全景视角，可以看到所有对象。
04. Frame Selected 视角聚焦到选中的对象，等价于 View Selected。
05. Toggle Local View (Numpad /) 切换到对象局部视图，临时隐藏无关对象。
06. Remove from Local View (Alt Numpad /) 将对象临时从局部视图中移除。
07. Frame Camera Bounds (Home) 将视图缩放到相机边框大小。
08. Toggle Quad View (Ctrl-Alt-Q) 显示四分法上下文视图。

除了场景中的 Camera 对象，场景中还有一个隐藏的相机，只要没有激活当前相机视图，就是使用隐藏的相机。
这也是最常使用的视图，Gizmo 就是操作这个隐藏相机的工具，鼠标也可以操作这个隐藏的相机镜头和位置：

01. MMB 拖动改变相机朝向。
02. Alt-MMB 点击，移动相机剧中显示点击位置。
03. Alt-MMB 拖动，切换到正视图，Top、Bottom、Left、Front 等等。
04. Ctrl-MMB 推拉相机镜头，不移动相机，使用滚轮也可以操作。
05. Ctrl-Shift-MMB 推拉视图，前移、后移相机位置，Dolly View (Shift Ctrl Alt LMB)。
06. Shift-MMB 平移相机。

视角对齐 View ‣ Align View 用于移动摄像机的视角：

01. Align View to Active 将场景的活动相机视角对齐到当前活动对象。
02. Align Active Camera to View (**Ctrl-Alt-Numpad0**) 将活动相机的视角与当前视图角度贴合。
03. Align Active Camera to Selected 将活动相机对齐到当前选中的对象，保留朝向角度。
04. Center Cursor and Frame All (**Shift-C**) 切换到全景视角，并将 3D 光标居中。
05. Center View to Cursor 将视图剧中到 3D 光标位置。
06. View Lock to Active 将视图锁定到活动对象，视图旋转总是心目标对象为中心。

视图区域裁剪 View Regions 用来定义裁剪显示区域，或者渲染时要出图的区域：

1. Clipping Region (Mark and Clear: Alt-B)
2. Render Region (Mark: Ctrl-B Clear: Ctrl-Alt-B)

Clipping Region 定义的剪裁区域，将三维视口显示限制为三维空间的一部分，以处理复杂的模型和场景。
激活工具后，用鼠标绘制一个矩形，它变成了一个由四个平面组成的剪裁体积：

1. 如果视图是正交的，则为直角平行六面体（无限长）。
2. 如果您的视图是透视的，则为基于矩形的金字塔（高度无限）。

在线框或实体着色模式下使用剪裁，将只能看到您定义的体积内部的内容。绘制、雕刻、选择、变换捕捉等
工具也会忽略剪裁边界之外的几何体。



相机视图可用于虚拟合成镜头并预览渲染时场景的外观，渲染图像将包含虚线内的所有内容。执行在渲染时，活动
相机的视口会被渲染输出。当前活动相机所在的对象，可以通过场景属性面板的摄像机属性指定，或通过大纲视图层
列表 Outliner - View Layer 中的摄像机指定，只需要将摄像机对象的层级展开，单击里层的 Camear 
对象激活即可。通过选择菜单获取 Select - Select Active Camera 选中当前摄像机对象。

使用反引号按键打开 View 环形菜单可以快速切换视角，View Camera 即切换到场景的活动相机视角。
又或者使用 View Selected 切换视角到当前选中对象。

场景存在多个相机时，可以在场景树列表中，点击相机对象条目的摄像机图标以激活它作为活动相机。
每个相机对象都有一个相机数据，它决定的相机视角看到的是什么内容，相机对象的数据属性面板可以随时
改变相机使用的数据对象。View ‣ Cameras ‣ Set Active Object as Camera (Ctrl-Numpad0)
菜单也可以设置相机数据对象。

设置摄像机属性：Object Data -> Background Images，可以指定摄像机视角下呈现的背景图，
可以是图形或者视频。使用视频，Depth 属性指定背景的显示方式，或在所有对象背后，或前面显示。 

配合好 Compositing 进行后期处理，将背景图与 2D 绘画内容融合。


利用相机不同位置和角度的变化获得不同的画面，是动画制作的常用手段。注意，每个场景只能设置一个活动相机。
如果要使用多个相机，就需要配合多个场景，或者在场景属性面板中设置活动相机以渲染需要的相机画面。

可以使用跟随路径约束 Follow Path Constraint 来让相机按曲线目标物体运动，使它沿着曲线或路径移动。
当跟随曲线 Follow Curve 选项启用，它也可以影响它的自身的旋转遵循曲线的弯曲。 可用于复杂的相机漫游，
火车在轨道上和大多数其他车辆也可以使用无形轨道，自行车链等。

Blender 支持从高端 3D 显示器到简单的红蓝色眼镜，立体视觉 Stereoscopic 管道的一个重要组成部分
是能够以适当的显示方式显示立体图像。在 3D 视图得侧栏面板 View 中，可以设置 Stereoscopy 立体视觉
图层，即通过 3D 眼镜观看得立体效果，可以选择 Left/Right/3D 图图像得显示，可以渲染输出左右眼相应
的红色/蓝色偏移图层。参考渲染输出属性设置，勾选 Stereoscopy 立体视觉激活。

再操作 Blender 3D 视图过程中还有一个隐藏的相机，在将视图切换到场景内的 Camera 对象视图之前，
就是这个内置的相机提供的视图。这个相机的参数修改需要通过 N 侧栏提供的 View 视图面板进行修改：

- Focal Length 焦距；
- Clip Start/End 视距钳位，设定可视范围； 
- Use Local Camera 给当前视图中 Camera View 指定一个对象，而不使用场景设置的活动相机；
- Render Region 限定渲染框内的部分，使用 Ctrl-B 和 Ctrl-Alt-B 绘制、清除渲染限制区；
- Clipping Region Alt-B 切换视图裁剪框，剪裁框限制 3D 空间的一部分，帮助简化处理复杂的模型和场景。
- Lock to Object 视图聚集、锁定到选中物体，以指定对象为视图的中心，可对其进行观察，快捷键 /；
- Lock Camera to View 锁定相机到视图，在相机视图中的所有更改，平移、旋转、缩放都将影响活动相机位置。 

模型对象可以设置作为相机视图使用，比如将一个 Cube 设置为活动相机，视图将以这个对象为相机视图的观察点。

相机按镜头类型分类如下，其中全景相机仅适用于 Cycles，分成三类，这些全景效果会在最终渲染的时候生效，
或快捷键 Z 打开 Rendered 实时渲染模式。

- Perspective 透视相机
- Othergraphic 正交投射
- Panoramic 全景相机
	- Equirectangular 等距柱状投影 ERP
	- Fisheye Equidistant 等距投射鱼眼镜头
	- Fisheye Equisolid 等角投射鱼眼镜头
	- Mirror Ball 镜像球

Perspective 透视相机与现实世界视觉匹配，距离中的物体看起来比前景中的物体小，并且平行线看起来会
随着它们越来越远而收敛，例如铁路上的铁轨。

Othergraphic 正交透视物体，无论距离如何，始终以实际尺寸显示。这意味着平行线看起来是平行的，并且
不会产生像透视那样的效果。

等距柱状投影 ERP - Equirectangular Projection，也叫 Equidistant Cylindrical Projection，
Geographic Projection，从摄像机的位置来渲染场景的全景视图，并使用等矩形投影，始终在 X 轴上渲染
整个 360°，在 Y 轴上渲染 180°。此投影与用于世界着色器的环境纹理兼容，因此可用于渲染环境贴图。

Fishieye 鱼眼镜头通常是具有强失真的广角镜头，可用于创建全景图像，例如圆顶投影，或作为艺术效果。
视野角度 360° 以上才能捕捉到整个环境。有平面投影 Stereographic，等距投射 Equidistant，等角
投射 Equisolid angle，正交投射 Orthographic 几种投射方式。

Mirror Ball 镜像球就是渲染拍摄镜像球的照片。与拍摄环境的相似照片相比，这在极少数情况下非常有用。

镜头焦距 Lens 是个很重要的成像参数，根据透镜的成像物理意义，焦距越大，可视距离越远，视场角 FOV - 
Field of View 越小，获得对象局部细节越细，相当放大。焦距越小，可视距离越近，视场角越大，同样的
画幅可以包含越多的内容，鱼眼镜头就是视场角超大的镜头。两者的区别可以用一张 A4 纸来比喻，焦距大相当
将远处山上的棵树画在纸上，焦距小相当将整座山画在纸上。

一般按镜头视角分类，广角镜头视角 90° 以上，观察范围较大近处图像有变形。标准镜头视角 30° 左右，
使用范围较广。长焦镜头视角 20° 以内，焦距可达几十毫米或上百毫米。例如 Cannon PowerShot S3IS 
变焦 Zoom lens 数码相机号称 12 倍光学变焦，相当于焦距可以从 36mm ~ 432mm 间调整。

摄像机对象可通过调整翻转，平移，滑动，和跟踪相机对象属性获得合适的视口，也可通过记录相机的动画
关键帧来实现镜头动画。先选择相机对象，以便对其应用变换操作，以下操作还假定处于相机视图中：

- 按 R 进入物体旋转模式。默认情况下，它将绕自身 Z 轴旋转旋转相机，与相机视图垂直的轴。
- 垂直平移或倾斜，这只是沿局部 X 轴的旋转。 多次按 X/Y/Z，将轴向锁定为全局轴、局部轴。
- 水平平移或偏向，这相当于沿相机局部 Y 轴的旋转。 按 R，然后按两次 Y。
- 滑动相机，按 G 进入相机对象移动操作，然后 MMB 拖动或按两次 Z 进入局部 Z 轴移位。
- 侧向跟踪，按下 G 并移动鼠标，或按 X 两次又或者 Y 两次来获得纯水平或纯垂直的侧向跟踪。

也可以在切换到相机视图后可以激活飞行/步行模式模式，这样可以很方便调整机位，得到想要的视口。

- Numpad0 视图菜单使用活动相机视图 View - Cameras - Active Camera
- Ctrl-Numpad0 设置活动相机 视图菜单设置活动相机 View - Cameras - Set Active Camera

渲染过程中还有一个活动摄像机镜头，选中摄像机后，在属性编辑器的 Object Data Properties 中设置：

- Lens 设置镜头参数
- Depth of Field 景深设置，勾选激活，景深区域前后的物体会模糊不清。
- Camera 提供匹配真实相机的预设，其传感器尺寸设置是控制焦距的另一种方法，与物理相机和镜头组合相匹配非常有用，例如用于运动跟踪。
- Safety Area 安全区域是用于定位元素的指南，以确保可以在所有屏幕上看到内容的最重要部分。
- Background 相机中的背景图片非常有用，绘画时作为参考图片，或动画视频作为背景等。
- Viewport Display 视口显示配置。

真实世界的相机通过镜头传输光线，镜头将光束弯曲并聚焦到传感器上。因此，距离一定距离的物体会聚焦，
但前后的物体会模糊不清。

焦点区域称为焦点，可以使用精确值或使用摄像机与所物体之间的距离进行设置：

- Focus Object 设置焦点到物体所在的位置，带滴管图标的控件可以在鼠标悬停时，按快捷键 E 调用。
- Distance 焦距，未指定焦点物体时，可以直接设置到焦点的距离，则在此距离处的摄像机视线上会显示黄色十字。
- 将鼠标悬停在距离属性上，快捷键 E 可以打开深度选择器，然后单击 3D 视图中的一个点以采样从该点到相机的距离。
- Apeture 光圈
	- F-Stop 光圈数值 光圈数值比率定义模糊量，较低的值会产生强烈的景深效果。
	- Blades 用于改变渲染中模糊物体形状的多边形刀片总数，以及渲染预览。与视口一样，启用散景效果的最小刀片数量为 3，导致三角形模糊。
	- Rotation 沿着面旋转多边形刀片，并以顺时针和逆时针方式旋转。
	- Ratio 更改失真比率以模拟变形散景效果，1.0 表示没有失真。

如果使用 Eeveee 渲染引擎，还需要结合 Render Peroperties - Depth of Field 景深设置，
景深在 eevee 里是作为后期处理效果完成的，设置背景虚化形状的最大尺寸，越低越快。

也可以使用合成器中的 Defocus 获得景深效果。运用 Z-Buffer 缓冲区输入连接端口在后期合成中模拟景深
 DOF 效果。当然也可以不连接 Z 深度通道端口对图像进行模糊操作。

Cycles 和 Eevee 渲染器配置中，勾选胶片的胶片透明 Film - Transparent 可以渲染带透明区的 PNG，
注意输出属性面板中的色彩空间要配合 RGBA


## 👉 Global Keys 全局快捷键

- Ctrl-O	打开文件。
- Ctrl-S	保存文件。
- Ctrl-N	新建。
- Ctrl-Z	撤销。
- Shift-Ctrl-Z	重做。
- Ctrl-Q	退出。
- F1	帮助 (上下文敏感)。
- F2	重命名活动项目。
- F3	操作搜索。
- F4	文件上下文菜单。
- F5 - F8	保留用户操作。
- F9	调整上一步操作。
- F11	打开渲染窗口。
- F12	渲染当前帧。
- Q	快速访问(收藏)。
- Ctrl-PageUp / Ctrl-PageDown	下一个/上一个 工作区。
- Spacebar	用户配置。
	- 播放:	切换动画回放。
	- 工具栏:	切换工具栏快捷键(Shift-Spacebar 播放)
	- 搜索:	搜索操作 (Shift-Spacebar 播放)。
- Shift-Ctrl-Spacebar	倒放动画(反向)。

区域的拐角上按下 Ctrl-LMB ，向目标区域拖动，然后释放鼠标，交换两个区域的内容。


## 👉 Common Shortcuts 通用快捷键

- 键盘

	在本手册呈现的字符快捷键，如下所示：

	G 等同于小写的“g"。
	Shift, Ctrl, Alt 特指修饰键。
	Ctrl-W, Shift-Alt-A, ... 表示应同时按下这些键。
	Numpad0 至 Numpad9, NumpadPlus 表示小键盘上的独立键位。
	其他键位如它们的名字一样 Esc, Tab, F1 至 F12. 需要特别注意的是，Left, Right 等。

- 鼠标

	本手册鼠标术语预定如下：

	LMB 鼠标左键
	RMB 鼠标右键
	MMB 鼠标中键
	Wheel 鼠标滚轮

	Blender 内置了两个选择物体的模式，左键选择和右键选择。使用右键单击选择可以清楚地区分用户执行
	选择和操作意图，在此模式下，RMB 鼠标右键通常用于选择，LMB 鼠标左键启动或确认操作。

- 悬停

	当悬浮(当鼠标放在一个输入框上时)。

- 属性

	Ctrl-C -- 复制输入框里的值(单个)。
	Ctrl-V -- 粘贴值进输入框(单个)。
	Ctrl-Alt-C -- 复制输入框里整个向量值或色彩值。
	Ctrl-Alt-V -- 粘贴整个向量值或色彩值进输入框里。
	RMB -- 打开上下文菜单。
	Backspace -- 清除值(归零或清楚内容)
	Minus -- 否定数值(乘以-1.0)。
	Ctrl-Wheel -- 递增变化。

	对于弹出选项菜单按钮，将循环选择。

	Return -- 选择菜单项或切换值。
	Alt -- 在编辑时按住，会把操作应用到所有选择项中。(如物体，骨骼，视频片段)。

	这对于数值栏或开关操作非常有用。可同时更改多个灯光亮度时，按住 alt 键，同时调节灯光亮度。

- Timeline 动画

	I 			-- 插入关键帧。
	Alt-I 		-- 清除关键帧。
	Shift-Alt-I -- 清除所有关键帧(移除所有F-曲线)。
	Ctrl-D 		-- 添加驱动。
	Ctrl-Alt-D 	-- 清除驱动。
	K 			-- 添加插帧集。
	Alt-K 		-- 清除插帧集。
	Ctrl-T 		-- 时间格式切换
	P 			-- 设置预览区
	Alt-P 		-- 清除预览区
	Ctrl-Home 	-- 设置回放范围的第一帧
	Ctrl-End 	-- 设置回放范围的最后帧

	Left/Right Arrow 左右箭头移动到上下帧。
	Up/Down Arrow 上下箭头跳到前后关键帧。

	Shift-Left Arrow 跳到开始帧
	Shift-Right Arrow 跳到结束帧

	Alt-Wheel Up/Down 逐帧移动播放头
	Spacebar 播放
	Shift-Ctrl-Spacebar 播放
	Esc 停止播放并回到上次播放起点

	Media Play/Pause 多媒体键控制播放/停止
	Media Last/First 多媒体键控制跳转到前后关键帧
	Media Stop 多媒体键控制停止播放


- Python脚本

	Ctrl-C 	-- 在任何 操作按钮 上，复制该按钮的 Python 命令进剪切板。
	Shift-Ctrl-C 	-- 在一个属性栏上复制该操作属性的调用路径。(也适用于上下文菜单)。
	Shift-Ctrl-Alt-C 	-- 在一个属性栏中复制 全部 数据块或属性值。

	需要注意在大多数情况下，最好根据正文而不是名称来访问值。

- 拖拽

	Ctrl 	-- 拖动时吸附倍数步长。
	Shift 	-- 精确控制拖拽的值。
	Shift-Ctrl 	-- 伴随高精度的移动物体时的精确捕捉约束。

- 文本编辑

	Home 	-- 到顶端。
	End 	-- 到末端。
	Left, Right 	-- 把光标移动一个字符距离。
	Ctrl-Left, Ctrl-Right 	-- 把光标移动一个单词距离。
	Backspace, Delete 	-- 删除字符。
	Ctrl-Backspace, Ctrl-Delete 	-- 删除文字。
	Shift 	-- 按住键并移动光标选择。
	Ctrl-A	-- 选择所有文本。
	Ctrl-C	-- 复制选择的文本。
	Ctrl-X	-- 剪切选择的文本。
	Ctrl-V	-- 在光标的位置粘贴文本。

- 确认和取消

	Esc, RMB -- 取消。
	Return, LMB -- 确认。



## 👉 3D View 三维视图
https://docs.blender.org/manual/en/latest/editors/3dview/modes.html

Blender 3D 视图有 9 种工作模式，可以在工作模式列表中切换，或者使用 Ctrl-Tab 打开模式切换菜单：

01. **Object Mode**
	The default mode, available for all object types. 
	Allows editing position, rotation and scale, duplicating objects, and so on.

01. **Edit Mode**
	A mode for editing an object’s shape (vertices/edges/faces for meshes, 
	control points for curves/surfaces, points/strokes for Grease Pencil, etc.).

01. **Sculpt Mode**
	Provides an alternative toolset for editing an object’s shape (only for meshes).

01. **Vertex Paint Mode**
	A mesh-only mode that allows you to set your mesh’s vertex colors 
	(i.e. to “paint” them).

01. **Weight Paint Mode**
	A mesh-only mode, dedicated to vertex group weighting.

01. **Texture Paint Mode**
	A mesh-only mode that allows you to paint a texture directly on the model, 
	in the 3D Viewport.

01. **Particle Edit Mode**
	A mesh-only mode dedicated to particle systems, useful for editable systems (hair).

01. **Pose Mode**
	An armature-only mode, dedicated to posing.

01. **Draw Mode**
	A Grease Pencil-only mode, dedicated to creating Grease Pencil strokes.

每种工作模式下，在大纲视图（Outliner）中，对象列表最左侧也会显示相应的图标，但是在对象模式下
不显示图标，其它工作模式都有不同的图标表示，其它拥有相同工作模式的对象会使用圆点表示。

3D View 提供了两种方便的操作：

1. Switching Objects
2. Multi-Object Editing

对象模式是默认的 3D View 工作模式，使用 Tab 可以切换到编辑模式。要保持当前工作模式并切换对象，
可以使用 Alt-Q 快捷键，配合鼠标悬停在目标对象上。

多对象编辑有两种使用方式：

1. 在对象模式下，按住 Shift 点击以选择多个要编辑的对象，然后进行编辑模式。
2. 在编辑模式下，按住 Ctrl 点击场景树（Outliner）中对象左侧的圆点，将对象添加到编辑模式。


使用 Edit - Lock Object Modes 可以锁定对象的工作模式，避免在意外点击其它对象时被切换。


- ~ 	AccentGrave	重音、波浪号、反引号按键，按住弹出视图导航 pie 菜单，按下松开旋转镜头。
- Ctrl-AccentGrave	切换显示操纵器。
- Shift-AccentGrave	步行/飞行模式。
- Tab	按住弹出模式切换菜单等效 Ctrl-Tab，按下立即松开切换编辑模式。
- Ctrl-Tab 切换模式 Pie 菜单(骨骼为切换动作模式)
- Z  切换渲染模式，按住弹出渲染模式菜单。

- Ctrl-Home 恢复视图查看全部
- Ctrl-Period 直接操作对象原点，勾选 Sidebar ‣ Tool ‣ Options ‣ Transform - Affect Only - Origins。
- Ctrl-NumpadPeriod 查看所选
- NumpadPeriod 聚集当前所选对象，View ‣ Frame Selected。视图导航菜单快捷操作 ~ -> View Selected。
- / 切换为选中物体局部视图 Local View，即最大化显示选择对象，暂时隐藏其它对象。
- Home 将所有物体最大化显示在3D视图中
- Shift-C 视图回到世界坐标中心。
- Shift-B 缩放选区，可以使用 MMB 拖拽出一个矩形，缩放框选区域。
- Alt-B 视图裁剪框 Clipping Region 线框或实体视图中定义剪裁框限制 3D 空间的一部分，可以帮助处理复杂的模型和场景。要删除裁剪，再次按 Alt-B 。
- Ctrl-B 清除: Ctrl-Alt-B 渲染框 Render Region 渲染着色模式中避免渲染整个视图，定义子区域以加速渲染，注意结合渲染设置的视图使用。

- Shift-Space 弹出编辑器快捷操作菜单
- Shift-S 3D Cursor 游标对齐/移动操作
- Shift-Tab 吸附模式 Snap
- Shift-Ctrl-Tab 吸附元素
- O	衰减编辑 Proportional Editing 是一种变换选定元素的方法，同时使该变换影响其他附近元素，使用滚轮调整操作区大小。
- Alt-O		是否只影响连接部分。
- Shift-O	Proportional Editing Falloff 选择衰减曲线

- A 全选
- Alt-A 不选
- Ctrl-I 反选
- H	隐藏选择。
- Alt-H	取消隐藏。
- Shift-H 只显示选择的模型。
- T	切换显示工具栏。
- N	切换显示侧栏。

- Shift-G 按组选择，编组和创建父级一样是用于管理多个物体间的物体与另一物体之间关系的方式，按组选择以活动物体为依据来选择其它相关联物体。
- Shift-L 选择相连元素，选择与活动物体共享同一个数据块的所有物体。
- Ctrl-J 合并选定物体

- Shift-Ctrl-M 镜像选择 选择指定轴向上镜像位置的元素。
- Ctrl-M 镜像物体或网格选中项将创建选中项的反转版本。选中项的镜像版本的位置由 轴心点 确定，按 X, Y 或 Z，沿特定的全局坐标轴镜像选中项。。

- Ctrl-A 可视变换 Visual Transform 应用约束结果并将其应用回物体的位置、旋转和缩放。
- X 删除
- M 移动对象到指定的集合
- G 对物体进行移动操作，附加操作参考状态栏提示，Alt-G 重置移动 Clear Move
- R 对物体进行旋转操作，附加操作参考状态栏提示，Alt-R 重置旋转 Clear Rotate
- S 对物体进行缩放操作，附加操作参考状态栏提示，Alt-S 重置缩放 Clear Scale，负值可以反转。
- W 选择模式，Tweak、 Box、 Circle、 Lasso 模式切换

- Shift-Alt-S To Sphere
- Shift-Ctrl-Alt-S Shear
- Shift-W Bend Angle

- Shift-A 添加对象
- Shift-D 复制 Duplicate
- Alt-D 关联复制 Duplicate Linked 复制链接副本

	物体关系菜单可以使对象独立化 Object - Relations - Make Single User，使已选或所有的
	物体数据块独立化意味着，在 blend 文件中不再共享(关联)其它物体的数据块

- Ctrl-L 产生关联项 Make Link 在不同场景或数据块中将所活动物体与所选物体进行关联。

- 轴向锁定，在操作时，通过键入 X, Y, Z 可以在变换过程中随时更改运动轴向。
- 轴向锁定还可以进入对象局部坐标，第一键入坐标轴时锁定的是全局坐标系，第二次键入时就切换到对象局部坐标系。
- 平面锁定，Shift-X, Shift-Y, Shift-Z 或 Shift-MMB 后，将鼠标移动到所需的方向。
  如移动对象时，Shift-X 锁定 X 轴，那么对象就只能在 YZ 平面移动。

在变换操作(例如移动、旋转、缩放)期间按住 Ctrl 将切换 变换吸附 。当 吸附元素 设置为 增量 时，变换的
程度将表现为离散状态。 在变换操作中按住 Shift 将使得物体以十分之一的速度变换，以达到精准控制。更
细致的可以按住 Shift 或 Shift-Ctrl。

对象的尺寸信息通过侧栏查看，N 快捷键打开 Item 面板，里面包含了基本的 Location、Rotation、Scale，
还有 Dimensions 尺寸信息，注意，属性面板不提供尺寸信息。

虽然使用鼠标进行变换很方便，但如果需要更精确的控制，也可以输入数字值。按快捷键后键入一个数字来表示
变换的大小，然后确认或取消。例如，依次按下 S 2 Return 会使物体比例加倍。Blender 支持简单模式和
高级模式。简单模式只接受简单的数字，除了选择项可以使用基本的文本编辑。在高级模式下，你还可以输入
表达式和单位。

- 简单输入模式

	- Period 来输入小数点。
	- Minus 对数值取负。
	- Slash 将输入的数字切换为其倒数，例如 2 / 结果是 0.5 (1/2)； 20 / 结果是 0.05 (1/20) 。
	- Backspace 删除所有前导字符后，输入数字将被取消，返回到通常的鼠标变换。
	- Tab 或 Ctrl-Tab 用来在要输入多个轴的数值时切换下一个/上一个组件。例如，要在一个物体所有的
	  三个轴移动一个Blender单位按下： G 1 和 Tab 1 和 Tab 1 。
	- 非数字输入，你还可以将数字输入与轴向锁定结合起来，以约束移动到特定轴或特定工具的快捷方式。

- 高级输入模式

	使用 = 或 NumpadAsterix 启用高级模式，Ctrl-= 或 Ctrl-NumpadAsterix 切换回简单模式。
	单位支持(cm 、 " 、 deg 等等)。
	Python/BKE_unit 的基本操作(+ 、 * 、 ** 等)，和数学常量和函数 (pi 、 sin 等)。
	按住 Ctrl 输入 Minus, Slash 或非数字。

用户可以使用物体或网格元素来自定义变换坐标系。Blender 自带五个预设坐标选项 Transform Orientations：

- Global 全局坐标 小部件匹配全局或世界坐标。视图右上角的轴以及栅格地面，指示了世界坐标系的轴向。
- Local 局部坐标 Gizmo 匹配物体坐标轴。当物体被旋转后，局部 Gizmo 的方向与物体相对全局的旋转轴向一致。
- Normal 法向坐标 Gizmo的Z轴将与选中元素点 法向 方向一致。如果选中多个物体，其朝向将与其平均法线方向一致。
- Gimbal 万向坐标 行为可以根据 旋转模式 改变。
- View 视图坐标 Gizmo 将匹配 3D 视图: Y 向上/向下，X 左/右，Z 朝向/远离屏幕。

Pivot Point 轴心点，当旋转或缩放一个物体或一组顶点/边/面时，可能需要移动轴心点，以便操作物体。
在任何 3D 视图的标题栏中使用此选择器，可以更改轴心点的位置。 编辑模式 中的边界框不考虑物体的原点，
仅考虑所选顶点的中心。

- , 变换方向菜单 Transform Orientations
- . 轴心点设置选项菜单 Pivot Point

在物体的变换操作时，平移/缩放/旋转或挤出操作，可以锁定到相对于当前变换坐标系的特定轴。通过将变换锁定
到特定轴，你将变换约束在单个维度进行操作。Blender 为属性保存了一个默认值 Default Value，对变换
结果不满意，可以使用 Alt-G、 Alt-R、 Alt-S 等快捷键回复移动、旋转、缩放的默认值，也可以使用属性的
右键菜单将属性的所以分量重置默认值：

- Reset All to Default Value ，
- Reset Single to Default Value

要将修改的结果应用到默认值，通过菜单操作，Object - Apply，或快捷键 Ctrl-A。

增量变换 Delta Transforms，可以在属性编辑器的对象属性找到，它是应用在变换之上的简单变换

	Properties Editor ‣ Object Properties ‣ Delta Transforms

增量变换在动画中特别有用，例如，可以使用基本变换动画化物体，然后使用增量转换将其移动到周围。

- Bounding Box Center
- 3D Cursor 是三维空间中的一个点，Shift-RMB 可以定点位置，可用于多种用途，如摄像机跟随，吸附，对齐点等等。
- Individual Origins 各自的原点，Ctrl-Period 设置原点。

	在 3D 视图中物体的原心显示为一个橙色小圆圈，用于指示该物体在 3D 空间中的相对位置。原点不一定
	要位于几何体(比如网格)的中心。这意味着物体的原点可以位于网格的一端，甚至完全位于网格的外部。

- Median Point 质心点 Ctrl-Comma

	质心点可以被认为与重心 COG - Center of Gravity 的概念大致相似。如果假设选中项的每个元素
	(物体、面、顶点等)具有相同的质量，则质心点将位于选中项重心的平衡点。

- Active Element 活动元素 Alt-Period

	活动元素 可以是物体、顶点、边或面。活动元素是最后一个被选中的元素，当在 物体模式 时将以黄色
	显示活动元素，而在 编辑模式 时显示为为白色。使用 活动元素 作为 轴心点 时，所有变换将相对于
	活动元素发生。


## 👉 Object Relations 模型对象关系

在复杂的模型中，管理大量对象，需要使用物体父子关系，这是常规的对象关系 Object Relations。例如，
对人体进行建模时，身体模型可以作为四肢的父级 Parent，身体的移动、缩放、旋转都会影响到子级对象。

- **Object Parent** 对象父级
- **Bone Parent** 骨骼父子关系，允许将骨架上的某些骨骼设为另一个物体的父级物体。
- **Vertex Parent** 顶点父级，网格物体的顶点或也可以用作其他物体的父级，如将一个物体设置父级到
  一个顶点或一组的三个顶点，这样，当父网格变形时，子级将会随之移动。
- **Vertex (Triangle)** 顶点父级，三角面父级


移动、 旋转或缩放父级意味着也同时移动、旋转、缩放子级物体，影响的方向是从父级到子级和而不是子级到父级。

为了观察到对象内部的坐标指向，可以使用快捷键 Ctrl-Period 打开对象的原点编辑模式，直接操作对象原点，
移动或旋转。通过 N 打开侧栏属性面板的工具选项设置：

	Sidebar ‣ Tool ‣ Options ‣ Transform
	- Affect Only - Origins 直接操作对象原点。
	- Affect Only - Locations 则只能对位移变换操作，而不能进行旋转或缩放。
	- Affect Only - Parent 表示只对父级对象进行变换操作，不影响其子级物体。

设置父级，至少选择两个物体，最后选择对象，以亮橙色表示的将作为父物体。然后按 Ctrl-P 弹出菜单设定
父级目标，Set Parent to，允许你从几种可选的不同的父子类型中选择一种。设定父级目标根据上下文差别，
根据选择的物体不同而不同，各种后选项如下：

- **Object** 将最后选择对象，以亮橙色表示的将作为父物体；
- **Object (Keep Transform)** 为子级物体保持原变换数据，在解散关系时可以选择恢复；
- **Object (Without Inverse)** 建立无父级反校正矩阵的父级关系，子级物体以父级的局部参考系作为
  世界参考系，对现有的关系也可以用清除父级反校正矩阵得到。只要子级不移动，父级可以保持在世界空间中
  有效地解释子级的位置、旋转和缩放属性。
- **Bone** 将选择对象绑定到骨骼；
- **Bone Relative** 使用骨骼父级时，在编辑模式并移动该骨骼，切换回姿态模式时，作为该骨骼的
  子物体将在姿态模式中吸附回骨骼的位置。
- **Vertex** 物体模式下选定子级和父级对象，然后 Tab 切换到编辑模式，在父对象的顶点中选择一个
  顶点作为父级，然后按下 Ctrl-P 并确认。
- **Vertex (Triangle)** 物体模式下选定子级和父级对象，然后 Tab 切换到编辑模式，在父对象的
  顶点中选择任意三各顶点作为父级，然后按下 Ctrl-P 并确认。
- **Make Parent Without Inverse**

以下菜单项除了建立物体父子关系之外，它还为子级物体添加了一个修改器或约束，并将父级作为目标物体或
激活父级属性：

- Armature Deform 骨架形变
	- Width Empth Groups
	- Width Automatic Weights
	- Width Envelope Weights
- Curve Deform 曲线形变
- Follow Path 跟随路径
- Path Constraint 路径约束
- Lattice Deform 晶格形变

以下菜单解散父级子级关系：

- **Clear Parent** 解散选择中的父级子级对象，并且恢复子级对象原来的位置，旋转和大小。
- **Clear and Keep Transformation** 解散选择中的父级子级对象，并保留子级对象现有的位置，旋转和大小。
- **Clear Parent Inverse** 用空矩阵替换选中的对象的父级反校正矩阵。清空矩阵后，子物体的位置、
  旋转、缩放属性以父物体的世界坐标为参考。

通过清除它的原点，你可以将一个子物体 移动 到它的父物体上。父级与子级之间的关系不受影响。选择子物体
并按下 Alt-O。通过确认子物体将吸附到父级的位置。使用 大纲 视图来验证子物体是否仍然存在父级。

在选择父子关系的对象时，可以使用快捷键来快速选择父级或子级，通过方括号操作：

- 扩选到父级 Shift-[
- 扩选到子级 Shift-]

对象关系选项参考属性编辑器的物体关系面板 Properties - Object Properties - Relations。

- Parent Type 设置父对象类型：
	- Object 作为另一个对象的父对象；
	- Vertex 作为另一个对象顶点的父对象；
- Tracking Axis 跟踪轴向，当启用 对齐到顶点法线 时应用 实例化顶点 。
- Axis 轴向，指向前进方向的轴向。
- Up Axis 上向轴向，指向 向上 方向的轴向。
- Pass Index



## 👉 Instancing & Apply 实例化与应用编辑
- https://docs.blender.org/manual/en/latest/scene_layout/object/editing/apply.html

Blender 中编辑、调整对像的属性有一个中间阶段，会将当前调整的状态数据记录下来，在执行 Apply 操作
后将这些数据正式写入几何体的数据块中。在执行 Apply 操作之前，可以恢复对象属性的上一个状态。

	Mode: Object Mode
	Menu: Object ‣ Apply ‣ Location / Rotation / Scale / Rotation & Scale
	Shortcut: Ctrl-A

最常用的就是矩阵变换的操作，包含平移、旋转、缩放等等，在应用修改之前，可以撤消自上一轮 Apply 操作后
修改：

	Menu: Object ‣ Clear ‣ Location / Rotation / Scale / Origin

除了基本的变换应用操作，还有以下这几个：

- Transforms to Deltas 
- Visual Transform 
- Visual Geometry as Mesh 
- Make Instances Real 
- Parent Inverse 应用父级变换矩阵的逆变换矩阵。

在处理 Object Relations 时，给一个对象设置父级时，Blender 通过 Parent Inverse，即父级
逆变换矩阵来避免子对象进行变换。当将子对象上的 Parent Inverse 清除后，即用空矩阵替换选中的对象的
父级反校正矩阵，这时父对象的变换矩阵就是直接作用于子对象。一个矩阵和逆矩阵相乘，就如同时一个数与它
的倒数相乘，当这个逆矩阵清零（变成单位矩阵），那么父级的变换就会体现在子对象上。

将主对象转换转换为增量转换，任何现有的增量转换也将包括在内。

Transforms to Deltas
	Reference

	Mode
	Object Mode

	Menu
	Object ‣ Apply ‣ Location / Rotation / Scale to Deltas

	Shortcut
	Ctrl-A

	Converts primary object transformations to delta transforms, any existing delta transforms will be included as well.

	Location to Deltas

	Rotation to Deltas

	Scale to Deltas

	All Transforms to Deltas
	Converts all primary transformations to delta transforms.

	Animated Transform to Deltas
	Converts the primary transformation animations (of the translation, scale, and, rotation values) to delta transforms.

	Options
	Reset Values
	Clear primary transform values after transferring to deltas.

Visual Transform
	Reference

	Mode
	Object Mode

	Menu
	Object ‣ Apply ‣ Visual Transform

	Shortcut
	Ctrl-A

	Apply (set) the result of a constraint and apply this back to the object’s location, rotation and scale.

Visual Geometry as Mesh
	Reference

	Mode
	Object Mode

	Menu
	Object ‣ Apply ‣ Visual Geometry to Mesh

	Shortcut
	Ctrl-A

	Apply the visual state of all selected objects (modifiers, shape keys, hooks, etc.) to object data. This is a way to freeze all object data into static meshes, as well as converts non-mesh types to mesh.

	For details, see the Convert mesh.

Make Instances Real
	Reference

	Mode
	Object Mode

	Menu
	Object ‣ Apply ‣ Make Instances Real

	Make Instances Real creates a new object for each instance generated by the selected ones, and removes any direct instancing from those.

	In the end, each instance becomes a real object.

	Warning

	This applies to both direct (from verts or faces…) and indirect (from particle system…) instancing. In case you have tens of thousands of instances (from particles for example), this can significantly slow down Blender, which does not always deal well with that many objects in a scene.

	Options
	By default, new objects will be added to the same collection as the one containing their instancer, without keeping any hierarchy relationships. This behavior can be altered with the following options.

	Parent
	If Keep Hierarchy is not set, parents all the generated objects to the former instancer.

	Otherwise, parents all the generated objects which are not already parented to their respective instancer, or its matching new copy (this is important in case of recursive instancing, see the note below).

	Keep Hierarchy
	Preserves internal hierarchies (i.e. parent relationships) in the newly generated objects.

Tip

	Usually, to get a new hierarchy as close as possible from the instancing one, you’ll want to enable both of these options.

	Note

	Preserving relationships in recursive instancing cases (instancers instancing other instancer objects, etc.) is only supported to some extent currently.

	Simple cases (like an empty instancing a collection containing instances of some other collections) will usually work, but more complex cases will fail to fully reproduce the whole instancing hierarchy.


在 Blender 的场景种使用 Scene 及集合 Collection 来管理模型的层次结构。在 Blender 中，物体
并不是直接属于场景的一部分，而是都储存在主数据库里，一般来说就是 blend 文件。场景 Scene 从数据
文件中引用物体并归属到集合中，Scene 其实就是一个顶层集合 Scene Collection，一个文件中可以有
多个 Scene 集合。

管理场景内的物体可以使用以下快捷键：

- M 移动所选物体到集合。
- Shift-M 关联所选物体到集合。可以在弹出菜单中创建新集合。
- Ctrl-G 创建新集合并将选中的物体添加到里面。
- Ctrl-Alt-G 从集合中移除所选的物体，如果该物体属于多个集合。
- Shift-Ctrl-Alt-G 从所有未在场景中使用的集合中移除所选物体。
- Shift-Ctrl-G 将选中的物体加选到活动物体所属的集合。
- Shift-Alt-G 将所选物体从活动物体所在的集合中移除。

视图层的加入允许设置各个集合的可见性、可选性和其他选项。视图层可以启用任何集合，多个视图层 可以使用
相同或不同的集合。每个视图层可以作为独立的渲染层被单独渲染从而有助于后期场景合成，在 View Layer 
属性面板中可以设置。

从其它文件中附加 Append 或关联 Link 对象也算是一种，快捷键 F4 弹出文件菜单，选择附加或链接其它
文件的模型对象。这些功能可以帮助你重复使用材质、物体和外部 .blend 文件中的数据块。可以建立 .blend
文件作为通用内容库，并跨文件引用它们。

关联方式 Link 创建对源文件中数据的引用不可以编辑，如果源文件中的数据被改变，那么引用该数据的文件
将在下次打开的时候更新数据内容。而追加方式 Append 会将复制数据的完整副本，不保留对原始数据的任何
引用。 可对本地数据副本进行进一步编辑，但外部来源文件中的更改不会反映在引用文件中。

为了修改关联的物体，可以使用代理 Proxies，执行菜单 Object - Relations - Make Proxy。关联
物体转换为一个本地代理后，并用一个空对象包装，在其名称后附加 proxy 后缀，它允许你在本地更改一个
从外部库关联进来的物体或集合。这些更改可能是受限的，你可以编辑代理物体的变换和变换动画及其约束。并且
这些更改是本地的，不会被同步回外部库。

这是一直以来 Blender 用于对关联数据块进行本地编辑的方式，这主要针对角色动画。它们最重要的限制之一是，
在给定的 blend 文件中，只能存在任何关联对象的一个代理。

现在可以使用一种功能更强大、更灵活的新系统库覆盖 Library Overrides，菜单位置： 

	Object ‣ Relations ‣ Make Library Overrides

大多数关联数据块都可以修改覆盖，外部库更新后，没有修改覆盖的数据块的将会更新。

除了复制模型 Shift-D 和引用复制 Alt-D，Blender 中有三种方式实现程序化地直接以其它物体为原型
实例化或复制物体，参考物体实例化属性面板，Object Properties - Instancing。

这里主要掌握以下三种方法，此外，直接实例化物体还有其它方法，如粒子系统...

- 顶点，实例顶点，允许在父级物体每个顶点的位置复制子级物体，仅适用于网格物体。
- 面，在每个面上创建所有子级物体的实例，仅适用于网格物体。
- 集合，这将创建一个带有物体变换信息的集合的实例。合集实例可以用动作来产生动画，或者获得一个链接代理对象 Proxy。

有两种建模情形需要用到实例化顶点，它们可以当作排列工具使用，允许模拟物体的几何排列。例如希腊神殿的石柱、
公园里的树、机器人军队、教室里的课桌等。第二种方法，从物体的一个部分开始对物体进行建模，例如狼牙棒上的刺、
海胆上的刺、墙上的瓷砖、花瓣。

需要一个基本物体，例如 树 或者 罗马柱，和一个你想要的形状的样式网格，如圆圈。将圆圈设置为基本对象的
父级对象，并设置圆圈的实例属性面板，设置顶点或面实例即可。

	Object Properties - Relatiions - Parent
	Object Properties - Instancing

- Display Instancer 勾选以显示父对象；
- Render Instancer 勾选以渲染父对象；
- Align to Vertex Normal 对齐到顶点法线方向；
- Scale by Face size 可以设置缩放系数；

如果你在物体模式或编辑模式选择基本物体并修改它，所有改动将影响到所有实例化物体的形状。你也可以选择
父级物体来修改实例物体的排列；增加父级物体顶点也会导致增加实例物体。

可以通过对齐到顶点法线来控制基本物体的方向，所有基本物体的旋转将取决于父级物体网格的顶点法线方向。
可以结合修改对象关系面板中的跟踪轴向来改变实例化物体的方向：

	Properties - Object - Relations - Tracking Axis

要将所有实例化的几何体转化为真正的物体，只需选择基本对象，并单击应用菜单进行实例独立化，实例化是很
方便的建模方法。还可以将实例化出来的对象和基本对象并成一个物体，全选它们并执行菜单的合并功能，

	Object ‣ Apply ‣ Make Instances Real，快捷键 Ctrl-A
	Object ‣ Join，快捷键 Ctrl-J

实例化为几何体时，对于面的定位取决于子物体相对于实例器原点的位置。 这可能会导致 3D 视图中出现一些
视觉瑕疵，因为原始物体的几何图形与实例几何图形重叠或相交。 一种解决方法是将实例器网格的原点移出其
所在的平面。

使用实例化集合，通过创建集合来实例化对象，集合可能包含动画、带物理模拟的物体和其它嵌套的集合。

- 在大纲视图中创建一个新集合；
- 在新集合中创建或将需要被实例化的物体移动到此集合中；
- 通过菜单在场景中创建集合实例，Add - Collection Instance；
- 或直接在大纲视图中将集合拖到场景中，也可以右键菜单执行 Instance to Scene；

此时，大纲视图中会出现集合的空对象实例，可以任意复制，Shift-D 或 Alt-D，并为每个空物体保留实例化
集合设置，这样，可以非常轻松地获得关联数据的多个副本。如果想对实例集合的对象做进一步编辑，只需要选择
实例集合并按 Ctrl-A，选择 Make Instance Real  将集合实例转换成常规物体以便正常地进行变换和动画。


通过 Alt-D 引用复制的对象可以通过关系菜单中的独立化功能来脱离与原型的关系，这会拷贝一份原物体数据块，
并使得新对象得以独立化。这意味着，在 Blend 文件中不再共享或关联其它物体的数据块，数据块可以是网格、
曲线、材质、动画……。

	Object ‣ Make Link...  快捷键:	Ctrl-L
	Object ‣ Relations ‣ Make Single User



## 👉 Object Origin 物体原点

每个物体都有一个原点。此点的位置确定对象在 3D 空间中的位置。当选择物体时，会出现一个小圆圈，表示原点。
当移动、旋转或缩放物体时，原点的位置很重要。有关更多信息，参见 轴心点。

原点的颜色变动基于物体的 选择 状态。

黄色:	物体已激活。
橙色:	物体已选择，但未激活。
白色:	物体未关联也未选择。
青绿色:	物体已关联。
浅青绿:	物体已选择，关联，但未激活。
Note

颜色受主题影响可能表现不同。此处描述的颜色基于默认黑色主题。

Set Origin 设置原点

物体模式和编辑模式下通过菜单设置物体原点，Object ‣ Set Origin，物体原点和几何体可以相对于彼此或
3D 游标移动。

原点类型：

- Geometry to Origin 将模型移动到几何中心，物体的原点也设置于物体的中心。
- Origin to Geometry 将原点移动到物体的中心，并且物体的原点也将位于物体的中心。
- Origin to 3D Cursor 将模型的原点移动到 3D 游标的位置。
- Origin to Center of Mass 将原点移动到计算的模型质心，假设网格具有均匀的密度。
- Center 中心点 质心点中心，边界框中心

为方便观察到对象内部的坐标指向，可以使用快捷键 Ctrl-Period 打开对象的原点编辑模式，直接操作对象
原点，移动或旋转。通过 N 打开侧栏属性面板的工具选项设置：

	Sidebar ‣ Tool ‣ Options ‣ Transform
	- Affect Only - Origins 直接操作对象原点。
	- Affect Only - Locations 则只能对位移变换操作，而不能进行旋转或缩放。
	- Affect Only - Parent 表示只对父级对象进行变换操作，在其子级物体不受影响的情况下变换父级物体。

	- Affect Only - Origins 直接操作对象原点。
	- Affect Only - Locations 则只能对位移变换操作，而不能进行旋转或缩放。
	- Affect Only - Parent 表示只对父级对象进行变换操作，在其子级物体不受影响的情况下变换父级物体。


## 👉 Model 建模工具
- 快速对头部拓扑布线 https://www.bilibili.com/video/BV1hJ411C76U/

一个 3D 场景的构建至少需要三个关键的构件：模型，材质和光照。建模是创造表面，模仿现实世界的物体形状
或者表达对抽象物体想象的艺术和科学。材质定义物理属性，光照应用物理属性产生视觉效果。

一般建模工作流：

- 概念设计，形成一个基本参考；
- 原画参考，通过绘画的形式给出更直观的模型参考；
- 建模起稿，比如生物模型，就应该先做一个低模，确定基本比例；
- 细节处理，通过雕刻、动态拓扑，给模型添加各种细节，此阶段的模型面数可达几十万，不能直接使用；
- 高模优化，将高面类的精细模型转化为更合理的低面数模型，用于游戏引擎等实际使用场合；
- UV坐标展开，模型需要贴图，就要合理处理好 UV 坐标，正确调整 UV 坐标与模型面片的映射布局；
- 纹理贴图、法线贴图制作，将高模转换低模必定会丢失细节，通过各种贴图技术来修复这些选丢失细节；

以上是一般的建模流程，当然，可以直接按优化的风格建模，跳过高拓扑、转低模的操作，这需要在建模过程中
就考虑如何布线，将模型以最少的面片展示出来。

可用的建模工具或方式：

- 可以有基本的 Mesh 网格对象编辑而来，也可以使用曲线 Curve 或曲面 Surface，甚至是原始的顶点。
- 使用各种修改器，如阵列复制，螺旋等等，新版本的几何节点修改器是一个强大的程序化建模工具。
- 使用动态拓扑、雕刻，可以是置换贴图结合纹理绘制，甚至是由粒子系统模拟演化而来。

而开始建模之前，对模型的拓扑结构需要成竹在胸，比如头部拓扑布线，如果网络走向不合理，后期做脸部动画
时就会出现奇怪的表情。在建构过程中，需要熟悉一些基本操作，如选择各种对象，移动、旋转、缩放等等。

熟悉对头部拓扑布线是认识拓扑结构的基础，因为头部结构有一定的复杂度，其拓扑结构有四个关键圈走线：

- 两眼圈；
- 鼻子、嘴巴圈；
- 耳朵圈；
- 下颌、后脑圈；

这些部位有较明显的凹陷或隆起，先确认周边的走线可以增加拓扑走线的简洁性。

建模时在模式之间切换很常见，某些工具可能可以在多个模式下使用，而其他工具则可能是专用于特定模式，
如 3D 模型的雕刻模式，蜡笔对象的绘画模式。编辑模式是建模用到的主要模式。除 Grease Pencil 蜡笔
对象以绘画方式编辑外，以下模型物体类型均可使用编辑模式：

- Mesh 网格
- Curve 曲线
- Surface 面
- Metaball 融球
- Text 文本对象
- Lattice 晶格

融球 Metaball 物体是隐式表面，不是由明确的顶点或控制点定义的，用于特殊效果或作为建模的基础。例如，
使用一组融球来形成模型的初始形状，然后将其转换为网格，以便进行进一步建模或雕刻。融球对于光线跟踪也
非常有效。

晶格 Lattice 通常被称为变形笼 deformation cage，它的主要用途是使用 晶格修改器 对它控制的物体
应用形变。

在场景 3D 视图的添加菜单上，除了以上对象外，还有其它常用的多用途对象：

- Armature 骨架，用于做动画角色骨架；
- Empty/Image 虚拟对象，单个坐标点，没有体积，无法渲染。常见用途：控制手柄、占位符、绑定控制、景深(DOF)距离、参考图片；
- Light 光照对象；
- Light Probe 光照探头，用在 Eevee 引擎，为了引导渲染引擎更快地算出效果更好的光照；
- Speaker 扬声器，给场景设置声音，参考属性设置 Scene - Audio，已经非线性或视频编辑器；
- Camera 摄影机，设置场景渲染需要的镜头摄像机位；
- Force Field 物理力场，设置模型需要的各种力场以模拟产生动画；
- Colleciton Instance 集合实例，向场景添加场景的集合对象副本；

3D 视图有三种主要用于创建、编辑和操作网格模型的模式：

- 物体模式 支持基础的操作比如创建对象、合并对象、管理形态键、管理UV层和顶点颜色层。
- 编辑模式 主要用于网格编辑操作。
- 雕刻模式 除了能够处理单独的网格元素，还支持通过笔刷进行雕刻。

建模的目标，就是建立一个具有良好拓扑结构 Topology 的模型。比如一个面部模型，将焦点放到嘴部，按
动画需求做嘴部动作，那么周围的网格就需要按嘴的外形环绕。如果不是这样，在设置对话口型时，模型就走样
不真实了。按 Blender Master Class 总结，一个好的拓扑需要满足以下几点原则：

- Avoid triangles and n-gons where possible.
- Avoid poles with lots of edges.
- Create loops around important forms.
- Align edges with the form. 

创建合理的拓扑结构会需要使用到循环边工具， Loop Cut 或 Ring Cut 循环切割 Ctrl-R 工具等。


### ⚡ Mesh 网格建模

网格建模通常从一个基础网格形状开始：

- Plane 平面
- Cube 立方体
- Circle 圆环
- UV Sphere 经纬球
- Icosphere 棱角球
- Cylinder 柱体
- Cone 锥体
- Torus 环体
- Grid 栅格
- Monkey 猴头

然后再深入编辑，借此创建一个规模更大、更复杂的形状。网格编辑涉及以下基本元素的编辑：

- 顶点 Vertexs
- 边线 Edges
- 片面 Faces 

常用工具菜单：

	- Ctrl-F 调出面工具菜单
	- Ctrl-E 调出边工具菜单
	- Ctrl-V 调出顶点工具菜单
	- Shift-A 添加模型网格 
	- U 调出 UV 坐标展开菜单
	- Ctrl-RMB 复制或挤出至光标
	- 1 - 3	切换 点/线/面 (Shift 扩展, Ctrl 扩展)，启用 Emulate Numpand 时失效。

编辑网格元素有点/线/面三种选择模式，热键对应 1, 2, 3 ，按住 Shift 多选择模式，Ctrl 扩展/缩减选择。

在几何对象中，法向是一个方向或一条垂直于某对象的直线，主要是垂直于三角面或其他表面，但也能和某条直线、
点在曲线上的切线或点在曲面上的切面垂直。自定义拆边法向 Custom Split Normals 用来指定法线方向，
替代默认法向来微调着色。

编辑视图提供以下常用的面片操作工具：

- Select 选择工具选中编辑元素，矩形 Box/ 圆形 Circle/ 套索 Lasso 等选择方式，W/B 快捷键；
- Extrude Region 挤出区域，Ctrl-RMB 或快捷键 E 将选中元素按任意方向拉伸成形。
	- 法线方向 Along Normals
	- 对象局部法线方向 Individual
	- 向光标方向 To Cursor
- Inset Faces 内插面，快捷键 I 向选中的面插入新的内插面，可以直接在 Material 参数给新面指定材质槽以使用不同的材质；
- Bevel 倒角，快捷键 Ctrl-B 给选中的边或面创建倒角；
- Loop Cut 环切，Ctrl-R 在模型的任意平面进行环形切割以形成新的面；
- Knife 切割网格，快捷键 K 将网格按小刀光标划过的位置进行切割；
- Bisect 切分网格，沿自定义平面将网格一分为二；
- Poly Build 多边形建模，通过添加边线、顶点创建模型，按住 Ctrl 点击或右击添加顶点并自动连成面，按住 Shift 删除面片；
- Spin 通过挤出和旋转创建新的模型，类似车床做出的结果；
- Spin Duplicate 通过复制和旋转选中对象创建新的模型；
- Smooth 平滑选择顶点的角度；
- Randomize 随机化选中的顶点，添加杂乱凹凸效果；
- Edge Slide 沿面滑移边线；
- Vertex Slide 沿边滑移顶点，Shift-V；
- Shrink/Flatten 按选中对象的法线方向伸缩；
- Push/Pull 推或拉缩放选中元素；
- Shear 切变，Shift-Ctrl-Alt-S，将选中的面/线/点按三轴六个方向切向变换；
- To Sphere 球形化，Shift-Alt-S 将选中的面/线/点围绕物体中心保持圆形向外移动顶点.
- Rip Region 分离顶点，快捷键 V 将顶点从网格中松开；
- Rip Edge 扩展边线，快捷键 Alt-D 将边线从网格中扩展形；

Mesh 网格工具菜单提供以下通用功能：

- Duplicating 复制或镜像
- Transformation 变形
- Subdivide 网格细分工具
- Mirror 镜像
- Clean Up 清理及删除
- Normals 法线编辑

- Snap 设置光标的吸附方式
- Extrude 挤出模型选中部分

- Knife Project	投影切割是一个非交互式工具，使用物体切割网格，而非手动绘制线条。
- Bisect 切分工具是沿自定义平面将网格一分为二的便捷方法。
- Convex Hull

	凸壳 接受点云作为输入，输出围住这些顶点的凸壳。如果输入包含位于凸壳上的边或面，这些边或面也会作为输出。该操作还可以当做桥接工具使用。

- Split 拆分

	将选中项与其他网格拆分，对边界线的选中元素进行复制，复制元素保留在原来的位置，使用 G 移动后才能看的比较清楚。

	拆分 Split 和顶点端离工具 Rip 操作很像，只是拆分对多个选中的点进行操作不要求它么连结状态，还可以分离边线或面片。

- Separate 分离网格成独立对象，可以按网格设置的材质、松散部位等进行分离

- Shading 着色方式，对网格的法线插值使模型看起来更平滑
- Weights

	顶点组权重编辑，需要在属性面板中添加 Vertex Group 才激活功能。可以通过 Weight Paint 
	权重绘制模式来修改。

- Sort Elements 用于按照指定的条件，对选中网格元素编号进行排序。

- Show/Hide

	- Revel Hidden 恢复显示隐藏项 Alt-H
	- Hide Selected 隐藏选中项 H
	- Hide Unselected 隐藏未选项 Shift-H



### ⚡ Selection 选择工具的使用

Blender 通过轮廓线的颜色标记不同选择项状态，活动物体为黄色，已选择的物体为橙色，未选择的物体为黑色。

在物体模式中最后被选择的物件叫活动物体 Active Object，它是许多操作的默认对象，它在大纲中呈黄色，
其它为橙色，任何时候最多只有一个活动物体。如果你已有一个选中项，但想要使另一个物体成为活动物体，只
需再用 Shift-LMB 选择一次。

所有其它已选物体仅仅属于选择状态，你可以选择任意多个物体。为了在全部所选物体(骨骼、序列脚本)上改变
某个参数或者实现某个操作，可以当进行确认时，按住 Alt。

选中的顶点可以在属性面板的 Object Data - Vertex Groups 中进行分组管理。

选择菜单提供的通用选择功能：

- A 全选
- Alt A 不选
- Ctrl-I 反选

- Box Select	B 交互式框选。
- Circle Select	C 交互式刷选。
- Select Random 随机选择物体

- Mirror Selection 镜像选择，即选中对象的镜像

在编辑模式下，可以进行对 点、 线、 面 的选择模式，热键 1, 2, 3 切换，切换时可以保持选中的点、线、面。
按住 Shift 多选择模式, 按住 Ctrl 扩展/缩减选择。

即按住 Ctrl 可以剔除现有的选择中的元素，按住 Shift 可以增加选择。

例如，按 L 可以选择有连接的顶点，按 Shift-L 则将有连接的顶点从选区中排除。

在对象浏览模式下的选择菜单：

- Select All by Type... 根据几何体类型选择
- Select Active Camera 选择当前活动摄像机对象

- Select More/Less 根据物体的父子关系联系选择

	笔记本没有小键盘，可以通过配置用大键盘的数字模拟。

	- More		Ctrl-Numpad+
	- Less		Ctrl-Numpad-
	- Parent	[ 选择当前对象的父级
	- Child		] 选择当前对象的子级
	- Extend Parent	Shift-[ 扩选到父级 Shift-[
	- Extend Child	Shift-] 扩选到子级 Shift-]。

- Select Grouped	Shift G 根据类型分组选择
- Select Linked		Shift L 根据连接关系选择
- Select Pattern... 根据对象名称模板选择


Edge Loops 循环边、 Edge Rings 并排边、 Face Loops 循环面这几个选择方式比较常用，可以通过 
Alt-LMB ，或 Shift-Alt-LMB 编辑已有选择。所谓循环边即边线走向上的其它边，并排边即边线平行的边。
配合 Ctrl-NumpadPlus/Minus 进行扩展选择，或 Ctrl-L 选择连接部分非常方便。 

对于笔记本键盘，如果开启了 Emulate 3 Button Mouse，Alt 将用于模拟鼠标中键。循环选择方式可以
通过双击实现，循环方向根据光标所在位置的偏向决定，如在水平两点间双击表示选择水平线上的点、线。面选择，
则以面几何中为出发点，各边线为方向，偏离原点的方向就是选择的方向。并排选择方式按住 Ctrl 双击即可以。

按住 Shift 点击可以添加/移除选中状态，按住 Ctrl 点击可以按最近走线 Shortest Path 选中所经过
的点、 线 或 面。  

编辑模式的选择菜单功能：

- Checker Deselect 间隔式选择，对已选中的所有目标进行间隔式选择过滤。

	- Deselected 跳过
	- Selected 选中
	- Offset 偏移

- Select Sharp Edges	选择模型的轮廓点、边或面
- Select Similar		Shift-G 根据相似性质选择

	- Normal 按相似法线选择
	- Amount of Adjacent Face 按邻近面数选择
	- Vertex Groups 选择同顶点组的所有顶点
	- Amount of connecting edges 按连结边数选择
	- Face Regions 按拓扑结构选择同一个网格能匹配到的相似区域的元素

- Select All by Trait 按特征选择

	- Non Manifold 选择非流形几何体

		非流形网格定义的是无法在真实世界存在的几何体，这种类型的几何体不适合几种操作，特别是在
		知道物体的体积很重要的情形下，比如折射，流体，布尔，3D 打印。非流形网格内部的非重叠面
		(基于其相连面)的结构无法根据其法线确定体积的内部和外部，定义了一个两侧法向相反的表面。
		用于非封闭体积时，一个非流形网格总是可以算出至少一个非连续法向，要么是由于相连循环反向，
		要么是奇数个面数。一个非流形网格总是定义了奇数个表面。

		有多种非流形几何体: 

		- 一些边界和空穴，边只有单一连接面，面没有厚度。 
		- 不属于任何面或线的边和顶点。
		- 连接 3 个或以上的面的边，包括内部面。 
		- 同属于两个不相邻面的点，如两个圆锥体在尖峰处共享同一个顶点。

	- Loose Geometry 选择松散几何体
	- Interior Faces 选择非流形内表面
	- Faces by Sides 选择侧面

- Select More/Less 按层级关系选择

	- More		Ctrl-Numpad+
	- Less		Ctrl-Numpad-
	- Next Active		Shift-Ctrl-Numpad+
	- Previous Active	Shift-Ctrl-Numpad-

- Select Loops 按循环选择

	- Edge Loops 循环边 选择相连边。
	- Edge Rings 并排边 选择相连的并排边。
	- Face Loops 循环面 选择相连面。
	- Select Loop Inner-Region
	- Select Boundary Loop

- Select Linked 按关联选择

	- Linked			Ctrl-L 选择相连元素
	- Shortest Path		两个元素之间的最短路径，可以按住 Ctrl 点击选择。
	- Linked Flat Faces 相连的平展面 按面与面的夹角阈值选择相连面，选择平整的面片相当有用。

- Side of Active 选择活动顶点的同侧 选择网格上与活动顶点处于相同单一轴向上的所有顶点。


- Alt-LMB 循环面
- Shift-Alt-LMB 会把下一组选中的循环边加入当前选中对象中。
- Ctrl-Alt-LMB 选择循环 ‣ 并排边
- Ctrl-LMB 选择相连元素 ‣ 最短路径


### ⚡ Vertex Tools 顶点工具


可以直接 Ctrl-RMB 添加最基础网格元素，顶点，并自动连成边线。在选中两个顶点的情况下，创建一个平坦
的表面，也叫做四边形。如果选中三个或更多独立顶点，则沿着光标方向挤出个顶点。但是，对于连成线的顶点，
表示选中了线段，会沿着光标的方向挤出选中的线段建立平面。

使用框选或套索选择工具时，在顶点附近点击就可以选中，按住 Ctrl 或 Shift 可以复选或取消选中。

或使用 Poly Build 建立多边形，在合适的光标位置会提示选中的顶点或边线，拖到即可挤出造型，按住 
Ctrl 点击或右击添加顶点并自动连成面，按住 Shift 删除面片或线段中的结点。

移除重叠顶点清理重合顶点，通过 Mesh - Merge 对选中顶点进行合并，大量的顶点处理可以通过 
By Distance 方式，设置一个合适的距离作为重叠顶点的判断依据。

- Bevel Vertices Ctrl-Shift-B 对顶点倒角形成新面
- New Edge/Face from Vertices 从多个选中顶点构建线段或面

- Connect Vertex Path 连结顶点路径

	J 用于连结按顺序选择的顶点，切开连线经过的面。当选中两个顶点时，将沿两者之间的面生成一条切线，
	有些类似切割工具。

- Connect Vertex Pairs 连结顶点对

	通过以连线连接选中顶点，切开所在的面，要求操作用平面的顶点。

- Mesh - Merge

	Alt-M 执行网格菜单的合并操作，该工具用于将选中顶点合并为一个顶点，融并其余顶点。

	Collapse 塌陷合并顶点，将每条边合并为单个顶点。适用于选中一组并排边，然后塌陷，移除其通过的面循环。

	该工具在新版中移到 Mesh 菜单，快捷键改为 M。

- Rip 断离

	- Rip Vertices		V 断离选中任意相连的顶点。
	- Rip Vertices and Fill Alt-V 补隙断离与上文的断离工具类似，不过它会补上几何体，而不留下空洞。
	- Rip Vertices and Extend Alt-D 断离顶点并延长

- Slide Vertices		Shift-V 顶点滑动对顶点沿其相邻边进行变换。

	- Event E 均匀偏移量默认为顶点沿边线移动距离相对其长度的百分比。当启用均匀模式后，顶点偏移量为绝对值。
	- Flipped F 翻转当激活翻转，顶点从其相邻点移动相同距离，而非从原始位置开始移动。
	- Clamp				Alt 或 C 限定切换是否将滑动限制在边长范围内。

- Smooth Vertex 平滑顶点

- Convex Hull

	凸壳 接受点云作为输入，输出围住这些顶点的凸壳。如果输入包含位于凸壳上的边或面，这些边或面也会
	作为输出。该操作还可以当做桥接工具使用。新版已将此功能移到 Mesh 菜单。

- Make Vertex Parent

	Ctrl-P 创建父级顶点，将选中的顶点/边/面作为其他选中物体的父级。

- Hooks

	Ctrl-H 为选中项添加一个挂钩修改器 Hook Modifier，给一个模型设置一个挂钩后，场景中就相应
	添加一个用来控制网格结构的 Empty 对象，通过对象这个 Empty 对象的变形，就可以实现对挂钩关联
	的网格变形。

	挂钩修改器中可以指定 Vertex Group 来控制每个顶点影响程度，给顶点进行权重绘制 Weight Paint，
	再将顶点组的所有顶点关联到挂钩上。

	- Hook to New Object

		为活动物体新建一个挂钩修改器 Hook Modifier，并指定至选择的顶点，同时在这些顶点的中心
		添加一个空物体，作挂钩之用。

	- Hook to Selectd Object

		挂钩到选中物体，如果存在的话，而不是新建用于挂钩的空物体。

	- Hook to Selected Object Bone

		挂钩到选中的物体，并将最后选中的骨骼作为挂钩目标。

	- Assign to Hook

		将选中的顶点关联到指定的挂钩上，挂钩中原有关联顶点会被移除，一个顶点可以指定至多个挂钩。

	- Remove Hook

		从物体中移除挂钩：从修改器堆中移除对应挂钩修改器。

	- Select Hook 选择所有指定挂钩的顶点。
	- Reset Hook 等同于对应挂钩修改器的重置按钮。
	- Recenter Hook 等同于对应挂钩修改器的重新指定中心按钮。

- Shape Keys

	形态键的功能用于制作动画将物体变形为新形态。

	- Blend From Shape 从形变混合 从形态键混合形状。
	- Propagate to Shapes 形变传导 应用选中顶点的位置至所有其他形态键。


### ⚡ Edge Tools 边线

- New Edge/Face from Vertices 

	F 从顶点创建边/面，基于选中项，创建一条边或一些面。

- Set Edge Attributes	设置边属性

	- Make/Clear Seam

		标记/清除缝合线 缝合边是在UV映射中用于拆分UV，创建孤岛的方法。

	- Make/Clear Sharp

		标记/清除锐边 标记用于 拆边法向 以及 拆边修改器 ，这是平滑、自定义着色技巧的一部分。

	- Bevel Weight

		倒角权重 介于0.0到1.0之间的值，用于 倒角修改器 控制边的倒角强度。通过 N 唤起侧栏菜单操作。

	- Edge Crease

		Shift-E 边线折痕 介于 0.0 到 1.0 之间的值，用于 表面细分修改器 控制细分过后网格边线
		的锐度。在线稿渲染 Freestyle 上也有应用。


- Edge Slide

	滑动边线	横穿相邻面滑动一条或更多边线，对边线的选择有些限制，选中项必须可以定义一个有效的循环。

	- Event

		E 均匀 使循环边与匹配相邻循环边形状。使用 F 可以翻转至与另一侧循环边匹配。使用 Alt-Wheel
		调整控制滑动的边线。

	- Flipped

		F 翻转 当开启均匀模式时，在两个相邻循环边之间切换匹配的循环边。

	- Clamp

		Alt 或 C 限定 切换是否将滑动限制在相邻循环边之间。


- Rotate Edge

	旋转边线 绕周边顶点，对两个面之间的边线进行顺时针或逆时针旋转，可用于重构网格拓扑结构。

- Edge Split

	拆边 与 断离 工具类似。当选中一个或多个内部边线，或边界线，然后对其使用 拆边，会创建一个空洞，
	并复制选中的边线作为空洞的边界。

- Bridge Edge Loops

	桥接循环边 使用面连接多组循环边。

Blender水母动画 https://www.bilibili.com/video/BV1b24y1W79k
对边线进行 Subdivide 细分，可以使用 Fractial 分型功能以产生水母触须的随机起伏。


### ⚡ Face Tools 面片

- Poke Faces 尖分面，将面分割成三角面。
- Inset Faces	I 内插面 为当前选中面建其内插面，厚度和深度可调节。

- Fill

	Alt-F 填充工具从任意选中的边或顶点创建 三角 面，只要它们可以组成一个或多个完整的线环，也用来
	连接两个顶点。

- Grid Fill

	栅格填充使用一对相连的循环边，或单个闭合的循环边，沿四周几何形状填充栅格。

- Beautify Faces

	完美建面 仅作用于现有选中面，通过重新排布选中的三角面，获得更加平衡的三角面，即减少细长三角面。
	设置最大角度限制边线旋转，获得平整表面。

- Triangles to Quads

	Alt-J 三角面转换为四边面，选中多个三角面后可调用该工具，此工具基于阈值，通过移除相邻两三角面
	的相邻边，创建四边面。

- Triangulate Faces		Ctrl-T 面三角化
- Weld Edges to Faces

	焊接边线到面 使用松散线框边来切割选中的面。该工具的用法与切割工具类似，不同的是可以先手动设置切割线。

- Intersect(Knife)		交集(切割) 相交工具用于将交叉部分切割为几何体。
- Intersect(Boolean)	使用选中部分对未选中几何元素执行布尔操作。
- Solidify				实体化
- Wireframe				线框
- Rotate Edges			旋转边
- Rotate & Reverse		旋转 & 翻转

把顶点压平，多平面的顶点对齐到同一平面，步骤:

- 选择要压平的点。
- 按 S 键(缩放)。
- 按 X/Y/Z 再按 0 键，意味着缩放为 0。
- 按 Enter 确认。

根据不同的对齐需要选择轴心，快捷键  `.` 弹出轴心 Pivot Point 菜单 `,` 弹出 Orientation 菜单，
也可以执行命令后进行调整 Adjust Last Operation，选择 Orientation，如按 Normal 法线方向归位。


### ⚡ Duplicating 复制

- Duplicate

	Shift-D 复制，使用 Alt-D 可以进行链接副本，多个模型使用同一个原型，使用 Shift-L 就可以
	选择所有实例

- Extrude

	E 挤出工具会复制顶点，但保持新几何元素与原始顶点相连，原来的顶点变成边，而边变成面。

- Inset Faces

	I 内插面 为当前选中面建其内插面，厚度和深度可调节。

- Spin

	Alt-R 旋绕 工具绕特定点和轴向旋转，挤出选中元素，当选中项为流形时复制。

- Screw Tool

	螺旋 工具是将重复的 旋绕 与移动结合，生成类似螺纹，或者螺旋形的物体。

	螺旋工具和螺旋修改器的主要差异在于，螺旋工具可以自动使用基础轮廓计算角度前进量，调整轴向角度向量，
	实现更加干净的顶点分布和用法。 将倒角修改器、曲线修改器与螺旋修改器一起使用。

- Mirror

	镜像复制


### ⚡ Transformation 变形

- Mirror

	Ctrl-M 镜像工具沿选定轴向镜像选中元素，还可以在激活工具后，按住 MMB 并拖动来交互式选择镜像方向。

- Shrink Fatten

	Alt-S 法向缩放 vertices/edges/faces

- Smooth

	平滑 平滑选中顶点的角度

- Laplacian Smooth

	拉普拉斯平滑使用另一种平滑算法，可以更好地保留大的细节和网格的大致形状。

- Noise

	噪波 用于使用网格材质的第一个纹理槽的灰度值来对网格上的顶点进行置换。

- Push/Pull

	推/拉 工具会移动选中元素(物体，顶点、边或面)，使之靠近(推)或远离(拉)。

- Shear

	Shift-Ctrl-Alt-S 切变 切变是两个平行表面的相向运动。

- To Sphere

	Shift-Alt-S 球形化 变换会赋予选中元素球形特征。

- Warp

	弯绕 变换接受选中元素，绕 3D 游标将选中元素弯曲特定角度，不受轴心点影响。

- Bend

	Shift-W 弯曲 Bend Angle，弯曲工具用于将形状弯曲为两端之间逐渐过渡的情况，控制的基础原理如下:

	指针和游标的初始位置决定了旋转的轴线。
	鼠标指针到3D游标的距离控制弯曲的锐利程度。
	鼠标指针与初始轴线的相对相对角度决定弯曲角度。

- Move Texture Space
- Scale Texture Space
- Align to Transform Orientation	对齐到变换方向
- Randomize Transform		变换参数随机设置
- Align Selected To Active	对齐到活动物体


### ⚡ Subdivide 网格细分工具

- Subdivide

	细分 将面和边切割为更小的单元，来增加分辨率。

- Subdivide Edge-Ring

	细分并排边 环切细分通过在一组并排边之间插入一组新的循环边，切分一组循环面。

- Knife Tool

	K 或 Shift-K 切割工具可用于通过绘制线条细分(切断)几何体，或切开闭合循环，制造空洞。通过 T 工具栏使用此工具

	- E 开始新的切割，用于定义多条不同的切割线。如果已经定义了多条切割线，会将其识别为新的吸附点。
	- Ctrl 按住后吸附游标至边线中点，这样产生的所有切点都正好位于边线的中点。
	- Shift 按住后忽略吸附，不同于默认的吸附至最近边。
	- Z 允许工具穿透切割被遮挡面，而非仅可见的面。
	- C 限制角度为吸附45度倍数。
	- LMB 双击 闭合当前切线的便捷方法。
	- 在任意时刻按下 Esc 或 RMB 取消操作，按下 Space 或 Return 确认切割。

- Knife Project

	投影切割是一个非交互式工具，使用物体切割网格，而非手动绘制线条。

- Bisect

	切分 切分工具是沿自定义平面将网格一分为二的便捷方法。

- Connect Vertex Path 连结顶点路径

	J 用于连结按顺序选择的顶点，切开连线经过的面。当选中两个顶点时，将沿两者之间的面生成一条切线，
	有些类似切割工具。

- Connect Vertex Pairs 连结顶点对

	通过以连线连接选中顶点，切开所在的面，要求操作用平面的顶点。

- Ring Cut 循环切割 Ctrl-R


Bevel 倒角的使用增加模型真实感，真实世界里的连线很少是完全尖的。即使是刀锋也不能当作完美的锐边。
多数连线都会因为机械或实用因素有意做成倒角。

倒角同样有助于为非自然模型赋予真实感。在现实世界中，物体的钝边吸收光线，并改变棱边四周的着色效果。
与看上去过于完美的无倒角物体相反，这带来了种实体的、真实的观感。

- Bevel Vertices	Shift-Ctrl-B 顶点倒角
- Bevel Edges		Ctrl-B 边线倒角

	- M 用于选择 数量 对倒角程度的计算方式，对应的类型有:

		- 偏移量 新边线到原始连线的距离。
		- 宽度 倒角面宽度。
		- 深度 原始边到倒角面的垂直距离。
		- 百分比 新边线滑移距离相对邻边长度的百分比。

	- S 滚动 Wheel 增加或减少倒角面段数。段数越多，倒角越平滑。也可以按下 S ，移动鼠标或输入数值来改变段数。
	- P 轮廓 大小介于0到1，用于控制倒角的轮廓(倒角边侧视)形状。默认值为0.5，轮廓为圆弧形
	    (如果这些面以正确的角度相连)。低于该值，轮廓变得平坦，0.25为平面，低于0.25为内凹的倒角。
	    该值大于0.5，倒角面更加突出。与 段数 类似，该值可以在按下 P 后移动鼠标或输入数值修改。
	- V 仅顶点 勾选后，使用 "仅顶点模式"，仅对每个顶点倒角。
	- C 限制重叠

对边线执行 Ctrl-B 倒角后，大概调整倒角的大小，然后再通过面板的选项细调。每次执行命令后，编辑器都会
提供上一次操作的参数面板，也可以通过 F9 调出修正上回操作面板 Adjust Last Operation，对倒角参数
细调：

- Width Type 宽度调整类型
	- Offset 偏移量 新边线到原始连线的距离。
	- Width 宽度 倒角面宽度。
	- Depth 深度 原始边到倒角面的垂直距离。
	- Percent 百分比 新边线滑移距离相对邻边长度的百分比。
- Width 设置宽度；
- Segments 段数越多也平滑；
- Profile 剖面轮廓，凹面或凸面调整；
- Vertex Only 是否只对顶点进行倒角；
- Clamp Overlap 重叠钳位，限制过宽以免盖过网格；
- Mark Seams 标记缝合线，缝合线是图像拼接的位置，方便 UV 展开时网格沿缝合线展开。
- Mark Sharp 标记锐边，用于拆边法向以及拆边修改器，这是平滑、自定义着色技巧的一部分。
- Material 材质槽编号，用于指定赋予新倒角面的材质；
- Harden Normals 硬化法线，倒角面的法线方向；
- Face Strength Mode 设置面强化模式，可以结合加权法向修改器 Weight Normals Modifier；
	- None 不使用
	- New 沿边线设置到新面，将新面沿强度设置为中等，顶点处的面强度设置为弱；
	- Affected 按 New 方式设置，并将新面附近的面设置为强；
	- All 设置所有面为强；
- Outer Miter 当两个斜边以一定角度相交时，便形成斜接。在角度大于 180° 的一侧称为外部斜接。
- Inner Miter
- Spread 设置顶点散布到 Outer and Inner Miters

为了避免破坏模型网格，也可以使用倒角修改器，Bevel Modifier，它是倒角工具的非破坏版本。


### ⚡ Mesh Normals 网格法线编辑 

Alt-N 弹出编辑自定义拆边法向菜单

- Face - Shade Smooth	光滑着色，在现有模型面数基础上进行法线插值让模型平滑。 
- Face - Shade Flat		平直着色
- Flip					反转方向
- Recalculate Outside	Ctrl-N 向外重算法线方向
- Recalculate Inside	Shift-Ctrl-N 向内重算法线方向
- Set From Faces		设置角部的自定义法向与角部所在的面法向一致。
- Rotate				R N 旋转法线
- Point to Target		Alt-L 指向目标体

	- 按键以设置目标：

		- 鼠标游标 M
		- 枢轴 L
		- 原始物体 O
		- 游标(单击设置) Ctrl-LMB
		- 网格选择(单击设置) Ctrl-RMB。

	- Mode 模式

		- Align A
		- Spherize S
		- Invert I
	
	- Reset R

- Merge					根据选择的顶点合并所有法向，创建一个平均法向给所有面。
- Split					拆分所有选择的顶点法向，使每个面有单独的法向，指向每个面的的法向方向。
- Average				平均所有每个链接有硬边的扇面的顶点法向。
- Copy Vectors			如果单选一个法向，就复制到内部矢量缓存。
- Paste Vectors			替换选择的法向为内部法向缓存中的一个。
- Smoothen Vectors		调整法向使与之相邻的顶点法向相近。
- Reset Vectors			重置法向为默认计算的法向。
- Select by Face Strength 使用子菜单选择 弱、中，或 强 之一。然后，此工具将选择所选面强度相对应的面。
- Set Face Strength		使用子菜单选择 弱、中，或 强 之一。然后，此工具将当前选定面的面强度更改为所选面强度。



### ⚡ Clean Up 清理

这些网格工具 Mesh - Clean Up 用于辅助清理无用的几何元素，并填充网格的缺失区域。

- Decimate Geometry 精简几何体 可以在引起最小形状修改的前提下，降低网格顶点/面数。
- Fill Holes 填充洞面 接受大量选中元素，然后侦测网格中的孔洞，然后填充。
- Make Planar Faces 生成平面 会迭代地让面变得更平，这可用于有三个顶点以上的平面
- Split Non-Planar Faces 拆分非平面 当非平直面弯折超过角度阈值时，对其进行拆分，以避免几何结构存在模棱两可区域。
- Split Concave Faces 拆分凹面 把一个 凹面 切分为多个凹面，将任何凹面转化为凹面。
- Delete Loose Geometry 删除松散元素 移除断开的顶点和松散边(也可以是面)。
- Degenerate Dissolve 简并融并 塌陷/移除不需要的几何元素。

和细分相反的操作就是 Merge，网格菜单和顶点菜单都提供合并精简点、线、面功能：

- Vertex - Merge Vertices 合并顶点操作

	- At First 合并选中的顶点到首选点，仅适用于 顶点 选择模式；
	- At End 合并选中的顶点到末选点，仅适用于 顶点 选择模式；
	- At Center 合并到顶点中心；
	- At Cursor 合并到 3D 光标位置；
	- Collapse

		塌陷，选中顶点的组成孤岛即顶点不相连的面，则分别合并至其自身质心点，每个孤岛合并为一个顶点；

	- By Distance 对于按距离合并选定的相互距离小于指定阈值的顶点而言非常有用。

- Edge - Un-Subdivide 反细分，精简细分边线，可以产生矩形到菱形的变

- Dissolve 融并操作

	Ctrl-X 融并选择的点、 线、 面，选择点时融并与点有关的面，选择面时融并面与面间的边线。
	融合相比直接删除，会保留原有的连接关系，直接删除则不会。

	也可以通过 X 快捷键弹出删除菜单中可以选：

	- Vertices 直接删除顶点
	- Edges 直接删除边
	- Faces 直接删除面

	- Only Edges & Faces 删除边和面
	- Only Faces 只删除面

	- Dissolve Vertics 融合点
	- Dissolve Edges 融合边
	- Dissolve Faces 融合面

	- Limited Dissolve 按角度等设置有限融合平坦区域中的顶点和边线，简化网格。

	- Collapse Edges & Faces 

		边线及面塌陷 将每条边合并为单个顶点。适用于选中一组并排边，然后塌陷，移除其通过的面循环。

	- Edge Loop

		循环边 用于删除夹在两组循环边之间的选定循环边，将现有的两组面循环转变为一组面循环。

- Decimate Modifier 精简网格修改器。




### ⚡ Curve 曲线建模
- https://docs.blender.org/manual/en/latest/modeling/curves/properties/index.html
- https://docs.blender.org/manual/en/latest/modeling/curves/introduction.html
- https://docs.blender.org/manual/en/latest/animation/constraints/relationship/follow_path.html
- https://docs.blender.org/manual/en/latest/modeling/modifiers/generate/solidify.html
- https://docs.blender.org/manual/en/latest/modeling/modifiers/generate/screw.html
- [植物生长动画](https://www.bilibili.com/video/BV1aY411G7bk/)

曲线和曲面是 Blender 物体的特殊类型。它们用数学函数表示，而不是用一系列点之间的线性插值表示。

贝塞尔曲线和 NURBS 曲面或路径，这些都是最基础的建模工具，用一组控制点来控制、定义模型。
和曲面相比，曲线的一个特点是线条绘制的灵活性更佳，并且可以贴近其它几何体的表面绘制曲线。
和蜡笔贝塞尔曲线的控制更加精确，使用的顶点数量也更少，不像蜡笔中的笔迹充满大量顶点。所以，
曲线常用来勾线，绘制模型的轮廓线，然后再对轮廓线进入深入加工。

在对象模式下，通过菜单 Object - Convert 可以将曲线转换为其它类型，比如 Mesh，然后再使用
网格工具进行建模，例如 Poly Build 可以逐面地添加进行建模。Mesh Merge 工具可以按距离
合并顶点以优化曲线。对选中的顶点，可以转化为边线，或填充成面片：Vertex - New Edge/Face。
或者使用边线工具：Bridge Edge Loops，桥接循环边，将选中的两条边点对点地连接并填充面片。

使用雕刻工具得到的精细模型包含的片面非常多，因为称为高模，但实际使用时需要进行减面、精简，
以方便动画制作，这就可以使用以上提到的这些工具。

Mirror 和 Shrinkwrap 修改器在减面建模过程中经常使用，它们分别进行对称建模，将面片缩裹
到高模表面。激活缩裹修改器的 On Cage 模式可以将新的面片中的顶点附着到高模表面。

另外还有 Surface Deform 修改器，可以用来做变形，可以配合 Shrinkwrap 一起使用。例如，
将一堵墙贴在一个球体表面，如果直接给墙体添加 Shrinkwrap 修改器，则会使墙坍塌或分散在
球体表面。需要给墙体添加 Surface Deform 修改器，然后再将修改器绑定到一个平面上。同时
给平面添加 Shrinkwrap 修改器，使墙体随平面进行变形，而平面则缩裹到球体表面。

注意，变形修改器的绑定操作时机不同，会有不同效果。如在平面的 Shrinkwrap 修改器激活后再绑定，
此时由于平面已经变形贴近到球体表面，墙体的 Surface Deform 修改器再执行绑定时将以当前的
状态作为参照，再禁止 Shrinkwrap 修改器时，平面就会恢复原样，这个变形过程就会反映到墙体上。

注意墙体要与平面对齐，平面细分超精细，变形就越平滑。为了方便墙体与平面保持一致的变换，可以设置
平面为墙体的父对象：选择墙体再加选平面，Ctrl P 打开父级设置菜单，选择 Object (Keep Transform)。
Blender 内置插件 Copy Attributes Menu，在选中多个对象时，可以拷贝活动对象的属性到其它对象。
Surface deform和shrinkwrap修改器的运用 https://www.bilibili.com/video/BV1nb411473s/
Projecting High-Res Models by Shrinkwrap https://www.bilibili.com/video/BV1P44y1x7gy/

使用曲线代替多边形网格的主要优点是，曲线由更少的数据定义，因此可以在建模时使用更少的内存和
存储空间来生成结果。然而，这种处理表面的过程方法会增加对渲染时间的需求。

某些建模技术只能使用曲线，如沿路径挤出轮廓。另一方面，当使用曲线时，顶点级控制更加困难，如果需要
精细控制， 网格编辑可能是更好的建模选择。

样条线 Splines 是曲线的一个子结构，是构成曲线物体的独立元素。曲线物体可以由多个不同的样条线组成，
就像网格物体在同一物体下可以有不同的不连续网格一样。样条线定义了曲线的形状，可以通过改变它的 控制点
进行变换。样条线有三种不同的类型，每一种样条线类型都有一个稍微不同的算法来计算如何表示样条线中的弯曲。

- Poly 多边形样条线，不会对控制点之间曲线的形状插值，能够给出原始网格物体的精确表示。
- Bézier 贝塞尔曲线，在两个控制点之间是线段主体，黑色箭头表示曲线的法线，指示其方向和倾斜程度。
- NURBS - Non uniform rational B-spline 非均匀有理样条是精确连续的，贝塞尔曲线是近似的。
- Nurbs Path 曲面路径，也是贝塞尔曲线，只是功能上有差异。

曲面路径对象数据属性 Geometry -> Bevel 可以指定一条放样贝塞尔曲线进行造型，Bevel -> Depth
设置一定的倒角厚度得到实体。在 Blender 2.93 版本改进了这一工具，直接在属性面板中指定 Profile
截面曲线，而不必另外添加贝塞尔曲线。路径上的控制点，可以设置半径来控制放榜对象的截面大小，在侧栏
工具中操作：Sidebar -> Item Transofrm -> Radius，快捷键 Alt-S 缩放半径。

也可以使用 Deform -> Curve Modifier，并指定一条贝塞尔曲线作为运动路径，Deforamtion Axis
指定为 X 轴，然后按 X 轴移动或缩放对象就可以沿着贝塞尔曲线的径向移动，模拟植物生长效果。

利用这种按曲线路径的径向移动的方式，可以将一个球体按路径控制点的半径进行缩放，产生气球的模型。


贝塞尔曲线有四种控制柄类型，可以按下 V 并从弹出菜单中进行选择：

- Automatic 黄色的自动控制柄，该控制柄具有完全自动的长度和方向，在移动时转换为 Aligned 控制柄。
- Vector 绿色的矢量控制柄，两个控制点成为独立向量，允许创建由直线或锐拐角构成的曲线或截面。
- Aligned 紫色的对齐控制柄，这些控制柄始终位于一条直线上，定义的连续平滑曲线。
- Free 黑色的自由控制柄，该控制柄的两端互不相关，移动向量控制点就会转变为 Free 方式。

设置视口选项可以上控制点的手柄始终显示，方便操作：

	Viewport Options - Curve Edit Mode - Handles - All

曲线编辑视图工具栏主要工具：

- Draw 绘制 徒手绘制新的曲线，按住 Ctrl-RMB 以交互方式放置新点。
- Extrude 挤出 通过添加新的控制点来挤出曲线。
- Radius 半径 控制控制点的半径值。
- Tilt 倾斜 控制控制点围绕曲线轴线的旋转值，例如做缠绕的麻线、DNA 双链。
- Randomize 随机化 向伪随机方向移动选定的控制点。

曲线绘制可以通过铅笔或挤出工具逐点添加，已经绘制的线段增加顶点，可以进行细分，选择两点执行细分命令，
Segments - Subdivide 指定分段数量。或者使用 Draw 工具，直接绘制出曲线。

曲线是没有厚度的，即不能作为实体渲染，使用 Solidify 修改器可以给曲线设置厚度，使其实体化。注意，
曲线要先进行造型，实体化修改器只作用于曲面。

菜单提供的其它功能：

- Curve 曲线菜单
	- Toggle Cyclic 切换曲线的循环开合 Alt-C；
	- Split 拆分选中线段，快捷键 Y，从曲线中拆分选定的曲线段；
	- Separate 分离选择的线段成为独立曲线，快捷键 P；
- Control Points 控制点菜单
	- Make Segment 将两控制点连成线段；
	- Set Handle Type 设置控制点类型，快捷键 V；
	- Tilt 倾斜，快捷键 Ctrl-T，这个设置控制法线如何围绕每个控制点扭曲，仅与 3D 曲线相关！
	- Hooks 挂钩，快捷键 	Ctrl-H，可以用来控制其他物体一个或者多个点。
	- Make Vertex Parent 创建父级顶点，Ctrl-P，使其他选定物体成为选中一个或三个控制点的子级。
- Context Menu 上下文菜单
	- Set Goal Weight 给选定控制点的曲线的权重设置指定值，如果选择多个控制点，将设置 平均权重。


默认情况下，新曲线被设置为 3D，这意味着控制点可以放置在 3D 空间的任何位置。曲线也可以设置为 2D，
这将控制点约束在曲线的局部 XY 轴上。通过属性面板设置 Object Data - Shape - 2D/3D。

通过属性面板的几何 Geometry 可以对曲线进行 Extrude 挤出/ Bevel 倒角，这样可以形成空壳体。可以
指定锥化曲线 Taper Object 和倒角放样曲线 Bevel Object。 

对象数据属性面板的活动样条 Active Spline 用于控制当前选定样条的属性，比如样条是否闭合 Cyclic，
样条分辨度 Resolution 等。

曲线可以转换为面片，在对象模式下执行：

	Object - Apply - Visual Geometry to Mesh
	Object - Convert to - Mesh from Curve/Meta/Surf/Text。

Modifiers & Constraints

- Curve Modifier 使模型按曲线样式变形，注意模型要细分足够的面；
- Screw Modifier 螺旋修改器使模型按轴心螺旋旋转造型，当 Screw 高度为 0 时就是车削造型；
- Follow Path Constraint 此约束可以使模型按曲线路径运动，可以按百分比设置位置；
- Clamp To Constraint 类似路径跟随，但根据模型自身的位置映射到曲线相应的位置来确定放置位置；


曲线建模最基本的方法：

- 放样 Lofting，给定一个剖面，按曲线走向进行造型。
- 车削 Lathes，指车床按给定侧面曲线对工件的加工方式。
- 倒角 Bevel，即斜切，把方形边改成斜面边，将边角抹平。
- 挤出 Extruded，增加顶点或厚度。

Blender 3.4 插件 Add Mesh: Extra Object 可以创建单个的顶点进行建模，Add Single Vert。
Mesh: Looptools 造型插件工具也提供了放样功能。

Blender 中的车削造型功能是通过 Screw Modifier 修改器实现的，高度参数 Screw = 0，就是车削，
高度增加就会生成弹簧样式。

曲线属性面板提供的造型工具，注意，3D 切换为 2D 会使曲线坍缩到 XY 平面：

- Geometry - Extruded 径向挤出，可以指定一个 Tapper 曲线控制锥化；
- Geometry - Bevel 提供三种倒角造型
	- Round 使用圆形曲线进行倒角，通过控制挤出、深度和分辨度，剖面可以由扁平到矩形变化；
	- Object 指定另一条曲线进行放样；
	- Profile 剖面倒角，默认为圆角四边管体，圆角矩形的放样效果，通过曲线可以控制任意剖面形状；

使用曲线放样时，侧栏面板 Item - Transforms 包含位置信息，还包含曲线顶点的几个重要属性：

- Weight 权重，用于 Blender 权重控制系统；
- Radius 半径，可以控制放样；
- Tilt 倾斜角，用于专用功能；

编辑曲线顶点时，为了约束顶点在一个平面上，可以切换到 Left/Right/Top 等正交视图下操作。



### ⚡ Surface 曲面建模
- https://docs.blender.org/manual/en/latest/modeling/surfaces/index.html
- [Blender教程-生物](https://www.bilibili.com/video/BV1Dt4y1W7UW)
- [减面插件 Instant Meshes](https://github.com/wjakob/instant-meshes)

曲线和曲面都是 2D 物体，而曲面是其三维上的扩展。Blender 只能创建 NURBS 曲面，没有贝塞尔曲面，
也没有多边形曲面。虽然曲线和曲面共用同一物体类型，但它们并不是同一回事；例如，不能使同一个物体里
既包含曲线又包含曲面。

曲线可以通过使用拉伸工具，或在较小程度上填充闭合的 2D 曲线得到 2D 曲面。也可以从 2D 曲面中获得
构成曲面的 1D 曲线，就像只有一行（U 或 V 方向）控制点的 NURBS 曲面只生成一条曲线…

曲面有两个插值坐标轴，即 UV 坐标轴。重要的是，两个维度的插值规则(结点、阶数、分辨率)可以是独立的。

曲面似乎是三维的，为什么只有二维？因为曲面没有体积，即使是闭合的，也没有体积；曲面与挤出曲线的
结果非常相似，它们无限薄。

正如图 编辑模式下的 NURBS 曲面，除了 U 向坐标是用黄色的栅格线，V 向坐标是由栅格线标识出来之外，
曲面跟 NURBS 曲线几乎没有区别。

[NURBS surface in Edit Mode](https://docs.blender.org/manual/en/latest/_images/modeling_surfaces_introduction_nurbs-surface.png)

NURBS 曲面的控制点和 NURBS 曲线的一样。然而, 曲面的布局相当受限，受到类型不同的约束而不同。
线段概念消失，取而代之的是行和整体的栅格。

行是指在一个插值方向形成的一组控制点，有点类似于网格的循环边。一个 NURBS 曲面里有 U 行和 V 行。
所有这一切形成一个栅格或罩体，其形状控制了 NURBS 曲面的形状。

重要的是要知道：不能在 NURBS 曲面上只添加单个控制点，必须一次添加一整行 U 或者 V 行控制点，这些点
的数量和其他行一样。

类似于 NURBS 样条 NURBS 曲面控制点具有权重属性，此权重属性控制着控制点对曲面的影响程度。 这个权重
不应该与仅用于软体模拟的目标权重混淆，NURBS 控制点权重可以在变换面板的 W 数字字段中调整。

在物体/编辑模式下，添加曲面 菜单提供六种不同的曲面基本体：

- NURBS Curve 曲线上每个 V 行只有一个控制点。
- NURBS Circle 圆环每个 V 行只有一个控制点，注意曲面是不会填充的。
- NURBS Surface 曲面
- NURBS Cylinder 圆柱
- NURBS Sphere 球体
- NURBS Torus 环体

在属性面板，可以在对象数据中设置活动样条线，在编辑模式下用于控制当前选定样条的属性。

除了使用 7 种曲面基本体，可以使用以下曲面建模的基本操作：

- Side Bar - Transform - Median - W 控制点的权重，用于调整曲线受此点控制的强度。
- Surface ‣ Add Duplicate - `Shift-F` 复制选中的控制点。
- Surface ‣ Spin 对 U 行控制点进行旋转造型，类型车削。
- Control Points ‣ Make Segment - `F` 连接控制点形成曲线、曲面，(旧版本 Surface 菜单中)。
- Control Points ‣ Extrude Curve and Move - `E` 对选中的控制点挤出造型。

控制点的 Weight 属性容易和 W 权重属性搞混，前者是 Goal Weight，用在曲面设置 Soft Body 物理
时，控制曲面附着在其原点的强度。

Spin 工具与网格工具有点相似，但控制和选项较少，只有旋转轴的调整。它仅适用于由一个 U 行（不是 V 行）
组成的选定“曲面”，即所谓的“曲面曲线”，通过以方形图案“挤出”该“截面”。同时自动调整控制点的权重以获得
完美的圆形挤出（这也意味着沿 V 轴闭合曲面），遵循与 NURBS 管状体或圆环体基本体完全相同的原理。


### ⚡ Metaball 隐式曲面
- https://docs.blender.org/manual/en/3.4/modeling/metas/index.html
- [Metaball（融球）快速制作洞穴关卡](https://www.bilibili.com/video/BV1KD4y1R7c6/)

所谓隐式曲面，是指没有使用顶点定义，边线定义这样直观的几何表达方式，通常是指能完数学方程式描述的曲面。
Metaball 就是在程序上存在，元对象实际上是由 Blender 实时计算的数学公式，简称为 Meta。

相比之下，Constructive Solid Geometry (CSG) 使用的是显式几何体表达，通过逻辑运算进行组合建模。

Metas 的一个非常明显的视觉特征是，它们是流动的水银或粘土状形状，具有“圆形”形态。此外，当两个元对象
彼此靠近时，它们开始彼此交互。它们“混合”或“合并”，就像水滴一样，特别是在零重力状态。如果它们随后彼此
移开，它们就会恢复原来的形状。

可以将 Meta 看成一个没有厚度的肥皂泡泡，靠近溶合在一起时，内部就是中空的状态，只有一层外壳。

每一个 Meta 都由其自身的基础数学结构定义，可以随时使用 Active Element 面板在它们之间进行切换。
通常，元对象用于特殊效果或作为建模的基础。例如，可以使用一组图元来形成模型的初始形状，然后将其转换
为网格以进行进一步建模或雕刻。元对象对于光线跟踪也非常有效，因为数学公式可以直接求值。

Active Element 属性面板参考：

- **Type** 指定 Meta 形状类型，因为是隐式曲面，可以随时更改类型，球、盒、平面、胶囊、椭圆等基本形状。
- **Stiffness** 指定 Meta 硬度，影响 Meta 本身的轮廓。
- **Radius** 指定 Meta 形状的半径大小。
- **Negative** 对族内其它 Meta 影响方式，负值影响会使其它 Meta 形状收缩。

元对象的名称非常重要，因为它们定义了对象族 Object Families，并且只有同一族中的对象彼此交互。
与其他对象类型不同，即使在 Object Mode 中进行编辑、变换，也会影响编辑族中生成的几何图形。

决定 Meta 对象的名称是 Object Name，并非 Metaball Name，即场景树设置的节点名称才决定一个对象族。
比如，MetaPlane.001 就是属于 MetaPlane 这个对象族。如果没有 MetaPlane 这个对象就不会显示所有
MetaPlane.001 这些子对象。

利用 Meta 的溶合特性，可以快速构建一个基础模型，然后通过菜单将 Meta 转换为 Mesh：

- Object - Apply - Visual Geometry to Mesh
- Object - Convert - Mesh

传统的洞穴关卡，需要用盒子搭建，然后逐点调整，地形编辑很费时间。融球工具，就很适合制作这种洞穴地形。
融球也可以快速迭代，有很多室内和过道的场景，就很适合用这种方法制作。



### ⚡ Poly Build - Retopology 拓扑
- Blender2.8 手动重拓扑方法 https://www.bilibili.com/video/BV1qt41177Vh/
- RetopoFlow 3.1.0 拓扑插件 https://www.bilibili.com/video/BV1Ki4y1T7SK
- RetopoFlow https://docs.retopoflow.com/general.html
- https://github.com/CGCookie/retopoflow/releases/tag/v3.2.5
- https://docs.blender.org/manual/en/latest/modeling/meshes/tools/poly_build.html
- https://docs.blender.org/manual/en/latest/modeling/meshes/retopology.html
- https://docs.blender.org/manual/en/latest/modeling/meshes/editing/edge/subdivide_edge_ring.html

对复杂模型进行重新拓扑，是常见的简化手段，可以按照精度要求将高模精简为一定面数的低模。

将多边交汇点放置到相对平坦的位置总是正确的，这样可以减少问题。

Poly Build 本身就是一个 Retopology 工具。

操作步骤：

- 添加一个 Monkey 做为被拓扑的模型；
- 添加一个 Plane 作为拓扑的结果；
- 给 Plane 添加一个 Shrinkwrap 坍缩修改器，按以下设置以将顶点吸附到喉头表面上：
	- Target 为 Monkey 模型；
	- Wrap Method 为 Nearest Surface Point；
	- Snap Mode 为 Above Surfaces；
	- Offset 为 0.01 m，设置合适的浮动距离以方便观察和拓扑的包裹；

然后，根据 Mokey 模型的肌理走向添加拓扑顶点、面。对于对称的模型，可以给 Plane 使用 Mirror 修改器，
这样只需发要拓扑一半就可以构成完整的模型。

虽然，可以使用吸附工具 Snap -> Surface，但是效果不及坍缩修改器好用。

操作按键：

- Add Geometry *Ctrl-LMB* 逐个顶点添加并且自动组合成四边形。
- Delete Mesh Elements *Shift-LMB*，删除面、线、顶点。
- Moving Vertices *LMB* 拖动顶点。
- Extruding Edges *LMB* 在最近边线高亮为蓝色时，拖动即挤出新连线。

开启顶点吸附功能方便操作，使用 Merge by Distance 可以用来合并重合顶点，不能使用 Face -> Fill
来填充面，也不能使得。但可以通过选中的多个顶点来构建面，Vertex -> New Edge/Face from Vertices。

可以使用 Shift 拖动来选择顶点、连线或面，再使用 Edge -> Subdivide 进行细分，Alt-A 取消选择。
可以使用分拆工具 Alt-M 将面分拆出来进行独立的细分。

注意，Edge Subdivide 不能单独设置各边的细分级数，需要使用并排边细分工具 Subdivide Edge-Ring
对选中的矩形对边进行细分。

使用 Ctrl-Num+ 可以很方便地逐步扩大选择相连的部分，或者使用 Ctrl-L 直接选择相连的部分。选择菜单
中有很多好用的选择工具，可以先选择一个对象，再使用 Select Similar 来选择类似的对象，类似的方向、
长度等等。

为了方便操作，可以使用 Shift-H 将未选中的面隐藏起来，以避免被修改，Alt-H 取消隐藏。

可以使用 RetopoFlow 这样的插件，下载安装后可以在视图顶部的工具条中找到它。不过还不够稳定，可能会
经常出现异常退出。

选中一个模型，然后执行 New Target at Active 为当前选择的模型激活拓扑工具。使用 Q 调出快捷工具。

使用 Contours 轮廓工具，可以很方便地对柱状模式拓扑，按住 Ctrl 拖动一个一切线，就会自动按指定的
位置放置对应的顶点构成环切面，操持最后一个环处于选中状态，逐次添加更多的环切线。使用 R 进行适当的
旋转，调用位置，Shift-R 进行径行旋转。

使用 PolyStrips 或 Strokes 可以对面片、连线进行调整。按住 Ctrl 在模型上拖动就可以按鼠标移动
轨迹创建面片或边线。

使用 +, =, Shift-Up, Shift-WheelUp 可以增加分段，使用 -, Shift-Down, Shift+WheelDown
减少分段。选中两个环切线可以使用 F 进行桥接，也可以使用 Enter, NumEnter。

其它工具介绍：

- Patches 工具可以用来补洞，选择要填充的边界边线，按 Enter 完成。
- PolyPen 可以按需要分割任意的面，可以插入顶点，额外的边线以及填充面。
- Loops 工具可以在循环边插入新的面或边线，使用 Ctrl-R 快速切换到 Loops 工具。
- Tweak 微调工具，像用手指涂抹一样调整风格。
- Relax 风格松弛工具。

RetopoFlow Shortcuts

- Tab, Escape	:	quit RetopoFlow
- Ctrl+S	:	save blend file (same as Blender’s save)
- F2	:	view help for currently selected tool
- F9	:	toggle on/off main RF windows

Quick Tool Shortcuts

- Ctrl+R	:	Loops
- K	:	Knife
- C	:	Tweak
- Z	:	Relax


## 👉 UV Unwrapping 贴图坐标展开
https://docs.blender.org/manual/en/latest/modeling/meshes/editing/uv.html

参考文档：制作模型 » 网格 » 编辑 » UV，编辑模式 UV 菜单快捷键 U。

贴图的英语 Mapping 其实包含了另一层含义就是映射，其功能就是把二维的纹理图片通过 UV 坐标映射到 
3D 物体表面。贴图坐标指定如何在几何体上放置贴图、调整贴图方向以及进行缩放。贴图坐标以 U、V 和 W 指定，
其中 U 是水平维度，V 是垂直维度，W 是可选的第三维度，它指示深度。

贴图可以说是最简单的材质方法，给选定物体表面的某些区域赋予一张二维图片就可以很好地通过算法模拟出
真实世界的物理属性，如颜色、粗糙度、反光度、透明度等。而最简单的贴图是位图文件，其他有 2D/3D 贴图，
按程序生成。

最简单的模型就是由四个顶点构成的 Plane，四个顶点可以很好地映射到纹理图像的像素上，它们都是二维的。
面片关联一个独立的纹理图像，UV 坐标定义图像如何映射到面，然后图像可以用于渲染或实时显示。

实际中，不可能只进行一个面的映射处理，稍为复杂一点的就是包含六个面的 Cube，它的展开也相对简单。
每个面可以映射到一整张纹理图像，也可以将六个面平铺开来，作为一个整体映射到纹理图像上。通过展开模型
来确定贴图到模型的映射关系，如果不进行展开，那么贴图的映就可能是混乱贴到模型的曲面上。

更复杂的模型可能还需要手动进行 UV 布局调整，以正确映射纹理贴图。设置好 UV 映射关系后，后续只要
模型的拓扑结构不会发生改变，那么也不需要再展开模型。可以在模型边线上标记出缝合线 (Seams)，以提示
Blender 展开模型时，按这些缝合线剪开模式。

在编辑模式下，选择面片后，才能指定图像或修改活动网格物体对应的 UV 坐标。选择面片后，UV 编辑器中
会显示相应的控制点，通过调整 UV 坐标点使相应的面片映射到指定的纹理区域，这个过程就是 UV 布局调整。
3D 视图下，可以使用 H 或 Alt-H 快捷键临时隐藏面片，以避免在 UV 编辑器中误操作。

Constrain to Image Bounds 菜单可以用来约束 UV 坐标点，避免将它们移出纹理图像边缘。
尽管，将 UV 坐标点移出图像边缘也是经常有的，它们可以折回到纹理的开始位置。可以相像将纹理
图像平铺在 UV 编辑器中，UV 坐标点在什么位置就表示面片映射到什么内容。

UV 坐标数据保存在对象数据属性面板的 UV Maps，每个对象可以创建多个 UV Maps，默认名为 UVMap。

Blender 提供了几种 UV 映射方式。比较简单的投影方法使用三维空间到二维空间的映射公式，将点的位置朝
点/轴面确定的表面插值。更高级的方法可以用于更加复杂的模型，并有更具体的用途。

模型编辑模式的 UV 菜单参考：

- Unwrap

	直接展开，依据模型上的缝合线，通过菜单标记缝合线 Mark Steam。这也是 Cube 的默认展开方式，
	可以想象一个折纸立方体盒子，将正面的左边、上下边沿边线剪开，将左侧面和后面的上下边剪开后碾平，
	得到的纸片就相当展开的模型，这张纸可以作为二维图像看待，纸张上的绘图就是贴图。

- Smart UV Project 

	智能 UV 投射，以前叫做 Archimapper，基于角度阈值裁剪模型，提供了对自动缝合线的精细控制。
	该功能会检测物体的形状，选中面以及其与其他面的关系，根据这些信息和用户设置的参数创建 UV
	映射。对于更加复杂的机械物体，该工具可以非常快速而且简单地创建一个有逻辑和直接的 UV 布局。

	- Angle Limit 此参数控制面片如何分组，值越大得到的分组越多，细节越多。
	- Island Margin 控制 UV 孤岛的边距，1 表示整个 UV 空间。
	- Area Weight 面积权重，按面积较大的面加权投影的矢量。

- Lightmap Pack 

	光照贴图拼排，分离网格的面或选中面，并将其拼排至 UV 边界范围内，每个面都是一个 UV 孤岛。
	光照信息都烘焙在 UV 贴图中，可以尽可能多的利用 UV 空间，它还可以一次用于多个网格。

- Follow Active Quads 

	沿活动四边面展开，此工具沿选中的四边面对连续的面循环展开，即使网格面是非常规形状的。
	要注意的是，展开时不会考虑图像尺寸，所以可能需要稍微缩放一点，以匹配图像区域。

	Edge Length Mode 边长度模式：

	- Even 统一所有 UV 面为同一尺寸
	- Length 按边长设置
	- Length Average 对每个循环边上的边长度取平均值。


需要注意的是，这里匹配的是活动四边面在 UV 空间中的形状，而非三维空间中的形状。
要获得整齐的 90 度展开，在使用 沿活动四边面展开 前，要确保活动四边面在 UV 空间中是矩形。


- Cube Projection

	将网格当立方体展开，6 个平面投影至一个 UV 孤岛。所谓 UV 孤岛就是那些相连顶点构成的坐标集合。

- Cylinder/Sphere Projection 

	柱面和球面投射，就是制图人员绘制世界地图的方法。

- Project from View 
- Project from View (Bounds) 

	按视图投影，按照 3D 视图的当前视角显示的网格形状及大小投射到 UV 贴图上。
	当前角度看到的网格贴图就和纹理图像一样。	后者会约束 UV 坐标边界与贴图边界对齐。

- Reset 

	重置 UV，将每个面片映射为到 UV 栅格，即面片与纹理图形 1:1 映射，每个面同样映射。


这些展开操作只对当前选择的面片有效，不会修改没有选中的面片的 UV 坐标。这些模式化的展开工具
相当于自动添加了缝合线。手动标记缝合线也可以，比如圆柱体，需要在上、下两个圆面的边缘，以及
柱体上标记一条缝合线以分割柱体方便展平，最后执行 Unwrap 命令将圆柱体展平成三个 UV 孤岛。
3D 视图的 Viewport Overlays 选项面板中可以打开缝合线的显示，用红色边线标记。

如果柱体没有沿纵向标记缝合线，或者两个圆面没有标记缝合线，那么展平时就需要做柱体到平面的投射。

模型的每个独立面对应 UV 的相应的面，尽管 UV 展开，就像把一个立体的物体，在一些地方适当地剪开，
然后，平摊到平的桌面上一样。这个平坦的贴图是包含对应模型各个面的 UV 坐标的。

一个面片通常只影射到纹理图像的一部分，坐标点不会占满 UV 编辑器中的空间。
类似地，多个面可以共用图像的同一部分，坐标点就会重叠在一起。

UV 展开的一般工作流程如下：

- 在模型上定义缝合线。
- 展开。
- 反复调整缝合线。
- 手动调整 UV。

在场景中添加一个 Cube 作为测试，按 Tab 进入编辑模式，给它标记上缝合线 Mark Seams。按下 2 数字
键切换到 Edge 模式操作，按住 Shift 选中需要标记的边，你想象一下如何把 Cube 盒子剪开才能平整铺
到桌面上，那么就选择那些边。

按 Ctrl+E 调出 Edge 边编辑菜单，选择标记缝合线 Mark Seams。那么在展开贴图是，就会按选选中的边
当做 UV 的剪开线对纹理贴图进行裁剪展开。按 Alt-A 取消选择时，缝合边会变成红色。已经标记的缝合边
可以取消标记 Clear Seam。

在标记缝合线时，可以在选择面后使用选择关联项 Select Linked，按 Ctrl-L 来检查那些面时相连的。
该菜单选项会选择所有与选中边相连的面，如果目标缝合线之外的面被选中，就可以知道你的缝合线不是连续的。

保持编辑模式，然后按 U 键打开 UV 菜单，选择展开命令 Unwrap 按定义的缝合线把 UV 贴图剪开并向
平面摊开。通过 UV Editor 视窗可以看到立方体的 UV 展开的效果，选择模型的各个面可以看到 UV Editor
对应的区域位置。也可打开 UV Editor 标题栏的 UV Sync Selection 选项，这样在贴图点击某个位置时，
贴图对应的模型面也会选中。

模型的 UV 展开以后就会存储在模型文件中，如果以 FBX、 OBJ 导出模型，UV 数据也包含在模型之中。


## 👉 UV Editor
https://docs.blender.org/manual/en/latest/editors/uv/index.html
https://docs.blender.org/manual/en/latest/modeling/meshes/uv/index.html

通过模型的 UV 展开后，接下来就需要使用 UV Editor 来细调 UV 面布局，编辑调整布局要达到的效果是：

- 将一些碎片(UV)重新缝合到一起。
- 最大化地利用图像空间。
- 对细节面进行放大。
- 调整/缩放被拉伸的面。
- 缩小过于粗糙和细节过多的面。

有实结构混乱的模型展开得到的是一个错乱的 UV 面片，需要对模型或展开结果进行调整。模型中那些相互没有
连结点的部分会产生独立 UV 面片，可以使用 Ctrl-L 来选择连结面片，即所谓 UV 孤岛。

UV 编辑器的选择模式有四种，顶点、 边、 面、 孤岛。在编辑器中，关闭同步选择 UV Sync Selection 就
可以使用孤岛选择模式 Island Selection Mode，按钮就在 UV 编辑器的左上角。

通过排列 UV 孤岛，可以将多个模型共享同一张贴图，这样做的好处是节约硬件资源。因为每张图像文件都会被
加载到内存里，不同的网格重复使用同一张图像，就可以节约内存。比如，可以绘制一个通用的脸部，然后用在
不同的角色上，通过调整 UV 映射和形状以及道具(墨镜)来加以区别。

使用 UV 雕刻快捷工具对 UV 布局进行变换：

- 移动、缩放、旋转等通用操作；
- Annotate 工具对 UV 面进行注解；
- Grab 抓起，调整布局线的顶点；
- Relax 松弛，放松布局线，使线条往更短的方向调整；
- Pinch 拿捏，将顶点往光标方向慢慢挪动；

UV 菜单提供功能：

- Export UV Layout 

	导出 UV 布局到图片，在外部图像处理程序如 PS 中加工上色。导出设置可选 UV 栅格贴图文件格式，
	UV 线的透明度、贴图文件像素大小等。

- Show/Hide Faces
	- Revel- Show/Hide Faces
	- Revel Hidden 恢复显示隐藏项 Alt-H
	- Hide Selected 隐藏选中项 H
	- Hide Unselected 隐藏未选项 Shift-H
 Hidden 恢复显示隐藏项 Alt-H
	- Hide Selected 隐藏选中项 H
	- Hide Unselected 隐藏未选项 Shift-H
- Weld/Align
	- Weld 焊接 W 将选中的 UV 顶点移动至其平均位置。
	- Merge UVs by Distance 合并指定边距的 UV 面。
	- Straighten 拉直
	- Straighten X
	- Straighten Y
	- Align Auto 自动对齐
	- Align X
	- Align Y
- Stitch 缝合 V，将选择的共享顶点的 UV 面连接起来。
- Minimize Stretch 最小化拉伸 Ctrl-V 通过最小化角度降低 UV 拉伸，这实质上是松弛UV。
- Average Island Scale 孤岛比例平均化 Ctrl-A， 对每个孤岛执行缩放，使其获得近似的缩放比例。

- Pack Islands 

	拼排孤岛 Ctrl-P 用于生成无重叠的最优 UV 布局以充分利用纹理空间。首先，它会统一缩放选中的 UV
	孤岛，然后分别变换每个孤岛，尽可能填满整个 UV 空间。

- Seams from Island 沿孤岛边线生成缝合边，将现有 UV 孤岛边界标记为缝合边。
- Unpin Alt-P 取消钉住 
- Pin P 钉住
- Copy Mirrored UV Coordinates 

	复制镜像 UV 坐标，将镜像所得网格一侧的 UV 复制到另一侧，仅影响选中顶点(两侧)。


在完成 UV 映射的编辑之后，你可能需要为同一物体创建其他的映射，或者将 UV 映射传递至其他网格。如果
两个网格有相同的几何/顶点顺序，可以将 UV 映射从一个网格复制给另一个。在模型视图中选择目标模型，
再按 Shift 复选 UV 来源模型，通过菜单 Object - Make Links - Transfer UV Maps 即完成 UV 传输。

一个网格并不限于一个 UV 映射，通过属性编辑器的物体数据可以为部分网格创建多个 UV 映射，

	Properties - Object Data Properties - UV Maps

每个 UV 映射总是包含整个网格，每个 UV 纹理也只有一个图像。

获得模型的 UV 布局最后都是为了将图像纹理正确地渲染到网格面上，如果用的是外部程序编辑图像纹理，
需要知道正在绘制的是网格的哪个部分。UV 编辑器允许直接将贴图映射到网格面，只需要在 3D 视图编辑器
中将视图着色方式设置为纹理 Meterial Preview 即可以立即预览 UV 编辑器或图像编辑器中的修改。

要把贴图渲染到物体，必须为物体创建材质，同过设置材质的图像纹理且告诉 Blender 在渲染时对物体表面
使用 UV 贴图。Cycles 着色器和灯光照明可以烘焙到图像纹理，这有几个不同的用途，最常见的是：

- 烘焙纹理，如基础颜色或法线贴图，用于导出到游戏引擎。
- 烘焙环境光遮蔽或程序纹理，作为纹理绘制或进一步编辑的基础。
- 创建光照贴图以提供全局照明或加快游戏中的渲染速度。

在渲染引擎属性编辑面板中指定烘焙类型，Rnder Properties - Bake - Bake Type，可以选择烘焙 UV 
仅烘焙材质的颜色和纹理，不含有着色信息。

UV 纹理是一张用于模型表面着色的图像(图片、图像序列或者影片)，它通过一张或者多张纹理 UV 贴图映射到
模型上的。使用 UV Editor，或 Image Editor 绘画模式都可以建立 UV 贴图，可以在前选中的 UV 纹理
上绘制平面图像，使用笔刷时设置合适的颜色还有笔刷纹理 Texture、 纹理遮罩 Mask 等等。参考官方文档
Sculpting & Painting » Modes » Texture Paint

笔刷纹理可以通过属性编辑器配置 Texture Properties。

在 3D 视图中可以使用直接在网格模型上绘制，让 Blender 使用当前选中的 UV 贴图更新 UV 纹理。

使用任意图像编辑软件来创建图像。在UV/图像编辑器中，选择UV纹理并加载图像。Blender 会将该纹理 UV
贴图的颜色传递到网格面上。

Blender内置的绘画模式叫 纹理绘制 ，它是特别为了在 UV/图像编辑器窗口或3D视图窗口简单快速绘制 UV
纹理和图像而设计的。由于 UV 纹理仅是一张特殊用途的图像，GIMP 或 Krita 等程序都可以创建。


## 👉 Geometry Node Editor
1. https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/index.html
2. https://docs.blender.org/manual/zh-hans/2.93/editors/geometry_node.html
3. https://docs.blender.org/manual/zh-hans/2.93/modeling/geometry_nodes/index.html
4. [嫩芽生长动画(几何节点)](https://www.bilibili.com/video/BV13P4y1V75T)
5. [几何节点生成无限种立面样式组合](https://www.bilibili.com/video/BV1yY41137UF)
6. [Blender 几何节点 - 电弧效果](https://www.bilibili.com/video/BV1PZ4y1973s/)

几何节点编辑器用于编辑由 *几何节点修改器* 使用的节点编组，也就是几何节点树的编辑器。该节点编组可
定义许多操作，以修改一个物体的几何信息。这是非常特殊的一个修改器，是程序化几何生成器。从实现上来看，
几何修改器作用于 GPU 渲染流水线的 Vertex Shder 编程阶段，通过修改顶点数据产生各种几何体。也作
用于 Fragment Shader，给几何体进行材质的处理。

使用几何修改器，可以编辑以下内容：

- Meshes
- Curves
- Point Clouds
- Volumes
- Instances

Spreadsheet 电子表格编辑器提供了数据图表，节点所有几何体的数据，包括顶点、边线、面片等数据。此外，
几何节点上提供了 Socket Inspection 和 Node Warnings 提示功能，通过鼠标悬停在端口，或者节点
右上角的警告图标，就会显示相应的提示信息，帮助了解节点的工作状态。

另外，还可以使用以下两个覆盖层，通过右上角 Node Editor Overlays 弹出菜单设置：

- Node Timings Overlay 显示上一次计算节点组时节点执行所需的时间。
- Named Attributes Overlay 显示节点使用的命名属性。

几何修改器有任意输入、输出端，Node Group 管理，输入输出分别在其它几何修改器中连接使用，引用其它
几何修改器时，通过 Group 节点分组下获取相应引用节点。

在几何节点编辑器中，任意节点相连成为一棵节点树，或者称为节点组。可以有任意的节点组，并且通过输入、
输出组节点进行数据传递，并且输出的属性可供材质编辑器使用。在几何修改器属性面板中，给输出属性命名，
Output Attributes 中指定名称。然后，在材质着色器中使用 **Attribute** 节点，输入几何节点
提供的属性名，并选择 Geometry 类型即可以使用属性数据。

几何修改器中设置的节点树可以标记为资产以方便复用，在节点组的下拉选择按钮上使用右键弹出菜单操作。

注意，因为节点的端口在连接时，会自动根据连接时使用的数据类型确定端口的数据类型，如果后继有变更，可以
在侧栏工具面板中管理设置，Sidebar - Group - Inputs/Outputs。

通过将字段端口连接到 Group Output，可以从节点树中任何节点的字段输出创建自定义属性。必须在组节点
的输出属性中指定属性的域。注意，这不适用于实例化数据，Instanced Data。比如，可以直接将 Curve 或
Mesh Primitive 中提供的基本几何体连接到输出节点的 Geometry，就会忽略输入，生成所设置的几何体。

首次在修改器中使用节点组时默认使用的属性名称在节点组输出面板中定义。


几何编辑器中，Filed 字段是函数，可以处理任意的输入得到一个输出值。几何节点按端口类型差别分为三种：

- **Dataflow Nodes**：包含几何体输入/输出的节点，包含圆圆端口 Circle；
- **Function Nodes**: 执行函数运算的节点，包含棱形输入输出端口 Diamond；
- **Input Nodes**: 为其它节点提供数据的节点；

其中，连接虚线的带点棱形表示 varying input，可以输入多种数据类型。

一个常见的误解是，同样的 Filed 节点连接产生同样的输出！但实际不是，随着场景数据的改变，节点在不同
时间下输出的值是可以不相同的。

![nodes fields flow](https://docs.blender.org/manual/en/latest/_images/modeling_geometry-nodes_fields_flow-2.png)

属性 Attributes 是一个通用术语，描述几何数据块中每个元素存储的数据。是几何节点中非常重要的概念。
例如，每个顶点可以关联数值或者向量，通过将值连接到输出节点来更改属性，节点也可以更改特定属性的值。
属性有多种形式及数据类型：

- Named Attributes
- Anonymous Attributes
- Built-In Attributes
- Custom Attributes

|   Data Type   |                     Notes                     |
|---------------|-----------------------------------------------|
| Boolean       | True or false value                           |
| Integer       | 32-bit integer                                |
| 8-Bit Integer | Smaller integer with a range from -128 to 127 |
| Float         | Floating-point value                          |
| Vector        | 3D vector with floating-point values          |
| 2D Vector     | 2D vector with floating-point values          |
| Color         | RGBA color with 32-bit floating-point values  |
| Byte Color    | RGBA color with 8-bit positive integer values |

属性域 Attribute Domains 是指属性对应的几何元素类型。了解属性的域很重要，它定义了如何在节点和
着色中进行插值和使用。

可以使用电子表格编辑器来确定属性的域，Spreadsheet 列表中显示的是几何节点当前输出的数据。

各种属性域参考如下：

- **Point domain** 关联空间中一个位置的属性，有以下三种：
	- Vertices of a mesh
	- Points of a point cloud
	- Curve control points
- **Edge domain** 关联面片的边线的属性。
- **Face domain** 关联网格的面片的属性。
- **Face Corner domain** 关联网格面片角位的属性，如 UV 映射属性。
- **Spline domain** 关联一组样条控制点的属性。
- **Instance domain** 几何实例数据属性，只用于几何节点。

不同域的属性会自动插值转换。例如 Position Node 连接到 Set Material Node 节点的选择输入端口，
属性值从 Point 域插值到 Face 域。域转换通常取平均值，但布尔数据类型属性具有特殊的插值规则，比如
Point 域到 Edge，当边线两个顶点都选中时，则转换结果等于选中边线。

除了存储网格或曲线等真实数据外，几何体可以存储实例，所谓实例 Instance 即引用原始数据，而不是复制
出新的实际数据。这些实例本身可以引用更多几何体、对象或集合。实例化目的是在结果中包含更多的几何图形，
而避免复制实际数据。这是因为与复制数据时相比，Cycles 这样的渲染器的可以更好地处理只是位置上有差别
的相同几何数据。

ID Marker 应用示范，给一个 Cube 各个顶点添加 ID 序号标记显示：

- 首先，创建一个 String to Curve，将字母作为序号字符串输入到 String 属性中使用；
- 通过 Instance on Point 将序列字符串实例化到几何体的顶点上。
	- 连接输入节点 Geometry 到 Points；
	- 连接字符串曲线节点 Curve Instance 到 Instance；
	- 连接几何体顶点序号属性到 Pick Instance，可以使用 **Index Node** 或 **ID Node**；
	- 因为字符串生成的曲线会按序号出现偏移位置，可以通过 Set Postion 将每个字符归位。

Pick Instance 输入为 0 表示不做选择，即选择所有，可以使用 **Math** 节点进行数学运算处理。


书本纸张双面贴图演示：

- 创建 UV 贴图，勾选 Tile 启用拼贴贴图；
- 也可以通过侧栏工具创建 Image - Source - UDIM Tiles，并对 1001 贴图执行 Fill Tile；
- 在 UDIM Tiles 列表中，点击 + 号添加分块，指定 Count 为纸张的数量，即创建相应的贴图拼块数量；
- 在 Image 面板中点击 Pick Image 右侧的贴图选选择按钮，从文件浏览器中选择图像文件；
- 着色器中连接纹理坐标、Mapping、Image Texture 使用纹理贴图，通过调整 UV 坐标就可以使用 UDIM。
- 添加输入节点 Geometry 获取几何数据，使用 Backfacing 用来做正反面判断，分别对应 0.0 和 1.0。
- 正面放偶数序号的贴图，反而放奇数号的贴图，需要在几何节点编辑器提供相应的数据来驱动纹理坐标。

几何节点编辑器中设置：

- 添加一个 Mesh - Grid 节点用于定义纸张的基本网格；
- 因为有多张纸，需要使用实例化 Instance on Points；
- 为了将纸张实例化在一行、一列或一叠的形态，可以使用 Mesh Line 节点给实例节点提供 Points 输入；
- 为了给实例出来的网格设置不同的纸张贴图，需要对其进行 Realise 真实化，这样可以能进行材质设置；
- 注意，实例 Realize 之后会产生 Face Corner 属性 uv_map，原本几何体的坐标数据为 UVMAP；
- 为了着色器能够正确使用纸张的正反面贴图，需要将网格体的 ID 输出，索引属性也可以；
- 在 Realize 后使用 Capture Attribute 捕捉几何数据，Value 连接一个 ID 属性节点；
- 将捕捉到的 ID 属性数据值连接到输出节点，并在几何修改器属性面板中为其指定一个名称，如 faceid。

注意，捕捉节点要设置为 **float** 类型和 **face** 属性域，并且要保持和 Group Outputs 设置
一致。否则在着色器中不能正确获取属性数据，尽管捕捉节点中可以设置为 integer 数据类型，但输出端口
一定要设置为 float 类型。

使用 Transfer Attribute 节点也可以将面片 ID 输出给着色器使用，但需要注意，其映射方式和属性域
的设置，与 Surface 输入不匹配则不能正确获取到面片 ID 值。可以使用 Spreadsheet 数据表查看相应
属性域中是否有相应的数据输出。

着色器使用 Attribute 读取 uv_map 作为纹理贴图坐标，以正确处理实例产生的几何体贴图。注意，UDIM
各个贴图 UV 空间依次为 (0-1, 1-2, 2-3)，递增关系。在处理 UV 坐标时，只需要修改对应的分量即可，
使用 Vector 合并节点。再与初始 UV 值相加，得到正确 UV 坐标。

面片 ID 从 0 开始计数，为了将贴图与正反面对应，可以按以下思路处理：

- 使用 Math Multiply 将 ID 加倍，这时，每个面片的正面显示的是同为奇数偶数页的贴图；
- 使用 Backfacing 值，将其乘 -1 并且与上一步产生的值叠加起来，即可以实现两面不同贴图；
- 注意：渲染可能从背面开始，此时应该将乘数 -1 改为 1。



新版本使用 Store Named Attribute 将属性值保存为 2D Vector 类型以及 Face Corner 属性域，
并且命名为 **uv**。然后，在着色器中就可以通过纹理坐标节点输出的 UV 读取，不需要再通过属性节点。
旧版本虽然可以覆盖掉 **UVMap**，但是只能使用 3D Vector，所以并不能正确存储 UV 坐标属性值。


要自动创建贴图并加载贴图到相应的位置，需要按以下两种规则之一命令贴图文件，每行最多 10 张图：

	<UDIM>: A 4-digit notation calculated as 1001 + u-tile + v-tile * 10.
	<UVTILE>: A notation defined as u(u-tile + 1)_v(v-tile + 1).

例如，

	monster.<UDIM>.png   will load/save files like monster.1021.png etc.
	monster.<UVTILE>.png will load/save files like monster.u1_v3.png etc.

使用以下 PowerShell 脚本可以对 JPG 文件进行序列化命名：

	$seq=1001; 
	(dir *.jpg) | % { ren $_.name "prefix.$seq$($_.Extension)"; $seq = $seq + 1; }

	$seq=1; 
	(dir *.jpg) | % { ren $_.name "udim.u$($seq)_v1$($_.Extension)"; $seq = $seq + 1; }


- [点云 实例随机材质赋予](https://www.bilibili.com/video/BV1wR4y1W7cN)
- [几何节点详解 书页坐标传递](https://www.bilibili.com/video/BV1k44y1Y7gE)


几何编辑器提供的节点类型非常丰富，涉及曲线、网格、材质等各个方面，总体可以将它们分成三类型，使用
它们进行程序化建模：

功能处理类型：

01. Input Nodes 几何节点输入；
02. Utilities Nodes 工具类节点；
03. Vector Nodes 向量运算处理；
04. Volume Nodes 体积处理；
05. Instances Nodes 实例处理节点；
06. Output Nodes 几何节点输出；

几何体、网格、曲面处理类型：

01. Geometry Nodes 几何处理节点；
02. Point Nodes
03. Curve Nodes
04. Curve Primitive Nodes 基本曲线节点；
05. Curve Topology Nodes 曲线拓扑节点；
06. Mesh Nodes
07. Mesh Primitive Nodes 基本网格几何体；
08. Mesh Topology Nodes 网格拓扑节点；

纹理处理类型：

01. Color Nodes 颜色处理；
02. Material Nodes 材质处理节点；
03. Text Nodes 字符串、文本纹理处理；
04. Texture Nodes 纹理生成；
05. UV Nodes 贴图坐标处理；

几何节点中不支持创建材质，需要先创建好材质，再通过 **Material** 节点获取相应的材质，以及使用
材质处理节点对使用不同材质的面片进行处理。


### ⚡ Blender 3.5 毛发几何节点
1. Hair Nodes https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/hair/index.html
2. Blender 3.5 Release Notes https://www.blender.org/download/releases/3-5/
3. 快速上手 Blender 3.5 毛发几何节点 https://www.bilibili.com/video/BV1hs4y1D7oq/
4. Blender New Hair Sysetm by Noggi https://www.bilibili.com/video/BV13B4y1e7sE/


自 Blender 3.3 引入 curves-based hair system，新版本的毛发系统已对集成到几何节点。
通过 Asset Browser 访问毛发预置资产，使用这些毛发资产相当于给毛发对象添加修改器。
往场景中添加一个 Curve - Empth Hair 对象，它会自动附加到最后选择的几何体上。
进入毛发雕刻模式，雕刻出毛发，然后将毛发资产拖动到毛发对象上，会自动创建几何节点修改器，
并且将资产预置的节点添加到节点编辑器中，也可以在几何节点编辑器中添加毛发资产节点。

注意，几何体也可以接收毛发资产的节点修改器配置。

Hair Nodes 对应了 26 个毛发资产：

- Deformation
	01. Blend Hair Curves
	02. Displace Hair Curves
	03. Frizz Hair Curves
	04. Hair Curves Noise
	05. Roll Hair Curves
	06. Rotate Hair Curves
	07. Shrinkwrap Hair Curves
	08. Smooth Hair Curves
	09. Straighten Hair Curves
	10. Trim Hair Curves
- Generation 毛发生成、复制、插值生成
	01. Duplicate Hair Curves
	02. Generate Hair Curves
	03. Interpolate Hair Curves
- Guides 引导毛发成束
	01. Braid Hair Curves
	02. Clump Hair Curves
	03. Create Guide Index Map
	04. Curl Hair Curves
- Read
	01. Curve Info
	02. Curve Root
	03. Curve Segment
	04. Curve Tip
	05. Hair Attachment Info
- Utility
	01. Attach Hair Curves to Surface
	02. Redistribute Curve Points
	03. Restore Curve Segment Length
- Write
	01. Set Hair Curve Profile


### ⚡ Function Nodes

Attribute Nodes 属性处理节点：

- **Attribute Statistic** 数学统计 Attribute 端口输入的几何体属性值，并输出整个数据集的统计信息。
- **Domain Size** 属性域大小，获取几何体各种属性域数据，比如面片数量、顶点数量等等。
- **Capture Attribute** 属性捕捉，将值保存在几何体数据块中，并输出给其它节点使用，但不命名。
- **Store Named Attribute** 保存命名属性，将值保存到几何体数据块中，并设置一个名称。
- **Remove Named Attribute** 移除已经保存的命名属性。
- **Transfer Attribute** 属性传递节点在新版本中，根据其映射方式拆分成三个节点。
	- Geometry Nodes - **Sample Index**
	- Geometry Nodes - **Sample Nearest**
	- Mesh Nodes - **Sample Nearest Surface**
- **Blur Attribute** 新版本增加的模糊功能节点，根据几何体拓扑结构进行模糊。

模糊属性参考：

- https://www.bilibili.com/video/BV1F24y1D7ns
- https://docs.blender.org/manual/en/3.5/modeling/geometry_nodes/index.html

保存的命名属性会在修改器面板中显示在 Internal Dependencies 分组下，即内部属性。要将内部属性
输出给外部修改器使用，可以通过 **Named Attribute Node** 将属性连接到组输出节点。后续的几何
修改器可以在 Group 分组下获取到前面输出的属性数据。这个过程和着色器的变量传递类似，本质就是如此。

Input Nodes 包含场景中原始的几何体数据输入，以及一些常量输入，如：

- **Boolean Node** 布尔值常量。
- **Color Node** 颜色值常量。
- **Integer Node** 数值常量。
- **String Node** 字符串常量。
- **Material Node** 材质选择及输出节点。
- **Object Info** 获取场景中的对象信息，当前几何节点编辑器 Pin 住，将其它对象拖入即可生成。
- **Collection Info** 获取场景中其它集合中的几何体，同样可以从场景树中拖入生成此节点。
- **Self Object Node** 使用几何节点的当前对象，新版本已经移除。
- **Scene Time Node** 场景时间输出，单位是 seconds 或 frames。
- **Index Node** 给出当前元素在列表中的序号。
- **ID Node** 点域中每个元素的 ID 序号，存储在 id 属性中。
  注意，与其他内置属性不同，id 属性并不总是存在的。在这种情况下，该节点将输出索引。
- **Named Attribute Node** 获取已定义的命名属性，配合属性节点或输出节点使用。
- **Is Viewport Node** 判断是否处理视口模式，当前视口看见的几何体都是，在执行渲染时即非视口状态。

Instances Nodes 实例化操作节点，用于复制生成几何体：

- **Instance on Points** 将 Instance 输入的几何体实例化到 Points 指定的位置；
- **Instances to Points** 获取 Instance 输入的几何体原点作为输出；
- **Instance Rotation** 获取几何实例的旋转向量；
- **Instance Scale** 获取几何实例的缩放值；
- **Rotate Instances** 在 local 或 global 空间旋转几何体实例，注意不影响原始几何体；
- **Scale Instances** 在 local 或 global 空间缩放几何体实例，注意不影响原始几何体；
- **Translate Instances** 在 local 或 global 空间移动几何体实例，注意不影响原始几何体；
- **Realize Instances** 将实例转换为真实几何体，即拷贝原始数据产生新的几体体。

通过 Instance on Points 几何节点实例化墙面几何结构，将物体集合（Collection）内的几何体实例化
出来，从而产生任意组合的建筑立面。特别适合香港这种差别不大重复度极高的公寓建筑立面。

将建筑图片作为几何体的贴图，展示出墙面的大体外观，只需要给窗户、空调等大件添加细节面，不必扣其它细节。

注意，实例化几何体后，如果再对生成的实例做 **Realize** 操作，会导致着色器中不能通过纹理坐标节点，
Texture Coordinates 来获取 UV 坐标，而需要使用 Attribute 节点读取几何节点提供的 UVMap 数据。

使用 Python 脚本获取对象的几何属性数据、UVMaps 数据，UV 坐标数据就是一个向量值：

```py
	# Geometry Node Attributes
	>>> C.selected_objects[0].data.attributes.values()
	# Geometry UV Maps
	>>> C.selected_objects[0].data.uv_layers.values()

	>>> dir(C.selected_objects[0].data.uv_layers[1].data[0])
	[..., 'bl_rna', 'pin_uv', 'rna_type', 'select', 'select_edge', 'uv']

	>>> C.selected_objects[0].data.uv_layers[1].data[0].uv
	Vector((0.375, 0.0))

	>>> [it.uv for (id, it) in C.selected_objects[0].data.uv_layers[1].data.items()]
	[Vector((0.375, 0.0)), Vector((0.625, 0.0)) ...]
```

Utilities Node 实用工具节点：

01. **Align Euler To Vector** 对齐欧拉角至矢量
02. **Boolean Math** 布尔运算
03. **Clamp** 钳制
04. **Compare Floats** 比较浮点
05. **Float Curve** 浮点曲线
06. **Float to Integer** 浮点转整数	
07. **Map Range** 映射范围
08. **Math** 数学运算，Divide/Add/Minus/Multiply，三角函数等等
09. **Random Value** 随机值
10. **Rotate Euler** 欧拉旋转
11. **Switch** 切换开关，输入布尔值控制输出。

Vector Nodes 矢量处理节点：

01. **Combine XYZ** 合并分量输出一个矢量。
02. **Separate XYZ** 分离矢量输出三个分量。
03. **Vector Curves** 映射输入向量的分量到曲线，并输出一个向量，用于减慢或加快速度。
04. **Vector Math** 提供向量的各种数学运算功能。
05. **Vector Rotate** 向量旋转功能。

Volume Nodes 体积处理：

01. Volume Cube Node
02. Volume to Mesh Node

以上是一些通用功能节点，还有大量涉及点、曲线、面片材质处理的节点。


### ⚡ Geometry Nodes
- [Geometry Node 程序化建模 - Rolling Box](https://www.bilibili.com/read/cv21998124)

Geometry Nodes 提供了几何处理的功能：

01. **Bounding Box** 边界框即一个包围盒，在几何体变换后，新的边界框依然是可以将变换后的几何体包裹。
02. **Convex Hull** 凸壳和凸形是指：过其一平面的直线不会与其它面相交的形状。
03. **Delete Geometry** 删除几何体的指定部分，点、边、面、样条、实例等。
04. **Duplicate Elements** 在原位置复制几何体的指定部分，点、边、面、样条、实例等。
05. **Geometry Proximity** 几何接近，用来计算与 target 最接近的坐标，配合位置可以实现吸附效果；
06. **Geometry to Instance** 将多个几何转化为实例，和 Join 操作类似，但没有合并几何数据。
07. **Join Geometry** 合并多个几何体成一体。
08. **Merge by Distance** 将指定距离周边的网格顶点合并，精简几何结构。
09. **Raycast Node** 在指定几何体向指定方向投射光线，输出光线击中其它几何体的信息，击中点坐标、距离等等。
10. **Sample Index** 根据指定索引采样输入几何体的数据。
11. **Sample Nearest** 根据输入位置采样几何体的最近的元素索引，类似几何接近节点，只是输出索引值。
12. **Separate Components** 将输入几何体各种组件拆分输出，组件包括网格、点云、曲线、体积、实例等几何体。
13. **Separate Geometry** 根据 Selection 将输入的几何体一分为二。
14. **Transform** 对几何体进行变换操作。
15. **Set ID** 给输入的几何体设置元素 ID 属性的值，会改变顶点原来的 ID 序号。
16. **Set Position** 设置几何体或元素的位置。

使用 **Bounding Box** 边界框可以比较方便地实现 Rolling Box 动画，通过变换使盒子滚动时，根据
最新的边界盒数据来更新 Box 的位置，使其像在地面上滚动一样。

考虑在地面上滚动的箱子，每旋转 90 度，就是一个运动周期，滚动距离为单条边的长度。当对角线竖直时，
滚动角度变化与产生滚动距离达到最大例。质心的运动曲线大概是 ⌒⌒⌒⌒⌒⌒ 这样重复的。

根据傅里叶变换的观点，任何曲线都可以使用一组不同周期的三角函数组合而成。可以先将这种曲线看作是匀速
平移，每周期移动距离为边长的 2 倍。另一方面，可以使用三角函数进行修正，使其在箱子对角线在竖起时达到
最大的滚动速度，而在箱子边线贴紧地面时达到最小的移动速度。注意，三角函数的周期是 2PI，即 360 度。

Blender 默认创建的 Cube 边长为 2m，缩放值为 1，也就是默认的匀速移动 4m/s。

使用 Transform 做矩阵变换进行平移时，Translation 中的值表示单位长度，即 1 表示一单位边长。


Point Nodes 顶点处理节点：

01. **Distribute Points in Volume** 将顶点分布于指定体积容器内。
02. **Distribute Points on Faces**  将顶点分布于指定面片上。
03. **Points Node** 
04. **Points to Vertices** 
05. **Points to Volume** 
06. **Set Point Radius** 

Curve Nodes

01. Curve Length Node
02. Curve to Mesh Node
03. Curve to Points Node
04. Deform Curves on Surface Node
05. Fill Curve Node
06. Fillet Curve Node
07. Resample Curve Node
08. Reverse Curve Node
09. Sample Curve Node
10. Subdivide Curve Node
11. Trim Curve Node
12. Curve Handle Position Node
13. Curve Tangent Node
14. Curve Tilt Node
15. Endpoint Selection Node
16. Handle Type Selection Node
17. Is Spline Cyclic Node
18. Spline Length Node
19. Spline Parameter Node
20. Spline Resolution Node
21. Set Curve Radius Node
22. Set Curve Normal Node
23. Set Curve Tilt Node
24. Set Handle Positions Node
25. Set Handle Type Node
26. Set Spline Cyclic Node
27. Set Spline Resolution Node
28. Set Spline Type Node

Curve Primitive Nodes

01. Arc Node
02. Bézier Segment Node
03. Curve Circle Node
04. Curve Line Node
05. Curve Spiral Node
06. Quadratic Bézier Node
07. Quadrilateral Node
08. Star Node

Curve Topology Nodes

01. Curve of Point Node
02. Offset Point in Curve Node
03. Points of Curve Node


Mesh Nodes

01. **Dual Mesh** 对偶化网格，即面转化为顶点，顶点转化为面。属性也会转移到对偶网格中的点域。
02. **Edge Paths to Curves** 
03. **Edge Paths to Selection** 
04. **Extrude Mesh** 
05. **Flip Faces** 
06. **Mesh Boolean** 
07. **Mesh to Curve** 
08. **Mesh to Points** 
09. **Mesh to Volume** 
10. **Sample Nearest Surface** 提供最近曲面点处的任何属性的值，采样输入网格中最近面片上的值。
11. **Sample UV Surface** 
12. **Scale Elements** 
13. **Split Edges** 
14. **Subdivide Mesh** 细分网格
15. **Subdivision Surface** 细分曲面
16. **Triangulate** 面片三角化
17. **Edge Angle** 
18. **Edge Neighbors** 
19. **Edge Vertices** 
20. **Face Area** 
21. **Face Neighbors** 
22. **Face Set Boundaries** 
23. **Is Face Planar** 
24. **Is Shade Smooth** 
25. **Mesh Island** 
26. **Shortest Edge Paths** 最短边路径查找，Dijkstra 寻路算法实现。
27. **Vertex Neighbors** 
28. **Set Shade Smooth** 

Mesh Primitive Nodes

01. Cone Node
02. Cube Node
03. Cylinder Node
04. Grid Node
05. Icosphere Node
06. Mesh Circle Node
07. Mesh Line Node
08. UV Sphere Node

Mesh Topology Nodes

01. Corners of Face Node
02. Corners of Vertex Node
03. Edges of Corner Node
04. Edges of Vertex Node
05. Face of Corner Node
06. Offset Corner in Face Node
07. Vertex of Corner Node


### ⚡ Material Nodes


Material Nodes 材质处理节点：

01. **Replace Material** 使用新材质替换掉几何体的材质。
02. **Material Index** 输出每个元素对应的几何体材质列表中的材质索引呈。
03. **Material Selection** 选择使用了指定材质的面片。
04. **Set Material** 给几何中选中的面片设置指定材质。
05. **Set Material Index** 给几何体材质设置索引号，material_Index 是面片上的内置属性。

Text Nodes 节点提供字符串处理能力：

01. **Join Strings** 使用 Delimiter 连接符将输入的多个字符串连接起来。
02. **Replace String** 字符串内容替换，输出替换后的内容。
03. **Slice String** 字符串分割，指定位置与长度分割字符串。
04. **Special Characters** 特殊字符，如 Tab、换行符号。
05. **String Length** 获取字符串长度，并输出数值。
06. **String to Curves** 字符串转换为曲线。
07. **Value to String** 数值转换字符串。

Texture Nodes 纹理噪声生成节点：

01. **Brick Texture** 砖墙纹理生成。
02. **Checker Texture** 棋盘格纹理。
03. **Gradient Texture** 渐变色纹理。
04. **Image Texture** 图像纹理。
05. **Magic Texture** 从着色器节点移植的迷幻纹理。
06. **Musgrave Texture** 从着色器节点移植的马斯格雷夫纹理。
07. **Noise Texture** 噪声纹理。
08. **Voronoi Texture** 沃洛诺伊细胞风格纹理。
09. **Wave Texture** 波浪纹理。
10. **White Noise Texture** 白噪声纹理。

Musgrave 纹理节点计算输入纹理坐标处的分形 Perlin 噪波。Noise Texture 也是分形 Perlin 噪波，
不同的是，Musgrave 纹理允许更好地控制八度的组合方式。输出 height 


Color Nodes 颜色处理节点：

01. **Color Ramp** 颜色映射。
02. **Combine Color** 合并颜色分量
03. **Mix Node** 颜色混合。
04. **RGB Curves** 通过曲线调出颜色。
05. **Separate Color** 分离颜色为分量。

UV Nodes 贴图坐标处理：

01. Pack UV Islands Node
02. UV Unwrap Node


# 🚩 Modifiers 修改器
- https://docs.blender.org/manual/zh-hans/3.0/modeling/modifiers/index.html
- https://docs.blender.org/manual/en/latest/grease_pencil/modifiers/index.html

通过模型对象的属性栏使用修改器，扳手图标 Properties - Modifier Properties

修改器是一种自动操作，以非破坏性的方式影响对象的几何形状。使用修改器，可以自动执行许多效果而且不会
影响对象的基本几何形状，否则手动执行这些效果，例如细分曲面 Subdivision，螺旋 Screw，阵列重复
 Array 等等会非常麻烦。

它们的工作原理是改变对象的显示和渲染方式，而不是改变可以直接编辑的几何图形。您可以向一个对象添加
多个修改器，以形成修改器堆队列，如果您希望该更改永远存在，则 Apply 应用一个修改器。

按用途修改器分为四类，不同的修改器可以结合粒子系统，物理系统等一起使用。比如用于变形挂钩修改器
Hook Modifier，给一个模型设置一个挂钩后，场景中就相应添加一个用来控制网格结构的 Empty 对象，
通过对象这个 Empty 对象的变形，就可以实现对挂钩关联的网格变形。虽然钩子不能像形状键那样很好地控制
顶点的移动，但它们的优势是可以直接选择顶点进行操作。

作为常用的细化修改器 Subdivision，可以直接使用快捷键 Ctrl-0 ~ 5 添加 5 级细化。 

顶点组 Vertex Group 常用工具，配合修改器可以控制哪些顶点受到修改器的影响，以及影响到什么程度，
即使用它们的顶点权重 Vertex Weight，在修改网格或晶格时，它们都可用。

比如挂钩修改器中可以指定 Vertex Group 来控制每个顶点影响程度，给顶点进行权重绘制 Weight Paint，
再将顶点组的所有顶点关联到挂钩上。

纹理 Texture 也是修改器常用的选项，纹理选项允许使用任何类型的图像，包括参数图像来控制修改器的效果。
大多数情况下，只使用纹理的灰度，但在某些情况下，如置换修改器 Displace Modifier 的一些模式，可能
会利用整个 RGB 颜色组件。

曲面模型对象修改器：

- 修改 Modify

	- Data Transfer 数据传递修改器
	- Mesh Cache 网格缓存修改器
	- Mesh Sequence Cache 网格序列缓存修改器
	- Normal Edit 法线编辑修改器
	- Weight Normal 加权法向修改器
	- UV Project UV 投射修改器
	- UV Wrap UV 偏移修改器
	- Vertex Weight Edit 顶点权重编辑修改器
	- Vertex Weight Mix 顶点权重混合修改器
	- Vertex Weight Proximity 顶点权重邻近修改器

- 生成 Gennerate

	- Array 阵列修改器
	- Bevel 倒角修改器
	- Bollean 布尔修改器
	- Build 建形修改器，使网格物体的面随着时间的推移一个接一个地出现或消失。
	- Decimate/Simplify 精简修改器
	- Edge Split 拆边修改器
	- Mask 遮罩修改器
	- Mirror 镜像修改器
	- Multires 多级精度修改器 Multi-Resolution Modifier
	- Remesh 重构网格修改器
	- Screw 螺旋修改器
	- Skin 蒙皮修改器，将顶点和边当作骨架来创建蒙皮面，用顶点的半径来更好地定义形状。
	- Solidify 实体化修改器
	- Subdivision Surface 表面细分修改器 
	- Triangulate 三角化修改器
	- Weld 焊接修改器
	- Wireframe 线框修改器

- 形变 Deform
	
	- Armature 骨架修改器
	- Cast 铸型修改器
	- Curve 曲线函数修改器
	- Displace 置换修改器
	- Hook 挂钩修改器
	- Laplacian Deform 拉普拉斯形变修改器
	- Lattice 晶格修改器
	- Meshreform 网格变形修改器
	- Shrinkwrap 缩裹修改器
	- Simple Deform 简易形变修改器
	- Smooth 平滑修改器
	- Smooth Corrective 矫正平滑修改器
	- Smooth Laplacian 拉普拉斯平滑修改器
	- Surface Deform 表面变形修改器
	- Wrap 弯绕修改器
	- Wave 波浪修改器：给几何对象添加波浪运动效果。

- 模拟 Simulate
	
	- Cloth 布料修改器
	- Collision 碰撞修改器
	- Dynamic Paint 动态绘图修改器
	- Explode 爆炸修改器
	- Fluid Simulation 流体模拟修改器
	- Ocean 海洋修改器
	- Partical Instance 粒子实例修改器
	- Partical System 粒子系统修改器
	- Smoke 烟雾修改器
	- Soft Body 软体修改器

Grease Pencil 修改器：

- Generate
	01. Array Modifier
	02. Build Modifier
	03. Dot Dash Modifier
	04. Envelope Modifier
	05. Length Modifier
	06. Line Art Modifier
	07. Mirror Modifier
	08. Multiple Strokes
	09. Outline Modifier
	10. Simplify Modifier
	11. Subdivide Modifier
- Deform
	01. Armature Modifier
	02. Hook Modifier
	03. Lattice Modifier
	04. Noise Modifier
	05. Offset Modifier
	06. Shrinkwrap Modifier
	07. Smooth Modifier
	08. Thickness Modifier
	09. Color
	10. Hue/Saturation Modifier
	11. Opacity Modifier
	12. Tint Modifier
- Modify
	01. Texture Mapping Modifier
	02. Time Offset Modifier
	03. Vertex Weight Angle Modifier
	04. Vertex Weight Proximity Modifier



## 👉 Vertex Weight Mix 顶点权重混合修改器

此修改器使用不同的操作将第二个顶点组(或简单值)混合到受影响的顶点组中。

混合模式决定模型顶点组权重如何受 Vertex Group B 顶点组权重的影响。例如，使用替换权重 Replace 
就会用第二组的权重替换受影响的权重，Mix Set 决定哪些顶点将受到影响。对于不在指定顶点组的顶点，
Default Weight A/B 指定其默认权重。

Influence/Mask 选项对于三种顶点权重修改器 Vertex Weight Eddit/Mix/Proximity 是相同的。

全局影响对修改器的整体有影响，0.0 将保持顶点组的权重不变，1.0 是标准影响。 影响仅作用于权重，此值
设置为 0.0 并不会阻止向/从顶点组添加/删除顶点。 使用顶点组或纹理(两者都是互斥的)对每个顶点的精细
控制影响效果，其中的每个顶点值将与全局影响值相乘。


## 👉 Multiresolution 多级精度修改器
- [Multires 多级精度修改器](https://www.bilibili.com/video/BV18f4y1N7Fg)
- [FlyCat - Born to run... 3D 角色动画全流程](https://www.bilibili.com/video/BV1SU4y1j7nw)
- [FlyCat - 古风少女角色雕刻全流程 Character Sculpting](https://www.bilibili.com/video/BV11X4y1K7Vv)
- [FlyCat on Patreon](https://www.patreon.com/flycat/posts?filters[tag]=Blender)
- https://docs.blender.org/manual/zh-hans/3.0/modeling/modifiers/generate/multiresolution.html

曲面细分基本思想是在每条边上插入一个新顶点，可以看到随着细分次数的增加，折线逐渐变成一条光滑的曲线。
曲面细分需要有几何规则和拓扑规则，几何规则用于计算新顶点的位置，拓扑规则用于确定新顶点的连接关系。

曲面细分是指将一个模型的面合理的分成更多小的面，从而提升模型精度，提高渲染效果。曲面简化是指将一个
模型的面合理的合成更少的面，从而降低模型精度，为特定情形下提供使用，如 LOD (Level Of Detail)。

Catmull-Clark 是一种四边形网格的细分算法，每个面计算生成一个新的顶点，每条边计算生成一个新的顶点，
同时每个原始顶点更新位置。

时钟拨回到 1972 年, 在 Utah 大学的计算机科学课程上, 一位博士, 用贝塞尔曲线算法, 为这节课提交了
一个课程项目：A Computer Animated Hand，这只手, 是美国历史上最早记载的计算机生成动画(CG)。

这位博士, 名字叫做 爱德稳 卡特缪尔(Edwin Catmull)，在此前 3 年，他刚拿到自己的物理系学位，
凭借着自己对于图形的热情，他成为了一家叫 Applicon 的做 CAD 软件的公司的雇员。直到他遇到了
Ivan Sutherland 而开始了计算机科学博士学位的进修，仿佛重获新生，找到了将自己的艺术理想与
理工科学结合的希望。

Ivan Sutherland 是图灵奖得主、计算机先驱、冯诺伊曼奖章、工程与科学院院士、ACM会士、计算机历史博物馆会士，
伊凡·苏泽兰是计算机图形学之父，是 Sun 研究院的高级技术顾问，是隐藏在 Sun 团队背后真正的导师。

1974 年 Catmull 的博士毕业论文至今超过一千引用，他当时也许不知道自己的博士论文将创造一个伟大的时代，
A subdivision algorithm for computer display of curved surfaces。


多级精度修改器 Multi-Resolution Modifier (Multires) 可以让你像表面细分修改器那样细分网格，
但也可以在雕刻模式中修改新的细分等级。

多级精度修改器是唯一一个不能在修改几何形状、或其他对象数据之后，在堆栈中重新定位的修改器。即所有生成
修改器，和一些形变、模拟修改器不能在多级精度修改器之前出现。

多级精度修改器用于非破坏性雕刻，多级精度控制模型的精细度，同时保留了模型的 LOD，在游戏制作中也非常
方便地导出不同精细度的模型。

在雕刻模式下启用动态拓扑功能，Ctrl-D，模型的风格会随着雕刻而改变，会破坏原有模型结构。

如果使用表面细分修改器 Subdivion Surface，那么对模型进行雕刻时，修改的是模型原有的顶点数据。
而网格细分工具细分出来的顶点则根据原有模型的顶点数据构造出细分的模型，所以不能进行实时的雕刻。

Multires 则不同，它细分出来的模型可以直接雕刻，并且可以随时在不同的细分级别下调整出来不同 LOD。

参考 Patreon 上 FlyCat 的作品：

- 古风少女角色雕刻全流程展示了破坏性雕刻工作流程，先动态拓扑雕刻模型，得到满意的模型后，再手工拓扑，精简模型网格。
- Born to run... 3D 角色动画全流程则非破坏性雕刻，使用多级细分修改器，对细分模型进行雕刻，直接得到精简网格体模型。

Multires 修改器选项使用：

- 选择模型，通过 Modifier Properties 属性面板添加 Generate -> Multiresolution 修改器。
- 设置细分方式，Catmull-Clark 或 Simple，前者是针对四边形网格细分的算法，后者是 Loop 细分曲面算法。
- 第一次点击 Subdivide 表示一级细分，这里可以调整 Preview/Render 的级别，当前只有 0 和 1 两个级别。
- 再次点击 Subdivide 表示进行二次细分，这时就有 0、1、2 三个级别的精细度，你可以按需求设置细分精度级别。
- Delete Higher 表示删除最高一级细分，依次逐级进行删除。
- Reshape 从另一个网格复制顶点坐标。使用前先选择有与之匹配的拓扑结构和顶点索引的不同网格的物体，然后用 Shift 选择你要复制的顶点坐标的物体，点击重构外形。
- Apply Base 将当前细分的模型作为基本模型，修改原始的未细分网格，以匹配细分后的网格形态。



## 👉 Remesh Modifier
- https://docs.blender.org/manual/en/latest/modeling/modifiers/generate/remesh.html

Remesh 重构网格修改器，用于生成新网格拓扑。输出遵循输入的曲面曲率，但其拓扑仅包含四边形。

有四种模式：

- Blocks - There is no smoothing at all.
- Smooth - Output a smooth surface.
- Sharp - Similar to Smooth, but preserves sharp edges and corners.
- Voxel - Uses an OpenVDB to generate a new manifold mesh from the current 
  geometry while trying to preserve the mesh’s original volume.


## 👉 Skin 蒙皮修改器

Skin 蒙皮修改器，将顶点和边当作骨架来创建蒙皮面，用顶点的半径来更好地定义形状。是一种快速生成基本
网格的方法，用于雕刻和/或用任意的拓扑结构有机形状进行平滑。并在物体之上创建骨架，使每个边都成为骨骼。


## 👉 Screw 螺旋修改器

螺旋修改器类似于编辑工具栏中的螺旋工具 Edges - Screw，因为它使用一个物体轮廓、一个网格或一条曲线
来创建一个类似于螺旋的形状。

螺旋 工具是将重复的 旋绕 与移动结合，生成类似螺纹，或者螺旋形的物体。使用该工具制作螺纹、弹簧或者
壳形结构(海贝、木螺钉尖、特殊轮廓等)。

螺旋工具和螺旋修改器 的主要差异在于螺旋工具可以自动使用基础轮廓计算角度前进量。它无需其他修改器
(比如，将倒角修改器、曲线修改器与螺旋修改器一起使用)就可以调整轴向角度向量，实现更加干净的顶点分布和用法。

该工具可用于开放或者闭合的轮廓，也可以是带有闭合面的轮廓。用户可以使用整体的一条开放边线作为轮廓，
也可以是一个封闭的圆或者半球这样闭合的轮廓。

使用螺旋工具制作的木螺丝尖、弹簧，等等。


## 👉 Simple Deform 简易形变修改器

可以进行四种简单形变：

- Twitst 扭麻花 围绕指定对象的 轴 旋转网格。 
- Bend 弯曲 将网格沿特点 轴 弯曲。 
- Taper 锥化 沿着指定的 轴 线性缩放。
- Stretch 沿着指定的 轴 拉伸对象(负 系数 将导致挤压)，通过在另外两个轴上反向缩放来保持体积。

还可以添加一个 Simple Deform 修改器来弯曲网格为管状，弯曲时 它需要一个参考坐标，使用
Empty - Arrows。设置弯曲 360 度，再调整 Empty 对象的旋转属性控制对象的弯曲。

适当调整约束 Restrictions 可以使用图形接合更紧密。

- 在场景中添加一个 Empty 对象，类型随意选择，使用 Arrow 可以有三个轴的方向指示；
- 为了便于理解，保持空对象的 Z、X 轴与网格同平面，X 轴作为简易形变修改器的弯曲轴。
- 那么当 X、X 轴与网格的边一一平行时，对网格的弯曲就是对齐的弯曲成管状。
- 如果成 45°，那么网格就是对角卷起。
- 如果，以 Y 轴作为修改器的弯曲轴，那么结果就是网格扇形化。
- 当参考的空对象坐标角度的不是平行或垂直时，弯曲的效果就按空间的对成关系弯曲。


## 👉 Lattice 晶格

晶格 Lattice 通常被称为变形笼 Deformation Cage。晶格由三维不可渲染的网格顶点组成，它的主要
用途是使用晶格修改器对它控制的物体应用形变。如果物体的父级是晶格形变 ，则会自动应用晶格修改器 
Lattice Modifier。

在物体模式下晶格应被缩放和移动以适当围绕您的物体。 在编辑模式下应用于物体的任何缩放都将导致物体形变。 
这包括使用 Ctrl-A 应用其缩放，因为这将获得与在编辑模式下缩放晶格乃至物体相同的结果。


## 👉 Wave 波浪修改器
https://docs.blender.org/manual/en/latest/modeling/modifiers/deform/wave.html

## 👉 Twist 扭曲模型

打开 blender 创建一个球体。

创建一个晶格对象 Lattice 包裹准备扭曲的模型，给模型添加晶格修改器，在修改器的属性中指定晶格对象，
再编辑晶格对象，对晶格的一个面进行旋转，这个旋转就会影响模型的扭曲。

类似的方法是比例操作，打开编辑视图的 Proportional Editing 选项，衰减类型设置为 Linear，
直接对模型一部分进行旋转就可以获得一定的扭曲效果。

使用 SIMPLE DEFORM（BEND）和 Array 修改器，添加平面并按上述方式细分，转到对象模式并添加一个
Simple Deform Modifier，将变形角度增加到 360 度.然后添加一个 Array Modifier ，增加计数
编号，并设置 z 相对偏移为 1.000，可以添加另一个 Array 沿 X 轴复制段。

使用 Bezier 曲线对象和 Tilt 属性轻松实现此目的。只需添加两条新的贝塞尔曲线，一条用作斜面对象，
另一条用作扭曲的色带。

属性窗口 > 对象数据（曲线）> 几何 > 斜角对象

将斜角对象设置为功能区曲线，在曲线上输入编辑模式，并通过将所有句柄类型更改为自动（V）来扭转它，
然后仅选择一端 顶点并通过$360º$从空格键菜单或热键Ctrl+T倾斜.

如果您不需要变化，则可以使用数组修饰符重复该模式，或者手动添加一些随机性.如果几何图形不够平滑，
请根据需要调整曲线段。

建议实际倾斜曲线 360º 而不是 180º，因为 只旋转半圈会使法线在两端不一致，形成一个可见的接缝，
防止几何形状无缝焊接。



# 🚩 Sculpting & Painting 模型雕刻与绘制
1. [Blender 2.81 头发制作小教程](https://www.bilibili.com/read/cv4981401)
2. [Blender实用案例训练 ep.9 制作头发小技巧（非雕刻）](https://www.bilibili.com/read/cv5466422)
3. Blender 3.5 Vector Displacement Map https://www.bilibili.com/video/BV1wo4y1i7bZ/
4. Cycle Bake (Emit) VDM https://www.bilibili.com/video/BV1HL411Z7SF/
5. VDM for the sculpting draw brush https://projects.blender.org/blender/blender/pulls/104481
6. Blender VDM 矢量位移置换 https://www.bilibili.com/video/BV1ZD4y1w736/
6. http://docs.pixologic.com/user-guide/3d-modeling/exporting-your-model/vector-displacement-maps/
6. https://80.lv/articles/case-study-vector-displacement-mapping-in-real-time/
6. Shin Min Jeong 3D角色建模 https://www.bilibili.com/video/BV1tP4y1Y7SD/

Blender 3.5 支持 VDM 矢量位移置换，可以直接将模形在雕刻模式置换出来，创建和使用 VDM：

- 使用 Cycle 渲染引擎的 Bake (Emit) 将模块的发光图烘焙出来，并保存为 EXR/PNG 纹理贴图；
- 在雕刻模式下，将发光纹理贴图加载到雕刻工具的 Texture 属性，并设置：
	- Mapping = Area Plane
	- Vector Displacement 勾选状态
	- Stroke Method = Anchored 或者 Drag Dot

使用高动态的 EXR 图像文件时，分辨率在 512x512 水平就足够，大尺寸占用空间很大。

VDM 贴图中，越是亮色表示在锚定模式下雕刻时，就越先浮雕出来。


3D 视图的雕刻模式和绘制模式使用笔刷 Brush 直接在网格上绘制，这种新方法是一种艺术性的建模方式，
以下多种模式使用网格绘制功能:

- Sculpting 雕刻: 修改网格拓扑。
- Vertex Paint 顶点绘制: 修改活动色层的顶点颜色。
- Weight Paint 权重绘制: 修改活动顶点组的顶点权重。
- Texture Paint 纹理绘制: 修改活动图片纹理的像素。

雕刻模式 类似于 编辑模式，因为它们都是用于改变模型的形状，但雕刻模式使用的是一组非常不同的工作流程：
不是处理单个元素(顶点，边和面)，而是用笔刷改变模型的一块区域。

在绘制模式中，Vertex Groups 顶点组是一个常用工具，它管理顶点选择的方式，通过将选择中的顶点分配
到一个顶点组，下次可以通过顶点组的再次选中分组内包含的顶点。通过对象属性面板使用顶点组，
Properties - Object Properties - Vertex Groups。

建立分组：选中顶点，点击 Assign 分配给顶点组，这是增量添加顶点。要重新给顶点组分配顶点，先 Remove
清除旧的顶点。

顶点组结合权重，可以控制粒子的发射位置，可以控制骨架对相应顶点的控制量。



## 👉 Brush & Textrue 画笔与纹理

所谓画笔，可以理解为存储配置信息的对象，这些配置信息包括画笔的精细、颜色、纹理，以及压感方面的支持。

使用到的工具可以在侧栏面板中设置：

- Brush 设置笔刷基本参数

	- Radius 半径
	- Strength 强度/力度
	- Blend 笔刷混合模式 Blending Mode，两种颜色混合在一起的方法，是通用图像混合方法。
		[参考 GIMP 图像处理软件](https://docs.gimp.org/en/gimp-concepts-layer-modes.html)

		- Mix 混合色彩，画笔权重值定义了目标权重，即在同一位置上绘制足够长的时间时就会变成笔刷所用的颜色。
		- Darken 变暗，这种混合模式和变亮混合模式类似，只有权重高于目标权重的受影响。
		- Multiply 正片叠底(相乘)，将顶点权重与指定的权重值相乘，和相减类似，但移除的权重取决于权重值本身。
		- Blur 模糊，平滑相邻顶点的权重。在此模式下，忽略权重值。强度定义了应用平滑的程度。
		- Color Burn
		- Linear Burn
		- Lighten 变亮，指定的权重值为目标权重，与混合模式非常相似，但仅影响低于目标权重的权重。
		- Screen
		- Color Dodge
		- Add 指定的权重值将会被 添加 到顶点权重。
		- Overlay
		- Soft Light
		- Hard Light
		- Vivid Light
		- Linear Light
		- Pin Light
		- Difference
		- Exclusion
		- Subtract 指定的权重值将被从顶点权重中 减去。
		- Hue
		- Saturation
		- Color
		- Value
		- Erase Alpha 清空透明区
		- Add Alpha 增加透明区

- Texture 纹理，在绘制模式中作为颜色源，而在雕刻模式则是用来确定画笔的强度。

	- Mapping 映射 设置纹理应用于笔刷笔触的方式。

		- View Plane 视图面 如果启用，则使用当前视角来将笔刷纹理投射到模型上。即纹理跟随着鼠标，所以看起来纹理被拖过模型。在2D绘画中，纹理随着笔刷移动。
		- Area Plane 区域面 沿着局部曲面法线投射笔刷纹理，这样在与视点成极点角度的网格部分进行雕刻时，纹理不会拉伸。
		- Tiled 平铺 选项在整个屏幕上对纹理进行平铺，所以移动笔刷似乎是单独移动纹理。 平铺 选项比起程序纹理对于可缩放图像是非常有用。
		- 3D 允许笔刷充分利用程序纹理，此模式使用顶点坐标而不是笔刷位置来确定要使用的纹理区域。
		- Random 随机 从每一抹(dab)采样，选择一个随机纹理坐标。
		- Stencil 镂版

			镂版贴图通过从相机空间投射影绘画到网格或画布上来工作。绘画仅适用于镂版的边界内。镂版显示为视口上的屏幕空间的一个叠加层。要转换镂版纹理和镂版遮罩请按下 Alt ：

			- 移动 RMB
			- 缩放 Shift-RMB
			- 旋转 Ctrl-RMB
			
			当使用镂版缩放, X 和 Y 用于约束缩放那一个轴。按下其中一个按钮两次可以恢复到无约束缩放。

			- Image Aspect 图像纵横比 通过重置镂版(仅限图像纹理)恢复因缩放产生的拉伸图像的原始图像的宽高比。
			- Reset Transform 重置变换 恢复镂版的位置。

	- F 设置笔刷大小，可用快捷键 [ 和 ] 更改笔刷大小。
	- Shift-F 设置笔刷强度
	- Angle 角度 Ctrl-F 这是纹理笔刷的旋转角度，在交互式旋转中，你也可以输入数值更改旋转角度。
	- Rake 变向 R 角度随笔刷笔画的方向变化。不可用于 3D 纹理。(只用于雕刻)。
	- Random 随机 R 每一抹(dab)的角度是随机的，可以设置随机角度限制随机偏差范围。
	- Offset 偏移 纹理贴图在X，Y和Z轴上的位置偏移。
	- Size X/Y/Z 尺寸 设置每个轴的纹理的缩放。不可用于 拖动 雕刻纹理。
	- Sample Bias 采样偏移量 纹理采样增加的量(仅用于雕刻模式)。

- Stroke Method 描边方式 定义画笔描边应用于画布的方式。
	- Dots 点 在鼠标移动的每一小步上都绘制。
	- Drag Dot 拖动点 通过拖动鼠标留下一抹(dab)描边在画布上。
	- Space 间距 将画笔描边创建为一系列点，其距离(间距)由 间距 设置确定。
	- Airbrush 喷枪 只要鼠标单击并按住画笔的流动就继续(喷雾)，此选项不适用于 Grab 雕刻画笔。
	- Anchored 锚定 在画笔位置创建一抹(dab)描边。单击并拖动将调整 dab 直径的大小。
	- Line 线 单击并拖动可让您在屏幕空间中定义一条线。线上的每一抹(dabs)由 间距 分隔，类似于间隔描边。使用 Alt 时，线描边被约束为 45 度增量。
	- Curve 曲线 在屏幕空间中定义曲线。

		- Draw Curve 绘制曲线 描边曲线是可重用的，可以使用 数据块菜单 菜单进行存储和选择。
		- 添加点 Ctrl-RMB 来定义曲线控制点。
		- 变换点 控制点和控制杆可以使用 LMB 来拖动。
		- 选择 可以使用 RMB 单独选择控制柄，通过 Shift-RMB 扩展选择，并使用 A 取消选择/选择所有控制柄。
		- Alt 约束线描边 45 度增量。
		- Shift-LMB 拖动曲线变换电确保控制点的控制杆对称。
		- Shift-S 画笔滞后于鼠标，并遵循更平滑的路径。
		- X 删除一个曲线上的点。
		- Return 要确认和执行曲线描边，请按 Return 或使用绘制曲线按钮。

- 衰减 Falloff 控制笔刷衰减的强度，更改曲线的形状将使画笔更软或更硬。曲线左侧控制笔触中心的色彩浓度，右侧控制边缘浓度，曲线越陡边缘越清晰，反之模糊。
- 显示 允许自定义画笔的 曲线 和 纹理 的视窗中的显示。
- 动态拓扑 dyntopo 是一种动态细分雕刻方法，可以即时添加和删除细节，而常规雕刻仅影响网格的形状。
- 对称 Symmetry 配置笔刷对称作用于模型，比如，通过 X 对称只需要雕刻模型左眼就可以同时雕刻右眼。
- 选项 使用多 CPU 线程来提高雕刻性能、 重力悬垂效果等。


启用动态拓扑后，笔刷可以使用拓扑耙 Topology Rake 自动将网格边缘与笔刷方向对齐，以生成更清晰的拓扑并定义清晰的特征。 拓扑耙(Topology Rake) 会对性能产生严重影响，因此在低多边形网格上效果最佳。

为了在雕刻中得到准确和可预测的效果，Blender 需要几何图形来进行处理，实现这一点的一种方法是从经过高度细分的网格开始进行雕刻。另一种方法是使用两种自适应雕刻方式中的任意一种来动态地增加几何图形。

动态拓扑 dynotopo 是一种能够通过笔刷增添和减少细节的动态细分雕刻方式。这是通过首先对网格进行细分，然后在细分后的网格上应用雕刻笔触来实现的。这使得可以用简单的网格来雕刻复杂的形状，而不是仅仅将细节添加到建模的基本网格上。

多级精度修改器 Multi-Resolution Modifier 可用来动态地细分网格。细分地越多，需要的数据计算量也就越大。当您拥有干净拓扑的基础网格时，多级精度雕刻将有所帮助。

当使用多级精度修改器雕刻时，我们可以在不同的细分级别中进行雕刻，这意味着我们可以在细分级别 1 中雕刻一些细节，并在细分级别 2 中添加更多细节， 1 纠正一些错误。虽然此工作流程经常被使用，但多级精度修改器仍有一些局限。你可能会遇到一些网格失真问题。作为建议，在增加更多细分之前添加尽可能多的细节。在多级精度雕刻中进行二次雕刻，Clay 笔刷是更合适的选择。

- 增加一个细分级别 PageUp
- 降低一个细分级别 PageDown
- 设置细分级别 Ctrl-0 至 Ctrl-5

在雕刻的过程中，模型的部分区域可能隐藏在了一些网格的后面或者太靠近其他部分。要在该种情况继续工作，隔离部分网格以进行雕刻是非常有用的。这可以通过隐藏部分网格或者对不需要进行雕刻的区域进行遮罩来实现。


## 👉 Texture Type
- https://docs.blender.org/manual/en/latest/editors/texture_node/index.html
- https://docs.blender.org/manual/en/latest/render/materials/legacy_textures/index.html

注意，Blender 中的图像文件与纹理两个概念的区别，一个称为 Image，另一个称为 Texture。图像是像素
数据对象，纹理可以使用图像数据也可以使用程序化纹理，用于材质中做贴图，或其用作笔刷纹理等等。

材质预览节点和渲染都会产生相应的图像文件，图像编辑器显示为 Render Result 和 Viewer Node。材质
编辑器，它们对应 Image、Texture 节点。Blender 有一个 Texture Nodes 编辑器，它就像材质节点一样
使用节点的形式编辑纹理。每个纹理可以设置多个输出节点，作为不同用途，如 Diffuse 或 Normal。

但是，这是一个过去的编辑方式，官方手册内容都不更新了，不建议使用。同时，可能有 Bug，节点内容不能
正常输出，图像预览图也不能正常显示。

属性编辑器中还有一个 Texture Properties 面板，也称为传统纹理面板 Legacy Textures，列表中
可以选择所有用到纹理的对象。选择列表中对象及其使用的纹理，然后就可以对其所使用的纹理进行修改，或变
更使用其它纹理。

除了 Image or Movie 纹理类型之外，还有常用的程序化噪声纹理，如 Voronoi。

面板中可以设置纹理的图像来源和颜色，Color Clamp 限幅和 Color Ramp 影射。但是对图像、视频文件做
Color Ramp 映射时，似乎有 Bug，不能正常映射。

Textures Nodes 启用节点编辑后，图像就需要在节点编辑器中设置。


纹理节点编辑器通过将颜色、图案和其他纹理组合在一起来实现纹理创建，同样使用节点编辑界面，类似材质节点。
生成的纹理可用于画笔、合成和粒子系统内部。

- Color Nodes			颜色节点
	- Invert Node		反转节点 反转输入图像中的颜色，生成一个负片。
	- Mix Node			混合节点 通过处理两个输入图像的单个、相应像素来混合图像，在着色器和纹理中称为 MixRGB。
	- RGB Curves Node	RGB 曲线着色器节点 允许每个颜色通道的颜色进行单独校正，从而调节合成图效果。
	- Hue Saturation Value Node		色相/饱和度/明度 着色器节点 允许对颜色通道进行单独校正，从而调节合成图效果。
	- Separate Node		分离着色器节点从复合颜色通道将图像拆分出来。
	- Combine Node		合并着色器节点将复合颜色通道的图像重新组合。
- Converter Nodes		转换器节点
	- Color Ramp Node	颜色渐变着色器节点 用于将值映射到渐变颜色。
	- Distance Node		距离节点 计算两个 3D 坐标之间的距离。
	- Math Node			运算节点 执行数学运算。
	- RGB to BW Nodes	灰度化着色器节点 通过亮度将 RGB 彩色图像映射成灰度图像。
	- Value to Normal Node	数值转法线节点 计算法线贴图。
- Distort Nodes			畸变类节点
	- At Node			At节点 返回纹理特地坐标的颜色信息。
	- Rotate Node		旋转节点 旋转图像或纹理的坐标。
	- Scale Node		缩放节点 缩放图像或纹理坐标。
	- Translate Node	移动节点 移动图像或纹理的坐标。
- Input Nodes			输入节点
	- Coordinates Node	坐标节点 输出自身坐标几何信息，RGB颜色分量对应表示坐标与包围盒的相对 XYZ 位置
	- Image Node		图像节点 图像节点可用于加载外部图像。
	- Texture Node		纹理节点 用于加载基于节点或非基于节点的纹理。
	- Time Node			时间节点 生成一个随时间线变化，且同时受曲线影响的因数，从 0.0 到 1.00。
- Output Nodes			输出节点
	- Output Node		输出节点 此节点包含节点纹理的结果。可存在多个输出节点，但是，只能激活一个。
	- Viewer Node		预览器节点 预览节点效果。
- Pattern Nodes			图案节点
	- Checker Node		棋盘格节点 创建一个棋盘格图案。
	- Bricks Node		砖墙节点 创造一个砖墙类的图案。
- Texture Nodes			纹理节点
	- Blend Node		混合节点 生成一个平滑的插值渐变，可以与其它纹理混合生成漂亮的效果，特别是与贴图的法线技巧。
	- Clouds Node 		云絮节点 柏林噪点 Perlin Noise 算法生成，模拟云絮，火焰，烟雾。配合凹凸贴图使用，将给材质带来整体的不规整效果。
	- Distorted Noise Node 	畸变噪波节点 接受从噪波偏移中选择的选项，过滤后生成混合模板，常用于做旧效果。
	- Magic Node 		幻彩节点 可以用于薄膜干涉效果，用得不多，如果你设置映射为反射，并使用相关的高数值紊流，RGB 组件将以正弦公式形式独立生成。
	- Marble Node 		大理石纹节点 生成大理石纹理，火焰或有噪波的结构。条带状的生成基于正弦波，锯齿波，或三角波以及噪波紊流。
	- Musgrave Node 	马氏分形节点 生成有机色生物材质，但它比较灵活多变，你可以做很多其它类似的效果。
	- Noise Node 		噪波节点 它是真的随机生成的噪点，通常用法动画中的白噪点。
	- Stucci Node 		斯氏分形 纹理基于噪波功能，通常用于石头，沥青，或橙子，一般用于创建粗糙颗粒状表面的凹凸贴图。
	- Voronoi Node 		沃罗诺伊节点 生成真实质感的金属，尤其是捶打的效果。生物体着色器，如皮肤的纹理张弛。
	- Wood Node 		木纹节点 生成木头和环状花纹。


## 👉 Sculpting 雕刻工具
- https://docs.blender.org/manual/zh-hans/3.0/sculpt_paint/sculpting/index.html

雕刻模式 类似于 编辑模式，因为它们都是用于改变模型的形状，但雕刻模式使用的是一组非常不同的工作流程：
不是处理单个元素(顶点，边和面)，而是用笔刷改变模型的一块区域。换句话说，雕刻模式不是选择一组顶点，
而是会根据笔刷的位置自动选择顶点，像捏泥人一样建模。

搭配多级精度修改器 Multi-Resolution Modifier 可以让你像表面细分修改器那样细分网格，同时又可以
实现多级精度的模型雕刻。多级精度修改器可用来动态地细分网格。细分的越多，需要的计算量也就越大。当拥有
干净拓扑的基础网格时，多级精度雕刻将有所帮助。

当使用多级精度修改器雕刻时，我们可以在不同的细分级别中进行雕刻，这意味着我们可以在低级别细分
雕刻一些粗糙的轮廓，然后在更高的细分级别下雕刻出更多细节。同时，又会保留低级别的顶点信息，当返回
到细分低级别时又可以纠正一些错误，使用其影响高级别细分中效果。

虽然，多级细分的工作流程经常被使用，但仍有一些局限。你可能会遇到一些网格失真问题。作为建议，
在增加更多细分之前添加尽可能多的细节。在多级精度雕刻中进行二次雕刻，Clay 笔刷是更合适的选择。


使用 Mask 遮罩避免不需需改的位置有改动，也就是说，遮罩区域越黑，雕刻对该部分产生的效果就越小。
遮罩笔刷绘制遮罩过程种可以使用 Ctrl 临时激活擦除模式，按下 Shift 将会激活遮罩光滑模式。

记住，Ctrl 通常是用来反转一个工具的作用，比如，*Draw* 工具会向法线方法扩张曲面，按下 Ctrl
再雕刻时，就会逆着法向收缩曲面。进入雕刻时，可以将对象着色方式改为 Flat，这是默认的几何体着色
方式，相比 Smooth 方法，平坦着色更能看到曲面的朝向，而平滑着色方式通常用于完成后的模形。

雕刻工具的笔刷大小，即蓝色圆圈的大小以及力度决定了每次下笔时的效果，施力方向通常以法线为准，
并且与笔刷蓝色圆圈所表示的平面正交。

除了遮罩，还可以使用 H 定义隐藏区，完全避免指定区域的改动，Shift-H 框选不不需要隐藏的部分，
Alt-H 取消隐藏。

- M 绘图遮罩区；
- B 盒式遮罩；
- Shift-Ctrl-LMB 套索遮罩；
- Ctrl-I 反转现有的遮罩；
- Alt-M 清除遮罩；

清除遮罩 Alt-M 是使用 0 值填充来使遮罩无效，要完全删除遮罩数据需要在属性面板清除，
Object Data - Geometry Data - Clear Sculpt-Mask Data。完全清除网格的遮罩数据可以提高雕刻性能。

雕刻模式下也像是在绘图，画笔纹理及笔触的设置会影响雕刻工具的效果，雕刻工具需要选择正确的笔触方式，
快捷键 E 可以设定笔触方式 Stroke Method：

- Dot 点
- Drag Dot 拖动点
- Space 空间
- Airbrush 喷涂
- Anchored 锚点
- Line 直线
- Curve 曲线

使用曲线方式时，需要先创建曲线并绘制曲线 Draw Curve，添加点 Ctrl-RMB 来定义曲线控制点。

画笔纹理可以选取任意图片，图片中的像素越亮表示受到笔触的影响越强，黑色相当于遮罩作用，画笔纹理是
制作高逼真模型的一大法器。纹理的可以通过不同的映射模式绘制到模型上，其中镂版 Stencil 比较有趣，
贴图将会通过从相机空间投射影绘画到网格或画布上来工作。此时可以使用以下操作转换镂版纹理：

- 移动镂版纹理 RMB
- 缩放镂版纹理 Shift-RMB
- 旋转镂版纹理 Ctrl-RMB

以下是画笔设置的通用快捷键：

- F 设置笔刷大小，可用快捷键 [ 和 ] 更改笔刷大小。
- Shift-F 设置笔刷强度
- Ctrl-F 旋转笔刷纹理
- S 或 Ctrl 分别用于当前光标位置色值获取，和临时使用候选色 Secondary Color。

快捷键 N 打开侧栏的 Tools 面板，选中任一工具后会显示工具的效果示意缩略图。


Sculpting 雕刻模式快捷键:

	- Shift 平滑笔划。
	- Ctrl 反转笔划，注意，配合不同在工具使用可以得到相反的效果，和膨胀工具 Inflate 使用就是凹陷效果。
	- Esc 取消正在进行的笔触。

	- Ctrl-D 切换动态拓扑支持，在动态拓扑处于活动状态时，大多数画笔将在笔划范围内细分网格。
	- Shift-D 设置细节尺寸/百分比，分辨率。

支持以下标准选择操作：

	- RMB -- 单面。
	- Shift-RMB -- 选择多个。
	- A -- 所有面，同时也用于取消选择。
	- B -- 方形选框。
	- C -- 使用笔刷的圆形选框。
	- L -- 选择链接项(在鼠标光标下)。
	- Ctrl-L -- 选择链接项
	- Ctrl-I -- 反向选择 反选。

	- Shift-K 设置顶点色



- 绘制笔刷 *Draw* X

	根据绘制的画笔描边中包含的顶点的平均法线向内或向外移动顶点，产生隆起的效果。

- 粘土笔刷 *Clay* C

	它的作用类似于 压平笔刷 和 绘制笔刷 的组合，包括了用于调整画笔作用的平面的设置。

- 粘土带笔刷 *Clay Strips*

	类似于 粘土 笔刷，但是它使用立方体而不是球体来定义笔刷的影响范围。

- 层笔刷 *Layer* L

	除了置换层的高度有上限外，此笔刷与 绘制笔刷 类似。该笔刷可以绘制出层状表现的实体。
	该笔刷不会在它自身上面绘制;笔刷笔划与自身相交。释放鼠标按钮并开始新笔划将重置深度
	并在上一笔划的基础之上绘制。

- 膨胀/萎缩笔刷 *Inflate/Deflate* I

	想象模型就是一个气球，这个工具就是给它充气，配合按住 Shift 放气，顶点按法线方向位移。

- 球形笔刷 *Blob*

	将网格向外和向内挤压成球形，并设置球体边缘的揉捏形变量。

- 折痕笔刷 *Crease* Shift-C 

	通过推动或拉动网格创建尖锐的凹痕或脊线，同时将顶点夹在一起，雕刻出沟槽的效果。

- 平滑笔刷 *Smooth* S

	顾名思义，通过平滑顶点的位置，消除画笔影响范围内网格区域的不规则性。

- 压平/对比笔刷 *Flatten/Contrast* Shift-T

	压平笔刷 默认位于画笔区域内顶点上方/下方平均高度的“区域平面”。然后将顶点拉向该平面。
	压平笔刷 反转是 对比笔刷，它将顶点向上或向下推离画笔平面。

- 填充/加深笔刷 *Fill/Deepen*

	像压平笔刷一样工作，但只将在笔划平面下的顶点往上带。 填充 的反转是通过向下推动平面下方的顶点来深化。

	在雕刻时按住 Ctrl 会将笔刷行为更改为刮削笔刷。禁用时，在雕刻时按住 Ctrl 将向下推光标下方的顶点。


- 刮削/尖峰笔刷 *Scrape/Peaks*

	刮削笔刷 的工作方式类似于 压平笔刷 ，但仅将高于笔划平面的顶点往下压。刮削笔刷 的反转为 尖峰笔刷 ，通过将笔划平面上方的顶点向上推离平面。

	在雕刻时按住 Ctrl 会将笔刷行为临时转变为填充笔刷。禁用时，在雕刻时按住 Ctrl 将光标上方的顶点向上推离光标。


- 夹捏/放大笔刷 *Pinch/Magnify* P

	将顶点拉向画笔的中心。反向设置为 放大笔刷 ，其中顶点被推离画笔的中心。

- 抓变笔刷 *Grab* G

	用于拖动一组点。与其他画笔不同，抓变笔刷 在画笔拖过模型时不会修改不同的点。相反，抓变笔刷 在鼠标按下时选择一组顶点，并拉动它们以跟随鼠标。效果类似于在编辑模式下使用衰减编辑移动一组顶点，但 抓变笔刷 可以使用其他雕刻模式选项，如纹理和对称。

- 蛇形笔刷 *Snake Hook* K

	拉动顶点以及跟随笔刷的运动，形成长而呈蛇形的形状。

- 夹捏笔刷 *Pinch*

	蛇形笔刷 倾向于沿着笔划减少体积，一旦把夹捏值设置至 >0.5 就可能在不损失体积的情况下进行形状雕刻了。

- 耙状工具 *Rake*

	支持跟随光标旋转移动网格的因数。

- 指推笔刷 *Thumb*

	和 轻推笔刷 相似，此笔刷在沿画笔笔划方向移动网格的同时，使网格在画笔区域中变平。

- 轻推笔刷 *Nudge*

	往笔划方向移动顶点。

- 旋转笔刷 *Rotate*

	沿光标移动的方向旋转画笔内的顶点。初始的拖拽方向是零度角，随着笔划围绕其初始位置旋转，你可以创造出漩涡的效果。

- 简化笔刷 *Simplify*

	无论 塌陷短边线 选项是否启用，这个笔刷都会塌陷边线，由细节大小定义。如果动态拓扑没有启用，这个笔刷不会有任何效果。

- `Pose` 让顶点根据笔刷半径进行计算旋转（Ctrl键可实现扭曲效果）



## 👉 Vertex Paint 顶点绘制
[如何使用顶点绘制功能](https://www.bilibili.com/video/BV1q7411G7jR?p=2)
[Blender 顶点绘制技巧](https://www.bilibili.com/video/av74467119/)
[Blender实用案例训练 ep.3 Vertex Paint 工作流](https://www.bilibili.com/read/cv4094940/)

顶点绘制是一种通过直接操作顶点颜色的方法, 而不是使用纹理来将颜色绘制到物体上, 并且顶点绘制相当直观。

绘制顶点时，顶点的颜色将根据画笔的设置进行改变。附着到顶点的所有可见平面和边的颜色会渐变为其他连接
顶点的颜色。请注意，被遮挡面的颜色不会改变。

也可以通过材料节点树属性节点 Input - Attribute 来访问顶点颜色信息，填入属性与属性面板中
Vertex Colors 列表一致的顶点色数据集名称。可以使用 Input - Vertex Color 来获取顶点色数据。
直接将获取到的顶点色输出到 Principal BSDF 材质的 Base Color 端口，这样就可以直接把顶点色
当做模型的纹理使用。对于高密模型，这种方法可以得到不错的效果，还省去重新拓扑和 UV 展开。

材质编辑器的顶点颜色节点从对象的属性获取顶点色，并提供顶点颜色及其 alpha 值给其它节点使用。根据
顶点色的数据流向不同，顶点绘制可以有不同的用途，比如作为纹理遮罩，用来混合多贴图。

顶点绘制工具

- Draw 绘制 在目标物体上绘制指定颜色。
- Blur 模糊 平滑相邻顶点的颜色。此模式忽略颜色值。强度/力度定义了颜色模糊的影响力度。
- Average 平均 以绘制笔刷下所有颜色的平均值来平滑颜色。
- Smear 涂抹 通过抓取笔刷下的颜色并 “拖动” 它们来涂抹颜色。这可以想象成一个手指绘画工具。

在图像的任何部分按 S 对该颜色进行采样并将其设置为画笔颜色。
绘制时按住 Ctrl 使用辅助颜色临时绘制。
翻转(循环图标) X 交换首选色和辅助色。
设置顶点色 Shift-K 使用当前绘制颜色填充活动顶点色层。



## 👉 Weight Paint 权重绘制
- Hiding & Masking https://docs.blender.org/manual/en/2.79/sculpt_paint/painting/weight_paint/hide_mask.html
- Blender 教程 右键选择模式 https://www.bilibili.com/video/BV1QZ4y1W7U3?p=43
- https://docs.blender.org/manual/en/3.4/sculpt_paint/weight_paint/index.html

Blender 提供了一个可视化的权重设置模式即权重绘制模式，权重绘制是一种以非常直观的方式保持大量权重
信息的方法，可以用 Ctrl + Tab 切换。

给顶点绘制权重信息会绑定到网格，而其相关的顶点组 Vertex Group 可用于定义骨骼在网格上的影响区域，
也使用它来控制粒子的发射，头发密度，许多修改器，形状关键帧等等。

骨骼绑定可能是顶点组和权重这两个概念出现最频繁的场景，实际上这两个概念并不专属于骨骼绑定，而仅仅是
被借用了一下，了解这一点可能有助于更好地理解 Blender 的工作原理。

在权重绘制模式下，鼠标光标会变成笔刷，右键可以调出笔刷菜单，权重绘制时蓝色表示最小权重 0，红色权重
最大为 1。

顶点组 Vertex Group 实际上就是一个容器，一个模型可以有若干个顶点组，顶点可以被任意顶点组引用。

顶点组可以被灵活地应用于骨骼绑定，材质指派等多种场景。在有些场景中，要对隶属于多个顶点组的顶点的
控制力加以比较，因此有了权重 Weight 的概念。权重体现顶点组对顶点的控制力，用 [0,1] 的数值表示。
每个顶点组的权重都是独立设定的，所以允许出现例如两个顶点组对某顶点的权重都是 1 的情况。最终某个
顶点组对某顶点的控制力，由该组的权重除以该顶点隶属的所有顶点组的权重之和的值决定。

对于复杂的模型，可以使用 Masking 来遮罩不需要被改动的部分。在权重绘制视图的顶部工具条左侧，提供了
Paint Mask 和 Vertex Selection 两个遮罩工具。点击后，在工具栏会多显示一个选择工具，按 T 显示
工具栏，然后使用选择工具选择要绘制权重的顶点，选择完成后，再使用画笔刷权重。

选择工具快捷操作：

- RMB – Single faces. Use Shift-RMB to select multiple.
- A – All faces, also to de-select.
- B – Border selection.
- C – Circle select with brush.
- L – Pick linked (under the mouse cursor).
- Ctrl-L – Select linked.
- Ctrl-I – Invert selection Inverse.

Blender 右键选择模式可以提高绘画模式的工作效率，设置用户喜好：

	Keymap -> Preferences -> Select with Mouse Button -> Right。

通常，左键选择模式，在绘制时点击左键用来绘画，也用来选择对象，这经常引起问题。软件不能很好地处理用户
意图，不能确定用户是在绘画还是在做选择。而使用右键选择模式，左键用来绘画，右键专门用来在 3D View 
中做选择，这样软件就很明确用户的意图。

右键选择模式下，原本的右键菜单通过 W 键触发，许多操作以及工具选择还是左键点击，但右键部分做选择操作，
在 3D 视图下点击左键会自动设置 3D Cursor 位置。

使用右键选择模式更适合绘图的例子：在选择好骨架后，再按 Shift 加选网格体，然后进入权重绘制模式。
这种情况下，如果是左击选择模式，那么选择骨骼的操作和绘制权重的操作都使用左击。但是用户需要切换另
一根骨骼再刷权重就不是很方便了，用户需要按住 Ctrl 点击来选择骨骼以实现顶点级的切换。

而右键选择模式，根本没有这样的困惑，用户直接使用右键选择，左键绘制权重。绘制过程不需要使用键盘，
即使骨骼被模式覆盖看不见，也不影响右键选择操作。

右键选择模式操作提示：

- 右键总是做对象选择，并且可以用来移动对象；
- 点击左键会自动设置 3D Cursor 位置。



## 👉 Texture Paint 纹理绘制
[Blender 实用案例训练 ep.4 绘制PBR贴图技巧冰效果](https://www.bilibili.com/read/cv4475939)
- https://docs.blender.org/manual/en/3.4/sculpt_paint/brush/index.html
- https://docs.blender.org/manual/en/3.4/sculpt_paint/texture_paint/index.html

纹理绘制是一种很好模型纹理贴图的创建方法，这种方法的使用让平面绘画很好地应用到了 3D 场景中。

UV 纹理是一张用于模型表面着色的图像(图片、图像序列或者影片)，它将一张或者多张纹理贴图，通过
UV 坐标映射到模型上的。有三种方法来建立 UV 贴图：

- 在 UV 或图像编辑器当前选中的 UV 纹理上绘制平面图像，然后将图像中的颜色映射到模型网格表面。
- 在 3D 视图中直接在网格模型上绘制，会按当前选中的 UV 贴图更新 UV 纹理。
- 使用任意图像编辑软件来创建图像。

Blender 内置了纹理绘制模式，它是特别为了在 UV 及图像编辑器窗口或 3D 视图窗口简单快速绘制
UV 纹理和图像而设计的。由于 UV 纹理仅是一张特殊用途的图像，可以用任何外部程序来创建，如 GIMP
或 Krita。

Blender 纹理绘制模式本身就和这些图像处理工具类似，只是笔刷配置相对简化了，配置相对复杂。
另外，由于笔刷逻辑上也不同，比如 Mix 混合模式下，按下笔刷不停来回刷，画面并不会趋向指定的颜色。
而是一个中间值，并且是一个计算好的中间值，要得到笔刷指定的色彩就要多次着笔，不能来回地刷。

如果不适应这种绘画算法，可以勾选 Brush Settings - Advanced - Accumulate，启用积累
方式后，笔刷的表现更像自然的绘画过程。

纹理绘画的配置复杂，也就是说它的功能与一般图像处理工具不同，毕竟 Blender 需要将这处绘图工具
与三维建模融合。比如，可以使用对称绘画：Brush Settings - Symmetry。

进入纹理绘制模式之前，需要设置材质，并给几何体设置好纹理，以及 UV 映射关系。
然后可以通过各种画笔的设置，比如画笔的纹理及画笔纹理遮罩等等可以绘制真实漂亮的模型纹理。

绘画工具或者填充工具有两个色彩，默认使用主色绘画，按下 Ctrl 时使用次色绘画，或者按 X 交换。
再配合快捷键 S 可以获取光标位置的色值。

另外，笔刷可以设置两个不同功能的纹理贴图：

01. Texture 笔刷纹理，绘画到图像上的纹理。
02. Texture Mask 遮罩纹理，

Blender 的纹理绘图中的笔刷纹理的默认映射方式就像复写纸，Stencil 方式需要在纹理所在位置上绘画。
需要不断调整纹理位置、缩放、旋转等，好处是纹理可以放置在任意位置上。可以使用 View Plane 这种更
贴合自然绘画的映射方式，根据视角与绘画平面的角度差，纹理绘画出来可能会变形，视角垂直绘画平面时
就不会导致纹理变形。

配合 Stroke Method 可以实现多种纹理绘画体验，一个复杂的笔触是曲线笔触，设置笔触为 Curve 方式 就要创建或关联一条曲线。按下 Ctrl-LMB 可以在绘图区设置曲线控制点，
定义好曲线后再绘画，笔迹就会按曲线运动。

笔触曲线编辑状态中，可以使用快捷键操作，尽管没有相应的菜单：

- A 全选控制点，或取消选择；
- S 绽放曲线；
- G 移动曲线；
- X 删除选中控制点；
- Shift-RMB 扩展选择控制点；
- Shift-LMB 拖动曲线变换电确保控制点的控制杆对称。
- Return 确认和执行曲线描边，或使用绘制曲线按钮。
- Shift-S 激活平滑特性，Stabilized Stoke，画笔滞后于鼠标，并遵循更平滑的路径。


笔刷控制快捷键：

- 设置笔刷大小 F
- 设置笔刷强度 Shift-F
- 旋转笔刷纹理 Ctrl-F
- E Stroke Method 描边方式/笔触选择。
- S 临时激活取色工具，获取当前光标位置色值。
- Ctrl 临时使用候选色 Secondary Color。
- 旋转笔刷纹理 Ctrl-F，交互式旋转，你也可以输入数值更改旋转角度。
- 旋转笔刷纹理 Ctrl-RMB
- 缩放笔刷纹理 Shift-RMB
- 移动笔刷纹理 RMB


纹理图像还可以使用图片编辑器进行绘画修改，Image Editor 绘画模式提供的工具不多：

- Draw 画笔

	在图像上绘画，注意画笔的设置，如果给画笔设置一个完全透明的纹理画不出来。还有画笔的混合模式，
	默认是 Mix。在透明的纹理上使用 Overlay 混合画不效果，同理，在黑色纹理上使用 Darken 模式，
	或在白色纹理上使用 Lighten 混合都是没有变化的，因为运算结果都是原图。

- Soften 柔化，使用模糊效果来柔化或锐化图像。
- Smear 涂抹，点击鼠标时将光标下面的颜色与你移动鼠标方向的颜色相混合。
- Clone 克隆，指定的图像(或同一图像的区域)复制色彩到活动图像。

	在三维投射绘制中，可使用 Ctrl-LMB 定位克隆游标。在二维绘制中，可以 RMB 拖动来移动克隆。

- Fill 用于使用笔刷颜色填充图像的大片区域。
- Mask 遮罩工具，绘制灰度值图像，像素值表示权重，0 表示没有遮蔽可以修改，1 表示完全遮蔽避免修改。


纹理绘制之前的准备工作，需要 Unwrap UV 映射，需要给物体材质设置 Color 属性对就的 Image Texture，
纹理图片通过 UV 关联到曲面上，这样才可以使用纹理绘制功能。纹理绘制模式下，侧栏面板 Texture Slots
中显示了当前正在对什么图像进行绘制操作，可以是单独的图像文件，或者是材质关联的纹理图像。材质方式下
可以关联多个图像，此时可以选择要绘制哪个图像。材质中并不需要将这些图像连接到输出端，只在供绘制使用。
使用 Z 呼出渲染模式菜单，选择材质观览模式或 Solid，查看材质中已经联接到输出端，或没有连接的图像。

如果没有关联图像，根据使用到的不同功能，会提示相应：

- Missing Textures, detected! 纹理贴图没有设置。
- Missing Stencil, detected! 遮罩纹理图像设有设置。

遮罩工具需要在 mask texture 上绘制出权重灰度图，通过侧栏 Masking 面板中设置：

01. Stencil Mask 镂空方式，使用 Mask 工具定义镂空的表面，以避免受到绘画工具作用。
02. Cavity Mask 洞孔遮罩方式，是可选项，算法基于顶点实现，网格表面的洞孔就是遮罩区。

Stencil Mask 定义的遮罩区默认显示为黑色，即不能绘画的区域。使用 Mask 工具可以绘制遮罩区，
按住 Ctrl 绘制则清除遮罩区。3D 视图中显示为黑色，在其纹理图像中是白色，即数值 1 代表的遮罩区域。
可以随时在 Masking 面板中反转遮罩区，或者改变遮罩显示的颜色。

另一个遮罩工具是基于网格面片的 Paint Mask，此遮罩工具激活时，工具栏会出现 Select Box，用来
选择哪些面片是可以绘画的，不能绘画的面片就会以模糊状态显示。


纹理绘制的一个方便的功能是，可以将 Texture 图案绘制到模型上。在纹理绘制工作空间，为 Texture 属性
设置一个纹理，将下载好的部图像关联到纹理对象上，如树皮图像素材，然后设置纹理的映射模式为镂空 stencil。
然后使用 RMB 鼠标右键拖动纹理图案到可以覆盖模型的位置，再使用画笔涂抹就可以将纹理图转印到模型上。
可以使用 Shift-RMB 缩放纹理，Ctrl-RMB 旋转纹理图片。

注意，Blender 中的图像文件与纹理两个概念的区别，一个称为 Image，另一个称为 Texture。图像是像素
数据对象，纹理可以使用图像数据也可以使用程序化纹理，用于材质中做贴图，或其用作笔刷纹理等等。

Blender 中各种编辑器使用的是同一套画笔设置，即在图像编辑器中使用的画笔与纹理绘制中使用的是相同的
画笔，任何一方对画笔的配置修改，另一编辑器中都是使用修改后的画笔。


置换修改器 Displace Modifier 可以通过纹理来改变曲面结构，就像材质输出节点中的 displacement。
通过直接修改几何体的顶点坐标，可以实现地形制作。注意，置换修改器设置中的顶点组，它指定那些顶点是需要
置换坐标的，留空表示几何体所有顶点都会进行置换。对于新手来说，这些关键设置没搞定清楚，可能导致有工具
却用不起来的尴尬。另外，Midlevel 表示中间值，这个值对应的灰度值不会有转换，高于此值坐标值增加，
反之减小。控制置换的纹理通常是灰度图案，用 [0.0, 1.0] 表示亮度，注意不是 (0 to 255)。

置换前，细分曲线，使用其有足够的顶点被转换出效果，如果顶点不足，可能完全没有效果。

着色器中有两个置换节点，Vector Displacement 可以做任意方向的置换，而 Displacement 只有法向。
使用 Cycles 渲染引擎，材质着色器的属性面板 Settings -> surface -> displacement 可以指定
置换方式：

- bump only 表面凹凸细节方式
- displacement only 顶点坐标转换方式
- displacement and bump 两者合用

材质着色器中，将一个 Image Texture 或者程序化纹理的颜色输出到转换节点的 Height 输入端，再将
转换节点输出到 Ouput 节点的 Displacement 端口。

高精度的转换贴图使用 16 bit 格式，TIF or EXR，而使用 JPEG or PNG 只有 8 bit 会导致像素化，
结果看看起来会有许多等高线。

- https://artisticrender.com/how-to-use-displacement-in-blender/
- https://docs.blender.org/manual/en/3.4/render/shader_nodes/vector/vector_displacement.html
- https://docs.blender.org/manual/en/3.4/modeling/modifiers/deform/displace.html
- https://docs.blender.org/manual/en/latest/editors/3dview/display/overlays.html
- [Displace modifier](https://www.bilibili.com/video/BV1aS4y1P7fx)
- [Blender Displacement Modifier Tutorial](https://www.creativeshrimp.com/blender-quick-tip-9-displacement.html)
- [Blender Procedural Displacement Tutorial](https://renderguide.com/blender-procedural-displacement/)

Texture Paint 结合 Displace Modifier，可以实现绘画即雕刻的功能，只需要将同一张图像关联到材质
与 Displace Modifier 中，设置修改器 Coordinate = UV 映射方式，Direction = Normal，法线
方向默认为曲面垂直向外，绘画时，图像内容被修改，就通过修改器反映为几何体的顶点转换效果。

还可以使用两张图像，材质基本色纹理不用于绘制，而是在转换修改器关联的图像上绘制，单独保存转换贴图。
掌握了这种技术后，就可以结合材质节点编辑器，对其它贴图照此处理，比如可以用来混合多种纹理到模型上，
地形编辑中经常会有草地、土地、岩石等等混合材质。

注意：保存 Blnder 项目时，出于保护资源文件目的，在外部图像文件的内容不会自动保存，需要手动保存。
在关闭项目会提示外部文件修改要不要保存，也可以将文件 pack 到项目文件内部，这样会自动保存。

模型法线检查，打开 3D 视图 Viewport Overlays，对象模式下，找到 Face Orientation 显示片面
的朝向，正面蓝色向外，背面红色向内。在编辑模式下找到 Normals 设置：

- Display vertex normals 显示顶点法线；
- Display face normals at vertices (split normals) 显示拆分法线；
- Display face normals 显示片面法线。

检查状态显示的颜色可以修改，Themes - 3D Viewport - Face Orientaion Back/Front。


# 🚩 Motion Tracking 摄像机跟踪
VFX Basics Camera Tracking and Matchmoving in Blender https://cloud.blender.org/p/track-match-2/5604153b044a2a00cd8ed380

运动跟踪用于跟踪对象和/或照相机的运动，并通过约束将此跟踪数据应用于在 Blender 中创建或导入应用程序的三维对象(或一维对象，Blender 可以只跟踪一个点进行特效制作)。Blender 的运动跟踪器有两个非常强大的功能：二维跟踪和三维运动重建工具，可以进行包括相机跟踪和对象跟踪，以及一些特殊功能，如用于合成的平面跟踪反求。

剪辑视图是电影剪辑编辑器的主要部分。几乎所有的运动跟踪工具都集中在电影剪辑编辑器中。

应该提到的是，相机解算器由三个完全独立的步骤组成：

- 镜头的平面追踪.
- 相机内部函数(焦距，失真系数)规格/评估/校准。
- 解算相机，场景定位和场景重建。


整个标记可以使用 RMB 移动或者通过 LMB 拖动锚点(黑点)。按 G 也可以平移整个标记。当按下 G 两次时，标记将被平移，同时保持锚点到位。请注意，图案区域外的锚点以虚线显示为与标记位置交叉连接。

S 缩放整个标记。整个图案区域按 S 两次来缩放; 图案(模式)也可以使用 R 按钮来旋转，这取决于所使用的轴心点，将围绕它们自己的中心旋转图案或者围绕中间点旋转整个标记。

要匹配平面上标记的透视变换，必须手动编辑单个角点。每个标记角点可以单独变形以定义形状。角点位置可以通过用鼠标拖动来编辑。拖拽 LMB 将改变单个角点的位置。

Track 追踪面板

- Prefetch 预读取 P

	用帧缓存来读取序列。从驱动器加载装入高速缓存的帧。这允许在您确实需要跟踪某个镜头时尽可能快地缓存序列，但如果您打开了剪辑编辑器，但实际上没有与之交互，这会使CPU和驱动器带宽保持空闲。

- Reload 重载

	强制重新加载当前加载的电影剪辑。主要用于在blender外剪辑或者裁切视频的序列或者视音频片段。

- Set Scene Frames 设置场景帧

	设置结束场景帧以匹配当前剪辑所持续时间(首尾帧对位使用)。

- Detect Features 检测功能

	在当前帧上检测所有可能的功能，并在这些功能上放置标记。此算法不考虑其他帧，因此它可以在属于移动对象的特征上放置标记，如果摄像机偏离了镜头，摄像机移开后，不会在帧上放置任何标记。

- Motion Model 运动类型

	定义有哪些可能的运动跟踪类型存在。此选项应根据特定类型具有的运动来设置，它将使跟踪对于此类运动最准确。

	- Loc 仅位置
	- LocRot 位置+旋转
	- LocScale 位置+缩放
	- LocRotScale 位置+旋转+缩放，
	- Affine 仿射
	- Prospective 透视 通常用于跟踪平面特征，但通常 Affine 有一个足够好的近似值，可能有更稳定的轨迹。

- Match 模式匹配
	模式匹配控制跟踪哪些模式；更确切地说，从哪个帧得到跟踪的模式。下面是一个简介粗暴直观的例子。

	跟踪算法接收搜索区域内的两个图像以及要在第一个图像中跟踪的点的位置。跟踪试图从第二幅图像中的第一幅图像中找到该点的位置。

	现在，这就是跟踪序列的方式。第二个图像总是来自于标记位置未知的帧(下一个跟踪帧)。但是，不同的第一个图像(而不是紧接在素材中的第二个图像之前的那个)可以发送到跟踪器。

	- Keyfreame 关键帧
		从轨道关键帧构成的图像。这种配置防止从原始位置滑动(因为跟踪器返回与原始图案最相对应的位置)，但是当特征点由于相机运动而变形时可能导致小的跳跃并导致失败(例如，透视变化)。
	- Previous Frame 上一帧
		轨道的关键帧创建每个帧，并使用关键帧图像和下一个图像之间的跟踪。在这种配置中，模式在两个相邻帧之间进行跟踪。它允许处理特征点的大转换情况，但可能导致从原始位置滑动，因此应该控制它。

- Track 轨迹
	第一排按钮用于执行所选轨道的跟踪(即，按照帧与帧之间的选定特征进行跟踪)。跟踪可能发生(按按钮顺序)：

	向后一帧 Alt-Left
	沿着序列向后 Shift-Ctrl-T
	沿着序列前进 Ctrl-T
	向前一帧 Alt-Right

- Clear 清空
	清除(后/剩余)(左箭头图标) Alt-T 此项将删除当前帧之前的所有轨迹中的所有被追踪的、设置了关键帧的标记点。
	清除(前/右)(右箭头图标) Shift-T 删除所选轨道的当前帧所有的跟踪和关键帧标记。
	清除(跟踪路径/全部) Shift-Alt-T 此项将清除所有选中的轨迹中除当前帧之外的所有标记点。

- Refine 改善
	此命令将为所有选定标记运行从上一个关键帧到当前帧的跟踪。当前标记位置正在猜测初始位置，可由跟踪器更新以获得更好的匹配。

- Merge 合并
	加入轨道 Ctrl-J
	此操作将所有选定的跟踪路径合并为一个。选定的合并跟踪路径不应在同一帧上具有公共的跟踪标记或关键帧标记。


## 👉 Masking 制作遮罩

遮罩可以在图像 Image Editor 或视频片段编辑器 Movie Clip Editor 中创建，更改编辑器标题中的模式更改为遮罩 Mask 即可向编辑器面板添加各种工具和属性，同时隐藏与遮罩交互不需要的其他工具和属性。

遮罩有很多用途，可以用于视频运动跟踪的工作流，以屏蔽或影响影片中的特定对象。它们可用于手动旋转，将特定对象从画面中提出，或作为绿幕键控的范围控制蒙版。遮罩相对电影片段来说是一个独立的的特定影像，因此它们也可以用于在合成器中创建运动图形或其他效果。

遮罩可以通过时间来驱动，这样他们就可以从镜头中跟踪一些物体，例如一个正在奔跑的演员。这可以通过形态键”父子遮罩来追踪标记来实现效果。



## 👉 Movie Clip 影片剪辑

影片剪辑编辑器有两个主要用途，用制作追踪或遮罩影片。

场景属性面板中可以在 Active Clip 指定活动影片剪辑用于约束以及视图显示。



# 🚩 NPR 非真实渲染
1. 水彩风格 by Gakut https://www.bilibili.com/video/BV1F44y1r75Y
1. 水墨山水 by Mamenr https://www.bilibili.com/video/BV1EV411H79U/
2. 三维水墨金鱼《戏》 五天晴 https://www.bilibili.com/video/BV1kT411F7HU/
3. 三维水墨教程 五天晴 https://www.bilibili.com/video/BV14M4y1k7pD/
4. 王希孟你也太会画了吧？！ https://www.bilibili.com/video/BV1gT4y1k7qL/
5. 《千里江山图》 北宋 王希孟 https://www.ltfc.net/img/5be396f78ed7f411e26a464a
6. 《清明上河图》 明 仇英 台北故宫博物院 https://g2.ltfc.net/view/SUHA/608986e1d14344504828dffb
7. 清明上河图 明 仇英 辽宁省博物馆 https://g2.ltfc.net/view/SUHA/609672f536bd622e5d1ee9bf
8. 清院本清明上河图卷 清 陈枚 台北故宫博物院 https://g2.ltfc.net/view/SUHA/609678bfe2d4222ecd8c2f7f
9. SAI 笔刷纹理 https://pan.baidu.com/s/1hYRk548QDDFYYtbctEQeDw?pwd=j9jf

清院本清明上河图卷
清  陈枚  台北故宫博物院

材质尺寸：
绢本 长卷 设色 35.6x1152厘米

简要介绍：
绘十八世纪的以苏州城为主要特色的城市风貌，由清画家陈枚、孙祜、金昆、戴洪、陈志道合绘。画卷人物鞍马用工笔设色、山水树石系用青绿画法、建筑舟船用界画法、浮云流水用白描画法等。

款识题跋：
款识：乾隆元年（1736年）十二月十五日奉勅，臣陈枚、孙祜、金昆、戴洪、程志道恭画。

钤印：
作者印：臣枚、臣孙祜。
收传印：清内府诸收藏玺。

图片拼接脚本，利用 IrfanView 看图工具：

```sh
	$v = (dir *.jpg).Length / 4 - 1
	foreach ($i in 0..$v) {
	    $list = ((dir "$($i)_*.jpg")|% {"$($_.Name)"}) -join ","
	    & "C:\Program Files\IrfanView\i_view64.exe" /panorama=`(2,$list`) /convert=a$i.png
	}
	sleep 3
	$list = (dir "a*.png") -join ","
	& "C:\Program Files\IrfanView\i_view64.exe" /panorama=`(1,$list`) /convert=a.png
```


## 👉 Grease Pencil 2D绘图蜡笔
1. Grease Pencil https://docs.blender.org/manual/en/3.0/grease_pencil/index.html
2. [Grease Pencil Fundamentals](https://cloud.blender.org/p/grease-pencil-fundamentals/)
3. [Grease Pencil Blender 2.8 Free Samples](https://cloud.blender.org/p/gallery/5b642e25bf419c1042056fc6)
4. GP Magic Cube 示范 https://www.bilibili.com/video/BV16J411z7ph
5. GP 绘制三维头部模型 https://www.bilibili.com/video/BV18t411a7eV/
6. GP 《幽灵公主》YAKURU制作 https://www.bilibili.com/video/BV16K411u7ok
7. Grease pencil Tutorial by Dedouze https://www.bilibili.com/video/BV19y4y1r741/
7. PS水墨画笔刷 https://sheyingps.com/2020/12/0ea28775ce.html
7. Character turnaround sheet by Pcaggegi https://www.bilibili.com/video/BV1ZA411b7rg/
7. Line Art Modifier https://docs.blender.org/manual/en/latest/grease_pencil/modifiers/generate/line_art.html
7. Grease Pencil Blender Reel 2022 https://www.bilibili.com/video/BV1oT411L7Z2/


Blender 3.0 升级后，Grease Pencil 的绘画效果更好了，相比 2.83 或 2.93 好了不只一个档次。
不再有笔迹的采样不连续的问题，笔刷效果更好看了，而且不会像旧版本一样快速绘画就会有直线问题。

操作流畅性来说，是不能和 SAI 那样轻便的工具比较的，流畅程序不是一个级别，即使和 Krita 或 
Autodesk SketchBook 比也要差多了。

官方教程 Grease Pencil Fundamentals：

	01 - Introduction
	02 - The New GPencil Object
	03 - Object Mode
	04 - 2D Animation Template
	05 - Drawing Mode
	06 - Editing Drawings - Edit & Sculpt mode
	07 - 2D Animation
	08 - Drawing Brushes and Materials
	09 - Drawing and Layout in the 3D space
	10 - Modifiers and VFX Shaders
	11 - Rendering and Compositing.mp4
	12 - Annotate


蜡笔物体使用 layer 记录笔迹顶点数据，是三维空间中绘制的顶点。可用于制作传统的二维动画，剪纸动画，
动态图形(Motion Graphics)或者用作故事板工具等。蜡笔工具的主要目的是提供一个 3D 环境中的 2D 
动画工具。为了使用蜡笔获得最佳效果，强烈建议使用 绘图板。

如果学习二维动画，一个非常棒的参考是 Richard Williams Animation Masterclass 2008 年
发行的动画师生存手册，The Animators Survival Kit Animated，里面系统的展示了动画技术成就。

给摄像机设置背景图可以模拟绘画的纸张纹理，设置摄像机属性：Object Data -> Background Images，
指定纹理图片，然后按 ~ 选择摄像机视图就可以看到背景图。设置渲染引擎属性：Film -> Transparent，
可以渲染带透明层的图像。设置好 Compositing 进行后期处理，将背景图与 2D 绘画内容融合：

- 打开 Compositor 进行后期处理，勾选顶部的 Use Nodes 激活节点编辑器；
- 默认的节点有两个，Render Layers -> Composite。
- 在 Image 之间的连接增加一个 *Alpha Over* 节点进行透明通道合成处理；
- 增加 *Image* 节点，并指定背景图片，然后连接一个 *Scale* 节点设置缩放为 1 x 1。
- 将 Scale 的图像输出连接到 Alpha Over 的 Image 端口上。
- 按 F12 进行渲染，就可以看到融合的图像，如果绘画内容被背景覆盖，那么就交换 Alpha Over 的输入图像位置。
- 按住 Ctrl 拖动其中一个端口的连线到另一个端口即可以交换连接。 

Object Mode 菜单中提供多种蜡笔添加方式，Add - Grease Pencil 菜单项说明：

- **Blank** 内容空白的蜡笔对象；
- **Stroke** 包含一条笔迹的蜡笔对象；
- **Monkey** 包含一个猴头的蜡笔对象；
- **Object Line Art** 给指定对象生成轮廓线；
- **Scene Line Art** 给场景中所有对象生成轮廓线；
- **Collection Line Art** 给指定集合中的对象生成轮廓线；

Line Art 修改器是用于生成几何体线框的工具，类似 Freestyle Line 工具。创建蜡笔对象后，
添加 Line Art 修改器，属性设置：

1. **Source Type** 指定要生成轮廓线的对象类型。
2. **Layer** 指定生成的线稿保存的图层。
3. **Material** 线稿使用的材质。

在默认的线稿配置中，Edges Type 使用 Contour 方式，即产生轮廓线。另外，折痕阈值 140 度角，
Crease threshold，小于这个角度的边角就当作折痕处理，即产生轮廓线。折痕角是两个相邻面之间的角度。

折痕在曲面建模中也有应用，使用修改器细分几何体时，Edge - Edge Crease 命令可以用来卡边，
使细分的边线贴近折痕边。

线稿可以通过 Bake 面板烘焙到指定的蜡笔图层，注意，烘焙动作会删除图层原有内容。烘焙得到的线稿
就是可编辑的蜡笔对象中的笔迹。

几何体上线稿的生成与摄像机的位置有关，那些曲面法线与视线垂直的位置就是轮廓线产生的位置。
比如一个球体和一个盒子，球体边缘位置与盒子可以被观察到的连线就会有相应的轮廓线。笔刷材质
为 Dots 或者 Squares 时，只会在几何体顶点位置打点而不是绘线。

如果材质使用了填充，则会填充将摄像机能够看见部分。

蜡笔绘制的是矢量图形，可以看作是贝塞尔曲线，笔迹有 3 种基本组件：

- **Point**，点是蜡笔物体编辑时用的主要元素，代表在3D空间中构成笔迹的单个顶点。 
	每个点都存储定义笔画最终外观的所有属性，即纹理的位置，厚度，alpha，压力和 UV 方向。
- **Edit Line** 编辑线，两个顶点之间总是以直线相连，编辑或在线框视图中查看笔画时显示。 
	不会出现在渲染图像上，并形成最终的笔画。
- **Stroke** 笔触，笔画是使用特定的蜡笔材质渲染出的点和编辑线图像。 (蜡笔材质在笔画层次关联。)

在编辑模式下，可以对蜡笔的点、线或整个笔迹进行编辑，也可以使用蜡笔雕刻工具进行处理。
删除蜡笔图层，或者关键帧，或者删除所以笔迹的顶点都可以清空内容。

每个蜡笔图层都可以设置图层颜色的混合模式 Color Blend Modes：

- *Regular* 正常模式；
- *Overlay* 叠加，反转下层的像素，再乘于两倍上面图层像素值，再加上下层的原值，再除以 255，再乘下层的原值，再除以 255 得到较暗的效果，但比相乘要亮；
- *Addition* 叠加，将混合的图层像素值相加得到更亮的效果；
- *Subtract* 减去，下面图层减去上面图层的像素值得到较暗的效果；
- *Multiply* 相乘，与下面的混合图层像素相乘再除以 255，白色部分保持，黑色部分保持黑色；
- *Divide* 除去，这种模式会将上下图层的像素相乘，再除于 255，产生较暗的效果； 

默认情况下，视窗中图层的视图顺序为从上到下。每个图层都对应于摄影表编辑器 Dope Sheet 中的一个通道(在蜡笔模式下)。图层也可以与修改器一起使用，仅影响部分绘图。在 Dope Sheet 编辑器中，选择 Grease Pencil 模式即可查看蜡笔对象的帧动画。

Onion Skinning 洋葱皮显示当前帧之前和之后的关键帧鬼影，给动画制作者当前动画序列的前后帧关系参考。


## 👉 Grease Pencil 笔刷与材质

画笔各种属性的关系：

1. Brushes：笔刷是一种渲染程序模型，决定笔触呈现出的外观，例如 Airbrush、Ink Pen、Pencil。
2. Strokes：笔触是蜡笔对象基本的图形单元，笔触绘制后得到构成笔迹的一组数据。
3. Material：笔刷材质，可以设置 Line Type、Stroke Style，填充色和 Base Color。

笔画颜色有两种设置模式 Paint Mode：

- Material 材质决定画笔颜色模式，只能通过材质指定颜色；
- Vertex Color Attribute 顶点颜色模式，可以直接选择画笔颜色；

笔刷材质 Line Type 可以设置为 Line、Dot、Square 等基础图形，样式可以设置 Texture 方式，
笔触纹理图像与基础色进行混合，显示为 Line Type 指定的形状。

填充样式可以设置为 Solid（纯色）、Gradient、Texture，后两种与填充色 Base Color 进行混合。
可以给蜡笔对象创建多个 Material Slot 以使用多种材质设置，笔迹一旦绘制，就记录笔刷材质关系，
后续通过编辑材质就可以再次修改内容。

如果在绘制过程中需要频繁切换图层或材质，可以使用 Y、U 快捷键进行操作。

注意，3D 视图着色模式要设置为 Rendered 或者 Material Preview 方式才会显示蜡笔的色彩。

而使用顶点颜色绘画模式下，颜色会记录到顶点属性数据集，Vertex Color 面板中可以设置 Mode 和 
Mix Factor，默认混合系数为 1，表示完全为顶点颜色，后续也不能再通过材质来修改笔迹内容。
尽管如此，颜色属性模式下，材质是否启用 Strke 或 Fill 有影响。当顶点颜色混合系数小于 1，
寻么，后续修改材质属性时，就可以改变现有的笔迹外观。

顶点颜色是顶点属性数据的一种，在图形学 API 中，列如 OpenGL 向 GPU 传递的顶点数据中，除了
坐标信号，还会包含顶点颜色等数据。


2D Animation 模板默认提供的笔刷材质有四种：

- Solid Stroke 实心笔迹；
- Squares Stroke 方块笔刷；
- Solid Fild 填充区笔迹；
- Dots Stroke 点状笔迹；

Blender 3.3 提供的内置笔刷：

1. Airbrush 喷枪
2. Ink Pen 墨水笔
3. Ink Pen Rough 粗墨水笔
4. Marker Bold Pen 马克记号笔
5. Marker Chisel 方头马克笔
6. Pen 实心圆珠笔
7. Pencil 硬铅笔
8. Pencil Soft 软铅笔

笔刷材质总是和画笔关联的，画笔改变材质后，线条也会随之改变。而画好的线条和材质是关联的，
修改材质会反映在线条上。可以创建自定义笔刷，配置各种笔刷参数，修改参数不会影响现有的笔迹。
有些 Blender 玩家通过几何节点创建水墨笔刷效果，通过曲线进行程序化建模，使用曲线绘制水墨画。

不同的笔刷可以更换不同的材质，不同蜡笔的笔刷有不同的效果，并且材质属性又会影响绘图效果。

蜡笔材质是一种特殊的着色器，用于定义笔划和填充曲面的外观，笔刷材质和 3D 模型使用的
不是同一套材质模型，蜡笔材质主要是设置 Stroke 和 Fill 属性。不能使用材质节点编辑器
对其进行自定义。

不同的绘制笔刷，如铅笔、钢笔、马克笔等具有不同的绘画效果，你可以创建若干笔刷，每一个笔刷
使用独特的设置，从而在绘制时得到不同的艺术效果。Blender 内置的笔刷数量有限，不及 Krita
这样的开源软件丰富，可以去定制或借用别人的笔刷。

在进入绘图模式后，选择画笔/填充工具后，或其它矢量图形工具，可以在侧栏工具面板中对笔刷进行设置。
笔刷材质主要设置：笔触 Stroke 和填充 Fill 属性，材质如何绘制到场景中还受笔刷的各种参数影响。
如笔刷的大小半径 Radius/ 强度 Strength/ 采样量 Input Sample，笔触的稳定度 Stabilize，
随机性 Randomize/ 收笔处理 Post-Processing，还有笔刷的压力设置。

Windows Ink 触屏的压感支持接口在 Preferences - Input - Tablet 中设置。

笔刷使用的材质可以在属性面板中设置，笔刷材质有个圆形色块图标表明这是一个填充材质，材质图标
带有 3 个点的表明是一个描边材质，只设置了笔触颜色 Stroke 而没有设置填充 Fill。材质图标为
实心圆表示使用了 Fill 填充色。

填充方式 Fill Style 可以设置一个颜色 Solid 或渐变色 Gradient，或外部导入的纹理图片。
图像编辑器 Pack 命令可将纹理文件可以内嵌到 blend 文件：Image Editor - Image - Pack。

使用渐变色填充时，只有两个颜色，使用 Blend 指定混合比例，1 表示完全使用 Base Color。
渐变方式有 Linear 和 Radial 两种，但是很难在绘画模式下控制渐变方向。

蜡笔**编辑模式**，可以对渐变方向进行调整，编辑模式下也可以修改等笔迹的半径、变换，还可以
对笔迹曲线的顶点进行挤出，Extrude，3D 化曲线。可以在材质属性面板中重新设置笔迹所使用的材质，
或者根据材质选择所有的笔迹。

如果使用顶点颜色，并且设置了 Fill 模式，那么顶点色就会替代 Base Color，按指定系数混合。

材质中还有两个额外选项：

01. Holdout 阻隔，将当前笔划作为遮罩使用，过滤掉当前笔迹后方笔迹的颜色，形成透明区。
02. Self Overlap 自遮挡，禁止与 alpha 材质的镂空、重叠自相交。
	Disables stencil and overlap self-intersections with alpha materials.

蜡笔材质 Holdout 在多个蜡笔对象之间有效，同一个蜡笔对象内，比较的是笔迹的前后顺序，
不同蜡笔对象之间比较它们在 3D 空间的深度。相对于图层遮罩，只能在同一个蜡笔对象内使用。

蜡笔**雕刻模式**，可以对笔迹的颜色强度、顶点随机性、平滑性、半径等进行调整。

画笔材质主要由笔触线条和填充两部分构成，要定制画笔就要从这两部分入手。喷枪和铅笔使用的是 
Dots Stroke，利用紧密的点云来模拟笔迹。但不能直接通过 Dot Stroke 材质来模拟这两种
笔刷的效果，需要复制这两种笔刷再进行参数修改。Blender 内置的几个笔刷会根据用户选择的材质，
或笔刷颜色模式进行绘图，除非使用 Pin Mode 固定画笔材质或颜色模式。

笔刷材质定制与纹理图像：

- Mode Type 只有三种可选的笔刷模式，Line、Dots、Squares，以上四种材质基于这些模式定义的。
- Style 风格选择，默认是 Solid 实心风格，可以指定线条和填充颜色，另一个是纹理风格 Texture。

使用纹理风格，可以指定一个纹理图片当作笔刷的纹理。此外可以指定一个 Base Color，设置 Blend
混合百分比，即可以与纹理图案的颜色按比例进行混合。纹理图像可以用于笔触，也可以用于填充，这两种
使用方式有些差别。首先 Blender 会按**电子布告**方式呈现笔触上的纹理，即二维的纹理图像始终面向
观察者。而填充中使用纹理图形则不是这样，因为填充意味隐含着一个填充平面，这个平面会上填充的纹理
符合 3D 对象的空间变换，所以在同平面角度下看不到填充的纹理图像。


而笔触上的纹理图形始终可见，这就会在 2D 笔刷上产生一种厚度感，在 Alignment = Fixed 
对齐方式下，笔刷纹理就不会随视图角度的变换而出来翻转的现象。在给叶片这样的模型时，可以一笔笔
地画出轮廓，如果画笔使用了纹理，那么就会有厚度感。如果是使用填充方式，则叶片就没有因纹理朝向
带来的厚度感，但依然可以使用带有线条状的纹理图像来实现叶片的绒毛效果。

不使纹理的笔刷，只要半径足够大，也会因为笔迹朝向观察者而产生厚度感，只有使用区域填充才不会。

在网格平面上绘画，或者 Surface 笔触方式时需要一个偏移距离，避免笔迹的填充内容所在平面与
网格重叠而导致笔迹不能正确渲染。在蜡笔对象之间，这种因绘画平面重叠导致的渲染异常现象也会发生。
表现就是蜡笔 Stoke 会先和场景的背景色混合，再覆盖掉其它蜡笔对象中平面重叠的填充内容。同一个
蜡笔对象内不存在这种问题。

另一个问题是，蜡笔对象的笔迹会记录大量数据，一般用于线稿或色块填充，不适宜用来厚涂绘画，
应该使用几何体的 Texture Paint 绘画模式，这种工作方式使用位图，在指定纹理图像大小前提下，
可以任意绘画，而不会像蜡笔对象一样出现数据积压。

笔刷参数定制在 Advanced 和 Stroke 两个下拉列表中，或者在侧栏工具 Brush Settings 中设置：

- Input Samples 画笔输入采样系数，10 级为最大采样，笔迹越贴近输入值，产生的采样数据也最多。
- Hardness 硬度设置越接近 100%，绘画时的笔迹大小就越接近 Radius 指定的大小。硬度越小，边缘融合就越平滑。
- Aspect X/Y 笔触外观比例比值差距越大，线条边缘也会越模糊，在 1% 的比例下，线条会呈现绒毛状态。
- Angle/Factor 角度控制哪个方向下的笔迹最粗，0° 表示水平方向，Factor 为强度系数，为 0 表示无效果。
- Randomize 设置各种随机强度，比如 Pressure 设置为 100% 表示笔迹的压力是完全随机的，Jitter 的弯曲抖动的随机性。

在 Blender 2.93 版本上，还可以对颜色进行随机化处理，Hue/Saturation/Value 三个变量。
并且可以根据笔迹所在的层级，即每次下笔都是一个随机值，或者根据绘图板压力随机变化。这些随机化
可以定制出效果非常好的笔画，可以用来模拟水彩效果。

蜡笔对象可以有光照，但是与几何体中使用的光照不同，蜡笔对的的光照只是在原有色彩的基础上增亮而已。
使用 Object Properties ‣ Visibility ‣ Use Light 启用蜡笔对象的光照，或者对图层逐个控制。


Blender 官方资源网站上提供了一套由 Daniel 配置的多彩笔刷，纹理贴图可以用 Krita 创建。
纹理贴图可以使用带透明通道的 PNG 图像，一般同使用黑色表示形状，配合材质的 Blend 过滤纹理颜色。
用户笔刷通过复制内置笔刷创建，然后修改属性配置、材质选项等等，通过 Active Tool 属性面板操作，
点击 Brushes 预览框中的复制按键，然后点击 Brush Setting 面板中的材质选项的数字按钮创建
新材质，也可以在材质面板中创建。新创建笔刷后，需要给蜡笔对象添加材质插槽，并添加新创建的材质。

杂草笔刷配置参考，包含材质配置、笔刷设置：

- Stroke Line Type = Dots
- Stroke Style = Texture 使用杂草纹理 
- Texture Blend = 1.0 完全由材质或顶点颜色进行混合着色，不使用纹理中的颜色
- Alignment = Fixed 笔迹不会因视角改变面发生对齐变化

- Strength = 0.7 适当强调保持边缘清晰
- Input Samples = 0.0 减少重复，避免每株草因过度连续而覆盖
- Hardness = 1.0 保持边缘清晰
- Randomize Radius = 0.6 半径随机范围产生杂乱感
- Randomize UV = 0.3 设置朝向随机范围产生杂乱感，Jitter 可以实现更混乱的效果
- Hue/Saturation/Value 根据需要设置色度、饱和度、明亮度的随机范围

使用纹理的笔刷材质，Line Type = Line 时，笔迹通常为断断续续的纹理图像，并不像名称那样成为线条。
对于水墨类笔刷则要调低强度。在线条模式下，可以设置 UV Factor 来改变纹理像素的大小。

Brush Pack_v2_Blender2-90 or above by Daniel Martinez Lara (Pepeland) By 
Daniel Martinez Lara (Pepeland) 
https://pillar.blender.cloud/p/grease-pencil-fundamentals/resources
https://cloud.blender.org/p/gallery/5f235cc297f8815e74ffb90b
Water color flower in Grease Pencil https://www.bilibili.com/video/BV1F44y1r75Y?p=7


## 👉 Grease Pencil 绘画平面与笔触定位

在绘图模式下拉列表右侧，有几种绘图选项 Drawing Options：

01. *Draw Strokes on Back* 启用时，新绘画的笔迹会位于旧笔迹的后面，即避免覆盖旧笔迹。
02. *AutoMerge* 新笔划起点与当前图层的旧笔迹起止点够近时，就将它连接起来成为一条笔迹曲线。
03. *Add Weight Data* 启用并且创建顶点组，笔迹顶点将在当前顶点组中记录权重 Weight = 1。
04. *Additive Drawing* 增长式绘画，配合 Auto Keying 功能使用，使用绘图工具或擦除工具时，
	会将上一个关键帧或活动帧中的笔迹复制到新的帧，作为新帧的基础内容。
05. *Multiframe* 允许同时在多个帧上绘制，配合时间线进行动作制作。

另外，画笔放置方式和绘画平面决定了绘制内容如何在 3D 空间，默认绘画平面是 3D Viewport，
绘画平面与相机视图正交。默认的 Origin 放置方式表示绘画平台经过蜡笔对象原点，选择 Surface
绘画到模型的曲面上，并指定 offset 表面距离。Stroke 放置方式，会按画笔的指定点进行连接。
例如 First Point 表示由起笔位置现有笔迹决定新笔迹的放置位置：

1. Stroke Placement
	- **Origin** Strokes are placed at Grease Pencil object origin.
	- **3D Cursor** Strokes are placed at 3D cursor.
	- **Surface** Strokes will stick on mesh surfaces.
	- **Stroke** Strokes will stick on other strokes.
2. Drawing Planes
	- **Front** Strokes are drawn on the plane determined by the XZ axes.
	- **Side** Strokes are drawn on the plane determined by the YZ axes.
	- **Top** Strokes are drawn on the plane determined by the XY axes.
	- **View** Strokes are drawn with the current 3D Viewport orientation.
	- **Cursor** Strokes are drawn with the current 3D cursor orientation.

在对象数据属性面板中，蜡笔物体都有一个 2D 图层列表 Layers，用于分组和排列笔画 List view。 
任何笔画只能从属于单个 2D 图层。列表中始终只有一个活动层(选定的一个)。绘制时，新笔画将添加到
活动层里。图层列表中，可以设置图层遮罩、洋葱皮 Onion Skining，及显示状态和锁定状态。一个图层
作为其它图层的遮罩层使用时，那么这个层有笔迹的部分就会叠加被遮罩层的内容，空白区就不会显示内容。
当然，可以反转遮罩。一个层激活遮罩功能后，可以在 Mask List 中设置多个遮罩层。

图层遮罩有个特点，2D 图层都是 3D 空间中投影得到的，在调整摄像机视角时，遮罩层也一样在进行变换，
但只要遮罩层的内容（笔触与填充）与被遮罩的内容重叠，就可以显示出来，而不管遮罩层是在上还是在下。
这是非常有用的一个特性，例如，可以用来制作伪 3D 脸部，视角在变换时遮罩超出的区域的部分可以很好
地使用 2D 图形模拟出 3D 效果，在 Spine 这种二维动画工具应用非常多。

使用蜡笔绘画 3D 模型是有些困难的，因为着笔点和提笔点的空间位置不好确定，不像 2D 空间绘画，
有明确的二维坐标，三维中多了一维：深度。笔画放置有**3D Cursor**和**Surface**两种方式，
可以使用它们提高画笔定位的精确度，它们在蜡笔绘画中的作用就是提供深度参考值，也就是绘画平面
会经过 3D Cursor 或者画笔与曲面的交点。

同时，配置绘画平面的设置，以提高三维空间的绘画准确度。除了全局坐标轴提供的参考平面，3D Cursor
本身也有一个参考平面，但是使用 View 平面是最方便调整的，用户可以随时通过旋转来改变它。另外，
激活 Local View 可以将视图的旋转操作围绕着蜡笔对象中心点进行。

在三维空间中，笔迹的覆盖关系按其在图层的绘画顺序确定，默认状态是后面绘画的笔迹覆盖旧笔迹，
新的笔迹在 3D 空间上在旧笔迹的更远处，激活**Draw Strokes on Back**则反转绘画顺序。
对于现有的笔迹，需要在编辑模式下调整它们的绘画顺序，菜单操作：Stroke - Arrange。

比如，荷花的花瓣类似椭圆曲面，那么就可以在场景中创建一个挤压后的球体曲面作为绘画参照体，笔触
设置为**Surface**放置方式，这样就可以直接在球体表面约绘画荷花的花瓣。Blender 内置插件
Sapling Tree Gen 可以用来生成树干模型，这也可以用于蜡笔绘画的参照物。

使用 2D Animation 模板时，会隐藏 3D Cursor，显示设置：Viewport Overlays - 3D Cursor。

默认的 View Layer 属性配置下，几何体与蜡笔对象组合渲染过程中，蜡笔对象始终会遮盖几何体，因为
缺失了几何体的位置深度数据。需要打开视图层的 Z 通道数据：View Layer - Passes - Data - Z。

默认的蜡笔对象的渲染顺序按 Z-Depth 深度数据比较，蜡笔对象数据面板中，要将 Stroke Depth Order
由默认值 2D Layers 改为 3D Location 即可使用深度信息来确定笔迹的绘图顺序。使用以下方式添加
的蜡笔对象可能无法设置深度排序方式：

- **Object Line Art** 给指定对象生成轮廓线；
- **Scene Line Art** 给场景中所有对象生成轮廓线；
- **Collection Line Art** 给指定集合中的对象生成轮廓线；

默认的 2D Layers 深度比较方式不会考虑笔迹的三维空间位置，它们总是按其在图层中的堆叠顺序决定
哪个笔迹被覆盖，而与其三维空间位置无关。2D Layers 深度方式下，可以使用多个蜡笔对象，蜡笔对象
之间会进行 3D 位置的比较。


1. 水墨场景 by Aubiz https://www.bilibili.com/video/BV1wd4y1A7Pb/
2. 几何表面绘制蜡笔 https://www.bilibili.com/video/BV1bW4y157X4/

注意，Stroke Placement 方式设置可能导致 Blender 卡顿。例如，Surface 方式，但绘画时
笔触又没有到达相应的几何体表面。又或者，使用 Stroke 方式，但绘画时没有触及其它笔迹，这就
导致 Blender 找不到相应的参考物体，产生卡顿。



## 👉 Grease Pencil 各种模式介绍

蜡笔对象有四种主要工作模式，各模式介绍如下：

- *Draw Mode* 绘画模式，
- *Sculpt Mode* 雕刻模式
- *Edit Mode* 编辑模式
- *Vertex Paint Mode* 顶点绘制模式
- *Weight Paint Mode* 权重绘制模式
- *Object Mode*  对象模式

蜡笔绘画模式下的工具栏有一系列规则形状工具，如直线、矩形、圆形等等，还有以下常用工具：

**Draw tool** 绘画工具。
**Fill tool** 填充工具。
**Erase tool** 橡皮工具，用于擦除现有笔迹，使用绘画工具时直接按下 Ctrl 触发此工具。
**Tint tool** 着色工具，利用顶点颜色，将材质基础颜色与选定颜色混合，Ctrl 触发顶点色擦除模式。
**Cutter tool** 用于裁剪交叠的笔迹，要圈选到笔迹的顶点才会有效果。

蜡笔绘制模式下，工具栏中的 Fill 填充工具需要配合启用了 Fill 属性的材质才能起到填充效果。
填充工具需要在封闭的笔迹上操作，Edit Mode - Stroke - Close 将笔迹首尾连接起来。执行
填充时，会在原有封闭的笔迹上创建新的笔迹，并且使用材质 Fill 属性指定的颜色或纹理进行填充，
又或者使用顶点颜色进行填充。

**绘画模式**是最基本的，所有蜡笔对象都可以通过绘图获得，通过雕刻或编辑改变对象的呈现形状。
**雕刻模式**类似编辑模式，但使用一个非常不同的工作流程，使用类似捏泥人的方法修改笔画，
而不是处理单个元素，点或线。

蜡笔绘图是 2D 空间，在三维场景中要先确定一个绘图平面 Drawing Plane，进入绘画模式后，
可以在视图中上位置选择绘图平面，比如 Front(X-Z) 就将所笔画的绘制锁定到同一个平面，
默认绘画平面是 View，即当前视图的投射平面作为绘图平面。

编辑模式可以对笔迹进行重新投射：Grease Pencil - Clean Up - Reproject Strokes，
画笔曲线的顶点重新投影到指定的平面上。再次投身的平面如果是正交的，笔迹的顶点就会成为一个直线。

3D 空间中的不同平面位置绘制的笔画，它们从某个平面或从摄像机视图看起来是正确的，笔画重投影
可以将现有的笔迹投射到正确的绘画平面上。进入蜡笔编辑模式，选择需要重投影的笔画。笔画投射后
将保持在选中的平面上，并且在当前视图上看起来的形状是一样的。

*雕刻模式*与*编辑模式*的相似之处在于，它用于更改图形的形状，但雕刻模式使用了完全不同的工作流：
不是处理单个元素（点和编辑线），而是使用笔刷更改模型的区域。换句话说，不是选择一组点。雕刻模式
在笔刷影响区域操纵图形，对笔迹进行推拉挤压。蜡笔对象的雕刻与几何体雕刻工具有此不同，蜡笔雕刻
工具可以说极其简化，只能对笔迹顶点的强度、随机性、平滑度、半径（粗细）进行调整，一般是在同平面
上进行的操作，可以 Grab 或 Push 工具将顶点推出其它平面上，形成三维的曲线。操作之前，需要在
编辑模式下选中要雕刻的笔迹或顶点。

使用雕刻模式的克隆工具可以快速复制笔迹，需要先使用 Select Box 选择要复制的笔迹，按 Ctrl-C
将其复制到粘贴板，然后再点击指定位置克隆出来。克隆出来的笔迹保持与原笔迹一样的空间朝向，不会
因为用户调整视角而改变。

*编辑模式*将蜡笔的笔迹当作 3D 场景中的一个对象进行处理，提供的许多实用工具，可以对笔迹
进行挤出、缩放、移动、旋转、切变、弯曲等操作，还有对笔迹进行图层间的移动。

通过编辑工具给 2D 的绘图元素增加立体感是常用的手段，将原来 2D 平面化的对象挤出立体感，并作为
3D 场景中的物体来使用。例如，先绘制 2D 的花瓣，按球面弯曲进行造型，这样就具有 3D 的效果。


*顶点绘制模式*是在油笔对象上绘制顶点颜色的一种简单方法，通过绘制顶点的颜色属性就可以改变
笔迹的颜色，以及填充区的颜色，从而影响笔刷材质基色。使用选区遮罩 Selection Mask，
只在选择中的顶点、笔迹上绘画，也可以选择被其它笔迹交叉的部分进行绘画。

- C 进入圆形选择工具，涂抹要选择笔迹，然后回车确认选区；
- D 使用画笔；
- 鼠标右键调出色板；


在三维视口中，构成笔迹的顶点可以转换为三维空间，可以基于当前视图设置，将活动层上的蜡笔草图转换
为几何体。目前，将使用所有点，因此可能需要简化或细分所创建几何图形的部分以供标准使用。草图可以
在**对象模式**下转换为曲线，曲线又可以再转换为曲面。

蜡笔的**对象模式**提供了两种基础功能，Object ‣ Convert 菜单提供转换操作：

01. Convert to Geometry 将笔迹曲线转换为几何体；
	- Path 将笔迹转换为 NURBS 3D 路径。
	- Bézier Curve 将笔迹转换为贝塞尔曲线。
	- Polygon Curve 将笔迹转换为多边形曲线。
02. Trace Image to Grease Pencil 描边黑白双色图像得到蜡笔对象，配合 Image Empty 使用；

一个非常好的例子就是通过蜡笔进行树干的建模：

01. 使用蜡笔的线条绘制树干的基本形态；
02. 在对象模式下，Convert - Path 将蜡笔转换为 NURBS 3D 路径；
03. 在路径对象数据属性面板中，修改 Geometry，设置 Profile 得到合适的切面，Depth 调整粗细；
04. 编辑模式下，使用 Radius 工具调整顶点的半径，树干半径通常自下往上逐增，合理使用比例化编辑工具；
05. 在对象模式下，将路径转换为 Mesh 得到最终的几何体；

编辑模式下，Grease Pencil - Separate 菜单提供的命令可以分离选中笔迹或图层，得到新的蜡笔对象。
蜡笔绘图建模 https://www.bilibili.com/video/BV1J84y1v71a/

部分编辑快捷键：

- 挤出 E 挤出工具会在复制点的同时，保持新的几何结构与原始点相连。
- 半径 Alt-S 拓展或收缩选定点的半径厚度。
- 弯曲 Shift-W 弯曲3D游标与鼠标/压感笔之间的选定点。
- 切变 Shift-Ctrl-Alt-S 沿屏幕坐标水平或竖直方向切变选定点。
- 圆化 Shift-Alt-S 在选定笔画的中心以球形向外移动选定点。
- 点和笔画可以 G 移动，R 旋转，S 缩放，与 Blender 中其他元素一样。
- C 进入圆形选择工具，涂抹要选择笔迹，然后回车确认选区；
- B 矩形选择；

绘图模式下最常用的是手绘工具，需要绘画基础。

- LMB 或使用绘图笔在视角绘制自由线。
- 视图 Guides 列表中提供多种引导线
	- L Parallel 激活平衡引导线模式。
	- C circular 激活圆形引导线。
	- O 移动参考点。
	- M 以 90 度为单位旋转参考角度，水平、竖直方向切换。
	- J 逆时针旋转参考角度。
	- K 顺时针旋转参考角度。
- B 框选删除选中区域。
- F 来改变画笔大小，移动鼠标/压感笔或输入数字并确定。
- Shift-F 改变画笔强度，移动鼠标/压感笔并 LMB，也可以输入数值大小。
- Y 图层选择。
- U 笔刷材质选择。
- 鼠标右键在 Material 颜色模式下调出材质相关设置面板，在 Vertex Color 模型下调出色板。
- Alt-LMB 限制画出水平或竖直的线条。
- Ctrl-LMB 暂时激活擦除工具。
- Shift-LMB 平滑线条，或勾选笔刷选项面板中的稳定选项 Stabilize。

填充闭合笔划区域使用 Fill 填充工具，通常用来上色，配合画笔材质的 Fill 填充属性使用。

- Alt-LMB 创建边缘笔画，闭合目标区域。 边缘笔画，一种用于闭合开放性形状的临时线条，填充的区域有较大的缝隙时使用。
- Ctrl-LMB 暂时激活自由线工具。例如，可以手动填充一些工具难以填充的小区域。
- 使用 Shift 创建完美圆弧，使用 Alt 从中心点开始创建圆弧，使用 M 翻转。

内置二维猴头： Add - Grease Pencil - Monkey，名字叫做"苏珊娜"，是 Blender 的吉祥物，
可以作为标准测试的蜡笔对象。与蜡笔对象一并添加的还有相应添加画笔材质，在属性材质面板查看
Materials Properties。有肤色相关的 Skin 前缀的三个颜色材质，还有眼睛相关的 Eyes、 Pupils，
可以在此设置画笔材质的笔触外观 Stroke 和填充类型 Fill，填充有固色 Solid、 渐变 Gradient、 
棋盘 Checker Board、 纹理图 Texture。

绘画模式下，View - Tool Settings 打开工具设置面板就可以设置画笔的类型、材质、压力及敏感度曲线。

在蜡笔对象的编辑模式下，提供了 3 种选择模式，对应热键 1, 2, 3：

- Only Point 选择单独的点；
- All Stroke Point 选取整个笔画，笔画的所有点。
- 两者间的点 选取其他笔画之间的所有点。


蜡笔修改器

- 生成
	- Array 阵列修改器
	- Build 构建修改器
	- Mirror 镜像修改器
	- Simplify 简化修改器
	- Subdivide 细分修改器
- 变形
	- Armature 骨架修改器
	- Hook 挂钩修改器
	- Lattice 晶格修改器
	- Noise 噪波修改器
	- Offset 偏移修改器
	- Smooth 平滑修改器
	- Thickness 线宽修改器
	- Time Offset 时间偏移修改器
- 颜色
	- Hue/Saturation 色相/饱和度修改器
	- Opacity 不透明度编辑
	- Tint 染色修改器

蜡笔视觉效果 Visual Effects

- Blur 模糊视效
- Colorize 着色视效
- Flip 翻转视效
- Glow 发光视效
- Light 灯光视效
- Pixelate 像素化视效
- Rim 边缘视效
- Shadow 阴影视效
- Swirl 漩涡视效
- Wave Distortion 波浪扭曲视效


## 👉 Grease Pencil Animation

Grease Pencil 对象动画有多种方式：

- Moving as a whole object (Changing their position, orientation or size in time;)
- Drawing frame by frame (traditional animation).
- Deforming them (Animating their points)
- Inherited animation (by its parent, hook, armature, etc. cut-out animation)

蜡笔工具提供一个完全沉浸在 3D 环境中的 2D 动画工具，有多种方式进行动画制作：

- 作为整个物体移动及时改变他们的位置、方向或大小；
- 逐帧绘制 每次绘制一帧(传统动画)；
- 将它们变形 为它们的点设置动画；
- 继承其它对象的动画，使物体根据另一个物体移动(例如其父对象、挂钩、骨架等)，例如剪纸动画。

蜡笔绘画工具是基于曲线（贝塞尔）实现的绘画笔迹，可以和骨骼系统结合，通过骨骼来控制曲线的运动。

**Interpolate tool** 笔迹插值工具，在关键帧之间产生新的 breakdown keyframe。

笔迹插值工具在两个关键帧之间产生插值笔划，并产生相应的分解关键帧 breakdown keyframe。
需要游标位于两个关键帧之间时操作，单击并拖动，到指定的插值百分值，将添加一个新的细分关键帧。
比如，在第一帧绘制一个 S 符号，在第三帧绘制一个 Y 符号，注意笔数要一致，然后在第二帧进行
插值，拖动到插值百分比为 50%，即产生一个介于 S 和 Y 之间的符号。

使用 Dope Sheet -> Grease Pencil 视图管理 2D 动画关键帧，注意与 Timeline 的关键帧
区别开来，这里使用传统的 2D 动画技术做一个弹跳小球动画。 

首先，从新的 2D 动画模板开始，该模板已创建了蜡笔物体，激活了洋葱蒙皮，并激活了相机视图。

- 在 Timeline 编辑器中，设置时间轴中的动画范围 Start = 1，End = 24。
- 在 3D 视图中，使用绘制工具在左上角绘制一个球 (extreme，极限帧)。
- 移动到第 12 帧，并在底部中心中绘制一个挤压的球 (breakdown，间断帧)。
- 移动到第 24 帧，并在 3D 视图的右上角绘制一个球 (extreme，极限帧)。
- 继续绘制所有您想要的中间帧，使用 Onion Skinning 洋葱皮作为参考。
- 测试动画，请按 Spacebar 进行播放。


2D 传统动画使用了关键帧 Keyframes 和洋葱皮 Onion Skinning。每次在蜡笔物体绘制模式下创建
描边时，都会在活动通道上的当前帧处添加新关键帧。摄影表中的蜡笔物体通道对应于活动 2D 图层。
洋葱皮产生当前关键前后的关联帧鬼影，作为绘画时的轮廓参考，可以在多个位置打开洋葱皮功能，如
蜡笔图层、材质属性、时间轴或摄影表。

在蜡笔对象的属性面板中，Onion Skinning，可以设置显式模式、前后关键帧的数量。

在蜡笔对象的编辑模式下，激活 Multiframe 多帧允许您同时在多个动画关键帧上编辑，雕刻或刷权重。
这点非常有用，可避免在动画制作时一次一帧地执行重复性任务，例如在动画中重新定位图形。

蜡笔绘画模式下，使用 Draw - Animation 菜单，可以为当前活动图层或所有图层增删动画关键帧。
使用 Interpolate Secquence 可以在两个关键帧之间生成插值序列帧，游标要在两个关键帧之间。

使用 Multiframe 多帧编辑模式，首先要选择好需要编辑的关键帧，激活 3D 视图标题中的多帧工具。
在多帧编辑模式下，会显示已经选择的关键帧的轮廓，绿色、蓝色对应前、后关键帧，相当于洋葱皮功能。

激活 Multiframe 多帧编辑模式后，可以：

- 开始编辑，配合 Proportional Editing 工具使用。
- 开始雕刻，雕刻笔刷将会作用于所有选中帧上的笔画。
- 开始刷权重，权重绘制笔刷将会作用于所有选中帧上的笔画。

使用衰减工具可以修改多个关键帧内容，只要蜡笔图层内容位于作用区块内，对笔画的影响将从当前帧
按照曲线定义的方式开始作用于已经选择的关键帧。使用鼠标操作 Proportional Editing，可以
用滚轮调整作用区域的大小。


可以给蜡笔对象添加修改器，有四类修改器 Modify、Generate、Deform、Color。

例如，用于修改功能的 Time Offset Modifier 可以用来指定要循环播放的帧范围。
用于变形的修改器作用很大，比如 Noise modifier 可以在静态的帧加上噪声波动
补出几帧，包括颜色也有波动效果。

专用于变形的两个修改和对应的主控对象：

- Lattice -> Lattice Modifier  晶格对象与晶格变形修改器；
- Armature -> Armature Modifier 骨骼对象与骨骼变形修改器；

晶格对象 Lattice 通常称为外部变形笼，晶格由三维不可渲染的顶点网格组成，相当于集成多个
Hook Modifier。其主要用途是使用晶格修改器对其控制的对象应用变形。如果对象的父对象为
晶格变形笼，则会自动应用晶格修改器。

晶格变形的一些应用场景：

- 那些具有极多顶点的模型，如果直接修改是不可能的，晶格变换可以有效地实现复杂模型的变形。
- 从晶格修改器获得的平滑变形可能很难手动实现。
- 多个对象可以使用同一晶格，从而允许您一次编辑多个对象。
- 与所有修改器一样，它是非破坏性的。
- 晶格不会影响网格曲面的纹理坐标。

在物体模式下，将晶格对象缩放、移动以适当围绕的应变物体，修改晶格的分辨率，格子越多控制越精细，
适度就好。选择应变物体，再选择晶格对象，按 Ctrl-P 执行 Set Parent to -> Lattice Deform，
再给模型设置晶格控制器并指定晶格对象以实现控制。在编辑模式下，修改晶格对象，对晶格的任何缩放、
移动以及顶点的修改，都将导致物体形变。这包括使用 Ctrl-A 应用其缩放，因为这将获得与编辑模式下
缩放晶格乃至物体相同的结果。

给模型设置晶格修改器时，勾选 Outside 可以对晶格对象表面的部分进行变形。Vertex Groups 
可以限定作用的顶点范围，顶点组来自应变对象。

尝试了一下将晶格对象绑定到骨骼，但是并不能使用骨架姿态来控制晶格，只在对象模式下的操作有影响。


*权重绘制模式*将权重分配给点主要用于在剪纸动画，或者骨骼控制的动画中操纵笔迹。蜡笔对象使用
贝塞尔曲线来建模笔迹，曲线中的顶点不仅存储颜色信息，还有权重信息。蜡笔对象数据属性面板中，
顶点组用于定义对笔画的相对骨骼影响。

Blender 的权重系统是通用的动画控制技术，一般都与顶点组配合使用。Vertex Groups 位于对象
数据属性面板中，可以将选择中的顶点分配到一个顶点组中，Assign 表示给这些选中的顶点设置 Weigth 属性中指定的权重值。Vertex Groups 不仅用来管理顶点的分组，同时还记录分组内的顶点的权重数据。
同一个顶点可以归属于不同顶点组，并且记录不同的权重值，记录顶点权重值就是顶点组的意义。

权重绘制是一种非常直观的方式，用来记录大量顶点权重信息。在权重绘制模式下，必定选择一个顶点组
进行权重刷制。顶点用不同的颜色来表示不同的权重，从 0 到 1，颜色对应蓝、青、绿、黄、红。顶点颜色
可视化表明了它在活动顶点组中所记录的权重数据。默认情况下，蓝色表示未加权，红色表示完全加权。

通过使用权重笔刷在其上绘制，可以为物体的点指定权重。开始在笔画上绘画会自动向活动顶点组添加权重，
如果需要，可以创建新的顶点组。设置弱一点的 Strength 属性，可以慢慢地将顶点权重刷成指定值。
在刷权重的过程中，有数值变化的顶点会自动添加当前的活动顶点组中。

权重数据有多使用场合，典型的就是使用骨骼动画系统时，将模型的顶点组与某块骨骼关联起来，那么
骨骼就会根据顶点组中记录的权重数据，按权重记录的比率值控制顶点的运动。

和权重有关的蜡笔修改器：
https://docs.blender.org/manual/en/latest/grease_pencil/modifiers/index.html
Vertex Weight Proximity Modifier 教程 https://www.bilibili.com/video/BV1bU4y147Pu/

	01. Armature Modifier
	02. Vertex Weight Angle 修改器基于预定角度设定顶点组的权重，Angle 对应最大权重的角度。
	03. Vertex Weight Proximity 根据蜡笔对象顶点与目标之间的距离设定顶点组内的顶点权重。

Vertex Weight Proximity 修改器中的 Lowest 和 Highest 代表最小权重、最大权重对应的距离。
几何体也有此修改器，参数有些不同，可以设置邻近模式：Proximity Mode。
物体距离模式：使用修改后的网格物体和目标物体之间的距离作为受影响顶点组中所有顶点的权重。
几何距离模式：使用每个顶点与目标物体或其几何体之间的距离。

而蜡笔对象的 Vertex Weight Proximity 修改器多了 Influence Filters 参数，这是蜡笔对象
的修改器通用属性，用于约束修改器作用的目标，如蜡笔图层、材质、顶点组、自定义曲线。默认不用设置，
修改器作用于蜡笔对象的所有笔迹。如果设置了条件，所有过滤器条件值同时满足的目标才会受修改器影响。

蜡笔对象绑定骨骼与几何体绑定骨骼操作相同，首先，添加一个**Armature**对象，然后添加骨骼块
以及构成合适的骨架。注意各个骨骼的名称，在给蜡笔对象创建顶点组时，骨骼只影响和它同名的顶点组。
然后给蜡笔对象添加一个**Armature**修改器，并设置其 Object 属性为前面添加的骨架对象。另外，
可以指定 Vertex Group 属性，以明确哪些顶点会受骨架的影响。

绑定骨架后，就要刷顶点权重，可以先选择好骨架，再按住 Shift 加选网格体，然后进入权重绘制模式。
使用笔刷绘制权重时，就会自动给模型添加顶点组，并顶点组名称与当前活动的骨骼同名。

与几何体权重绘制模式不同，蜡笔对象的权重绘制模式没有提供 Masking 和顶点选择功能，绘制复杂的
蜡笔对象可能处理起来有点麻烦，可以考虑预先手工分配顶点组及权重，然后再绘制权重，减弱或增强它。




## 👉 Freestyle Line-Arts
1. Freestyle Rendering https://docs.blender.org/manual/en/latest/render/freestyle/index.html
2. [Blender 2.82 Freestyle API](https://docs.blender.org/api/2.82/freestyle.html)
3. [Blender NPR - Freestyle Level Up](https://www.bilibili.com/video/BV11t411e74e)
4. 来几个freestyle花式线稿 https://www.bilibili.com/video/BV1sE411F7zB
5. 卡通渲染 https://www.bilibili.com/video/BV1VW411E7XQ/

Freestyle 渲染引擎是基于边线的非真实感绘制技术 NPR - Non-Photorealistic Rendering，
可以结合卡通着色器节点 Toon BSDF 渲染成动画输出。NPR 也叫艺术渲染，将模型渲染成插图或
动画镜头就是一种应用方向。

Blender 使用 Compositor 来合成卡通渲染，简化步骤：

1. 亮面、暗面提取：设置 View Layer 属性面板，勾选 Passes 直通选项下的 Diffuse Color 和 Shadow 为合成器的 Render Layers 打开漫反射光和阴影图层，这样就可以对模型的光面和暗面进行后续处理。
2. 线稿提取：在渲染属性面板为复制的图层打开 Render -> Freestyle 功能。然后勾选图层面板中的 As Render Pass 以生成线稿供合成器使用，透明线稿的图像就在 Freestyle 端口输出，另外还要勾选上 Culling 以将背部线条剔除。
3. 线稿设置：图层启用 Freestyle 渲染方式后，就可以在图层面板中对线稿进行配置。

在 Compositor 中使用 Viewer 节点预览图层输出内容，将 DiffCol 端口连接到 Viewer -> Image 
端口查看物体漫反射颜色信息，按 F12 渲染以生成各种图层。

添加 Mix 节点，将亮面和暗面混合起来，使用 Multiply 即正片叠底模式，调整一下 Fac 系数，使暗面
有一个合适亮度。合成的图像和线稿图层输出的 Freestyle 通过 Alpha Over 节点叠加起来，将线稿
叠在其它图像的上面。

虽然，Culling 可以将背部大量线条剔除，但是还是会有少量线条在特定的角度中会出现部分遮挡的情况，
这时线条被遮挡的部分就会跑出来，需要里进行细致的调整。一般只要打开 Visibility -> Visible 
可见性条件即可以解决这类问题。还可以使用 Passes -> Data -> Z 深度数据来处理，在 Render Layers 
节点的 Depth 端口输出深度数据。

Freestyle 渲染功能打开后，还可以在图层属性面板中使用 Filter 来选择要输出什么内容，例如，
Filter -> Freestyle 勾选后只输出线稿，而不渲染输出模型的面。

Render: Freestyle SVG Exporter 内置插件还可以导出线稿为 SVG 文件，启用插件后，
在渲染属性面板勾选 Freestyle SVG Export，然后在视图层属性面板找 SVG Exporter 面板设置。

默认图层只有 View Layer，可以复制两个分别用于亮面、暗的线稿的渲染。

在编辑模式下，和 Freestyle 有关的菜单项：

- Edge -> Edge Crease 边线折痕 介于 0.0 到 1.0 之间的值，用于 Freestyle 线稿渲染。
- Edge -> Mark Freestyle Edge 将选中的边线标记为 Freestyle 线稿的线条。
- Edge -> Clear Freestyle Edge 清除线稿标记。

标记过的线条会处于绿色高亮的状态中，在图层属性面板中，勾选 Freestyle Line Set 下的 Edge Type -> Edge Mark 即可以渲染输出已经标记的线条。这种手动标记线条的方式，和绘画中创建线稿的方式差别非常大。

图层启用 Freestyle 渲染方式后，会默认添加 LineSet 线条集，每个线条集设置的是线条检测参数，对匹配的线条应用 Freestyle Line Style 配置的样式进行渲染。可以设置多套线条集，配置好选择过滤条件，还有线条的渲染样式。

默认的 Edge Types 设置：

- Edge Crease 折痕，模型面相交的边线，两个面的夹角是检测中用到的重要参数。
- Silhouette 物体内部轮廓。
- Border 边界线。

使用 Inclusive + Logical OR 检测条件，即包含所有 Edge Types 列表中勾选的边线类型，只要被检测的连线满足其中一种类型即可。

Edge Types 下的边线类型选项分为两列，左边为边线类型，每种类型右侧有个专用的排除按钮。并且提供两组按钮，左边可以选择 Inclusive 或 Exclusive 来包含或排除那些经过 Logical Or 或 Logical And 运算得到的边线，这就像是一个真值表。

例如，场景中的对象有 Silhouette 和 Contour 两种边线，也有一条标记边线 Edge Mark。在 LineSet 配置中，勾选这三种边线。

如果选择 Logical And 运算，那么只有这三种线在同一条边重复才是逻辑真，那么选中的就是这个同属于 Silhoutte/Contour/Edge Mark 的边线。

如果选中 Logical Or 对这三者进行运算，结果就是这三种边线的并集。而每种边线类型的右侧的排除按钮，就相当一个 Logical Not，只对此边线类型进行求补集。


Freestyle 根据网格和深度 Z-depth 信息在选择的边缘绘画，可以定义各种线条样式一模拟手绘效果。

列如，设置线稿风格的 Thickness，添加一个 Along Stroke 修改器，即沿着线条的方向进行修改，使用 Multiply 混合模式，并且使用 Curve 映射方式，然后调整曲线来控制线稿的大小随着线条的方向进行变化。还可以再添加 Noise 修改器，给线条粗细增加随机效果。

要使用 Freestyle 渲染，在渲染引擎属性面板激活 Properties ‣ Render ‣ Freestyle。然后所有 Freestyle 设置都会出现在视图层属性面板，Freestyle Line Set/Style 等。

每个视图层有且只有一个视图映射，它可以包含多个线条集 Line Set，也保存边缘检测设置，如 Crease Angle, Culling toggle, Face Smoothness toggle, Material Boundaries toggle, Sphere Radius, Kr Derivative Epsilon 高级选项等。

Freestyle 通过线条样式定义的颜色、Alpha、粗细等对关联的线条集进行渲染。每一线条使用一个线条样式定义，每个样式定义可以在不同的线条集中使用。一个线条集 Line Set 定义用于渲染的线条类型和线条选项，用于探测和匹配场景中的线条。

启用 Freestyle 渲染：Properties ‣ Render ‣ Freestyle，通过面板 View Layer properties 设置 Freestyle 选项。

工作流程：

- 开始 3D 场景；
- 应用渲染层选项 *Render Layer Options* 进行特征边缘探测；
- 生成包含特征边的视图映射 View map；
- 应用线条集选项 *Line Set Options* 进行挑选，连结和分割；
- 连结特征边；
- 应用线条样式选项 *Line Style Options* 进行样式处理；
- 生成绘画笔触；
- 应用渲染选项 *Render Options* 渲染笔触；
- 输出 2D 线条画。


已知的局限性

- 高内存消耗，一次加载视图层的网格对象；
- 只支持面向网格对象；
- 面与面相交出无法检测到边缘；
- Freestyle 渲染结构不含 Z depth 深度信息；
- 不支持全景相机。


View Map Cache 选项用于重用先前计算的视图映射，以供后续渲染。当输入三维场景的网格几何结构被改变时，缓存将自动更新。此功能提供了一个主要的性能提升，就是在 Freestyle 的动画渲染时，当相机空间网格的几何结构是静态的，如同重复，则依然以直线化选项进行渲染。



## 👉 Edge Dectection 线条检测

要正确选择需要渲染的线稿，线条检测必须准确识别。Freestyle 检测到特征边缘后，就经过 Line Set 设定的条件进行选择过滤，最终对选出的线条进行绘制成稿。这里涉及的选择运算主要是集合论的方法，对各种集合进行 Logical Not/Or/And 运算。

控制方式 Control Method 用于检测实际上已渲染的边缘，并且将从头到尾地执行控制，有两种方式：

- Python 脚本方式，复杂但强大；
- 参数编辑器方式，简单但局限；

选择脚本方式，可以在 Style modules 中加载多个样式脚本。Blender 自带 Japanese big brush, cartoon, blueprint, thickness-with-depth 等等实现，在安装目录中：

	\scripts\freestyle\styles

编写一个样式模块涉及 Python 脚本编程，需要参考 Blender API 文档，以下是编写样式模块的 5 中操作：

- Selection Operators.select()
- Chaining Operators.chain(), Operators.bidirectional_chain()
- Splitting Operators.sequential_split(), Operators.recursive_split()
- Sorting Operators.sort()
- Stroke creation Operators.create()

模块输入是检测到的特征边缘，即包含 ViewEdge 的 ViewMap，模块输出是样式化的线条，也叫笔触 Strokes，模块以流水线方式对输入的边缘进行处理。

Selection 操作根据用户定义从 ViewMap 挑选 ViewEdge，根据用户定义再对 ViewEdge 的子集进行 Chaining 连结，可以后续分割再连结。挑选的边缘连结后再排序 Sorting，这个决定了哪条线在上，哪条线在下，最后应用样式创建笔触，并输出。

ViewEdges, Chains 和 Strokes 都是一维元素 1D，可以是多条相连的线段 polyline，连结的顶点则是零维 0D。


视图层属性面板中，View Layer ‣ Freestyle 提供的设置，除了设置探测控制方式 Control Method 外，还有一些检测相关选项：

- View Map Cache

	沟线以重用先前计算的视图映射，以供后续渲染。当输入三维场景的网格几何结构被改变时，缓存将自动更新。

	此功能提供了一个主要的性能提升，就是在 Freestyle 的动画渲染时，且相机空间网格的几何结构是静态的如同重复，则依然以直线化选项进行渲染。

	尽管 View Map Cache 是在视图层属性面板设置的，但是缓存供所有场景使用，因此在不同场景的更新都是更新同一个缓存。

- As Render Pass 直通渲染

	这是 2.83 版本新增功能，用来直接生成透明线稿，渲染结果却看不到线稿。此时，通过合成编辑器 Compositor 就可以查看，点击 Use Nodes 激活合成器的节点，注意 Render Layers 节点有个 Freestyle 输出端口，透明线稿的图像就在这里输出。可以添加一个 Viewer 输出节点，连接上 Freestyle 输出即可看到线稿图像。

	如果使用 Cycles 渲染引擎，还可以在视图层属性面板中设置过滤器 Filter，只勾选 Freestyle 就可以输出不含有其它内容的线稿。配合 Cycles 引擎属性面板中的 Film - Transparent 选项可以输出透明底的线稿。

- Face Smoothness 勾选以在计数边缘是考虑面平滑着色

- Crease Angle 

	折痕夹角阈值，如果两个相邻的面形成的夹角小于指定阈值，则表示可以选中进行渲染，在线集 Line Set 中定义的边缘类型选择匹配时将呈现两面夹角的的边缘，该值也影响轮廓边缘类型选择。

- Culling 背面剔除

	忽略视图之外的边，以节省硬件资源，但某些情况可能会导致结果质量下降。

- Advanced Options 高级选项

	- Sphere Radius 球体半径

		对脊线/沟线/外形暗示的曲率计算有影响，曲线每个顶点上的曲率会按指定的球体半径平均化，增大半径可以减少噪点提高细节。

- KR Derivative Epsilon 极小 Kr 导数

	对用来挑选外形暗示边缘 Suggestive Contour 的曲率变化率进行控制，增大值会从平滑区开始减少渲染线条。



视图层属性面板中，Freestyle Line Set 包含了 Line Set 线条集，每个线条集设置的是线条检测参数，在 Selection By 展示的选择方式有五类。点击变成高亮的蓝色表示这一组选择条件得到的结果有效，这些生效的选择方式得到选择结果还要进行 Logical And 运算，最后汇总得到结果：

- Visibility

	通过可见性选择渲染，可见或不可见，或通过 QI Range 指定遮挡边缘的面数量在指定范围的边线，QI 为量化隐性 Quantitative Invisibility。

- Edge Types 通过边线类型选择；

- Face Marks

	通过标记边线选择，选择 Inclusive 或 Exclusive 以包含或排除满足 One Face 或 Two Faces 条件的边线。One Face 表示匹配那些单个或两个相邻面作标记的边线，Both Faces 匹配那些相邻的双面都作标记的边线。

	要标记面，在编辑模式中执行菜单 Face - Face Data - Mark Freestyle Face。

	以一个 Cube 为例，将相邻的两个面标记，那么满足 One Face 的边就有七条，两个面 8 条边，减去其中公共边一条。满足 Two Faces 条件的就只有这条公共边，如果标记三个相邻面，那么，满足 Two Faces 条件的有三条了。

- Collection 通过指定集合来选择，可以先包含或排除指定集合；
- Image Border 通过图像边界选择；


边条类型 Edge Types 中分为两类展示各种边线类型：

- Silhouette 轮廓线

	物体内部轮廓线由物体的各边线构成。

- Border 网格边界

	网格边界是物体分隔内外部空间的线条，是区分那些区域属于此对象的重要依据，国界就是 Border 这个词。比如，一个空心圆的面，边界线有两条，一条是圆周线，另一条是内部空心的圆周线。

- Contour 外形轮廓

	外形轮廓，相比 Silhouette 轮廓线，外形只关注物体在视角上投影的轮廓，不含物体的其它边线。

- Ridge & Valle 脊线&沟线

	脊线和沟线曾经是两种线，Concave & Convex，后来改进后是根据物体边线曲率 Curvature 的变化推断的同一种线条。

- Suggestive Contour 外形暗示

	外形暗示是非常有用，它是视角上形成的边线，比如看面前的台阶，注意和眼睛高度差不多的那一级就像是一条线，这就视觉暗示作用。

- External Contour 重叠外形

	物体有外形，当两个物体在某个视角处于重叠时，两者的外形也重叠，这个重叠的外形的轮廓就是重叠外形。

- Crease 折痕

	Crease 折痕，模型面相交的边线，两个面的夹角是检测中用到的重要参数。

- Edge Mark 标记边线

	用边线标记明显的物体外形，在模型编辑模式下，通过右键菜单标记选择的边 Mark Freestyle Line，再到 Freestyle Line Set 属性面板中设置需要渲染标记边线，Face Marks - Inclusive，还 /Both Faces，再渲染即可以看到标记线输出。

- Material Boundaries 材质边界

	材质边界线是物体上两种材质相交的位置形成的一条边界。



## 👉 Freestyle Line Style 

Line Set 设置的边线检测参数决定了场景中那些线条需要渲染，Line Style 的设置决定了线条会渲染成什么样子，什么颜色。

渲染引擎属性面板 Freestyle 中又两个选项设置渲染线条的粗细：

- Line Thickness Mode 模式设置
	- Absolute 绝对模式
	- Relative 相对模式
- Line Thickness 线条粗细，指定绝对像素大小。

在相对模式下，线条会进行缩放，480P 垂直分辨率时为 1x，720P 垂直分辨率就为 1.5x，960P 垂直分辨率就为 2x。


材质属性面板种提供两个选项设置，Properties ‣ Material ‣ Freestyle Line：

- Line Color 为材质指定线条颜色；
- Priority 指定在材质边界 Material Boundaries 比较线条色彩时的优先级；


视图层属性面板 Freestyle Line Style 提供了六类样属性设置：

- Strokes 基本笔触设置，如连笔、断笔、前后排序、封线口等；
- Color 设置线条底色和修改器；
- Alpha 笔触透明控制；
- Thickness 对笔触的粗细及位置等进行控制，笔触可以描在边线的中心、内则、外侧或相对位置；
- Geometry 笔触几何修改；
- Texture 设置笔触纹理；



Color/Alpha/Thickness 三种属性基本共用了一套修改器，利用属性映射关系产生颜色变化、透明度变换、粗细变化效果：

- Along Stroke 顺行修改器
- Crease Angle 折痕角度
- Curvature 3D 曲率 3D
- Distance from Camera 到相机距离
- Distance from Object 到对象距离
- Material 材质修改器
- Noise 噪波修改器
- Tangent 正切修改器
- Calligraphy 书法修改器 Thickness 专用


以 Distance from Camera/Object 修改器为例，它们可以从物体到相机或物体位置的距离作为一个映射值，并设置到修改的对象上。

添加 Distance from Camera 修改器，适当调整参数：

- Range Min 物体到相机的最小距离，比如 10m；
- Range Max 物体到相机最大的距离，比如 15m；

或者选中对象后，直接按 Fill Range by Selection 按钮，它会自动检测对象远端和近端到相机的距离并自动填入。

比如设置底色，这两个距离映射为色带上的颜色，物体对应距离的颜色就在色带对应位置上；又如设置 Alpha 透明通道，这两个值的范围就映射为 0 - 255 的 Alpha 值设置到物体相应距离的位置上。设置粗细度，这两个距离映射为对应的 Value Min/Max，距离远的就是 Value Max 指定的粗细，距离近的笔画就是 Value Min 中指定的粗细度，Value Min 指定的值可以大于 Value Max 的值。


材质修改器这个很特别，可以将物体材质的各种属性数据映射到笔触上，根据材质的设置可以得到非常丰富的效果。
设置了笔触选项 Split by Material，在各材质间就不会有模糊效果。


几何体修改使用的是另一套修改器；

- 2D Offset 二维偏移
- 3D Transform 三维变换
- Backbone Stretcher 骨架伸展
- Guiding Lines 引导线
- Perlin Noise 1D 一维柏林噪波
- Perlin Noise 2D 二维柏林噪波
- Polygonization 多边化
- Sampling 采样修改器
- Simplification 简化修改器
- Sinus Displacement 凹槽置换修改器
- Spatial Noise 立体噪波
- Tip Remover 拔梢器 







# 🚩 Animation 动画

Shape Keys 形态键与音波动画 https://www.bilibili.com/video/av78957420

视频教程使用了插件 Import Sound to Animation Addon 将声波转换为曲线，需要用 Blender 2.82，才会有测试版的插件。

Blender 如何修改已调整过的模型，比如给一个场景内的圆添加边数，

Blender 动画使物体随时间移动或改变形态，物体可以通过多种方式动画化：

- 作为一个整体移动 随时间变化，改变物体的位置，方向，或尺寸;
- 形变物体 动画化它们的顶点或控制点;
- 继承的动画 使一个物体随着另一个物体的移动而移动(例如，父物体，挂勾， 骨架，等等)。

骨架通常与修改器一起形变网格用于角色动画。可以使用摄像机绑定来代替动画化摄像机物体来直接模拟真实世界的摄像机装备 (例如，悬臂装在旋转底座上，也可以添加摄像机抖动等效果)。

对于不同的状态，属性有不同的颜色和菜单项。

- Gray		灰色 没有动画化
- Yellow 	黄色 当前帧是关键帧
- Green 	绿色 当前帧不是关键帧
- Orange 	橙色 从关键帧值改变
- Purple 	紫色 由驱动器控制

绑定经常涉及使用到以下一个或多个功能：

- Armatures		骨架 这允许网格物体象具有灵活的关节，经常用于骨骼动画。
- Constraints	约束 控制各种有意义的运动类型并为绑定添加功能。
- Modifiers		物体修改器 网格形变可以相当复杂，有多个修改器可以帮助控制复杂度。
- Shape Keys	形态键 支持不同的目标形态 (如面部表情) 进行控制。
- Drivers		驱动器 因此，你的绑定可以一次控制许多不同的值，并根据其他地方的变化自动更新一些属性。



## 👉 Timeline/Keyframe 关键帧动画
- https://docs.blender.org/manual/en/latest/editors/timeline.html
- Dope Sheet https://docs.blender.org/manual/en/latest/editors/dope_sheet/index.html

关键帧 Keyframe 是一种在动画帧上记录属性数据的一种产生动画的方式，每个对象都可以设置其属性的数据到关键帧上保存。那些支持关键帧的属性会在右边有个白色小圆点编辑，点击它就可以在当前帧的位置记录一个关键帧，并且小圆点会变成菱形。

使用时间轴 Timeline 或摄影表 Dope Sheet 可以管理模型对象动画关键帧，关键帧只是存储对象属性值的时间标记。

摄影表 Dope Sheet 可以为动画师提供场景内关键帧的鸟瞰视图，摄影表来源于经典的手绘动画过程，称为曝光表或摄影表。在这一过程中，动画师将使用图表，精确显示每次绘图、声音和相机移动的时间以及持续时间。虽然 CG 基础与经典手绘动画有着显著的不同，但 Blender 的摄影表继承了类似的指令。摄影表 Dope Sheet Mode 通过选择不同的关键可以一次编辑多个动作。

Dope Sheet/Timeline 动画视图快捷键：

	- I 插入关键帧。
	- Alt-I 清除关键帧。
	- Shift-Alt-I 清除所有关键帧(移除所有F-曲线)。
	- Ctrl-D 添加驱动。
	- Ctrl-Alt-D 清除驱动。
	- K 添加插帧集。
	- Alt-K 清除插帧集。

例如，关键帧可以定义一个立方体的水平位置在第 1 帧上是 3 米。关键帧的目的是允许内插动画，这意味着，例如，用户可以在第10帧上添加另一个关键帧，指定立方体的水平位置在20米处，Blender将根据所选择的插值方法(例如，线性，贝塞尔曲线，二次曲线等)自动确定帧 1 和帧 10 之间的所有帧中立方体的正确位置。

关键帧插值 Interpolation 通过 动画函数曲线 来表示和控制，也称为 函数曲线. 可以通过 曲线编辑器 Graph Editor 查看和修改这些曲线。

注意，只是单纯视觉上而非功能上，区分常规关键帧类型和其他不同的动画事件或状态(极端，间断或其他中间状态)，可以在它们上应用不同的颜色以进行可视化，快捷键 R。

1. **Keyframe**  (白/黄色菱形) 常规关键帧。
2. **Breakdown** (青色小菱形) 间断状态，如用于不同关键姿态间的过渡。
3. **Move Hold** (深灰色/橙色菱形) 惯性延续，一个可以在一个保持姿势附近添加少量动作的关键帧。 在动画摄影表中，它还会在它们之间显示一个条块。
4. **Extreme** (红色大菱形) 极端状态，或者其他需要的用途。
5. **Jitter** (绿色小菱形) 抖动，填充或烘焙关键帧，用于在其他帧上插帧，或用于其他所需目的。

对于 Move Hold 关键帧，如果连续出现，在 Timeline 中会显示一条黄色色带，两个 Move Hold 关键帧之间的都是可以删除的，并不影响动画效果，因为动作一起在两端的关键帧之间持续。

有多种方法可以插入关键帧:

- 在 3D View 视图，按下 I 将弹出菜单，选择需要插入的类型，位置 Location、 旋转 Rotation、缩放 Scale，或三者都选 LocRotScale 等。
- 在 Timeline 或 Dope Sheep 视图，按下 I 将弹出菜单，选择需要插入的类型，时间轴中的关键帧是以通道 Channel 组织对象属性的，可以选择需要记录的通道
	- All Channels 记录关键帧中所有属性通道
	- Only Selected Channels 只记录选中的关键帧属性通道
	- In Active Group 记录活动的通道分组，比如选中坐标变换分组 Object Transforms，那么插入关键帧就只记录这个分组的属性通道
- 将鼠标悬停在属性/对象上并按 I 或通过 RMB 点击下文菜单中选择 插入关键帧，或者右键菜单中插入单个属性关键帧 Insert Single Keyframe。
- 自动关键帧，时间轴 标题栏中的记录按钮可以打开自动关键帧记录，会自动将变换类型属性的值发生的变化记录到设定的帧。

关键帧插值通过动画函数曲线来表示和控制，也称为函数曲线。选定关键帧，快捷键 T 弹出插值函数列表 Interpolation Mode，插帧效果就按列表中指定的曲线函数进行计算得到，函数曲线可以通过曲线编辑器 Graphic Editor 查看和修改。曲线的 X 轴对应于时间，而 Y 代表属性的值。 关键帧本身定义曲线的控制点，而插值由附加参数控制。

关键帧备选曲线列表：

- Interpolation 插值
	- Constant 常数
	- Linear 直线
	- Bezier 贝塞尔平滑曲线
- Easing by strength 缓动曲线
	- Sinusoidal 正弦曲线
	- Quadratic 二次函数曲线
	- Cubic 三次函数曲线
	- Quartic 四次函数曲线
	- Quintic 五次函数曲线
	- Exponential 指数函数曲线
	- Circular 圆环曲线
- Dynamic Effects 动态效果
	- Back 回退预备效果
	- Bounce 回弹效果
	- Elastic 弹力效果

同时可以 V 弹出 Handle Type 来给关键帧指定控制柄的类型。

- 圆形(默认)		Auto Clamp 自动钳制控制柄
- 带点的圆		Automatic 自动控制柄
- 正方形			Vector 矢量控制柄
- 修剪过的菱形	Aligned 对齐控制柄
- 锐菱形			Free 自由控制柄

关键帧只是制作动画的一种传统方式，有时候显得不够灵活。比如，让物体旋转越来越快，只需要设置 Exponential 指数函数曲线即可。但是，要旋转动画越来越慢就不好办了，需要一点点细调关键帧，这是强大的曲线编辑器 Graph Editor 上场了。

设置 Playback Sync 同步方式为 Frame Dropping 或 Sync to Audio 可以保证播放速度，而不像 Play Every Frame 那样逐帧播放，即使有延迟也不跳过。

## 👉 Keying Sets 插帧集

插帧集 Keying Set 是一个属性集合，用于记录同一时刻的多个属性。 当在 3D View 视图中按下 I 时，Blender 会将活动插帧集里的所有属性值添加到关键帧。

要选择和使用插帧集，请在时间线标题栏中设置 插帧弹出面板 Keying 中的 活动插帧集 Active Keying Set，或在 3D 视图中按 Shift-Ctrl-Alt-I，弹出的活动插帧集菜单中设置。

有内置插帧集 Built-in Keying Sets，如 RotScale 插帧集只记录旋转和缩放 Rotation & Scale，而 Available 则记录所有有效属性，通过选择当前前使用的插帧集就可以在插入关键帧时记录对应的属性数据：

- Available				记录所有有效属性
- BBone Shape			记录双足动物骨架形态 Biped Bone Shape
- Delta Location		记录增量
- Delta Rotation		记录增量
- Delta Scale			记录增量
- Location				记录位置
- LocRot				记录位置、旋转
- LocRotScale			记录位置、旋转、缩放
- LocScale				记录位置、缩放
- Rotation				记录旋转
- RotScale				记录旋转、缩放
- Scaling				记录缩放
- Visual Location		
- Visual LocRot			
- Visual LocRotScale	
- Visual LocScale		
- Visual Rotation		
- Visual RotScale		
- Visual Scaling		
- Whole Character		
- Whole Character (Selected bones only) 


可以自定义插帧集，称为 绝对插帧集 Absolute Keying Sets，属性编辑器中的场景面板 Properties - Scene - Keying Sets 可以进行自定义插帧集管理，也可以为绝对插帧集添加相关的对象属性路径。属性路径用来帮助 Blender 定位用于计算关键帧插值的数据，插帧集设置好属性路径后才能记录关键帧。

- Target 目标
	- Target ID-Block 用于指定 ID 类型和物体 ID 的数据路径
	- Data Path 数据路径 设置属性的数据路径余下的部分，通常时属性名，注意旋转属性的路径是 rotation_euler 不是 rotation
	- Array All Items 陈列全部项或者指定索引号，比如 3D 位置、 旋转、 缩放等 x、 y、 z 对应的索引是 0、 1、 2
- F-Curve Grouping 函数曲线群组方法，控制添加通道到的群组，插帧集名称 Keying Set Name、 无 None、 命名组 Named Group

给插帧集中添加属性的几种方法：

- 在对象数据属性面板 Object Properties 中 RMB 单击属性，选择 添加单项到插帧集 Add Single to Keying Set 或 添加多项到插帧集 Add All to Keying Set ，会自动创建插帧集如果不存在。
- 鼠标在属性上方悬停，按 K，将 添加多项到插帧集，Alt-K 移除。


插入关键帧设置 Keyframing Settings 提供选项控制如何处理插帧集中的属性值：

- Needed 仅必要 仅在相关函数曲线中需要的位置插入关键帧。
- Visual 可视化插帧 基于可视变换插入关键帧。
- XYZ to RGB 对于新的函数曲线，将属性集合如位置 XYZ 的颜色设置为 RGB。


## 👉 Actions 动作

在 Blender 中动画化物体和属性时，动作数据块将会记录和保存动画相关数据。和 Blender 中其它概念类似，动作是以数据块形式存储的。使用动作来管理动画关键帧，是为非线性动画编辑功能考虑的，将动作片段化，可以在 NLA 编辑器中以非线性的方式任意组合动画。

当通过使用关键帧、或曲线编辑器设置物体动画时，动画数据会被储存到动作中，这些动作数据可以在 NLA 中进行再组合。

动画中每个属性在时间轴视图都有一个对应的记录通道，例如， Cube.location.x 记录到 X 通道位置上。如果多个物体都有 X 轴位置 和 Y 轴位置 属性，那么这些属性可以在这些物体间共享：

- Actions 动作 记录和保存动画数据。
- Groups 组 通道群组。
- Channels 通道 记录单一属性。
- F-Curves 函数曲线 函数曲线 用于对关键帧间的变化进行插值。
- Keyframes 关键帧 关键帧 用于设置绑定到某个时间点上的属性值。

当您第一次通过添加关键帧动画化一个物体时，Blender 为该数据创建一个动作 Action 对象来记录这些数据。

动作可以使用动画摄影表的动作编辑器 Dope Sheet - Action Editor 标题栏上的动作数据块面板管理，还有 NLA 编辑器的 Animation Data 属性栏中也提供了动作数据块面板，可以管理。

动作数据块面板主要是一个列表，里面有场景内现有的动作记录。从动作数据块面板选中要编辑的动作时，其记录的关键帧信息就会复原到 Timeline/Dope Sheet 编辑器的轨道上。同时可以在动作数据块面板上重命名动作。

物体在同一时间只能编辑一个动作数据块。 NLA 编辑器 用于将多个动作数据混合在一起。

对于没有被引用过，即没有使用过的动作对象，列表中的名字会有一个 0 前缀着。这个标记使用次数为 0 的动作在保存文件时，就会被忽略，这个动作也就算是被删除了。

动作名称右侧的数字表示当前动作被引用的次数，还有一个盾牌按钮 Fake User，表示即使动作对象没有被使用过，也可激活一个伪引用，这样可以确保动作不被删除。

而删除按钮也不是删除动作，而是将动作从当前的激活编辑状态撤下来。点击删除按钮时，Timeline 编辑器上的关键帧就会清除，随动作对象撤下来，但动画数据还保留在数据堆栈。

Action Editor 标题栏中有两个和 NLA 非线性便器器相关的按钮，制作动作片段 Push Down 和暂存动作 Stash，将当前的动作转换成动作片段后就可以使非线性编辑器来制作动画。暂存按钮 Stash 会将当前动作存放的 NLA 非线性编辑器的数据堆栈中并在 NLA 编辑器中设置一条 [Action Stash] 轨道来临时存放动作关联的片段 Action Strip。

通过菜单 3D 视图，物体或姿态模式提供的烘焙动作功能，可用于在关键帧之间应用插值帧，这可以为循环动作，比如 行走循环 ，添加变化。这对于通过驱动或约束制作的关键帧动画也很有用。 Object 或 Pose 菜单下找 Animation - Bake Actions。




## 👉 Nonlinear Animation 非线性动画
- Nonlinear Animation https://docs.blender.org/manual/en/latest/editors/nla/index.html
- Nonlinear Animation using Mixamo https://www.bilibili.com/video/BV1h5411J7UC?p=3

Blender 提供了 NAL - Non-Linear Animation 非线性动画编辑器，所谓非线性动画就是动画不同关键帧之间那样，比如位移关键帧动画，物体的位移是连续变化的，也就是线性动画。而非线性动画，则可以将对象的各个动画片段进行组合，而不必受线性关系约束。

一个对象的 Timeline 编辑好的一组动画关键帧可以转换为 Nonlinear Animation 中的一个动画块，并且非线性动画中可以使用任意个动画片段 Action Strip。选中状态下的动画片段可以切换为静音状态 Toggle Muting，这样使用相应的动画不起作用，或者整个轨道禁用，动画片段周边会出现虚线。

每个对象的 Timeline 关键帧动画在 NLA 视图中都有一条 Timeline 轨道。在这条轨道名称右侧，有一个 Push Down Action 按钮，它可以将 Timeline 上现有的关键帧打包为 Action Strip，并且放置到标准的 NLA 轨道上。可以对其进行非线线的排列，可以切割再分段、时间缩放等操作，并且可以再次进行关键帧修改，如果需要。

在大纲视图 Outline 可以看到对象内部同时包含 Timeline 和 NLA 动画的差别，使用不同的图标表示。

Adobe 开发了 Mixamo 动画绑定插件，并且在官网上提供了动画库，可以直接下载模型动画。

通过 Edit 菜单将 Action Strip 发回 Timelne 视图再细调：

- Start Tweaking Strip Actions *Tab* ；
- Start Editing Stashed Action *Shift-Tab* ;

Editing Stashed 进入调整模式，与 Tweaking 方式类似，但确保动作可以单独编辑（通过将动作条来自的 NLA 轨迹标记为 Solo 状态。这对于编辑隐藏的操作非常有用，而不会干扰 NLA 堆栈的其余部分。

注意，NLA 编辑器中的操作不能通过 Undo 来撤消，如果这样做，将会丢失大量动画设置。

对于同一个对象，多个 Action Strip 包含相同的关键帧数据，即使时间上没有重叠，轨道排列在上面的就会覆盖掉排在下层的。除非在侧栏属性面板设置 Edited Action -> Blending 混合模式，默认为 Replace 模式。

NLA 侧栏面板提供了片段属性设置功能，快捷键 N 打开。Strip 属性面板提供动画片断属性的修改，Edited Action 动作数据块菜单，允许你复原动画片断数据到 Timeline 上再次编辑，或者点击 + New 新建一个动作对象。

注意，删除掉的动画片段还保留在 Blend 文件中，除非执行了 File -> Clean Up 清理数据，它们才会永久删除。

Action Blending 的混合模式影响其属性值如何与轨道堆栈下的其它动作片段如果求值，最底层的片段会基于上层的值进行混合。

- Replace 代替模式，根据 Influence 的百分比混合顶层片段与下层片段，累积结果为线性混合，100% 则完全覆盖下层片段。
- Multiply, Subtract, Add 运算模式，可以用公式表达 `result = mix(previous, previous (+-*) value, influence)`
- Combine 模式根据属性类型，自动选择以下方法之一：
	- Axis/Angle Rotation `result = previous + value * influence`
	- Quaternion Rotation `result = {previous} \times {value} ^ {influence}`
	- Proportional (Scale) `result = previous * (value / default) ^ {influence}`
	- Others `result = previous + (value - default) * {influence}`

如果动画片段连接有间隔，可能出现意外的动画效果，使用 Extrapolation 进行推断补间以避免意外：

- Nothing 默认值，什么也不管，可能出现对象位置错乱；
- Hold 表示在间隙期间保留上一个动画片段的结束状态；
- Hold Forward 表示后面的动画片段结束后，还回到当前这个片段的结束状态。

试试 Non-Linear Animation Editor

- 添加 Cube 立方体，保持选中状态，在第 1 帧位置按 I 插入关键帧，选择 LocRotScale 记录位移、旋转、缩放属性的关键帧。
- 在第 100 帧位置，移动对象或进行缩放旋转等，再添加关键帧，这时就设置好一个关键帧动画了，对象是线性的动画变化。
- Blender 的动画是以动作片断数据的方式管理的，以上的关键帧动画就会产生一个 CubeAction，可以在 Timeline、Dope Sheet 编辑器查看。
- 打开 NLA 编辑器，列表中也可以看到当前场景存在的 Action 对象。
- 接下来需要将 Action 对象转换成动片段对象 Action Strip，然后就可以进行非线性编辑了。
- 单击 CubeAction 对象右侧的 Push Down Action 下推动作按钮将动作对象转换成动画片段对象。
- 注意，转换后原有的关键帧动画就不存在了，可以使用 Editing Stashed Action 工具复原编辑。
- 再编辑一段关键帧动画，转换成动画片段后，就有两个动画片段了，通过调整这俩个片段的所在轨道的位置，动画就以不同的方式组合，这也就非线性动画的本意。

轨道是 NLA 的分层系统，帮助组织片段，像图像编辑器层叠像素一样层叠运动，首先是底层，最后是顶层。所以，在动画效果有冲突时，上面的轨道会覆盖下面的。这里关键帧 Action 对象有一个默认的关键帧轨道，而动作片段 Action Strip 需要放在非线性动画轨道 NlaTrack。可以通过菜单添加，Add - Add Action Strip，这会在 Timeline 保留原有的关键帧以继续编辑，第一次添加时注意先添加 NLA 轨道。

NLA 轨道有几个控制按钮分别用来设置当前轨道：

- Solo 独奏模式，五角星图标，设置是否为动画对象的唯一有效动画轨道，可以用来调试复杂动画；
- Mute 静默模式，喇叭图标或复选框，设置是否禁用轨道；
- Lock 锁定模式，锁头图标，锁定以免被误修改。要选择编辑多个轨道时，避免移动特定轨道时，这很有用；

NLA 使用的任何动作首先必须转化为动作片段，动作片段可以任意复制新实例再修改 Shift-D ，关联复制 Alt-D 可以保持动画片段的一致管理，有四种片段类型：

- Action Strip 动作片段是动作的关键帧数据的容器。
- Transition Strip 过渡片段在动作之间进行插值，自动计算过渡动画效果，在同一轨道上选择两个或更多片段后，点击菜单添加或 Shift-T。
- Sound Clip Strip 声音剪辑片段控制扬声器何时播放声音剪辑。
- Meta Strip 复合片段将片段组合一起作为一个整体方便管理，因此你可以将它们作为一个整体移动。复合片段可以像普通片段一样移动和复制。

就如动作片段保留有关键帧的动画信息，可以选择动作片段，点击菜单开始编辑暂存的动作 Edit - Start Editing Stashed Action ， 或开始调节片段动作 Edit - Start Tweaking Strip Actions，动作片段的动画信息将复原到时间轴的关键帧上以进行编辑。

创建一个新的动作片段时，它将被暂存在 NLA 的数据堆栈，动作暂存用于防止大多数的动作丢失。NLA 堆栈中使用内部的静默 NLA 轨道来保存未使用或休眠的动作片段。这样，动作片段就可以链接到特定的数据块，即与特定物体或特定材料/灯等有关，并将保留供以后使用。

如果你决定不再需要动作片段暂存，只需删除相应的 NLA 片段，然后保存并重新加载文件。或者通过菜单删除空白动画数据 Edit - Remove Empty Animation Data。由于这些是 NLA 片段，你可以通过取消禁默、重命名它们所在的 NLA 轨道，将它们重新用作普通的 NLA 片段，也可以将其移动到所有其他暂存动作轨道之上。

删除动作时，该动作并不会在列表中马上消失，而是会标记使用次数为 0，保存文件时，这个动作的就会被忽略，这个动作才会被删除。

Blender 对场景中的立体声音处理也需要使用非线性编辑器，首先在场景中某个位置添加 Speaker 扬声器对象，然后在属性面板中加载声音文件用于在 3D 视图中提供声音。当摄像机与扬声器的位置发生变化时，即动画过程中扬声器提供的声音会根据摄影机的位置提供一个立体声，多普勒效应也在计算范围。扬声器对象的加入会在非线性编辑器中添加一个声音片段对象 Sound Clip Strip，可以调整声音位置。需要渲染带声音的动画，在属性面板输出设置视频格式，在编码 Encoding 中指定声音编码即可。

和图片可以打包到 blend 文件一样，声音文件也可以，打开视频序列编辑器 Video Sequencer 执行 Add - Sound 添加声音文件，然后执行侧栏面板 Strip - Source - Pack 打包。视频序列编辑器主要功能是后期的视频合成工作，Blender 工程中的多个场景 Scene 或剪辑 Clip 都可以编排在一起，组成一个完整的视频。

文件菜单 External Data - Pack All Into .blend 可以将所有外部数据打包到同一文件，或者勾选自动打包选项 Automatically Pack Into .blend。

所有打包的文件数据都可以在大纲视图中查看，在大纲视图的列表选项中选择 Blender File，可以通过右键菜单删除没有用的数据，再保存以缩小文件尺寸。有必要还可以执行文件菜单的解包再打包，File - External Data - Unpack All Into Files。

大纲视图可以查看对象的选项包括：

- Scenes 场景列表
- View Layer 视图层列表
- Sequence 视频序列列表
- Blender File 文件对象列表
- Data API 数据接口列表
- Orphan Data 孤立数据块列表



- Action Extrapolation 动作外推，对超出片段范围的空隙处所使用的动作。

	- Hold 保持方式影响片段的两侧。
	- Hold Forward 保持前进方式，只影响剪辑片段后的区域。
	- Nothing 不使用动作外推。

- Action Blending 混合动作，影响片段堆栈结合生成效果。

	- Replace 替换，顶部片段根据影响值与累积结果线性混合，如果影响值设置为100％则完全覆盖它。
	- Multiply 相乘，Subtract  相减，Add 相加，将片段的结果计算累积到结果中，然后根据影响值进行混合。

		result=mix(previous,previous(+−∗)value,influence)

	- Combine 合并，根据每个属性的类型，自动选择一种混合运算方式。
	- Action Influence 动作影响量，活动动作对 NLA 堆栈结果的贡献量。

- Active Strip 活动 NLA 片段的设置，如动画片段在轨道的开始及结束帧 Start/End Frame。
- Auto Blend In/Out 自动混入混出设置当前片段如何控制于前后片段的混合方式。
	- Blend In 淡入，设置表示该片段何时具有完全影响的帧。
	- Blend Out 淡出，设置该片段完全影响的最后一帧。

- Action Clip 动作对象裁剪
	- Action 指定关联的动作对象
	- Start/End Frame 裁剪出来需要在轨道播放的动画帧；
	- Playback Scale 缩放动作的时间，比如 2 表示慢放，0.5 表示 2 倍速快放，这会影响关键帧标记在时间轴的相对位置。
	- Playback Repeat 重复播放次数。

Evaluation 解算，决定了片段的影响程度以及经过的时间。添加解算控制后，可以在动画摄影表或曲线编辑器的 NLA 控制曲线下中找到，并编辑它们。通过快捷键 I 给它们添加关键帧，或曲线控制点，按住 Ctrl 右键点击即可以添加曲线控制点。

- Animated Influence 动画影响力，允许改变这个片段的影响程度作为关键帧的值。如果影响没有动画化，则在重叠期间，片段会线性淡出。
- Animated Strip Time 动画化的片段与动画化的影响相同，但带片段时间 。
- Cyclic Strip Time 循环片段时长，在动作开始和结束之间循环动画化的时间。

Modifiers 修改器就像在图形和视频编辑中的对应部分一样，修改器可以为片段叠加不同的效果组合，参考函数曲线修改器。




## 👉 Graph Editor 曲线编辑

曲线编辑器允许用户随时调整任何可动画化的属性的动画曲线，添加任意关键帧后，就可以在曲线编辑器中查看和编辑，双击左侧的曲线列表的任一曲线通道即激活编辑状态。

试试用曲线编辑一个盒子翻滚的动画

- 添加一个 Cube，尺寸为 2m 的边长的立方体；
- 快捷键 I 插入初始位置关键帧，记录 LocRot；
- 使用 Timeline 编辑器，移到 30 帧的位置，修改立方体的 X 坐标为负 8m，同时 Y 轴旋转，即翻滚 270° 并插入关键帧；
- 接下来通过编辑曲线修正动画，方块滚动时其中心应该有起伏，这个动画效果很难用关键帧的方式去做；
- 翻滚过程中重心起伏的最大高度是对角线的 1/4 即 1.4m，需要给 Z 轴添加起伏曲线，两个 1.4m 的高点大概落在第 10、20 帧的位置，中间有一个低点即立方体翻转第一个面的位置，具体结合位移的曲线；
- 选定通道后，按住 Ctrl 单击即可给曲线添加控制点，为了方便操作，可以先通过眼睛图标将未用到的通道隐藏，结合侧栏面板输入坐标；

结合快捷键操作曲线编辑器：

- Home 曲线视图最大化显示曲线。
- Numpad . 只显示选中的曲线 View Selected
- Numpad 0 显示当前帧位置 View Frame
- 选中控制点后，可以使用 G 移动、 R 旋转、 S 缩放 等通用操作，当然，你可以在变换过程中通过按下 X 或 Y 来锁定轴的变换。
- Ctrl-M 镜像操作。
- Ctrl-LMB 将一个关键帧插入到鼠标位置的活动函数曲线。
- H 隐藏所选曲线
- Alt-H 显示所有先前隐藏的曲线。
- Shift-H 隐藏未选中，仅显示所选曲线并隐藏其他曲线。
- V 选择控制点类型 Handle Type。
- T 选择曲线插值函数类型 Interpolation Mode，可以在侧栏属性面板中设置 F-Curve - Active Keyframe - Interpolation。
- Ctrl-E 选择控制点缓动类型 Easing Type，可以在侧栏属性面板中设置 F-Curve - Active Keyframe - Easing。
- Alt-O 平滑曲线
- P 通过设置预览范围 Set Preveiew Range 可以将动画时间锁定在当前关注的区域。
- Tab 切换曲线锁定状态，防止误动其它曲线。或打开 View - Only Selected Curve Keyframes 以专注当前曲线的编辑。
- Back Curve 烘焙曲线 Alt-C 将曲线替换为一组采样点，并删除编辑曲线的能力。
- Sample Keyframes 采样关键帧 Shift-Alt-O 采样一组关键帧用每个帧的新关键帧替换内插值。

Bake Sound to F-Curve 可以将声音烘焙成函数曲线，先选择要修改的曲线，再执行烘焙音频文件并使用其声波创建动画数据，文件选择界面中提供以下曲线调整参数。

- Lowest frequency 最低频率，应用于音频数据的高通滤波器的截止频率。
- Highest frequency 最高频率， 应用于音频数据的低通滤波器的截止频率。
- Attack time 发生时间，Hull Curve 响船曲线计算值指示 响船曲线可以上升的速度。值越低，它可以上升越陡峭。
- Release time 放松时间，响船曲线计算的值，表示 响船曲线可以下降的速度。值越低，越容易下降。
- Threshold 阈值，影响船体曲线所需的最小振幅值。
- Accumulate 累积，只有船体曲线振幅的正差异被摘要出来才能产生输出。
- Additive 添加，总结了船体曲线的振幅。如果启用累积，则累积正负差异。
- Square 平方，将输出显示为平方曲线。负值始终为 -1，正值为 1。
- Square Threshold 平方阈值， 所有低于此阈值的值都会导致 0。

函数曲线修改器 Curve Modifiers 类似于物体修改器，可以随时对曲线进行无损的效果，并进行分层以创建更复杂的效果。修改器提供以下两项通用属性设置：

- Restrict Frame Range 面板中 Start/End 设置受影响帧范围，及 Ease-in 缓入、  Ease-out 缓出。
- Use Influence 设置曲线的输出量与上一级输入量的比例，1.0 表示完全不考虑上级曲线的输入。绘制曲线图上的为第一级输入，最后添加的修改器级别最高。

内置曲线修改器如下：

- Generator 波形生成器，有两种方式 Factorized/Expanded Polynomial，通过分解或扩展的多项式产生函数曲线，Poly Order 指定阶数并设置各项系数。这些都是基本的数学公式以表示线，抛物线，和其他更复杂的曲线，取决项数和参数。
- Built-in Function 内置函数，提供各控制参数，波幅 Amplitude，相位倍增 Phase Multiplier，相位偏移 Phase Offset 等。
	- Sine 正弦
	- Cosine 余弦
	- Tangent 正切
	- Square Root 平方根
	- Natural Logarithm 自然对数
	- Normalized Sine 归一化正弦等。
- Envelope 包络线，使用包络线控制点调整曲线的整体形状，可以添加任意控制点对曲线局部进行修改。
- Cycles 循环控制，将循环运动添加到具有两个或更多控制点的曲线。
- Noise 噪波，用噪波公式修改曲线，为动画运动创建微妙或极端的随机性很有用，例如相机抖动。
- Limits 限幅器，将曲线值限制为指定的X和Y范围。
- Stepped Interpolation 阶梯插值，通过在一定范围的帧内向下舍入值，使曲线呈现阶梯状外观。

举例，给 Z 轴添加 Generator 产生恒定旋转，只需要选择已有关键帧属性的 Z Euler Rotation 层，打开侧栏的 Modifier 添加一个 Generator，表达式默认就时一次方程即一条直线，y = 0 + 1x，即随时间固定旋转一定的度数，x 系数即直线的斜率，修改一下 Use Influence 为 0.02 大概就是每一帧一度的变化。

也可以设置 Restric Frame Range 指定曲线的有效范围，Start/End 开始/结束帧位，In/Out 缓入/缓出帧数量。


## 👉 Drivers 驱动器

驱动器是构建装备的极其强大的工具，通常用于驱动骨骼变换以及形状键，操作约束和影响修改器，通常使用自定义属性作为输入。

注意：动画驱动器这部分需要一定的 Python 脚本基础。

打开 Blender 在需要运行这些复杂或有风险的脚本时，会提示是否许可运行脚本，Allow Execution 或 Ignore，或者勾选 Permanently allow execution of scripts 以配置自动运行脚本。在用户设置中的 Save & Load 选项卡中，提供选项 Auto Run Python Scripts 来确定是否自动运行 Python 脚本。启用后，Blender 就不会再提示是否许可运行有风险的 Python 脚本了。

官方参考文档相关的内容：

- Advanced » Scripting & Extending Blender 
- Editors » Preferences » Save & Load


驱动器整合了曲线编辑能力，通过函数曲线，也可以式脚本表达式来控制输出属性值，由以下部分组成:

- 驱动器配置，指定任意个其他属性或物体变换通道的输入值，并使用预定义的数学函数或自定义的 Python 表达式将其结合在一起。
- 动画函数曲线，将驱动配置的输出映射到最终值，以应用到被驱动属性。
例如，物体 A 的旋转可以被物体 B 的位置控制。可以说，物体 B 的位置驱动物体 A 旋转。

驱动器不仅可以调用大多数属性值，直接映射到其他属性，而且属性也可以作为数学表达式或者 Python 脚本的一部分，通过函数进一步调整。

驱动器就是利用其它物体的属性来控制另一物体的属性，给 A 物体的属性如 Rotation 配置驱动器，设置好驱动器的控制变量，再给驱动器绘制驱动曲线，并曲线的 X、Y 坐标对应输入输出量，通过输入不同的 X 值就可以实现 A 物体的 Rotation 控制。

现在就尝试驱动器的使用：

- 场景中添加两个 Cube 物体 A 和 B，可使用快捷键 Ctrl-D 复制。
- 现在要通过 A 的旋转量来控制 B 的缩放，先给 B 物体 Y 轴旋属性设置驱动器；
- 鼠标悬停在 B 物体的 Scale 属性，按 Ctrl-D 给属性添加驱动器；
- 或者使用属性的右键菜单添加，Add Driver；
- 属性设置驱动器后会变成*紫色*，并且有一条箭头线标记，可以通过右键菜单直接编辑它；
- 右键菜单打开驱动器编辑器，然后在左侧通道里选择 Y 欧拉旋转；
- 按下 N 打开侧栏，选择驱动器选项卡；
- 将驱动器类型设置为 Averaged Value 均值类型，以使用驱动器变量的方式来控制 B 物体；
- 在变量类型列表，即 Add Input Variable 按钮下面的列表中选择变换通道 (X) Transform Channel；
- 然后设置物体一栏 Object 里选择 A 物体，类型 Type 设置为 X Rotation；
- 这就表示使用 A 的 X 轴的旋转控制 B 的 Y 轴旋转，默认的变量名 var 就是这个旋转的输出值。
- 试着移动物体 A，并注意它是如何影响物体 B 的。
- 结果，驱动器会通过对 A 变换通道的求和运算，并将运算的结果来控制 B 对象的缩放。

在驱动器编辑器中，可以对象现有的驱动器进行配置，对驱动器的曲线进行修改，使用内置的曲线修改器，如 Generator 波形生成器，产生函数曲线，具体参考曲线编辑器。

通过上下文菜单，还可复制粘贴驱动器，或直接在属性中键入表达式来给属性添加驱动器。


在驱动器编辑器的 Drivers 工具面板中，提供了 5 种驱动器类型，四个内置函数类型和一个脚本表达式类型：

- Scripted Expression 脚本表达式控制方式；
- Averaged Value 均值类型，通过驱动器变量控制；
- Sum Value 求和类型，通过驱动器变量控制；
- Minimum Value 最小值，通过驱动器变量控制；
- Maximum Value 最大值，通过驱动器变量控制；

类型列表下的 Driver Value 就是驱动器在当前帧的输出值。

选择脚本表达式后，会出现 Experssion 文本框，可以在其中输入一个任意 Python 表达式，表达式可以引用驱动器变量名，表达式控制方式包含了驱动器变量控制方式。

表达式也可以访问驱动器命名空间 Driver Namespace 中提供标准常量和数学函数，如 sin/cos 等。还可向命名空间添加自定义函数，需要使用 Blender Python API 中的 bpy.app.driver_namespace。

通过表达式添加驱动器的快速方法，首先单击要添加驱动器的属性，然后键入 # 和表达式内容即可以给属性添加驱动器。 为了优化性能，最好尽可能使用简单表达式。

Pytond 表达式驱动属性的例子：

	#frame
	#frame / 20.0
	#sin(frame)
	#cos(frame)
	#len([1,2,3])

勾选 Use Self 使用 self 这个变量引用自身数据，用于物体、骨骼，避免创建指向自身属性的变量。请注意，可能无法完全跟踪通过 self 访问的属性的依赖项。这种方式不属于简单表达式，涉及 Python 脚本与安全问题，默认不自动执行。所以需要许可授权运行脚本，并且许可后会得到提示：Slow Python Expression！

例如通过 self 变量访问自身的 X 坐标或 Z 轴旋转，甚至是获取场景中对象的数量: 

	self.location.x
	len(bpy.context.scene.objects)
	sin(self.rotation_euler.z-pi/2)*5
	cos(self.rotation_euler.z-pi/2)*5


简单表达式能显著提高性能，尤其是在多个系统中，即使当前因为安全原因禁用 Python 脚本执行，也会计算简单表达式，这是安全的。要利用此功能，驱动程序的表达式必须且仅使用以下功能，要更丰富的脚本功能参考 API 文档：

- 变量名称仅使用 ASCII 字符。
- 全局变量，frame，这是很重要的一个常量，代表了以帧为单位的时间。
- 字面常量，浮点和十进制整数，pi, True, False 等
- 运算符号 +, -, *, /, ==, !=, <, <=, >, >=, and, or, not, conditional operator/ ternary if
- 内置函数 min, max, radians, degrees, abs, fabs, floor, ceil, trunc, int, sin, cos, tan, asin, acos, atan, atan2, exp, log, sqrt, pow, fmod


通过 Add Input Variable 添加驱动器变量来访问物体数据，而不是以 Python 表达式形式引用，以便正确跟踪依赖项。

控制变量有 4 种：

- Single Property 物体单个属性

	如设置单个属性的驱动变量，注意 Single Property 那个 RNA 图标，表示检索由数据块引用和路径字符串组成的的 RNA 路径来获取属性的值。物体属性的 RNA 名称，基于 Python 属性访问语法的子集。

	Prop 中指定目标对象，ID Type 下拉列表指定标识类型，例如：关键帧，图像，物体，材质等，不同的对象类型提供不同的数据。

	后面的输入框指定物体 ID，也叫数据块的 ID，如场景中的一个立方体名字 Cube.001，然后是 RNA 路径的指向物体属性的部分。

	比如获取立方体模型的 X 位置，`location.x` 或 `location[0]` 表示 X 向位置坐标值，或者 `["prop_name"]` 访问自定义属性。

	又比如，使用材质对象作为数据来源，那么选中材质后在 Path 填入 `diffuse_color[0]` 就表示输出材质的散射色的红色分量，其它可以参考 Blender Python API。

- Transform Channel 变换通道

	使用物体或骨骼的某一变换通道，含对象位置/缩放/旋转等信息，可以通过列表进行选择，使用起来比 Single Property 简单，但仅限获取对象的变换数据。

- Rotational Difference 使用两个物体或骨骼之间的旋转角度差值。
- Distance 使用两个物体或骨骼之间的距离。


### ⚡ Focus on 相机聚焦

使用驱动器生成动画在一些情况显得特别好使，比如要将相机的镜头对焦到一个移动中的对象上。

Blender 内置了一款插件 Turnaround Camera，它会修改场景中的对象层次结构，会将相机移到一个 Empty 对象上，并给这个对象设置回旋的关键帧动画，使相机也绕着它转。再把 Empty 对象放到模型对象上，就可以得到相机绕模型转的画面。

使用驱动器给相机设置驱动表达式也可以做这样的效果。

	cos(self.rotation_euler.z-pi/2)*5




## 👉 Shape Keys 形态键

形态键的功能用于制作动画，可以将物体变形为新形态，形态键可能被称为形变目标 morph targets 或混合形态 blend shapes，通过 Properties - Object Data 面板管理。

可以在具有顶点(如网格，曲线，曲面和晶格)的物体类型上应用形态键。最常用的用例是用在角色面部动画，以及用在调整和改进骨架绑定。 它们对于模拟有机柔软部位和肌肉建模特别有用，这里需要对结果形态进行更多控制，而这些控制不是旋转和缩放组合可以实现的。

无法在形态键中添加或删除顶点，需要保持顶点一致，不要删除或添加顶点。 顶点的数量及其连接方式由网格，曲线，曲面或晶格指定。 形态键仅记录每个顶点的位置，因此形态键始终包含所有物体的顶点。

添加顶点时，所有形态键都会使用它的位置记录它。 工作流程方面，可以在创建形态键后添加和删除顶点，但最好在网格完成或它的拓扑稳定时开始形态键的创建。

网格(曲线，曲面或晶格)具有一个形态键堆栈，堆栈可以是 相对 或 绝对 类型。

- Relatived 相对

	主要用于肌肉，四肢关节和面部动画。每个形态都是相对于基型或另一个指定的形态键定义的。

	在3D视图中可见的效果即是混合效果，是每个形态及其当前值的累积效果。 从基型形态开始，混合效果是通过将每个形态的相对偏移加权到其参考键来获得的。

	- Value 值 

		表示形态键与其参考形态键之间的混合权重，可以通过面板右侧的小圆点设置为动画关键帧属性。Value 0.0 表示参考键的 100% 影响量，混合结果就是参考形态键。1.0 表示参考形态键的 0% 影响量，混合结果就是当前形态键。Blender 可以推算 1.0 以上和 0.0 以下两种形态之间的混合。

	- Range Min/Max 

		活动形状键的影响值的最小和最大范围。 低于 0.0 或高于 1.0 时，Blender可以推断结果。

	- Vertex Group 

		将活动形状键形变限制为顶点组。 通过将临时顶点组指定给复杂形态并将结果复制到新的更简单形态，可以将复杂形态分解为组件。

	- Relative to 

		参考形态键 基型是堆栈中第一个键的名称，表示物体顶点在其原始位置的状态。 它没有权重值，也不是可以控制的，只作为创建其他形态时的默认参考键。


- Absolute 绝对

	主要用于随时间将物体变形为不同的形态。在 value 中指定每个形态定义物体的形态估算时刻。形态混合结果是当前估算时刻 Evaluation Time 给定的前一个和下一个形态的插值。

	- Value 值 

		表示该形态键将处于活动状态的 估算时刻 。

	- Relative to 基型 

		基型是堆栈中第一个(最顶端)键的名称。 基型形态表示物体顶点在其原始位置的状态。

	- Interpolation 插值算法

		按平滑度依次为 线性 Linear，基本 Cardinal，凯特摩-若门 Catmull Rom，插值样条 BSpline

	- Evaluation Time 估算时刻 

		控制形态键的混合效果。 通常，此属性可以插帧动画或绑定驱动器。



试试绝对形态键

- 新建 Cube 盒子模型，在对象数据属性面板 Object Data Properties 增加三个形态键，Basis、 Key 1、 Key 2
- 取消 Relative 相对复选框激活绝对形态键。
- 保持 Cube 盒子选中状态，按下 Tab 进入 Edit Mode
- 选中 Key 1 形态键，根据需要调整变形网格，保持顶点一致，不要删除或添加顶点，Key 2 也一样进行修改。
- 可以按 Re-Time Shape Keys 重置形态键时序 按钮。
- 再按下 Tab 切换回到物体模式 Object Mode。
- 拖拽 估算时刻 Evaluation Time 就可以查看形态如何产生连续变化。
- 通过右键弹出菜单将添加估算时刻属性到 驱动器 Driver 或设置不同的时刻到关键帧 Keyfreame 就可以创造出动画。

使用关键帧动画，绝对形态键的所有绝对形态键共用 Evaluation Time 估算时刻，而相对形态键的 Value、 Range Min/Max 独立于各个形态键，即各个相对形态键的 Value 都可以设置独立的关键帧。

要修改选中的形态键对应的模型，先激活 Pin 按钮锁定选择的形态键 Shape Key Lock。或先将 Evalution Time 清零，并在属性列表中将形态键位置调到上面，再进行修改。

Shape Key Lock，形状键锁定即 Pin 图钉图标按钮激活时，可以在不混合的情况下在 3D 视图中显示形态键形态，当对象处于编辑模式时，形态键锁定自动启用。

Shape Key Edit Mode 形态键编辑模式 启用时，则在进入对象编辑模式时，活动形态键将不会默认产生最大影响量。而是，将当前形态键的混合形态呈现，并且可以从该状态进行编辑，移动时间轴的帧位可以观察不同的混合效果。


Shape Keys 面板下拉菜单提供的其它专用功能：

- New Shape From Mix 添加一个混合后的形态键，与列表的 + 按钮不同，因为它总是独立于当前混合形态复制基型形态。
- Mirror Shape Key 镜像形态键，X 轴上镜像，除非网格顶点完全对称，否则这将不起作用。 在 编辑模式 中使用 网格 ‣ 对称 工具。
- Mirror Shape Key (Topology) 镜像形态键(拓扑)，根据网格的拓扑检测镜像顶点。
- Join as Shapes (Transfer Mix) 合并为形态

	从不同的物体转移当前结果的形态。选择要复制的物体，然后选择要复制到的物体。 使用此操作，一个新的具有第一个物体的当前混合形态的形态键将被添加到活动物体。

- Transfer Shape Key 传递形态键

	从其他物体转移活动形态键而不管它的当前影响值。 选择要复制的物体，然后选择要复制到的物体。 使用此操作，一个新的具有第一个对象的活动形态键的形态键将被添加到的活动物体。




## 👉 Armatures 骨架
1. Blender2.8 官方教程 角色绑定 https://www.bilibili.com/video/BV1QZ4y1W7U3?p=34
2. 动画 https://docs.blender.org/manual/zh-hans/3.0/animation/introduction.html
3. Adjustable Mannequin V1.1 https://www.lookae.com/adjustable-mannequin/

Blender 中的骨架就像一个真实的骨架那样，骨架是由许多骨骼连接组成。这些骨骼可以控制表面附着
网格或者相关联的任何东西一起旋转移动。骨架 Armature 和网格绑定后，就可以用骨架姿势控制网格，
骨骼相当于控制器，类似于通过牵线来控制木偶。骨架存在的目的是用于驱动模型实现角色的 Pose 姿态，
进而得到角色动画，这无论是游戏开发或者电影制片都是非常重要的。

骨架是由骨骼构成的，骨骼的设置就是为了获得一个完整的骨架，骨架需要姿态调整、蒙皮、骨架属性设置等。
要给模型绑定骨架，就需要创建 *Armature* 对象，添加骨骼建立骨架，再添加模型并绑定到骨架，即蒙皮。

骨架对象类型特点:

- 它有一个原心，还有位置、 旋转和缩放系数。
- 有物体数据块, 所以能够在 编辑模式 中被编辑.
- 它可以被连结到其它场景, 同样的骨架数据可以被多个物体使用。
- 在姿态模式 Pose Mode 下才可以对骨架的骨骼进行调整。

骨架是为姿势设计的, 无论是静态或动态场景, 它们有一个特别的姿态叫静置位置 Rest Position，
编辑模式下看到的骨架就是处于静置位置。 骨骼有默认的形状/位置/旋转/缩放，可以在编辑模式修改。
一般在物体模式和姿态模式下看到的骨架是当前的姿势，除非你启用了骨架面板的静置位置按钮，将它恢复
到初始姿势：Armature - Rest Position。

每根骨骼都可以设置约束器，以限制或约束骨骼的运动，通过对象约束属性面板操作。

骨骼是骨架的基本要素，骨架里的骨头一般可分为两种类型，分别对应是否勾选了骨骼属性面板的选项
Bone Properites -> Deform ：

- *Deforming Bones* 变形骨骼通过直接参与改变与骨骼相关联的顶点组位置来使他们跟随变形骨骼做出类似的变换
- *Control Bones* 控制骨骼相当于切换开关，他们变换时控制着其他骨骼或物体如何动作。

例如，控制骨骼可以作为滑动开关控制，当控制骨骼位于左侧时，变换时它可以指示其他骨骼以特定方式
进行反应，当控制骨骼位于右侧时当其变换时骨骼或物体以一些完全不同方式反应。控制骨骼不直接用于
改变顶点的位置，因此，控制骨骼通常没有与自身直接相关联的顶点。

骨骼有 3 个基本元素，在编辑模式下可以选择和编辑骨骼基本元素，点击主体就可以选中整个骨骼对象:

- root or head 开始的节点，首端或头部。
- body 本体部分是骨骼的主体。
- tip or tail 结束节点，顶端或尾端。

首端和尾端也叫关节 Joint，它们各自的位置定义了骨骼。它们都有半径属性, 但只在封套变形模式下有用。
在编辑模式选择默认的骨架，在这个模式你可以选择首端 root 和尾端 tip, 像操作网格顶点一样移动它们。
骨骼有一个 Roll 扭转轴，Y 轴总是从根部沿着骨骼指向尾端，所以 Y 轴都叫骨骼的 Roll 扭转轴。
勾选面板选项以显示局部坐标轴：Properties - Object Data - Viewport Display - Axes

骨骼头尾可以相连，每个骨骼可以通过骨骼关系菜单的父级 Parenting 连接多个子骨骼，形成骨骼链结构
Chains of Bones， 骨架可以零散的骨骼构成也可以由骨骼链构成。典型的骨骼链就是手掌的骨骼结构，
把手指关节看作子骨骼，掌心骨看作父骨骼，那么掌心到各个手指的骨骼连接就构成了条 5 条骨骼链。

骨骼链之间，可以有位置的约束 Connected 连接状态，也可以没有连接位置的约束 Free 游离状态，
比如事故导致手指断了。

骨骼链在后面使用的姿势 Posing 中是一个特别重要的话题，特别是在正向运动学和反向运动学姿势技术，
Forward/Inverse Kinematics。简单讲正向运动学就如同大脑指挥手的动作，先是骨骼动作的传导是
由身体中心向手指末端进行的。而反向运动学以相反的方式进行，由手指先确定目标位置，再往肩部传递运动。
反向运动 IK 由一个目标点去确定运动，再反求自身整个物体的运动。

简单来说 IK 就是自身的运动被末端带动的，IK 允许你通过摆放骨骼链中的最后一个骨骼来自动调整
将其他骨骼位置。 它简化了动画过程，方便了姿态 Poses 的调整，可以用较少的努力制作更高级的动画。

一根变形骨骼控制着附着在骨骼的网格顶点组，就像当你移动手指时你的手指肌肉和皮肤跟随你的手指骨。
骨骼通过封套技术 Envelope Technique 定义其影响的强度或几何范围。在编辑模式 Edit Mode 
和姿势模式 Pose Mode 可以看到它的影响范围, 这取决于：

- 距离属性 Envelope Distance
- 首端和尾端的半径 Radius Head/Tail

这些可以在骨骼属性面板查看修改，Properties - Bone Properties - Deforem。

复杂的骨架需要使用分层管理，骨架编辑模式或姿态模式下，选中的骨骼可以分配到指定的层，按快捷键 M，
或通过 Pose、Armature 菜单执行 Change Bone Layers，然后指定一个层。骨架操作分层，为每个
骨架提供 32 个分层，通过属性面板 Object Data -> Skeleton 查看，要显示哪一层的骨骼，就点击
相应的色块，按住 Shift 可以多选。色块有空心圆表示已经分配有骨骼，实心圆表示当前选中的骨髓所在层。

在骨架的姿态模式下，还可以将选中的骨骼分配到骨骼组。通过属性面板操作：Object Data -> Bone Groups，
点击 + 号按钮添加一个组，点击 Assign 将选中的骨骼分配到选中的组，还可以给骨骼分组设置一个标记色。


### ⚡ Skinning & Animation 蒙皮与动画
- 蒙皮 https://docs.blender.org/manual/zh-hans/3.0/animation/armatures/skinning/index.html
- 姿态 https://docs.blender.org/manual/zh-hans/3.0/animation/armatures/posing/index.html
- 骨骼 https://docs.blender.org/manual/en/latest/animation/armatures/bones/index.html
- Mixamo add-on for Blender Creating Control Rig https://substance3d.adobe.com/plugins/mixamo-in-blender/
- Hiding & Masking https://docs.blender.org/manual/en/2.79/sculpt_paint/painting/weight_paint/hide_mask.html
- Skeleton-Aware Networks for Deep Motion Retargeting https://deepmotionediting.github.io/retargeting
- Quck tutorial on retargeting animations in UE4 https://www.bilibili.com/video/BV1TA411x7tz

创建好骨骼链是制作动画的一个基本工序，接下来还需要给骨架蒙皮，也就是将模型绑定到骨架上。
除非你想制造一个骷髅之舞这样的动画，不然总会需要在你的骨骼上添加一些血肉！链接一个骨架
到模型物体以产生变换或变形的这个过程被称为蒙皮，这个名称很贴切。

有点教材也译作装配((Rigging)，或许这是角色创建过程中最具技术含量、最为复杂的环节。

链接一个骨架到物体产生变换和变形的过程被称为蒙皮，这就是蒙皮动作，蒙皮也可以作为名词理解，
蒙皮就用来模拟皮肤的模型，将连接到骨架，并随着骨架运动模拟真实的动画角色。

Blender 有两种主要的蒙皮类型：

- 使用简单的模型绑定，通过父级/约束物体至骨骼，然后，在姿态模式下变换骨骼，它们的子物体也跟着变换，是一个标准的父子关系，这种模式的子物体从不产生形变。
- 给网格体添加骨架修改器 Deform - Armature Modifier，然后，这些物体的一部分对应骨骼里面的一些骨骼。这样，才能真正使物体的几何形状形变，即修改它的顶点/控制点的相对位置。

Retargeting 重新定向技术是从现实世界获取或捕获运动数据并应用于绑定，可通过插件和导入获得，
这是高端 CG 工厂常用方法。

Armature Deform Parent 父级骨架变形是创建并设置骨架修改器的一种方式。

有了骨架后，首先要做的就是将骨架与模型对齐，将各个骨骼移动到模型对应部位的中心。比如，脊椎骨骼
就应该放置到身体躯干的中心，而大腿骨骼就应该放置到大腿的中心。

按 N 打开 Tool -> Options -> X-Axis Mirror 对称操作，方便对称地调整手臂、大腿等骨骼。 

对齐好骨架后，就要建立骨架变形父子关系，在姿态模式下选择将受到骨架影响的所有子对象，最后选择
骨架对象本身。选择了所有子对象和骨架后，设置父级到选择骨架变形，按 Ctrl-P 然后选择弹出菜单：
Set Parent To - Armature Deform。

骨架将是所有其他子物体的父物体，每个物体子将具有与骨架相关联的骨架修改器(Object 字段)。

在 Object Mode 选择骨架对象后，就可以切换到姿态模式 Pose Mode 以调整骨架得到需要的角色 
Pose。也可以使用 Ctrl+Tab 与网格元素之间快速切换。

姿态模式下可以调用骨骼以测试模式对应骨骼的控制下如何表现得像一张皮肤。

接下来的步骤就是使用 Timeline 或 Nonlinear Animation 给骨架设置角色动画。给角色调整姿势
其实就是给骨架设置动画，也就是添加动画数据，在姿态模式下，选中 Armature -> Pose 中的骨架，
Timeline 视图可以记录下姿态的关键帧动画数据。

在 Armature 对象内部，即便是最简单的 Single Bone 对象，它内部也会包含以下三个基本的内容：

- Armature 骨骼层级关系，描述了骨架包含的骨骼层次结构；
- Pose 姿态，它基于骨骼层级关系来记录设置在各个骨骼具体的位置旋转等数据，最终结果就是角色表现出来的姿态；
- Animation 动画，基于姿态，用动画帧的形式记录下各种姿态，以及姿态的变换；

如果确定状态可以作为一个基准姿态，那么可以执行 Pose -> Apply，Ctrl-A 将姿态应用为默认状态：

- Pose as Rest Pose 将当前姿态作为默认状态，执行 Clear Transform 时复原到这个状态；
- Pose Selected as Rest Pose 同上，但是只应用到选中的骨骼；
- Visual Transform to Pose 应用约束后骨骼的视觉位置，允许删除约束，骨骼将保持在其受约束的位置。
- Assign Custom Property Values as Default 将自定义特性的当前值作为默认值，以用作 NLA 轨迹混合中静止姿势状态的一部分。

总结 Blender 最朴素的动画绑定操作步骤其实只有两步：

- 创建骨架，并调整大小和位置，完成骨骼定位，使用其与模型对齐；
- 设置模型与骨架的 Parent 关系为 Armature Deform，即模型绑定到骨架，让骨架控制模型；

将模型绑定到骨架上，With Automatic Weights 使用自动权重，其实就是以下等价操作：

- 设置模型的 Parent Object 为骨架对象，通过属性面板 Object Properties -> Relations -> Parent 指定。 
- 给模型添加了 Armature 修改器，并指定修改器的 Object 属性为指定的骨架对象。
- 设置修改器的绑定方式为 Bind To Vertex Groups，模型顶点组与骨骼关联，使得特定顶点组的顶点受控于指定的骨骼。
- 根据模型与骨架的对齐关系，将就近某一骨骼的顶点编组，顶点组命令与相应的骨骼名相同。

Armature 修改器设置 Bind To Vertex Groups 绑定方式，那么骨骼将变形应用于同名顶点组的顶点。
例如，名为 forearm 的骨骼只会影响 forearm 顶点组中的顶点。骨骼对给定顶点的影响强度由相关顶点组
中该顶点的权重控制，这是一种比骨骼封套更精确的方法。

如查设置骨架修改器的绑定方式为骨包膜 Bind To Bone Envelopes，那么就根据骨骼的包络线封套半径
和距离定义的覆盖范围来决定哪些顶点受哪个骨骼控制。

可以给 Armature 修改器设置 Vertex Group 属性，当该修改器的结果与其他修改器的结果混合时，
其权重将用于确定该修改器结果的影响。在同一对象上至少有两个这样的修改器且激活了多个修改器时才有意义。

如果模型要修改权重，首先选择要刷权重的模型，进入权重模式 Weight Paint，选择要刷权重的顶点组：
Object Data Properties -> Vertex Groups。修改笔刷的属性，按 T 显示画笔工具栏，按 N 显示
侧栏工具，在 Tool 面板中设置笔刷权重，绘制在模型上的颜色越红表示权重越大，越蓝权重越小，绿色表示
中间值。权重为 1 即红色表示完全控制，权重为 0 即蓝色表示完全不控制。

要管理顶点分组，需要在模型编辑模式下操作。

绑定骨架后，要刷顶点权重，可以先选择好骨架，再按住 Shift 加选网格体，然后进入权重绘制模式。
这种情况下，按住 Ctrl 选择骨骼，即选择相应的顶点组，然后左键点击绘制权重。即使骨骼被模型
覆盖看不见，也不影响右键选择操作。

使用笔刷绘制权重时，就会自动给模型添加顶点组，并顶点组名称与当前活动的骨骼同名。



骨骼的姿态模式或编辑模式下，Pose、Armature 菜单提供了许多工具：

- Clear Transform -> All 复原姿态，可以按 F3 打开命令搜索面板，或者单独复原移动、旋转、缩放 Alt-G, Alt-R, Alt-S。
- Names ‣ Auto-Name Left/Right, Front/Back, Top/Bottom，Flip Names，自动命名工具，它们会自动给骨骼添加上相应的后缀，或者反转配对的后缀。
- Symmetrize，先选择要生成对称的骨骼再执行生成对称骨骼。
- Change Bone Layers 改变骨骼所在层，每个骨架都有 32 个分层管理骨骼。
- Fill Between Joints 选择两根骨骼端点，执行此命令以自动填充骨骼。
- Switch Direction 反转骨骼方向。
- Bone Roll ‣ Recalculate Roll 复原骨骼在 Y 轴方向的旋转，即骨骼径向旋转复原。

另外，姿态模式还提供了补间动画工具 In-Betweens，工具栏中多了一个补间动画工具，它提供有几种补间方式：

- Breakdowner 分解
- Push 夸张
- Relax 放松

在 Pose -> In-Betweens 菜单有以下选项：

- Push Pose from Breakdown 需要两个关键帧，通过使当前姿势更接近下一个关键帧位置来插值当前姿势。
- Push Pose from Rest Pose 同上，但会将姿势插值到默认姿态，此工具只需要一个关键帧。
- Relax Pose to Breakdown 松弛姿势，使当前姿势更接近下一个关键帧位置来插值当前姿势。
- Relax Pose to Rest Pose  同上，但可以将姿势恢复到默认姿势，且需要两个关键帧。
- Pose Breakdowner 在当前帧上创建合适的细分姿势，对应工具栏的 *Breakdowner*。
- Blend to Neighbor 在时间轴中的相邻两个关键帧变换当前姿势，要求当前帧前后必须有一个关键帧。

Blender 支持使用 Pose Library 来管理姿态资产 Pose Asset，即包含一个姿态关键帧的动画。

可以通过骨骼对象的属性面板创建 Pose Library，其实创建姿态库就等于在 Dope Sheet -> Action Editor 中创建一个动作片段。然后，需要进入姿态模式下，才能给姿态库添加姿态资产。

添加第一个姿态资产比较特别，它是一个默认状态，和第二个姿态资产具有一样的姿态。添加 Pose Asset 时，选择 Add New (Current Frame) 表示将当前的状态保存到列表最后一个姿态资产中。

定义好角色的这些基本姿态后，就可以很方便地用它们来做动画：

- 选择一个姿态资产，并点击 Apply Pose Library Pose 将其应用到角色模型的骨架上；
- 保护骨骼处于选中状态，按 I 添加关键帧；
- 再选另一个姿态资产，重复以上操作，将关键帧记录到往后几帧的时间上，这样就会产生两个姿态的补间动画；

在新的 Blender 3.0 中还引入了资产浏览，更方便动画资产的管理，可以在 Object Data 属性面板中，
点击书本图标，将旧式的 Pose Library 转换为新的可以在资产浏览器中使用的格式。启用 Pose Library
动画插件，就可以在 3D 视图中的侧栏面板中调出姿态库，并且可以通过资产浏览器给 Pose Asset 设置图标，
以更清晰便捷地展示。


其实，直接给骨骼调整姿态是非常繁琐的工作，需要使用一些专用工具，Blender 提供了内置的 Rigify
插件，使用 Mixamo 这样的动画绑定插件也可以提高工作效率。大型工作室还会使用动作捕捉设置进行处理，
然后对采集到的运动数据做 Motion Retargeting 匹配到模型的骨架上。

调整好的动画应该尽量复用，以提高其价值，利用动画重定向技术 Animation Retargeting 可以
将现有的动画应用到不同的角色。比如，有一个翻越护栏的动画，通过将动作动画重定向到其它模型的骨架上，
这样就避免大量重复的工作。

在大型游戏中，每个角色可以公用很多动画，可以节约制作成本、调试修改维护时间，也节约了内存、包体大小。
Unity 和 UE4 原理都差不多，都是基于一个人体骨骼作为标准化的中转。Unity 给定了一个 Humanoid 
类型的动画系统，也就是类人形的骨架。

在 Blender 中复用动画，就需要确保骨架结构的一致，然后再将骨架与模型的顶点组关联起来，就可以
达到动画复用的目的。这个过程中，动画数据和模型顶点组的权重数据一样重要，任何一部分不一致都需要
进行细调。Blender 导出模型时，需要和相应的骨架一并导出，这样才会有相应的顶点组数据。


Set Parent 菜单项功能解析：

- Set Parent To 菜单项
	- Object
	- Object (Keep Transfrom)
	- Object (Without Inverse)
	- Armature Deform 不含顶点组
		- With Empty Groups 使用空顶点组
		- With Automatic Weights 使用自动权重
		- With Envelope Weights 使用封套权重
	- Bone
	- Bone Relative

- With Empty Groups 使用空顶点组

	当父级关系建立时，它将在在骨架中的每个变形骨骼的子级物体上，如果它们不存在，创建一个同名的空的顶点组。新创建的顶点组将为空，这意味着它们将不会分配任何权重。只能为设置为变形的骨骼创建顶点组，(属性编辑器 ‣ 骨骼 ‣ 形变面板)。

	然后，你可以手动选择顶点并将其分配给你选择的特定顶点组，以使骨架中的骨骼影响它们。

	如果你已经创建(并权重)网格所需的所有顶点组，请选择此选项。

	示例
	例如，如果有一个由三个骨骼命名为 BoneA ，BoneB 和 BoneC 以及称为 Cube 的立方体网格的骨架。如果你将立方体设置父级到骨架，立方体将会在其上创建名为 BoneA ，BoneB 和 BoneC 的三个空的新顶点组。

- With Automatic Weights 使用自动权重

	使用自动权重 类似于使用附带空顶点组，但它不会将顶点组留空。它根据从顶点到特定骨骼的距离(“bone heat”算法)计算特定骨骼对顶点的影响程度。这种影响将被分配为顶点组中的权重。

- With Envelope Weights 使用封套权重

	工作方式类似于 附带封套权重 。不同之处在于影响是基 骨骼封套 设置内容计算的。它将分配给每个顶点组的顶点在骨骼内的影响体积，权重取决于它们的到这骨骼的距离。

	这意味着新包含/排除的顶点或新的封套设置不会被考虑。你将不得不再次使用骨架变形附带封套权重( Armature Deform With Envelope Weights)来再次建立父子关系。


### ⚡ Custom Rig 自定义骨骼绑定
- Blender 2.8 快速的骨骼绑定教程 https://www.bilibili.com/video/BV1h441127gt?p=3
- Arm Rig Example https://docs.blender.org/manual/en/latest/animation/armatures/posing/bone_constraints/inverse_kinematics/introduction.html

Blender 中专用于变形的两个修改和对应的主控对象：

- Lattice -> Lattice Modifier  晶格对象与晶格变形修改器；
- Armature -> Armature Modifier 骨骼对象与骨骼变形修改器；

结合骨骼修改器的 Armature 对象用于构建骨骼系统，以便为角色的姿势和任何其他需要设置姿势的对象设置动画。向 2D 对象添加 Armature Modifier 修改器，可以精确变形该对象，从而不必手动设置几何体的动画。需要添加一个 Armature 骨架对象，并指派给修改器的 Object 属性。另外，Vertex Group 属性只在使用多个骨架修改器 Multi Modifier 激活时有效。

用骨骼和骨骼修改器控制对象的变形要点在于，绑定骨骼修改器的两种方式：

- Bind to Vertex Groups
- Bind to Bone Envelopes

如果是通过 Vertex Groups 进行绑定，那么，对象的顶点组名称就要和骨骼的名称要对应。并且对象顶点组记录了相应顶点上绘制的权重，可以在 Weight Paint 视图中进行顶点权重绘制。设置骨架为受控对象的 Parent 其实不是必要的，只要正确设置了 Armature 修改器和绑定方式，和顶点组的对应关系即可。

使用 Set Parent To -> With Automatic Weights 使用自动权重菜单来绑定的最大用途就是，Blender 会为对象自动创建对应的顶点组并提供和骨骼一致的命名，所以可以利用它们自动处理顶点组的命名操作。而骨骼的命名，则可以使用 Blender 提供的 Batch Rename 工具进行批量改名，快捷键 Ctrl-F2。

Blender 批量命名支持使用正则表达式，可以很容易将所有骨骼名称批量改正，列如 `mixamorig:Right(.*)` 替换为 `\1_R`，就可以可以将右侧所有骨骼的名字改成 `_R` 后缀，并且删掉 Mixamo Rig 前缀。注意要将 Batch Rename 面板中的 Find 和 Replace 右侧的 * 点亮才是正则表达式模式，`\1` 表示将正则表达式中第一对圆括号匹配到的内容。比如，可以将 `(Right|Left)(.*)` 替换为 `\2_\1`，这样就直接将左右前缀改为后缀。

注意，绘制定点组权重时，顶点组和骨骼可以不一一对应，但要对于需要通过骨骼控制变形的部分，定要确认 Vertex Groups 列表中的分组名称和骨骼名称要一致。

为了简化，可以直接在编辑模式下，给顶点组指派权重：

- 打开模型的编辑模式，定位到顶点组属性面板 Object Data Properties -> Vertex Groups；
- 点击 + 号按钮创建一个顶点组，并设置和骨骼一样的名称；
- 使用选择工具选中需要控制的顶点，可以使用 C、B、L 等快捷键操作圆形选区、矩形选区、关连选择；
- 然后，设置 Assign 按钮下的 Weight 权重值为 1.0，即完全控制这些选中的顶点；
- 再点击 Assign 将顶点以及权重指派给相应的顶点组。

尽管定义了和骨骼名称对应的顶点组权重，但是为了 Bind to Bone Envelopes 绑定方式可用，还是需要对模型进行定位，确保骨骼与模型的相应部位在空间上处于同样的位置。这一个步骤很重要，因为软件需要根据骨骼所在的空间位置来探测周边的网格体。

注意，模型制作要规范，模型有问题，调整骨骼姿态时，就可能出现几何体的运动量将会达不到骨骼的运动量的问题。

当然，也可以使用 Bone Envelopes 包络膜来指示骨骼对应控制对象的哪些顶点。这种方式下，骨骼所在位置定义了两个空间：

- 内部区域，由骨骼的实体部分具体化，并由根部和尖端半径控制，Radius Head & Tail。
- 外部区域，由骨骼周围较轻的部分具体化，并由设置的距离控制。

为了显示包络膜所定义的空间范围，需要切换到编辑模式或姿态模式，在骨骼的属性面板设置 Object Data Properties -> Viewport Display -> Display As Envelope。此时，骨头两端都会呈现圆形，半径由 Radius Head & Tail 定义。外部区域用更透明的颜色表示，程一个椭圆形的圈圈在骨架外围，这就是包络膜，是这个骨骨骼所影响的空间范围。

为了更清晰地观察骨骼的位置和操作，可以在视图顶部右侧的工具栏打开 Bone X-Way 选项，这样，即使骨骼有重叠都可以看得清楚。

在骨骼的属性面板 Bone Properties -> Deform 可以看到和包络膜相关的主要属性，它们共同定义了包络膜体积：

- *Envelope Distance* 包络距离距离定义了一个体积，在该体积空间范围内，对变形对象顶点有影响的。随着骨骼二次衰减而消失，几何体受骨骼的影响越来越小。
- *Envelope Weight* 包络膜权重，骨骼特性，用于控制骨骼对变形对象的全局影响程序，对于多根骨骼控制相同区域的顶点时有用。
- *Envelope Multiply* 包络乘数选项控制两种变形方法在同时启用时的交互方式。默认情况下，当它们都处于活动状态时，属于至少一个顶点组的所有顶点仅通过顶点组方法变形。由封套处理的其他“孤立”顶点。启用此选项后，此骨骼对顶点的变形影响将乘以相应顶点组中该顶点的权重。换句话说，顶点组方法通过封套方法进一步加权。
- Radius Head, Tail 根部和尖端半径，在此体积内的几何体受到骨骼控制。

骨骼分为两种类型，对应是否勾选了骨骼属性面板的 Bone Properites -> Deform 选项：

- *Deforming Bones* 变形骨骼通过直接参与改变与骨骼相关联的顶点组位置来使他们跟随变形骨骼做出类似的变换
- *Control Bones* 控制骨骼相当于切换开关，他们变换时控制着其他骨骼或物体如何动作。

只有勾选了骨骼的 Deform 选项才表示骨髓可以用于控制几何体的变形，如果不勾选它，那么骨骼就没有控制器，相当于一个不渲染的对象，这时候可以将它当作其它骨骼的控制器使用。

对于 Control Bones，它用来控制其它骨骼的行为，可以定制其外观，就像 Rigify 插件生成的绑定控制器那样。需要在 Object Mode 或 Pose Mode 姿态模式下设置 Bone Properties -> Viewport Display -> Custom Shape -> Custom Object，指定一个几何体作为控制器的外观。


以下演示如果使用 IK 修改器来自定义骨骼绑定控件的实现，相当于手动制作 Rigify 绑定工具生成的 Rig 控件。

- 首先，添加 Armature 对象，创建简单的骨架；
- 将第一根骨骼命名为 *root*，用来控制整个模型的移动；
- 从 root 挤出一根骨骼，命名为 *body*，按 E 挤出，以 Keep Offset 方式连接，这样可以随意分离移动；
- 再从 body 挤出一根骨骼，命名为 *head*，目前这几根骨骼都是往上生长的；
- 打开视图右上角的 X-Axils Mirror，这样就会对称产生对象；
- 从 root 执行 Extruded Forked 对称挤出两根骨骼，按 Shift-E，命名为 *thigh*，会自动添加 *_L* 或 *_R* 后缀；
- 从 body 执行对称挤出两根骨骼，命名为 *arm*，同样它们会自动添加 *_L* 或 *_R* 后缀；
- 从 arm 执行对称挤出两根骨骼，命名为 *forearm*；
- 从 forearm 执行对称挤出两根骨骼，命名为 *hand*，至此，完成简单的一个骨架结构；

在骨骼编辑模式下，通过属性面板设置骨骼与父级的关系 Bone Properties -> Relations -> Connected 勾选表示连接到父级，不勾选表示 Keep Offset 方式连接。

完成基本骨架制作后，就对模型进行定位，确保骨骼与模型的相应部位在空间上处于同样的位置。因为一方面，在包络绑定模式下，软件需要根据骨骼所在的空间位置来探测周边的网格体。另一方面，骨骼在控制变形时，也需要一个正确的变换中心点，如果骨骼不和模型对应部分的中心重合，那么变形就会出现问题。

虽然，设置父子关系不是必需的，但对齐这一个步骤很重要。另外，通过设置父子级关系，也相应地设置了中心的重合，这是很自然的操作。当然，可以对象模式一，使用 Object -> Snap -> Select to Active 来对齐到骨架，选择好模型和骨架再对齐。

现在，根据骨骼及其名称，在受控对象上创建顶点组，并且设置对应骨骼名称的组名，同时绘制顶点权重，或者直接进入编辑模式指派权重：

- *root* 根骨骼对应的顶点组，模型所有顶点都指派 1.0 权重；
- *body* 躯体骨骼对应的顶点组，模型身体顶点部分指派 1.0 权重；
- *head* 头部骷髅对应的顶点组，模型头部顶点部分指派 1.0 权重；
- *thigh_R* 和 *thigh_L* 大腿部骷髅对应的顶点组，模型腿部顶点部分指派 1.0 权重；
- *arm_R* 和 *arm_L* 手臂骷髅对应的顶点组，模型手臂顶点部分指派 1.0 权重；
- *forearm_R* 和 *forearm_L* 前臂骷髅对应的顶点组，模型前臂顶点部分指派 1.0 权重；
- *hand_R* 和 *hand_L* 手掌骷髅对应的顶点组，模型手掌顶点部分指派 1.0 权重；

设置完顶点组后，为受控对象设置 Armature Modifier，绑定方式为 Bind To Vertex Groups，这样就可以在骨骼姿态模式下调整角色的姿态了。

接下来，自定义 Rig 绑定控件器，只需要设置骨骼的显示内容。并且使用 IK 修改器来约束骨骼的运动，这样就可以通过控制器来调整角色姿态。

需要给骨骼设置约束器，来约束骨骼的运动。Blender 中可以给对象和骨骼使用约束器，所以有两个属性面板对应：

- Object Constraints Properties
- Bones Constraints Properties 

要使用到的骨骼修改器如下：

- Inverse Kinematics Constraint 反向运动学约束器，利用 IK 来简化姿态调整工作；
- Copy Location Constraint 用其它骨骼位置来约束本身的位置，类似的还有 Scale/Rotation/Transfrom 的复制约束；
- Limit Rotation Constraint 限制骨骼的旋转角度；

以下操作创建 IK 控制器，并且需要修改骨架结构：

- 在 *arm* 和 *hand* 左右两边共四根骨骼末端拉出一根骨骼，作为 Control Bones，即当作 IK 控制器使用。
- 并且与父级断开，通过骨骼属性面板设置，Bone Properties -> Relations -> Parent 设置为空。
- 分别命名为 *arm_ik_target* 和 *hand_ik_target* 加上表示左右的后缀，它们将作为 IK 约束器的跟踪目标。
- 因为作为控制器的骨骼不需要参与几何体的变形，所以，在其属性面板中去掉勾选的 Deform。
- 创建一个 Cube 并编辑，通过倒角 Ctrl-B 制作一个 8 面体，命名为 *ctrl_ik* 作为 IK 控制器的 UI。
- 在姿态模式下选择以上 IK 控制器，为其设置 UI，将 Bone -> Viewport Display -> Custome Shape 指定为 *ctrl_ik*。
- 完成以上步骤后，作为 IK 控制器使用的骨骼将以 8 面体呈现。

以下操作设置骨骼约束器：

- 给 *forearm* 骨骼设置 IK 约束器，在姿态模式下选中骨骼后在 Bones Constraints 面板中添加 `Inverse Kinematics` 约束器。
- 设置 IK 约束器，Target 属性指定要追踪的对象，先指定骨架再指定骨骼为 *hand_ik_target*，两边各自对应，各回各家。
- 设置 IK 约束器的 Chain Length 为 2，并勾选 Use Tail，因为只需要控制 *arm* 和骨骼链末尾的 *forearm* 这两根骨骼。
- 然后，Pole Target 属性指定极旋转追随的对象，同样先指定骨架再指定骨骼为 *arm_ik_target*，它用来约束手臂的径向的旋转。
- 现在可以通过调整 *arm_ik_target* 和 *hand_ik_target* 来对骨架姿态进行调整了。
- 将 *hand* 骨骼的父级指定为 *hand_ik_target*，脱离原来的前臂，跟随 IK 控制器移动。
- 为了约束 *hand* 的位置不脱离手臂，给它设置 `Copy Location` 约束器，设置 Head/Tail 属性为 1.0 即附着在手臂末端。
- 为了更方便地使用 IK 控制器做姿态调整，给 *hand* 和 *forearm* 添加 `Copy Rotation` 约束器。
- 位移约束器对应拷贝 *hand_ik_target* 和 *arm_ik_target* 的旋转值，这样就可以限制直接旋转骨骼，而是通过操作器来操作。
- 为了更真实地模拟手腕部位的在三个轴向的旋转角度，给 *hand_ik_target* 添加 `Limit Rotation` 约束器，并设置角度范围。

注意一下，给 *hand* 设置位移约束器后，可能会出现 IK 骨骼不会弯曲的情况，只需要重新设置位移约束器就好，或者松弛一下手臂骨骼。

以上操作，就完成了最基本的手动绑定骨骼操作器，以此为基础，你可以实现更高级复杂的骨骼控制器绑定而不必使用 Rigify 这样的插件，比如，实现脸部表情控制的骨骼系统的控制器绑定。

IK 是自定义骨骼绑定重点，只有借助它才能避免传统的 FK 姿态调整的繁琐操作。

假设有四个骨骼构成的链 Arm -> ForeArm -> Hand -> Finger，那么，只需要在 Finger 上设置一个 IK 约束。然后，直接改变 Finger 骨骼的位置，其它的骨骼就会受 IK 解算控制，自动设置合适的位置。而传统的 FK 就需要繁琐地从 Arm 到 Finger 逐个进行调整。

只需要给 IK 约束器设置 Target 对象，那么 IK 所约束的骨骼链就会自动通过解算去接触 Target 所指定的对象。

如果在根骨骼 Arm 上设置 IK 约束器，那么就不能移动 Arm 骨骼了。

选择骨架，进入姿态模式后添加骨骼约束器，如果在编辑模式下，骨骼约束列表呈现灰色，处于不可用状态。

添加约束器后，骨骼的颜色也会相应变化：

- Gray: Default.
- Blue wireframe: in Pose Mode.
- Green: with Constraint.
- Yellow: with IK Solver constraint.
- Orange: with Targetless Solver constraint.

Inverse Kinematics 约束器面板参考：

- *Target* 指定一个要 IK 解算跟踪的目标对象；
- *Pole Target* 指定用于极旋转的目标对象，如果指定一个骨架，则需要指定具体的骨骼。
- *Iterations* 最大解算递归次数。
- *Chain Length* 骨骼链长度，设置为 0 表示包含所有骨骼。
- *Use Tail* 是否包含末端骨骼，如果包含，末端骨骼就在解算范围内。
- *Stretch* 是否启用 IK 拉伸。
- Weight 权重设置：
	- *Position* 位置权重控制。For Tree-IK: Weight of position control for this target.
	- *Rotation* 骨骼链跟随 Target 旋转的强度。
	- *Influence* 控制约束器影响对象的百分比。


### ⚡ Rigify 动画绑定工具
- Blender 2.8 官方教程 角色绑定 https://www.bilibili.com/video/BV1QZ4y1W7U3?p=34
- Blender 2.9 Rigify 教程 @russellmidfield https://www.bilibili.com/video/BV1dV411t7jf
- https://docs.blender.org/manual/zh-hans/3.0/addons/rigging/rigify/index.html
- https://docs.blender.org/manual/en/latest/modeling/modifiers/deform/armature.html

直接使用 Rigify 插件提供现成的骨骼进行绑定是不错的选择，启用 Blender 内置的 Rigify 插件后，它可以提供现成的 Human (Meta Rig) 和常见的鸟类、马、猫、狼、鲨鱼等动物骨架结构。

骨架大小可以缩放以匹配模型大小，在工具栏中设置 Transform Orientations -> Cursor 可以 Cursor 标记为缩放中心，使用 Shift-S 设置 Cursor 位置为世界中心，这样可以避免骨架原点偏移。调整骨架后还会需要重新计算扭转，在编辑模式下先按 A 全选所有骨头，再按 Shift-N 弹出 Recalculate Roll 菜单，比如选择 Global +Y 坐标以重新计算骨骼的纵向扭转角度。

启用 Rigify 插件后，在骨架对象的属性面板 Object Data Properties 还会提供多个 Rigify 工具，包括：

- Rigify Bone Groups 骨骼分组控制，用颜色进行分组，常用的默认分组有 FK、IK、Special、Tweak、Extra、Root。
- Rigify Layer Names 操作分层，为每个骨架提供 32 个分层。
- Rigify Buttons 在对象模式下提供生成绑定对象的按钮，在编辑模式下提供各种 Meta-rigs 骨架类型。

在骨骼编辑模式下，可以通过 Rigify Buttons 添加示范骨骼，进入对象模式后 Rigify Buttons 会提供 Generate Rig 按钮为骨架生成 Rig 绑定对象，这就是自动生成一套 IK 骨骼，只是还是需要自己刷权重。使用 Rigify 绑定后，原始骨架再次修改后，还可以更新重新生成 Rig 绑定对象。

Rigify 根据现有的 Meta-rigs 类型生成绑定控制器，比如常见的角色特征，如头部、脊椎、四肢、手指等。在骨架创建 Rig 绑定之前，进入姿态模式，就可以通过属性面板 Bone Properties -> Rigify Type 查看或修改绑定类型。在编辑模式下，通过 Rigify Buttons 添加的骨架自带 Rigify Type。

比如，在 Armature 编辑模式下，通过 Rigify Buttons 添加一个 faces.super_face 骨架，然后回到对象模式，点击 Rigify Buttons -> Generate Rig 生成对应类型的绑定控制器。控制器在大纲列表中以 rig 对象呈现，点击选中它，并切换到 Pose Mode 模式进行姿态调整，注意，正确将 rig 转入姿态模式，而不是将 Armature 转入姿态模式。正确状态下，会在姿态模式下显示彩色控制器线条，选中控制器时会转为白色。

Rigify 允许第三方开发人员实现附加组件，称为功能集 Feature Sets，它可以提供新的 Meta-Rigs 和 Rig Types。与常规加载项类似，它们可以通过插件配置面板设置 Rigify 安装 zip 文件提供的 Feature Sets。

Human (Meta-rigs) 骨架对应的控制器分组说明，按 G 或 R 键进行移动或旋转就可以看到效果：

- Special 分组（黄色）：
	- 腰部黄色立方体控制躯干的位置，扭动等；
	- 髋部弯曲圆形，控制髋关节扭动；
	- 胸部两个圆环，用于控制相关肌群；
	- 胸部大弯曲圆形，控制上身的运动，主要是胸部排骨覆盖的区域、肩关节以内的部分；
	- 肩膀部两个小圆环，用于控制肩胛骨相关肌群；
	- 脖子小圆环，用于控制脊柱靠近脑袋部分；
	- 头部下颌部分用一个弯曲椭圆控制；
	- 眼睛用一个两端为两个圆的控制器用来控制眼球的转动。
	- 头顶小圆环，用于控制脑袋的俯仰、偏向；
- IK 反向运动解算组（红色）：
	- 两脚底板各一个红色矩形，控制腿部的固定位置；
	- 大腿根部各有红色大箭头，用于控制大腿根部关节位置；
	- 两手掌各一个红色矩形，控制手部的固定位置；
	- 上臂根部各有红色大箭头，用于控制手臂根部关节位置；
	- 此外，脸部的眼睛、嘴巴等部分也有大量的 IK 控制器；
- FK 正向运动学分组（绿色）控制器在四肢根部放置，用线段穿过一个圆环表示，直接调整骨骼的原始方式，没什么用。
- Tweak 微调分组（蓝色），主要是各大关节、手臂、大腿、躯干等部位额外添加的控制，用圆环或圆球表示。
- Extra 额外分组（棕色），主要是手掌、手指关节的控制。Rigify 自带的 Human 骨架简化了脚掌，没有相应的脚趾控制器。
- Root 根分组（紫色），带有四个箭头的控制器用来调整模型的朝向，按 R Z 键按 Z 轴进行旋转即可以调整；

Rigify 还提供了一个精简的人体骨架 Basic Humen (Meta-Rig)：

	+-- spine
		+-- spine.001 ~ 004
		|   +-- spine.005 -> spine.006
		|   +-- breast.L
		|   +-- breast.R
		|   +-- shoulder.L -> upper_arm.L -> forearm.L -> hand.L
		|   +-- shoulder.R -> upper_arm.R -> forearm.R -> hand.R
		+-- pelvis.L
		+-- pelvis.R
		+-- thigh.L -> shin.L -> foot.L -> toe.L + heel.02.L
		+-- thigh.R -> shin.R -> foot.R -> toe.R + heel.02.R

为了方便调整姿态，可以设置 Object Data Properties -> Viewport Display -> In Front，这样控制器就会显示在上层。

骨络动画 FK - Forward Kinematics 正向运动学和 IK - Inverse Kinematics 逆向运动学是最常见的两种。反向运动控制器分组很重要，它可以设置关节的固定点，然后调整其它控制器时，就会自动解算出关连骨骼链上的其它骨骼位置，可以简化动画姿态调整工作。在编辑骨架时，可以添加 IK 约束器。

在 Rig 控制器对象的属性面板 Object Data Properties 可以看到骨骼分组和分层控制，通过 Select 或 Deselect 就可以选取或不选指定分组的控制器。32个骨骼分层可以决定要显示哪些层，Row Top 和 Row Button 各 16 层。

生成 Rig 绑定时常见问题：

- 如果出现尺寸过大或过小，可能是骨骼缩放问题，可以在对象模式下 Ctrl-A 应用缩放，将对象的缩放归置为 1。
- 如果出现 Disjoint 骨骼，可以使用 Cursor 工具来对位，先选择关节，按 Shift-S 执行 Cursor to Selected 对齐到选择的对象。再选择未连接的关节，执行 Armature -> Snap -> Selection to Cursor 对齐。

创建控制器绑定后，可以将原本的 Meta-rigs 参照骨架隐藏。因为不需要通过它来调整模型状态，生成的 Rig 绑定对象包含了骨架，但是可以再次修改原始骨架，并重新生成 Rig 控制器。

Rigify 生成的许多小部件旋转在 WGTS_rig 集合内，如果你只需要骨架，这部分没什么用途可以删除。

Blender 2.93 版本中正常操作生成绑定对象，3.0 版本中点击 Generate Rig 生成绑定对象后不能正常操作。 

调整好骨架并生成 Rig 控制器后，就可以将模型绑定到 Rig 控制器。即设置 Parent 关系，先选择模型，最后选择 Rig 控制器，Ctrl-P 执行绑定 Armature Deform。可以单独绑，也可以一起绑定，一定要最后选择控制器，让其成为 Parent 以控制模型。一般绑定时，可以选择 With Automatic Weights 使用自动权重。

进入姿态模式，拖动或旋转 Rig 控制器，模型就会跟着动作。

如果 Rig 控制器位置不对，可以通过调整原 meta-rig，修改完重新生成即可。如果只想改变一个骨骼，可以在骨架属性 Generate Rig 按钮下面找到高级选项，选上覆盖 Override，然后再点击创建 Rig。


### ⚡ Bone/Skeleton 骨骼操作
- https://docs.blender.org/manual/zh-hans/3.0/animation/armatures/bones/index.html

创建 Armature 骨架后，选中其中一根骨骼，按 Tab 就可以进入编辑模式。

骨骼编辑工具集与网格编辑使用的非常相似。骨架编辑的一个重要之处是编辑骨架的重置位置 ，骨架处于没有旋转状态，并在其局部空间所有缩放到 1.0。之后基于此重置位置的创建不同姿势 Poses。 所以在编辑模式下修改它会影响已经存在的所有姿势，通常应该在开始蒙皮 Skin 和姿势 Pose 之前，确保你的骨架是确定的！

- Shift-A 在骨架编辑模式添加一个新的骨骼到你的骨架。
- E, Shift-E 挤出或镜像挤出新骨骼 Extrude，在每个选定的头部或末端创建一个新子骨骼对象，对主体挤出则会在两端挤出子骨骼。
- F 在关节之间填充 Armature ‣ Fill Between Joints，在选定的关节端点之间键创建一个骨骼。
- Shift-D 复制选定的骨骼，选择关节时无效
- X 删除选定的骨骼，不能操作关节，Ctrl-X 溶解骨骼 Dissolve Bones，Armature ‣ Delete Selected Bone(s)
- Armature ‣ Subdivide 细分骨骼可以得到两个或更多的骨骼，并保留现有的关系。
- P 分离骨骼为一个新的骨架对象， Armature ‣ Separate
- Ctrl-J 对象模式中重新将选择的骨架合并， Object ‣ Join Objects
- Alt-W、 Shift-W、 Ctrl-Shift-W 打开骨骼选项菜单
- Y 拆分骨骼，将选择的骨骼从骨骼链中断开，并将移到骨架顶级，Armature ‣ Split
- Alt-P 弹出断开骨骼连接菜单
- Ctrl-P 重新连接骨骼。

- Parenting 父级链接

	Ctrl-P Make Parent 建立父连接

	在骨骼编辑视图，通过快捷键 Ctrl-P 弹出菜单菜单建立连接 Armature ‣ Parent ‣ Make Parent，选择了两个或以上的骨骼，最后选择的那个是父级。有两种连接方式，Connected 方式便是将子骨骼移到父骨骼末端，Keep Offset 方式，父骨骼与子骨骼只有连接关系，没有位置约束，不会移动子骨骼。

	Alt-P Clear Parent 清除父连接

	选中需要脱离父连接的骨骼，选择 Clear Parent 将断开与父骨骼的连接，选中的子骨骼成为顶级骨骼，被选中的子骨骼的下级骨骼保持连接关系。选择 Disconnect Bone 则是保持连接脱离父骨骼的位置约束。

	以上操作都可以通过骨架属性编辑器完成，的骨骼关系设置父级骨骼 Bone Properties - Relations - Parent，从骨骼候选列表中指定父级骨骼数据 ID。将候选列表的父骨骼清除即可以断开连接，或去掉 Connected 复选框即可以取消位置约束，再次勾选即可将子骨骼移动到父骨骼末端。

- 骨骼命名

	好的命名习惯 Naming Conventions 可以帮助在 Blender 找到正确的骨骼，也告诉 Blender 哪两个骨骼是配对骨骼。

	如果你的骨架可以镜像另一半，这是值得坚持左/右命名的约定。这将使您能够使用一些工具，可能会节省您的时间和精力，如 X 轴镜像编辑工具会用到。

	- 首先，你应该给你的骨骼有意义的基名称，如 leg 腿部，arm 手臂，finger 手指，back 背部，foot 脚部等。
	- 给骨骼在另一边的副本，像手臂左右小胫骨，给它前缀或后缀分隔符区别，`L_calfbone`，`calfbone.R`，不使用分割符将不被识别。
	- 如果有一个大写或小写 "L", "R", "left" 或 "right", Blender 正确处理副本。如 `_` underscore 下划线、 `.` dot 点、 `-` dash 破折号都是有效的分隔符。

		hand_L --> hand_R
		hand.l --> hand.r
		hand-l --> hand-r
		hand LEFT --> hand RIGHT

	在 Blender 处理一个骨骼的镜像和翻转前，它首先是移除名称的数字扩展，如果有的话。如 `bla.L` 通过翻转命名 Armature ‣ Names ‣ Flip Names 将向拷贝骨骼得到 `bla.L.001`，然后翻转名得到 `bla.R`。

	AutoName 自动命名工具 Armature ‣ Names ‣ AutoName Left/Right, Front/Back, Top/Bottom 可以根据骨骼的局部坐标判断子骨骼在 X、Y、Z 正负轴的位置，自动给子骨骼名字添加后缀，如 `.L` `.R` `.Bk` `.Fr` `.Top` `.Bot`。如果位置处于原点，则不能正确改名。

- X 轴镜像

	编辑和姿势模式，此选项可以沿X轴自动镜像编辑动作。 Sidebar region ‣ Tool ‣ Options ‣ X-Axis Mirror

	如果你有一对同名的骨头只有一个不同的后缀名，例如 `.R` 和 `.L`，或 `_right` 和 `_left`，一旦启用此选项， 每次你转换(移动/旋转/缩放......)骨骼，它的另一边对应物将相应地通过沿着骨架局部的 X 轴进行对称性变换。 由于大多数操纵对象至少有一个对称轴如动物，人类，这是一种简单的方法，可以让您免于一半的编辑工作！

- 锁定骨骼

	在编辑模式你可以有几种方法避免骨骼产生变换：

	按 Shift-W 开启骨骼设置锁定，或勾选骨骼属性面板激活 Bone Properties - Bone Properties - Transform - Lock

	如果一个锁定骨骼的首端接到一个没有锁定骨骼的尾端，则不会被锁定 ，换言之，你可以随意移动它们。这意味着相链的骨骼链，当你锁定其中一个骨骼时，你其实只是仅仅锁定了它的尾端。对于没有相连的骨骼，锁定是对骨骼两端关节都是有效的。

- Alt-M 合并骨骼 Armature ‣ Merge Bones

	只要它们形成链接，就可以合并几个选定的骨骼。由所选骨骼形成的每个子链将产生一个骨骼，其首端将是首端骨骼的首端，并且其尾端将是尾端骨骼的尾端。

- Transforms 变换

	其他变换工具局部轴是指物体的轴不同，骨骼变换涉及了骨骼链，变换的它们是骨骼自己的轴，当你锁定到局部轴时，通过按相关键两次，约束将沿所选骨骼的局部轴应用而不是骨架物体的轴。

- Armature ‣ Switch Direction 反转骨骼方向 Alt-F

	切换骨骼的方向通常会破坏它所属的链条。但是，如果你换整个(一部分)链，则切换的骨骼仍将保持父子和链接关系，相反的顺序。

- Armature ‣ Transform ‣ Scale Radius 封套球形半径 Alt-S

	通过选择骨骼的头部，身体或尾部来改变骨骼的半径，然后按 Alt-S ，向左或向右移动鼠标。如果选择了身体，意味半径将被缩放。需要注意的是当调整骨大小时，Blender 自动校正它的封套的末端半径，建议首先放置所有骨骼再调整。

- Armature ‣ Transform ‣ Scale Envelope Distance 缩放封套间隔 Ctrl-Alt-S

	你可以通过单击要更改的骨骼的主体来更改骨骼封套体积的大小，然后向左或向右拖动鼠标，骨骼封套体积将相应更改。

- Armature ‣ Transform ‣ Align Bones 对齐骨骼 Ctrl-Alt-A

	旋转选中的骨骼，保持与活动的相一致。

- Armature ‣ Bone Roll ‣ Set 设置骨骼扭转 Ctrl-R

- Armature ‣ Bone Roll ‣ Recalculate 重新计算骨骼扭转 Ctrl-N
	
	- Axis Orientation 轴向
		- Local Tangent 与骨骼及其父级定义的轴对齐。 X, Z
		- Global Axis 全局轴向 对齐滚动(扭转)到全局 X，Y，Z轴。
		- Active Bone 激活骨骼 遵循活动骨骼的旋转。
		- View Axis 视图轴 将滚动设置为与视图对齐。
		- Cursor 游标 设置滚动朝向3D游标。
	- Flip Axis 翻转轴 反转轴方向。
	- Shortest Rotation 最短旋转 避免将骨骼从其当前值滚动超过90度。


在骨骼编辑模式下，可以使用该面板控制单个骨骼的位置和滚动。而在姿态模式 下，只有父级主骨骼的位置能调整之外其他的骨骼不能改动位置，所有骨骼可以设置旋转和缩放。
另外，在姿势模式中，可以限制骨架中每个骨骼上的轴的位置，旋转和比例的变化。





## 👉 Constraint 约束
- https://docs.blender.org/manual/en/2.93/animation/constraints/index.html

约束是通过使用数值限制来控制物体属性的方法，例如限制对象的位置、旋转、缩放等。主要用途在动画项目中，当然，在静态项目中也有用。

可以使用跟随路径约束 Follow Path Constraint 来让相机按曲线目标物体运动，使它沿着这个曲线 或路径移动。当跟随曲线 Follow Curve 选项启用，它也可以影响它的自身的旋转遵循曲线的弯曲。 可以用于复杂的相机漫游，火车在轨道上和大多数其他车辆也可以使用无形轨道，自行车链等。


通过约束引用的目标，可以间接控制物体的动画，这是间接动画的一种形式。实际上，目标对象可以控制约束的物体属性，因此，目标对象将间接地带动物体的动作。

可以调整约束里的数值，如滑动 Influence影响 ，或者在使用骨架的骨骼作为目标时，滑动沿着该骨骼(根部和尖端之间)分布的位置。
约束可以使网球运动员眼睛跟踪网球弹跳地穿过球场、可以让一辆巴士所有车轮一起旋转，也可以帮助一只恐龙的腿抬高时膝盖处自动弯曲，或者轻松地让手握住剑柄并挥动剑。

在 Blender 里，约束作用于 对象 和 骨骼，约束可以相互组合，形成一个约束堆栈，约束堆栈是按从顶部到底部进行运算的。

使用物体约束属性，在属性编辑器物体约束选项卡中添加，Properties - Object Constraint Properties，在选项卡点击 Add Object Constraint(添加对象约束) 菜单。或者在 3D 视图中，使用菜单添加约束 Object - Constraints：

- Add Constraint (with Targets) 给选定的对象添加约束，会自行添加空对象 Empty 做为主控对象； 
- Copy Constraints to Selected Objects 将剪贴下的约束设置到选中的对象上；
- Clear Object Constraints 清除对象上的约束；

一个简单的约束就是 Copy Location Constraint 复制位置约束，它强制约束对象和目标位置相同，类似的还有 Copy Rotation/Scale Constraint。

添加 Copy Location 约束后，在约束属性面板中，设置好 Target 即主控目标，然后，设置要约束的坐标分类，勾选 XYZ 任意组合，可以对分量值取反方向。

添加的约束对象保存存在约束堆栈，也就是约束面板中的前后关系，在堆栈中的约束是从顶部到底部计算的。每个约束的顺序对堆栈的最终结果有实质性的影响，更改约束的顺序可以更改整个堆栈的行为，更改约束属性中的 Influence 值来调整影响力比率。

被控对象与世界原点存在偏移量，那么勾选 Offset 将允许与主控对象保持这个偏移量，否则被控对象的属性值会设置保持与主控对象一致。

其中 Space，涉及主控对象与被约束对象的空间转换关系，Target Space & Owner Space。前者用来计算约束物体的目标的空间称为目标空间，后者用来计算拥有该约束对象，即受控者的空间。比如，

空间类型如下：

- World Space 世界空间，这个空间类型以世界坐标系为物体的参照系，其位置相对于世界的原点，旋转和缩放以世界的轴为参考。
- Local Space 局部空间，这个空间类型以物体本身或骨骼的父级为参照系，其位置相对于父级的原点，旋转和缩放是面向父级的轴。
- Local With Parent (bones only) 局部父对象，仅限于骨骼，骨骼属性由它自身局部空间计算得到，包括骨骼链上的父级的变换。
- Pose Space (bones only) 姿势空间，限于骨骼，那么骨骼属性通过计算它所在的骨架局部空间得到。因此，如果骨架物体有空变换， 姿势空间 和 世界空间 将具有相同的效果。

使用 Local Space，约束关系使用的参考原点会不同，在选择变换主控对象时，参考点可能会偏移。因此，使用的是 Copy Location 约束也会有响应主控对象的旋转变换的错觉。

为了观察到对象内部的坐标指向，可以使用快捷键 Ctrl-Period 打开对象的原点编辑模式，直接操作对象原点，移动或旋转。通过 N 打开侧栏属性面板的工具选项设置，Sidebar ‣ Tool ‣ Options ‣ Transform，勾选 Affect Only - Origins。勾选 Affect Only - Locations 则只能对位移变换操作，而不能进行旋转或缩放。勾选 Affect Only - Parent 表示只对父级对象进行变换操作，在其子级物体不受影响的情况下变换父级物体。


作为第一个探索的约束就不错，官方文档有一个动画示例，模拟太阳系的运动。

	https://wiki.blender.org/wiki/File:ManAnimationTechsUsingConstraintsExSolarSys.blend

- Motion Tracking 镜头运动追踪

	- Camera Solver Constraint 相机解算
	- Object Solver Constraint 物体解算
	- Follow Track Constraint 跟踪轨迹

- Transform 变换约束，约束对象的位置、缩放、旋转，还有对象间的距离，对象体积等

	- Copy Location Constraint 复制位置约束，对相连骨骼使用该约束无效，因为父级骨骼头部位置决定了根部骨骼所在位置。
	- Copy Rotation Constraint 复制旋转约束
	- Copy Scale Constraint 复制缩放约束
	- Copy Transforms Constraint 复制形变约束
	- Limit Distance Constraint 限定距离约束
	- Limit Location Constraint 限定位置约束
	- Limit Rotation Constraint 限定旋转约束
	- Limit Scale Constraint 限定缩放约束
	- Maintain Volume Constraint 维持体积约束
	- Transformation Constraint 自设变换约束
	- Transform Cache Constraint 变换缓存约束

- Tracking 跟踪约束

	- Clamp To Constraint 钳制到约束
	- Damped Track Constraint 阻尼跟踪约束，也叫 Look At 约束，维持自身的一个本地轴总是指向目标。
	- IK Solver Constraint 反向运动学约束
	- Locked Track Constraint 锁定跟踪约束，为非激活的选择物体添加约束，目标对象是激活选择物体。而激活选择物体不会被添加约束。
	- Spline IK Constraint 样条线IK约束
	- Stretch To Constraint 拉伸至约束
	- Track To Constraint 标准跟踪约束，也叫 Billboard tracking 公告牌跟踪，是指平面总是面向摄像机，平面是追踪者 trackers，摄像机是它们的目标。

- Relations 关系约束
	
	- Action Constraint 动作关系约束
	- Armature Constraint 骨架约束
	- Child Of Constraint 子级约束
	- Floor Constraint 基面约束
	- Follow Path Constraint 跟随路径约束
	- Pivot Constraint 轴心约束
	- Shrinkwrap Constraint 缩裹约束

姿势模式下，当使用另一个骨架的骨骼作为约束的目标时，添加约束(预指定目标物体)工具将查看非活动骨架内部并使用其活动骨骼。


### ⚡ Motion Tracking & Object/Camera Solver
- https://docs.blender.org/manual/en/2.93/animation/constraints/motion_tracking/object_solver.html
- https://docs.blender.org/manual/en/2.93/animation/constraints/motion_tracking/camera_solver.html
- 如何用Blender进行运动跟踪 (上)  https://www.bilibili.com/video/BV12U4y1p7Sx
- Motion Tracking https://docs.blender.org/manual/en/2.93/movie_clip/tracking/index.html

Object Solver 和 Camera Solver 是用于镜头追踪的约束器，镜头追踪也叫 Motion Tracking。

Object Solver 对象解算器约束为该约束的所有者提供对象运动的位置和旋转，可用于解算将网格添加到视频中使用。

已解算对象运动是指 Blender 认为物理、真实世界（跟踪）对象相对于拍摄它的相机的位置，比如，视频中的一个杯子的运动。

Object Solver 约束器属性：

- *Active Clip* 从电影剪辑编辑器中的活动电影剪辑接收跟踪数据。
- *Object* 选择要从中接收 Transform 数据的被跟踪对象。
- *Camera* 选择作为运动父对象的摄影机（如果留空，则使用活动场景摄影机）。
- *Set Inverse* 将对象的原点移动到摄影机的原点。
- *Clear Inverse* 将对象的原点移回，Movie Clip Editor Toolbar ‣ Solve ‣ Orientation ‣ Set Origin.
- *Constraint to F-Curve* 应用约束，为变换创建关键帧。
- *Influence* 控制约束对对象的影响百分比。


Camera Solver 摄影机解算器约束为该约束的所有者提供已解算摄影机运动的位置和旋转。

已解算的摄影机运动是指 Blender 重建物理真实世界摄影机拍摄视频片段时相对于被跟踪对象的位置运动。

Camera Solver 约束器面板：

- *Active Clip* 从电影剪辑编辑器中的活动电影剪辑接收跟踪数据。
- *Constraint to F-Curve* 应用约束，为变换创建关键帧。
- *Influence* 控制约束对对象的影响百分比。

进入电影剪辑编辑器侧边栏区域设置，Movie Clip Editor ‣ Sidebar region ‣ Objects，根据需要设置摄影机或对象，对应的解算按钮会显示 Solve Camera Motion 或 Solve Object Motion。

注意，追踪点的数量一定大于 8 个！只有在设置了至少八个标记，即 8 个追踪点，并按下求解对象/镜头运动后，约束器才起作用。操作路径：Movie Clip Editor ‣ Traking ‣ Toolbar ‣ Solve ‣ Solve Camera Motion 或 Solve Object Motion。

标记点设置要在视频轮廓明显的位置，四个点组成的矩形部分为匹配区，另外一条引线用来做旋转缩放控制，调整匹配区大小以包含轮廓。要求被标记的内容运动速度不能太快，这样每帧画面组合在一起可以形成一个可追踪的运动轨迹。Alt-S 添加搜索框，当标记跟丢，就会在搜索框查找标记内容。

在 Track 工具面板中，Tracking Settings 设置：

- Motion Model 运动模型，设置镜头的运动方式。
- Match 设置匹配方式。
- Correlation 相关度，设置跟踪点的匹配百分比为正确结果，一般设置 0.9 即 90% 正确率才通过。 

跟踪匹配，更准确地说，如何跟踪视频帧的 Pattern。这里有一个例子，可以让事情变得更清楚。跟踪器算法接收搜索区域内的两幅图像，第一幅图像中指定跟踪点的位置。跟踪器试图从第二幅图像中找到第一幅图像出现的位置。现在，就是跟踪方式，第二幅图像即搜索区始终来自标记位置未知的帧（下一个跟踪帧）。

Keyframe 方式，从为轨迹设置关键帧的帧创建的图像。此配置可防止从原始位置滑动（因为跟踪器会返回与原始图案最对应的位置），但当特征点因相机运动（例如透视变换）而变形时，可能会导致小跳跃并导致失败。

Previous frame 方式，每个帧都创建轨迹的关键帧，并使用关键帧图像和下一个图像之间的跟踪。在此配置中，模式在两个相邻帧之间跟踪。它允许处理特征点有较大变换的情况，但可能导致从原始位置滑动，因此应加以控制。

设置好跟踪点，按 A 选中所有跟踪点，执行 Track -> Track Motion -> Track Forwards，Ctrl-T 进行跟踪。然后，将 Clip 视频剪辑视图切换到 Graph 曲线视图，就可以看到追踪到的数据，曲线越平滑，差值波动越小就越好，准确度也越高。

基于线的颜色，图形或曲线视图有多种用途。图中的红线和绿线显示了给定帧下跟踪器的速度。绿色是垂直运动，红色是水平运动。

蓝线线，是每帧的平均误差。此曲线仅在解算后可用，不可编辑。这是一条线尽可能平坦，尽可能接近零。高点会告诉你在你的拍摄中哪里有不准确的跟踪。

有了跟踪数据后，就进入 Solve 面板，进行解算。设置 Solve -> Keyframee A/B 限定解算的关键帧范围，或者勾选 Keyframe 让系统自行处理关键帧数据。如果是三角架拍摄的视频，可以勾选 Tripod。

解算成功后，通过 Scene Setup 将跟踪点设置到场景中。然后，选择跟踪点可以进行后续的操作，通过 Orientation -> Set Scale 用于缩放解算。回到 3D 视图，设置顶部右侧 Viewport Overlays -> Motion Tracking 可以显示运动追踪对象

如果，解算出现以下提示，说明轨迹数据不够，不能解算到运动轨迹，需要更多准确的跟踪点产生更多的轨迹：

	At least 8 common tracks on both keyframes are needed for reconstruction.
	Some data failed to reconstruct (see console for details)

提高解算成功率的提示：

- 拍摄避免摇晃或模糊的好镜头。
- 添加更精确的跟踪点，以产生优质的轨迹数据，按 Ctrl 点击左键添加跟踪点。
- 删除一个轨迹，然后再解算，如果没有帮助，选择一个不同的轨迹，然后重复。
- 确保并非所有轨迹都在空间中的一个平面上（如墙上）。


### ⚡ Inverse Kinematics IK反向运动约束
- https://docs.blender.org/manual/en/2.93/animation/constraints/tracking/ik_solver.html
- https://docs.blender.org/manual/en/2.93/animation/armatures/posing/bone_constraints/index.html

Inverse Kinematics constraint 实现了反向运动学骨架处理技术，在骨架进入姿态模式后，可以按 Shift-I 快速添加 IK 约束器。

IK 允许固位骨骼链中的最后一个骨骼，并自动定位其他骨骼，这就像拽着一个人的手指会使他的手臂跟着运动一样。

常规姿势技术，必须从根骨骼开始，依次设置骨骼，直到到达尖端骨骼。移动每个父骨骼时，其子骨骼将继承其位置和旋转。因此，在链的更深处对姿势进行微小的精确更改变得更加困难，因为您可能必须首先调整所有父骨骼。

以上就是 FK 正向运动的操作，而通过使用 IK 可以有效地简化这种操作。虽然约束更多，但它可以用于快速摆放姿态。

假设有四个骨骼构成的链 Arm -> ForeArm -> Hand -> Finger，那么，只需要在 Finger 上设置一个 IK 约束。然后，直接改变 Finger 骨骼的位置，其它的骨骼就会受 IK 解算控制，自动设置合适的位置。

如果在根骨骼 Arm 上设置 IK 约束器，那么就不能移动 Arm 骨骼了。

Inverse Kinematics 约束器面板：

- *Target* 指定一个要 IK 解算跟踪的目标对象；
- *Pole Target* 指定用于极旋转的目标对象，如果指定一个骨架，则需要指定具体的骨骼。
- *Iterations* 最大解算递归次数。
- *Chain Length* 骨骼链长度，设置为 0 表示包含所有骨骼。
- *Use Tail* 是否包含末端骨骼，如果包含，末端骨骼就在解算范围内。
- *Stretch* 是否启用 IK 拉伸。
- Weight 权重设置：
	- *Position* 位置权重控制。For Tree-IK: Weight of position control for this target.
	- *Rotation* 骨骼链跟随 Target 旋转的强度。
	- *Influence* 控制约束器影响对象的百分比。


### ⚡ Spline IK Constraint 样条IK约束
- https://docs.blender.org/manual/en/2.93/animation/constraints/tracking/spline_ik.html

样条线 IK 约束沿指定曲线对齐骨骼链，通过曲线提供的实现美观形状的轻松性和灵活性，以及骨骼提供的可预测性和良好集成控制，样条线 IK 是装配工工具箱中一个非常宝贵的工具。它特别适合于装配灵活的身体部位，如尾巴、触手和脊椎，以及无机物品，如绳索。

若要设置样条线 IK，需要有一个连接骨骼链和一条曲线来约束这些骨骼：

- 在对象模式下添加 Curve 对象，比如 Beizer 或 Path，并编辑路径。
- 添加骨骼链，并选择链中的最后一个骨骼，再从骨架属性面板添加样条线 IK 约束器，Bone Constraints -> Add Bone Constrint -> Spline IK constraint。
- 将骨骼链长度设置为链中应受曲线影响的骨骼数（从选定骨骼开始并包括选定骨骼）。
- 最后，将 Target 设置为应控制的曲线。

根据需要可以再次调整曲线。

设置 Y Scale Mode 为 Fit Curve 可以缩放骨骼以匹配曲线长度。


### ⚡ Copy Constraints to Selected 复制约束到选择

	参考

	模式:	物体模式和姿态模式
	菜单:	物体 ‣ 约束 ‣ 将约束复制到当前所选
	将激活物体的约束复制给非激活的选择物体

	Clear Constraints 清除约束
	参考

	模式:	物体模式和姿态模式
	面板:	物体 ‣ 约束 ‣ 清除物体约束
	删除选定对象的所有约束。

	Track 跟踪
	参考

	模式:	物体模式
	面板:	物体 ‣ 跟踪
	为非激活的选择物体添加约束，目标对象是激活选择物体。而激活选择物体不会被添加约束。


	Clear Track 清除跟踪
	从选定的对象中删除所有阻尼跟踪，标准跟踪和锁定跟踪约束。
	清除跟踪并保持当前变换(取消跟随)
	移除选定对象的所有跟踪约束，并保持由跟踪引起的最终变换。

### ⚡ Follow Path Constraint 跟随路径约束

Follow Path Constraint 跟随路径约束 的作用是把约束对象放在约束目标 曲线 上，并使它能沿着这个曲线 (或路径)移动。当勾选 跟随曲线(Follow Curve) 选项时，约束对象会顺得约束目标曲线路径来旋转自己。

可以用于复杂的相机漫游，火车在轨道上和大多数其他车辆也可以作为“隐形”的轨道，还能做自行车车链条等。

自身总是在全局(世界)空间中进行计算：

它的位置(如 变换 面板中所示)用作与其路径上正常位置的偏移量。如果约束对象的位置在(1.0, 1.0, 0.0)，这将使其沿着X和Y轴远离其在曲线正常位置的一个blend单位。因此，如果您希望你的约束对象 在 其目标路径，则使用 Alt-G 将坐标归零！

该位置的偏移量目标对象曲线的比例缩放影响。采取与上述相同的(1.0,1.0,0.0)偏移量，如果曲线的缩放为(2.0,1.0,1.0)，约束对象将沿着 X轴(和一个沿 Y轴)偏移 两个 blend单位......

当 跟随曲线(Follow Curve) 选项启用，约束对象Y轴会顺得曲线旋转(如果想要你约束对象的Y轴与曲线的方向对齐，在约束之前，必须把约束对象的Y轴与全局Y轴对齐)。再次 Alt-R 清除自身的旋转可能有用...

可以以两种不同的方式来控制约束对象沿着约束目标曲线/路径的移动：

最简单的就是定义移动帧的数量，在曲线设置的 路径动画 ，通过数字按钮帧，和它的开始帧通过约束的偏移选项(默认情况下，开始帧：1 ，偏移量为0，持续时间：100)。

第二种方式，更加精确和强大，是给 目标 路径定义一个 估算时刻 的函数曲线(在 曲线编辑器 中)。请参阅 曲线编辑器章节 以了解有关F-Curves的更多信息。

如果您不希望约束对象沿路径移动，您可以为目标对象曲线指定一个直的*速度* F曲线(其值将控制约束对象沿路径的位置)。

Follow Path跟随路径 约束和另一个 锁定跟随 约束可以搭配一起工作。一个典型例子就是一个在路径中滑行的相机。为了控制相机的滚动角度，当相机沿着路径飞行时，你可以使用 Locked Track(锁定跟踪) 和约束目标对象指定向上的方向 。

Note

Follow Path & Clamp To

不要混淆这两个约束。两者都是沿着曲线限制其自身的位置，但是 跟随路径 是一个“仅限动画”的约束，因为是通过时间(即当前帧)确定自身沿曲线的位置，而钳制到约束( Clamp To ) 约束 通过使用其位置变换的一个值确定自身沿曲线的位置。

Note

请注意，您还需要路径的关键帧解算时间，选择曲线对象，转到属性面板曲线(curve)标签 Path Animation(路径动画) 栏，设置整个帧到路径的第一帧(例如帧1)，设置解算时间的值到路径的第一帧(例如1)，右键点击解算时间，选择创建关键帧(create keyframe), 设置整个帧到路径的最后一帧(例如帧100)，设置解算时间的值到路径的最后一帧(例如100)，右键点击解算时间，选择创建关键帧(create keyframe)。

选项

- Target 目标

	数据ID 用于选择约束目标，目标 必须 是一个曲线对象，当它为无(none)时不起作用(标题栏名称为红色状态)。

- Animate Path 动画路径

	在开始和结束帧选项添加 F 曲线。

- Curve Radius 曲率半径

	通过曲率半径缩放对象。见 曲线编辑。

- Fixed Position 固定位置

	对象将保持锁定在曲线长度的某个地方，而不论时间如何变化。

- Offset 偏移量

	从路径定义的"动画" 偏移的帧数(默认情况下，从第 1 帧)。

- Follow Curve 跟随曲线

	如果此选项未激活，则约束对象自身不会顺得曲线旋转。否则会受到以下选项的影响：

	- Forward 前进

		物体的轴线必须与路径的前进方向对齐(即与自身位置处的曲线相切)。

	- Up 向上

		物体的轴线必须(尽可能的)与世界Z轴对齐。事实上，这个选项激活，自身的行为与 锁定跟踪约束 共用一些属性，路径为“轴”，世界Z轴为“磁铁”。



### ⚡ Follow Track Constraint 跟踪轨迹

默认情况下，跟踪轨迹约束使对象在一个帧处具有与轨道相同的位置，并且此对象的运动发生在由摄像机定义的单个平面上以及对象的原始位置。

- Active Clip 激活剪辑

	在影片剪辑编辑器中从活动影片剪辑接收跟踪数据。 如果未选中，则会出现一个选项，可以从其他可用剪辑中进行选择。

- 3D Position 3D 位置 使用轨迹的3D位置为父级。

- 移除畸变 父级到2D轨道的未失真位置。

- 匹配方式 定义镜头如何安装在相机框架中。

- Camera 相机 选择运动所属的摄像机(如果激活了空场景摄像机)。

- Depth Object 深度目标

	如果设置了此对象，则约束对象将投影到此深度对象的表面上，该表面可用于创建面部化妆视觉效果。

- Constraint to F-Curve 约束到图形曲线 

	为复制由约束引起的移动的对象创建F曲线。





## 👉 Markers 标记

标记用于标示动画中具有关键点或重要事件的帧。 例如， 它可能是角色的动画开始，相机改变位置，或门打开。
标记可以被命名，使它们在快速浏览时更有意义。 它们可以在 Blender 的许多编辑器中找到。

- Graph Editor 曲线编辑器
- Dope Sheet 动画摄影表
- NLA Editor 非线性 Non-Linear Animation 动画编辑器
- Video Sequence Editor 视频序列编辑器
- Timeline 时间线

除了标准标记，姿势标记 是另一种类型的标记，它们特定于骨架和形态键。 在动画摄影表编辑器的动作编辑器
模式和形态键编辑器模式中，它们用于表示姿态。

大多数编辑器将标记显示为底部单独行中的小白色三角形，如果未选中则为空，如果选中则填充。如果他们有名字，
则将以白色显示在他们的右边。

添加标记的最简单方法是在 Timeline 时间轴视图移动到您希望它出现的帧，然后按 M。可以通过视图菜单
显示标记线，是一条垂直虚线。

3D 视图不允许您创建，编辑或删除标记，但当在标记所在帧，将在左上角的物体信息中显示它们的名称。

姿态标记在动画摄影表中显示为菱形图标。 在NLA编辑器中姿态标记显示为红色虚线。

在时间线中可以将相机绑定到标记，使用标记将活动物体设置为活动摄像机。要使用此操作，请选择要成为活动
摄像机的物体，然后选择要将活动摄像机绑定到的标记。 如果在执行操作时未选择标记，则将添加标记。当物体
绑定到标记时，标记将重命名为活动对象的名称。 这些标记在名称左侧旁边还有一个摄像头图标，可以轻松地将
其与其他信息标记区分开来。

可以移动这些标记以更改帧为将 活动摄像机 更改为 标记绑定的物体 时的帧。


## 👉 Motion Paths 运动路径


运动路径工具允许您将点的运动以可视化方式显示为一系列帧上的路径。 这些点可以是物体原点和骨骼关节。

要创建或删除运动路径，首先必须选择对象/骨骼，然后：

- 要显示路径(或根据需要更新它们)，请单击 计算路径 Calculate/Update Paths 按钮。
- 要隐藏路径，点击 清除路径 按钮。

在编辑姿态/关键帧时路径会自动更新，并且在动画播放期间它们也处于活动状态。 仅当启用了 当前帧附近 选项时，播放动画才会影响路径。

通过以下界面使用运动路径：

- 编辑骨架，姿态模式下，通过姿态运动路径菜单 Pose - Motion Paths。
- 属性编辑器，物体属性面板 Properties editor ‣ Object Properties ‣ Motion Paths
- 属性编辑器，骨架属性面板 Properties editor ‣ Armature ‣ Motion Paths



# 🚩 Render 渲染流程

一个 3D 场景的构建至少需要三个关键的构件：模型，材质和光照，渲染就是将这些组织好的材料固定
下来输出图片或视频。模型是现实世界的物体的结构模拟，材质决定模型物理属性，光照使得模型的物理
属性作用于光线，产生视觉效果。

Blender 提供三种渲染引擎：

1. Cycles 产品级渲染：基于光线追踪的照片级效果，基于物理的光线路径跟踪器。
2. Eevee 实时快速渲染，基于光栅化的实时渲染引擎，可以利用各种反射光探针提升光照效果。
3. Workbench 建模或动画快速渲染引擎，可以用于 Grease Pencil 模型渲染。

此外还提供实时渲染引擎 Eevee 和 Workbench Engine 来加速项目的制作。Workbench 是一个针对建模和动画期间的预览进行了快速渲染优化的渲染引擎。 其目的并不是为项目执行最终像素级渲染输出，主要任务是在 3D 视图中时显示正在处理的场景。

在旧版 Blender 还提供了 BGE - Blender Game Engine，即内建游戏引擎，使用 Bullet 物理系统，但 BGE 并不算是一个专业的游戏引擎，可以做一些不是特别复杂的游戏，现在已经移除，独立出来一个 UPBGE 游戏引擎。但是无论如何，有 Unity 和 Unreal 的存在，其它游戏引擎显得相当无助。


Cycles 的渲染方式有两种，分别是CPU渲染和GPU渲染。渲染时我们可以看到渲染的方格，一个方格代表一个核心，一般使用CPU渲染的时候是多个方格同时进行，而使用 GPU 渲染时一般单显卡是一个核心。为了提高渲染效率，对于CPU渲染，一般在渲染属性面板下，Performance 下的 Ties 设为较小的值，比如 16x16 等，而对于 GPU 渲染 256x256 甚至 512x512。

设置 GPU 渲染需要在 Edit - Preferences -> System -> Cycles Compute Device 中指定可用的 GPU，比如英伟达显卡会出现 CUDA，如果显示None，表示无法使用GPU加速。

渲染的设置可以在属性面板中的 Render Properties 细调，渲染输出面板设置文件编码，视频分辨率等等，测试期间将 Dimensions - Resolution 的百分比调小能减少渲染区的大小，加快渲染。或者配合视图设置的 Render Region 进行区域渲染，Ctrl-B 设置渲染区，Ctrl-Alt-B 清除，对应的 Render Region 选框也会自动勾选。

需要渲染的视图可以在场景属性面板中设置 Scene Properties - Scene - Camera

为了能够更加灵活地编辑材料属性 Blender 中提供了 Shader Editor 着色器，纹理节点编辑器 Texture Node Editor，通过添加着色节点，改变材料特性。操作时可以灵活使用 / 快捷键调用对象局部视图，也可以使用 H 和 Alt-H 暂时隐藏对象。还有 UV Editor 可以用来编辑 2D 贴图的 UV 坐标。

材质由三部分着色器组成：

- 表面外观 Surface，表面着色器控制着网格表面的纹理和与光照交互的表现。
- 物体内部体积 Volume，体积材质定义了网格内部的表现。一个材质可以仅拥有一个体积着色器，例如烟雾和火焰，也可混合表面着色器，例如磨花玻璃。
- 表面的置换 Displacement，可以改变模型表面形状细节或内在体积。因此，纹理可以用来增加网格表面更多的细节。置换可以是虚拟的，仅修改表面的法线来营造一种类似于凹凸贴图的置换的感觉

着色器编辑器基于节点编辑渲染的材质，Cycles 和 Evee 渲染器使用的材质都是使用节点树定义的。Blender 中有用于不同功能的节点编辑器，但节点结构相似。节点在编辑器中看起来就时一张卡片，有节点标题，有输入输出插口，节点从输出插口可以接到其它节点的输入插口，其它节点就可以获得本节点处理好的数据流，未使用的插口可以隐藏 Ctrl-H ，每插口都根据其处理的数据类型不同而显示的颜色不同。

- 颜色(黄色) 表示需要输入或从节点输出颜色信息，这可能包含或不包含Alpha通道，取决于节点树的类型。
- 数值(灰色) 表示数值信息，可用于单个数值或叫做值映射，可以看作灰度值映射，其中不同亮度/暗度上反映出每个点的值。常用于 Alpha 映射和值的节点选项。
- 矢量(蓝色) 表示向量、坐标和法线信息。
- 着色器(绿色) 用于 Cycles 和 Eevee 的着色节点。

试试给模型设置材质

- 通过 General 模板新建一个文件，在 3D View 视图中包含一个 Cube 模型，此时模型已经有一个基本的内置材质 Material，在 Outliner 编辑器中的展开 Cube 对象结构就可以看到；
- 直接 Shift-F3 打开材质着色器 Shader Editor，可以看到 Material 材质包含两个节点，Principal BSDF 双向散射分布函数着色器和 Material Output 材质输出节点；
- 也可以在 3D View 视图中 Shift-A 新建一个 Cube，这时需要自行设置材质；
- 打开材质着色器，点击编辑器标题栏中部的材质球可以调出内置材质 Material，也可点击 + 号新建一个材质，同时材质会自动赋予最后选中的模型对象； 
- Shift-A 添加一个位图纹理 Texture - Image Texture，浏览定位一个纹理图片，并拖动 Color 输出连接 SFDF 着色器的 Base Color 输入插口；
- 回到 3D View 视图，快捷键 Z 打开 Rendered 或 Material Preview 模式，即可看到纹理贴图覆盖在模型上的效果；
- 属性编辑器也提供了材质面板，材质球图标就是，Material Properties 也可以编辑材质节点。

默认情况下物体仅有一个材质槽 Slot，它指定了整个物体单一的材质。如果网格的不同部分需要不同的材质，那就创建多个材质槽。

视图层 View Layer 的使用，使得渲染可以被分成不同的层，然后将它们重新组合在一起。如将合成效果分别应用于角色，或分别为模糊背景和前景层用于景深，或渲染同一场景的不同光照变化。 使用视图层还可以避免每次更改时重新渲染整个图像，从而允许您仅重新渲染所需的图层。其中通道面板 Passes 可将渲染图像分为颜色，直接光和间接光来分别编辑它们，以及提取深度或法线等数据。根据使用的渲染引擎 Eevee 或 Cycles，在视图层属性面板 View Layer Properties 提供了细致的设置选项。

使用 Cycles 引擎，还可以为视图层得渲染提供 Denosing 降噪，使用渲染过程中收集的信息(称为特征传递)过滤生成的图像，以去除噪点，同时尽可能保留视觉细节。

视图层属性面板 View Layer Properties 提供了 Frestyle 设置，材质中使用得 Freestyle 是卡通描边效果，用于渲染非真实的 non-photorealistic (NPR) 卡通形象线条。

渲染输出面板 Output Properties 中可以设置输出图片、视频的分辨率 Dimensions - Resolution，需要渲染的帧范围 Frame Start/End/Step，或视频的帧速率 Frame Rate，一般影片默认 24 FPS 帧速就完全满足。

渲染单帧时，输出应为单个图像格式，而不是视频，渲染多帧视频时，也可以选择输出图像。图像用于渲染视频帧具有一些优点，例如，可以通过更改帧范围来取消渲染作业并在最后渲染的帧处恢复。如果动画需要很长时间来渲染并且其他内容需要计算机资源，这将非常有用。

渲染得到的图像序列又可以添加到视频序列编辑器 Video Sequencer 进行编辑，也可以结合其它修图工具修复后再选择适当的视频输出，就可以快速将图像序列编码为视频，在几秒钟内尝试不同的视频编码选项，而不是几分钟或几小时，因为编码通常比渲染 3D 场景快得多。

## 👉 Video Sequencer 视频编辑

视频序列编辑器 Video Sequencer 可以处理渲染得到的图像序列，以及视频、音频进行简单剪辑，可以结合
其它修图工具修复后再选择适当的视频输出，比如 FFMPEG，可以快速将图像序列编码为视频，可以尝试不同的
视频编码选项。视频的合成过程比渲染速度要快，不用几分钟或几小时，因为图像的编码通常比渲染 3D 场景快得多。

除非 Video Sequencer 中添加了图像或视频片段，渲染视频格式时可以添加音轨，如果添加了图像或视频片段，
则只会对编辑器中的图像进行处理。

要添加字幕，可以使用 Subsimport 插件，可导入和编辑 srt 等字幕文件，使用快捷键 D 和 F 设置开始、
结束位置。

https://github.com/doakey3/subsimport

	D:	Set the start of a text strip.
	F:	Set the end of a text strip.
	S:	(like pressing F, then D rapidly)
	W:	(like pressing D, then F rapidly)
	Z: Send top strips to the end of the base strip. Useful for resetting the position of syllabified lyrics.
	Ctrl + Shift + Right:	Select all strips in the Subtitle Edit Channel to the right of the current time indicator.
	Ctrl + Shift + Left:	Select all strips in the Subtitle Edit Channel to the left of the current time indicator

- Add - Image/Sequence 添加渲染得到的图片块 Image Strip；
- View - Sequence Render Animation 重新渲染图片序列，也可以勾选渲染输出面板 Output Properties 中的后期处理选项来实现
	- Post Processing - Compositing 合成渲染 3D 场景
	- Post Processing - Sequencer 优先渲染视频序列
	- Dither 抖动，通过模糊像素的技术，防止在渐变区域中看到条带，其中在颜色之间出现阶梯式步进。
- 视频序列编辑器的其他功能，例如添加 先前渲染的 图像片断，音频，视频剪辑等。

为了渲染输出音频，在输出面板勾选合适的音频编码器，如 Output - Audio - Audio Codec - AAC。

没有设置选择扬声器开始播放的开始时间，因为您可能希望单个扬声器多次播放。因此，您必须打开NLA编辑器，
可以在其中添加定义声音何时开始的声带(没有别的，因此条带的任何其他属性，如长度无关紧要)。添加扬声器
对象时，将在当前帧添加条带。

视频剪辑格式的分辨率设置：

|  格式 |   分辨率    |  帧率  | 宽高比 |  码率  |
|-------|-------------|--------|--------|--------|
| 144p  | 192 x 144   | 20 fps | 4:3    | 1MB/m  |
| 240p  | 320 x 240   | 20 fps | 4:3    | 3MB/m  |
| 360p  | 480 x 360   | 20 fps | 4:3    | 7MB/m  |
| 480p  | 640 x 480   | 20 fps | 4:3    | 12MB/m |
| 720p  | 1280 x 720  | 30 fps | 16:9   | 35MB/m |
| 1080p | 1920 x 1080 | 30 fps | 16:9   | 80MB/m |
| 2k    | 2560 x 1440 | 30 fps | 16:9   |        |
| 4k    | 3840 x 2160 | 30 fps | 16:9   |        |
| 8K    | 7680 x 4320 | 30 fps | 16:9   |        |

参考：

| 码率级别 | 640X480 | 1280X720 | 1920X1080 |
|----------|---------|----------|-----------|
| 极低码率 | 250kbps | 500kbps  | 1mbps     |
| 低码率   | 500kbps | 1mbps    | 2mbps     |
| 中码率   | 1mbps   | 2mbps    | 4mbps     |
| 高码率   | 2mbps   | 4mbps    | 8mps      |
| 极高码率 | 4mbps   | 8mbps    | 16mbps    |

常用的清晰度等级：

- UHD (Ultra High-Definition) 超高清：4K、8K
- FHD (Full High Definition) 全高清：1080i、1080p
- HD (High Definition) 高清：720P
- SD (Standard Definition) 标清：480P

分辨率越高、码率越大，视频就越清晰，帧率越高视频动作看起来就越流畅，同时储空间占用就越大，所以使用
推荐码率即可。

码率就是单位时间的数据大小，码率越小表示压缩越利害，画质越差。以高清格式 HD 为例，第幅画面总的 RGB
 像素占用字节数为 1080 * 720 * 3 = 2332800 即 2.2247 MB，如果在不压缩的情况下，30 fps 
 帧率计算，每秒的码率就超过 66 MB，每分钟 3GB，这是很恐怖的流量。

据了解，现行有这样的配置：

- 国内视频网站的 4K 码率一般只有 3-5Mbps，
- 而国外的 Netflix 4K 码率 ≥15Mbps (H.265压缩标准下)，
- Youtube 4K 码率 ≥18Mbps(VP9压缩标准下)，
- Comcast 试播的服务码率是 18M ~ 22M(H.265压缩标准下)。
- 而 BiliBili 则推荐使用 480P 24fps 2.5MB，720P 24fps 5.5MB，1080P 24fps 12.5MB 。

最常听到的帧率是 24fps，这也是绝大多是电影采用的帧率。电影工业选择 24fps 作为标准背后有着一段很
曲折的历史。

低于 24fps 的视频常在早期电影中使用，为了节省胶片使用，无声电影的非正式标准被设置为 16fps，再
就是需要逐帧拍摄的定格动画，帧速率如果设置太高会极大提高拍摄成本，所以一般设置在 12fps 左右，
另外还有一些导演为了刻意营造“降格”的感觉，会把帧率调到 20-22 左右，后期再以 24 帧每秒的速度播放，
就会产生一种轻微快放的感觉。

当帧速率提高到一倍达到 50fps 或者 60fps 的时候，画面看起来会更流畅、更逼真，可以明显提升交互感
和逼真感，尤其是运动镜头的画面观感提升很会更为明显：画面稳定、动作更加细腻、清晰、流畅、细致、立体，
甚至能让人产生分辨率提高了的错觉。

除了视频，高帧率对游戏体验来说也同等重要，一般来说，第一人称射击游戏会更加比较注重 FPS 的高低，
如果 FPS<30 的话，游戏会显得不连贯，因为游戏画面通过渲染引擎绘制，缺少运动时产生的模糊。



## 👉 Shader Nodes

在设定材质节点时，需要了解的一个重要概念就是 着色器接口。所有的表面着色器及体积着色器的输出对象都是
着色器，它可用于描述光对于表面及体积内部的作用方式，而不仅仅是表面颜色这么简单。

着色器编辑器的节点很丰富，Cycles 引擎还可以使用开放着色语言 Open Shading Language 创建节点。
编写好的着色器脚本通过 Script 节点加载就是一个着色器节点。注意，这些节点只能在 CPU 渲染下运行，
不支持 GPU 运行 OSL。

其中着色器有以下几种基本类型，这里的着色器是指 Shader Node 而非 Shader Editor：

- BSDF shader 双向散射分布函数着色器，定义物体表面光的反射、折射与吸收。
- Emission shader 自发光着色器，定义物体表面或其体积内部的发光。
- Volume shader 体积着色器，定义体积内部的光线散射。
- Background shader 背景着色器，定义来自环境的发光。

节点连线默认直线，可以在用户配置中修改连线曲度：

	Blender Preferences - Themes - Node Editor - Noodle Curve

着色器节点 Shader Nodes：

- Output Node 着色器输出节点

	着色器输出节点是每个节点树的最后一个节点，虽然可以添加多个，但只有一个起作用。

	- Material Output 材质输出节点 将曲面材质信息输出到曲面对象。
	- Light Output 灯光节点 将灯光信息输出到灯光对象。
	- World Output 世界节点 将颜色信息输出到场景的世界。
	- AOV Output 

	AOV - Arbitrary Output Variables 任意着色器节点提供自定义渲染通道。作为艺术家，这可能是
	一个很好的用来调试或调整一个场景在后期处理非常精细的细节的方法。要使用应用量沙化器 AOV，在着色
	AOV 面板创建该通道，然后在 AOV 输出 着色节点引用该通道，就可以使用着色AOV了。可在 着色AOV
	面板中添加或删除着色AOV。

- Input Node 着色器输入节点


	- Ambient Occlusion 环境光遮蔽节点

		计算被遮蔽点上方的半球形空间的遮挡量。该节点可用于程序贴图纹理，例如，仅向拐角处添加风化效果。

		对于 Cycles 引擎，该节点会显著拖慢渲染速度。如果需要较快的渲染速度，可以选择几何数据节点下
		的尖锐度选项，或烘焙环境光遮蔽。

	- Attribute Node 属性节点 

		获得物体或网格的属性信息，比如在 Name 属性中输入烟雾流对象的名字 flame，或者顶点色 
		Vertex Color 名称等等。

	- Bevel Node 倒角节点 

		可用于渲染圆角，边缘上轻微的圆角有助于实现真实世界中的镜面高光效果，但该着色器十分吃显卡。

	- Camera Data Node 相机数据节点 

		获取物体相对于相机位置的信息。

	- Fresnel Node 菲涅尔节点 

		计算光线在层面上反射和折射的量，生成的权重可以与混合着色器一起对着色器进行分层。

	- Geometry Node 几何数据节点 

		提供有关当前着色点的几何信息。所有矢量坐标都在 世界空间 中。

	- Hair Info Node 毛发信息节点 

		用于访问毛发型粒子信息。

	- Layer Weight Node 层权重节点 

		通常与 混合着色器 节点一起使用，输出一个用于层着色的权重值。

		输出非传导性菲涅尔权重，可用于分层漫射和光泽着色器，以产生塑料材料效果。这类似于菲涅耳节点，
		但它在 0.0 到 1.0 范围内选值会更加方便。

		输出面朝向 Facing，当表面从面向观察者过渡至掠射角观察角度的过程中，该面朝向给出一个从
		第一个着色器到第二个着色器混合的权重值。

	- Light Path Node 光程节点 

		用于确定着色器正在计算何种入射光线；它特别适用于非物理依赖的光线制作。

	- Object Info Node 物体信息节点 

		提供有关对象实例的信息。这对于向单一材质的物体分配不同材质提供便利。

		location - 输出物体在世界空间中的位置。
		Object color - same as Color in the Properties ‣ Object Properties ‣ Viewport Display.
		Object pass index - same as Pass Index in the Properties ‣ Object Properties ‣ Relations.
		Material pass index - same as Pass Index in the Properties ‣ Material ‣ Settings.
		Random 单个对象实例的唯一随机数。

	- Particle Info Node 粒子信息节点 

		可用于复制粒子系统物体的材质节点树，此节点可以访问生成对象实例的粒子数据，可用于向复制物体
		赋予不同的材质。

	- RGB Node 颜色节点 输出单一的 RGBA 颜色。

	- Tangent Node 切向节点 

		为各向异性BSDF生成切线方向。

	- Texture Coordinate Node 纹理坐标节点 

		纹理坐标节点处理网格体的 UV 坐标，有多种坐标生成方式。
		https://www.jianshu.com/p/1ddac5c01254

		Object 设置用于对象空间坐标的特定对象，仅影响指定对象输出。

		对于生成的实例，那么它的顶点或面就具有实例的纹理坐标，from instance 仅对生成和 UV 输出起作用。

		- `Generated` 从网格顶点生成纹理坐标而不造成网格变形，这样可以使它们在动画下保持粘附在
			曲面上。从未变形网格的边界框上取值，取值范围从 0.0 到 1.0。
		- `Normal` 物体空间法线，用于纹理对象，其中纹理在变换时保持在对象上固定。因为此方式包含了
			光源旋转，可用于点光源和聚光灯光源。 
		- `UV` UV 纹理坐标来自渲染用的 UV 贴图。
		- `Object` 使用指定对象作为坐标源。 通常与 Empty 空物体一起使用，这可以很方便地将小
			图像放置在对象的给定点上。该对象也可以设置动画效果，以使得纹理在表面移动。
		- `Camera` 相机空间中的定位坐标。 
		- `Window` 屏幕上阴影点的位置，在渲染的左右侧和顶底部的范围从 0.0 到 1.0。非常适合混合两个对象。 
		- `Reflection` 使用反射向量的方向作为坐标。对添加反射贴图很有用。使用环境贴图时，需要此输入。

		当模型结构十分的复杂，几乎无法做到 UV Unwrap 时使用，或者赶时间时使用 Generated 方式。
		算是一个备选方案，因为他会基于当前对象的尺寸和形状去将纹理应用到模型上，即使用模型网格的
		顶点坐标来映射到 2D 的纹理贴图上，当模型变形时贴图依旧会紧贴在对应的顶点上。想象当一个人
		从前体重只有 80 斤时在肚子上有一个纹身，现在当他变胖后此时肚子上纹身的样子。

		同时 Generated 也是程序化纹理，如 Nosie Texture、Brick Texture 的默认选项。

		另外，使用 Generated 往往需要手动调整顶点属性的 Texture Space 来确保纹理不被异常拉伸。

		法线方式会告诉渲染引擎物体的表面所朝向的方向，当得到了这些信息后，就可利用这个特性制作类似
		雪花落在物体表面的样子。注意，Normal 关联的是 local-space，所以当你转动物体时他不会跟着
		改变。即物体倒转放置，雪花会附着在原先的位置。


	- UV Map Node UV贴图节点 

		用于检索任意特定的 UV 贴图，相比纹理坐标节点仅能提供正在使用的 UV 贴图信息。

	- Value Node 值(明度)节点 

		将数值输入节点树中的其他节点。

	- Vertex Color Node 顶点颜色节点 

		提供顶点颜色及其 alpha 值。

	- Volume Info Node 体积信息节点 

		提供有关 烟雾场 的信息。

	- Wireframe Node 线框节点 

		Cycles 引擎中用于检索对象的边缘，由于网格在 Cycles 引擎处理之前会进行三角剖分。因此，
		在使用线框 节点查看时，网格拓扑将始终显示为三角剖分。


- Shader Node 着色器节点

	- Add Shader			相加着色器节点
	- Anisotropic BSDF		各向异性BSDF节点
	- Background			背景节点
	- Diffuse BSDF			漫射 BSDF节点
	- Emission				自发光节点
	- Glass BSDF			玻璃 BSDF节点
	- Glossy BSDF			光泽 BSDF节点
	- Hair BSDF				毛发 BSDF节点
	- Holdout				阻隔节点
	- Mix Shader			混合着色器节点
	- Principled BSDF		原理化 BSDF着色器节点
	- Principled Hair BSDF	原理化毛发 BSDF节点
	- Principled Volume		原理化体积着色器节点
	- Refraction BSDF		折射 BSDF着色器节点
	- Specular BSDF			高光 BSDF着色器节点 仅限 Eevee 引擎
	- Subsurface Scattering	次表面散射(SSS)着色器节点
	- Toon BSDF				卡通 BSDF着色器节点
	- Translucent BSDF		半透 BSDF着色器节点
	- Transparent BSDF		透明 BSDF着色器节点
	- Velvet BSDF			丝绒 BSDF着色器节点
	- Volume Absorption		体积吸收着色器节点
	- Volume Scatter		体积散射着色器节点

- Texture 纹理节点

	- Brick Texture Node	砖墙纹理节点 用于添加具有噪声失真的带或环。
	- Checker Texture Node	棋盘格纹理节点
	- Environment Texture	环境纹理节点
	- Gradient Texture Node	渐变纹理节点

		渐变纹理 节点根据输入向量的值来生成颜色和强度插值，即输出的是一维灰度渐变，给一个 Cube 渐变纹理会用这一个一维的渐变纹理包裹。

	- IES Texture Node		IES纹理节点

		北美照明工程协会 IES - Illuminating Engineering Society of North America 是技术性学会，学会标准化工作由所属 80 多个技术委员会和分技术委员会负责。各技术委员会从事各种照明设备的研究与标准的制订工作，就各个领域照明的问题进行调查并向理事报告。例如，机场和飞机、农场、工厂、研究机构、办公室、公共交通工具、住宅、学校、服务处所、街道和公路、剧院和电视台。其它课题包括光源、照明和空气调节等。

		IES 文件就是光源（灯具）配光曲线文件的电子格式，文件格式就是由北美照明协会定制施行的，现为许多地区默认的存储光源空间光强分布的一种文件格式。IES 如果你用缩略图来看的话，你看到的是它的子午面配光曲线图，也就是极坐标曲线图。

		IES 文件包括：灯光强度信息（流明或其他）、配光曲线（灯光照射出来呈现什么造型）、色温等信息（灯光照射呈现什么颜色）。

	- Image Texture Node	图像纹理节点

		常用的节点，用来为模型指定图像纹理。

		采样类型有 linear、Closet、Cubic、Smart；
		纹理投影方式 Flat、Box、Sphere、Tube；
		纹理坐标超出 UV [0,1] 范围时的处理方式 Repeat、Extend、Clip；
		纹理文件类型 Single Image、Image Sequence、Movie、Generated、UDIM Tiles；

		选择生成纹理，会将带有 + - 符号的纹理写入到指定的文件中。

		UDIM 是多象限 UV，可以让模型能放置多张 UV，用多张不同分辨率的纹理实现更高的精度。

	- Magic Texture Node	迷幻纹理节点
	- Musgrave Texture Node	马氏分形纹理节点
	- Noise Texture Node	噪波纹理节点

		生成柏林噪波分形图，设置畸变 Distortion 可以获得扭曲的色带，在低缩放得情况下获取局部输出，色彩变动较大。
		细节 Detail 设置柏林噪声倍频程 Perlin Noise Octaves，配合粗糙度使用可以获得边界模糊或清晰的斑块输出。

	- Point Density Node	点密度纹理节点 用于为每个粒子或物体的顶点添加体积点。
	- Sky Texture Node		天空纹理节点
	- Voronoi Texture Node	沃罗诺伊纹理节点 输出色块分割的纹理，如半点。
	- Wave Texture Node		波浪纹理节点
	- White Noise Texture	白噪波纹理节点

- Color 颜色节点

	- Bright/Contrast Node	亮度/对比度节点
	- Gamma Node			伽玛着色器节点
	- Hue Saturation Value	色相/饱和度/明度 着色器节点
	- Invert Node			反转着色器节点。
	- Light Falloff Node	光线衰减着色器节点
	- Mix Node				混合节点
	- RGB Curves Node		RGB曲线着色器节点

- Vector 矢量着色器节点

	- Bump Node				凸凹着色器节点
	- Vector Curves Node	矢量曲线节点将输入矢量的分量映射到曲线。
	- Displacement Node		置换着色器节点
	- Mapping Node			映射节点

		映射节点通过应用平移，旋转和缩放来变换输入矢量，输出的变换矢量可以对其它节点的数据进行矢量变换，比如对渐变纹理进行缩放。

		使用不同类型进行不同的变换映射：

		- `Point` 节点对向量执行直接转换。
		- `Texture` 节点对向量执行逆变换，意味着对被求值的纹理本身进行变换，例如，沿X轴 正方向移动纹理坐标将导致被求值的纹理向 X 轴正方向移动。 
		- `Vector` 将执行 点 转换，但转换为零。
		- `Normal` 节点执行变换的逆转置并规格化结果。这种变换可确保非均匀缩放后的正确规格化。 因此，在转换规格化时应使用此类型。

	- Normal Node			法向着色器节点 

		生成法线向量和点，点是标量值。
		如果两个法线指向相同方向，则点值为1。
		如果两个法线指向相同垂直，则点值为0。
		如果两个法线指向相反方向，则点值为-1。

	- Normal Map Node		法线贴图着色器节点

		法线贴图节点从 RGB 法线贴图图像生成扰动法线。它通常与颜色输入中的图像纹理节点连接，以指定法线贴图。对于切线空间法线贴图，图像的 UV 坐标必须匹配，并且图像纹理应设置为非彩色 模式以提供正确的结果。

	- Vector Displacement	矢量置换着色器节点
	- Vector Transform		矢量变换着色器节点

- Converter 转换器节点

	- Blackbody Node		黑体着色器节点

		Blackbody 黑体着色器节点，它可以将黑体温度转换为 RGB 值，用于材料发射自然光，只需要给它一个温度值，就可以输出对应温度的光。将温度 Temperature 设置为 4500。同时将场景的灯光对象改为 Sun 光类型，设置强度 Strength 4，这样可以让场景的模型的背光面具有热辐射状态下的红火质感，向光面呈现皮肤的通透感。

	- Clamp Node			钳制节点
	- Color Ramp Node		颜色渐变着色器节点
	- Combine/Separate		合并/分离着色器节点
	- Map Range Node		映射范围节点
	- Math Node				运算节点
	- RGB to BW Node		RGB -> BW 着色器节点
	- Shader To RGB			Shader --> RGB着色器节点 仅限 Eevee 引擎
	- Vector Math Node		矢量运算节点
	- Wavelength Node		波长着色器节点



## 👉 Principled BSDF 原理化材质模型

最新 Blender 提供了基于 BSDF 模型的通用着色器 Principled BSDF，通过它几乎可以定义任何类型的材质。

原理化 BSDF 着色器节点是默认的基本材质节点，它将多个节点组合成一个易于使用的节点。基于物理的渲染
PBR - Physically Based Rendering 技术，自迪士尼在 SIGGRAPH 2012 上提出了著名的迪士尼
Disney Principled BRDF 之后，由于其高度的易用性以及方便的工作流，已经被电影和游戏业界广泛使用。

与其他软件兼容，如皮克斯的 Renderman® 和虚幻引擎®。SubstancePainter® 等软件绘制或烘焙的图像
纹理可以直接链接到此着色器中的相应参数。

该着色器节点包含多个层，可以创建各种各样的材质。基础层为漫反射，金属度，次表面散射和透射。除此之外，
还有镜面层，光泽层和透明涂层。Blender 文档中有示例图片，展示了原理化 BSDF 着色器节点中的各参数间
的相互影响所呈现的图形效果。

Principled BSDF 这个模型将物体按表面光的反射、折射与吸收等物理特性分成电介质 Dielectrics、
金属物质 Metals，对光学特性影响上考虑了 Fresnel 菲涅尔效应、 粗糙度、 金属性。

Fresnel 效应解析光波通过不同介质的分界面时发生反射和折射，入射光分为反射光 Reflection 和折射光
Refraction 两部分。浅入射角获得的反射光更多，比如看湖面反射的景物倒影，远处比近处的倒影清晰明亮，
还有看一颗金属球，球体的圆周更明亮。

电介质对光的反射、折射和金属只对光线反射的特性是明显的差别，一般 Metallic 金属度设置为 0 或 1 
对应电介质和金属两类材料，不使用中间值，基本没有非金属和金属材料模型之间的混合材料。数值为 1.0 时，
表示使用基础色着色的完全镜面反射 Specular，且不含有漫反射 Diffusion 或透射 Transmission，
透射是入射光经过折射穿过物体。而对于金属表层的异物，如锈斑 Rust 的处理，就等价为电介质的覆盖。 

衍射（Diffraction），又称绕射，是指波遇到障碍物时偏离原来直线传播的物理现象。

物体的粗糙度对光反射有很大的影响，但是 Fresnel 效应一直存在，即使是没有镜面反射的木球的周边也更亮。

Principled BSDF 提供了完整的材料属性，每个属性在特定的材料中才有效果，比如次表面散射 Subsurface 
相关的属性 SSS 与光路的折射有关，对于金属材料是没有效果的，同样透射 Transmission 相关属性也对
金属无效。对于不透明的材料 Transmission = 0，那么折射率 IOR - Index of Refraction 就是无效属性。

光泽 Sheen 属性适合 Fabric 织物类无镜面反射的材质。

清漆 Clearcoat 适合物体表层的光泽，如用于汽车油漆等材质的模拟。

各向异性 Anisotropic 通常搭配 Tangent 切向用于丝线、条纹的梳理，如布料的线条光影、煎锅底部的圆圈条纹。

通过法向的控制来控制不同观察角度的光影效果是很基础且重要的技术，Normal 法向控制基础图层的法线方向，
Tangent 切向控制各向异性图层的法线方向。

在 Blender 中，凹凸贴图通过图片纹理 Image Texture 加载，再经过 Normal Map 得到法向输出，
最后接入着色器。而置换贴图 Displacement Mapping 则直接通过图片纹理 Image Texture 加载接入
Material Output 节点的 Displacement 端口。一般，模型表面的细微凹凸可以用 Bump Mapping 或
Normal Mapping，如墙面，而高起伏的纹理，如地形则可以使用置换的方法处理，置换贴图或模型修改器。

提示：材质在使用带 Alpha 通道的贴图时，比如背景透明的叶子贴图，在侧栏设置中的混合模式 Blend Mode
和阴影模式 Shadow Mode 中使用 Alpha Clip 来应用透明通道。可以使用 Import Image as Plane 
来导入纹理贴图，它会自动设置材质连接贴图 Alpha 通道，并设置 Blend Mode。

Blender 中可以利用  Texture Paint 模式对模型的 Bump 贴图进行绘制。

总结一下金属材质的 5 大要素：

- Base Color 基础色
- Metallic 金属度
- Roughness 糙度
- Clearcoat 清漆
- Normal 法向

玻璃材质的 4 大要素：

- Base Color 基础色
- Transmission 透射
- IOR 折射率
- Specular 高光
- Roughness 糙度
- Clearcoat 清漆

光滑白陶瓷材质，设定固有色为白，然后降低粗糙度参数，配合次表面 SSS 增加材质的半透明。


所有这些属性除了直接设置一个值，还可以通过贴图赋值，如 Base Color 通过贴图赋值，那么，贴图上的
黑色比白色辉光明显，因为辉光就是颜色在数值上和白色一样越大越亮，所有白色得存在覆盖得辉光效果，而
黑色在数值上是 0，叠加任意鲜艳得色彩都会很明显。

金属输入端为例，贴图上的黑色相当电介质，那么对金属的发射特性具有抑制作用，白色相当全反射的金属面。
相比 Eevee，在 Cycle 引擎上，黑色会被 Base Color 指定的颜色覆盖。反过来白色会作为金属色覆盖
Base Color 中的深色。可以使用 Alpha 透明来设置金属材质的表面电解质。

对于 Specular 辉光，贴图的黑色表示脏斑不具有反光能力。

通过包装原理化 BSDF 可以得到衍生的材质，比如 Emission 发光体就可以看作是 Principled BSDF 
与 Bright/Contract 组合，通过亮度控制发光体强度。又如 Glass BSDF 玻璃材质可以通过原理化 BSDF
设置合适的 浅色为基础色、 透射、 折射率、 高光、 糙度、 清漆 得到，注意不要混入金属性。

在物理学中定义的法线就是过入射点垂直于镜面的直线，渲染引擎在着色时就按光学原理，根据法向来渲染出光影。
对于立体表面而言，一般来说，由立体的内部指向外部的是法方为正即内法线，反过来的是法向为负。对于曲面，
法线直观讲就是切平面的垂线，但是这个垂线的位置是比较特殊的，要过平面和曲面的交点。

对于一个 Cube 方块模型而言，每个面的法线只有一个正法向，对同一观察角度，光线入射后计算得到的颜色值
始终一致，它最终的渲染效果将会非常单一，并不能模拟现实环境中如墙面凹凸痕迹，为了改变法线单调性，
通过法线贴图、视差贴图来增加模型细节层次显得非常实用。这些贴图技术也是一种用来降低模型面数的技术。

把墙面的每个像素与法线贴图的像素映射起来，渲染的时候根据每个像素的法线确定他们的阴暗程度，那么模型的
一个面就可以拥有大量的光影细节，同时又不必增加模型的面数降低了模型的复杂度。实现同样的光影效果的前提下，
使用法线贴图比增加模型面数更有效地利用 CPU 的计算能力，贴图就是利用存储硬件的价格优势来替代 CPU 算力。
因为计算光线的公式保持一致，面数有不需要增加，只是需要读取存储在法线贴图像素的矢量值。

法线贴图在材质表现中起到了很大的作用，但并非所有材质都需要，比如光滑的油漆表面不需要贴图，但能看到
木纹的清漆表面则需要贴图。

在三维控间的法线是矢量，而法线贴图中的像素的 RGB 三个分量可以当成一个 XYZ 向量储存，RGB 分量的
范围 0 - 255 对应法向量分量 -1 - 1。在 3D 世界空间 World Space，每个面的朝向不同，法线指向
也不同，一个可行方案是为每个表面制作一个单独的法线贴图，那么一个立方体就需要 6 个法线贴图。但是如果
模型上有无数的朝向不同方向的表面，同时模型对象只有位置变换，那么各个面的法向就会改变，原来的法线贴图
就不能用了，这个方法显然不行，贴图的数量会把磁盘空间吃掉。

实际上对于复杂模型可以把朝向各个方向的法线储存在同一张贴图上，你可能看到过不只是蓝色的法线贴图，
不过用那样的法线贴图有个问题是你必须记住模型的起始朝向，如果模型运动了还要记录模型的变换，非常不便。

另一个解决方案是，切线空间 Tangent Space，这个坐标空间里，法线贴图中保存的向量总是指向 +Z 方向，
所有的法线向量都相对与这个 +Z 方向进行变换，这样我们就能始终使用同样的法线贴图，不管朝向问题。

这种法线贴图产生的色调是偏蓝色的，因为所有法线的指向都偏向 Z 轴（0, 0, 1），也就是 RGB 像素的
蓝色分量为主色调。法线向量从 Z 轴向其他方向轻微偏移，就控制模型表面法线的偏移。算法上使用一个特定
的矩阵就能将切线空间中的法线向量转成世界或视图坐标，使它们转向到最终的贴图表面的方向。

切线空间的一大好处是我们可以为任何类型的表面计算出一个这样的矩阵，由此我们可以把切线空间的 z 方向
和表面的法线方向对齐。这种矩阵叫做 TBN 矩阵，代表 Tangent 切线、 Bitangent 副切线和 Normal，
这是建构这个矩阵所需的向量。

打开法线贴图，其像素颜色大概对应的方向，手绘法线贴图可以参考：

- (0.0, 0.0, 1.0) 平面垂直向外，蓝色；
- (0.5, 1.0, 0.6) 指向南边，浅绿；
- (1.0, 0.5, 0.6) 指向东边，粉红；
- (1.0, 0.0, 0.6) 指向北边，紫红；
- (0.0, 1.0, 0.6) 指向西边，青色；

只要面法向带蓝色，那么法线就是朝外的，正常。不带蓝色分量，变红色是朝内的。

检查网格法线问题可以打开 Viewport Overlays -> Face Orientation 查看哪些面有问题，看法线颜色。
如果不正常，按 Alt-N 执行 Normals -> Flip 翻转法线就可以了，这样的贴图才会朝外显示。

在编辑模式下查看单个面的法向量，可以选择网格面后，使用移动工具，打开 Transform Orientations 
选择 Normal，这样就可以直接看到网格法向量。主要检查其 Z 轴朝向，它指示了法向。

三点确定一个平面，同时它的法向也是确定的，为了让模型看起来更平滑，可以在顶点上设置法向 
Object -> Shade Smooth。


除了专用的法线贴图生成工具如 CrazyBump，Blender 本身也可以将模型的法线贴图单独渲染出来，一般是
将高模即高面数细节丰富的模型的细节烘焙到法线贴图上，然后通过法线贴图就可以在低模上模拟除丰富的细节。
比如有一张现成的砖墙纹理图片，结合置换 Displace 修改器来生成高模，相当于将砖墙纹理图片作为置换贴图
Displacement Mapping 来生成模型的表面凹凸细节，然后再通过 Cycle 渲染器的烘焙功能生成法线贴图，
烘焙前给这个生成的高模设置一个空贴图用来保存烘焙结果，步骤如下：

- 场景中添加一个平面 Plane 准备利用纹理图片置换生成高模；
- Ctrl-3 给平面对象添加表面细分修改器 Subdivide，不够可以再添加一个或加大细分段数以达到高模的细节要求；
- 添加一个置换修改器 Displace；
- 将纹理图片加载到置换修改器上，增加一个 Texture 纹理即可，可以根据需要调整纹理坐标，默认是 Local，置换方向使用默认的 Z 轴就可以；
- 再转到纹理属性面板 Textures Properties，选择上一步创建的纹理对象，使用默认的 Image or Movie 类型，设置 Image 面板的文件路径；
- 可以通过纹理属性中的 Colors 面板调整纹理的亮度 Brightness、 对比度 Contrast、 饱和度 Saturation；
- 调整置换修改器的强度 Strength，以模型凹凸纹理清晰平滑为标准即可。

通过以上的置换修改器等到高模后，再给 Plane 设置材质，可以打开材质编辑器操作，也可以通过材质属性面板操作：

- 转到材质属性面板，保持 Plane 对象选中，点击 + New 新建材质；
- 设置 Base Color 属性，点击其右侧的圆点关联一个图片纹理 Image Texture，它是用来接后烘焙结果的；
- 点击图片纹理的文件选择框中的 + New 新建一个纹理文件即可，指定文件名如 normal_bake，不需要其它设置；

设置好高模后，接下来就可以使用 Cycle 渲染引擎烘焙法线贴图了：

- 属性编辑器中，Render Properties 渲染引擎设置为 Cycle；
- 在 Bake 烘焙面板中选择烘焙法线 Bake Type - Normal，空间类型可以选择切线空间 Tangent 或对象空间 Object。
- 使用 UV Editor 或图片编辑器查看烘焙的法线贴图文件。

材质编辑器中将法线贴图文件连接到起来观察效果，使用 Image Texture 载入纹理文件，通过 Normal Map
节点连接 Principled BSDF 着色器的 Normal 输入端口。 

使用这个方法可以给纹理图片生成法线贴图，通过法线贴图来增强低模的细节，但是这种方法生成的法线贴图
不是很准确。也不太可能人工绘制法线贴图，细节太多了，必须通过软件进行转化而来，如 CrazyBump 就可以
灵活自如从图片中生成法线贴图，还有 Substance Bitmap2Material、 Knald、 xNormal 等等。


高模转低模，也可以将高模的细节烘焙到法线贴图，按高模的复杂度进行不同的处理，以简单的地势模型为例：

- 首先低在上、高模在下，沿 Z 轴摆放；
- 先给低模设置材质，通过材质编辑器添加一个图像纹理节点接口，新建纹理文件并设置好纹理文件名，不用连接即可；
- 选择高模模型，再选择低模；
- 将渲染器改为 Cycle，勾选烘焙面板中的 Selected to Active 选择作为活动物体；
- 如果低模在下方摆放，那么到高模的距离不要超过 Ray Distance 指定的距离，如果超过，烘焙结果则会对高模中超过距离的位置进行裁切；

如果对一个复杂的模型进行烘焙，那么可以用一个罩体 Cage 围住低模和高模，勾选 Cage 并指定罩体进行烘焙。
Selected to Active 能烘焙所选物体的着色到活动物体，光线会从外面的低模物体投射到内部的高模物体。
倘若高模物体没能被低模物体完全包裹，通过调节光线距离或是罩体挤出 (取决于你是否使用罩体)来调节光线的起点。


参考资料：
- 法线贴图烘焙 https://www.bilibili.com/video/av55915594/
- Real-Time Rendering Fourth Edition https://pan.baidu.com/s/13OWXszPrjG0KxhIqR1srOQ#a1p7
- Opengl 教程 Tutorial 13 : Normal Mapping http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/



Principled BSDF 提供以下选项及属性：

- Distribution 分布，使用微表面分布。

	- GGX

		比多重散射 GGX 渲染速度快，但不够精确。选择它后，可以启用透射粗糙度 输入选项。

	- Multiple-scattering GGX 多重散射 GGX

		会计算微平面之间的多次反弹和散射。这样就可以使物体不会因为过度变暗而显得突兀。

- Subsurface Method 次表面渲染方式，模拟次表面散射的渲染方式。

	- Christensen-Burley 克里斯坦森-伯利

		基于物理学中的体积散射得到的近似值。与立方函数和高斯函数相比，计算结果精度较低。
	
	- Random Walk 随机游走

		对薄物体和弯曲物体的计算结果较理想。这是以增加渲染时间或噪点为代价，来使密集的
		介质(如皮肤)获得较好的渲染效果，并且可以更好保存物体的几何细节。随机游走模式在
		网格内部使用真正体积散射，这意味着它更加适用于闭合网格。 网格中的重叠面和孔
		可能会导致渲染出现问题。

- Base Color 基础色，漫反射 Diffusion 或金属 Refraction表面颜色。
- Subsurface 次表面，漫反射 Diffusion 和次表 Refraction面散射之间的数值进行相乘运算混合。
- Subsurface Radius 次表面半径，光散射到表面下方的平均距离。较高的半径可以使外观更柔和，因为光线会流入阴影区域并穿过物体。
- Subsurface Color 次表面基础颜色。
- Metallic 金属度，非金属和金属材料模型之间的混合。数值为1.0时，表示使用基础色着色的完全镜面反射，且不含有漫反射 Diffusion 或透射 Refraction。
- Specular 高光，非传导性高光反射量。表面沿法线方向的反射率常设定在 0-8％ 范围内。
- Specular Tint 高光染色，使用基础色对朝向面进行高光反射，而镜面反射保持白色。普通电介质具有无色反射，因此该参数在技术上并不具有物理学上的正确性，但可用于模拟具有复杂表面结构的材质外观。
- Roughness 糙度，用于确定漫反射 Diffusion 和镜面 Refraction反射时，物体表面的微平面粗糙度。
- Sheen 光泽，边缘附近类似天鹅绒材质的反射数量，用于模拟布料等材质。
- Sheen Tint 光泽染色，在白色和基础色之间进行混合，以获得光泽反射效果。
- Clearcoat 清漆，物体表层的白色高光层，适用于汽车油漆等材质的模拟。
- Clearcoat Roughness 清漆的粗糙度。
- IOR 折射率 Index of Refraction。
- Transmission 透射，数值设定为 0 时，表面完全不透明；数值设定为 1 时，表面为玻璃状。
- Emission 自发光，来自表面的自发光，与自发光着色器类似。
- Alpha 控制表面的透明度，数值设定为 1.0 时，表面完全不透明。通常连接到图像纹理着色器节点的 Alpha 输出接口。
- Normal 法向，控制基础图层的法线方向。
- Clearcoat Normal 清漆法线，控制清漆图层的法线方向。
- Tangent 切向，控制各向异性图层的法线方向。
- 仅适用于 Cycles 引擎输入项
	- Anisotropic 镜面反射的各向异性量。较高的设定值可提供沿切线方向的细长高光；设定为负值则会给出垂直于切线方向的高光。
	- Anisotropic Rotation 旋转各向异性的方向，取值为 1.0 时，旋转一周。
	- Transmission Roughness 透射粗糙度，与微表面分布函数 GGX 模型一起，用于控制透射光的粗糙度。



## 👉 Material & Texture
[Cycle 材质教程](https://www.bilibili.com/video/BV1p741147fh)

CG - Computer Graphics 领域中，材质与纹理 Material & Texture 是两个基本概念，在一般的实践中，
大致上的层级关系是 Material 包含贴图 Mapping，贴图包含纹理 Texture。纹理是最基本的数据输入单位，
游戏领域基本上都用的是位图。

贴图的英语 Mapping 其实包含了另一层含义就是映射，其功能就是把二维的纹理图片通过 UV 坐标映射到 
3D 物体表面。贴图坐标指定如何在几何体上放置贴图、调整贴图方向以及进行缩放。贴图坐标以 U、V 和 W 指定，
其中 U 是水平维度，V 是垂直维度，W 是可选的第三维度，它指示深度。

贴图可以说是最简单的材质方法，给选定物体表面的某些区域赋予一张二维图片就可以很好地通过算法模拟出
真实世界的物理属性，如颜色、粗糙度、反光度、透明度等。而最简单的贴图是位图文件，其他有 2D/3D 贴图，
按程序生成。

计算机通过 Material & Texture 来模拟表现真实可信的光影效果，渲染出 CG 图形，这个过程关于光线
和颜色部分表达为 Shading 完成这个过程的程序成为着色器 Shaders。材质是一个数据集，主要功能就是
给渲染器提供数据和光照算法。贴图就是其中数据的一部分，根据用途不同，贴图也会被分成不同的类型，比如
Diffuse Map，Specular Map，Normal Map 和 Gloss Map 等等。

另外一个重要部分就是光照模型 Shader ，用以实现不同的渲染效果。

- 渲染 Render 从模型生成图像的过程。说白了就是把三维场景特殊数据格式计算，转化为位图图像或图像序列的过程。（XYZ到XY，从三维到二维）。
- 渲染器 renderer 实现渲染算法（mental ray ,vray，Arnold)。主要两类：一个光线跟踪，一个是光能传递。
- 着色器 shader 是可以直接在 GPU 上运行的程序。是一组提供计算机图形资源在执行渲染时使用的指令，负责计算目标颜色。

GPU 流水线中有一系列着色流程，其中顶点着色器，片段着色器可以相对自由地编程。

Shading 是真实世界中的光影效果，它是由物体表面材质、灯光、观察者的视角等多种因素共同决定的。要实现
计算机的模拟生成，是一个非常复杂的过程。不过它的原理大概可以简化为一个函数：

	Intensity = Material (Light, Eye)

也就是说，光影的强度，是由照在材质上的光线及视线共同决定的。

例如一个木制球体和一个玻璃球的材质差别可以明显观察到外观的不同，其材质属性差别主要体现在物体对光线
的漫反射 Diffusion 和反射 Reflection，还有透明度 Transparent 差异上，木球完全是漫反射，
而玻璃在较小的光线入射角是则是高反射。漫反射的反面是镜面反射，反射的反面是对光线的吸收。

漫反射 Diffusion 和反射 Reflection 是描述光与表面作用的两个基本术语，光是一种横向传播的电磁波，
电磁波的波长范围非常广，但只有 390 ~ 760nm 之间的一段波谱是人眼可见到的，也就是在图形学里对渲染
着色起作用的部分。另外因为光有波粒二象性的缘故，有时候我们在图形学里也会把光做为光子 photon 来处理。

当一束光投射到表面上时，其中一些会发生反射——即在表面法线另一侧射出的光线。这个行为跟球从地面或者
墙壁上弹回来很像。在一个光滑的表面，这使得表面看起来像镜子。镜面 Specular 一词经常用来描述这个效果，
词源来自于拉丁文 mirror，即镜子的意思。

然而，并不是所有的光都从表面反射出去，有些光会渗透到被照明物体的里面。其中有些光被物体材质吸收 
absorption，通常转化成热量。当非均匀物质内部的折射率非常突然的时候，这时就会发生 Scattering 散射现象，
光会被分割为多个方向，但光的总量并不会发生变化。这些被散射的光有一部分最后从表面再射出来，从而被眼球
或者摄像机看见。我们知道有很多名次来形容这个现象，漫反射，表面散射都是一个意思。

对于不同波长的光，不同物体的漫反射和散射行为通常会有很大差异，这就是为什么物体会看起来有不同的颜色。
比如，一个物体吸收大部分除了蓝色波长的光，那么它看起来是蓝色的。散射往往是如此的混乱、均匀，我们可以
认为各个方向看上去都一样，这点和镜面完全不同。

一个着色器在实现这种近似效果时，只需要一个输入：“albedo”，它用来描述各种颜色的光照射表面并散射出去
时的颜色。我们有时候也叫做“漫反射颜色（Diffuse color）”。

设置折射贴图和光线跟踪所使用的折射率 IOR - Index of Refraction。 1.0 是空气的折射率，这表示
透明对象后的对象不会产生扭曲。折射率为 1.5，后面的对象就会发生严重扭曲，就像玻璃球一样。
对于略低于 1.0 的 IOR，对象沿其边缘反射，如从水面下看到的气泡。

常见的折射率为（假设摄影机在空气或真空中）：

	材质		IOR 值
	真空		1.0（精确）
	空气		1.0003
	水		1.333
	玻璃		1.5（清晰的玻璃）到 1.7
	钻石		2.418

在物理世界中，IOR 为灯光穿过透明材质与观察者用眼睛或摄影机观看时所在介质的相对速度。通常这与对象
的密度有关；IOR 越大，对象的密度越大。


物质还可能因为其他能量发出新的光，即自发光 emission。

总之，光与物质交互的三种方式，吸收，散射，发光。

Physically Based Rendering（基于物理渲染），是基于现实物理规律进行计算机的仿真，而这一趋势最终
也将统一影视、游戏、跨软件之间的协同。


PBR 的一些关键因素。

- 能量损耗。 反射的光线不会比第一次碰到表面时的光线更亮。 耗能由着色器处理。
- 菲涅耳。 BRDF 由着色器处理。 对于大多数常见的电介质，F0 反射率值具有最小的变化，落在2％-5％的范围内。 金属的 F0 是70-100％的高值。
- 通过双向反射分布函数 BRDF，粗糙度或光泽度图和 F0 反射率值来控制镜面强度。
- 照明计算在线性空间中计算。 所有具有伽马编码值（如基色或漫射）的地图通常都会被着色器转换为线性。

可能必须通过在游戏引擎中导入图像时检查相应的选项来确保转换正确完成，或者渲染器。 描述表面属性
（如粗糙度，光泽度，金属和高度）的图应设置为线性。

菲涅耳效应模拟的就是物体材质反射率随角度改变的效果，如肥皂泡在边缘处，即视线与表面夹角处比较小时，
反射效果更强烈；在肥皂泡中心附近，即视线与表面夹角近乎垂直时，看起来更透明一些。

通用材质物理属性
- Ambient Color 基本环境色
- Deffuse Color 漫反射色
- Refaction 折射
- Glossiness 辉光
- Specular Color 高亮
- Self-Illumination/Emmiting 自发光
- Filter Color 过滤色
- Bump/Roughness 粗糙度
- Metallic 金属化
- Fresnel 菲涅尔效应
- Transparent/Opacity 透明度
- Sub-Surface Scattering 表面散射


8 着色纹理还原现实材质

- Shader 着色器
- Texture 纹理
- BW Map 黑白图的作用
- Base Color Map 基本色纹理
- Metallic Map 金属度纹理
- Roughness 粗糙度纹理
- Normal Map 法线纹理
- Displacement Map 置换纹理


## 👉 Lights 光照

Blender 场景中默认的灯光是点光源，并开启了一些环境光的，这是 Cycles 和 Eevee 的默认光照。和 Cycles 不一样，Eevee 灯光的尺寸不会改变阴影的柔化程度。在 Eevee 中除了设置灯光，更多是使用 Light Probe 对象以提升光线的处理效率。

还可以可以通过光源对象属性面板修改类型，或调整世界属性面板的环境光。

光照对象有以下四种：

- Point Light 

	点光源是一种全方向的光，如一个灯泡，向各方向辐射相同数量的光，光线照射到物体表面的方向由光线和物体表面上的点之间的连线决定的。光强度能量从发光点到物体的距离衰减，换句话说，表面离得越远就会被渲染得越暗。

- Spot Light 

	聚光灯，给定的方向上提供光照，从圆锥体的尖端发射圆锥形状的光线。

- Area Light 

	区域光，模拟来自表面发射的光，例如屏幕、霓虹灯、窗户或多云的天空只是几种类型的区域灯。

- Sun Light 

	太阳光，太阳光与点不同，距离足够远，在地球上认为太阳光是平行光。无论太阳光对象放置于何处，其光线总是平行得，只是物体靠的越近接受得光就越强。


光线类型可分为四类:

- 相机，光线直接从相机发出。
- 反射，由表面反射而产生的光线。
- 透射，由穿透表面而产生的光线。
- 阴影，光线用于(透明)阴影。

反射和透射光线还具有以下特性：

漫射：光线由漫反射或透射(半透明)产生。
光泽：光线是由光泽镜面反射或透射产生的。
单一：光线是由一个完美的反射或透射产生的。

除了来自背景照明和任何具有发光着色器的对象外，灯光是将光线添加到场景中的另一种方式。不同之处在于它们在渲染图像中不是直接可见的，并且可以更容易地作为它们自己类型的对象进行管理。

光程节点 Light Path 可用于找出正在为其计算着色的光线类型。


光线照射到不同的模型上，根据其材质配置对光线有不同的作用。还可以在对象的属性面板中配置对象可视属性，Object Properties - Visibility：

- Show in Viewports 是否在视口显示
- Show in Renders 是否需要渲染
- Selectable 是否可选中
- Shadow Catcher 阴影捕捉 使对象只能接收阴影。需要注意的是，阴影捕捉物体将通过间接光交互与其他CG物体交互。这项功能使它很容易结合 CGI 元素到现实世界的镜头。
- Holdout 阻隔
- Ray Visibility
	- Camera 相机 使物体在相机光线中可见。
	- Diffuse 漫射 使物体在漫射光线中可见。
	- Glossy 光泽 使物体在光泽光线中可见。
	- Transmission 透射 使物体在透射光线中可见。
	- Volume Scatter 体积散射 使物体在透射光线中可见。
	- Shadow 阴影 使物体能够投射阴影。


## 👉 HDRI Environment Texture

世界环境设置 World Environment，可以根据不同的场景设置气氛合适的环境色调，这是一种基于图像的照明。
注意，如果你希望环境光是其他颜色，需要设置合适的强度，天光的整体感觉要弱于阳光。

- Surface 着色器，默认 Background 着色器
- Color 环境色彩，默认是灰色 Color 0x404040
- Strength 强度，默认 1.0

环境光可以设置出大致的光效果，但是，这种方法还不能真实模拟世界光环境。现实生活中的环境有各种光，
有太阳直射光，还有各种物体的反射光、折射光，它们都具有不同的色调属性。

虽然 3D 场景的渲染功能本身就可以形成光色影响，但是出于效率问题，不可能把环境中所有的物体都建模出来。
一个变通的方法是，利用高动态范围 HDR - High-Dynamic Range 贴图模拟光照。简单说，就是利用超高
解析度和颜色、亮度的图片纹理，在一个球体上进行贴图以模拟一个全角度的世界全景环境。目前普通的图片都是
由 RGB 红、绿、蓝三原色组成的，这是针对 CRT 显示器显示的图像而制定的规范。计算机在表示图象的时候是
用 8bit 或 16bit 数据来存储图象的色彩像素信息，但这区区几百万色彩无法再现真实自然的光照情况，所以
必须使用 HDR 高分图。

Blender 在 Studiolights 目录下自带 HDRI 贴图，在 Meterial Preview 视图模式时会自动加载。
使用 OpenEXR 软件的 EXR 格式文件，OpenEXR 是由工业光魔 Industrial Light & Magic 开发的
一种 HDR 标准。

要使用环境贴图，在材质编辑器中选择 World，并为输出节点连接一个 Background 节点，再为其 Color
端口提供一个 Texture - Environment Texture，这个操作会给环境色添加纹理对象。点击环境贴图的
Open 按钮加载一张环境贴图文件，当然，环境贴图可以是一张图片，也可以是图片序列、视频等。

根据机器性能选用不同的分辨率，2K 也可以，4K 更好，8K 目前算比较适中，如果能上 8k、 16k 那就太好
不过了。i7-8650U + 8765GTX 1050 GPU + 16GB 配置加载个 4K 没问题。因为环境光贴图在场景渲染
输出的只是渲染区选中的部分，所以渲染区指定的尺寸和 HDR 贴图选中的部分像素匹配时，清晰度才高。如果
 HDR 选中区域的像素不足，那么就进行放大匹配，这就失真了。

世界环境也可以通过材质编辑器修改，Shift-F3 打开材质编辑器，将视图模式从 Object 更改为 World，
可以看到材质编辑器的 3 个节点和世界环境属性界面的属性项是一致的，World Output 表示世界环境材质
输出节点。

通过环境光贴图的 Color Management 属性面板可以控制曝光度，对与同一张 HDR 日照图，可以通过调整
动态调整曝光度来模拟日落或日出。对应场景内不同的光线环境，环境贴图会执行 Dynamic Exposure。

还可以体验镜头景深效果，设置摄像机属性面板 Depth of Filed，将光圈调小增加景深的效果 Aperture 
F-Stop 设置 1.0 试试。在对焦物体 Focus Object 指定景深需要包括的对象，也可以悬浮光标到 
Distance 上，按下快捷键 E 来捕捉目标物体的距离。

添加环境光照贴图后，3D 场景内的模型也会渲染得到正确的环节色，渲染场景更加真实。当然，使用环境贴图
也有一些局限性，环境贴图中的阳光照射方向是无法改变的，要么调整场景内的视角，要么调整贴图的方向。
可以使用不包含阳光直射的 HDR 贴图，然后自己添加一个阳光光源来模拟。

这里使用到一个 Blender 自带的插件，它可以提升材质编辑器的节点自动连接，在喜好配置中加载节点辅助插件，
点击菜单栏 Edit - Prefrences - Add-ons，搜索 Node Wrangler，勾选它，保存设置。

节点编辑辅助插件快捷键功能参考如下，完整列表见插件 Hotkey List。

- Ctrl-Shift-LMB 预览节点。
- Ctrl-T 自动添加并连接相关节点 Add Texture Setup，直接调出 Mapping 变换节点，对 UV 调整时必须。
- Alt-RMB 快速链接节点，从一个节点拖动到另一个节点即可，拖鼠标靠近节点也可以，Alt-Shift-RMB 可以显示备选菜单。
- Alt-R 重新加载图片。
- Alt-Shift-RMB 拖动鼠标，可以显示输入和输出的菜单，以便进行更准确的连接。
- Alt-S 选择两个具有链接到其输出的节点按进行交换输出。
- Shift-S 更换选定节点的类型。
- Shift-C 将活动节点的设置复制到同一类型的所有选定节点。
- Shift-P 选择节点将它们包装到框中。
- Ctrl-Shift-T 直接基于 PBR 材质命名赋予材质对应贴图，一次指定 color metal rough bump normal disp。
- 快速混合，选择要混合的节点后在按快捷键 Ctrl 加混合方式 + - * / 0 < > 等，还可以更改混合类型 Alt-↑ 或者 Alt-↓。

选中贴图节点，Ctrl-T 一次添加贴图坐标变换节点 Mapping 和 Texture Coordinate。调整 Mapping
节点中 Point - Rotation 的 Z，让 HDR 贴图沿着 Z 轴旋转。可以看到，环境贴图发生了变化，带来的
投影方向也变了，这就是旋转环境贴图的方法。也可以给 Emission - Color 输入端设置纹理贴图，做出来的
灯光效果相当于广告灯箱。

除了使用内置的光源对象外，还可以通过 Emission 着色器自制光源材质，不过这需要使用 Cycle 渲染引擎
的支持，同时 Emission 着色器也需要大量运算，谨慎使用。点光源和面光源是比较常用的，参考以下步骤：

- 新开一个 Blender 文件，首先设置渲染引擎为 Cycle，添加球体灯泡；
- 打开材质编辑器 Shader Editor，点击 + New 新建一个材质 lightbulb，并给材质 Surface 添加一个 Shader - Emission 发光体着色器；
- 给发光体 Color 设置一个 RGB 色彩就可以当一个灯光使用，根据场景需要设置适当的强度，如 Strength 5.0；
- 给场景添加地板，光源附近添加几何体以观察光影效果，渲染查看结果；

如果使用面光源，那么就需要在模型使用多个材质槽 Slot，至少有两个，第一个材质槽 Slot 1 是给整个
模型设置材质的，其它材质槽可以给指定的面设置材质。选择 Slot 2 材质槽，从材质列表里选择 lightbulb，
然后点击 Assign 将材质槽的材质分配给选中的面即可。

Cycle 引擎支持全景相机，使用 Equirectangular 等距柱状投影就可以将 3D 场景渲染为 HDR 全景，
可以在活动摄像机的属性中修改 Object Data Properties - Lens - Type - Panoramic：

- Equirectangular 等距柱状投影 ERP
- Fisheye Equidistant 等距投射鱼眼镜头
- Fisheye Equisolid 等角投射鱼眼镜头
- Mirror Ball 镜像球


## 👉 Blender Python API

Blender 使用 Python 3.x 脚本引擎，所以要有 Python 编程基础。

在 blend 文件中包含 Python 脚本的功能对于高级任务非常有价值，如绑定和自动化。但是，Python 不限制脚本的行为，因此它会带来安全风险。因此，你应当只运行你知道且信赖的来源的脚本。

Blender 默认关闭了自动运行脚本选项，但是一些 blend 文件需要启用该选项才能正常工作。当 blend 文件试图运行脚本并且未被允许，标题栏将显示信息，并提供允许执行或者忽略该脚本的选项。


下面是一些 blend 文件可能自动运行脚本的方式。

- 注册的文本块，文本数据块可以启用 注册 选项，这意味会在启动时自动加载。
- 动画驱动中的简单 Python 表达式可以用于驱动动画，并且经常在进阶的绑定和动画中使用。

还有一些情况下，blend 文件需要用户交互才能运行脚本，因此禁用自动运行也会运行，但你需要清楚这种情形，因为它不是那么显而易见。

- 在文本编辑器中运行脚本。
- 使用 FreeStyle 渲染，需要使用脚本控制线条样式。

打开 Blender 在需要运行这些复杂或有风险的脚本时，会提示是否许可运行脚本，Allow Execution 或 Ignore，或者勾选 Permanently allow execution of scripts 以配置自动运行脚本。在用户设置中的 Save & Load 选项卡中，提供选项 Auto Run Python Scripts 来确定是否自动运行 Python 脚本。启用后，Blender 就不会再提示是否许可运行有风险的 Python 脚本了。


通过命令行执行批处理渲染或一些其他的任务，也可能要使用脚本的执行，且不使用界面运行 Blender。 这种情况下，前面的用户设置同样适用，不过你也许想要通过命令行参数覆盖该设置：

	-y or --enable-autoexec
	-Y or --disable-autoexec

例如在后台模式渲染动画，允许使用驱动和其他脚本：

	blender --background --enable-autoexec my_movie.blend --render-anim



Text Editor 和 Python Console 都可以运行脚本，安装目录提供了 UI 和操作脚本示例：

	scripts/startup/bl_ui
	scripts/startup/bl_operators

有几种方法将 Python 脚本集成到 Blender：

- 通过定义一个渲染引擎。
- 通过定义操作。
- 通过定义一个菜单、头部、面板。
- 通过插入一个按钮到 Blender 的界面，菜单、头部、面板上都行。

对应类型：

	bpy.types.Panel
	bpy.types.Menu
	bpy.types.Operator
	bpy.types.PropertyGroup
	bpy.types.KeyingSet
	bpy.types.RenderEngine

也可以直接通过命令行执行脚本：

	blender --python /home/me/my_script.py


Blender Python API 可以做的事：

- 编辑所有界面可以编辑的 Scenes, Meshes, Particles 等等；
- 修改用户配置，快捷键，或主题；
- 按自己配置运行工具；
- 创建用户界面元素，如菜单、头部、面板；
- 创建新工具；
- 创建交互工具；
- 创建新渲染引擎；
- 订阅数据或属性的变动；
- 基于现有数据定义新设置；
- 在 3D 视图上绘画；

Blender Python API 不可以做的事：

- 不可以创建新的空间类型；
- 不可以将自定义类型赋值给所有类型；


API 模块有应用模块和独立模块两类：

- Application Modules

	- Context Access	*bpy.context*
	- Data Access	*bpy.data*
	- Operators	*bpy.ops*
	- Types	*bpy.types*
	- Utilities	*bpy.utils*
	- bpy.utils submodule	*bpy.utils.previews*
	- Path Utilities	*bpy.path*
	- Application Data	*bpy.app*
	- Property Definitions	*bpy.props*

- Standalone Modules

	- Math Types & Utilities	*mathutils*
	- Freestyle Module	*freestyle*
	- OpenGL Wrapper	*bgl*
	- Font Drawing	*blf*
	- GPU Shader Module	*gpu*
	- GPU Utilities	*gpu_extras*
	- Audio System	*aud*
	- Extra Utilities	*bpy_extras*
	- ID Property Access	*idprop.types*
	- BMesh Module	*bmesh*


示例，拷贝以下脚本到 Text Editor 上运行，即可在对象的属性面板中创建一个 Hello World Panel 面板。方法 draw 会在需要的时候将面板绘制出来，点击面板上的 Add Cube 按钮就可以在视图中添加模型，这个按钮事通过 mesh.primitive_cube_add 标签定义的一个操作：

	import bpy


	class HelloWorldPanel(bpy.types.Panel):
	    """Creates a Panel in the Object properties window"""
	    bl_label = "Hello World Panel"
	    bl_idname = "OBJECT_PT_hello"
	    bl_space_type = 'PROPERTIES'
	    bl_region_type = 'WINDOW'
	    bl_context = "object"

	    def draw(self, context):
	        layout = self.layout

	        obj = context.object

	        row = layout.row()
	        row.label(text="Hello world!", icon='WORLD_DATA')

	        row = layout.row()
	        row.label(text="Active object is: " + obj.name)
	        row = layout.row()
	        row.prop(obj, "name")

	        row = layout.row()
	        row.operator("mesh.primitive_cube_add")


	def register():
	    bpy.utils.register_class(HelloWorldPanel)


	def unregister():
	    bpy.utils.unregister_class(HelloWorldPanel)


	if __name__ == "__main__":
	    register()


示例，定义一个操作，因为没有将操作关联到任何界面，所以需要通过 Edit - Menu Search 来查找 Operator Simple 来执行：

	import bpy


	def main(context):
	    for ob in context.scene.objects:
	        print(ob)


	class SimpleOperator(bpy.types.Operator):
	    """Tooltip"""
	    bl_idname = "object.simple_operator"
	    bl_label = "Simple Object Operator"

	    @classmethod
	    def poll(cls, context):
	        return context.active_object is not None

	    def execute(self, context):
	        main(context)
	        return {'FINISHED'}


	def register():
	    bpy.utils.register_class(SimpleOperator)


	def unregister():
	    bpy.utils.unregister_class(SimpleOperator)


	if __name__ == "__main__":
	    register()

	    # test call
	    bpy.ops.object.simple_operator()


对关键帧的操作：

	# Simple example:
	obj = bpy.context.object
	obj.location[2] = 0.0
	obj.keyframe_insert(data_path="location", frame=10.0, index=2)
	obj.location[2] = 1.0
	obj.keyframe_insert(data_path="location", frame=20.0, index=2)


	# Using Low-Level Functions:
	obj = bpy.context.object
	obj.animation_data_create()
	obj.animation_data.action = bpy.data.actions.new(name="MyAction")
	fcu_z = obj.animation_data.action.fcurves.new(data_path="location", index=2)
	fcu_z.keyframe_points.add(2)
	fcu_z.keyframe_points[0].co = 10.0, 0.0
	fcu_z.keyframe_points[1].co = 20.0, 1.0


# 🚩 CMD Line

命令行参数

	Blender 2.82 命令行用法: Blender [args ...] [file] [args ...]

渲染选项

	-b, --background 		在后台运行渲染(通常用于无需UI的渲染)。
	-a, --render-anim 		渲染从开始到结束帧(包含最后帧)。
	-S, --scene <name> 		设置要渲染场景 <name>。
	-f, --render-frame <frame> 		渲染某一帧 <frame> 并保存。
	
		+<frame> 相对起始帧， -<frame> 相对结束帧。
		还可以使用逗号隔开组成帧列表(无空格) 
		在首末帧之间加 .. 隔开，表示包含首尾的帧范围。

	-s, --frame-start <frame> 		设置起始帧为 <frame>, 支持 +/- 设置相对帧。
	-e, --frame-end <frame> 		设置结束帧为 <frame>, 支持 +/- 设置相对帧。
	-j, --frame-jump <frames> 		设置帧步长。
	-o, --render-output <path> 		设置渲染路径和文件名。

		在路径起始位置使用 // 设置渲染路径为当前blend文件的相对路径。
		# 会被替代为帧序号，不足位补零。

		animation_##_test.png 变成 animation_01_test.png

		test-######.png 变成 test-000001.png

		如果文件名不包含 # , 默认为文件名添加后缀 #### 。

		那么渲染器保存文件名的时候,就会把帧号添加到文件的结尾,如:

		blender -b animation.blend -o //render_ -F PNG -x 1 -a
		//render_ 会变成 //render_####, 帧会写成 //render_0001.png

	-E, --engine <engine>		指定渲染引擎, 使用 -E 查看所有可用渲染引擎列表。

	-t, --threads <threads>		渲染或其他操作使用线程数量， <threads> 填写1-64就是线程，0表示使用CPU全部线程。


格式选项

	-F, --render-format <format>
	设置渲染格式。有效选项有: TGA RAWTGA JPEG IRIS IRIZ AVIRAW AVIJPEG PNG BMP

	可以编译到Blender中的格式如下，但并非在所有系统可用: HDR TIFF OPEN_EXR OPEN_EXR_MULTILAYER MPEG CINEON DPX DDS JP2

	-x, --use-extension <bool>
	设置选项，将文件扩展名添加到文件的结尾。


动画播放选项

	-a <options> <file(s)>
	该操作将Blender作为动画播放器运行，以查看Blender渲染的影片和图像序列帧(如果 -b 被设定则忽略此参数)，不显示Blender的用户界面.

	回放参数:

	-p <sx> <sy>		打开，左下角位于 <sx>, <sy> 。
	-m		从磁盘读取(不进行缓冲)。
	-f <fps> <fps-base>		指定开始播放的FPS。
	-j <frame>		设置帧步长为 <frame> 。
	-s <frame>		从 <frame> 帧开始播放。
	-e <frame>		播放到 <frame> 帧。

窗口选项

	-w, --window-border		打开有边框窗口。
	-W, --window-fullscreen		强制以全屏模式打开。
	-p, --window-geometry <sx> <sy> <w> <h>		以左下角位于 <sx>, <sy> ，宽度和高度分别为 <w>, <h> 打开。
	-M, --window-maximized		强制最大化打开。
	-con, --start-console		从控制台打开(忽略 -b 选项)，(仅适用Windows)。
	--no-native-pixels		对于高分辨显示器(MacBook Retina)，不使用本地分辨率。
	--no-window-focus		在其他窗户后面打开，无需获得焦点。

Python 选项

	-y, --enable-autoexec		启用自动执行Python脚本(默认)。
	-Y, --disable-autoexec		禁用自动执行Python脚本(py驱动与启动脚本)。
	-P, --python <filename>		运行指定的Python脚本文件。
	--python-text <name>		运行指定的Python脚本文本块。
	--python-expr <expression>		将给定表达式作为Python脚本运行。
	--python-console		使用交互式控制台运行Blender。
	--python-exit-code <code>		设置抛出Python异常时的结束代码( [0..255])，(仅用于从命令行执行的脚本)，0表示禁用。
	--addons <addon(s)>		逗号分隔的插件列表(无空格)。

日志选项

	--log <match>
	启用日志分类，使用单个逗号分隔的参数。多个类别可使用 .* 后缀进行匹配，所以 --log "wm.*" 记录窗口管理器所有类型的日志。使用 "^" 前缀以忽略，所以 --log "*,^wm.operator.*" 记录所有类型的日志但是除了 wm.operators.* 使用 "*" 以记录所有日志。

	--log-level <level>
	设置日志冗余等级(等级越高细节越多)默认为1，使用-1以启用所有等级。

	--log-show-basename
	只显示文件名称于输出中(不显示加载路径)。

	--log-show-backtrace
	显示日志信息回溯(仅限于debug模式)。

	--log-show-timestamp
	从启动后开始为每个日志信息添加以秒为单位的时间戳显示。

	--log-file <filename>
	设定日志输出文件。


调试选项

	-d, --debug
	开启调试。

	启用内存错误侦测

	禁用鼠标抓取(在某些情况下与调试器进行交互)

	保留Python的 sys.stdin 而不是将其设置为None

	--debug-value <value>		在启动时设置调试值 <value> 。
	--debug-events		启用事件系统的调试消息。
	--debug-ffmpeg		启用来自ffmpeg库的调试消息。
	--debug-handlers		启用事件处理的调试消息。
	--debug-libmv		启用来自libmv库的调试消息。
	--debug-cycles		启用来自Cycles的调试消息。
	--debug-memory		启用完全保护的内存分配和调试。
	--debug-jobs		启用后台任务的时间分析。
	--debug-python		启用Python的调试消息。
	--debug-depsgraph		启用依赖树的全部调试消息。
	--debug-depsgraph-eval		启用依赖树的调试消息(分析相关)。
	--debug-depsgraph-build		启用依赖树的调试消息(树构造)。
	--debug-depsgraph-tag		启用依赖树的调试消息(标记相关)。
	--debug-depsgraph-no-threads		切换依赖图到单线程运算。
	--debug-depsgraph-time		启用依赖树的调试消息(时间相关)。
	--debug-depsgraph-pretty		启用调试信息颜色。
	--debug-gpu		对OpenGL 4.3+启用GPU调试上下文和信息。
	--debug-gpumem		启用在状态栏显示GPU内存状态。
	--debug-gpu-shaders		启用在状态栏显示GPU内存状态。
	--debug-gpu-force-workarounds		启用在状态栏显示GPU内存状态。
	--debug-wm		启用窗口管理器的调试消息，同时逐个打印operator调用，打印键位映射错误。
	--debug-all		启用全部调试消息。
	--debug-io		启用来自I/O ((collada, ...))的调试消息。
	--debug-fpe		启用浮点异常。
	--disable-crash-handler		禁用崩溃处理程序。
	--disable-abort-handler		禁用中止处理程序。

综合选项

	--app-template <template>		设置应用模板(匹配目录名称)， default 表示参数为空。
	--factory-startup		跳过读取用户家目录中的startup.blend。
	--enable-library-override		在UI中启用库重载特性。
	--enable-event-simulate		启用事件模拟测试特性 bpy.types.Window.event_simulate。
	--env-system-datafiles		设置 BLENDER_SYSTEM_DATAFILES 环境变量。
	--env-system-scripts		设置 BLENDER_SYSTEM_SCRIPTS 环境变量。
	--env-system-python		设置 BLENDER_SYSTEM_PYTHON 环境变量。

	-noaudio		禁用声音系统。
	-setaudio		设置声音系统到指定设备: NULL SDL OPENAL JACK。
	-h, --help		打印帮助信息，并退出。
	-R		注册 .blend 扩展名，然后退出 (仅适用于Windows)
	-r		悄悄注册 .blend 扩展名(不弹出提示对话框)，然后退出 (仅适用于Windows)
	-v, --version		打印Blender版本信息并退出。
	--		结束选项处理，传递的参数不变。通过Python的 sys.argv 访问。

其他选项

	/?		打印帮助文本，并退出 (仅适用于Windows)。

	--debug-freestyle
	启用FreeStyle调试信息。

	--verbose <verbose>
	设置日志记录的详细程度.

参数解析

	参数必须用空格隔开,例如：

	blender -ba test.blend
	...将退出，因为 -ba 是未知参数。

参数顺序

	参数是按从左到右的循序执行的，例如:

	blender --background test.blend --render-frame 1 --render-output '/tmp'
	...不会渲染到 /tmp ，因为不能在渲染路径(output)之前设置 --render-frame 1 参数。

	blender --background --render-output /tmp test.blend --render-frame 1
	不会渲染到 /tmp ，由于加载混合文件会覆盖渲染输出设置。

	blender --background test.blend --render-output /tmp --render-frame 1
	以上命令行正确，可得到预期结果。

环境变量

	BLENDER_USER_CONFIG		用户配置文件目录。
	BLENDER_USER_SCRIPTS		用户脚本目录。
	BLENDER_SYSTEM_SCRIPTS		系统脚本目录。
	BLENDER_USER_DATAFILES		用户数据文件目录 (icons, translations, ..).
	BLENDER_SYSTEM_DATAFILES		系统数据文件目录。
	BLENDER_SYSTEM_PYTHON		系统Python库目录.
	TEMP		临时文件目录。

	TMP 或 $TMPDIR 	临时文件目录.
	SDL_AUDIODRIVER		LibSDL 音频驱动- alsa, esd, dma.
	PYTHONHOME		Python主目录路径, 例如/usr/lib/python。


## 👉 CMD Line Render 命令行渲染

某些情况下我们想要提高渲染速度、远程访问 Blender 进行渲染或通过命令行编写脚本。

	set path=c:\Program Files\Blender Foundation\Blender 2.82\
	set path=C:\Program Files\Blender Foundation\blender-2.83-beta
	blender shape-keys.blend -b -s 25 -e 100 -j 1 -t 4 -a

使用命令行的一个好处就是我们并不需要图形界面进行显示，比如不需要 Linux 的窗口系统 X server，因此可以通过远程 shell 进行渲染，典型的比如 SSH。

注意命令的正确使用，错误命令可能导致全黑输出。使用粒子等模拟运算的动画需要注意，模拟数据要进行烘焙。例如，执行粒子的 Cache 属性面板 Bake All Dynamics，否则执行命令行渲染时，模拟不会执行，只有第一帧有效果。

对于物理刚体系统的模拟烘焙，见场景属性面板 Rigid Body World。

以下命令不会生效，因为输出和拓展参数被设定于 Blender 已经被指派进行渲染之后：

	blender -b file.blend -a -x 1 -o //render

以下命令将按预期执行：

	blender -b file.blend -x 1 -o //render -a

始终 将 -f 或 -a 放在最后一个参数的位置上。


*单张图像*

	blender -b file.blend -f 10

	-b 后台渲染(没有用户界面)。
	file.blend 用于渲染的blend文件路径。
	-f 10 只渲染第10帧。


	blender -b file.blend -o /project/renders/frame_##### -F OPEN_EXR -f -2
	-o /project/renders/frame_#####

保存渲染图像的路径，使用五个 0 补位用于帧计数。

	-F OPEN_EXR 覆盖blend文件中指明的图像保存格式，并保存为一张OpenEXR图像。
	-f -2  仅渲染倒数第二帧。

参数对大小写敏感！ -F 和 -f 是不同的。


*指定多帧*

渲染第 21 帧和倒数第 30 帧

	blender snowboy.blend -b -f +21,-30

*动画*

	blender -b file.blend -a

	-a 使用blend文件中保存的设置渲染整个动画。

	blender -b file.blend -E CYCLES -s 10 -e 500 -t 2 -a

	-E CYCLES 使用“Cycles Render”渲染引擎。执行 blender -E help 查看可用渲染引擎列表。
	-s 10 -e 500 将起始帧设为 10 结束帧设为 500。
	-t 2 仅使用两个线程。
	-a 动画序列渲染，注意不是动画播放。

*动画播放命令对比*

	blender -a render/0000.png -s 2 -e 24
	blender snowboy.blend -b -s 51 -e 100 -a -t 4



# 🚩 Particles 粒子

粒子是被网格对象大量发射出来的，通常为数千个。每个粒子可以是一个光点或网格，并且可以是连接的或动态的。
它们可能对雨多不同影响和力做出反应，并且有寿命的概念。动态粒子可以表征火，烟，雾和其它比多灰尘或魔法。

粒子系统发分为发射器 Emiter、 毛发 Hair 两种。

毛发粒子是常规粒子的子集，毛发系统形成可代表头发，毛发，草和刷毛的曲线。

发射器会按时间量产生/发射颗粒，从开始帧发射到结束帧，并具有一定的寿命。发射出来的粒子呈现为什么样子，
这取决于粒子系统的 Render 渲染面板的设置， 默认是呈现为光晕 Halo。

粒子通常从发射器的网格流出到空间中，它们的运动可能会受许多因素的影响，包括：

- 从网格出来的初始速度。
- 发射源 定点，面或体积 本身的运动。
- 根据 重力 或 空气阻力 的运动。
- 风场，涡流或沿引导线的力场的影响。
- 与其它对象如碰撞的相互作用。
- 一群有智力成员，如鱼群在试图达到目标或者避开掠食者的同时，对群体的其它成员做出反应。
- 柔软的身体物理平衡运动 (仅 头发 粒子系统)。
- 甚至手动转换 栅格。


使用标准粒子的过程是：

- 创建网格发射粒子。
- 创建一个或多个要从网格物体发射的粒子系统，多个粒子系统彼此互相作用或者合并以实现整体预期效果。
- 定制每个粒子系统的设置已达到所需的效果。
- 为基础网格和场景中设计的其他粒子网格设置动画。
- 定义和塑造粒子的路径和流动。
- 对于 毛发 粒子系统：雕刻发射器的流(如毛发修剪或梳理)。
- 进行最终渲染并进行物理模拟，根据需要尽心调整。

在属性编辑器的粒子选项卡中给对象添加新的粒子系统，Particles Properties 中单击小 `+` 按钮。
列表中每个粒子系统都附有单独的设置， 可以对列表的粒子配置进行复制，这些设置可以在不同的粒子系统
之间共享，因此不必手动复制每个设置，并且可以对多个对象使用相同的效果。

Emission/Render/Pysics 是三个是粒子最重要最基础的属性设置。

粒子生成是一个模拟计算过程，计算结果产生的粒子物体，可以转换为真实的模型，通过修改器属性面板，点击
粒子修改器中 Make Instances Real 进行转换。


## 👉 Particles Emission 发射器属性

- Seed 随机数种子影响粒子随机性

- Number 粒子或毛发数量，

	对于毛发，尽可能使用小颗粒，特别是如果打算稍后使用软体动画，需要足够的粒子来控制好。对于法线修改，
	大概一两千个粒子基本足够控制了。如果打算用毛皮覆盖身体，可能需要更多的颗粒，可以与子级 Children
	一起制作体积。

- Hair Length 控制毛发的长度
- Segments 设置毛发的段数

- Frame Start/End 

	粒子发射开始/结束帧指定，可以设置负值，这样就可以在实际渲染的帧之前开始模拟。

- Lifetime 生命周期决定粒子的寿命，以帧为单位。
- Lifetime Randomness 生命周期的随机性

	给定粒子寿命的随机变化，最短寿命可能是 Lifetime × (1 - Randomness)。不允许高于 1.0 的值。
	例如，默认的 Lifetime 值为 50，随机设置为 0.5 将为您提供范围从 25 帧到 50 的实时范围的粒子。

- Source 粒子发射源头

	- Emit From

		设置粒子从发射器的什么位置流出到空间中，还可以通过顶点组 Vertex Groups 来设置。

		- Vertices 从发射器对象的顶点发射；
		- Faces 从发射器对象的网格发射；
		- Volume 从发射器对象的整个体积发射；

		注意，选择 Volume 方式，发射器的网格必须为流形网格，否则，像 Edge Split Modifier 
		这样的修改器不能正常工作。

		流形又称水密网格，定义了一种封闭不自相交的几何体，相对于非流形。一个流形网格指的是封闭体
		的所有相连面的结构将总是无重叠地从法线(和它的面)指向网格的外面或里面。如果重新计算法向，
		它们将总是指向垂直方向(向外或向内)。用于非封闭体时，流形网格则指那些法向定义了两不同且
		不相连的面的网格。流形网格总是定义了偶数个不重叠表面。

	- Use Modifier Stack

		在发射粒子时考虑修改堆栈中，粒子修改器上方的任何修改器 ，否则它使用原始网格形状。

	- Distribution 分布

		设置从 Face 或 Volume 发射的粒子如何分布在整个发射位置。

		- Jittered 粒子以抖动的间隔防止在发射器元上。

			- Particles/Face 每面的排放数量(0 = 自动)。 
			- Jittering Amount 抖动量。

		- Random 粒子从发射器元中的随机位置发射。
		
		- Grid 粒子在 3D 网格中，并且保持元素附近/中间的粒子。

			- Invert Grid 网格反转，反转什么被认为是对象，什么不是。
			- Hexagonal Grid 使用六边形网格而不是四边形网格。
			- Resolution 网格的分辨率。 
			- Random 向网格位置添加随机偏移。

	- Random Order

		发射器索引以随机顺序而不是线性的通过。
	
	- Event Distribution

		基于元素的表面积进行粒子分布，即小元素比大元素发射更少的粒子，因此粒子密度是均匀的。



## 👉 Particles Render 粒子可视化属性

粒子可以渲染为：

- 光晕 Halos，用于火焰，烟雾，云。
- 网格 Meshes，它又可以是动画，例如鱼，蜜蜂等，在这种情况下，每个粒子看一个物体。
- 发丝 Hair Curves，发丝会贴着粒子的路径，可以在 3D 视图中进行梳理，添加，修剪，移动等。

每个对象都可以携带许多粒子系统，每个粒子系统可以包含多达 1000 万个粒子。毛发和键控这些粒子类型的
每个粒子可能有多达 1 万个子级，子级移动和发射或多或少像各自的父级一样。

- Common Settings 通用设置

	- Scale 按比例缩放粒子或粒子示例化的对象。
	- Scale Randomness 设置缩放的随机性。
	- Material 从发射器对象的材质中挑选一个用于着色粒子。 
	- Coordinate System 使用不同的对象坐标来确定粒子的诞生。 
	- Show Emitter 勾选以在渲染时显示发射器。

- Render As 指定粒子渲染类型

	- None 不渲染粒子，如果您使用粒子复制对象，这将非常有用。
	- Halo 光晕，渲染为发光的点，没有任何实质内容，用于火焰、烟雾、云等。
	- Line 作为键控粒子的直线运动路径。
	- Path 作为键控粒子的运动路径。

		可视化可以是 Hair Particles 毛发粒子或 Keyed Particles 键控粒子，路径使用 B 样条
		插入毛发或键控粒子的运动路径。
		
		- B-Spline 

			勾选使用 B 样条插入毛发。如果要使用较低的渲染值，这可能是一个选项，降低一点控制但获得
			更顺畅的路径。 

		- Steps

			渲染路径的细分步数，值作为 2 的幂，比如设置 4 步就表示 16 次细分。应该仔细设置此值，
			因为如果将渲染值增加 2，则需要渲染四倍的内存。

		- Timing 时序

			- Absolute Path Time 轨迹时序是绝对帧。 
			- End 实际轨迹的结束时间。 
			- Random 给轨迹长度一个随机变化。

	- Object 对象

		粒子会实例化指定的模型物体作为粒子的呈现。

		- Instance Object 实例化指定的物体来代替每个粒子。
		- Global Coordinates 勾选使用物体的全局坐标系进行实例化。
		- Object Rotation 勾选保持粒子指定物体的旋转属性一致。
		- Object Scale 勾选保持粒子与指定物体的大小一致。

	- Collection 集合

		在粒子的位置依次实例化属于集合中的所有物体。请注意，Pick Random 机制使用 parentage 
		和 Instancing Verts 完全替换旧的 Blender 粒子系统，以用实际几何体替换粒子。

		- Instance Collection 指定要实例对象的集合
		- Whole Collection 一次示例化全部集合中的物体，而不是其中一个。
		- Pick Random 粒子随机拾取集合中的一个物体进行实列化。

		- Global Coordinates 勾选使用物体的全局坐标系进行实例化。
		- Object Rotation 勾选保持粒子指定物体的旋转属性一致。
		- Object Scale 勾选保持粒子与指定物体的大小一致。

		- Use Count 使用计数

			设置集合中的物体使用的次数，或者从列表中删除不使用，计数越大实例化就越多。列表视图
			指定的每个物体的顺序和次数都可以通过上下箭头按钮调整，使用 + 按钮复制，或使用 - 
			按钮删除副本，环状箭头重置。

- Extra 额外设置

	- Parent Particles 

		默认情况下，如果激活 Children 面板的子项，则不会呈现父集，勾选表示也渲染父粒子。 
		子集有很多不同的变形选择，所以策略是父集在他们折叠的子集之间。

	- Unborn 

		勾选在粒子诞生前渲染它；

	- Dead 

		勾选设置在粒子消亡时渲染，如果粒子在碰撞中消逝，那么这非常有用，因此可以用例子覆盖物体。




## 👉 Particles Physics 粒子物理运动

有多种方式控制粒子的移动，这里讨论狭义上的粒子物理，即粒子属性面板中物理面板设置。

移动粒子的其他方法是：

- 通过软体动画(仅适用于头发粒子系统)。 
- 通过力场和沿曲线。 
- 通过晶格。

常用物理设置

- Size 设置粒子的大小。 
- Random Size 给粒子一个随机的大小变化。 
- Mass 指定粒子的质量大小。
- Multiply Mass with Size 粒子质量与大小乘积，勾选会导致较大的颗粒具有较大的质量。

接下来对不同的物理类型进行讨论，根据物理属性面板的 Physics Type 指定物理类型。

首先就是 *None* 非物理运动类型，非物理类型粒子不会运动，它们不属于物理系统。起初，使粒子静止的
物理类型看起来有点奇怪，但它有时非常有用。物理学没有任何东西可以让粒子在整个生命周期中都和发射器粘连.
例如，通过这种物理类型的谐振器，在谐振结束时给粒子一个初始速度。

此外，使用物体或分组可视化来处理植被与生态系统，就可以非常方便地处理粒子，Unborn 和 Died 两种状态
都在渲染中可见。还有，非物理类型粒子可以与键控 Keyed 类型结合使用，以形成粒子的运动链。

例如，利用非物理运动类型来做一个碳原子结构模型：

- 添加 Cycle，设置为 6 段半径为 1m 的多边面， Fill Type 为 Ngon，得到一个正六边面；
- 到修改器属性面板中添加 Array 阵列复制 8 个，X 偏移 1m；
- 再添加一个阵列复制 4 个，X 偏移 0m，Y 偏移为 1.5，相对偏移方式，也可以用恒定偏移方式；
- 再添加一个阵列复制 1 个，X 偏移 1/16m，Y 偏移为 3/11，按多变形的面积计算偏移；
- 然后添加一个 Wireframe 修改器，让网格显示为边框结构；
- 为网格添加粒子，设置物理类型为 None，发射位置的顶点 Verts，粒子附着在再六边体的顶点位置；

还可以添加一个 Simple Deform 修改器来弯曲网格为管状，弯曲时 它需要一个参考坐标，使用 Empty 就可以。

- 在场景中添加一个 Empty 对象，类型随意选择，使用 Arrow 可以有三个轴的方向指示；
- 为了便于理解，保持空对象的 Z、X 轴与网格同平面，X 轴作为简易形变修改器的弯曲轴。
- 那么当 X、X 轴与网格的边一一平行时，对网格的弯曲就是对齐的弯曲成管状。
- 如果成 45°，那么网格就是对角卷起。
- 如果，以 Y 轴作为修改器的弯曲轴，那么结果就是网格扇形化。
- 当参考的空对象坐标角度的不是平行或垂直时，弯曲的效果就按空间的对成关系弯曲。



### ⚡ Newtonian 经典牛顿力学运动

经典牛顿力学运动 *Newtonian* 中的粒子以指定的初始速度和角速度开始其生命，并根据外力移动。

- Forces 力
	
	- Brownian 布朗运动量，基于布朗噪声场向粒子添加随机运动，很适合模拟随机微风。 
	- Drag 拖拽力，可以降低粒子速度与其速度和大小的关系，用于模拟空气阻力或水阻力。 
	- Damp 阻尼力，降低粒子速度，减速，摩擦，阻尼。

- Integration 积分
	
	积分器是一组可用于计算粒子运动的数学方法。根据动画师的目标，以下指南将有助于选择合适的积分器。
	提供四种积分方法：

	- Euler 欧拉

		也被称为前向欧拉，最简单又非常快，但结果不太准确。如果不使用阻尼，颗粒随着时间的推移会
		获得越来越多的能量。例如，弹跳粒子每次都会反弹越来越高。不应与具有相反特征的还没有实现的
		后向欧拉相混淆，即使没有阻尼，能量也会随着时间的推移而减少。使用此积分器进行短时间模拟或模拟，
		并进行大量衰减，快速计算比精度更重要。

	- Verlet 维莱

		非常快速和稳定的积分器，随着时间的推移，能量保持很少，数值耗散很少。

	- Midpoint 中点

		也被称为二阶 Runge-Kutta 积分，比欧拉慢但稳定得多。如果加速度是恒定的，例如没有阻力，
		则它是能量保守的。应该注意的是，在弹跳粒子的例子中，粒子可能比它们偶尔开始的反弹更高，
		但这不是趋势。该积分器通常是一个很好的积分器，可用于大多数情况。

	- RK4
	
		4 阶 Runge-Kutta 的缩写，与中点相似，但速度较慢，在大多数情况下更准确。即使加速度不恒定，
		它也是能量保守的。仅在发现中点不够准确的复杂模拟中才需要。


	以下是其它选项：

	- Timestep 每帧间隔的模拟时间，以秒为单位。 
	- Subframes 子帧，每帧的模拟步骤数。提高模拟稳定性和精细度，对更快移动的粒子使用更高的值。

	以下是流体物理类型专用选项：

	- Adaptive 自适应，自动设置子帧数。
	- Threshold 阈值

		允许子帧数变化的容差值，在需要更多子帧之前粒子可以移动的相对距离。 每帧的步数将至少为子帧 +1，
		根据阈值，如果流体变为湍流，则可以模拟更多子帧。

- Deflection 撞击偏转

	- Size Deflect 在撞击偏转中改变大小。 
	- Die on Hit 当粒子撞击偏转物体时杀死粒子。 
	- Collision Collection 碰撞集合，如果设置，粒子将与集合中的对象发生碰撞。



### ⚡ Fluid 流体物理运动

流体物理类型 *Fluid*  流体粒子类似于牛顿粒子，但这种粒子受到内力如压力，表面张力，粘度，弹簧等
影响。从液体到粘液，粘液到沙子和细小的烟雾，可能的使用数量是无穷无尽的。

Blender 粒子流体使用光滑粒子流体动力学方法 SPH - Smoothed Particle Hydrodynamics 来解决
颗粒流体方程，这是一种用于模拟流体流动的计算方法。它已被用于许多研究领域，包括天体物理学，弹道学，
硫化学和海洋学。它是一种无网格的拉格朗日方法，坐标随流体移动，并且可以根据密度等变量轻松调整方法的
分辨率。这里可以选择双密度 Double-Density 或经典 Classical 模式。

流体物理与牛顿物理共享部分选项，如积分 Integration 选项。

- Fluid Settings 流体属性

	- Stiffness 硬度，流体的不可压缩性。 
	- Viscosity 线性粘度，较粘稠的液体使用较低的粘度。 
	- Buoyancy 浮力，基于流体内部压力差的负重力方向的人工浮力。

- Advanced 高级

	- Repulsion Factor

		斥力系数，流体试图保持多大程度的聚集，硬度系数。Factor Repulsion 复选框将排斥系数设置
		为硬度系数。 

	- Stiff Viscosity

		硬性粘度，为膨胀液体创造粘度。Factor Stiff Viscosity 复选框将其设置为正常粘度的因子。

	- Interaction Radius

		互动半径，流体的相互作用半径。 Factor Radius 复选框将其设置为 4 倍的粒子尺寸。

	- Rest Density

		静止时的流体密度，Factor Density 复选框将此设置为默认密度系数。

- Springs 弹性
	
	- Force 弹性力度。
	- Rest Length 静止长度的弹性。初始粒子半径。复选框将其设置为粒子尺寸 2 倍。

	- Viscoelastic Spring 勾选使用粘带弹性代替胡克弹性。

		- Elastic Limit 弹性极限，弹性必须拉伸/压缩多少才能改变其长度。 
		- Plasticity 可塑性，超过弹性极限后弹力支撑长度可以改变多少。 
		- Initial Rest Length 勾选设置初始静止长度，作为弹力支撑长度而不是粒子尺寸 2 倍。 
		- Frames 从粒子诞生到指定这个帧创建弹力，默认为 0。

- Fluid Interaction 流体交互 （没有相关文档）


### ⚡ Keyed 键控物理运动

键控物理类型 *Keyed* ，在任何两个或更多个粒子系统的粒子之间，确定键控粒子的运动路径。这允许创建
系统链以长链或常规粒子移动。基本上，粒子没有动态，但是从一个系统插入到每个帧的下一个系统。

要设置键控粒子，您需要在 Relations 关系列表中至少有两个粒子系统，粒子会在这些键控粒子对象上穿梭，
穿梭中会受到这些粒子系统的运动方式影响，设置为 None 非物理运动类型则不会。

- Options

	- Loops 

		设置在整个模拟期间重复整个键控关系列表的次数，如果使用时序则禁用。

	- Use Timing 使用时序

		启用将使用关系中的 Time 时间和 Duration 持续时间选项以单独指定每个键的时间。默认情况下
		禁用，粒子将持续其生命周期通过所有键，寿命越短意味着移动越快。寿命将在键之间平均分配，
		这可能导致目标之间的粒子速度变化。

- Relations 关系

	- Targets 目标键，键控的列表视图选择的粒子系统。

	- Target Object 列表所选的目标对象的名称，如果为空，则使用当前粒子系统。 
	- System 目标对象上的粒子系统索引。 

	- Time 

		粒子在指定的时间出现在所选的系统所在位置，是一个帧编号。注意，键控系统的起始帧会作为偏移量。

	- Duration

		设置停留时间，以帧为单位。在开始穿梭到下一个系统之前，粒子会在此系统上停留的时间。



### ⚡ Boids 群体物理运动

群体物理类型 *Boids* ，由有限的人工智能控制，可以编程种群以遵循基本规则和行为，非常适合模拟鸡群，
群体，群体以及各种动物，昆虫和鱼类或捕食者与捕食者模拟的学校。它们可以对其他对象的存在以及他们自己
系统的成员做出反应。

群集行为逻辑面板控制群簇粒子间互动的方式，群簇的行为由一系列规则控制，只能解算列表中的一定数量的信息，
如果超出内存容量，则忽略其余规则。因此 Boid Brain 首脑规则的顺序非常重要，在某些情况下仅评估前
三个规则参数。规则从顶部列表解析到底部列表，顺序就是明确的优先级，并且可以使用右侧的小箭头按钮修改顺序。

一个群群总是尽力去完成列表中给的规则，但是经常有情况会导致一些规则会取得优先。例如大多数时候，避免
捕食者时，Boid 就会忽略 Collision/Separate/Flock 等规则，即陷入混乱之中，可能受到阻碍，即使
指示不要这样。

在属性面板 Boid Brain 首脑规则的列表中，默认添加了两个首脑规则：Sperate & Flock，远离规则
和聚集规则。

首脑规则可以设置其影响的群体属于空中 In Air 还是陆地 On Land。

规则评估方式 Rule Evaluation 有三种方法可以控制规则的解算方式:

- Average 所有规则都为平均值。 
- Random 为每个群体选择随机规则。 
- Fuzzy 使用模糊逻辑来解算规则。

模糊解析模式下，仅估算模糊阈值 Rule Fuzziness 以上的第一个规则。该阈值应该考虑群簇将如何努力
尊重给定规则，值为 1.000 表示群体将始终坚持它，值为 0.000 表示它永远不会。如果群体同时遇到多个
冲突条件，它将尝试根据每个规则的相应权重来满足所有规则。

Boid Brain 首脑规则设置提供了以下不同行为方式：

- Average Speed Rule 均匀速度规则

	- Speed 最大速度的百分比； 
	- Wander 漫游，速度方向上的随机量；
	- Level 速度在 Z 轴上的分量保持多少恒定量；

- Avoid Rule 避免规则

	设定的指令时逃避捕食者，即在 Relations 关系中设置为 Enemy 的粒子系统。注意，如果不设置要
	逃离的目标对象，可以配合 Boid Force 群簇力场使用，那么力场设置为正强度 Positive Strength 
	就表示捕食者角色，负强度 Negative Strength 就表示猎物角色。 

	- Object 设置要逃离的目标对象；
	- Predict 预测目标的运动； 
	- Fear Factor 恐惧系数，超过此值就触发逃避运动；

- Avoid Collision Rule 避免碰撞规则

	Avoid objects with activated Deflection.

	- Boids 勾选以避免群簇的碰撞；
	- Deflectors 勾选避免碰撞偏转器对象；
	- Look Ahead 指定向前探索看的时间，秒数；

- Separate Rule 远离规则，互相远离；

- Flock Rule 聚集规则，模拟临近的运动并且避开；

- Follow Leader Rule 追随首领规则 

	- Distance 保持与正在追随首领的距离；
	- Line 成排队形追随首领，候鸟迁徙的经典队形； 
	- Queue Size 成排队形允许的队列大小个数；

- Goal Rule 捕食规则

	设置捕食规则后，群起会扑向猎物目标。设置了负强度 Negative Strength 的 Boid Force 群簇
	力场也算猎物目标。

	- Object 设置被追踪的目标；
	- Predict 预测目标的运动；

- Fight Rule 逃离规则

	当关系中设置 Enemy 群体，使用逃离规则时，此群簇就会按指定的距离逃离。

	- Fight Distance 逃离距离，逃离到这个距离停下；
	- Flee Distance


Avoid 和 Flight 两种都是逃离使用的规则，需要设置好因为那个目标而逃离，是 Relations 中设置的 
Enemy，还是 Boid Force 中 Strength 大于 0 的群簇力场。



- Movement 移动

	- Allow Flight 允许通过空气飞行。
	- Allow Land 允许通过陆地移动。
	- Allow Climbing 允许攀爬。

	- Max Air Speed 最大飞行速度，速度越大，在整个模拟中飞行越远。
	- Min Air Speed 最小飞行速度
	- Max Air Acceleration 最大空中加速度，相对于最大速度的百分比，用于确定转向速度。
	- Max Air Angular Velocity 最大角速度，相对与 180°，用于定义群体突然加速以执行规则的能力。
	- Air Personal Space 个体空间大小的半径，以粒子大小的百分比表示。

	- Landing Smoothness 着陆平滑度。
	- Max Land Speed 最大着陆速度。
	- Jump Speed 最大跳跃速度。
	- Max Land Acceleration 最大陆地加速度，最大速度的百分比，用于确定群体转向能力。
	- Max Land Angular Velocity 最大角速度，相对与 180°，用于定义群体突然加速以执行规则的能力。

	- Land Personal Space 个体陆地空间大小，以粒子大小的百分比表示。
	- Land Stick Force 群体开始着陆需要的粘滞力大小。
	- Collision Collection 设置可以碰撞的物体集合。

- Battle

	- Health 健康状态，出生时的初始健康状态。
	- Strength 强度/力度，攻击时每秒造成的最大伤害。
	- Aggression 侵略，群体这次比敌人更强大。
	- Accuracy 攻击的准确性。
	- Range 群里可以攻击的最大距离。

- Misc

	- Banking 倾斜姿态，转弯时速度矢量周围的旋转量。1.0 的倾斜量具有自然的倾斜效应。
	- Pitch 俯仰姿态，侧向量的旋转量以控制俯仰角度的变化。 
	- Height 在陆地的高度，群体相对于粒子系统大小的高度。

- Relations

	在列表中显示的是需要交互的目标粒子系统，可以设置这些目标与自身的关系。

	- Target Object 目标对象 ID；
	- System 目标对象的粒子系统索引号，因为可能使用了多个粒子系统，需要在这指定它的序号；
	- Mode 设置关系模式
		- Enemy 设置为敌对模式会导致粒子逃离对方；
		- Friend 设置友好模式可以相互成群； 
		- Neutral 自然模式不会导致结盟或逃离；

- Deflection 偏转

	群体根据碰撞规则的权重尝试避免偏转对象，与凸面 Convex 一起工作较好，凹面 Concave 还需要
	一些做些设置。

- Force Fields 力场

	与其他物理类型一样，群体也收外力场的影响，使用特殊的群簇力场 Boid Force Field 可以影响
	群体物理运动。效果器可以是群体试图避免捕食者(正强度)，或者是群体试图根据群体首脑的回避规则
	Avoid 或攻击规则 Goal 尝试到达的目标(负强度)。



## 👉 Children 子级

子级 是指 毛发 和 键控 粒子指定的子粒子。使得只需使用相对较少的父粒子就可以工作，对于这些子粒子，
是用物理学计算出来的。然后子粒子与父粒子保持一致。在不重新物理计算的情况下，可以改变子级的数量和视觉效果。

子级可以从粒子或面发射(有一些不同的选项)。面 的排放有一些优点，特别是每个面上的分布更均匀(这使得它
更适合毛皮等)。然而，来自粒子的子级更好地跟随他们的父级，例如，如果你有软体动画并且不希望毛发穿透
发射网格。但另请参阅我们关于 毛发 的手册页。

如果你启用了子级，父集将不再被渲染了(这是说得通的，因为子级的形状可能与父级的形状大不相同)。如果要
查看父级项，请另打开 可视化 面板中 父级 按钮。

子级使用父级所附带的材质，并根据发射的具体位置进行着色(因此所有子级可能具有不同的颜色或其他属性)。

可能的选项取决于粒子系统的类型，如果使用 面子级 或者 粒子中的子级。没有显示所有可能的组合，只显示 
毛发 粒子系统的设置。

除了 None 不生成子级，子级类型只有两种：

- Simple 简单型子级，子级从父级的位置发射出来。
- Interpolated 插值型子级，在父级粒子之间的面上发射出来。这对毛发特别有用，这样可以实现均匀分布。
	有些子级可能成为虚拟的父级，影响附近的其他粒子。


基本设置：

- Display Amount 设置 3D 视图中显示每个子级的数量。
- Render Amount 实际渲染子级的数量。
- Length 子级子轨迹的长度。 
- Threshold 阈值 未受子粒子路径长度影响的粒子数量。 
- Seed 在子粒子的随机数种子，以获得不同的随机化结果。

- Clumping 簇集

	- Use Clump Curve 使用 曲线部件 代替参数化。 
	- Clump 簇 沿着子线聚集的数量。子级可以在沿途 (1.0) 交集或者在根部 (-1.0) 一起开始。 
	- Shape 簇 的形状。反抛物线 (0.99) 或指数 (-0.99)。 
	- Twist 扭曲 待定。 
	- Use Twist Curve 使用扭曲曲线 待定。 
	- Clump Noise 簇噪波 在父级毛发周围创建随机簇集。 
	- Clump Noise Size 簇噪波尺寸，簇集的尺寸。

- Roughness 

	- Use Roughness Curve 使用 曲线部件 代替参数化。 
	- Uniform/size 均衡，尺寸 

		当子级靠近时，基于子级的位置以类似的方式改变轨迹。 

	- Endpoint/Shape 端点，形状 

		噪度结束 随机化轨迹末端，有点像负向的簇集随机化。 

	- Random/Size/Threshold 随机，尺寸，阈值 

		基于随机向量，因此对于附近的子级来说不一样。可以指定阈值以仅将其应用于部分子级。这对于
		创建一些不会做别人做的独立子级很有用。

- Kink Type 扭结类型

	- Nothing 停用； 
	- Curl 卷曲 子级在父级毛发周围生长成螺旋状。 
	- Radial 径向 子级在父级周围形成一个穿过父级毛发的波浪形状。 
	- Wave 波浪 子级形成一个波浪，朝着同一个方向。
	- Braid 编织 子级在父级的毛发周围编织。
	- Spiral 螺旋 

		在每根毛发的末端产生螺旋。 Radius, Resolution 半径，分辨率 定义整体大小。 Shape 
		形状 使螺旋向内或向外生长。

	- Amplifier 振幅 偏移的幅度。 
	- Clump 簇 多少簇集影响扭结幅度。 
	- Flatness 平直度 毛发有多扁平。 
	- Frequence 偏移的频率(1 /总长度)。频率越高，旋转越多。 
	- Shape 形状 旋转开始的地方(旋转偏移)。


专用设置：

- Simple 简单型子级

	- Size 尺寸 仅适用于 发射器。子级尺寸的乘数。 
	- Randomize Size 随机变化的子粒子的大小。 
	- Radius 子级分布在父级身边的半径。这是3D，因此子级可能比父级更高或者更低。 
	- Roundness 父级周围子级的圆度。在球体(1.0)或平面内(0.0)。 

- Interpolated 插值型子级

	- Virtual Parent 虚拟父级的相对数量。 
	- Long Hair 长毛发 计算适合长毛发的子级。

	- Parting 分界 待定。




## 👉 Emitter 粒子发射器


发射器与毛发的几个重要的基础设置，Emission 发射器设置/ Physics 物理控制/ Render 渲染方式，
在前面解析过了，这里解析粒子发射器的一些专用设置。

- Cache
 缓存 模拟出来的粒子数据可以缓存在内存中或存储在驱动器上，可以烘焙到和软体和布料模型上。

- Cache 粒子缓存

	将模拟结果烘焙保存是很好的做法，烘焙固定下来后，在执行渲染时不会因为选择渲染区间，即开始与
	结束帧范围不同而导致模拟效果出现差异。

	如果尚未将文件保存，则会在内存中创建的缓存，因此请先保存文件，否则缓存可能会丢失。

	- Simulation Start/End 指定模拟处于活动状态的帧数范围，模拟的第一和最后一帧。
	- Bake 将仿真计算结果烘焙到缓存保存，需要在物体模式才能烘焙。
	- Calculate To Frame 将物理模拟运算烘焙到当前帧。
	- Current Cache to Bake 从当前缓存烘焙。
	- Bake All Dynamics 烘焙所有动力学结算结果。
	- Delete All Bakes 清除烘焙缓存。
	- Update All To Frame 更新缓存到当前帧。


- Velocity 速度 

	基于粒子系统的类型，可以通过不同的参数设定粒子的初始速度。 对于发射器或毛发则通过法线 Normal、
	切线 Tangent、 切线相位 Tangent Phase 即旋转面切线等指定。

	- Normal 发射器的面法线(即让面法线给出粒子的起始速度)。 
	- Tangent 让切线速度给粒子一个起始速度。 
	- Phrase 切线相位，旋转面切线。 
	- Object Aligned X/Y/Z 对其对象在 X/Y/Z 轴上给出初始速度。
	- Object Velocity 发射器物体移动(即让物体给出粒子的起始速度)。 
	- Randomize 使起始速度随机变化。可以使用纹理更改，请参阅控制发射，交互和生命周期。

- Rotation 旋转 指定各个粒子在行进过程中如何旋转。
- Viewport Display 视图显示

- Children 子级

- Force Fields 力场
- Vertex Groups 顶点组


## 👉 Hair 毛发粒子系统

毛发型粒子系统可用于线状物体，例如头发，毛皮，草，羽毛笔等。

Regrow 开启毛发长出，为每一帧长出毛发，在动画属性非常有用。

Advanced 启用高级设置，激活物理属性，设置与在发射器模式下工作的设置相同。


毛发的使用步骤：

- 生长

	第一步是制作毛发，指定毛发束的数量及其长度。

	预先计算粒子的完整路径。所以粒子做毛发的一切也可能。只要粒子路径适用于具有100帧生命周期的粒子，
	毛发就是如此。不是逐点渲染粒子动画的每一帧，而是使用插值计算控制点。

- 造型

	下一步就是为毛发造型。可以通过调整 物理设置 来更改基础毛发的外观。

	改变毛发外观的更高级方法是使用 子级。可以将毛发添加到原生毛发中，并具有为其提供不同形状的设置。

	还可以在 粒子编辑模式 下以交互的方式设置毛发样式。在此模式下，粒子设置将被禁用，可以梳理，修剪，
	延长毛发的曲线等。

- 动画

	使用布料解算器可以是毛发动态化。这将在 毛发动力学 页面中介绍。

- 渲染

	在Cycles渲染器下可以使用专用的毛发着色器 毛发 BSDF节点 或者 原理化毛发 BSDF节点。

	毛发也可以用作 粒子实例修改器 的基础，可以沿着曲线变形网格，这对于较粗的线束或草皮或羽毛等，
	可以使外观更具象。

	毛发可以渲染为路径，对象，或集合。见 粒子可视化 的描述及 毛发形状 设置。


在发射器设定发束的数量，尽可能使用小颗粒，特别是如果打算稍后使用软体动画，需要足够的粒子来控制好。
对于 法线 修改，一两千个粒子基本足够控制了。如果打算用毛皮覆盖身体，可能需要更多的颗粒。随后将与
子级一起制作卷。




毛发类型粒子设置面板

- Hair Dynamic 毛发动力学

	毛发粒子可以使用物理学具有的动态属性。要启用毛发物理，请勾选属性面板的毛发动力学 Hair Dynamics。

- 结构
- 体积
- 渲染
- Hair Shape 形状

	这些设置用于渲染的毛发时曲线形状的控制。

	- Strand Shape 发股形状

		一个形状参数，用于控制根和尖端之间的厚度转换。负值使基元更朝向顶部舍入，零值使基元呈线性，
		而正值是基元更靠近底部。

	- Diameter Root 根直径 根部毛发的宽度。 
	- Tip 梢 毛发尖端的宽度。 
	- Diameter Scale 半径缩放 根部和尖端值的乘积。这可用于改变毛发的厚度。
	- Close Tip 勾选闭合末端，设置尖端的厚度为零，即使使用非零尖端设置也是如此。


- Children 子级 参考发射器的子级属性设置
- 视图显示



## 👉 Particle Edit Mode 粒子编辑模式

物体添加粒子后，3D 视图的模式选择列表就会添加 Particle Edit 选项。

使用粒子系统编辑模式 编辑关键点 (关键帧) 和 路径 烘焙 毛发, 粒子, 布料, 和 软体 模拟器。
 (烘焙前你可以编辑毛发的造型。)

由于在粒子编辑模式下工作非常简单，并且非常类似于在3D视图中处理顶点，我们将展示如何设置粒子系统，
然后提供各种函数的参考。

只有烘焙进内存的帧是可编辑的！如果您无法编辑粒子，请检查您是否正在烘焙 磁盘缓存。

毛发粒子系统的设置

- 创建一个 毛发 粒子系统。
- 在 法线 方向给一个初始速度。
- 创建一个模拟。
- 检查 毛发动态 框。




# 🚩 Physics 物理系统

Blender 的物理系统用于模拟一些现实世界的不同物理现象。结合粒子系统可以使用这些系统创作各种静态和
动态的特效，比如 毛发、草地和集群、 雨、 烟雾和灰尘、 水、 布料、 果冻等等。

3D 视图对象模式下，通过菜单可以快速体验物理模拟 Object ‣ Quick Effects

- Quick Fur 模拟毛发，给选中模型添加 ParticleSettings 修改器和两个材质槽，一个设置 Material 毛发效果，一个空的 Fur Material 材质；
- Quick Explode 模拟爆炸，给选中模型添加 Explode、ParticleSettings 修改器和 Explode Fade 材质；
- Quick Smoke 模拟烟雾，给选中模型添加 Smoke 修改器，添加一个 Cube 模型作为烟雾的体积容器，设置 Smoke 修改器和 Smoke Domain Material 材质，主要是 Principled Volume 着色器；
- Quick Fluid 模拟流体，给选中模型添加 Fluidsim 修改器，添加一个 Cube 模型作为流体的体积容器，设置 Fluidsim 修改器和 Fluid Domain Material 材质，主要是 Glass BSDF 和 Volume Absorption 着色器；

建立包含选中物体的基础模拟场景或效果。该工具会使用预定义设定添加基本对象，如域或粒子系统，这样就可以立即看到结果。

3D 视图力场对象菜单和刚体菜单：

- Add - Force Field

	- Force			
		
		常力场是最简单的场，它给对象的原点(正强度)或远离(负强度)提供恒定的力。

	- Wind			
		
		风力场给出了在一个单一的方向上以恒定的力，沿着力对象的局部Z轴。

	- Vortex		
		
		涡流力场给出了一个螺旋式上升的力量，扭曲周围的力对象的局部Z轴点的方向。

	- Magnetic		
		
		磁力领域取决于粒子的速度，它模拟磁化物体上的磁力。

	- Harmonic		
		
		谐振力场中，力场的源是谐波振荡器的零点，如果你把它分配给粒子，将阻尼参数设置为 1，则在达到物体的时刻停止移动

	- Charge		
		
		电荷力场类似于常力场，但是只对有电荷的粒子作用。

	- Lennard-Jones	
		
		兰纳琼斯力场是一种非常短程的力，其行为由效应器和受影响的粒子的大小决定。 在小于组合尺寸的距离处，该场是非常排斥性的，并且在该距离之后它是有吸引力的。

	- Texture		
		
		纹理创建的任意复杂的力场，有三个方向的力被颜色编码。红色编码为X轴，Y轴为绿色，Z轴为蓝色，值 0.5 表示没有力。

	- Curve Guide	
		
		曲线引力场用于迫使粒子跟随由定义的某个路径曲线物体，典型的情况是移动静脉内的红细胞，或使动物中的颗粒流动。

	- Boid			
		
		群簇不影响物理，和群簇粒子一起使用，来为群簇大脑 Boid Brain 规则定义群簇捕食者和目标。

	- Turbulence	
		
		紊流力场创建随机或混沌 3D 噪音效果，类似海洋下的水射流或喷泉。

	- Drag			
		
		拖拽力场通过减缓下来抵抗粒子运动。

	- Smoke Flow	
		
		烟流力场根据烟雾模拟气流创建一个力。


- Object - Rigid Body

	- Add Active		添加主动刚体
	- Add Passive		添加被动刚体
	- Remove			
	- Change Shape		
	- Calculate Mass	
	- Copy from Active	
	- Apply Transformation
	- Bake to Keyframes	
	- Connect			连结连个刚体

Gravity 重力是一种全局设置，适用于场景中的所有物理系统，可以在场景选项卡中找到。 这个值通常在Z轴上默认为 -9.810，这是现实世界中的重力。

相关的属性编辑器面板有物理属性面板和粒子属性面板，同时物理对象和修改器的使用很密切，比如实现布料模型的 Cloth 布料修改器，许多设置都需要通过以下几个属性面板配置：

- Scene Properties
- Physics Properties 
- Particles Properties
- Modifier Properties

相关修改器主要是 Simulate 分类，需要配合相关物理属性使用：

- Cloth					布料修改器 模拟柔软织物
- Collision				碰撞检测修改器 检测刚体的碰撞
- Dynamic Paint			动态绘图修改器
- Explode				爆炸修改器
- Fluid Simulation		流体模拟修改器
- Ocean					海洋修改器 模拟海面波浪
- Partical Instance		粒子实例修改器
- Particle System		粒子系统修改器
- Smoke					烟雾修改器
- Soft Body				软体修改器


物理属性面板中设置了 8 个物理模型按钮来激活相应的修改器，Blender 2.82 将旧版中的 Smoke 和 Fluid 整合了：

- Force Field 力场
- Collision 物体碰撞检测
- Cloth 布料
- Dynamic Paint 动态绘画
- Soft Body 软体模拟用于模拟柔软的可形变物体。
- Fluid 流体
- Rigid Body 刚体模拟不可形变物体，Passive 类型为固定的，Active 类型会运动
- Rigid Body Constraint 柔体约束

所有物理动态经过模拟后的结果都在缓存中，可以通过烘焙物理模拟将缓存的计算结果保留到场景的模型中。

播放动画时，模拟结果会自动缓存到内存中，因此下一次播放时，可以从内存中读取结果，播放的更快。

如果你烘焙了模拟结果，缓存会被保护，你将无法改变模拟设置，除非点击清除烘焙清除模拟。

通常建议在渲染之前烘焙您的物理模拟，除了不再需要经过耗时的模拟过程之外，烘焙可以帮助防止潜在的错误，并确保模拟的结果每次都保持完全相同。

Blender 允许同时存储和管理同一物理对象的多个缓存，可以使用列表视图来管理这些缓存。


## 👉 Force Field 力场

力场是为其它系统提供影响力的对象，可以提供额外的运动，比如 Particles, Soft Bodies, Rigid Bodies, Cloth 等等都可以受到力场作用。给这些对象添加力场后，模拟器自动产生效果。禁用力场，只需要在力场权重面板 Field Weights 中关闭或设置为 0 即可。

- 所有类型的物体和粒子都可以生成力场，但只有曲线物体可以承受 Curve Guide 曲线引力场。
- 对象需要共享至少一个公共层才能生效。
- 您可以将粒子的影响限制在一组对象上。

所有力场中，重力是一种全局设置，适用于场景中的所有物理系统。 它可以在场景选项卡中找到，并可以选择是否激活。 重力通常在 Z 轴上默认为 -9.810，这是现实世界中的重力。 更改此值将模拟更低或更高的重力。 重力单位为 g 或 G，大小是米/秒^2。

重力以同样的方式应用于所有物理系统，每个物理系统的重力值可以在其物理属性面板中的场权重 Field Weights 选项卡中缩小。

整个行星地球的重力几乎相同。 对于从月球渲染场景，使用小六倍的值，即 1.622 m × s^-2，行星火星 的重力值为 3.69。


从现有对象创建一个力场，必须选择该对象并切换到物理属性选项卡添加，在力场菜单中选择力场类型。更改力场面板或偏转碰撞面板设置后，必须通过释放缓存重新计算软体或布料系统的粒子，这不会自动完成。

使用负压强的风力是一个小技巧，可以用来吸引诸如气球这样的对象，像风场中心靠近。



力场类型类型：

- Force 常力

	常力是最简单的力场，由原点向远离原点的方向提供恒定的力。 给力场对象的原点正强度，给远离原点负强度，牛顿粒子被吸引到具有负强度的场，并被吹离具有正强度的场。

- Wind 风力

	风力给出了在一个单一的方向上以恒定的力，沿着力对象的局部 Z 轴，强度通过圆圈的间距来指示。

- Vortex 涡流力场

	涡流力场给出了一个螺旋式上升的力量，扭曲周围的力对象局部 Z 轴点的方向，这可以用于制作旋转水槽或龙卷风或在颗粒毛发上扭结。

	设置 Point 之外的类型，可以在选项 Inflow 设置涡流力的内向分量。

- Magnetic 磁力场

	磁力场产生的力取决于粒子的速度，它模拟磁化物体上的磁力，可以通过 Angular 设置角度等参数。

- Harmonic 谐振力场

	谐振力场，如弹簧和单摆 Pendulum，力场的源是谐波振荡器的零点。如果你把它分配给粒子，将阻尼参数 Damping 设置为 1，则在达到物体的时刻停止移动。

	- Reset Length 静止长度控制谐振的剩余长度。
	- Multiple Springs 勾选导致每一点受到多个弹簧的影响。

	通常，现场系统的每个粒子都会影响目标系统的每个粒子，谐振除外！ 这里每个目标粒子都分配给场粒子。 因此，粒子将移动到其他粒子的位置，从而形成形状。

- Charge 电荷力场

	电荷力场类似于 Force 力场，除了它根据受影响的粒子电荷场负/正改变它的行为，吸引/排斥，就像带电荷的真实粒子一样。 这意味着该场仅对具有电荷力场的粒子有影响，否则，它们没有电荷，则不受影响！

- Lennard-Jones 兰纳琼斯力场

	兰纳琼斯力场是一种非常短程的力，其行为由效应器和受影响的粒子的大小决定。 在小于组合尺寸的距离处，该场是非常排斥性的，并且在该距离之后它是有吸引力的。 它试图使粒子彼此保持平衡距离。 颗粒需要彼此非常接近才能完全受到该场的影响。

	粒子可以包括一个电荷和一个兰纳琼斯分子力，这可能是核物理学家研究的东西。

- Boid 群簇力场

	群簇力场不影响物理，只和群簇粒子 Boids Particles 一起使用，用来为群簇大脑 Boid Brain 规则定义群簇捕食者和猎物。设置群簇力场的正强度 Positive Strength 就表示捕食者角色，负强度 Negative Strength 就表示猎物角色。也就是说负值越大，对捕食者的吸引力越大。

- Turbulence 紊流力

	在紊流力场创建随机混沌的 3D 噪音效果，类似海洋下的水射流或喷泉。

	- Size 表示噪音的大小比例。
	- Global 勾选使相对于世界的噪音的大小和强度，而不是它附着的物体。

- Drag 拖拽力

	在拖拽力场通过减缓速度来抵抗粒子运动。

	- Linear 拖拽分量与速度成正比。
	- Quadratic 拖拽分量与速度的平方成正比。

- Smoke Flow 烟流力场

	烟流力场从流体模拟的气流产生力，以流体模拟的烟雾产生的气流速度矢量来模拟此力场。 要使用它需要添加烟流力场为其指定流体域对象 Domain Object。

	例如，火花闪耀可能实际上沿着模拟火焰附近的空气湍流流动。

	- Domain Object 指定用作烟雾模拟的流体域。
	- Apply Density 根据烟雾密度调整力的强度。


除 Curve Guide 和 Texture 两种力场外，大多数力场有相似的基本设置，这些常用力场的设置如下：

- Settings 基本设置

	- Shape

		设置用于计算效应力的方向，对于来自 Empty 空对象的力场，Point 和 Plane 才有效，对于来自 3D 对象的场，还可以是 Plane 和 Every Point 选项，而來自曲线的力场只對應 Curve 选项。

		- Point 由对象中心点指向全方位的力场。
		- Line 产生在 Z 轴方向并经过中心点的线状力场。
		- Plane  产生在局部 Z 方向平面上的力场。
		- Surface 力场作用于 3D 物体的表面，在这种情况下，Z 轴是表面法线。
		- Every Point 使用网格对象中的每个顶点作为效应点。
		- Curve 力场沿曲线对象作用。

	- Strength 强度/力度

		力场效应的强度，这可以是正的或负的以改变力的作用方向。力场的强度和力对象的尺度缩放一致。

	- Flow 流

		该值定义效应器力(加速度)将被转换为恒定气流的速率。 如果不为零，则有效力取决于粒子速度。

	- Noise Amount 设置能影响力量强度的噪波数量。
	- Seed 改变随机噪声的种子能噪波的随机性变化。
	- Affet Location 勾选时力场会影响粒子的位置。
	- Affect Rotation 勾选时力场会影响粒子的旋转。
	- Absorption 力被碰撞物体吸收。

在 Falloff 这里可以指定力场衰减的形状，及其它参数。

- Shape 外形

	- Sphere 衰减在全方位统一，就像一个球体一样。
	- Tube 产生管状衰减力场，其徑向衰减以及力场的最小最大距离可以调整。
	- Cone 产生锥形衰减力场，附加选项与管形选项相同。

- Z Direction

	设置力场在 Z 轴正负方向或两向上受力，比如设置为 +Z 表示在力场 Z 轴上方的物体才有对应的受力。

- Power 

	衰减功率设置，如果衰减功率设置大于 0 即激活衰减，最大衰减功率为 10，设置为 0 表示没有衰减，力场始终在最大半径内保持全强度，或者禁用最大半径时全空间都是全强度。

	如果 r 是距离物体原点的距离，则力场强度随着 (1/r)^power 变化。 衰减功率为 2 时，力场变为 (1/r)^2，引力的衰减就是这样的。

- Min Distance

	物体原点到最小半径的的距离力场保持全效强度，即最小半径外的空间都处于衰减的状态，超过最大半径相当于由最大半径决定力场的全效强度的空间。不激活衰减时无效，表示该力场衰减在最大半径或无穷大时总是全强度。

- Max Distance

	使力场仅在指定的最大半径内产生作用力，不激活表示力场无穷远都产生作用力，由虚线圆圈指示。



### ⚡  Curve Guide 曲线引力场

曲线引力场用于迫使粒子跟随曲线定义的路径运动，典型的情况是移动静脉内的红细胞，或使动物中的颗粒流动，还可以用来塑造发丝。

您还可以使用粒子编辑模式 Particle Edit Mode 来定义路径。

由于可以将曲线动画化为软体或其他方式，您可以构建非常复杂的动画，同时保持很好的控制并将模拟时间保持在最低限度。

曲线引导选项对粒子不起作用，相反，您必须将粒子系统选项卡的角速度设置为转动，Rotation - Angular Velocity - Spin，并保持旋转不变，即不要打开动态 Dynamic。

曲线引导影响同一层上的所有粒子，独立于其与曲线的距离。如果你有一个层次上的几个引导，他们的力场会相互叠加，但是您可以通过更改最小距离来限制其影响半径。


- Minimum Distance 

	设置满力度的最小半径，从曲线到这个半径位置达到最大力度，除非衰减 Falloff 设置 0，因为这样从曲线到最大半径 Maximum Distance 位置总是满力度的。 

- Free 设置粒子寿命的分数。

- Falloff

This setting governs the strength of the guide between Min Distance and Max Distance. A falloff of 1 means a linear progression.

	Path
	A particle follows a Curve Guide during its lifetime, the velocity depends on its lifetime and the length of the path.

	Additive
	If you use Additive, the speed of the particles is also evaluated depending on the falloff.

	Weights
	Use Curve weights to influence the particle influence along the curve.

	Maximum Distance / Use Max
	The maximum influence radius. Shown by an additional circle around the curve object.

	Clumping
	The other settings govern the form of the force field along the curve.

	Clumping Amount
	The particles come together at the end of the curve (1) or they drift apart (-1).

	Shape
	Defines the form in which the particles come together. +0.99: the particles meet at the end of the curve. 0: linear progression along the curve. -0.99: the particles meet at the beginning of the curve.

	Kink
	Warning

	This feature is broken in the current version, see T46776.

	Changes the shape that the particles can take.

	Type
	Curl
	The radius of the influence depends on the distance of the curve to the emitter.

	Radial
	A three-dimensional, standing wave.

	Wave
	A two-dimensional, standing wave.

	Braid
	Braid.

	Roll
	A one-dimensional, standing wave.

	It is not so easy to describe the resulting shapes, so have a look at the example below.

	../../../../_images/physics_forces_force-fields_types_curve-guide_kink.jpg
	Kink options of a curve guide. From left to right: Radial, Wave, Braid, Roll. Animation.

	Axis
	Which axis to use for the offset.

	Frequency
	The frequency of the offset.

	Amplitude
	The Amplitude of the offset.

	Shape
	Adjust the offset to the beginning/end.


### ⚡ Texture 纹理力场

纹理力场用来创建任意复杂的力场，这三个方向的力被颜色编码。R/G/B 三色分量对应编码为 X/Y/Z 轴，如 3D 视图中坐标轴的颜色。值 0.5 表示没有力，大于 0.5 加速度为负轴方向，小于 0.5 加速度为正轴方向。

- Texture Mode 设置从纹理导出力矢量的方式。

	- RGB 将颜色成分直接用作颜色编码方向的力矢量分量。例如图像或色带，所以没有色带的混合纹理是不够的。 
	- Gradient 将纹理渐变作为 3D 的梯度计算力矢量，梯度矢量总是指向增加亮度的方向。 
	- Curl 从 3D-RGB 纹理的卷曲计算力矢量，RGB 矢量的旋转，这只适用于彩色纹理。它可以用佩林噪音 Perlin Noise 产生的云彩创建一个漂亮的湍流力。 

- Nabla 纳布拉是用于计算渐变和卷曲纹理模式所需的偏导数的偏移量。 
- Use Coordinates 

	勾选使用发射器对象坐标，还有旋转和缩放，作为粒子使用的纹理空间。允许移动力场，它们的坐标与对象的位置坐标相结合。

- Root Texture Cooradinates

	根纹理坐标对于头发是有用的，因为它使用为发束的所有部分的颗粒根位置计算的纹理力。

- 2D 

	勾选以忽略粒子 Z 坐标，仅使用 X/Y 作为纹理坐标。 记住只有程序处理后的纹理才是真正的 3D。

纹理力场例子

- 单色纹理(0.5, 0.0, 0.5) 在正 Y 轴的方向上产生一个力，例如头发定向到 Y 轴。
- 使用混合色带的纹理来创建力平面，例如在左侧(0.5,0.5,0.5)，在右侧(1.0,0.5,0.5)，您有一个垂直于 XY 即平行于 Z 轴的力平面，使用这个坐标的对象可以推送周边的粒子。
- 动画的木质纹理可以用来产生像运动一样的波浪。







## 👉 Explode 爆炸

爆炸效果需要和粒子搭配使用，Explode 修改器负责打散模型，Particle System 修改器负责碎片的运动。

使用方法：

- 添加一个 Plane 作为地面，添加碰撞 Collision 物理属性，让碎片发生碰撞；
- 添加一个 UV Sphere 作为爆炸物体，先添加粒子系统，再添加爆炸修改器；
- 设置粒子系统的 Number 为合适的碎片数，Frame Start/End 设置爆炸的作用帧范围；
- 可以设置 Render 为 None，这样就以模型的网格作为碎片；
- 粒子的物理运动方式默认为牛顿力学即可， Physics Type - Newtonian；
- 可以设置粒子物理属性 Die on Hit，或者碰撞属性 Kill Particles 让粒子碰撞后失去活力；
- 设置粒子的 Velocity / Rotation 增加杂乱感，随机或 Object Aligned X/Y/Z 的速度；
- 还可添加力场来影响碎片的运动，正力场强度吹散碎片，负力场强度吸走碎片；
- 碰撞时的反弹可以通过物理刚体/软体来模拟。




## 👉 Collision 碰撞

粒子, 软体 和 布料 可以与网格对象碰撞。 群体 会避开 碰撞 对象。

- 可以限制粒子的影响至一组物体，在力场权重面板设置。
- 软体物体偏移比较困难，它们经常穿透碰撞物体。
- 毛发粒子忽略偏移物体(但您可以将它们作为软体进行动画化，软体会计算偏移)。

要注意，开启碰撞面板，则碰撞体会参与同一图层中所有模拟对象的碰撞/偏移(粒子，软体和布料)。

碰撞体的形状会影响布料形变，因此碰撞模拟必须得到当前帧布料网格的正确形状数据。正确的形状是指经过形态键或骨架变形后的形状。因此，碰撞修改器必须位于这些修改器之后。

如果更改对象的偏转设置，则必须通过清除缓存重新计算粒子、软体或布料系统，这并不是自动完成的。

物理属性碰撞面板：

- Field Absorption 力场场吸收，偏转器可以造成效果器的损耗，设置一个吸收量，100％的场吸收导致没有力量传递到碰撞/偏转器物体。

- Particle 粒子

	- Permeablity 渗透率 粒子穿透网格的比率。
	- Stickiness 粘度 粒子粘在物体上的程度。
	- Kill Particles 消除粒子 消除碰到的粒子。
	- Damping 阻尼 碰撞时的弹性程度(与粒子的速度无关)。
	- Randomize 随机 阻尼随机变化。
	- Friction 摩擦 沿着表面运动时的摩擦。
	- Randomize 随机 摩擦随机变化。

- Softbody & Cloth 软体和布料碰撞

	- Damping 阻尼 碰撞时的阻尼。表面的弹性程度，1.0 - 最大阻尼，软体不会弹开。
	- Thickness Outer/Inner 外侧、内侧厚度 在每个面的内侧和外侧添加的填充距离，用来防止交叉，软体将离碰撞体表面此距离处停下来。
	- Friction 摩擦 布料与碰撞体碰撞时的摩擦系数。例如，丝绸的摩擦系数低于棉花。
	- Single Sided 单面 开启后，布料碰撞仅在碰撞平面法线方向的一侧执行。
	- Override Normals 覆盖法线 开启后，布料碰撞的受力沿平面法线方向起作用。

软体 碰撞难以完美，如果其中一个物体移动得太快，则软体将穿透网格。
确保网格表面的法线朝向粒子/点以获得正确的偏移。
毛发粒子直接受力场影响，所以如果你使用一个短距离的力场，不一定需要碰撞。
在 粒子编辑模式 中，毛发粒子会忽略其生成的网格。但你至少可以用碰撞塑造毛发。


## 👉 Cloth 织物

Blender 2.83 版本新增 Cloth 雕刻工具，在雕刻模式下也可以进行织物建模。

**面料碰撞还有 BUG 在执行撤消操作时，可能导致面料与其它刚体模型碰撞失败，似乎是刚体系统的问题。网格细分也会导致布料失去对风力的响应**

您可以应用布料修改器来冻结或锁定当前帧处的网格形状，例如，您可以在桌子上铺上一块平布，让模拟运行，然后应用修改器。从这个意义上说，您正在使用模拟器来节省大量建模时间。

模拟的结果保存在缓存中，以便一旦在动画中的计算出来的每一帧的网格形状不必再次重新计算。如果对模拟进行了更改，您可以完全控制清除缓存并重新运行模拟。第一次运行模拟是完全自动的，没有烘焙或单独的步骤会中断工作流程。

计算每一帧的布料形状是自动的，并在后台完成；因此您可以在模拟计算时继续工作。但是，这很占用CPU，并且取决于PC的性能和模拟的复杂性，计算网格变化所需的CPU占用量会有所不同，同样您可能会注意到的电脑卡顿也会不同。

制作布料的一般过程是：

- 建模出布料物体作为一般起始形状。
- 将该物体指定为属性编辑器的物理选项卡中的布料 Cloth。
- 模拟与布料相互作用的其他偏转对象。确保修改器堆栈上的形变修改器位于任何其他网格变形修改器之后。
- 给布料添加灯光并指定材料和纹理，如果需要，可进行 UV 展开。
- 如果需要，可以给予物体颗粒，如从表面上掉下来的蒸汽。
- 播放动画运行模拟，找到最合适的模拟结果。
- 可选的操作是，将网格动画到模拟中的某个时间点，以获取新的开始动画的形状。
- 在逐帧的基础上对网格进行较小的编辑，以修正较小的破洞。

可以将布料与骨骼绑定到一起，实现其它运动效果。

织物属性面板内置了一些布料例子，Cotton 棉料/ Denim 牛仔布/ Leather 皮革/ Rubber 橡胶/ Silk 真丝。


在大多数情况下，一块布会与环境中的其他物体碰撞。 为了确保正确模拟，有几个项目必须设置并一起工作：

- 保证布料网格的细密度和厚度，Panel 可以使用 Solidify 修改器增厚	。
- 必须设置布料对象参与碰撞的集合。
- 可选(但建议)告诉布料与自身发生碰撞。
- 其他对象必须对 布料 对象 通过 共享图层可见。
- 其他对象必须是网格对象。
- 其他物体可能会被另外物体(如骨架或形态键)移动或自身变形。
- 必须告知其他网格对象偏转布料对象。
- 必须将 blend 文件保存在目录中以便保存模拟结果。
- 然后你可以 烘焙 模拟。模拟器计算帧范围内的布料形状。
- 之后，您可以在特定帧处编辑模拟结果，或对布料网格进行调整。
- 您可以调整环境或改变对象形状，然后从当前帧向前重新运行布料模拟。


例子：骨架上的布料

服装可以模拟并固定在骨架上。 例如，一个角色可能会有一个宽松的长袍，用皮带固定在角色的腰部，钉固的典型工作流程：

- 将骨架设置为其绑定姿势。
- 模型布料包围但不穿透角色的网格。
- 将骨架指定为布料的父级，现在，骨架将有几个绑定到它的子网格物体。
- 在每个布料对象上为其固定的顶点创建新的顶点组。

	添加要固定到此顶点组的顶点，并为这些顶点赋予非零权重。例如，外衣的腰带区域将在顶点组中并且具有权重 1。这些带权重的顶点将通过顶点组绑定到骨骼，随骨骼的运动而运动。

- 在属性编辑器的物理选项中将布料对象指定为布料。确保布料修改器在修改器堆栈中骨架修改器的下面。
- 在布料形状面板中选择顶点组。
- 添加物理碰撞到角色的网格，布料现在准备好了; 非固定顶点将受布料修改器的控制。 固定顶点将受到骨架修改器的控制。

当给角色做动画或者摆姿势时，必须从绑定姿势开始。 将角色移动到几个帧后的初始姿势，这样物理引擎就可以模拟衣服的移动。 非常快速的运动和传送跳跃可能会破坏物理模拟。

带动画固定顶点组可以配合布料使用，但不支持未固定的顶点以 Goal 为 0 并增加它。通过布料的 Shape 中指定 Pin Group 顶点组来固定，再配合顶点权重混合修改器 Vertex Weight Mix 取消固定。




- Settings
	- Quality Steps 模拟步数，越大质量越好，太小可能导致碰撞失败而穿过
	- Speed Multiplier 步数
- Physical Properties
	- Vertex Mass 布料材质的质量。
	- Air Viscosity 空气黏度，可以减缓坠落的速度。
	- Blending Model 弯曲模型

		Linear 带线性弯曲弹簧的布料模型(旧)。
		Angular 带棱角弯曲弹簧的布料模型。

	- Stiffness 硬度
		- Tension 张力 
		- Compression 压缩度 
		- Shear 形变 
		- Bending 弯曲 
	- Damping 阻尼
		- Tension 张力 拉伸行为中的阻尼量。
		- Compression 压缩行为中的阻尼量。
		- Structural 拉伸结构中的阻尼量，仅在线性弯曲模型中。
		- Shear 切变行为中的阻尼量。
		- Bending 弯曲行为中的阻尼量。
	- Internal Springs 内部弹簧
		- Max Spring Creation Length 限定创建内部弹簧的最大长度，超出就不创建，0 表示不限制。
		- Max Creation Diversion 
		- Check Surface Normals 
		- Tension 材料抗拉强度
		- Compression 材料抗压强度
		- Vertex Group 顶点主控制
		- Max Tension 最大张力
		- Max Compression 最大压缩度
	- Presure 内部压力，用于模拟类似气球物体
		- Presure 压力

			过大可能冲破模型，需要设置足够的材料硬度来支撑。使用内置的橡胶配置 Rubber，表面强度 15，合适的压力值 10。

		- Custom Volume 
		- Target Volume
		- Factor
		- Vertex Group
- Cache
- Shape 形态设置
	- Pin Group 钉固顶点组，通过指定权重为 1 的顶点将布料固定。
	- Stiffness 固定硬度
	- Sewing 缝合

		像钉固一样限制布料的方法，缝合弹簧，是虚拟弹簧，其将布料网格的一部分中的顶点拉向布网格的另一部分中的顶点。 

		可以用缝纫弹簧制作斗篷上的扣子。 弹簧可以将一个斗篷的两个角落在角色的脖子上。 这可能会导致更真实的模拟，而不是将斗篷钉在角色的脖子上，因为斗篷可以在角色的脖子和肩膀周围自由滑动。

		缝合弹簧是通过在布料网格中添加额外边缘而创建的，这些边缘不包含在任何面中。 它们应该连接应当拉在一起的网格中的顶点。 例如斗篷的角落。
		
	- Max Sewing Force 最大缝合力
	- Shrinking Factor 收缩系数
	- Dynamic Mesh 动力网格

		允许使用放置在布料修改器上方的形状键或修改器(例如，骨架修改器或任何变形修改器)为静态形状的布料设置动画。 启用后，每帧重新计算静态形状，允许未固定布料在形状键或修改器的帮助下挤压和拉伸角色，但在物理模拟的控制下可以自由移动。

		通常布料使用第一帧中物体的状态来计算布料的自然静止形状，并在整个模拟过程中保持不变。 这对于完全逼真的场景来说是合理的，但对于使用大量压缩和拉伸的卡通风格角色的服装来说并不适用。

- Collisinos 碰撞设置
	- Quality 设置模拟的精细程度。
	- Object Collisions 碰撞对象

		如果布料对象需要被其他物体偏转。要偏转布料，必须发生碰撞的双方都启用。 要使对象与布料对象碰撞，请启用碰撞物理用于碰撞对象，不是用在布料对象上。

		- Distance

			另一个物体必须到达接近布料的距离，以便模拟排斥布料。 较小的值可能会产生错误，但会产生一些加速，而较大的值会产生不切实际的结果，如果太大而且会速度很慢。 所以最好在这之间找到一个合适的值。

		- Impulse Clamping 冲量钳制

			通过限制碰撞后的移动量，防止在紧凑和复杂的碰撞情况下发生爆炸。

		- Collision Collection 碰撞集合

			只有作为其中一部分的对象 集合 可能会与布料发生碰撞。请注意，这些对象还必须启用碰撞物理。

	- Self Collisions 自碰撞

		真正的布料不能穿透自己，因此你通常希望布料自碰撞。 启用此选项可告诉布料对象不应穿透自身。 这增加了模拟的计算时间，但提供了更真实的结果。

		- Friction

			布料与自身碰撞时的摩擦系数。 例如，丝绸的摩擦系数低于棉布。

		- Distance 距离

			当在这个距离时布料开始排斥自己。 较小的值可能会产生错误，但会产生一些加速，而较大的值会产生不切实际的结果，如果太大而且速度很慢。 最好在这之间找到一个合适的值。
		
		- Impulse Clamping 冲量钳制
		

			通过限制碰撞后的移动量，防止在紧凑和复杂的碰撞情况下发生爆炸。

		- Vertex Group 顶点组

			只有作为其一部分的顶点 顶点组 可以相互碰撞。

- Property Weights 属性权重分配
- Field Weights 力场分配



## 👉 Soft Body 软体

软体模拟用于模拟柔软的可形变物体。这个功能主要用于为动画添加辅助运动，例如人物行走时身体部分的轻微晃动。

它也可以用于模拟更加常见的软体，如弯曲、变形、受重力和风力作用、或是与其他物体碰撞。

虽然软体也可以在一定程度上模拟布料和其他有一定硬度的可形变物体，但专为此目的设计的 布料模拟 解算器可以更好的完成这一任务。

软体模拟的工作原理是将物体已有的动画与它受到的力结合起来。物体的顶点受外力如重力或力场，和内力的同时作用。这样，你就能模拟真实世界中物体的形状，好像它们确实有体积、是实心的、并且受物理力量的作用。

软体可以通过 碰撞 与其他物体产生相互作用。它也可以通过 自碰撞 与自己产生相互作用。

软体模拟的结果可以被转换为静态对象。你也可以对模拟进行 烘焙编辑 ，例如，修改中间某处的结果并从这里继续运行柔体模拟。

使用软体的典型场景：

- 人物移动时的轻微晃动。
- 使用橡胶、明胶等材料制作的富有弹性、可形变的物体。
- 在风中晃动的树枝，摇摆的绳索等类似的物体。
- 受力的旗帜、宽袖、垫子等简单的布制品。

碰撞计算会花费大量时间。如果某个对象是不可见的，就不要计算它。

为了提高碰撞计算的速度，通常会使用一个额外的、更简单、不可见、稍微大一些的物体来替代碰撞对象进行计算。

只在行得通时使用软体。如果试图给身体网格一个较紧的衣物，单单使用软体来模拟衣物的动画，你不会成功。自碰撞的软体毛发有实现的可能，但这是一条需要你独自摸索的道路。我们稍后会在 碰撞 中细述这个问题。

尝试使用 晶格 或 曲线引导 而非物体本身来进行软体模拟。这或许更快。


蹦蹦跳跳的立方体

- 首先，把起始和结束帧改为1和150.
- 然后，添加一个平面，缩放5倍。接下来，到物理选项卡，添加被动刚体、碰撞体，保持默认设置就好。
- 现在，添加一个立方体，或使用默认立方体。
- 然后进入 编辑模式，细分三次。添加一个倒角修改器平滑一点边缘，然后按两次 R，稍微移动一下光标。
- 添加软体模拟的准备已经就绪。
- 在物理属性中选择软体。 关闭结果 Goal， 勾选自碰撞。同时，在 边 中，增加弯曲数值到 10。
- 播放动画，现在你会看到一个慢慢的、蹦蹦跳跳的立方体。为了提高速度，我们需要烘焙软体模拟。
- 在 缓存 下更改起始和结束帧，本例中是 1 和 150。

现在，为了测试动画是否一切正常，你可以先设置 5 或者 10 的缓存步长，但是在最终的动画中最好把缓存步长降到1，才能缓存所有帧。可以烘焙模拟结果，给立方体上材质和贴图，并渲染动画。



## 👉 Rigid Body 刚体

刚体模拟可用于模拟固定的运动，它会影响物体的位置和方向，并且不会使物体变形。

和其它模拟不同，刚体模拟与动画系统的工作模式更接近。这意味着刚体可以像常规对象一样使用，并且可以是父子关系，动画约束和驱动程序的一部分。

目前只有网格对象可以参与刚体模拟，要建立刚体，使用属性编辑器物理属性面板设置，Physics Properties - Rigid Body，或使用工具栏。


刚体有主动和被动两种，主动刚体模拟动态的，而被动刚体是模拟静态的，使用动画选项时，都可以由动画系统驱动。

在模拟过程中，刚体系统将覆盖动态刚体对象的位置和方向。但请注意，对象的位置和旋转不会更改，所以刚体模拟的行为类似于约束。要应用刚体变换，你可以使用 应用对象转换 运算符。

刚体对象的比例也影响模拟，但是总是由动画系统控制。

可以使用 属性编辑器 - 物理 - 刚体 按钮或 物体 - 刚体 菜单来删除对象上的刚体物理属性。


主动刚体可以设置质量 Mass，指定对象有多重与重力无关。

- Dynamic 启用/禁用物体的刚体模拟。
- Animated 勾选允许刚体由动画系统控制。

与所有启用物理物体一样，请密切注意物理属性选项卡的刚体面板中的动画 Animated 复选框。一个常见的错误是在被动 Passive 物理物体上使用关键帧动画而不检查动画框、物体将移动，但物理引擎将像被动仍处于起始位置一样，导致失望。

最常见的技巧是勾选 Animated 用关键帧为物理物体做位置或旋转动画，当 Animated 复选框属性上设置的曲线将其切换到禁用时，物理引擎将使用物体的最后已知位置，旋转和速度来接管。设置各种刚体约束参数的强度动画，机动的目标速度，铰链的限制等，可用于完成各种有趣的结果。

在物理模拟过程中启用约束通常会产生戏剧性的结果，因为物理引擎试图将两个严重偏离的物体对齐。对于受影响的物体来说，建立足够的动能以使自己从相机中弹回并进入轨道，尽管物理引擎还不能很好地模拟行星的引力，胡乱编造吧。

在工具栏的物理选项卡中，Bake To Keyframes 可以使用烘焙功能将刚体动力学烘焙到普通关键帧。哪里？？？？

碰撞检测参数 Collisions，可以设置碰撞刚体的物理模型 Shape，根据不同的模型来检测碰撞边界，默认 Convex Hull 凸壳，一种类似于网格的曲面，包含了所有的定点，较少的点可获得理想效果。物体的凸面近似值，具有良好的性能和稳定性。

- Surface Response 响应参数
	- Friction 阻力，相互碰撞的任一方为 0 结果都为 0；
	- Bounciness 回弹，相互碰撞的任一方为 0 结果都为 0；
- Sensitivity 敏感度
	- Collision Margin 碰撞边界
	- Margin 设置边界距离
- Collections 碰撞组

	允许在不同组上分配刚体碰撞，最多 20 个，同组的刚体才进行碰撞检测。



### ⚡ Rigid Body Constraint 刚体约束

刚体约束也称为刚体连接器，用于连接 2 个刚体，在物体模式下，选中连个刚体，执行菜单 Object - Rigid Body - Connect 即可以连接。连接后场景中会添加一 Constraint 对象，它就是用来绑定两个刚体约束的。

也可以在物理属性面板中设置刚体约束，这种方式需要在属性种指定被约束的两个对象：

- Type 约束类型

	- Fixed 固定

		此约束导致两个对象作为一个物体移动。由于此物理系统确实有一点斜率，因此物体不会像它们是相同网格的一部分那样严格的移动。

	- Point 点

		物体由点关系连接，允许围绕约束物体的位置进行任何类型的旋转，但不允许相对平移。物理引擎将尽力确保在两个约束物体上指定的两个点一致。

	- Hinge 铰链

		铰链是唯一使用 Z 轴而不是 X 轴的轴旋转约束。如果铰链出现问题，请检查其他约束以确定是否存在问题。

	- Slider 滑块

		滑块约束允许约束物体沿着 X 轴相对平移，但不允许相对转动，或沿着其它轴相对平移。

	- Piston 活塞

		活塞允许沿约束物体的 X 轴平移。它还允许围绕约束物体的 X 轴转动。它就像滑块的自由度和铰链的自由度的结合。

	- Generic 通用

		通用约束具有许多可用的参数，具有 X/Y/Z 三轴灵活性，将最小值/最大值固定到零具有与点约束相同的效果。在任何参数上使用一个非零值，允许它在整个模拟过程中在该范围内转动或滑动。

		将相对转动固定到零可使物体保持对齐，结合绝对旋转和绝对平移固定的行为与固定约束 Fixed 非常相似。

	- Generic Spring 通用弹簧

		通用弹簧约束比通用约束多了一组弹簧参数，单独使用弹簧允许物体反弹，就像附着在锚定在约束物体上的弹簧一样，这通常有点过于自由，因此大多数应用都将受益于启用转换或旋转约束。

		弹簧上的阻尼设置为 1 可以防止弹簧力重新调整锚点，从而导致奇怪的行为。如果你的弹簧很奇怪，请检查阻尼。

	- Motor 机动

		机动约束导致两个实体之间的平移和/或转动，可以将两个物体分开或一起驱动，可以驱动简单的转动，或转动和平移，平移可以被其它物理特性阻挡而不会阻止转动。

		旋转轴是承载约束物体的 X 轴，这与使用 Z 轴的铰链形成对比。由于机动在没有匹配的铰链约束的情况下容易受到混乱的扰动，因此必须特别注意对齐轴。如果没有正确对齐，机动似乎没有效果因为铰链阻止了机动的运动。

- Settings

	- Enabled 勾选指定在模拟过程中约束处于活动状态。
	- Disable Collision 勾选禁用碰撞，不允许受约束的物体相互传递。
	- Breakable 勾选允许模拟过程中将约束断开。禁用 机动 约束。可以用来模拟破坏。
	- Threshold 冲量阈值，约束断开时所需的临界值。

- Objects First/Second 设置被约束的两个物体。
- Override Iterations 指定约束解算器在每步模拟中的迭代次数。

对不同的刚体约束类型，还有相应的限制参数，主要分为角度转动 Angular 和线性滑动 Linear 限制两种，适用铰链、滑动、活塞、通用、弹簧等约束类型。

通过使用限制，您可以通过制定分别在一个轴上的平移/旋转范围来进一步约束物体，可以锁定一个轴，将两个限制都设为 0 即可。以下为两种约束设置参考，具体约束的轴按不同约束类型设置。

Angular 角度限制：

- Z Angle 启用/禁用在 Z 轴上限制转动。
- Z Lower 较低的 Z 轴转动限制。
- Z Upper 较高的 Z 轴转动限制。

Linear 线性限制：

- X Axis 启用/禁用在 X 轴上限制滑动。
- X Lower 较低的 X 滑动限制。
- X Upper 较高的 X 滑动限制。

弹簧约束有专用的弹性参数：

	X/Y/Z轴
	分别启用/禁用X,Y或Z 轴弹性平移。

	刚度
	弹簧刚度分别在X,Y或Z轴上平移。指定弹簧的 "弯曲" 程度。

	阻尼
	弹簧阻尼分别在X,Y或Z 轴上的平移。弹簧的阻尼量。

	X/Y/Z 角度
	分别启用/禁用X,Y或Z 轴的弹性转动。

	刚度
	弹簧刚度分别绕X,Y或Z轴旋转。指定弹簧的 "弯曲" 程度。

	阻尼
	弹簧阻尼分别绕X,Y或Z 轴上的转动。弹簧的阻尼量。

机动约束的专用的旋转角机动和线性平移机动参数，涉及两个物理量：

- Target Velocity 设置目标线性或旋转机动速度。
- Max Impluse 设置最大线性或旋转机动脉冲。




### ⚡ Rigid Body World 刚体世界环境

在场景属性面板中，可以设置刚体世界环境参数 Scene - Rigid Body World。刚体世界环境是一组刚体物体，它保存适用于此模拟中所有刚体的设置。当您在物体上添加物理刚体时，主要创建一组具有默认刚体世界环境的物体。当您为它们添加刚体物理时，会自动将刚体物体添加到该组中。

可以创建多个刚体世界环境集合，通过物体属性选项卡中的面板分配刚体物体到不同的集合，Object Properties - Collections。

如果刚体物体和约束对象位于刚体世界环境指定的集合种，则它们生效，会被模拟器考虑在内。

参数参考：

- Remove Rigid Body World 从当前场景中移除模拟刚体环境。

- Settings

	- Collection 指定包含参与模拟的刚体物体集合。
	- Constraints 指定包含参与模拟的刚体约束对象的集合。
	- Speed 设置增加/降低模拟速度。
	- Split Impulse 分离冲量

		启用/禁用降低碰撞时可加强的额外速度，将使模拟稳定性略降低，因此在必要时使用。限制物体碰撞时分离的力，通常产生更好的结果，但是使模拟更不稳定，尤其是当堆叠许多物体时。

	- Steps Per Second 

		每秒的模拟步数，值越高越精确，但速度越慢。这仅影响精确度而不影响模拟速度。

	- Solver Interations 

		约束解算器在每步模拟中的迭代次数，值越高越精确，但速度越慢。增加这项使约束和物体堆积更稳定。

- Cache 刚体缓存

	将模拟结果烘焙保存是很好的做法，烘焙固定下来后，在执行渲染时不会因为选择渲染区间，即开始与结束帧范围不同而导致模拟效果出现差异。

	如果尚未将文件保存，则会在内存中创建的缓存，因此请先保存文件，否则缓存可能会丢失。

	- Simulation Start/End 指定模拟处于活动状态的帧数范围，模拟的第一和最后一帧。
	- Bake 将仿真计算结果烘焙到缓存保存，需要在物体模式才能烘焙。
	- Calculate To Frame 将物理模拟运算烘焙到当前帧。
	- Current Cache to Bake 从当前缓存烘焙。
	- Bake All Dynamics 烘焙所有动力学结算结果。
	- Delete All Bakes 清除烘焙缓存。
	- Update All To Frame 更新缓存到当前帧。


- Field Weights 力场权重

	与其它物理动力学系统一样，刚体仿真也受外力效应的影响。可以在这里指定各种力场的作用比例，All 设置所有力场的作用比例。


提高刚体仿真稳定性的方法：

- 最简单是增加每秒的步数。但是，太多步骤可能会导致问题，使模拟更加不稳定，如果您需要超过 1000 步，你应该考虑其他方法来提高稳定性。
- 增加解算器迭代次数有助于增加约束，并提高物体堆叠稳定性。
- 最好避免使用小的物体，因为它们当前不稳定。理想情况下，物体的直径应至少为 20 厘米。如果仍有必要，将碰撞边距设置为 0，虽然通常不推荐，但可以帮助使小对象更自然地执行。
- 当物体很小，移动又非常快时，它们可以互相穿过。除了上面提到的内容之外，在这种情况下避免使用网格形状。网格形状由单个没有任何厚度三角形组成，所以物体可以更容易地穿过。您可以通过增加碰撞边距给它们一些厚度。

将刚体与其他模拟相结合
由于刚体模拟是动画系统的一部分，它可以影响其它模拟，就像动画系统一样。为了使其工作，刚体物体需要具有碰撞修改器，只需在物理属性选项卡添加碰撞 Collision 即可。

在模拟过程中也可以缩放刚体物体，在大多数情况下，这种方法很有效，但有时会导致问题。如果不需要动态缩放，则刚体物体应使用应用缩放工具 Ctrl-A，Apply Scale。



## 👉 Dynamic Paint 动态绘图
[Dynamic Paint Guide](https://miikahweb.com/en/articles/dynamic-paint-guide)
[Dynamic paint 动态绘图](https://www.bilibili.com/video/BV1z4411K7t5)

动态绘画是一种修改器和物理系统，可以将设置为 Brush 和 Canvas 的两个对象的运动接触，即 Brush 
对象在 Canvas 对象上绘画，产生相应的顶点颜色 Vertex Color、图像序列 Image Sequences 或置换
Displacement。使用这些生成的数据就可以实现许多效果。例如雪中的脚步，使地面变湿的雨滴，粘在墙壁上
的油漆或逐渐冻结的物体。

还可以同时启用笔刷和画布在这种情况下，同一个物体的笔刷不会影响其画布，但仍可以与场景中的其他物体交互。

首先将一个物体设置为 Brush 对象，用于在 Canvas 对象的 Surface 表面绘画。

- Settings

	- Color 绘画颜色。
	- Alpha 定义笔刷透明度或可见性，最终的湿度也受到 alpha 的影响。
	- Wetness 

		定义新添加的绘制的湿润程度。 湿度在绘画表面的打湿贴图上可以看出来。画布设置的滴水和蔓延效果
		的速度也取决于油漆的湿度。

	- Absolute Alpha

		用于限制笔刷 Alpha 影响。没有它，笔刷会在每一帧上一遍又一遍地叠加，提高 Alpha 从而增加了
		画笔对画布的影响。

	- Erase Paint 擦除绘画使笔刷消融现有的绘画，而在其上添加。

- Source Paint

	绘画源设置笔刷对象那个部位作用于画布，

	- Particle System 设置为粒子系统，那么笔刷影响由来自选定粒子系统的粒子定义。
	- Object Center 画笔对象中心点。
	- Proximity 靠近周边位置。
	- Mesh Volumen + Proximity 画笔对象的体积加周边位置。
	- Mesh Volumen 画笔对象的体积容器或中心点。

- Velocity

	画笔速度面板显示基于物体速度的画笔选项。基本上，颜色渐变表示画笔速度值：左侧为零速度，右侧为
	最大速度，速度以单位每帧衡量。

	- Multiply Alpha 使用取决于当前速度的颜色渐变的 Alpha 值，并将笔刷 Alpha 与之相乘。
	- Replace Color 使用来自颜色渐变部件 Ramp 的值替换笔刷的颜色。
	- Multiply Depth 倍增画笔深度交集效果。基本上，你可以根据刷速调整位移和波强度。
	- Smudge 启用涂抹可使画笔在移动时涂抹表面上的现有颜色。

- Waves

	画笔波浪面板用于将画笔影响调整为波浪曲面，结合画布的 Wave 产生效果。

	- Type 波浪类型，选择画笔在波浪模拟中创建的效果。

		- Depth Change 使画笔与曲面的交点深度更改时创建波形，如果刷子保持静止，则不会产生影响。
		- Obstacle 交叉时不断影响表面，波浪也会从这种刷子类型中反射出来。
		  由于波浪模拟算法的性质，如果刷子保持静止，这种类型会在表面产生不自然的凹痕。
		- Force 直接影响波浪运动的速度，笔刷交叉深度不是一对一的效果，而力的强度取决于它。
		- Reflect Only 这种类型仅反射已经在表面上的波。

	- Factor 因子调整画笔深度对模拟的影响程度，可以使用负值使画笔向上拉而不是向下拉水。

	- Clamp Waves 在某些情况下避免画笔刷子在表面内部过深而弄乱整个模拟结构，使用此设置将影响限制
	  到仅一定深度。



设置好画笔对象后，将另一个物体设置为 Canvas 对象作为画笔关联的画布，可以为其添加任意个 Surface 
即绘画表面或叫油漆表面。

注意：画笔和画布交互作用产生的数据是关联在网格顶点的，因此需要有足够的网格细度来关联数据。

绘画格式有两种：

- Vertex 应顶点颜色，直接在网格顶点数据上运行；
- Image Sequences 图像序列，可以在输出栏生成具有指定分辨率的 UV 包装图像文件；

每种格式可以产生四种数据，即 Surface Type 列表指定的四种漆面类型：

- Displace 置换

	产生接触位置的表面置换变形，模拟足迹等，这种漆面输出画笔对象的交叉深度。

	- Incremental 追加，在现有的表面上追加新的表面。
	- Max Displace 置换上限，最大交叉深度水平，较大的值将被钳制到该值。
	- Displace Factor 置换因子，交叉点深度的乘数。您可以使用它来调整最终位移强度或使用负值来绘制凸起。

- Wave 波浪

	画笔与漆面作用过程产生波浪效果。

	- Open BOrders 开放边界，允许波穿过网格边缘而不是反射。
	- Timescale 时间比例，直接调整模拟速度而不影响模拟结果。较低的值会使模拟变慢，否则会变慢。
	- Speed 速率，影响波浪在表面上的传播速度，也对应于模拟的大小。
	- Damping 阻尼，随着时间的推移降低波浪强度，调整波浪消失的速度。
	- Spring 弹力，调节将水拉回零水平的力。
	- Smoothness 平滑度。

- Paint 油漆

	油漆这种输出颜色和湿度值，在 Vertex 顶点格式的情况下，结果输出为顶点颜色和湿度数据，对应 
	Paintmap Layer 和 Wetmap Layer 两个顶点组数据层。默认是没有建立顶点组的，可以通过属性面板
	设置顶点组的名称，通过 + 加号建立顶点组。

	手动设置 Brush 对象的动画关键帧，或者使用物理系统的主动刚体产生的运动，使画笔对象与画布对象
	有接触即可以产生数据。

	为了在 3D 视图查看顶点色的变化，可以设置 Solid 视图模式，并在右上角的视图选项中设置 
	Color - Vertex。

	湿度数据 Wetmap 受干燥 Dry 选项设置影响，它定义油漆颜色开始转移到漆面时的润湿度变化速度，
	完全禁用干燥对于无限涂抹油漆非常有用。较低的值可用于防止涂料在干燥时变得透明，而较高的值通常
	会产生更好的结果。Dry Time 设置的时间以帧数为单位。

	这些生成的顶点组数据层可以在材质器中的，可以通过 Vextex Color 节点或 Attribute 节点引用，
	Name 填入顶点组名称即可以获得画笔对象在顶点绘制下来的颜色数据了。

- Weight 权重

	这是一种仅适用于顶点格式的特殊曲面类型，输出可由其他修改器或工具使用的顶点权重组。也可以可以
	配合粒子系统 Vertex Group 设置模拟水滴在沙子上消失的效果。

	要观察产生的权重数据，可以给画布对象添加一个快速烟雾效果来观察，对象模式下执行：
	Object - Quick Effects - Quick Smoke
	然后在物理属性面板中设置流体的顶点组为画布配置的权重顶点组。
	Settings - Vertex Group 

	或者给画布设置一个粒子系统，Hair 类型，将权重顶点组的名字填入粒子属性面板中的 
	Vertex Group - Density。

	使用点密度纹理节点 Point Density 却不能获取权重数据。


对于每种类型，都有特殊设置可供调整。大多数类型都有溶解 Dissolve 设置：

- Dissolve 溶解消除，用于在定义的时间期间使曲面平滑地返回其原始状态，勾选 Slow 时间加倍。
- Brush Collection 画笔集合，用于定义从中拾取画笔对象的特定集合。
- Scale Influence/Radius 影响量表，半径量表，用于为每个曲面单独调整画笔设置。


画布的其它选项：

- Initial Color 初始颜色，定义画布的初始颜色。

	- None 没有
	- 颜色
	- 紫外线纹理
	- 顶点颜色

- Effects 效果，这是绘画类型表面的特殊功能。它在画布表面上生成动画移动。

	- Spread 延申，油漆慢慢扩散到周围的点，最终填满所有连接区域。
	- Drip 滴落，油漆在力场，重力和速度指定的特定方向上移动，具有用户定义的影响。
	- Shrink 收缩，涂漆区域缓慢收缩直至完全消失。

	对于涂抹和滴落效果，只有湿漆会受到影响，因此当涂料干燥时，移动会变慢，直至停止。

- Cache 高速缓存，此面板目前仅对顶点格式曲面可见，您可以使用它来调整和烘焙点缓存。




## 👉 Fluid 流体模拟
[Blender 2.82 Mantaflow](https://www.bilibili.com/video/BV1vk4y1d7vQ)
[Flow Exploder](https://www.bilibili.com/video/BV1RW411Q7yu)
[Metaflow 流体框架](http://mantaflow.com/)

流体物理用于模拟流体的物理性质，特别是水。当在 Blender 中创造一个场景时，一些特定的对象可以被标记为参与流体模拟，这些对象包括但不限于流体和障碍物。对于流体模拟，你必须有一个域，来定义流体模拟发生的空间。在域设置中，你可以定义全局模拟参数(如粘度和重力)。


一般情况下，请按照下列步骤：

- 首先，设置一个模型如 Cube 作为模拟作用的区域 Domain，即烟雾的体积容器；
- 在物理属性面板给 Cube 设置为 Fluid 流体，Type 选择 Domain；
- 然后，设置流体源及其物理属性，如建立一个球体作为流体源对象；
- 在物理属性面板给球体设置 Fluid 流体，Type 选择 Flow；
- 以上两步会自动给模型添加 Fluid Simulation 修改器；
- 设置效果器物体 Effector，使流体与场景中的物体交互；
- 为流体域物体分配材质，模拟出来的流体就是指定的材质效果；
- 流体域的材质通常设置类似玻璃材质，需要设置 Volume Absorption 节点；
- 最后，执行烘焙模拟生成模拟结果，然后才查看流体动画效果。
- 满意模拟效果，再在流体域的 Mesh 面板中将结果烘焙下来形成流体模型。

新版本中模拟数据的烘焙会在动画播放时自动执行，当一个流体域被烘焙后，它将变为流体网格，即 Cache 面板中指定的缓存，需要模拟的帧范围可以进行调整。

要手动执行烘焙功，能需要设置高速缓存类型 Cache - Type - Modular，使用 Replay 方式要留意自动烘焙的数据是否时最新的修改配置后的。

流体对象还可设置属性 Viewport Display - Display As Wire 这样就会在视图中显示为轮廓线，还有去掉 Visibility - Show in Renders 以面渲染。

如果不能正常渲染 Mantaflow 流体，试着以管理员账户运行 Blender 2.82。



### ⚡ Domain 流体域对象

即流体面板中 Type 设置为 Domain 的对象，其盒型边框作为模拟的边界，所有流体对象必须 在流体域内部，流体域外的对象将不进行烘焙。微小液滴不会移动到流体域边界外，就好像流体被无形力场束缚在三维空间内。在场景中仅允许存在一个流体模拟域。

流体域的形状并不重要，因为它总会被当作一个盒子(盒子的边框长度可以是不同的)。所以，通常没有理由去使用除盒子外的其他形状。如果你需要非盒状的障碍或边框来影响流体流动，你需要在流体域边界 内部 插入额外的障碍物体。

流体域有两种类型，Liquid 和 Gas，分别用来模拟液体和气体，不同的模拟类型使用不同的参数，以下是通用参数说明：

- Settings

	- Domain Type 设置流体域类型，Liquid 和 Gas，分别用来模拟液体和气体。
	- Resolution Divisions 控制流体域细分度，Voxels 即像素构成的流体单位，其细分度高越细致，在线框中可以看到流体域的一个角落有一个小盒子。
	- Time Scale 控制模拟速度，小值模拟慢动作。

	Controls the speed of the simulation. Low values result in a "slow motion" simulation, while higher values can be used to advance the simulation faster (good for generating fluids to be used in still renders).

	- CFL Number 用于降低模拟步数和时间的一个编码，CFL 是三个作者的简写 Courant–Friedrichs–Lewy，值越小模拟越精细。
	- Use Adaptive Time Steps 遇到每帧多个模拟步骤时使用自适应时间步数。
	- Timesteps Maximum 时间步长最大值，如果需要会将模拟步骤分解成子步骤。
	- Timesteps Minimum 解算器给每帧的模拟步骤至少分配的时间。
	- Using Scene Gravity 设置使用重力各个轴线分量值，会覆盖场景的设置。禁用全局重力，Scene - Gravity，可以启用流体的重力。

- Border Collisions 边界碰撞，勾选控制哪个方向的碰撞可以影响流体。

注意，烘焙功能需要设置高速缓存类型 Cache - Type - Modular，即模块化烘焙类型的缓存。如果网格有修改器，渲染设置会用于将网格数据导出到流体解算器内。模拟结果可以导出为 Mantaflow 脚本。

- Cache 高速缓存

	使用烘焙缓存前需要保存文件，注意，使用 Replay 方式会自动在播放时执行模拟，但不能保证每次都在修改参数后执行，可以使用 Final 执行手动烘焙。

	Blender 2.8x 使用还不是很稳定，即使使用 Quick Smoke 制作的烟雾，也可能渲染不到正确的烟雾，即使渲染视图有烟雾效果，可是用 F12 渲就没有烟。不清楚是否 GPU 驱动有问题。

	- Cache Directory 设置模拟数据缓存保存的目录。
	- Type 设置缓存类型，决定了什么数据可以烘焙

		- Modular 模块化烘焙，可以独立烘焙流体域配置数据、Fluid、Particles、Mesh 等面板的数据；
		- Final 可以将模拟结构统一烘焙缓存文件；
		- Replay 在模拟过程播放时自动烘焙；
	
	- Start 模拟开始的帧位置。
	- End 模拟结束的帧位置。
	- Data File Format 指定缓存数据文件格式。

		- Uni Cache 内置格式；
		- Raw Cache 内置无压缩格式；
		- OpenVDB 使用 DreamWorks Animation 开发的高效格式；

	- Particle File Format 指定流体模拟中的粒子数据缓存格式。
	- Mesh File Format 指定流体模拟中的网格数据缓存格式。

- Guides 辅助力

	流体辅助力给流体模拟内部设置力的影响。

- Collection 集合限定

	- Flow 设置流对象的集合，如果设置，那么当前流体域中属于指定集合内的流对象才有效。
	- Effector 指定效果器集合，如果设置，那么只有集合内的效果器才生效。

- Field Weights 力场权重

	设置什么力场对流体域起作用，起多大作用。Effector Collection 指定生效的效果器集合，Gravity 设置重力的有效比例，All 设置其它力的有效比例。


以下是气体流体域的专用参数，Blender 2.8x 版本变化较大，2.83 新版重新组织了面板，2.81 版中 Flames 可以设置 Smoke Color，新版改为 Flame Color。并将流对象中 Smoke Color 移除，这样更合理了，不会显得混乱。

- Smoke

	Blender 2.83 版本又重新组织了面板，将其移到流对象中设置，更合理了。

	- Buoyancy Density 设置烟雾密度浮力，正值上升，负值下沉，上升即烟轻于周边空气。
	- Heat 设置烟雾热度浮力，正值上升，负值下沉。受烟雾流体对象的 Initial Temperature 初始温度约束，多个流体对象的温度相互影响，热上升，冷下降。
	- Fuel 涡量控制烟雾的涡流量，值越大小漩涡越多，值越小涡旋越少。
	- Dissolve 设置烟雾溶解消失的时间，以帧为数。勾选 Slow 为对数方式，logarithmic fashion，开头加速收尾加长。

- Fire

	- Reaction Speed 燃烧反应速度，值越大火苗越小，因为燃料没喷远就烧掉了。
	- Flame Smoke 火焰烟雾量。
	- Vorticity 火苗涡旋增加量。
	- Temperature Maximum/Minimum 火苗最高低温度，值越大火苗上升越快，火苗的温度对应颜色。
	- Flame Color 火焰颜色。

- Noise 

	噪波可以增加模拟真实的细节。

	- Upres Factor 设置噪波分辨率系数。
	- Noise Method 设置生成方法，目前只有 Wavelet。
	- Strength 噪波强度，愈大噪波扰动越多。
	- Scale 噪波缩放比例。
	- Time 噪波动画时间。

	- Bake Noise, Free Noise 烘焙噪波，需要设置缓存方式为模块化方式 Modular

- Guides

	使用 Primal-Dual Optimization for Fluids 方法对流体进行引导优化。

	- Weight 
	Controls the lag of the guiding. A larger value (also known as the ‘alpha’ guiding value) results in a greater lag.

	- Size 设置引导产生的漩涡大小；
	- Velocity Factor 速度系数，每个引导格子都乘于这个系数，速度格子和引导流体域同大小；
	- Velocity Source 引导速度来源
		- Effector 流体域内部运动的效果器对象作为引导速度格子，烘焙后不可以再求改流体域的分辨率；
		- Domain 使用其它流体域作为速度引导源，当前流体域可以分辨率和类型不同，但需要经过烘焙；
	- Guide parent 指定作为引导的其它流体域对象；

	- Bake Guides, Free Guides 烘焙引导，需要设置缓存方式为模块化方式 Modular；

- Adaptive Domain

	流体域会适应模拟的结果，以动态的更改大小。

	- Add Resolution 附加分辨率设置给流体域外增加 Voxels 模拟单位。
	- Margin 边距设置给烟雾预留的 Voxels 单位空间，可用于快速移动的烟雾以避免画面边界隔断。
	- Threshold 设置阈值以使模拟器认定哪些附加的 Voxels 可以被丢弃处理。


- Viewport Display 视口显示选项




以下是 Liquid 流体类型使用的参数：


- Liquid

	流体面板的参数控制模拟中的使用的粒子系统，勾选后为流体模拟提供粒子视觉效果，会自动在粒子面板添加一个 Liquid 粒子对象，这个粒子系统用来视觉化模拟出来流体。

	- Simulation Method 模拟方法，当前只支持 FLIP 模拟方法。
	- FLIP Ratio 设置更新流体粒子速度时的 FLIP 速度比率，大值带来更多的扰动和飞溅。
	- Particle Radius 粒子半径，越大覆盖模拟区域的格子越多。

		粒子最大值
		The maximum number of liquid particles per grid cell. During a simulation the number of liquid particles in a cell can fluctuate: Particles can flow into other cells or can get deleted if they move outside the narrow band. Resampling will add new particles considering this maximum.

		This value sets the upper threshold of particles per cell. It is also a good way to estimate how many particles there can be in your simulation (one needs to take grid resolution into account too). This can be useful before baking and when planning a simulation.

		Particles Minimum
		The minimum number of liquid particles per grid cell. Similarly to the maximum particle threshold, this value ensures that there are at least a certain amount of particles per cell.

		粒子采样
		Factor that is used when sampling particles. A higher value will sample more particles. Note that particle resampling occurs at every simulation step.

		窄带宽度
		Controls the width in grid cell units of the narrow band that liquid particles are allowed to flow in. A high value will result in a thicker band and can result in an inflow region completely filled with particles. Unless the goal of the simulation is to visualize the liquid particles it is recommended to not increase the band width significantly as more particles slow down the simulation.

		In some situations increasing this value can help create volume when the simulation appears to leak. In all other cases it is best to keep the narrow band as thin as possible since the liquid surface contains most details and simulating particles inside the liquid is not an optimal use of computing resources.

		See also

		The narrow band is an implementation of Narrow Band FLIP for Liquid Simulations.

		粒子随机性
		New particles are sampled with some randomness attached to their position. This field controls this randomness. Higher values will sample the liquid particles more randomly in inflow regions. With a value of 0.0 all new particles will be sampled uniformly inside their corresponding grid cells.

		When trying to create a laminar inflow (with little randomness) or more turbulent flows (with greater randomness) this value can be useful.

		分数障碍
		Enables finer resolution in fluid / obstacle regions (second order obstacles). This option reduces the "stepping effect" that results when an obstacles lies inclined inside the domain. It also makes liquid flow more smoothly over an obstacle.

		Obstacle-Fluid Threshold
		Value to control the smoothness of the fractional obstacle option. Smaller value reduce the "stepping effect" but may result particles sticking to the obstacle.

		Bake Data, Free Data
		This option is only available when using the Modular cache type. Bake Data simulates and stores the base of the fluid simulation on drive. Both gas and liquid simulations can add refinements on top of this (e.g. gas simulations can add noise, liquid simulations can add a mesh or secondary particles or both).

		The progress will be displayed in the status bar. Pressing Esc will pause the simulation.

		Once the simulation has been baked, the cache can be deleted by pressing Free Data. It is possible to pause or resume a Bake All process.


- Mesh

	流体模拟结果可以在这里烘焙固化成为流体模型网格对象，烘焙网格需要在缓存类型设置 Cache - Type - Modular。

	流体网格和流体粒子的使用可以比设置高度细分 Resolution Divisions 更能提高视觉效果。

	- Upres Factor 设置
	Factor by which to enhance the resolution of the mesh. The scaling factor is coupled to the Resolution Divisions (i.e. the mesh is this times bigger than the base simulation).

	Particle Radius
	The radius of one liquid particle in grid cells units. This value describes how much area is covered by a particle and thus determines how much area around it can be considered as liquid. A greater radius will let particles cover more area. This will result in meshes covering more volume around liquid particles.

	This property refers to the same Particle Radius described in the liquid domain settings. Yet for the mesh, it is useful to interpret the particle radius on its own. For one, the mesh can have a resolution different from the base resolution through the Upres Factor. For another, it is often desirable to be able to control the mesh size around a single liquid particle.

	- Use Speed Vectors 勾选将速度矢量保存下来，以供图像运动模糊使用。
	- Mesh Generator 网格生成方法，Final 表示生成高质量网格，Preview 表示快速生成预览网格。
	- Smoothing Positive 
	Positive mesh smoothing iterations. Higher values will make the mesh outline increasingly smooth. Yet higher values can prevent small details (e.g. smaller liquid drops) from getting meshed.

	Smoothing Negative
	Negative mesh smoothing iterations. Higher values will make the mesh outline sharper. High values will preserve details, however, the mesh outline will become more ragged (e.g. a single mesh particle will become less rounded and have more flat sides).

	Concavity Upper
	Upper mesh concavity bound. High values tend to smoothen and fill out concave regions.

	Concavity Lower
	Lower mesh concavity bound. High values tend to smoothen and fill out concave regions.

	Using a lower concavity which is greater the upper concavity can result in distorted, non-manifold meshes. Unless the artist sees value in this kind of mesh, such concavity value combinations should be avoided.

	Crown splash with varying upper and lower concavity settings. Note that setting the concavity values to the same value produces a very granular mesh.


- Diffusion

	漫射调整液体的流动性，也就是流体动力粘度，单位厘泊。

	- Viscosity Presets 提供黏度配置预设，蜂蜜黏度 Honey 10000厘泊/ 原油黏度 Oil 500厘泊/ 清水黏度 Water 1厘泊。

	- Base 粘性基准值，比如水在 20℃ 为 1.002.
	- Exponent 幂，基准值的幂，比如水指定为 6 就是 1.002x10^6。
	- Real World Size 指定模拟的物体在真实世界的大小，单位米，以流体域的最长边为准。
	- Surface Tension 用格数表示表面张力，越大张力越强。

- Particles

	提供额外三种粒子效果选择，浪花 Spray/ 泡沫 Foam/ 泡泡 Bubble，勾选后自动在粒子属性面板上添加粒子对象。 



### ⚡ Flow 流体对象

流体对象，即流体面板中 Type 设置为 Flow 的对象，流体模拟就在该域边界框内进行。如果你将多个流体对象放置于流体域内部，他们目前不应该相交。另外，还要确保表面法线朝外。与流体域对象相反，流体对象使用其实际网格几何数据。

根据流体域的模拟能力，流体对象可以是以下四种效果，需要对应设置：

- Smoke 烟雾，对应流体域类型 Gas；
- Fire + Smoke 烟火，对应流体域类型 Gas；
- Fire 火苗，对应流体域类型 Gas；
- Liquid 液体，对应流体域类型 Liquid；

每种效果可以选择流体的行为 Flow Behavior 为 Inflow/Outflow 流出流体或吸收流体的对象，或成为补液/抽液更好理解，用来控制流体模拟体积，对象大小与流量相关。选项 Use Inflow 可以通过关键帧控制是否处于激活状态。Geometry 方式表示以几何体为流体的固有体积，如果需要喷射流就需要使用 Inflow 行为方式。

- Settings

	- Flow Type 设置流体模拟效果类型。。
	- Flow Behavior 流体的行为模式。

		Inflow / Outflow 流出流体或吸收流体的对象，或成为补液/抽液更好理解，用来控制流体模拟体积。选项 Use Inflow 可以通过关键帧控制是否处于激活状态。

	- Sampling Substeps 采样步长，越小的表示采样数越少，模拟出来的间隙越大。

	- Smoke Color 烟雾颜色，不同的流体烟雾色会进行混合，可以通过属性节点引用。在新版中，已经取消。
	- Absolute Density 勾选绝对密度使发射器在有空间的位置产生更多的烟火。
	- Initial Temperature 初始温度结合流体域对象中的烟雾热力升力约束烟雾的升降。
	- Density 每次发射烟火的密度，越大越浓。
	- Fuel 单位时间燃料的燃烧率，越大越多火苗。
	- Vertex Group 通过指定顶点组来控制烟火的发射位置。

- Flow Source 流来源

	- Flow Source 

		设置流发射来源，Mesh 表示从对象的网格发射，烟火还可以选粒子系统 Particle System。

	- Is Planar

		勾选指定发射对象为平面对象或非流形几何对象 Non-manifold，以使得模拟器准确模拟网格。

	- Surface Emission 

		指定发射表面的大小，越大烟火就越越大，受流体域 Voxels 细分度影响。

	- Volume Emission 

		控制发射对象的体积发射烟火量，1 表示全体积的流都发射。对于非流形 non-manifold 可能有不可预测结果。

	- Particle System 
	
		从当前流体对象中设置好的粒子发射器 Emitter 中挑选一个作为烟雾的发射器，为了避免受默认的重力影响，可以设置粒子的 Forces Weight 中的重力系数为 0。

	- Set Size 指定粒子系统的发射距离，类似设置 Surface Emission。

- Initial Velocity 初始速度

	- Source 设置参考量，流对象会从流源继承动能 Momentum，设置 1 表示和流源同速度。。
	- Normal 设置沿流源法向的速度，如果使用 Geometry 流源时。
	- Initial X, Y, Z 设置各轴初始速度分量，可以指定负值来模拟喷射，比如 -3，烟雾受热力作用，需要结合发射器的运动速度。

- Texture 纹理

	勾选后对烟火模拟的网格使用纹理来控制烟雾的发射位置，纹理图中白色为发射为，对 Outflow 行为模式无效。

	- Texture 指定纹理。
	- Mapping 指定纹理映射 UV 坐标，Generated UVs 或手动的 UV 映射。
	- Size 设定纹理尺寸。
	- Offset 设置纹理 Z 轴偏移量。


### ⚡ Effector 效果器

Blender 2.82 使用效果器替代了前一版本中的阻碍对象 Obstacle，其它流体对象变成 Flow Behavior 选项：

- Obstacle 该对象将被用于流体模拟中的障碍。
- Particle 用于显示在模拟过程中产生的粒子，目前只支持对随流体涌动粒子的示踪。
- Control 使用格子玻尔兹曼方法，采用物理模拟或一系列目标形状生成的局部力场定义的粒子，来控制流体。

比如设置一个 Obstacle 对象可以模拟流体的碰撞效果，修改 Slip Type 即滑入类型，它决定障碍物表面的粘着性。表面粘性在现实世界中取决于流体表面的颗粒度或摩擦/粘附/吸收性质。注意，流体模拟无法使用物理系统产生的运动。

- No Slip 无滑动导致流体附着在障碍上，即速度为 0。
- Free Slip 自由滑动允许沿障碍运动，仅法向速度为 0。
- Partial Slip 部分滑动包括以上两种类型，0 是基本无滑动，1 与自由滑动相同。
- Amount 决定无滑动和自由滑动之间的混合量。
- Impact Factor 流体体积与移动物体撞击时体积增/减的矫正参数。如果物体不动，则该设置没有任何效果。物体运动并与流体碰撞时，负值代表从流体域抽走流体体积，产生液体脱离流体的效果。

新版效果器有两种 Collision 碰撞对应旧版障碍对象，还有引导对象 Guide，它应该有移到速度，在烘焙时需要。

- Is Planar 将效果器定义为单维度物体即平面或网格为非流形。这可确保流体模拟器为这些类型的网格提供最准确的结果。流体解算会忽略网格内部的体积，直接从网格侧面流动。

- Thickness 表面厚度增加效果器的额外厚度。

- Volocity Factory 速度系数会与引导对象的速度相乘，用来修正速度。

- Guide Mode 引导模式会在引导对象的速度和流体域全局引导速度字段进行比较取舍。



## 👉 Smoke 烟雾模拟

Blender 2.81 适用，新版本使用 Mantaflow 流体，移除了 Smoke 修改器，整合到了 Fluid。

烟雾模拟是流体系统的一个子集，可用于模拟空气中固体，液体微粒和气体的混合，例如那些构成烟雾的物质。 它模拟空气的流体运动并生成动画 体素 纹理，表示可用于渲染的其他流体或悬浮颗粒(例如烟雾)的密度，热量和速度。

烟雾和火焰从网格物体或粒子系统中发射到域 。 烟雾运动由域内的气流控制，可受以下因素影响 烟雾碰撞物体 。场景里的力场也会影响烟雾。 域内的气流可以通过 烟流 力场影响其他物理模拟。

Blender 的烟雾模拟基于康奈尔大学 Theodore Kim, Nils Thürey, Doug James, and Markus Gross 的论文，相关的示例代码 [Wavelet Turbulence for Fluid Simulation](https://www.cs.cornell.edu/~tedkim/wturb/)

创建烟雾模拟，一个 域 物体和一个 流 物体 是必需的。基本工作流程如下所示：

- 创建一个 域 物体 来定义模拟体积的范围。
- 创建一个 流 物体 来发射烟雾和火焰。
- 设置 碰撞物体 来使烟雾和场景中的对象相互作用。
- 将体积材质赋予给域物体，可以使用原理化体积着色器来实现真实烟雾效果。
- 保存 blend 文件。
- 烘焙 模拟.

域物体内部包含整个模拟。 烟雾和火焰不能都离开域，它们将根据域的行为设置来选择与域的边界碰撞或者消失。域模型越大就需要越高的分辨率和更长的烘焙时间， 您需要使其足够大以使模拟适合其中，但不要太大以至于计算模拟所需的时间太长。

要创建一个域，请添加一个立方体，或者 Shift-A 添加 Mesh - Cube，调整形状直到它包含您想要实行烟雾火焰的区域。 将其转换为烟雾域，请通过属性编辑器的物理面板操作，Physics Properties - Smoke - Type - Domain。

烟雾流物体用来在烟雾域中发射或者吸收烟雾和火焰，要将任何网格物体定义为烟雾流物体，请通过属性编辑器的物理面板添加，Physics Properties - Smoke - Type - Fluid。现在您应该有一个默认的烟雾流物体，可以通过播放第一帧中的动画来测试它，播放第一帧时就会对烟雾进行模拟运算生成模拟效果。 如果您的烟雾 流物体在域中，您应该可以在 Wireframe/Solid 视图渲染方式下看到冒烟。

可以使用其他形状的网格物体作为域对象，但烟雾模拟器将使用形状的 bounding box (边界框)作为域边界。 换句话说，域的实际形状仍然是长方体。

给烟雾添加碰撞物体用于偏转烟雾并影响气流，要将任何网格物体定义为烟雾碰撞物体，请在属性编辑器的物理面板中设置，Physics Properties - Smoke - Type - Sollision。和大多数物理系统一样，支持 力场 (例如风力和涡流)，各个力场的权重可以被 控制 。

最后将模拟结果烘焙用于存储，烟雾烘焙的设置在烟雾域对象中，找到属性编辑器物理面板下的 Cache，与大多数物理模拟不同，它有专门用于烟雾的设置选项。只有保存blend文件后才能进行烘焙。 

烟雾流类型及主要设置如下，Flow Source 是烟雾模型中很重要的一个属性，设置用于发射烟雾和火焰的源：

- Flow Type

	- Outflow 流出，去除烟雾和火焰。 请注意，流出的形状将使用物体的 bounding box (边界框).
	- Smoke 只排放烟雾。
	- Smoke+Flame 发射火焰和烟雾。
	- Flame 只发射火焰，域将自动创建一点点烟雾来模拟燃烧燃料留下的烟雾。

- Flow Source

	- Mesh 网格源表示直接从物体的网格发射烟雾/火焰。
		- Surface 设置距离创建烟雾的网格表面最大距离。
		- Volume 体积，设置发射器网格内发出的烟雾量，其中 0 表示无，设置为 1 可能在 non-manifold 非流网格产生不可预测的结果。
	- Particles System 从流物体上的发射类型的粒子系统创建烟雾/火焰。 

- Flame Rate 火焰比率设置每秒燃烧的燃料量。
- Sampling Subframe 采样子帧用于减少快速移动源导致的烟雾发射间断问题。

- Texture 使用网格物体 Mesh 作为流动源，则可以使用纹理来控制网格烟雾的发射位置，这些设置对流出物体没有作用。


## 👉 Smoke & Volume Shader
[Volume Shader](https://www.bilibili.com/video/av34938292/)
[Voronoi Texture 体积着色器造云](https://www.bilibili.com/video/BV167411s7tt)

给烟火域调制材质是比较难的步骤，想真实的效果就需要设计合理的材质，为了方便调试材质，Blander 界面
分成三个区域，一个打开材质节点编辑器，另外两个设置为 Rendered 和 Solid 渲染方式的 3D 视图。

需要使用 Cycles 渲染引擎以支持真实光线追踪效果，Eevee 作为一个实时引擎不能实现完整支持体积着色器。

有三个关系密切的体积着色器：

- Principled Volume 原理化体积着色器

	集成所有体积着色器的功能，包括 Volume Absorption 和 Volume Scatter 的功能，含有散射，
	吸收和黑体辐射属性。还自动获取模型中的 density 和 temperature 两个属性数据。可以在颜色属性
	中指定用于为体积着色的网格，使用其颜色进行烟雾模拟。

	黑体强度设置火焰的黑体辐射量，设置为 1 可获得物理学上准确的强度。

	任何物体都具有不断辐射、吸收、反射电磁波的性质，黑体 black body 是一种理想物体化定义的物体。
	在任何条件下，对任何波长的外来辐射完全吸收而无任何反射的物体，即吸收比为 1 的物体。

	在黑体辐射中，随着温度不同，光的颜色各不相同，黑体呈现由红橙黄白蓝的渐变过程。光源颜色对应的
	黑体温度称为该光源的色温，黑体的温度越高，光谱中蓝色的成份则越多，而红色的成份则越少。例如，
	白炽灯的光色是暖白色 4700K，而日光色荧光灯的色温表示则是 6000K。

- Volume Absorption 体积吸收着色器

	允许光在通过体积时被吸收，允许部分光穿透，吸收的结果就是看起来没有相应的颜色了，典型用法是水
	和彩色玻璃效果的制作。体积的颜色设置允许透过的颜色，白色表示完全允许光线穿透，黑色表示对光线吸收。

- Volume Scatter 体积散射着色器

	让穿过物体的光线在碰到粒子后散射，散射密度设置越大光线散射越强。为场景添加弱散射看起来就是雾气
	朦胧的效果，是一个典型的用法，可以与体积吸收一起制作烟雾效果。Color 设置体积的颜色，当白色光线
	穿透时，相同的颜色就会被散射出去，使得穿透体积的颜色缺失了这部分颜色，看起来的效果就是补色。

	比如色红的体积会导致白光穿透显示为青。在一定浓度，体积色为白色看起来是黑的，体积色为黑色看起来
	就是透明的。

利用体积着色器的吸收、散射原理，可以用来实现像火，烟，雾，或者玻璃吸收光的渲染效果，以及许多不能单独
用表面网格所表现的效果。


对场景的 World 对象使用体积着色器就可以模拟烟雾环境。利用 Voronoi Texture 噪声节点结合渐变映射
ColorRamp 和体积着色器产生鱼鳞云效果，但是还不能模拟出积雨云的效果。

以下是制作步骤：如果使用 Eevee 引擎，需要设置一下引擎的体积化参数，在体积化面板中 Volumetrics，
适当减小 Tile size 和增加 Samples 以提高图像细腻度。勾选体积阴影 Volumetric Showdows，通过
吸收体积物周围的近似光来模拟阴影，这是一个非常消耗资源的选项。

- 加入一个 Cube，调整成不太厚的板状，添加材质，用上原理化体积着色器，Principled Volume 体积色设置浅白；
- 修改场景的点光源为太阳光，因为光源较近，强度设置 10 左右，让 Cube 对象看起来有点像云的灰白色即可。
- 继续添加 Noise 或 Voronoi 纹理节点生成色块，将生成的 Color 输出到 Principled Volume 的密度端口，这时变化不是很明显需要提升色彩的层次。
- 将生成的色块通过 ColorRamp 进行提升，移动渐变映射的黑色标到右侧靠近白色形成一条窄的灰度映射带，这样得到的输出就是黑低白加白色块的图片。
- 经过 ColorRamp 调整后得到基本的云层结构，但是缺少云层的厚度感，这是因为输入的坐标映射有问题。
- 添加一个纹理坐标节点 Texture Coordinate 和映射节点 Mapping，使用 Object 作为坐标输入到映射节点 Vector，再接入纹理节点。
- 经过以上设置机有云絮状物，但还是缺少云层的团状结构，需要使用 Math 进行纹理运算再合并使用，以产生更丰富的云团层次。



以下材质节点参考其它教程：

- 给域模型两个设置两个体积着色器 Volume Absorption 负责吸收色、 Volume Scatter 负责散射色，散射浓度 Density 0.5；
- 通过 Add Shader 节点连接到 Material Output 的 Volume 上，这时还看不到模拟的结果，只看到渲染的浓烟；
- 添加一个属性节点 Attribute 以使用烟雾模型自身的浓度属性来控制这连个体积节点；
- 属性节点的 Name 填写 density，然后将系数 Fac 连接到一个亮度/对比度节点 Bright/Contrast，这样更方便调整浓度；
- 连接亮度/对比度节点的色彩属性到两个体积节点的 Density 属性上；

有了烟雾浓度属性的控制，基本的材质效果基础就有了，接下来进行火焰和烟雾的色彩调整。火焰部分利用 flame 属性数据经过 ColorRamp 渐变映射为焰芯的色彩变化：

- 给输出节点添加一个发光着色器用来模拟火焰及烟雾的色彩，同样使用 Add Shader 节点并联；
- 添加发光体后，模型就或变白色的一块，还需要使用烟雾模型的火苗属性数据对发光体进行控制；
- 添加一个属性节点 Attribute 并指定 Name 为 flame 以使用烟雾模型控制反光体，连接系数和 Fac - Color；
- 发光体有了火苗的基本形态后，还需要进行颜色处理，那就在属性节点和发光体间插入 ColorRamp 节点进行颜色渐变处理；
- 在渐变条设置大概 5 个色标，从左到右依次 #8E0801 #E11A00 #F1E400，最后两个色标控制烟雾发射点位置的色彩，适当设置透明；
- 设置好色彩后，还需通过火苗属性节点对发光体的强度进行控制；
- 为了方便调整效果，Attribute 节点可以接入亮度/对比度节点 Bright/Contrast，再通过一个 Math 运算节点去控制发光体强度，算法设置为乘法运算；
- 另外，ColorRamp 也可以通过伽玛着色器节点 Garmma 和色调/饱和度着色器节点 Hue/Saturation 调整后再接输出；

一句话总结一下，使用 Attribute 节点读取 density、 flame 两组数据灰度数据，分别用来控制体积
着色器 Volume Absorption、 Volume Scatter 和发光着色器 Emission。

以上就是一个火焰着色器，可以在着色器编辑器中打包成自定义节点方便复用。选中所有节点除输出节点外，
Ctrl-G 打包，要切换编辑按 Tab 切换，侧栏属性面板还提供更多设置。打包后可以设置输入、输出端口，
将需要自定义的端口导出到分组对外端口，这样方便重复利用，还可以通过文件链入在其它文件中使用 
File - Links 浏览 blend 文件，双击进入选中 Materials 材质部分链入。




## 👉 Solar System Scope - Sun, Earth, Moon and Stars

Blender Sun https://www.bilibili.com/video/av79708264/
Sun Texture - https://www.solarsystemscope.com/textures/
CGI Moon Kit https://svs.gsfc.nasa.gov/4720

Textures in this pack are based on NASA elevation and imagery data. Colors and shades of the textures are tuned accordng to true-color photos made by Messenger, Viking and Cassini spacecrafts, and, of course, the Hubble Space Telescope.

NOTES:

Some parts of the planets remain to be mapped. These “gaps” are filled with fictional terrain that corresponds with the rest of the landscape.

The colors are slightly more saturated in order to highlite a unique nature for each object.

Earth textures are the most precise part of the pack: They are a result of merging and adjusting large amount of geo-data, space photos and images from NASA’s Blue Marble (which might well be the 2nd best collection of Earth’s textures available, so check it out)

True Earth colors (as seen from space) may vary depending on the camera used, duration of exposure, lightning conditions and atmospheric conditions. Textures in our pack are sharp, bright and colorful.

Seasonal variations affect Earth’s flora and snow coverage. Earth in our textures has a lot of vegetation and less snow.

Distributed under Attribution 4.0 International license:
You may use, adapt, and share these textures for any purpose, even commercially.


下面模拟一个太阳系模型，为了便于观察，模型的数值关系不与现实一致。需要用到 NASA 的太阳、地球等图片素材，可以在 www.solarsystemscope.com 网站上下载，以下数据仅供参考。

- 类地行星
	- ☿ 水星 Mercury 0.4 天文单位，是最靠近太阳，也是最小的行星，0.055 地球质量。直径 4878 km，公转 87.97 地球日，自转 58.65 地球日。
	- ♀ 金星 Venus 0.7 天文单位，体积尺寸与地球相似，0.86 地球质量，表面的温度超过400℃。直径 12103.6 km，公转 224.7地球日，自转 243 地球日。
	- ⊕ 地球 Earth 1 天文单位，是内行星中最大且密度最高的，也是唯一地质活动仍在持续进行中并拥有生命的行星。
	- ♂ 火星 Mars 1.5 天文单位，比地球和金星小，0.17 地球质量，只有以二氧化碳为主的稀薄大气，表面有巨大的火山和深邃的地堑。
- 类木行星
	- ♃ 木星 Jupiter 5.2 天文单位，主要由氢和氦组成，有云带和大红斑，有大量卫星，木卫三号比水星还要大，是太阳系内最大的卫星。
	- ♄ 土星 Saturn 9.5 天文单位，它与木星非常相似。土星不是很大，质量只有地球的95倍。
	- ♅ 天王星 Uranus 19.2 天文单位，是最轻的外行星，质量是地球的 14 倍。它的自转轴对黄道倾斜达到 90°，因此是横躺着绕着太阳公转，在行星中非常独特。
	- ♆ 海王星 Neptune 30 天文单位，虽然看起来比天王星小，但密度较高使质量仍有地球的 17 倍，它也是太阳系内唯一逆行的大卫星。


| 项目   | 赤道半径(km) | 偏率° | 赤道重力 | 体积比  | 质量比 | 比重比 | 轨道半径比 | 轨道倾角° | 赤道倾角° | 公转周期(地球日/年) | 自转周期(地球日) | 已知卫星数量 |
| ------ | ----------- | ---- | -------- | ------ | ------ | ------ | --------- | -------- | -------- | ------------------ | --------------- | ---------- |
| 太阳   |      696000 |  0.00 |  28.01G | 1304000 | 333400 | 1.44 | --    | --    | 7.25  | 2.26*10⁸年 | 25.38天/37.01天 | -- |
| 水星   |        2440 |  0.00 |   0.38G |   0.056 | 0.055  | 5.43 | 0.387 | 7.005 | ~0    | 88天    | 59天 | 0 |
| 金星   |        6052 |  0.00 |   0.91G |   0.857 | 0.815  | 5.24 | 0.723 | 3.395 | 177.4 | 225天   | 243天 | 0 |
| 地球   |        6378 | 0.003 |   1.00G |    1.00 | 1.000  | 5.52 | 1.000 | 0.000 | 23.44 | 365天   | 24h | 1 |
| 火星   |        3397 | 0.005 |   0.38G |   0.151 | 0.107  | 3.93 | 1.523 | 1.850 | 25.19 | 687天   | 24h37m | 2 |
| 木星   |       71492 | 0.065 |   2.48G |    1321 | 317.832 | 1.33 | 5.202 | 1.303 | 3.08 | 11.86年 | 9h50m | 69 |
| 土星   |       60268 | 0.107 |   0.94G |     755 | 95.16  | 0.69 | 9.554 | 2.489 | 26.7 | 29.46年  | 10h4m | 62 |
| 天王星 |       25559 | 0.023 |   0.89G |      63 | 14.54  | 1.27 | 19.22 | 0.773 | 97.9 | 84.01年  | 17h14m | 27 |
| 海王星 |       24764 | 0.017 |   1.11G |      58 | 17.15  | 1.64 | 30.11 | 1.770 | 27.8 | 164.82年 | 16h06m | 13 |

历史上约定地球跟太阳的平均距离为一个 Astronomical Unit 天文单位长度，等于 149,597,870,700 米，近 1.5 亿公里。月球是地球唯一的一颗卫星，地月距离，月球轨道平面即白道面，与地球轨道平面即黄道面保持著 5.15° 的夹角，即 5°09′。地球公转绕太阳一圈约 365 天，自转一圈约 1 天，黄道面与地球自转轴夹角 66°34'。黄赤交角 23°26'，也称为太阳赤纬角或黄赤大距。

月球直径大约是地球的 1/4，质量大约是地球的 1/81。地月平均距离是 38.4 千米，月球与地球近地点的距离是 36.3 万千米，与地球远地点的距离是 40.6 万千米。 月球将会越来越远离地球，因为地球自转越来越慢，每年远离3.8厘米左右。

- 新开一个 Blender 文件，首先设置渲染引擎为 Cycle，添加球体模拟太阳，地球和月球等；
- 现在可以删除场景中默认的点光源，接下来制作自己的太阳光源和太阳模型；
- 这里需要使用下载好 NASA 的太阳贴图 8k-sun.jpg 来做一个真实点的模型。
- 太阳、地球、月球大小比例设定 300:6:1.5，单位可以定为km，直接在场景这个数值，设定 AU 为 1500；
- 打开材质编辑器 Shader Editor，点击 + New 新建一个材质 sum，并给材质添加一个 Shader - Emission 发光体着色器，设定强度 1000；
- 

在调整场景的活动摄像机视图时注意，由于场景内的模型距离超大，可能很难定位到目标对象。摄像机有一个基本
的位置坐标，在 0 旋转的情况下是从 +Z 往下看的 Top 视图。可以选择场景活动摄像机，然后给它指定到模型
就近的坐标上再调整。

另一个方法是使用 3D Cursor 光标辅助定位，通过侧栏视图面板设定 View - Lock to 3D Cursor，
再设定 3D Cursor 的 Location，Rotation 可以定位后再调整。




# 🚩 Composite 合成器


和视频序列编辑器一样，Composite 合成器也是属于后期效果处理工具，但是合成器的效果可以输出到渲染器中渲染。用户通过编辑器节点对输入图像进行处理，对它们进行随意的更改及和其他图像进行合并处理，最终保存操作的结果到各种输出节点。

合成器中的节点允许用户对一张图片或视频进行自由的组合和增强处理，也可以对渲染结果进行合成处理，通过添加合成器节点对渲染结果进行合成处理。运用合成节点，用户可以将两段素材粘附在一起并同时对整个序列进行润色。在剪辑过程中，我们可以运用一种静态的方法或动态的方式来加强单帧图像或整个视频片段的色调。用这种方法，用户可以运用合成节点同时对视频素材进行随意组合和效果调整。

根据不同渲染器，在视图属性面板提供的设置，如 Passes 中有各种分层信息，Z 深度、Mist 迷雾 等，勾选它么就可以在 Render Layer 节点中使用。

在新版 Blender 还提供了 Denoise 节点来给 Cycles 降噪，Blender 2.81 新增的降噪节点，基于英特尔 Open Image Denoise 算法库，这样可以同等质量下降低渲染的精度实现提速。比如，以 Cycles 渲染 128 次采样每像素的需要 15 分钟的图像，换成 4 次采样每像素渲染需要的时间可以是 1 分钟，实乃低配机器的利器。如果在合成器菜单中找不到 Denoise 节点，可以通过搜索栏查找。在视图层属性面板勾选 Passes - Data - Denoising Data 以在合成器中使用。

通过单击合成选项卡，进入 合成 模块，通过单击贴临合成选项卡下方的合成模块菜单栏 使用节点 复选框，可激活节点在工作区域的显示。

演员在蓝色抠像布前表演的一段合成素材，和已渲染的一些其他道具物体，可以分别叠放在背景图层上方，并将两者和背景结合在一起，就获得了最终的合成后影像。通过在合成器中使用绿幕抠像节点 Matte - Keying 即可将指定颜色从图像上过滤掉。

合成器处理后的图像也和渲染结果一样显示在 Render Result 窗口，在 Slot 列表中可以选取 Composite 查看合成结果，View Layer 包含渲染结果。窗口右侧还包含各种分类通道信息，如 Alpha 通道、 Z-Buffer 深度通道。 

输入节点从一些源素材生成信息。比如，输入的素材可能是：

- 从选中场景的活动相机中获取,
- 从单张 JPG, PNG 等格式结尾的图像文件中作为一幅静态画面载入到输入节点,
- 一段视频剪辑片段(比如一系列图像序列帧或者是视频),
- 或者仅仅是颜色或单一数值。

输入节点把采集到的素材信息结果作为输入对象继续传递到下游的相关节点。就输入节点本身而言，它们上游不再有输入节点，节点只有输出节点连接到下游节点。

完成编辑，还可以保存合成结果为影片片段(所有的序列帧图片合为一个单一视频文件)，使用 AVI 或者 Quicktime 格式，然后保持默认设置单击 动画 按钮即可。

- Input Nodes 输入节点

	- Bokeh Image Node

		散景图节点 用于生成一个特定的散景形状用于合成，参考散景模糊滤镜节点。用来通过诸如光圈形状和镜头畸变等效果。

	- Image Node

		图像节点 可以给其添加任意图像 Blender支持的格式.

	- Mask Node

		遮罩节点 用来选择 blend 设置好的遮罩数据块，Movie Clip 的 Mask 模式可以编辑遮罩。

	- Movie Clip Node

		影片剪辑节点 这个节点可用于截取视频素材中的一部分并用于输出到其他节点。

	- Render Layers Node

		渲染层节点 用于放置需要通过场景获取特定渲染通道信息到合成节点网络，先点击右下角的按钮或 F2 获取场景的渲染结果。

	- RGB Node

		RGB节点 生成一个单独的RGBA颜色条状值。

	- Texture Node

		纹理节点 生成 3D 纹理。

	- Time Node

		时间节点 生成一个因子值(从 0.0 到 1.0)，该因子值会随着曲线变化，作为 时间轴 上的时间进程。

	- Track Position Node

		追踪位置节点 返回追踪点的坐标信息。

	- Value Node

		值节点 是一个在节点树当中将用户输入数据传递到另一个相关连的下游节点的简易节点。

- Output Nodes


	- Composite 合成节点

		合成节点由合成人员将其连接到渲染器的输出节点。在每次渲染后都会实时更新，体现出节点树发生的改变(至少需要一个编辑完后的总输入节点与其进行连接)。

	- File Output 文件输出节点

		此节点依据指定的帧范围，和输入的文件名及其相关的序列参数设置进行图像存储。

		此节点可用于渲染后自动保存图像；另外，此节点可放置在节点树流程中任意阶段进行和其他节点连接，所以也可以用来保存中间阶段生成图像的效果。

	- Levels 层级节点

		层级节点用于读取输入节点的颜色通道信息，并将分析结果进行输出。

	- Split Viewer 对照预览节点

		对照预览 节点将两幅图像并排以背景图的方式进行显示，或者作为预览器节点输出。

	- Viewer 预览器节点

		预览器节点是一个临时性的，合成进程中的查看器。它可以放置在节点流程树中的任意地方以检查图像或者是值映射情况。

		当场景中有多个预览器节点时，可以通过鼠标左键进行图像结果显示的切换。当在任意节点上使用 Shift-Ctrl-LMB 组合热键，将在此节点上自动连接一个查看器节点。

- Color Nodes 颜色类节点

	- Alpha Over Node

		将一幅图像覆盖在另一幅图像之上，当前景图像像素 alpha 值大于 0 即进行覆盖。

	- Bright/Contrast Node

		亮度/对比度节点

	- Color Balance Node

		色彩平衡节点

	- Color Correction Node

		色彩校正节点

	- Gamma Node

		伽玛节点

	- Hue Correct Node

		色相校正节点

	- Hue Saturation Value Node

		色相/饱和度/明度节点

	- Invert Node

		反相节点 将输入图像的颜色进行反相，产生图像负片效果。

	- Mix Node

		混合节点 通过将两幅单独的输入图像依据像素进行混合。

	- RGB Curves Node

		RGB曲线节点

	- Tone Map Node

		色调映射节点 计算颜色分布范围并将这些设置映射匹配到另一幅相似内容的图像上的技术。

	- Z Combine Node

		Z通道合成节点 将在上面的图像 Z 通道值覆盖叠加到另一幅图像的 Z 通道上。


- Converter Nodes 转换器类节点

	- Alpha Convert Node

		Alpha 转换节点 对一幅图像的 alpha 通道信息的映射方式进行转换。

	- Color Ramp Node

		颜色渐变节点 使用渐变的方式进行颜色值的匹配。

	- Combine/Separate Nodes

		合并/分离节点 对一幅图像的颜色通道分离/合并。

	- ID Mask Node

		ID 遮罩节点 用于获取每个对象或每个材质的 alpha 遮罩，输出白色的遮罩部分为保留部分，黑色的遮罩部分是移除部分。

	- Math Node

		运算节点

	- RGB to BW Node

		RGB -> BW 节点

	- Set Alpha Node

		设置 Alpha 节点 给图像加入一个alpha通道。

	- Switch View Node

		视图切换节点 合并拆分为左、右眼的视图到独立的3D立体化输出。


- Filter Nodes 滤镜节点

	- Bilateral Blur Node

		双边模糊节点 执行高品质适应性模糊，可以保持图像本身锐利边缘界限不变的前提下对图像进行模糊操作。

	- Blur Node

		模糊节点 对图像进行模糊操作。

	- Bokeh Blur Node

		散景模糊节点 类似散焦滤镜 Defocus。

	- Defocus Node

		散焦节点 基于一张 图片/遮罩 输入来模糊相应区域。

	- Denoise Node

		去噪节点 给 Cycle 渲染器输出图像去噪点。

	- Despeckle Node

		去斑节点 对其明显的杂痕进行平滑处理。

	- Dilate/Erode Node

		膨胀/侵蚀节点 提供一个形态学(数学形状分析)滤镜效果。

	- Directional Blur Node

		定向模糊节点 在指定的方向和量级上对图像进行模糊操作。

	- Filter Node

		滤镜节点 对图像执行各种常规滤镜效果。可选滤镜，柔化 Soften ，拉普拉斯过滤 Laplace ，索贝尔 Sobel ，维特 Prewitt 和克什 Kirsch 都根据矢量微积分和集合理论执行边缘检测，方式略有不同。

		- 柔化 在图像上执行轻微模糊效果。
		- 锐化 增加图像对比度，尤其在边的位置。
		- 拉普拉斯过滤 沿着边进行柔化。
		- 索贝尔 在高亮区域创建图像负片效果。
		- 维特 比使用索贝尔的效果更好。
		- 克什边缘检测 在接近边缘的位置，产生比索贝尔或维特更好的混合效果。
		- 阴影 使边的外缘变暗，产生类似斜面浮雕/凹凸的效果。

	- Glare Node

		辉光节点 在图像的曝光或更多部分添加镜头光斑，发光等效果。

	- Inpaint Node

		瑕疵修复节点 用来延展一幅图像的边界为透明或遮罩区域。

	- Pixelate Node

		像素化节点 在 缩放节点 添加此节点可获得像素化(非平滑)图像。

	- Sun Beams Node

		太阳光束节点 据图像上的亮度信息创建一个简易日光效果。

	- Vector (Motion) Blur Node

		矢量(运动)模糊节点  快速模拟 Motion blur 的方法。


- Vector Nodes 矢量类节点

	- Map Range Node

		映射范围节点

	- Map Value Node

		映射值节点

	- Normal Node

		法线节点

	- Normalize Node

		正则化节点

	- Vector Curves Node

		矢量曲线节点


- Matte Nodes 蒙版类节点

	- Box Mask Node

		方形遮罩节点 

	- Channel Key Node

		通道抠像节点 依据选择的通道值差异定义背景对象和前景对象。

	- Chroma Key Node

		色度抠像节点 

	- Color Key Node

		色彩抠像节点 

	- Color Spill Node

		色彩溢出节点 通过减少RGB色彩通道中的一种，使之不超过另外两种颜色产生色彩偏差溢出。

	- Cryptomatte

		为指定对象创建 Cryptomatte 标准蒙版 

	- Difference Key Node

		色差抠像节点 

	- Distance Key Node

		色距抠像节点 

	- Double Edge Mask Node

		双边遮罩节点 在两个遮罩之间生成一个过渡渐变效果。 

	- Ellipse Mask Node

		椭圆遮罩节点 

	- Keying Node

		抠像节点 绿屏/蓝屏去背景一站式解决方案。它结合了色度抠像移除背景和色彩溢出去校正前景物体表面从背景中吸收的颜色信息。

	- Keying Screen Node

		屏幕抠像节点 创建了关键帧集节点作为颜色参考使用的底片。在影片剪辑中的运动追踪点进行颜色采样生成渐变色。它可用来处理在绿屏背景上不平整的颜色。

	- Luminance Key Node

		亮度抠像节点 


- Distort Nodes 畸变类节点

	- Corner Pin Node

		边角定位节点 边角定位节点为图像平面弯曲变换指定明确的边角值。

	- Crop Node

		裁切节点 将连接到此节点的图像按照选择的区域进行裁切。

	- Displace Node

		置换节点 基于输入矢量对像素位置进行置换。

	- Flip Node

		翻转节点 在定义的轴向上进行图像翻转。

	- Lens Distortion Node

		镜头畸变节点 采集真实摄影机产生的镜头失真。

	- Map UV Node

		映射 UV 节点 可以将对象进行重新贴图，需要 UV 渲染通道的输入。

	- Movie Distortion Node

		影片畸变节点 从影片中删除失真或添加失真以使渲染与影片剪辑混合。

	- Plane Track Deform Node

		平面追踪形变节点 提供平面追踪信息的节点，供类似 Alpha Over 等图像覆盖节点使用。

	- Rotate Node

		旋转节点 

	- Scale Node

		比例节点

	- Stabilize 2D Node

		二维稳像节点 依据设置项将素材进行稳定性操作，影片剪辑编辑器 ‣ 属性 ‣ 稳像 ‣ 2D 稳像。

	- Transform Node

		变换节点

	- Translate Node

		移动节点


- Node Groups 节点组 群组节点能够通过镜像和隐藏部分节点来简化节点树。

- Layout Nodes 布局类节点

	- Switch 切换节点 使用复选框在两幅图像间进行切换。



# 🚩 Cycles 光线追踪渲染引擎
[Cycles Home](https://www.cycles-renderer.org/)

Cycles 是 Blender 用于产品级渲染，基于物理的路径跟踪器。它旨在提供易于使用以及准确的物理渲染结果，
具有艺术控制和灵活的着色节点以满足生产需求。

要使用 Cycles，需在渲染属性中选择其作为渲染引擎，在偏好设置 System 中选择 Cycles 渲染设备，
如果有可使用 GPU 加速渲染。


## 👉 Motion Blur 运动模糊

Blender 动画默认渲染为完全静止的图像序列，在 24FPS 帧速下，真实的视觉感受很大差别，只有一点不
流畅就会有卡顿的感觉，因为画面清晰可见细微的不流畅。尽管这对定格和延时动画很棒，但高速移动的物体在
运动方向看起来是模糊的，不管实在电影单帧或现实世界的摄影中。

如果场景中有粒子或其他物理系统，渲染前一定要进行烘焙，否则可能无法得到正确或一致的运动模糊。

每个对象都有其控制运动模糊的设置，这些选项可以在属性编辑器的对象选项卡中找到。

- Position 控制快门打开时机

	- Start on Frame 快门在当前帧中开始打开。 
	- Center on Frame 快门在当前帧中完全打开。 
	- End of Frame 快门在当前帧中完全关闭。

- Shutter 快门开合之间的时间，以帧为单位，1.0 即模糊一个帧的长度。
- Rolling Shutter 创建一个卷帘快门效果。

	- None 无卷帘快门效果。 
	- Top-Bottom 从图像的顶部到底部的卷帘快门。

- Rolling Shutter Duration

	快门持续时间，值为 0 时纯滚动快门效果，值为 1 时纯运动控制平衡模糊效果。


- Shutter Curve

	定义如何快门打开和关闭的曲线。 X 轴为时间，Y 为 0 时意味着完全关闭快门，1 表示完全打开快门。
	默认映射设置为快门立即打开和关闭。



## 👉 Cycles World 世界设置

### ⚡ Ambient Occlusion 环境光遮蔽

## 👉 Bake 烘焙

Cycles着色器和灯光照明可以烘焙到图像纹理。这有几个不同的用途，最常见的是：

- 烘焙纹理，如基础颜色或法线贴图，用于导出到游戏引擎。
- 烘焙环境光遮蔽或程序纹理，作为纹理绘制或进一步编辑的基础。
- 创建光照贴图以提供全局照明或加快游戏中的渲染速度。

烘焙需要设置 UV 坐标映射，烘焙输出可以选择着色器中指定的 Image Texture Node 或 Vertex Color layer。




# 🚩 Eevee 实时渲染器
- [Light Probes](https://www.bilibili.com/video/BV1pb411K7e3)
- [Irradiance Volume](https://www.bilibili.com/video/av43505944/)
- [Eevee 渲染器创建真实灯光](https://www.bilibili.com/video/BV1J4411L7SD)
- [Blender 官方参考DEMO](https://www.blender.org/download/demo-files/)
- [Eevee 烟火](https://www.bilibili.com/video/BV1Sb411r7ZW)
- [宇宙飞船 Alessandro Chiffi 18 MB CC-BY](https://download.blender.org/demo/eevee/race_spaceship/race_spaceship.blend)
- [爬树生物 Daniel Bystedt 398 MB CC-BY-NC-SA](https://download.blender.org/demo/eevee/tree_creature/tree_creature.blend)
- [寺庙 Dominik Graf 350 MB CC-BY-SA](https://download.blender.org/demo/eevee/temple/temple.blend)
- [流浪者 Daniel Bystedt 300 MB CC-BY-SA](https://download.blender.org/demo/eevee/wanderer/wanderer.blend)
- [余烬森林 Mike Pan 71 MB CC-BY](https://download.blender.org/demo/eevee/ember_forest/forest.blend)
- [黄蜂人 Emiliano Colantoni 58 MB CC-BY](https://download.blender.org/demo/eevee/wasp_bot/wasp_bot.blend)
- [大先生 Glenn Melenhorst 66 MB CC-BY-ND](https://download.blender.org/demo/eevee/mr_elephant/mr_elephant.blend)
- [室内效果展示 Marek Moravec 195 MB CC-0 Public Domain](https://download.blender.org/demo/eevee/archiviz/archiviz.blend)
- [Monster - UDIM By Daniel Bystedt](https://download.blender.org/demo/UDIM_monster.zip)
- [Cosmos Laundromat Demo(CC-BY, 230 MB)](https://download.blender.org/demo/test/benchmark.zip)
- [BMW demo by Mike Pan. (CC0, 3 MB)](https://download.blender.org/demo/test/BMW27_2.blend.zip)
- [Class room By Christophe Seux. (CC0, 72 MB)](https://download.blender.org/demo/test/classroom.zip)
- [Barcelona Pavillion (CC-BY, 24 MB)](https://download.blender.org/demo/test/pabellon_barcelona_v1.scene_.zip)
- [Bike Ride By Andry Rasoahaingo. CC-BY-SA 3.0](https://download.blender.org/demo/greasepencil-bike.blend)
- [Grease Pencil animation by Daniel “Pepeland” Lara (CC-BY-NC, 23 MB)](https://download.blender.org/demo/test/ForYou.blend)
- [Internal Air Pressure By Alexander Mitzkus](https://download.blender.org/demo/cloth_internal_air_pressure.blend)
- [Inner Springs By Alexander Mitzkus](https://download.blender.org/demo/cloth_inner_springs.blend)
- [实时光线追踪技术：业界发展近况与未来挑战](https://zhuanlan.zhihu.com/p/102397700)
- [细说光栅化与光线追踪的区别](https://www.bilibili.com/video/BV1Xr4y1T7aA/)
- [光线追踪到底是怎么追的？](https://www.bilibili.com/video/BV1n5411M7pa/)

Cycles 和 Eevee 是 Blender 内置的两个渲染引擎，它们使用不同算法，应用于不同场合。前者为光线跟踪
渲染方式，实现照片级渲染。后者为光栅化渲染引擎，为的是实现实时渲染，通常这种渲染引擎用于游戏等有实时
需要的场合中。

从图形学发展来看，Rasterization 光栅化是传统图形渲染技术，原理是基于三角形绘图，将数学模型像素化。
因为光栅化直接处理光照，常常用于实时渲染场景中，Real-Time Rendering，但是这种直接解决光照带来
了快速渲染的同时，也导致渲染质量较低。

光栅化着色过程：枚举每个像素的位置，从眼睛向它连线，通过 z-buffer 检测找到碰到的第一个物体，然后
根据光源计算颜色，使用某种着色模型，比如 Blinn-Phong 反射模型。也就是说，从眼睛-物体-光源，光线
只反射了一次，所以是只考虑了直接光照。

早期，为了加速像素的填充，使用了顶点着色，即三角形上每个顶点携带颜色信息，利用硬件在任意两点之间
的插值，快速地将三角面填充满。

光线追踪也经历了相当长的发展，从早期的 Whitted-Style Ray Tracing，到现代的 Path Tracing，
渲染质量已经实现照片级效果。光线追踪建立于光线传播的物理模型，考虑了间接光照的影响，能带来真实的
光照效果。随之而来的较长的渲染时间，在实时光追普及之前，只能用于电影等质量要求较高的场合。

Whitted 方法只对反射、折射的材质进行递归处理，当碰到其他材质便停下，例如遇到 diffuse。

算法上，光栅化枚举每一个物体，对物体上对应的像素进行处理。而光线追踪枚举每一个像素，从像素位置跟踪光线。

2018 年微软发布 DirectX Ray Tracing (DXR)；NVIDIA、ILMxLAB、UE4 联合发布了基于实时光线追踪
的具有电影级视觉效果的《星球大战》短片。同年，NVIDIA 宣布了可加速硬件中光线追踪速度的新架构 Turing，
以及搭载实时光线追踪技术的 RTX 系列显卡。第一款搭载 RTX 实时混合光线追踪技术的游戏 Battlefield V
正式面世，基于 EA Frostbite 引擎，带来了出色的 Hybrid Ray-Traced Reflections 混合光线追踪
反射渲染表现。



Eevee 是随 Blender 2.8 发布的实时渲染引擎，应用 OpenGL 技术来实现 PBR 效果的快速预览和实时
交互编辑，也可以生成高质量的渲染效果。官方 Tree Creature 和 Temple 实例展示了 Eevee 真实效果。

Eevee 实时渲染不仅提升渲染的效率，同时又可以兼容 Cycles 材质。可以将 Eevee 作为 Cycle 材质的
实时效果预览用帮助加速项目进程，当然也可以作为渲染器使用，但 Eevee 原意不是产品级渲染，也不能完全
和 Cycle 等效。Eevee 基于 Open GL 实现的一款实实在在的实时渲染引擎，支持分层渲染、后期合成。这
几年基于游戏引擎的实时渲染可谓是空前的火热，可以说实时渲染将会是 CG 行业的一场变革。

Eevee 可以实时渲染体积、反射、折射、SSS次表面散射、景深，还支持辉光等渲染后处理效果，通过 Cycle 和
Eevee 渲染器通用的 BSDF 着色器提供了强大的参数配置。

和 Cycles 不同的，Eevee 并不是光线跟踪引擎，它使用的是通过光栅化的多种算法来估算光线与物体材质
作用的方式，并不像 Cycles 基于物理光线跟踪来计算每个光线的反弹。


Eevee 场景中仅支持最多 128 个激活灯光，只能同时支持 8 个投影阳光。 目前, 灯光只能有一种颜色，
不支持灯光节点组。

尽管 Eevee 在设计上使用 PBR 的着色材质，但它并不完整，因为实际使用有不少限制，具体参阅文档。

Eevee 渲染器渲染设置选项上与 Cycles 有所不同，Eevee 可作为 Cycles 的视图实时预览，也可以作为
独立的渲染器使用。正因为这个特点，Eevee 更加专注于实时渲染，很多设置选项采用了主流的游戏引擎的技术，
其中绝大数设置选项是独立于 Cycles 存在的。以下基本是渲染设置项，这些渲染是保证渲染质量与渲染效率的
关键设置项。

- Sampling  采样
- Bloom  辉光
- Volumetric  体积
- Depth Of Field  景深
- Motion Blur  运动模糊
- Indirect Lighting  间接照明
- Amibient Occlusion  环境光遮蔽
- Hair  毛发+毛发材质
- SubSurface Scattering  次表面散射
- Screen Space Reflections  屏幕空间发射


## 👉 Eevee Shader 材质
[Eevee Glass](https://www.bilibili.com/video/BV1nJ41117iW)

在一般情况下，着色节点的处理与 Cycles 一样，尽管如此，但由于其渲染器内核的本质不同，某一些类型的
材质编辑与设置有一定的区别。

使用节点首选 Principled BSDF 而不是多个 BSDF 节点，因为 Eevee 已针对它进行了优化。Eevee 有
两个专用节点：

- Shader - Specular BSDF
- Converter - Shader To RGB

节点使用注意事项：

- Displace  置换
- Glass  玻璃材质
- Anisotropic  各向异性金属
- Neon Lights  节能灯-霓虹灯
- SSS  皮肤材质+布光
- Snow  雪材质
- Car Paint  汽车烤漆
- Fog  大雾+布光+镜头+调色
- Multi-Mat  多维子材质

现实中处处存在脏旧的材质，要从现实出发寻找规律材质模拟破损、水渍、污渍、腐蚀、划痕，并在材质编辑器中
使用节点进行模拟。这部分的材质难度稍微有点复杂，需要掌握其中的规律、原理、及材质节点混合技巧。

Eevee 默认关闭了屏幕空间反射 SSR，对于玻璃材质会丢失透明特性，打开其中的折射 Refraction。设置
材质，使用 Glass BSDF 材质也需要在侧栏的选项中，快捷键 N 打开侧栏面板，勾选屏幕空间反射光线
Options - Screen Space Reflection，这样才具有玻璃的透视特性。注意以下几点：

- 玻璃材质要打开 Refraction 折射功能，同时要在 Eevee 引擎属性面板打开 SSR 面板中折射功能。
- Refraction Depth 设置不能太远，否则无视玻璃体后近处物体。
- 玻璃体会无视其后面的其它玻璃体。

处理透明材质的另一方法是，通过 Light Probe 光照探头来实现。

对于体积化的烟雾效果，Volumetric 提供了设置。

其它材质设置选项：

- Backface Culling 勾选背面剔除会在最终渲染中隐藏面的背面。
- Blender Mode 设置混合模式

	计算表面的颜色后，混合模式定义如何将其添加到颜色缓冲区。 根据这一点，最终颜色会有所不同。	
	Alpha 混合被认为是透明混合模式，这会影响屏幕空间效果。

	- Opaque 不透明，之前的颜色将被表面颜色覆盖，Alpha 通道被忽略，这是最快的选择。
	- Alpha 裁切，当 Alpha 值高于裁切阈值时，前面的颜色将被表面颜色覆盖。
	- Alpha Hashed 当 Alpha 值高于随机裁切阈值时，前面的颜色将被表面颜色覆盖。这种选项是有图像噪点的，但能够近似 Alpha 混合没有任何排序问题。在渲染设置中增加采样数值能减少其产生的噪点。
	- Alpha 使用 Alpha 混合将表面颜色覆盖在前一种颜色之上。

- Shadow Mode 设置阴影模式

	- None 表面不会投射任何阴影。
	- Opaque 表面将投射阴影。
	- Clip 裁切，Alpha 值高于钳制阈值的区域，表面会像不透明的表面一样投射阴影。
	- Hashed 当 Alpha 值高于随机阈值的区域，表面会像一个不透明的表面一样投射阴影。

- Screen Space Reflections 屏幕空间折射

	启用屏幕空间折射在表面上的折射意味着折射BSDF将对深度缓冲区进行光线跟踪，以找到最准确的折射颜色。
	如果表面覆盖了大量的像素，这会很耗性能。

	因为兼容问题，启用屏幕空间折射的表面将禁用屏幕空间反射和环境光屏蔽(AO)。使用屏幕空间折射的物体
	表面将不会出现在屏幕空间反射的位置。环境光屏蔽不会计算此物体表面与其他物体的屏蔽。

	如果禁用此选项或屏幕空间折射光线追踪失败，折射光线将使用最近探针的颜色。

- Refraction Depth 折射深度

	如果折射深度不是 0.0 则着色器中的所有折射 BSDF 将表现为该对象是具有该厚度的折射材料的薄板。 
	这将模拟第二次折射事件，该事件将使吸收颜色加倍并在第二次事件之后开始折射光线。

	此选项可以极大地提高了薄玻璃对象的质量。

- Subsurface Translucency 次表面半透明

	Eevee 的次表面散射算法通过模糊屏幕空间的辐照度来工作。这意味着如果表面没有可见的部分被照亮，
	效果就会消失。

	然而，真正的次表面散射在表面下方并且可以行进很多距离。 这就是为什么从后面照亮的人耳在正面看
	起来是红色的。

	这就是这种效应模仿的结果。 这种半透明近似仅适用于具有阴影贴图的光，仅适用于次表面 BSDF
	(不是半透明BSDF)。 它不适用于间接照明。 阴影贴图的软参数也会影响此效果。

- Pass Index 材质编号，为材质指定编号，后期可以使用合成器中的 ID 遮罩节点读取该遮罩。



以下是各材质节点的支持情况，没有说明表示支持。

Shader Nodes

- Diffuse BSDF

	不支持粗糙度 Roughness，仅支持 Lambertian 散射。

- Emission

	它将被作为间接照明处理，在 SSR - Screen Space Reflection 和探头中可见。

- Glass / Refraction BSDF

	不折射灯光，不支持贝克曼散射 Beckmann 和多重散射 GGX multiscatter。

- Glossy BSDF

	不支持 Beckmann、 Ashikhmin-Shirley 和 GGX multiscatter 散射。

- Subsurface Scattering

	不支持随机游取采样 Random Walk，每个颜色通道半径由默认接口值指定，连入此接口的任何连线都将被忽略。
	纹理模糊对于 0.0 和 1.0 以外的任何值都不准确。

- Transparent BSDF

	透明仅在材质的混合模式不是不透明 Opaque 下才起作用。上色与累加透明仅兼容 "Alpha混合" 模式。

- Translucent BSDF

	不扩散物体内部的光。它只用反向法线照亮物体。

- Principled BSDF

	相当于漫射 BSDF，光泽 BSDF，折射 BSDF和次表面散射的所有限制，并不支持各向异性 Anisotropy，
	不支持透射的粗糙度 Roughness，发光只是粗略近似。

- Volume Absorption

	- 仅支持一次散射。
	- 只在相机光线中渲染体积。 它们在屏幕空间反射/屏幕空间折射和光照探针不可见。
	- 体积不接收体积辐射的光照但接收世界环境漫射照明。
	- 体积阴影仅在其它体积物体上有效，它们不能在场景实物上投射阴影。
	- 仅在视锥体(视野)中的体积会有阴影。
	- 体积光照明不支持设置灯光形状。它们都被视为点光。

- Volume Scatter

	各向异性参数 Anisotropy 将对所有重叠的体积对象进行混合和平均，Cycles 不同，这不符合物理规律。
	体积限制与 Volume Absorption 相同。	

- Principled Volume	同 Volume Scatter。
- Holdout

	部分支持，使用 Alpha 之外的混合模式可能会给出不正确的结果。

- Anisotropic BSDF *不支持*
- Toon BSDF *不支持*
- Hair BSDF *不支持*
- Velvet BSDF *不支持*
- Principled Hair BSDF *不支持*


Input Nodes

- Ambient Occlusion
	
	除法线和颜色外，调节其余参数都没有任何效果。 这是因为 Eevee 在评估此节点之前计算 AO 并且它
	使用场景设置。

- Camera Data 完全支持
- Geometry *不支持* Pointiness
- Random Per Island *不支持*
- Attribute 
	
	默认为激活 UV 图层，支持UV和顶点颜色图层。 仅支持 density 密度 / color 颜色 / flame 火焰 / temperature 温度 等内置属性。

- Bevel *不支持*
- Fresnel 完全支持
- Hair Info
	
	随机输出使用不同的 RNG 算法。 值的范围和统计分布应该相同，但是值是不同的。

- Layer Weight 完全支持
- Light Path
	
	光程节点可以调整着色器中的间接光照明。Eevee 没有射线的真正概念，但是为了简化 Cycles 和 
	Eevee 之间的工作流，有些输出在特定情况下是支持的。

	只支持输出的子集，射线深度的含义并不完全相同:

	- Is Camera Ray 支持
	- Is Shadow Ray 支持
	- Is Diffuse Ray 支持
	- Is Glossy Ray 支持
	- Is Singular Ray **不支持** 等同 Is Glossy
	- Is Reflection Ray **不支持** 等同 Is Glossy
	- Is Transmission Ray **不支持** 等同 Is Glossy
	- Ray Length **不支持** 默认值 1.0
	- Ray Depth 表示烘焙光缓存时的反弹
	- Diffuse Depth 等同 Ray Depth 但仅在烘焙漫反射光照时。
	- Glossy Depth 等同 Ray Depth 但仅在烘焙镜面光照时。
	- Transparent Depth **不支持** 默认值 0
	- Transmission Depth **不支持** 等同 Glossy Depth

	光泽度不适合用于屏幕空间反射/折射，但适用于反射平面(无论是否与SSR一起使用)。

- Object Info 完全支持
- Particle Info *不支持*
- Tangent 完全支持
- Texture Coordinate **不支持** From Instancer 选项
- UV Map **不支持** From Instancer 选项
- Wireframe
	
	像素大小选项输出结果可能会和 Cycles 不同，宽度可能不一样。


Other Nodes

- Light Falloff *不支持*
- Bump
	
	Imprecision due to less precise derivatives.</p></dd>

- Displacement/Vector Displacement *不支持*
- IES Texture *不支持* 照明工程协会纹理 IES - Illuminating Engineering Society
- Sky Texture *不支持*
- Image Texture
	
	选择智能插值 Smart 方式会始终使用 Cube 三次插值。因为硬件 mip-mapping 和各向异性的过滤，
	使用线性插值的管形 Tube 或球形 Sphere 投影会呈现伪像。如果提供的纹理坐标不连续，更容易见到伪像。
	Box 投影不支持设置为扩展 Extend 或剪辑 Clip，始终使用 Repeat。

	Mip 映射的核心特征是根据物体的景深方向位置变化应用不同大小的材质贴图，这样不仅可以产生更好的
	视觉效果，同时也节约了系统资源。

- Material Output
	
	与 Cycles 相比，置换 Displacement 输出效果是残缺不全的。

- Wavelength *不支持*
- Point Density *不支持*





## 👉 Sampling 采样

Eevee 使用称为时间性抗锯齿 TAA 的过程来减少锯齿。 由于 TAA 是基于样本，因此样本越多，以性能为
代价就会减少锯齿。

属性参考：

- Render 设置在最终渲染中使用的样本数。
- Viewport 设置在 3D 视图中使用的样本数。当设置样本数为零时，3D 视图中将会不断采样。
- Viewport Denoising 勾选设置移动视图或者播放动画期间降低噪点。


## 👉 Bloom 辉光

泛光 Bloom 是一种后处理效果，可以扩散非常明亮的像素。 模仿真实相机的镜头伪像,这样可以更好地了解
像素的实际强度。

属性面板参考：

- Threshold 设置阈值，过滤掉此亮度级别下的像素。
- Knee 拐点，在低于/超过阈值之间渐变。
- Radius 泛光扩散半径距离。
- Color 应用于泛光效果的颜色。
- Intensity 强度，混合因子。
- Clamp 钳制泛光像素的最大亮度。


## 👉 Volumetric 体积

设置一下引擎的体积化参数，在 Volumetrics 面板种适当减小 Tile size 和增加 Samples 以提高图像
细腻度。勾选体积阴影 Volumetric Showdows，通过吸收体积物周围的近似光来模拟阴影，这是一个非常
消耗资源的选项。
Eevee通过评估可见视角内的所有体积物体来模拟体积散射。

为此，它使用了显存占用率高的3D纹理。可以使用 平铺尺寸 和 采样 参数调整纹理尺寸。

物体体积有一些 限制。

体积属性面板参考：

- Start/End 设置体积效果的起始和结束距离。
- Tile Size 设置体积平铺单元尺寸，较小的尺寸会提高质量，但会增加大量显存占用。
- Samples 设置计算体积效果的采样数，采样数大会提高质量但增加显存占用。这些采样样本沿视图深度，即视图 Z 轴分布。
- Distribution 设置线性和指数样本分布之间的混合比例，值越高，靠近相机的样本越多。
- Volumetric Lighting 勾选让体积散射在场景中散射光，如果场景中没有体积散射，则不需要开启。
- Light Clamping 设置钳制光对体积散射效应的效果，减少闪烁和噪点，0.0 为禁用钳制。
- Volumetric Shadows 体积阴影

	勾选让体积物体周围的近似光吸收，这会使体积物体更不容易透光。这是一个非常消耗资源的选项，并有局限性：

	- 仅支持一次散射。
	- 只在相机光线中渲染体积。 它们在屏幕空间反射/屏幕空间折射和光照探针不可见。
	- 体积不接收体积辐射的光照但接收世界环境漫射照明。
	- 体积阴影仅在其它体积物体上有效，它们不能在场景实物上投射阴影。
	- 仅在视锥体(视野)中的体积会有阴影。
	- 体积光照明不支持设置灯光形状。它们都被视为点光。

- Samples 设置计算体积阴影的采样数。



## 👉 Depth Of Field 景深

景深效果在 Eevee 里是作为后期处理效果完成的，可以在摄像机设置中控制景深效果。

景深只在 3D 视图中的相机视图里工作。

出于性能考虑，当使用大散景虚化大小时，视口可能会出现颜色伪影。最终渲染中不存在这些瑕疵。

属性面板 Max Size 设置景深的背景虚化形状的最大尺寸，越低越快。


## 👉 Motion Blur 运动模糊

Eevee 中的运动模糊是通过渲染后对图像进行后期处理来实现的，只是简单基于像素的矢量速度来执行模糊计算。

暂时不支持物体运动模糊和变形运动模糊。仅支持相机运动模糊，运动模糊效果只在相机视图里可见。

运动模糊属性参考：

- Samples 指定用于运动模糊效果的采样数。
- Shutter 设置一帧以内快门打开到关闭的时间占比。



## 👉 Amibient Occlusion 环境光遮蔽

环境光遮蔽是一种基于 GTAO - Ground Truth Ambient Occlusion 的程序计算，并应用于间接光照。扭曲法线选项会使得漫射光照仅来自最少的遮挡方向。

环境光遮蔽可以在渲染层中作为独立的通道被渲染，使用环境光遮蔽材质节点时必须开启此效果。

属性面板参考：

- Distance 设置产生环境光遮蔽效果的距离。
- Factor 影响环境光遮蔽效果的混合系数。
- Trace Precision 追踪精度增加会产生更多的噪点并会最大化追踪距离。增加精度也会更加消耗硬件性能。而降低精度也会导致失去遮蔽从而失去效果。
- Bent Normals 弯曲法线以计算最少的遮蔽方向，这个方向能够用于更真实的漫射辐照采样。
- Bounces Approximation 近似反弹，一个用于给较亮的物体更少遮蔽的模拟光照反弹的衰减参数。它只考虑表面颜色而非环境，此效果无法应用于AO渲染通道。



## 👉 Hair 毛发+毛发材质



## 👉 SubSurface Scattering 次表面散射

次表面散射 SSS - Subsurface Scattering 是通过在屏幕空间内用模糊漫射光照的方式来模拟真实的次表面散射，类似模拟人耳背面透光。

此选项仅在附有阴影的光照环境中生效，且无法作用于间接光照。

次表面散射属性面板参考：

- Samples 用于计算散射效果的采样数量。
- Jitter Threshold 抖动阈值

若要保证该效果的运行效率，采样需要保持一致且非随机。当散射半径较高时将导产生十字形图案。为了隐藏可见图层，提高抖动阈值将用随机图层方式翻转采样至此半径百分比之下。当散射半径较大时会影响性能。


## 👉 Indirect Lighting 间接照明

在 Eevee 中所有不是从灯光物体直接出来的光照被视为间接照明，包括 HDRI 照明或世界照明。 同样，使用 Emission 节点的网格对象也被视为间接光照明。

间接光照明分为两个部分：

- Diffuse 漫反射
- Specular 高光反射/镜面反射

为了提高效率，间接照明数据根据需要预先计算到静态照明缓存中，两者都有不同的需求和代表性。

目前的光缓存是静态的，需要在渲染之前计算，不能被每帧更新，除非通过脚本。这个限制正在解决中，并会在将来的新版 Blender 中移除。因此，目前使用 Light Probe 时需要进行间接光烘焙才能看到效果。

只有视图中独立只能独立照明可以烘焙，这就是为什么 Reflection Planes 反光板不存储在光缓存中的原因。

烘焙过程中使用的是当前活动视图层中的可见物体和集合。

需要多次烘焙来完成光线在场景中的反弹计算，并将上次烘焙结果合成。整体烘焙时间受反弹次数影响而倍增。

光线反弹只限于漫反射照明。


间接光照明限制：

- 体积不接收体积辐射光但接收世界环境漫射照明。
- Eevee既不支持“镜面到漫反射”的光反弹，也不支持“镜面到镜面”的光反弹。
- 在烘焙过程中，所有镜面照明都会关闭。


间接光照明属性设置：

- Bake Indirect Lighting 将间接光照烘焙成纹理贴图。
- Bake Cubemap Only 只烘焙 Cubemap。
- Auto Bake 勾选自动烘焙将在更改探针时触发烘焙，调节探针物体时很有用。
- Diffuse Bounces 漫射反弹设置烘焙漫射辐照度时光线的反弹次数。
- Cubemap Size 反光盒贴图的尺寸。
- Diffuse Occlusion 漫反射遮蔽尺寸指定阴影贴图大小，每个辐照度样本还存储一个阴影贴图以尽可能地减少间接光泄漏。
- Irradiance Smooth 平滑辐照度插值，但引入光出血。
- Clamp Glossy 钳制光泽强度，以减少反射立方体内光泽反射的噪点。
- Filter Quality 过滤品质，在立方体贴图过滤期间增大采样以删除瑕疵，目前只对立方体贴图有效。 

- Display 显示
	- Cubemap Size 指定在 3D 视图中直接显示缓存中存在的反射立方体贴图大小。
	- Irradiance Size 在 3D 视图中显示在缓存中存在的辐照度样本大小。


## 👉 Screen Space Reflections 屏幕空间发射

Eevee 引擎为了实时渲染精简了光线追踪流程，默认处理有限的反射光，如来自世界环境的间接光。

开启屏幕空间反射 SSR - Screen Space Reflection，所有材质将利用深度缓存器和前一帧的颜色来创建，这比反射探针更精准的反射。

如果反光板和反光物体足够近，将有利于追踪反射源，和处理某些反射视觉错误的问题。

当然，反射的颜色不包含以下效果：次表面散射、体积、屏幕空间反射、屏幕空间折射。

屏幕空间反射属性面板参考：

- Refraction 勾选激活屏幕空间折射光照处理

	折射和反射有相同的工作机制并使用相同的参数。开启它会有额外性能消耗，因此所有物体材质默认不启用这功能。你需要在编辑材质时，在材质设置中开启屏幕空间折射，快捷键 N 打开侧栏面板，勾选 Options - Screen Space Reflection。使用屏幕空间折射的材质将无法使用屏幕空间反射。

- Half Res Trace 勾选激活半精度光线追踪

	使用半精度光线追踪。 仅为每四个像素投射一条光线。 启用此选项可大幅降低视频内存使用量并提高性能，但会降低质量。

- Trace Precision 设置追踪精度

	提升光线追踪精度会增加噪点并减小最大追踪距离，还会额外增加性能消耗。

- Thickness 厚度

	在追踪过程中纳入深度缓存器内计算的像素厚度。较高的数值会将反射像素拉伸并增加闪烁。较低的数值可能会导致物体表面反射被裁剪或消失。

- Edge Fading 边衰减

	反射像素在靠近屏幕边缘时会平滑淡出。淡出的程度由像素位置所处的屏幕中心到边缘的百分比决定。

- Clamp 钳制

	通过钳制反射颜色强度来移除噪点和闪烁。



## 👉 Light Probe 反射光线探头

Eevee 引擎为了实时渲染精简了光线追踪流程，默认处理有限的反射光，如来自世界环境的间接光。通过使用
光照探头 Light Probe 提升效率，用它们记录本地照明信息，在场景中设置它们来处理间接光照亮的场景。
可以结合间接光属性面板使用，配置如何烘焙处理间接光贴图。

在 Eevee 中所有不是从灯光物体直接出来的光照被视为间接照明，包括 HDRI 照明或世界照明。同样，使用 
Emission 节点的网格对象也被视为间接光照明。

在场景中设置一个模型，即使给它完全镜面反射的材质，它也不会反射附近的物体，即间接光照根本没有进行处理。
需要添加一个光照探头在模型相同的位置即可以纠正，光照探头就是通过记录的照明信息来引导间接光照明 
Indirect Lighting 的处理程序。

Eevee 的光线处理默认镜面反射会处理来自 World 的间接光，可以给 World 设置一个棋盘格子纹理 
Checker Texture 以测试。

默认环境 Eevee 不处理透射光线，这使得玻璃的透明质感丢失，要激活屏幕空间反射 Screen Space Reflections，
打开其中的折射 Refraction 功能支持。并且设置材质使用透明材质，如 Glass BSDF 材质，还要在侧栏的
选项中，快捷键 N 打开侧栏面板，勾选 Options - Screen Space Reflection，这样才具有玻璃的透视特性。

共有三种不同类型的探头，只在 Eevee 里有效，严格来说，还有 lookdev 模式，即视觉开发阶段模式。
这些是为了引导渲染引擎更快地算出效果更好的光照。

- Irradiance Volumes 辐射体积，用于间接光照明；
- Reflection Cubemaps 反光盒，用于间接光镜面反射；
- Reflection Planes 反光板，用于间接光镜面反射；

Eevee 的光照能做到什么效果，参考官方的爬树生物 DEMO，只是还缺粒子流体的实例。

Eevee 的目标是成为交互式渲染引擎，在不影响性能的前提下，一些功能还没有加入或不可能整合进 Eevee 
的架构中，具体限制词参考文档 Render - Eevee - Limitation。


光照探针使用限制：

- Eevee 仅支持至多 128 个活动立方体反射贴图。
- Eevee 仅支持至多 64 个活动的体积辐射。
- 在相机视野内，Eevee 仅支持最多 16 个活动的反射平面。


### ⚡ Irradiance Volumes 辐射体积

辐射体积这种探头将间接光漫射储存在辐射体积的阵列中，通过控制辐射体积的阵列和分辨率来控制。选中辐射体积物体后出现的那些小圆点阵列，就是他们计算漫射光照的位置。每个点就可以看作是一个探头，设置的分辨率越高，就越消耗运算资源，效果也越逼真。

如果场景中启用了环境光遮蔽 AO 将会影响到间接光漫射照明。如果启用环境光遮蔽时勾选 弯曲法线，它从被遮蔽最少的方向采样，结果会更准确。

来自辐射体积的光照数值会向外衰减，直至体积边界，它们会融入场景照明或者另一个辐射体积光照。如果多个辐射体积探头重叠一起，则优先显示体积较小的照明。如果物体不在任何辐射体积内部，或者间接光没有烘焙，将使用场景漫射光对其进行着色。

- 在照亮室内环境时，尽量使栅格与房间尺寸一致。 
- 尽量不要在空白区域或者光照差异较小的区域添加过多的分辨率。
- 可以在光照有问题的区域增加一个小的辐射体积探头来解决错误采样。


辐射体积属性面板参考：

- Distance 距离

	探头物体仅影响其邻近表面的光照，其作用区域由距离参数与物体定义。各种探头类型间有细微差别。

	对于辐射体积而言，体积内部的影响总是100%。其影响只有在体积外部才会发生衰减，直到距离达到设定的距离参数值(自身空间)。

- Falloff 衰减

	影响距离的百分比，探头的影响将沿其线性衰减。

- Intensity 强度

	被记录光照的强度系数。将该参数值设为1.0之外的值将不真实。用于调整艺术效果。

- Resolution 分辨率

	每个辐射体积探头的空间分辨率是独立的。其自身体积被分成指定尺寸的栅格。每个栅格的小格子都将被计算一次辐射采样。

- Clipping 范围限制

	定义当采集场景时的近距与远距裁减。裁切距离被应用于每个采样点的位置，而不是探头的原点。

- Visibility Collection 可见性集合

	当物体距离探头过近时，会影响探头探测场景来烘焙光照贴图。可见性集合可以使仅该集合(群组)物体可被探头采集到光照信息。

	右侧的按钮高亮激活时，可以反转该集合, 并隐藏此集合中的物体，集合物体不会被探头采集光照信息烘焙到反射贴图中。这只是一个过滤选项。如果一个物体在渲染时不可见，那么它在探头烘焙中也是不可见的。

- Visibility 可见性

	对于每个网格点，都会渲染一个小的方差阴影贴图。此可见性立方体贴图用于减少遮挡物后面的光泄漏。您可以在渲染设置中调整此贴图的大小，并在探头属性选项卡内调整每个网格的偏差和模糊因子。

	- Bias 偏差 降低自身阴影的伪影。 
	- Bleed Bias 出血偏移量 提高深度测试结果的对比度。 
	- Blur 模糊 过滤可见性阴影贴图时使用的模糊量。 它不会加大性能负担，对烘焙时间影响很小。


- Resolution 分辨率

	每个辐射体积探头的空间分辨率是独立的。其自身体积被分成指定尺寸的栅格。每个栅格的小格子都将被计算一次辐射采样。

- Viewport Display 视图显示

	- Influence 勾选以显示影响边界，在 3D 视图中靠内的边界是衰减开始的地方。
	- Clipping 范围限制 在3D 视图中显示裁减距离。


### ⚡ Reflection Cubemaps 反光盒

立方体反光盒将镜面间接反射 Specular Indirect Lighting 存储在立方体贴图阵列中。从哪里对场景光照进行采样，然后在哪里应用，这些属性都通过反光盒物体来定义。

在反光盒子影响范围内的对象会对间接光进行处理，结果就是它们的表面就有反射光所传递的映像。因为这是间接光的处理，需要配合间接光面板使用，渲染前需要对 Cubemap 进行烘焙，否则看不到间接光效果。

为了提高效率，Eevee 将间接照明数据根据需要预先计算到静态照明缓存中。到目前为止，光缓存是静态的，需要在渲染之前计算。它不能被每帧更新(除非通过脚本)。

屏幕空间反射反光盒要精确更多，启用后，优先使用屏幕空间反射，只有在光线无法采样时则使用反光盒作补充。如果启用环境光遮蔽 AO - Ambient Occlusion，将以物理合理的方式应用于间接光反射。

反光盒被编码为四面体映射，Z 轴负向的半球可能会出现一些畸变，粗糙度越高越明显。

来自反光盒的光照强度会向外逐渐衰弱，直到边界，它们会衰减至融入到场景光照或另一个反光盒光照。如果多个反光盒重叠，则优先考虑体积较小的反光盒。如果物体不在任何反光盒影响范围内，或者间接光没有烘焙，将使用场景立方体对其进行着色。

在使用反光盒时，注意其生效的范围，过大，会使得间接光的处理不恰当。当探头有效区外部的物体离探头太靠近时，探头可能会用探测到的场景来烘焙光照贴图，将本来应该被模型阻挡的间接光也当做有效光处理了，这时光线就会穿墙而过。解决这个问题的方法是离它远点，或者使用 Visibility
 中指定可见性集合，并激活右侧的箭头的按钮，让集合里的物体在探测过程不可见。所以设置合适的大小和形状，还有 Clipping 范围，将不该处理的光排除。



反光盒对象数据属性设置参考：

- Type 

	设置反光盒类型，Box 或 Sphere 以匹配模型。

- Size/Radius 

	指定探头有效距离半径，距离内表面的反射才有影响。

- Falloff 

	衰减距离的百分比，探头的作用将沿其线性衰减到有效半径处为零。

- Intensity 

	被记录光照的强度系数，设为 1.0 之外的值都不是物理正确的，可以将它调整达到艺术目的。

- Clipping Start/End 

	剪裁范围定义探头探测场景来烘焙贴图的最小距离和最大距离范围，丢弃此范围的光线。

- Visibility 

	可见性集合指定，当物体距离探头过近时，会影响探头探测场景来烘焙光照贴图。可见性集合可以使仅该集合物体可被探头采集到光照信息，双向箭头按钮可以反转集合的可见性。这只是一个过滤选项，如果一个物体在渲染时不可见，那么它在探头烘焙中也是不可见的。

- Custom Parallax 自定义视差

	默认情况下, 影响体积也是视差体积。视差体积是记录的光照投射的体积。它应该大致适合周围。在某些情况下, 最好在不触及影响参数的情况下调整视差体积。在这种情况下, 只需启用 自定义视差 并单独修改视差体积的形状和距离。

- Viewport Display 视图显示
	- Influence 勾选以显示影响边界，在 3D 视图中靠内的边界是衰减开始的地方。
	- Clipping 勾选以显示裁减距离。
	- Parallax 勾选在 3D 视图中显示自定义视差的外形。



### ⚡ Reflection Planes 反光板

反光板适用于平滑平面的反射，原理上是利用翻转的相机拍摄整个场景，这使得添加反光板的成像比高光的金属镜面还有清晰，曲面不适用。这个平滑平面就作为镜面反光物体，材质的粗糙度设置为 0。放置反光板时，其中有效位置需要在镜面对象上，反光板的有效大小取决于两者的最小面积。

反光板的反射效果中不包含次表面散射、屏幕空间反射和体积。

使用反光板会给性能带来负担，因为视图中有多少反光板，就要重复渲染多少次场景。

如果不启用屏幕空间反射选项的话，反光板仅对粗糙度为零的镜面物体有效。

如果启用屏幕空间反射，反光板将作为缓冲区来加速追踪过程，并给屏幕空间补全丢失的数据。这使得带有中等粗糙度或者扰动法线贴图的受影响表面的反射更加精确。

要启用屏幕空间反射选项，在 Eevee 引擎属性面板上勾选 Screen Space Reflections。

如果材质未启用背面剔除选项，没有勾选材质侧栏设置的 Backface Culling，则将反光板捕捉到平面将有效捕获曲面的下侧。

可以手动将反光板放在平面上方，使其不会被捕捉反射。或者，您可以将物体放在一个集合中，并将此集合用作反光板探针可见性设置中的反转集合 Visibility Collection。


- Probe 属性设置

	- Distance 设置探头物体仅影响其邻近表面的光照，其作用区域由距离参数与物体定义。只有与反光板法向一致的表面才能接收到捕捉的反射。
	- Falloff 影响距离的百分比，探头的影响沿其线性衰减。同时也定义了着色法向必须与接收反射的平面的一致程度。
	- Clipping Offset 钳制偏移定义反光板与裁切平面的靠近程度，调高该值可以解决反射接触的问题。
	- Visibility Collection 可见性集合在隐藏被探头捕捉的物体或者只有哪些物体可以被探头捕捉很有用。比如，当一个物体距离探头捕捉点过近时，用可见性集合可以将其隐藏。只有在该集合内的物体才会在探头捕捉场景时可见。另有一个选项可以反转操作，就是反过来去在探头中隐藏此集合中的物体。

- Viewport Display 视图显示

	- Arrow Size 指示反光板法向的箭头大小。
	- Show Preview Plane 显示反射面板，在 3D 视图中，全反光板显示捕捉到的反射图像。


Cycles 设置 Backface Culling 比较复杂，需要通过着色器设置混合透明实现，具体就是通过几何节点
Gemetry - Backfacing 获取到背面，并通过混合节点将其透明。配合 Holdout 着色器节点在图像中创建
一个 Alpha 透明度为零的 "孔" ，这对于合成非常有用。该着色器仅在开启属性 ‣ 渲染 ‣ 胶片 ‣ 透明时有效，
末开启的效果为黑色。





# 🚩 Example 学习案列

四棱锥 Pyramid 可以由 Cube + Bevel 修改器得到。通过倒角，将立方体的角切掉形成四个斜面，得到两个上下对称的四棱锥。设置 Segments 1，调整 Amount 到完全切掉角。

碳原子晶格 Carbon lattice，利用 Ico Sphere 棱角球和顶点倒角，棱角球本身每个顶点六条线，倒角处理就是六边形。一般设置百分比 33.33% 的顶点宽度类型即可以，再配置 Wireframe 修改器转换成线条风格模型。但这种方式得到的模型，每条边对应的是一个面，顶点是三面相交处。

另一个方法是使用 Array 修改器，利用 Circle 绘制六边形，利用几何关系，如绘制一个直径 0.1 的六边形，使用 Array 修改器复制，行偏移 0.5，列偏移 0.75，设置复制合适数量，最后再应用修改器，并删除模型中多余的边沿。结合 Simple Deform 进行简单形变 Bend 弯曲即可以构造成管状，修改器需要一个参考坐标，使用 Empty - Arrows 对象就可以。设置 Bend 弯曲 360 度，再调整 Empty 对象的旋转属性控制对象的弯曲。


将平面中选中的顶点成圆形化排列，使用官方内置的 looptoos 插件，手动球形化效果并没有插件好。如果顶点或连线太多，可以使用 Edge - Un-subdivide 进行精简。如果顶点不够多，可以使用顶点倒角 Bevel Vertices 加点平滑。

变通的方法是使用 Circle 形状，加上 Edge - Bridge Edge Loops 进行桥接，使用桥接循环边时，选中两个面上需要连接循环边。一般两组顶点数量要一致，否则会产生过多的连接连线。

可以将圆形和原平面压平，只要选择 Pivot Point - Active Element，并且保持目标平面上的顶点为当前亮的白色状态。再执行缩放，约束 z 方向，缩小到 0。

把顶点压平，多平面的顶点对齐到同一平面，步骤:

- 选择要压平的点。
- 按 S 键(缩放)。
- 按 X/Y/Z 再按 0 键，意味着缩放为 0。
- 按 Enter 确认。

根据不同的对齐需要选择轴心，快捷键  `.` 弹出轴心 Pivot Point 菜单 `,` 弹出方向 Orientation 菜单，也可以执行命令后进行调整 Adjust Last Operation，选择 Orientation，如按 Normal 法线方向归位。


### ⚡ displacement 渲染作弊
- Blender Guru 教程 displacement 渲染百万级物体 https://www.bilibili.com/video/BV1dJ411C7xu


### ⚡ 高模转低模
- [Blender 中烘培高模](https://www.bilibili.com/video/BV1p5411h7Rb)
- [法线贴图烘焙](https://www.bilibili.com/video/av55915594/)
- [Opengl 教程 Tutorial 13 : Normal Mapping](http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/)
- [概念到低模雕刻成高模，高模生成低模的法线](https://www.bilibili.com/video/av37077657/)
- [Bsurfaces GPL Edition 高模拓扑插件](https://www.bilibili.com/video/BV1Dp4y167Kh)
- [RetopoFlow 高模拓扑插件](https://github.com/CGCookie/retopoflow)
- https://blendermarket.com/products/retopoflow/
- [Creating 3D environments in Blender By Rob Tuytel](https://www.acfun.cn/v/ac22141019)
- [Rob Tuytel 材质教程](https://www.bilibili.com/video/BV1Z7411B7c3?p=9)
- [MultiRes + ShrinkWrap 高模转低模](https://www.bilibili.com/video/BV1At4y1T7Jv/)

流行的三维软件都可以实现一个基本的建模工作流，从高精度建模（High Polygon），再通过烘焙（Bakeing）
或其它拓扑工具，将高模转换为低精度模型（Low Polygon）的过程。而各种贴图可以用于修复丢失的部分细节。

在高精度模型与低精度模型之间的一个映射模型，一般叫做 Project mesh，或者 Cage Mesh，一般来说
由工具自动产生这个模型，它的作用就像一个投影机或者投影范围，想象一下你就知道它在三个模型之间的作用了，
这个中间模型，肯定会有并且发挥作用，当然大部分情况下你可以手工制作它。

除了专用的法线贴图生成工具如 CrazyBump，Blender 本身也可以将模型的法线贴图单独渲染出来，一般是
将高模即高面数细节丰富的模型的细节烘焙到法线贴图上，然后通过法线贴图就可以在低模上模拟除丰富的细节。

比如有一张现成的砖墙纹理图片，结合置换 Displace 修改器来生成高模，相当于将砖墙纹理图片作为置换贴图
Displacement Mapping 来生成模型的表面凹凸细节，然后再通过 Cycle 渲染器的烘焙功能生成法线贴图，
烘焙前给这个生成的高模设置一个空贴图用来保存烘焙结果，步骤如下：

- 场景中添加一个平面 Plane 利用纹理图片置换生成高模；
- Ctrl-3 给平面对象添加表面细分修改器 Subdivide，不够可以再添加一个或加大细分段数以达到高模的细节要求；
- 添加一个置换修改器 Displace；
- 将纹理图片加载到置换修改器上，创建增加一个 Texture 纹理即可，可以根据需要调整纹理坐标，默认是 Local，置换方向使用默认的 Z 轴就可以；
- 再转到纹理属性面板 Textures Properties，选择上一步创建的纹理对象，使用默认的 Image or Movie 类型，设置 Image 面板的文件路径；
- 可以通过纹理属性中的 Colors 面板调整纹理的亮度 Brightness、 对比度 Contrast、 饱和度 Saturation；
- 调整置换修改器的强度 Strength，以模型凹凸纹理清晰平滑为标准即可。

Blender 2.92 中提供了内置插件创建地形 A.N.T. Landscape, Another Noise Tool，这样就不必
使用置换贴图来获取实验用的高模。

通过以上的置换修改器等到高模后，再给 Plane 设置法线贴图以准备烘焙，可以打开材质编辑器操作，也可以
通过材质属性面板操作：

- 转到材质属性面板，保持 Plane 对象选中，点击 + New 新建材质；
- 设置 Base Color 属性，点击其右侧的圆点关联一个图片纹理 Image Texture，它是用来接后烘焙结果的；
- 点击图片纹理的文件选择框中的 + New 新建一个纹理文件即可，指定文件名如 normal_bake，不需要其它设置；

设置好高模后，接下来就可以使用 Cycle 渲染引擎烘焙法线贴图了：

- 属性编辑器中，Render Properties 渲染引擎设置为 Cycle；
- 在 Bake 烘焙面板中选择烘焙法线 Bake Type - Normal，空间类型可以选择切线空间 Tangent 或对象空间 Object。
- 使用 UV Editor 或图片编辑器查看烘焙的法线贴图文件。

在材质编辑器中将法线贴图文件连接到起来观察效果，使用 Image Texture 载入纹理文件，通过 Normal Map
节点连接 Principled BSDF 着色器的 Normal 输入端口。 

使用这个方法可以给纹理图片生成法线贴图，通过法线贴图来增强低模的细节，但是这种方法生成的法线贴图
不是很准确。也不太可能人工绘制法线贴图，细节太多了，必须通过软件进行转化而来，如 CrazyBump 就
可以灵活自如从图片中生成法线贴图，还有 Substance Bitmap2Material、 Knald、 xNormal 等等。


如果已经有低模，也可以将高模的细节烘焙到法线贴图，以简单的地势模型为例：

- 首先低模在上、高模在下，沿 Z 轴摆放；
- 先给低模设置材质，通过材质编辑器添加一个图像纹理节点接口，新建纹理文件并设置好纹理文件名，不用连接即可；
- 选择高模模型，再选择低模；
- 将渲染器改为 Cycle，勾选烘焙面板中的 Selected to Active 选择作为活动物体；
- 如果低模在下方摆放，那么到高模的距离不要超过 Ray Distance 指定的距离，如果超过，烘焙结果则会对高模中超过距离的位置进行裁切；

如果对一个复杂的模型进行烘焙，那么可以用一个罩体 Cage 围住低模和高模，勾选 Cage 并指定 Cage Object
罩体物体进行烘焙。Selected to Active 能烘焙所选物体的着色到活动物体，光线会从外面的低模物体投射
到内部的高模物体。

倘若高模物体没能被低模物体完全包裹，你可以通过调节光线距离或是罩体挤出 (取决于你是否使用罩体)来
调节光线的起点。



### ⚡ Water surface Render
- [水波纹模拟着色器 WaterSurfaceRender(从Unity移植)](https://www.bilibili.com/video/BV1Eg41187oR/)


### ⚡ Textures 14 种设置方式
- 14种贴图纹理与阴影混合方法 https://www.bilibili.com/video/BV1WE41117zH
- Rob Tuytel 材质贴图混合 https://www.bilibili.com/video/BV1Z7411B7c3?p=7

1.通过 Poligons
选择一些poligon并为其分配其他材料，十分简单。
调整两种材料，而不是一种。

2.按对象 ID
Blender 中的每个对象可以具有不同的 ID。您可以在“对象属性”面板中对其进行更改。
完成此操作后，您可以使用材质编辑器中的“对象信息”节点根据此ID在不同材质之间进行混合。例如，如果ID小于2，则将其混合。

3.随机
您可以使用“对象信息”节点的“随机”输出为每个对象分配随机的灰色阴影。

4.以3D方式绘制蒙版
使用智能UV项目解开对象。然后进入“纹理绘制”模式，将漫反射纹理添加到绘制槽中。

5.投射遮罩
按T打开工具架，然后转到“外部”选项卡，然后单击“快速编辑”按钮。启动 Krita，Gimp或Photoshop（取决于您在首选项中设置的内容）。
然后在单独的图层上绘制所需的任何内容。点击保存，转到Blender并点击应用。

6.使用第二个UV贴图
添加贴花的最简单方法之一是使用第二个UV贴图。选择第二个UV通道，然后选择一些多边形并使用“从视图中投影”方法将其展开。
在材质编辑器中，不要忘记将第二个UV贴图应用到贴花纹理。

7.程序纹理
程序纹理的一个巨大优势是它们具有无限的分辨率。可以无限放大并不改变分辨度和清晰度。

8.平铺的纹理和框映射
如果您不喜欢为模型创建UV贴图，那么您会喜欢这种混合纹理的方式。您只需要在Box映射中应用Generated坐标，即可从6个方向（盒子的侧面）投射无缝蒙版纹理。

9.法线
您可以基于表面法线混合着色器和材质。非常适合基于方向的效果：灰尘，雪等。

10.置换
对我来说，这是一种绘制模型的高度梯度的非常直观的方法。
您可以分离“生成”坐标的Z分量。然后将其用作高度混合系数。

11.坡度
您可以通过将Z值与法线向量分开来计算斜率。通过ColorRamp运行它以进行微调。

12.顶点颜色
混合纹理的另一种方法是使用“顶点颜色”。这种方法有点麻烦，因为这仅适用于高多边形模型。
如果要尝试，请按V进入“顶点绘制”模式，然后绘制蒙版。

13.指向性
指向性可用于基于对象曲率在纹理之间混合。这是创建边缘蒙版的最简单方法。
虽然，它也取决于多边形的密度。

14.距离（动态涂料）
可以找到两个对象之间的距离并将其传递给着色器。
您需要先启用Dynamic Paint。然后分配一个画布对象和一个画笔对象。黑白贴图将成为您的距离渐变。


### ⚡ 花朵制作
1. Grease Pencil 初学者教程 https://www.bilibili.com/video/BV1Tp4y1h7Ya/
2. 几何节点 花开动画 https://www.bilibili.com/video/BV1cP411Z7L2/

添加一个 plane，进入 edit mode，使用 k 或 Ctrl-R 分割成两个格子，适当调整近似纺锤形。

将两格子调整成 90 度关系，给中间的分割线设置连线倒角 Ctrl-B，这样就可以模拟花瓣弯曲的结构。

给模型添加一个 solidify 实体化修改器，使 plane 有一定的厚度。


### ⚡ 半透明叶片
- Creating 3D environments in Blender By Rob Tuytel https://www.bilibili.com/video/BV1Z7411B7c3?p=35
- http://soilcropandmore.info/crops/Grasses/Reed_canarygrass/Reed-Canarygrass-Phalaris-caroliniana.htm

可以通过建模来创建叶片，也可以通过 PNG 图片中现有的 Alpha 通道来将平面转换成相应的叶片。为了使用符合 glTF 的材质，请将纹理中 alpha 蒙版信息输入连接到 Principled BSDF 节点的 Alpha 输入。

但是，在叶片遮挡混合时，要模拟出半透明的效果就需要额外的设置。

Translucent BSDF 结合 Mix Shader 着色器节点来支持这一混合效果，Mix Shader 节点中的系数来定义 Alpha 值，或者直接指定一个值，也可以从其他一些节点（例如菲涅耳）创建依赖关系，以获得更逼真的外观。


### ⚡ Grass land 草地
- 制作照片级森林 https://www.bilibili.com/video/BV1jJ411r7BY/
- 制作真实的草全流程 https://www.bilibili.com/video/BV1fy4y1y72g/
- https://texturehaven.com/tex/?t=aerial_rocks_02
- https://texturehaven.com/tex/?c=terrain&t=aerial_grass_rock
- 水蒲苇莺 https://www.birdspot.co.uk/bird-identification/reed-bunting
- Turtle Dove by S.Ray https://sbbot.org.uk/sightings-2/sightings-birds
- Downy Woodpecker https://www.allaboutbirds.org/guide/Downy_Woodpecker
- 吉卜力卡通效果 By Lightning Boy Studio https://www.bilibili.com/video/BV1Nb4y1d79J

准备材料：

- Dirty ground 贴图
- 芦苇草高清纹理图

使用内置插件创建地形 A.N.T. Landscape, Another Noise Tool。

对象编辑器，Add - Mesh - Landscape 添加地形模型。



### ⚡ Sapling Tree Gen 内置树木建模插件
- Sapling Tree Gen 风吹树动 https://www.acfun.cn/v/ac22391871
- https://docs.blender.org/manual/zh-hans/latest/addons/add_curve/sapling.html

启用插件，在以下位置找到操作面板：

- 3D Viewport ‣ Add ‣ Curve ‣ Sapling Tree Gen

树木建模主要考虑三个部分：

- 树干和大树枝(branches)
- 小树枝(fronds) 
- 树叶(leaves) 

小树枝可以使用两个十字交叉的面模拟小树枝，为了节省三角形。

树叶可以使用 billboard 方式实现快速绘制，这样叶片始终朝向观察者，产生的视觉效果也比较好。也可以使用平面绘制，增加一定的弯曲来模拟细节，增加真实感。

叶片的特性，互生或对生，叶片形状，卵形或卵状椭圆形，条形、针形等等。

树干基本决定树的类型，是灌木 shrub 或是乔木 tree，其特征就是根部的分支数量，和躯干的分叉。树枝的长生还需要根据品种的特性设置，有环状的有零散的。



### ⚡ Ivy Generater 内置藤蔓插件
- [Ivy Generater 内置藤蔓插件](https://www.bilibili.com/video/BV16J411R72E)
- https://docs.blender.org/manual/zh-hans/latest/addons/add_curve/ivy_gen.html#
- An Ivy Generator by Thomas Luft University of Konstanz http://graphics.uni-konstanz.de/~luft/ivy_generator/

启用插件，在以下位置找到操作面板：

- 3D Viewport ‣ Sidebar ‣ Create tab.
- 3D Viewport ‣ Operator.




### ⚡ Tree & Particles
- [CG Geek 一分钟造树](https://www.bilibili.com/video/av78682037/)
- [真实三维树木 Realistic Tree](https://www.bilibili.com/video/av82406454/)

教程使用挤出功能对 Box 进行造型，形成树干部分，再使用粒子系统来生成枝叶。需要准备一两张带叶子的树枝，比如榛树，通过顶点权重的绘制将树枝挂到树干上，从而快速得到树的模型。

需要用到内置的插件 Import Images as Planes，在配置中打开，也可以手动建立一个平面 Plane 再将图片纹理设置为材质的 Base Color。

挤出工具快捷键 E 或 Ctrl-RMB。

- 添加一个 Box，进入编辑模式；
- 使用环切 Ctrl-R 工具，或细分 Edge - Subdivide 添加几条竖直边；
- 使用锥形化工具 To Sphere，快捷键 Shift-Alt-S 将上表面做成近似圆形；
- 继续使用挤出 Extrude 延展出树干，结合环切细分工具等，按树枝的形状任意挤出更多的枝干；
- 注意使用 S 缩放，逐级变小枝干，也可以增加枝干的面数使其接近圆形；
- 将准备好的枝叶图片导入 Add - Image as Plane；
- 进入编辑模式，使用小刀在图片关节位置切割，删除无用的顶点，调整顶点使平面起伏；
- 选择树枝的末端，即会长叶子的顶点分配新的顶点组，在属性面板 Object Data - Vertex Group；
- 进入权重绘制模式，末端绘制红色的大权重，粒子系统会使其叶子更多，带权重的顶点会自动归到顶点组；
- 给树干添加粒子对象，Particles 属性面板中设置为毛发模式 Hair；
- 设置粒子数改变茂盛度 Emission - Number；
- 设置粒子渲染为对象的 Render As - Object，并设置 Instance Object 为叶子对象；
- 设置粒子的 Vertex Groups - Density 为前面定义的顶点组，这样就会按权重生成枝叶；
- 打开粒子的高级模式 Advanced，勾选旋转 Rotation，并设置随机性 Randomize & Phase；

粒子生成的枝叶对象和树干连结的点是原点位置，通常需要根据图片进行调整，Ctrl-Period 打开原点编辑，适当调整 Object Origin 物体原点。

要获得更多的真实感，需要对枝叶及树干进行材质调整。

树木生成参考 SpeedTree/Realistic Tree Pack。


## 👉 Snowflake
- [String Fairy - Snowflake](https://www.bilibili.com/video/BV1Qb411Y7Up)
- [Dynamic Snow Effects](https://www.bilibili.com/video/BV11J411x7YR)
- [Create dynamic snow in blender](https://www.bilibili.com/video/BV16J411z7tq)
- [Dynamic Paint Guide](https://miikahweb.com/en/articles/dynamic-paint-guide)
- [Dynamic paint 动态绘图](https://www.bilibili.com/video/BV1z4411K7t5)

String Fairy 一直在油管上分享他制作的材质片段，这一次终于带来了一部完整的教程，讲解如何制作雪的材质。


创建一个滚雪球场景，雪球滚动产生的痕迹需要物理系统 Physics 的刚体 Rigid Body 和 Dynamic Paint 动态绘画组合产生。

- 创建适当大小的一个球体和平面，分别在物理属性面设置为 Active 和 Passive 刚体，平面充当地面；
- 沿 x 轴旋转平面 45°，并且移动球体到平面上方 1m 左右，这样播放动画是球体就会沿平面向下滚动；
- 适当调刚体的整碰撞响应参数，阻力或回弹 Collisions - Surface Response - Friction/Bounciness；
- 复制平面并沿 z 轴上移 20cm，在物理属性面板设置为 Dynamic Paint，类型设置为笔刷 Brush，这样


### ⚡ Apple - Blender Texture Paint
- [渲染效果](https://www.bilibili.com/video/BV1ai4y147wx/)
- [教程地址](https://www.bilibili.com/read/cv6052427)


预备工作要点：

- 搜索下载苹果纹理图片，最好带果柄。如果，有绘画基础，可以直接绘制自己的纹理；
- 使用 Blender 的雕刻模式 Sculpt Mode 将一个球体造型为平果；
- 使用 UV Unwrapping 生成模型贴图坐标；
- 给模型设置材质节点；
- 使用 Texture Paint 模式将苹果纹理绘制到模型上；

第一步 雕刻建模

添加一个球体 UV Sphere，执行右键菜单光滑着色 Shade Smooth 以使得模型看起来更平滑。保持选中球体，
切换到雕刻模式 Sculpt Mode。

对球体上下两点做凹陷造型，使用膨胀工具 Inflate，按住 Ctrl 就可以将这个工具反转成为制造凹陷的工具。
将球体上下两顶端深凹进去，面数不足，可以激活动态拓扑， Ctrl-D。

回到编辑模式，添加一个 Cylinder 圆柱体，作为果柄，按 S 适当对直径缩放到合适大小，再按 SZ 对长度
缩放调整到合适长度。

再转到雕刻模式，使用膨胀工具 Inflate 对果柄两端进行放大，模拟自然状态。再使用 Elastic Deform
弹性变形弯曲果柄。最后，按 M 移动果柄到苹果项端胡凹陷处，对好位置。


第二步 展开模型

因为上一步启用了动态拓扑，模型的面会较乱，直接使用智能展开 Smart UV Project。得到 UV 贴图坐标后，
再给模型设置材质，关联空白纹理贴图以进行绘画。

可以激活孤岛选择模式 Island Selection，这样可以对单独成片的贴图面片进行布局调整。

转到 Shading 工作空间，在右下角的图片编辑器中新建一个 1024x1024 差不多的贴图，然后在右侧在材质
节点通过 Image Texture 节点连接到原理化 BSDF 着色器上，这样简单设置材质即可。


第三步 绘制纹理

进入纹理绘制工作空间，进入绘图模式，开始将下载好的苹果纹理绘制到模型上。设置纹理的映射模式为镂空
 stencil，并在右下角的纹理属性面板中加载前面下载好的苹果纹理图片。

接下来就正式开始绘制纹理，使用 RMB 鼠标右键拖动纹理到可以覆盖模型的位置，再使用画笔涂抹就可以将
纹理图转印到模型上。可以使用 Shift-RMB 缩放纹理，Ctrl-RMB 旋转纹理图片。

最后，设置渲染器渲染，这里使用 Cycles 渲染引擎，GPU 渲染，8 次采样，Performance - Tiles X/Y
均为 256 以加速出图。输出设置为 PNG 图片。

然后，再使用视频序列编辑器，加载 PNG 图片序列，再加载一段 Music，再输出为视频。注意，输出选择上 
Audio，否则没有声音。

PS： 使用 Blender 自带的 Animate 插件生成相机环绕动画镜头。





### ⚡ Skin Texture Paint 超写实皮肤材质纹理
[超写实皮肤材质纹理绘制](https://www.bilibili.com/video/av77781302)

Blender 中可以利用 Texture Paint 模式对模型纹理贴图进行绘制。Blender 提供的模型绘制模式制作皮肤材质，通过绘制工具制作真皮层贴图、模拟皮肤血管带来的血色的次表面贴图、模拟表皮层凹凸感的贴图。

需要新建三个纹理，可以通过图片编辑器或 UV 编辑器操作，纹理贴图参数如下：

- skin_derm	2048x2048	Color #E4AD8F 米黄
- skin_sub	2048x2048	Color #742930 暗红
- skin_bump	2048x2048	Color #808080 中灰

新建纹理贴图文件后，通过编辑器菜单保存。如果打包到 blend 文件内部保存需要执行 Image - Pack，之后修改或在 Texture Paint 中绘画改动后需要执行 Image - Save 对纹理文件进行打包保存，可以在纹理工具面板中通过 Texture Slots - Save All Images 保存所有纹理文件的改动。并且要保存 blend 文件，否则改动内容不会保留。

接下来添加一个立方体到场景，将三张贴图通过材质关联起来，通过材质编辑器 Shader Editor：

- skin_derm	通过 Image Texture 连接到着色器 Principled BSDF - Base Color；
- skin_sub 	通过 Image Texture 连接到着色器 Principled BSDF - Subsurface Color，Subsurface 设置 0.2；
- skin_bump	通过 Image Texture 连接 Bump - Height，设置 Distance 0.4，再连接着色器 Principled BSDF - Normal；
- Principled BSDF - Roughness 糙度 0.5；
- Principled BSDF - Sheen Tint 光泽着色 0.5；

模型需要按需要进行 UV 贴图展开，默认球体会使用球体投射 Sphere Projection 方式展开，就是制图人员绘制世界地图的方法，这里为了使 UV 贴图面方正规整，使用 Unwrap 或 Smart UV Project 展开。不同的展开方式会影响绘图时，笔触与模型的接触点如何映射到纹理图片的位置。

进入编辑立方体模式，通过 UV 菜单进行展开，然后给模型添加表面细化修改器 Subdivide 配合 Face - Shade Smooth 光滑着色可以在 3 段细化的基础上让立方体转变为较平滑的球体。

继续设置一下世界空间的背景光，切换质编辑的模式 Object 切换到 World 模式，给 World Output 节点设置一个 Blackbody 黑体着色器节点，它可以将黑体温度转换为 RGB 值，用于材料发射自然光，只需要给它一个温度值，就可以输出对应温度的光。将温度 Temperature 设置为 4500。同时将场景的灯光对象改为 Sun 光类型，设置强度 Strength 4，这样可以让场景的模型的背光面具有热辐射状态下的红火质感，向光面呈现皮肤的通透感。


凹凸贴图底色使用 0.5 灰度 #808080，绘制时使用 0.4 灰度 #666666，这样会产生凹陷的视觉效果。需要使用到的颜色可以添加到画笔工具面板的调板 Color Palette，方便后续使用，清除整个贴图可以使用渐变填充，设置同一个渐变色即可。进入模型绘制模式 Texture Paint 后，在 Texture Slots 选择需要绘制的纹理槽对应的纹理图像。纹理图片文件也可以在这里创建，点击列表右侧的的 + 号既可创建纹理图片。

在侧栏工具设置面板调整画笔颜色、调板、笔触大小：

- F 设置笔刷大小，可用快捷键 [ 和 ] 更改笔刷大小。
- Shift-F 设置笔刷强度
- Ctrl-F 设置纹理笔刷的旋转角度，可以在 3D 视图中通过以下方式进行交互式更改，这里还不需要使用。

衰减曲线 Falloff 调整笔刷，曲线左侧控制笔触中心的色彩浓度，右侧控制边缘浓度，曲线越陡边缘越清晰，反之模糊。

调整笔触 Stroke Method 描边方式为 Space 间隔 Spacing 60%，晃动 Jitter 1.0，这样在模型表面绘制贴图时可以产生离散的笔触斑点，模拟皮肤的纹理。

注意选择笔刷混合模式 Blend，默认是 Mix 混合色彩，可以使用 Erase Alpha 设置透明区，反过来 Add Alpha 增加不透明度。




# 🚩 PureRef 参考图片神器

PureRef是一个非常好用的绘画素材参考神器，它可以非常方便的将图片截取下来并保存在其中，通过对素材图片的旋转，移动和拉伸，让它们排版从成你需要的样子。并且软件可以置顶悬浮在所有窗口之上，需要的用户快来下载使用吧。


首先是下载地址：
https://www.pureref.com/
http://www.3h3.com/soft/150562.html
https://pan.baidu.com/s/1yU_xXbmb6_JPGQnOJhjs7g#6cuj

这是款免费软件，在下载时可以通过PayPal捐赠支持作者，也可以输入0元直接下载。良心的不行。

- 添加图片

	您可以直接从浏览器中拖放计算机或图像中的文件。您也可以使用右键单击菜单或ctrl + v粘贴它们。

- 编辑图像

	您可以通过几种方式编辑图像以满足您的参考需求。您可以：

	- 选择一个或多个
	- 专注于一个或多个（双击/空格）
	- 旋转（自由或使用shift进行对齐）
	- 翻动
	- 规模
	- 作物
	- 改变不透明度
	- 删除
	- 保存图像

- 控制画布

	画布是您的场景，也可以通过多种方式使用。功能包括：

	- 优化图像周围的画布。
	- 打包你的图像。
	- 始终在顶级功能上切换。
	- 切换到鼠标功能透明。
	- 锁定画布以进行编辑。
	- 清晰的画布。
	- 撤销重做。
	- 重置相机。
	- 保存/加载场景。
	- 导出场景。

- 定制

	您可以自定义PureRef的外观和键盘快捷键以满足您的需求。

	- 自定义颜色。
	- 保存颜色主题。
	- 更改主不透明度。
	- 自定义键绑定。

- 使用方法

- 界面可以通过拉扯四个角落，进行形状的调整。
- 鼠标右键可以拖拽界面到屏幕上合适的位置。
- 在界面中按住鼠标滚轮，并移动鼠标，在界面平行移动。
- 鼠标左键就是选择图片。
- 如果一张图片，你只想显示其中的一部分，按住键盘上的 C 键裁剪想显示的区域。取消剪裁时，选中图片，Shift-Command-C。
- 右键或菜单选择模式，可以让参考图片一直显示在顶端，也可以对鼠标透明，穿透直达工作软件。
- 选中一个图片，按空格，这个图片就会显示到正中间。
- Command-U 可以调整界面的颜色。。
- 右键就是快捷菜单，可以对图形进行各种变换。
- 可以保存方便下次使用，不同的图片类型可以保存成不同的文件。
- 水平上下翻转，用 Alt-Shift-RMB 鼠标左键按照方向拖拽。
- 旋转，按住 Ctrl-LMB-Drag 用鼠标拖拽
- 查看颜色代码按住 S，然后鼠标左键点击。

- 怎么置顶

	PureRef 可以置顶悬浮在所有窗口上面，用于作画参考非常方便，下面就来告诉大家如何进行置顶操作。

	在 PureRef 右键呼出设置菜单，选择 Mode - AlwaysOmTop，快捷键 Ctrl-Shift-A。如果无法置顶，一般是和其他软件的热键冲突，导致无法置顶。

- 怎么退出全屏

	在全屏状态下右键，选择 Window - Maximize 就可以退出全屏了，快捷键  Ctrl-F。

- 菜单

	- Help		Ctrl-H
	- About		Ctrl-J
	- Setting	Ctrl-U

	- Undo		Ctrl-Z
	- Redo		Ctrl-Shift-Z

	- Copy		Ctrl-C
	- Pase		Ctrl-V
	- Note		Ctrl-N

	- Mode

		Transparent to Mouse		Ctrl-T 穿透鼠标/取消穿透
		Overlay Selection			Ctrl-Y 覆盖选择的图片到屏幕上（可操作其他软件）
		Always on Top				Ctrl-B 置顶，总是在其它窗口顶层显示
		Always on Bottom			Ctrl+Shift-B 置底

	- Window

		Maximum					Ctrl+F
		Minimize				Ctrl+M
		Resize to Selection		Ctrl+Shift-R
		Lock Window				Ctrl+W 锁定

	- Canvas

		Optimize				Ctrl-O
		Reset Camera			Ctrl-G
		Reset Camera Rotate		Ctrl-Shift-G
		Lock Canvas				Ctrl-R
		Grayscale				Ctrl-Alt-G
		Clear					Ctrl-K

	- Images

		- Select All			Ctrl-A

		- Selection

			Reset Cropping				Ctrl+Shift+C	⇧⌘C
			Reset Transform				Ctrl+Shift+T	⇧⌘T
			Open Source					Ctrl+Shift+O	⇧⌘O
			Toggle Bilinear Sampling	Alt+T	⌥T
			Toggle Grayscale			Alt+G	⌥G
			Send To Back				Down	↓
			Send To Front				Up	↑
			Delete						Del	⌫

		- Arrange

			Arrange By Addition		Ctrl+Alt+A	⌥⌘A
			Arrange By Name			Ctrl+Alt+N	⌥⌘N
			Arrange Optimal			Ctrl+P	⌘P

		- Align

			Align Bottom	Ctrl+Down	⌘↓
			Align Left		Ctrl+Left	⌘←
			Align Right		Ctrl+Right	⌘→
			Align Top		Ctrl+Up		⌘↑
			Stack			Ctrl+Alt+S	⌥⌘S

		- Normalize

			Normalize Height	Ctrl+Alt+Left	⌥⌘←
			Normalize Scale		Ctrl+Alt+Down	⌥⌘↓
			Normalize Size		Ctrl+Alt+Up	⌥⌘↑
			Normalize Width		Ctrl+Alt+Right	⌥⌘→

	- Save

		Save			Ctrl-S
		Save As		Ctrl-Shift-S

		- Export

			Scene				Ctrl-I
			All Images		Ctrl-Alt-I
			Selected Images	Ctrl-Shift-I

	- Load
		
		Load				Ctrl-I
		Load Images		Ctrl-L
		Load Rencent	

	- Close		Ctrl-X


Default keybindings

Actions

	Function	Windows/Linux	Mac
	About	Ctrl+J	⌘J
	Align Bottom	Ctrl+Down	⌘↓
	Align Left	Ctrl+Left	⌘←
	Align Right	Ctrl+Right	⌘→
	Align Top	Ctrl+Up	⌘↑
	Always On Bottom	Ctrl+Shift+B	⇧⌘B
	Always On Top	Ctrl+Shift+A	⇧⌘A
	Arrange By Addition	Ctrl+Alt+A	⌥⌘A
	Arrange By Name	Ctrl+Alt+N	⌥⌘N
	Arrange Optimal	Ctrl+P	⌘P
	Close	Ctrl+X	⌘Q
	Copy	Ctrl+C	⌘C
	Decrease Master Opacity	Ctrl+-	⌘-
	Export All Images	Ctrl+Alt+I	⌥⌘I
	Export Scene	Ctrl+E	⌘E
	Export Selected Images	Ctrl+Shift+I	⇧⌘I
	Grayscale	Ctrl+Alt+G	⌥⌘G
	Help	Ctrl+H	⌃H
	Increase Master Opacity	Ctrl++	⌘+
	Load Images	Ctrl+I	⌘I
	Load Most Recent	Ctrl+Shift+L	⇧⌘L
	Load	Ctrl+L	⌘L
	Lock Canvas	Ctrl+R	⌘R
	Lock Window	Ctrl+W	⌘W
	Maximize	Ctrl+F	⌘F
	Minimize	Ctrl+M	⌘M
	New Scene	Ctrl+K	⌘K
	Normalize Height	Ctrl+Alt+Left	⌥⌘←
	Normalize Scale	Ctrl+Alt+Down	⌥⌘↓
	Normalize Size	Ctrl+Alt+Up	⌥⌘↑
	Normalize Width	Ctrl+Alt+Right	⌥⌘→
	Note	Ctrl+N	⌘N
	Open Source	Ctrl+Shift+O	⇧⌘O
	Optimize Canvas	Ctrl+O	⌘O
	Overlay Selection	Ctrl+Y	⌘Y
	Pack All And Optimize	Ctrl+Shift+P	⇧⌘P
	Paste	Ctrl+V	⌘V
	Preset Custom1	Alt+4	⌥4
	Preset Custom2	Alt+5	⌥5
	Preset Custom3	Alt+6	⌥6
	Preset Custom4	Alt+7	⌥7
	Preset Dark	Alt+1	⌥1
	Preset Glass	Alt+3	⌥3
	Preset Light	Alt+2	⌥2
	Redo	Ctrl+Shift+Z	⇧⌘Z
	Relink Missing Images	Ctrl+Alt+Shift+R	⌥⇧⌘R
	Reset Camera Zoom	Ctrl+Shift+G	⇧⌘G
	Reset Camera	Ctrl+G	⌘G
	Reset Cropping	Ctrl+Shift+C	⇧⌘C
	Reset Transform	Ctrl+Shift+T	⇧⌘T
	Resize To Selection	Ctrl+Shift+R	⇧⌘R
	Save As	Ctrl+Shift+S	⇧⌘S
	Save	Ctrl+S	⌘S
	Settings	Ctrl+U	⌃⇧⌘D
	Stack	Ctrl+Alt+S	⌥⌘S
	Toggle Bilinear Sampling	Alt+T	⌥T
	Toggle Grayscale	Alt+G	⌥G
	Transparent To Mouse	Ctrl+T	⌘T
	Undo	Ctrl+Z	⌘Z

Controls

	Function	Windows/Linux	Mac
	Axis Snapped Move Item	Left MB + Shift	Left MB + ⇧
	Change Opacity	Left MB + Ctrl+Alt+Shift	Left MB + ⌥⇧⌘
	Continuous Select	Left MB + Shift	Left MB + ⇧
	Crop Selection	Left MB + C	Left MB + C
	Delete	Del	⌫
	Flip Image Horizontally	Alt+Shift+H	⌥⇧H
	Flip Image Vertically	Alt+Shift+V	⌥⇧V
	Flip	Left MB + Alt+Shift	Left MB + ⌥⇧
	Focus Canvas	Ctrl+Space	⌘Space
	Focus Image	Space	Space
	Focus Next Image	Right	→
	Focus Previous Image	Left	←
	Move Item	Left MB	Left MB
	Neighbour Snapped Move Item	Left MB + Shift+Space	Left MB + ⇧Space
	Pan (While Locked)	Left MB	Left MB
	Pan (While Maximized)	Right MB	Right MB
	Pan Cropping	Left MB + V	Left MB + V
	Pan	Left MB + Alt	Left MB + ⌥
	Pan	Middle MB	Middle MB
	Rotate	Left MB + Ctrl	Left MB + ⌘
	Scale	Left MB + Ctrl+Alt	Left MB + ⌥⌘
	Select All	Ctrl+A	⌘A
	Select Items	Left MB	Left MB
	Send To Back	Down	↓
	Send To Front	Up	↑
	Show Color Code	Left MB + S	Left MB + S
	Show Image Coordinate	Left MB + D	Left MB + D
	Snapped Rotate	Left MB + Ctrl+Shift	Left MB + ⇧⌘
	Zoom Cropping	Left MB + Shift+V	Left MB + ⇧V
	Zoom	Left MB + Z	Left MB + Z

System

	Function	Windows/Linux	Mac
	Move Window	Right MB	Right MB
	Open Context Menu	Right MB	Right MB
	Resize Window	Left MB	Left MB