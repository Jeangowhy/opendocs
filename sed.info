
_______________________________________________________________________
Sed in 5 Minutes
---------------------------------------------------
1. https://www.gnu.org/software/sed/manual/
2. https://www.gnu.org/software/gawk/manual/

GNU sed 是一个以命令行方式运行的编辑器，它使用流式数据处理，可以处理文件或
其它命令的 stdout 输出流。所谓流式处理，即数据像流水一样，从头到尾一次过
流过（处理）sed 命令（stream editor）。

因此，sed 中的数据有两种形式：原始数据和处理过的数据。
使用 `-n` 命令行参数即打印原始数据，sed 提供了多种工具（命令），其中 `p` 
即为 print 命令，用于打印处理过的数据。

GNU sed 与 POSIX Basic Regular Expression (BRE)  正则表达式引擎密切相关，需要使用
正则表达式才能最化发挥功能。这里假设你已经掌握正则表达式的基础，会使用以下
POSIX BRE Special Character Classes 特殊正则符号所能匹配的字符串：

| Class | Description |
| ----- | ----------- |
| [[:alnum:]] | Alphanumeric characters: '[:alpha:]' and '[:digit:]', the same as '[0-9A-Za-z]'.
| [[:alpha:]] | Alphabetic characters: '[:lower:]' and '[:upper:]', the same as '[A-Za-z]'.
| [[:blank:]] | Blank characters: space and tab.
| [[:cntrl:]] | Control characters.  have octal codes 000 through 037, and 177 (DEL).
| [[:digit:]] | Digits: '0 1 2 3 4 5 6 7 8 9'.
| [[:graph:]] | Graphical characters: '[:alnum:]' and '[:punct:]'.
| [[:lower:]] | Lower-case letters; 'abcdefghijklmnopqrstuvwxyz'.
| [[:print:]] | Printable characters: '[:alnum:]', '[:punct:]', and space.
| [[:punct:]] | Punctuation characters; ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ \` { | } ~.
| [[:space:]] | Space characters: tab, newline, vertical tab, form feed, carriage return, and space.
| [[:upper:]] | Upper-case letters: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.
| [[:xdigit:]] | Hexadecimal digits: '0123456789ABCDEFabcdef'.

这里使用双层方括号是习惯用法，因为 Character Classes 表示的是一类字符，必需使用正则
表达式中的方括号，可以对 Character Classes 各种分类进行组合应用，例如，C/C++ 语言的
变量标识符号可以使用 `[[:alpha:]_][[:alpnum:]_]` 来表示，即字母或下划线开头，后面还可以
跟着任意字母和数字。

GNU sed 命令一般工作流程要点如下，简化起见，只使用基本的 sed 命令：p (print) 打印：

1. 确定数据输入来源：
    1. 文件：`sed -n 'p' some.data`
    2. stdout 重定向： `cat some.data | sed -n 'p'`
2. 选择要处理的数据行（Address）：`sed -n '1,2p'` 表示处理的数据区间选择在起始两行。
3. 使用 sed 命令处理数据，例如 `sed -n 1,2s/[0-9]/_/g` 替换首两行的数字为下划线。
4. 使用缓冲空间，*patter space* 和 *hold space*。
5. 对处理后的数据进行定置：
    1. 直接写文件：使用 `-i` 命令行参数激活 in-place 工作模式；
    2. 写入文件：使用 `w filename` 命令；
    3. 使用控制台标准文件重定向写入文件或传递给其它命令；

这里使用 Bash Brace Expansion 创建一个函数用来生成带有行编号的数据。
Brace Expansion 花括号扩展功能是一种组合式数据序列生成工具，基本用法如下：

```sh
$ echo a{A..H}box
aAbox aBbox aCbox aDbox aEbox aFbox aGbox aHbox
$ echo a{A..H} box
aA aB aC aD aE aF aG aH box
```

以下定义 bash 脚本函数，生成的数据内容可以通过 stdout 重定向，写入 data.txt 数据文件：

```sh
function generator {
    list=`bash -c "printf '%s ' {2..$1}"`
    echo -n "This is the first line."
    for it in $list
    do echo ""; echo -n "This is line $((it+0))"
    done
}
$ generator 5 > data.txt
$ cat data.txt
# This is the first line.
# This is line 2
# This is line 3
# This is line 4
# This is line 5
```


使用 sed 提供的各种命令来处理这些数据，以下两组织命令输出内容相同，但工作方式不同。
sed 默认输出原始数据，所以第一条命令没使用任何 sed 命令，只是按默认输出了原始数据。
而第二组，则使用了 sed print 命令将输入的内容逐行打印出来：

```sh
generator 5 | sed ""

generator 3 | sed -n p
generator 5 | sed -n "p"
generator 3 | sed -n {p}
```

因为 bash 中的双引号字符串可以进行变量插值，为了避免 sed 命令受到影响，一般使用
单引号包括 sed 命令。当然，简单的命令，不使用引号也可以。当需要使用多个 sed 命令，
就需要使用花括号将它们组合起来（Grouping commands），并且使用分号 ; 作为各个命令的
分隔符号。语法格式参考 `{ CMD ; CMD ... }`。

按照 sed 文档所述，sed 命令基本语法格式如下：

     [addr]X[options]

1. `X` 是一个 sed 命令，使用单个字母表示，如前面用过的 p 表示打印命令；
2. `[addr]` 即行定位 line address，用于限制命令将要处理的内容所在行；
3. `[options]` 是附加选项，用于配置 sed 命令的行为；

先来说内容寻址，Address，它决定了输入数据中，那么行是需要处理的，有以下形式：

1. **Numeric Addresses**
    1. 'NUMBER' 例如 `1p` 表示只打印第一行；
    2. '$' 例如 `$p` 表示只打印整个输入文档的最后一行；
    3. 'FIRST~STEP' 例如 `1~2p` 表示从首行开始，隔行打印；
2. **Regexp Addresses**
    1. '/REGEXP/' 例如 `/^$/p` 表示打印空行，如 `/[0-9]$/p` 打印行尾有数字的行；
    2. '/REGEXP/I' 使用 case-insensitive 模式的正则寻址；
    3. '/REGEXP/M' 使用 multi-line 模式的正则寻址；
    4. '\%REGEXP%' 自定义的正则分隔符，默认是正斜杠 /，这里定义 % 为正则分隔符号；
3. **Range Addresses**
    1. 区间式，结束行号如果小于起始行，那么就只处理起始行；
    2. 'START,END' 例如 `1,3p` 表示打印前三行，又如 `1,$p` 表示从头到尾打印；
    3. 'ADDR1,+N' 从某行开始到 +N 行，例如 `3,+2` 表示第 3 行到第 5 行；
    4. 'ADDR1,~N' 从某行开始到 N 的倍数行结束，包括结束行，例如 `3,2` 表示 3、4 行；
    5. 'N,/REGEXP/' 表示从 N 行后开始直到 REGEXP 匹配的行结束，N 可以是 0；
    6. '/REGEXP/,/REGEXP/' 起始行位置都通过正则表达式匹配。

GNU sed 提供了一个 `!` 功能符号用于反转内容寻址，invert selection，`1,2!p` 表示反转，
不选择 1、2 行。

`$` 也是一个多功能符号，它除了在正则表达式中表示一行的未尾位置，sed 也用它来表示
输入文件的最后一行。上面展示的 `$p` 命令组合意思是选择输入数据的最后一行执行打印。
结合 `!` 反转可以表示不打印最后一行内容，`$!p`，这个命令组合的意思就是不选择最后行。
注意，不是“不打印”的意思，而在选择输入数据时过滤掉了最后一行。

另外，sed 可以选择正则表达式的分隔符，只需要选择好的分隔符紧跟在 `s` 命令后。
例如，使用 `!` 作为正则表达式的分隔符号，`'1,2s!line!LINE!gp'`，将首两行的 line 大写。
这种用法方便在正则表达式中使用 Linux 的文件路径。

通常不不需要自定义的正则分隔符，但是对于处理大量文件路径的数据中，自定义更方便。

指定正则寻址时，与内容替换命令在语法上比较相似，完整表达：`/regexp/flags/s/pat/sub/flags`。
GNU sed 使用的正则表达式分两个部分，命令行中使用 `-E` 或者 `-r` 激活 ERE：

1. Basic Regular Expression (BRE):
2. Extended Regular Expression (ERE)

BRE vs. ERE 两者体现在 GNU sed 中的差别在于特殊字符的使用，BRE 需要在
特殊符号中添加反斜杆，否则特殊符号将当作普通字符处理，这些符号包括：
'?'，'+'，圆括号、花括号 '{}' 和分组选择符号 '|'。这些符号转义是出于兼容 
bash 环境考虑设置的，而 . * 这样的功能符号可以直接在 bash 环境中使用。
注意，方括号表示字符范围（Range）的表达式不需要转义，参考手册:

5.3 Overview of basic regular expression syntax
5.5 Character Classes and Bracket Expressions

例如，过滤 info 文档的一级标题、修改标题内容。一个符合 Texinfo 规范的 info 文档，
它的一级标题后面使用整行连续的 * 符号：

```sh
# * WoMan: (woman).               Browse UN*X Manual Pages "W.O. (without) Man".
$ sed -n '/^[[:digit:]]\+ /,/^\*\+$/{p}' woman.info
$ sed -n '/^[[:digit:]]\+ /,/^\*\+$/{ s/^[[:digit:]]/\/.\0/; p}' woman.info                                                
/.1 Introduction
**************
/.2 Background
************
/.3 Finding and Formatting Man Pages
**********************************
```

但是，如果想要修改文档的内容，而不是过滤其中的一些内容，就需要启用 `sed` 的
分支跳转 (branching) 功能，配合 `x` 命令进行缓冲区内容互换，使用输入数据被延后
一行输出，利用这一行的内容，就可以根据其内容结构来修改前一的内容。如果需要
处理大量的 info 文档，使用 `for` 循环。程序具体逻辑后续和缓冲区一起解析：

```sh
for it in `ls *.info | grep -v '[_]'`; 
do sed -i -n '
    s/^\([\*=]\)\1\+$/\0/;
    t B;
    x ; 1!p ;
    b ;
:B  s/^\(.\)/\1\1\1\1\0/; x ; s/^.*$/# \/. \0/p ;
' $it; 
done

# for it in `ls *.info | grep -v "_"`;  
# do 
#     echo $it; 
#     cp "/mingw64/share/info/$it" ./
# done
# cat "/mingw64/share/info/gnutls.info-*" >> gnutls.info
```

以上脚本修改后的内容输出参考，并且使用 `\1` 引用延长标题后一行的符号串：

    # /. WoMan: Browse Unix Manual Pages “W.O. (without) Man”
    # /. 1 Introduction
    # /. 2 Background
    # /. 3 Finding and Formatting Man Pages

_______________________________________________________________________
| Desired pattern | Basic (BRE) Syntax | Extended (ERE) Syntax |
|-----------------|--------------------|-----------------------|
| literal '+'     | $ echo 'a+b=c' > foo    |   $ echo 'a+b=c' > foo
| (plus sign)     | $ sed -n '/a+b/p' foo   |   $ sed -E -n '/a\+b/p' foo
|                 | a+b=c                   |   a+b=c
|-----------------|--------------------|-----------------------|
| One or more 'a' | $ echo aab > foo        |   $ echo aab > foo
| characters      | $ sed -n '/a\+b/p' foo  |   $ sed -E -n '/a+b/p' foo
| followed by 'b' | aab                     |   aab
| (plus sign as   |                       
| special         |
| meta-character) |

GNU sed 支持的命令多达十数种，具体参考官方文档，这里主要以替换、打印命令作为敲门砖：

1.  `s` String substitute，正则表达式格式 `s/pat/sub/flags`，flags 参数说明如下:
    1. `pat` 正则模式，用于搜索符合指定规则的字符串内容；
    2. `sub` 替换内容，用于替换符合 `pat` 规则的旧字符串内容；
    3. `g` flag - Global, whold line process, not only the first one match.
    4. `i` flag - Insenstive
2. `p` (print) command
3. `P` (print first line) command

替换命令中的 `sub` 可以引用正则分组匹配到的内容，使用 `\N` (N = [0,9]) 引用。
正则分组匹配即使用圆括号内 ( ) 规则匹配到的内容，注意在 GNU sed 需要转义 `\( \)`。

GNU 'sed' 为替换命令提供了扩展功能：字符大小写转换，规如下：

| CMD | Description |
|-----|-------------|
| '\L' | Turn the replacement to lowercase until a '\U' or '\E' is found,
| '\l' | Turn the next character to lowercase,
| '\U' | Turn the replacement to uppercase until a '\L' or '\E' is found,
| '\u' | Turn the next character to uppercase,
| '\E' | Stop case conversion started by '\L' or '\U'.

```sh
echo "abcba" | sed -E -n 's/[ab]/\U\0/gp'
ABcBA
```

除了在命令行中直接输入 sed 命令，对于复杂的命令还可以使用脚本文件输入：

| Option | Description |
|--------|-------------|
| -e script | Adds commands specified in the script to the commands run while processing the input
| -f file | Adds the commands specified in the file to the commands run while processing the input
| -n      | Doesn't produce output for each command, but waits for the print command

以下命令用于演示 sed 流式数据处理，使用 printf 生成 5 行内容用于测试。然后，通过
管道操作符 | 将数据流送到 sed 命令的标准输入文件 stdin。流处理过程包含两条命令，
两条都是用于字符串替换，前一条将数字替换为下划线，后一条将 line 替换为 LINE。最后，
一条命令多了一个 `p` 打印命令，它会将修改后的数据打印出来。当然，这个打印命令
可以单独编写，也可以在其它任意命令前后出现，只需要使用分号隔开，会打印多份内容：

```sh
printf "this is line %s\n" {1..5} | sed -n 's/[0-9]/_/g; s/line/LINE/gp;'
printf "this is line %s\n" {1..5} | sed -n 's/[0-9]/_/g; s/line/LINE/g; p;'
```

GNU sed 可以直接修改文件，但建议使用备份功能，指定 `-i.bak` 打开 in-place 修改功能，
同时启用备份，扩展名指定为 `.bak`：

```sh
$ generator 3 > data.txt;
$ sed -i.bak -n '1s/first/MODIFIED/pg' data.txt;
$ cat data.txt
This is the MODIFIED line.
$ cat data.txt.bak
This is the first line.
This is line 2
This is line 3
```

3.5 Less Frequently-Used Commands

| CMD | Description | Example |
| --- | ----------- | ------- |
| 'a TEXT'     | Appending TEXT after a line.    | '2i world'        |
| 'c TEXT'     | Replaces the line(s) with TEXT. | '2,9c hello'      |
| 'i TEXT'     | insert TEXT before a line.      | '2i hello'        |
| 'r FILENAME' | Reads file FILENAME.            | '2r/etc/hostname' |
| 'w FILENAME' | Write the pattern space to FILENAME. | 's/./SUB/w out.txt' |
| '='   | Print out the current input line number (with a trailing newline).    | sed = data.txt |
| 'l N' | Print the pattern space in an unambiguous form, N is line-wrap length |                |
| 'z'   | Clears pattern space, like 's/.*//'.
| 'y/src/dst/' | Transliterate any characters. | `echo "abcba" | sed -n 'y/abc/123/; p'`

GNU sed 手册中多处出现 `e` 命令，文档中会以 'e'、'e COMMAND' 或者'e [COMMAND]'
以及 'e' (command execution) 等等方式出现，内容有点混乱。这个字母 e 至少被 sed 用在
以下几个方面：

1. 命令行参数：`-E` 激活 ERE 扩展正则表达式引擎；
2. 命令行参数：`-e SCRIPT` 用于添加多条 sed 命令表达式以处理输入数据；
3. Executes 命令，执行 shell 命令，并将命令输出内容打印到 stdout，有两种形式：
    1. 将输入数据作为 shell 命令，例如 `echo "ls ." | sed -n -e 'e' -e 'p'`
    2. 直接执行 shell 命令，例如 `echo -e '1\n2\n3' | sed -n '1,2e echo Hello'`
    3. 用在替换命令后面，'s///e'，将替换后的内容作为 shell 命令执行，
        应该使用换行符号，避免命令包含无效字符，参考 3.8.1 Commands Requiring a newline。

在同一个 sed 进程中，通过 `-e SCRIPT` 添加的多个命令组合处理的数据始终是同一份。
例如，无法在同一个 sed 进程中对数据进行逐层的过滤 (Addresses)，假设第一层过滤偶数行，
第二层再过滤出其它行。这种过滤可以通过管道符号将第一层过滤出来的数据流送到下一个
sed 进程中进行二次处理。

使用多个 `sed` 进程将这些 `sed` 命令组合串联起来，最大化地利用正则表达式的功能。

```sh
printf "this is line %s\n" {1..5} | sed -n '/[135]/{p};' | sed -n '/[5]/{p};'
```

但是，如果可以，应该尽量使用同一个 sed 进程，利用 Address 中设置的起止正则表达式
来定位内容的大概范围。然后，再利用替换命令本身所具有的数据过滤功能获取最终数据。

举例来说，Sphinx 文档处理工具使用的 reStructuredTest 格式中，自定义了一个 toctree 指令，
它用来在 rst 文档中定义嵌套文档，获取这个文档的嵌套结构就是文档目录的生成过程。

Node.js 使用的 libuv 异步事件驱动 I/O 构架就是使用  reStructuredText 文档格式，其
文档目录文件包含类似以下的 toctree 数据，其中 api.rst 文档使用了 reST 超链接语法，
定义了标题为“libuv API”，对应的文档文件是 apirst，省略了扩展名：
http://www.pythondoc.com/sphinx/markup/toctree.html

```sh
Documentation
-------------

.. toctree::
   :maxdepth: 1

   design
   libuv API <api>
   guide
   upgrading


Downloads
---------

libuv can be downloaded from `here <https://dist.libuv.org/dist/>`_.
```

要获取这个目录列表，可以先使用 Address 正则表达式框定内容，应该从 `.. toctree::` 
指令所在行开始，直到行缩进恢复无缩进状态时结束。这里也就是 Downloads 行前结束。
但是 sed 的数据处理需要包含两起止两站的行内容，这些是无效的数据，包括 `:maxdepth:` 
属性标签，然后需要使用替换命令中的正则表达式，将符合要求的行内容过滤出来：

```sh
$ rst=../deps/uv/docs/src/index.rst
$ sed -n '/\.\. toctree\:\:/,/^\w/s/^ \+\w\+/\0/p'`  $rst
   design
   api
   guide
   upgrading
```

以下演示读取 rst 文件中的目录数据，用于合并 libuv 1.x 异步事件驱动构架的文档：

```sh
    #! /usr/bin/env bash
    
    print_title () {
        printf '\n%.0s' {1..2};
        printf '=%.0s' {1..51};
        printf "\n/. $1\n"
        printf '=%.0s' {1..51};
        printf '\n%.0s' {1..2};
    }
    
    print_title "/RST docs combine script"
    cat << EOF
    文档合并脚本中使用了 sed 流式文档处理工具，使用教程参考： 
    
    1. [Sed in 5 Minutes](https://github.com/Jeangowhy/opendocs/blob/main/sed.info) "
    2. [AWK in 5 Minutes](https://github.com/Jeangowhy/opendocs/blob/main/sed.info)"
    3. [libuv 1.x docs](https://github.com/Jeangowhy/opendocs/blob/main/libuv_1.x_docs.rst)"
    
    EOF
    echo '.. code-block:: bash'
    echo ''
    cat $0 | sed -n 's/^/    /p'
    
    function filter {
        local parent=`echo $1 | sed -n 's/[^/\]\+$//p'`
        for it in `sed -n "/^.. toctree/,/^\w/{ s/^ \+\w/\0/p }" $1`
        do
            rst="$parent$it.rst"
            echo $rst
            filter $rst
        done
    }
    
    while read -r line
    do 
        print_title "$line"
        cat $line
    done << EOF
    `
    echo ../README.md
    filter ../docs/src/index.rst
    `
    EOF
    
    while read -r line
    do 
        print_title "$line"
        echo '.. code-block:: cpp'
        echo ''
        cat $line | sed 's/.*/    \0/p'
    done << EOF
    `
    echo ../docs/code/CMakeLists.txt
    find ../docs/code/ | grep -E "\.(h|c)$"
    `
    EOF
```


可以给 `sed` 输入多个文件，并且每个文件共用的是同一套处理逻辑。

```sh
printf "Line %s\n" {1..5} | sed -n -e '1,2p' -e '$p'
Line 1
Line 2
Line 5
sed -n -e '1,2p' -e '$p' data1.txt data2.txt ...
```

GNU sed 提供了基于标签的流程跳转功能，定义命令块时可以设置标签。然后，
使用以下命令跳转到标签位置执行命令，命令语法格式参考：` [address]b [label]`：
 
| CMD | Description | Example |
| --- | ----------- | ------- |
| ': LABEL'  | Specify the location of LABEL for branch commands ('b', 't', 'T').
| 'b LABEL'  | Branch unconditionally to LABEL.  
| 't LABEL'  | (test) Branch to LABEL only if there has been a successful 's'.
| 'T LABEL'  | (test) Branch to LABEL only if there have been no successful 's'.

其中 `b` 是无条件标签跳转，另外两个是测试条件跳转，对最后一个输入行执行
`s` 替换命令，其成功执行状态决定是否执行相应分支跳转到 LABEL。初始的状态下，
`T` 命令会跳转。

如果命令中省略 LABEL，这种情况下表示结束本轮命令处理，相当于 break 功能。

```sh
$ generator 5 | sed -n '{:A 1~2b B; 2~2b C :B s/[0-9]/ODD/p; :C s/[0-9]/EVEN/p }'
This is line EVEN
This is line ODD
This is line EVEN
This is line ODD
$ generator 5 | sed -n '{:A /1~2T B; 2~2t C :B s/[0-9]/ODD/p; :C s/[0-9]/EVEN/p }'
This is line ODD
This is line ODD
This is line ODD
This is line ODD
$ generator 1 | sed -n '{:A s/NEVER/LINE/; T C; b ; :C s/[0-9]/CHANGED/p }'
This is line CHANGED
$ generator 1 | sed -n '{:A s/line/LINE/; t C; b ; :C s/[0-9]/CHANGED/p }'
This is LINE CHANGED
```

GNU sed 使用两个缓存区保存数据 data buffers：

1. _pattern_ space 是当前活动的缓冲区；
2. _hold_ space 辅助保持缓存区；

两个缓冲区的内容使用以下命令进行切换和处理：

| CMD | Description |
| --- | ----------- |
| 'D' | _deletes_ line from the *pattern space* until the first newline, and restarts the cycle.
| 'G' | _appends_ line from the *hold space* to the *pattern space*, with a newline before it.
| 'H' | _appends_ line from the *pattern space* to the *hold space*, with a newline before it.
| 'N' | _appends_ line from the input file to the *pattern space*.
| 'P' | _prints_ line from the *pattern space* until the first newline.
| `x` | Exchange *hold space* with *pattern space*.

以上大写母命令使用，还有对应的小写字母版本，差别：后者处理的内容包括行尾换行符。
缓冲区初始状态为空，输入数据后，*pattern space* 就会包含当前处理的数据。注意：`P`
命令和 `p` 命令，大写版本只打印第一行，即使 *pattern space* 缓冲区可能存在多行内容。

以下命令可以演示，大小写版本的功能差异：

➊ 小写版本没有前导换行符号，当使用 `g` 命令时，第一轮中它总是一个空行，并且
没有往里面存数据，所以这些 `g` 使用空行替换掉刚输入的数据。导致最后看不到文字。

➋ 大写版本带有前导换行符号，虽然 *hold space* 初始时依然没有数据，但是 `G` 命令
获取到的 Newline 会写入 *pattern sapcee* 的第二行，而原始内容保留下来了，这是 sed 的
缓冲区数据读写逻辑：前导换行符号将导致数据写入缓存区后续的空闲位置。

所以，小写字字母版本的缓冲区命令具有完全的覆盖目标缓冲区特性。大写字母版本，
因为自带了一个前导换行，它会保留目标缓冲区的当前行。

```sh
printf "Line %s\n" {1..1} | sed -e 'g;g;g' # ➊
# -
printf "Line %s\n" {1..1} | sed -e 'G;G;G' # ➋
# Line 1
# -
# -
# -
```

以下命令用来演示两个缓冲空间的使用：

```sh
generator 3 | sed -n "p; p"
# This is the first line.
# This is the first line.
# This is line 2
# This is line 2
# This is line 3
# This is line 3
generator 3 | sed -n "x; p; x; p;"
# 
# This is the first line.
# 
# This is line 2
# 
# This is line 3
```

第一条命令为了提供参，这里使用使用两个 `p` 命令打印处理过的数据，也就是
同一行输入数据，会产生两条同样的输出。注意 `-n` 禁用默认的输出，默认会
输出原始数据。

第二条命令使用了 `x` 交换 pattern space 的数据 hold space，运行状态如下表。
这是其中第一行数据的处理流程，使用 - 表示没有数据，空行输出使用 _E_ 表示：

| CMD | pattern space | hold space | Output |
| --- | ------------- | ---------- | ------ |
| INIT | This is the first line. | -                      | -                      |
| x    | -                      | This is the first line. | -                      |
| p    | -                      | This is the first line. | _E_                    |
| x    | This is the first line. | -                      | -                      |
| p    | This is the first line. | -                      | This is the first line. |

也就是每行输入数据对应输出两行内容，分别来自 *hold spaces* 和 *pattern space*。

注意，缓冲区可以存放多行内容，具体取决于使用命令的处理方式。每一轮数据处理，
*pattern space* 内容将被新读取的数据替换，除非使用 `H` 或者 `x` 这样的命令将数据
转移到 *hold space*，或交换它们的数据。使用 `G` 命令可以再将数据拷贝回来。

注意，`H` 和 `G` 并不会清除数据源，可以在同一轮数据处理中多次执行获取数据。
但是，它们会覆盖掉目标缓冲区，分别覆盖 *hold space* 和 *patter space*。因为，
每一轮数据处理，*patter space* 的内容都会被替换成新的数据，要相保留这此旧数据，
就必需使用 *hold space* 缓冲区，这也就是这个暂存区的存在意义。

`N` 表示 Next，预取下一行输入加入处理。G 表示 Get，从 *hold space* 获取暂存内存到
*patter space* 中进行处理。如果使用此命令连续读取数据超出 EOF，那么这部分数据将会
被丢弃。使用以下命令验证，数据源有 7 行，而 sed 每一轮将处理 4 行（1 + 3N）：

```sh
printf "Line %s\n" {1..7} | sed -n 'N ; N ; N ; p'
Line 1
Line 2
Line 3
Line 4
```

`N` 命令还有一个隐含的特性，因为数据是流式处理的，读取后就相当消费掉了。所以，
使用一条 `N` 命令，就意味着，第 1、2 行放到 *pattern space* 处理，后续的 3、4 行
又放到一起处理，依些逻辑执行，相当于是处理一个带有两行内容的数据结构。通过
使用 *hold space* 暂存内容，可以让这些成组处理的数据有一个“上下连接”的关系。
然后配合 `b` `t` `T` 这些跳转命令就可以处理一些结构化的数据。

这两个缓冲区属性 FIFO (Fist-in Fist-out) 数据结构，前面先存入的数据先输出（被获取）。

使用文档处理的实例来演示 `sed` 脚本跳转与暂存缓冲区的应用。这里选择 GNU m4 
宏编程工具的文档，TextInfo 是 GNU 官方文档格式，原始文档是 .texi，默认发布格式
是 .info，它们都是文本文件，使用 `info` 命令就可以看看当前系统软件安装好的文档。

文档安装目录默认在 /usr/share/info，并且是 gzip 压缩包的形式发布的，压缩包只有
一个 info 文档，可以直接将内容输出到控制台 stdout。文档通常分成个包，使用数字
后缀命名。

例如 m4 宏编程工具有三个 info 文档包，其中无数字后缀的这个包含 Tag Table，后缀
数字最大的这个通常包含 Index 数据，其它的是主文档。文档中，使用了连续的符号
来表示一个标题，标题内容就是上一行的文本。通常使用连续的 `*` `=` `-` `.`
这些符号。为了便于说明，以下将 sed 脚本中的命令拆分成行独立的行展示：

```sh
$ ls -lth /usr/share/info/m4*
-rw-r--r-- 1 OCEAN None  88K Dec 29  2021 /usr/share/info/m4.info-1.gz
-rw-r--r-- 1 OCEAN None  13K Dec 29  2021 /usr/share/info/m4.info-2.gz
-rw-r--r-- 1 OCEAN None 1.7K Dec 29  2021 /usr/share/info/m4.info.gz

$ gzip -d -c `find /usr/share/info/m4* | sed -n '1p'` | sed -n '
    N ;        # ➊
    s/^\(\S\)\1\{3,\}\n.*/>>>/M;    # ➋
    t B;       # ➌
    s/\(.*\)\n\(\S\)\2\{3,\}/\1/p; # ➍
    s/.*\n//;  # ➎
    h ;        # ➏
    b ;        # ➐
:B  g ; p ;    # ➑
'
# GNU M4
# 1 Introduction and preliminaries
# 1.1 Introduction to ‘m4’
# 1.2 Historical references
# 1.3 Problems and bugs
# 1.4 Using this manual
# 2 Invoking ‘m4’
# 2.1 Command line options for operation modes
# .....
# 2.6 Specifying input files on the command line
# 3 Lexical and syntactic conventions
# 3.1 Macro names
# 3.2 Quoting input to ‘m4’
# 3.3 Comments in ‘m4’ input
# 3.4 Other kinds of input tokens
# 3.5 How ‘m4’ copies input to output
# .....
```

首先，将文档文件解压出来，这一步先通过 `find` 命令找出文档的路径，然后经过
一轮 `sed -n '1p'` 筛选出  m4.info-1.gz 这个主文档。`gzip -d -c` 命令会将指定
的压缩包解压，并将内容写入控制台 stdout 标准文件。最后再通过第二个 `|` 管道
操作将数据流送给第二个 `sed` 命令处理，这里就是核心功能：

➊ 执行 `N` 命令，将下一行数据（对于首轮处理就是读取第二行）加入处理。这样，
当前的处理数据中就包含了两行内容，中间包含一个 `\n` 换行符。

➋ 这是一条查找重复符号的正则表达式，只要求符号至少重复 3 次，但持续到换行。
如果在现有内容中第一行中找到一整行的连续符号，那么就表示上一行内容（暂存区中）
就是标题内容。接下来进行条件测试，并根据条件进行分支处理。

➌ 这里就使用 `t` （成功匹配时）进行条件触发跳转，执行 ➑ 行脚。

➍ 如果 ➋ 匹配不成功，那么 `t` 命令就不会跳转（匹配失败），➍ ➎ 就会被执行。
这里再尝试匹配第二行是不是连续的符号，如果是，那么就表示当前内容的第一行就是
标题内容，可以替换掉第二行内容后直接使用 `p` 命令输出。如果不是，也不要紧，
数据将交给 ➎ 处理。

➎ 到这一步就需要将当前内容中的第二行数据保存到暂存缓冲区，因为它可能就是
标题内容，这需要在下一轮数据处理中得到确切答案。因此，使用 `s` 命令替换掉
第一行的数据再送暂存区。这里有一个逻辑上的不完善，但它可以完成任务，
就是 ➍ 可能已经找到标题了，那么第二行就不会是标题了，也就不需要再暂存了。

➏ 使用 `h` 命令将工作区数据暂存起来。

➐ 这一行只有一个 `b` branching 命令，但是没有目标标签，当作 break 使用。

➑ 使用 `G` 获取暂存区数据并打印出来。暂存区内容来自 ➏ 行的 `h` 命令。


还可以配合 'a TEXT' 'c TEXT' 'i TEXT' 等命令对缓冲区数据进行操作。这几个命令
有些个性，所有跟在后的内容都将作为字符串处理，包括引号。所以不要在这些命令中
使用引号来包括字符串，除非引号本身作为字符使用。解决方法是用换行来分隔命令、
或者使用 `-e` 参数拼接其它命令。

```sh
$ printf "Line %s\n" {1..2} | sed 'aApple ; 2d' 
Line 1
Apple ; 2d
Apple ; 2d

$ printf "Line %s\n" {1..2} | sed -e aBox  -e '2d'
Line 1
Box
Box

$ printf "Line %s\n" {1..2} | sed 'aCan
    2d'
Line 1
Can ; 
Can ; 
```

使用以下命令验证 sed 的缓冲区操作逻辑：

```sh
printf "Line %s\n" {1..1} | sed -n 'h ; h ; G ; G; p' 
Line 1
Line 1
Line 1
```

利用两个缓冲区的操作，就可以实现将输入内内按行倒序处理。处理逻辑是：

1. sed 读取首行数据到 *pattern space*；
2. 将当前行从 *pattern space* 转存到 *hold space*，暂时保存起来；
3. sed 读取后续的一行数据；
4. 现在将 *hold space* 暂存的数据恢复到 *pattern space*，并且紧跟新数据后面；
5. 然后再将目前已经处理好的数据转存到 *hold space*；
6. 重复执行 3 ~ 5 步，直到所有输入数据处理完毕，逆序处理就完成了；
7. 最后，获取所有处理好的数据，并打印出来。

这个过程只需要使用 `G` 和 `h` 命令转存数据，命令参考如下。有点巧妙的是 `1!G`
和 `$p` 这两组命令的使用，它们分别表示首行不执行 `G`，末行执行 `p`。对于有
5 行的数据，末行就是第 5 行，对于剩下的数据，最后一次过打印输出。这里使用 `h`
而不是 `H`，


```sh
printf "Line %s\n" {1..5} | sed -n -e '1!G; h ; $p' -e 'esleep 1'
Line 5
Line 4
Line 3
Line 2
Line 1
```



_______________________________________________________________________
AWK in 5 Minutes
---------------------------------------------------
1. https://www.gnu.org/software/sed/manual/
2. https://www.gnu.org/software/gawk/manual/

AWK 取名自作者的姓氏，Alfred V. Aho, Brian W.
Kernighan, and Peter J. Weinberger's ‘The AWK Programming Language’
(Addison-Wesley, 1988)

GNU sed 作为一款流式数据编辑器，可以利用正则表达式实现强大的替换处理，但是它的
缺点在于没有结构化的数据。尽管 sed 提供了 6.4 Branching and Flow Control 高级的流程
控制功能，但是基于标签跳转会使脚本编写变得异常复杂。

而 gawk 则是作为一个补充可编程工具，可以实现：

1. Define variables to store data.
2. Use arithmetic and string operators to operate on data.
3. Use structured programming concepts, such as `if`, `while`, `for`, `do`, `switch` ...
4. Generate formatted reports by extracting data elements, reorder or reformat.

由此可见，AWK 既是一个 Linux 内置工具，同时它又是一门数据处理脚本语言。
AWK 同样支持正则表达式，功能完全覆盖 sed 支持的功能，拥有通用编程语言能力。
因此，应该将 `gawk` 工具当作一门计算机编程语言工程来学习，而不是像 `sed` 一样。

AWK 默认使用标准文件 stdout，如果没有指定磁盘文件就会等待用户输入数据。
可以使用 BEGIN 来启动脚本的执行，而不是等等数据。使用 `getline` 方法
也可以从 stdin 中读取用户输入的数据：

```sh
$  gawk ' { print } '
⇥hello
hello

$  gawk 'BEGIN { print getline } '
⇥hello
hello
1

$  gawk ' { print } ' data.txt
This is the FIRST line.

$ echo {1..9} | gawk 'BEGIN { print "hello" } '
hello
```

AWK 命令格式，命令行中指定要运行的 awk 脚本，注意变量设置和特殊的脚本名称处理：

```sh
awk [options] 'script' var=value file(s) 
awk [options] -f scriptfile var=value file(s) 

# ‘count=1’ is a variable assignment, not a file name:
awk -f program.awk file1 count=1 file2

#‘./count=1’is a file, not varialbe assignment.
awk -f program.awk file1 ./count=1 file2
```

2.2 Command-Line Options 常用命令选项

1. `-F FS` 设置 `FS` 内置变量更改数据的字段分隔符（Field Separators），
    可以是字符串、正则表达式，比如 `-F:` 或者 `-F " "` 分别表示冒号、空格作为字段分隔符；
2. `-v var=value` 赋值一个用户定义变量，将外部变量传递给 AWK；
3. `-e sourceText` 命令行中编写 awk 脚本，使用示范：`awk -e '{print}'`；
4. `-f scriptfile` 运行指定 AWK 脚本，使用示范：`awk -f ./toc.awk -e '{print}'`；
5. `-E FILE` 运行指定 AWK 脚本，但禁止 `VAR=VALUE` 方式设置变量，并且将此参数指定的脚本内容传递给 awk 脚本程序处理；

例如，可以按如下编写 awk 脚本，使用注解头部，bash 会自动加载解析器：

```sh
#! /usr/local/bin/gawk -E
#! /usr/bin/gawk -E
#! /usr/bin/bin/gawk -Esome.awk
#! /usr/bin/bin/gawk -fsome.awk
```

AWK 输入数据每一行都看作是一个记录，并且按 FS 分割成多个字段，使用 `$n` 等
变量引用 n 数值序号对应的字段。使用 `printf` 函数进行格式化输出，就像 C 语言一样：

```sh
gawk -F: '{ printf "Field 1: [%s] Field 2: [%s]\n", $1, $2 }' /etc/passwd
gawk -F " " '{print $1}' /etc/hosts
awk '{ sum += $1 }; END { print sum }' file 
```

`gawk` 与 `sed` 的差别不不仅体现在编程能力上，数据处理的思维也完全不一样。
`sed` 是流式数据处理思维，`gawk` 是结构化数据处理思维，它输入的数据会转换
为一个数据结构，默认状态下使用空白符号作为一个数据的字段分隔（Field separator），
因此每一行会自动分割成多个字段（Fields），使用自动变量访问，`$n`，n 为自然数，
对应字段的编号，`$0` 表示整个数据结构（整行）。脚本中可以使用变量来访问字段，
如果变量未定义，其值为 0。所以，像 `$notavar` 这样的就可以访问到整个数据结构。

通过给这相应字段对应的变量赋值，`$0` 变量也会有反映，因为这个变量值就是
其它变量中的字符串连接得到的结果。注意，字符串连接直接将各个变量写在一起，
但是使用空格分隔。字符串连接没有专用运算符号，`gawk` 只使用 + 号来计算数值。

另外，字段可能包含多个 FS 符号，例如默认的空格，读取源数据时，只会利用其中一个，
保留余下的。通过对字段重新赋值可以移除这些多余的 FS 符号，如 `$1 = $1`。输出
内容的连接符号定义在 `OFS` 自动变量（Output Separators），默认和 FS 相同。

另外，`gawk` 正则表达式编写也和 `sed` 不同，不需要对 { } + ? | 等功能符号转义。

```sh
$ seq 3 | awk '/^[[:digit:]]+$/ { print }'
```

字段分隔符也可以是换行符，那么一行就为一个字段，配合 Record separator 将多行分割
成对应的数据结构，Multiple-Line Records。

注意：使用 `split` 函数分割读入的文件数据时，分割符 `" "` 和 `/ /` 表现有些差异，
虽然字面上它们都是指一个空格。字符串方式下它只以空格分割数据。但是正则方式下，
`/ /` 隐含了 `\n` 换行符号也是分割符号，所以它代表是空白符号，而不仅仅是空格。

`gawk` 中正则表达式可以用于相关函数，如 `sub` 或者 `match`，也可以用于匹配表达式，
matching expressions，即使用  `~` 和 `!~` 两个运算符，将字符串与正则表达式进行匹配，
并生产布尔值的一种脚本表达式，它可用于任何需要布尔值的语句中，例如流程控制语句，
 `if`, `while`, `for`, `do` 等等。

```sh
$ echo Apple | awk '$1 ~ /a/'
$ echo Apple | awk '$1 ~ /p/'
Apple
```

`gawk` 提供了扩展机制，可以使用 C/C++ 编写动态链接库扩展功能，其本身也自带了
一系列扩展，其中一个就是 `readfile`，用于读取磁盘中的数据文件。另外，`gawk` 和
`sed` 一样支持直接编辑文件（in-place），这个功能也是通过扩展模块的形式提供的，
使用 `@namespace "inplace"` 加载此功能。使用控制台 stdout 文件重定向就可以写文件。

扩展开发参考官方文档 17.4 API Description，`gawkapi.h`。

第三方扩展项目 `gawkextlib` 提供多种数据文档处理，包括 JSON 等格式。
https://sourceforge.net/projects/gawkextlib/

使用 `readfile` 扩展读取的文件将作为一个数据结构处理。注意 `print` 表达式不是函数，
它们不一样，调用函数需要使用圆括号。

命令行中传入多个文件进行处理时，使用 `nextfile` 可以跳过文件数据的处理过程，
直接处理下一个文件。对于通过命令行重定向输入的数据，filename=="-"。另外，
`close` 函数只是关闭文件，并不会导致数据的处理被省略。

```sh
#! /usr/bin/gawk -Etoc.awk

@load "readfile"

BEGIN {
    contents = readfile("data5.txt");
    if (contents == "" && ERRNO != "") {
        print("problem reading file", ERRNO) > "/dev/stderr"
    } else {
        N = split(contents, res, " ")
        print "record fields count:", N
        for ( it in res ) {
            print it, "->", res[it]
        }
    }
}

{
    print "data from cli: ", $n
}

BEGINFILE {
    print "Begin file:", FILENAME
    close (FILENAME)
    nextfile # skip current file
}
ENDFILE {
    print "End file:" FILENAME
}
```

使用斜杠编写的正则表达式属于常量，通过 `~` 或者 `!~` 运算符，分别用于匹配、
不匹配比较，`gawk` 支持了 Dynamic Regexps，一种动态表达式，即使用表达式来生成
正则规则。感叹号表示取反，例如 `EXP !~ /REGEXP/`，当 EXP 与 REGEXP 
正则规则不匹配时返回 True。注意，正则表达式一定写在右侧。

如文档所展示，`digits_regexp` 变量定义了一个常量正则规则，匹配一组数字。注意，
这个变量中所使用的是字符串，而不是正则常量。通过改变这个变量的字符串，
就可以改变 Action 中的脚本是否该执行。这个动态规则不是一定要在 `BEGIN` 中设置：

```sh
     BEGIN { digits_regexp = "[[:digit:]]+" }
     $0 ~ digits_regexp    { print }
```

以下脚本展示了 `gawk` 编程思维。使用 `seq` 生成一系列行数据，每行含一个数值。
使用 `print` 语句打印变量 `i` 和对应的 `$i` 字段值。`while` 循环控制语句会在
每一行数据，准确点说，是一个数据结构输入，就会循环三次，即以下脚本逻辑
用于打印输入数据结构的前三个字段：

```sh
# printf "Line %s\n" {1..3} 
seq 3 | awk -F" " '
     {
         i = 1
         while (i <= 3) {
             print i, "->", $i
             i++
         }
     }'
# 1 -> 1
# 2 -> 
# 3 -> 
# 1 -> 2
# 2 -> 
# 3 -> 
# 1 -> 3
# 2 -> 
# 3 -> 
```

要使用 `gawk` 替换 `sed` 来完成任务，基本上只需要掌握两个函数即可，`sub` 和 `match`
两个函数除了指定正则，默认输入的字符串是 `$0` 变量的值，即当前处理的数据结构，
也可以指定其它值。字符串替换函数有三个版本：

1. `sub` 基本的正则匹配、替换函数，使用 `&` 引用整个匹配串；
2. `gsub` Global Substitution 版本，对输入字符串中多个匹配进行处理；
3. `gensub` General 版本正则匹配、替换函数，可以使用 `\N` (N=[1,9]) 引用匹配串。
    HOW 参数可以指定 `g` or `G` 开头的字符串，表示启用 "global" 选项，
    或者一个数值表示要执行替换匹配分组序号。

注意：`gensub` 通用替换函数直接返回替换后的字符串。另外，要考虑脚本的字符转义，
脚本中编写 "\\1" 才表示引用第一个正则分组匹配到的内容。`&` 转义表达是 `\\&`。

```sh
# sub(REGEXP, REPLACEMENT` [`, TARGET`]`)
# gsub(REGEXP, REPLACEMENT` [`, TARGET`]`)
# gensub(REGEXP, REPLACEMENT, HOW` [`, TARGET`]`) #
# match(STRING, REGEXP` [`, ARRAY`]`)

      str = "water, water, everywhere"
      sub(/at/, "ith", str)

      {
          if ($1 == "FIND")
              regex = $2
          else {
              where = match($0, regex)
              if (where != 0)
                  print "Match of", regex, "found at", where, "in", $0
             }
      }
```

使用以下实例演示这些函数的使用，[Advanced Linux Programming] 电子书的目录数据处理，
为了给 Markdown 添加链接，文档中有一个 TOC 总目录，每一页也都有页码引用标签。
它们的连接结构如下：

[Advanced Linux Programming]: https://github.com/Jeangowhy/opendocs/blob/main/adv_Linux_prog.md

1. TOC 总目录条目链接格式 `[℗](#p315){id=t315}`，其中 id 属性表示标签本身地址；
2. 页码链接标签链接格式 `[℗](#t315){id=p315}`，其中 id 属性指示了页码地址；

点击页码标签跳转到 TOC 相应的位置，点击目标条目就跳转到相应的页码地址。但是，
总目录条目不可能对应每一个页码，需要将各个页面标签中的跳转地址映射到 TOC 条目。
现有数据如下，单个数值的行对应 TOC 目录存在的地址：

```sh
315
315
315 [℗ 315](#t315){id=p_315}
316 [℗ 316](#t316){id=p_316}
317
317 [℗ 317](#t317){id=p_317}
318 [℗ 318](#t318){id=p_318}
319 [℗ 319](#t319){id=p_319}
320 [℗ 320](#t320){id=p_320}
321 [℗ 321](#t321){id=p_321}
```

处理逻辑是：读取数据，判断是否是一个 TOC 标签地址，如果是就暂存到 `toc` 变量中。
如果读取到的是页码标签，寻么就用当前的 `toc` 地址替换它的链接地址，awk 脚本如下：

```sh
/.*/ {
    if ($0 ~ /^[[:digit:]]+$/) {
        toc = $0
    } else {
        $0 = gensub(/(\<t)([[:digit:]]+)/, "\\1" toc, "g")
        # sub(/(#[^[:digit:]]+)[[:digit:]]+/, "#t" toc)
        print $0
    }
}
```

经过处理后的数据如下：

```sh
315 [℗ 315](#t315){id=p_315}
316 [℗ 316](#t315){id=p_316}
317 [℗ 317](#t317){id=p_317}
318 [℗ 318](#t317){id=p_318}
319 [℗ 319](#t317){id=p_319}
320 [℗ 320](#t317){id=p_320}
321 [℗ 321](#t317){id=p_321}
```

AWK 脚本程序的一般形式如下，它使用正则模式 PATTERN 匹配的规则来管理
一组动作（Actions），也就是 AWK 脚本编程，脚本使用花括号包括。正则模式
可以省略（Empty Pattern），相当于使用 `.*`，每个输入数据（行）都适用。

```sh
     [PATTERN]  `{ ACTION }`
      PATTERN  [`{ ACTION }`]
     ...
     `function NAME(ARGS) { ... }`
     ...

     /foo/  { }     match foo, do nothing --- empty action
     /foo/          match foo, print the record --- omitted action

awk 'BEGIN{ commands } /pattern/{ commands } END{ commands }'
```

AWK 脚本程序基本结构由多种规则模板组成，每个规则使用正式表达式进行匹配、执行。
其中最主要的特殊规则是 `BEGIN` 和 `END`，它们对应 AWK 开始执行（读取标准输入之前），
和结束执行。所有规则可以任意顺序、任意数量使用，但是 `BEGIN` 和 `END` 规则只在
启动时执行一次。其它规则则会根据输入数据的数据，重复地执行，特殊规则说明如下：

```sh
awk 'END { print "end" } /(hello|world)/{ print toupper($0) } { print } BEGIN { print "begin" }'
⇥begin
hello
HELLO
hello
⇥world
WORLD
world
end
⇥ `Ctrl-d`
```

Special patterns

1. The `BEGIN` rule executes before reading any input.
2. The `BEGINFILE` rule executes when each new file is processed.
2. The body rules executes repeatly to process data records input.
3. The `ENDFILE` rule executes after each file has been processed.
4. The `END` rule takes care of producing the correct exit status.

```sh
# AWK script file: showargs.awk
     BEGIN {
         printf "A=%d, B=%d\n", A, B
         for (i = 0; i < ARGC; i++)
             printf "\tARGV[%d] = %s\n", i, ARGV[i]
     }
     BEGINFILE {
         fcount = 0
         if (ERRNO && no_errors)
             nextfile
     }
     END   { printf "A=%d, B=%d\n", A, B }

# Running it produces the following:

     $ awk -v A=1 -f showargs.awk B=2 /dev/null
     ⊣ A=1, B=0
     ⊣        ARGV[0] = awk
     ⊣        ARGV[1] = B=2
     ⊣        ARGV[2] = /dev/null
     ⊣ A=1, B=2
```

以下符号或逻辑运算符后面的换行符号，会被 `gawk` 忽略，使用它们可以编写那些
需要多行脚本才能完成的功能：

     ,    {    ?    :    ||    &&    do    else

使用 Record Ranges 过滤指定区间的数据，正则模式语法 `/RE_START/,/RE_END/`：

```sh
# 7.1.3 Specifying Record Ranges with Patterns
awk '$1 == "on", $1 == "off"' myfile
```

用户函数定义类似 bash 中的函数定义，除了数组外，所以参数传值方式传递，即数组
才能受到用户函数的修改影响。使用 `@` 符号可以间接调用函数，将函数名（字符串）
紧跟 @ 符号，再跟圆括号：

```sh
function triple(it)
{
    return it it it
}

/7[[:digit:]]+/ || /9\w+/ {
    myfun="triple"
    print "triple direct:", triple("di")
    print "triple indirect:", @myfun("it")
}
```

AWK 正则规则符号参考如下，匹配测试表达式语法是 `EXP ~ /REGEXP/`。

3.2 Escape Sequences

| Escape | Description |
|--------|-------------|
| `\\` | Escape one backslash in the string or regexp.
|`\a` | The "alert" character, `Ctrl-g`, ASCII code 7 (BEL). 
|`\b` | Backspace, `Ctrl-h`, ASCII code 8 (BS).
|`\f` | Formfeed, `Ctrl-l`, ASCII code 12 (FF).
|`\n` | Newline, `Ctrl-j`, ASCII code 10 (LF).
|`\r` | Carriage return, `Ctrl-m`, ASCII code 13 (CR).
|`\t` | Horizontal TAB, `Ctrl-i`, ASCII code 9 (HT).
|`\v` | Vertical TAB, `Ctrl-k`, ASCII code 11 (VT).
|`\NNN` | The octal value NNN, where NNN stands for 1 to 3 digits between `0` and `7`. 
|`\xHH...` | The hexadecimal value HH. (The `\x` escape sequence is not allowed in POSIX awk.)
|`\uHH...` | The hexadecimal value HH. (The `\u` escape sequence is not allowed in POSIX awk.)
|`\/` | A literal slash (should be used for regexp constants only). 
| `\"` | A literal double quote (should be used for string constants only). 

正则中使用 `$` 和 `\n` 表示含义并不完全一至，`$` 表示行尾，这个位置总是存在的，
不管所在行有没有字符。但是 `\n` 却不一定存在，对于没有换行的内容，就不存在这
个换行、结束符号，所以它可以导致正则表达式匹配不到内容。

类似的 `"line1\nLINE 2" ~ /^L/`，或者 `"line1\nLINE 2" ~ /1$/`，都不为 true。
严格来说，`^` 和 `$` 符号匹配的是字符串的开头、结尾，字符串可能中间包含换行，
所以这种情况就匹配不了。`.` 符号可以匹配字符串内的换行符，不同于 POSIX mode。

3.3 Regular Expression Operators

| Operators | Description |
|-----------|-------------|
| `\` | This suppresses the special meaning of a character when matching.
| `^` | This matches the beginning of a string.
| `$` | This is similar to `^`, but it matches only at the end of a string.
| `.` | (period) This matches any single character, _including_ the newline character.
| `[`...`]` | Bracket expression.
| `[^`...`]` | Complemented bracket expression.
| `|`      | This is the “alternation operator” and it is used to specify alternatives.
| `(`...`)` | Parentheses are used for grouping in regular expressions, as in arithmetic.
| `*`      | the preceding regular expression should be repeated as many times as necessary.
| `+` | Similar to `*`, except that the preceding expression must be matched at least once.  
| `?` | Similar to `*`, except that the preceding expression can be matched either once or not at all.
| `{`N`}` | Interval expression: the preceding expression must be repeated N time.
| `{`N`,}` | Interval expression: the preceding expression must be repeated at least N time.
| `{`N`,`M`}` | Interval expression: the preceding expression can be repeated N to M time.

3.7 `gawk`-Specific Regexp Operators

| Operators | Description |
|-----------|-------------|
| `\s` | Matches any space character as defined by the current locale. shorthand for `[[:space:]]`.
| `\S` | Matches any character that is not a space, shorthand for `[^[:space:]]`.
| `\w` | Matches any word-constituent character, shorthand for `[[:alnum:]_]`.
| `\W` | Matches any character that is not word-constituent, shorthand for `[^[:alnum:]_]`.
| `\<` | Matches the empty string at the beginning of a word.  For example, `/\<away/` matches `away` but not `stowaway`.
| `\>` | Matches the empty string at the end of a word.  For example, `/stow\>/` matches `stow` but not `stowaway`.
| `\y` | Matches the empty string at the word boundar*y*.
| `\B` | Matches the empty string that occurs between two word-constituent characters.

`gawk` 有两个工作在缓冲区数据之上的运算，用于匹配整个缓冲区的数据边界：

| \` | Matches the empty string at the beginning of a buffer (string)  |
| \' | Matches the empty string at the end of a buffer (string) |

AWK 使用 `\<` 和 `\>` 两个运算符类似后向、前向零宽度匹配，只用于单词边界，
并且不是零宽模式。

JavaScript ES6 支持零宽模式，前行断言 lookahead 和后行断言 lookbehind，有 4 种形式：

    (?=pattern)  零宽正面、前行断言 zero-width positive lookahead assertion
    (?!pattern)  零宽负面、前行断言 zero-width negative lookahead assertion
    (?<=pattern) 零宽正面、后行断言 zero-width positive lookbehind assertion
    (?<!pattern) 零宽负面、后行断言 zero-width negative lookbehind assertion

AWK 内置变量

| Buit-in Vars | Description |
| ------------ | ----------- |
| $n          | 当前记录的第 n 个字段，比如 n=1 表示第一个字段。
| $0          | 这个变量包含执行过程中当前行的文本内容。
| ARGC        | 命令行参数的数目。
| ARGIND      | 命令行中当前文件的位置（从 0 开始）。
| ARGV        | 包含命令行参数的数组。
| CONVFMT     | 数字转换格式，默认值为 `%.6g`。
| ENVIRON     | 环境变量关联数组。
| ERRNO       | 最后一个系统错误的描述。
| FIELDWIDTHS | 字段宽度列表（用空格键分隔）。
| FILENAME    | 当前输入文件的名。
| IGNORECASE  | 如果为真，正则表达式匹配时忽略大小写。
| NR          | Record number 表示记录序号，默认对应于当前转入数据的行号。
| FNR         | The current record number in the current file. 同 `NR` ，但相对于当前文件。
| FS          | Field separator 字段分隔符（默认是任何空格）。
| NF          | Number of fileds 当前的字段数，`print $NF` 打印最后一个字段
| OFMT        | 数字的输出格式（默认值是 `%.6g`）。
| OFS         | Output Separators 输出字段分隔符（默认值是一个空格）。
| ORS         | Output record separator 输出记录分隔符（默认值是一个换行符）。
| RS          | Record Splitting 记录字段分隔符（默认是一个换行符）。
| RT          | Record Terminates 记录终结符（默认是一个换行符）。
| RSTART      | 由 `match` 函数所匹配的字符串的第一个位置。
| RLENGTH     | 由 `match` 函数所匹配的字符串的长度。
| SUBSEP      | 数组下标分隔符，默认值是 34。

`gawk` 5.0 开始使用命名空间管理函数、内容变量、扩展模块，默认的命名空间是 `awk`,
例如，以上的内置变量等价表达是 `awk::ARGC`，`awk::NF` 等等。改变当前命名空间，
使用 `@namespace "passwd"` 这样的指令。

AWK 比较运算符号

| Expression | Result |
|------------|--------|
| X `<` Y    | True if X is less than Y
| X `<=` Y   | True if X is less than or equal to Y
| X `>` Y    | True if X is greater than Y
| X `>=` Y   | True if X is greater than or equal to Y
| X `==` Y   | True if X is equal to Y
| X `!=` Y   | True if X is not equal to Y
| X `~` Y    | True if the string X matches the regexp denoted by Y
| X `!~` Y   | True if the string X does not match the regexp denoted by Y
| SUBSCRIPT `in` ARRAY | True if the array ARRAY has an element with the subscript SUBSCRIPT

Table 6.3: Relational operators

逻辑运算符有 OR `||`，AND `&&`，NOT `!` 三个，基本用法：

    `BOOLEAN1 && BOOLEAN2`
    `BOOLEAN1 || BOOLEAN2`
    `! BOOLEAN`

AWK 内容比较以字符串为基准，除非都是数值，或者数字字符串才进行数值比较：

            +---------------------------------
            |   STRING      NUMERIC    STRNUM
    --------+---------------------------------
            |                        
    STRING  |   string      string     string
            |                        
    NUMERIC |   string      numeric    numeric
            |                        
    STRNUM  |   string      numeric    numeric
    --------+---------------------------------


AWK 数值运算、赋值运算符号缩写形式

| Operator | Effect |
|----------|--------|
| LVALUE `+=` INCREMENT   | Add *INCREMENT* to the value of *LVALUE*.
| LVALUE `-=` DECREMENT   | Subtract *DECREMENT* from the value of *LVALUE*.
| LVALUE `*=` COEFFICIENT | Multiply the value of *LVALUE* by *COEFFICIENT*.
| LVALUE `/=` DIVISOR     | Divide the value of *LVALUE* by *DIVISOR*.
| LVALUE `%=` MODULUS     | Set *LVALUE* to its remainder by *MODULUS*.
| LVALUE `^=` POWER       | Raise *LVALUE* to the power *POWER*.
| LVALUE `**=` POWER      | Raise *LVALUE* to the power *POWER*.  (c.e.)

Table 6.2: Arithmetic assignment operators


GNU sed - GNU Sed: a stream editor
======================================================

*********

This is sed.info, produced by makeinfo version 6.5 from sed.texi.

This file documents version 4.8 of GNU 'sed', a stream editor.

   Copyright (C) 1998-2020 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".
INFO-DIR-SECTION Text creation and manipulation
START-INFO-DIR-ENTRY
* sed: (sed).                   Stream EDitor.

END-INFO-DIR-ENTRY

- GNU 'sed'
- 1 Introduction
- 2 Running sed
-   2.1 Overview
-   2.2 Command-Line Options
-   2.3 Exit status
- 3 'sed' scripts
-   3.1 'sed' script overview
-   3.2 'sed' commands summary
-   3.3 The 's' Command
-   3.4 Often-Used Commands
-   3.5 Less Frequently-Used Commands
-   3.6 Commands for 'sed' gurus
-   3.7 Commands Specific to GNU 'sed'
-   3.8 Multiple commands syntax
-     3.8.1 Commands Requiring a newline
- 4 Addresses: selecting lines
-   4.1 Addresses overview
-   4.2 Selecting lines by numbers
-   4.3 selecting lines by text matching
-   4.4 Range Addresses
- 5 Regular Expressions: selecting text
-   5.1 Overview of regular expression in 'sed'
-   5.2 Basic (BRE) and extended (ERE) regular expression
-   5.3 Overview of basic regular expression syntax
-   5.4 Overview of extended regular expression syntax
-   5.5 Character Classes and Bracket Expressions
-   5.6 regular expression extensions
-   5.7 Back-references and Subexpressions
-   5.8 Escape Sequences - specifying special characters
-     5.8.1 Escaping Precedence
-   5.9 Multibyte characters and Locale Considerations
-     5.9.1 Invalid multibyte characters
-     5.9.2 Upper/Lower case conversion
-     5.9.3 Multibyte regexp character classes
- 6 Advanced 'sed': cycles and buffers
-   6.1 How 'sed' Works
-   6.2 Hold and Pattern Buffers
-   6.3 Multiline techniques - using D,G,H,N,P to process multiple lines
-   6.4 Branching and Flow Control
-     6.4.1 Branching and Cycles
-     6.4.2 Branching example: joining lines
- 7 Some Sample Scripts
-   7.1 Joining lines
-   7.2 Centering Lines
-   7.3 Increment a Number
-   7.4 Rename Files to Lower Case
-   7.5 Print 'bash' Environment
-   7.6 Reverse Characters of Lines
-   7.7 Text search across multiple lines
-   7.8 Line length adjustment
-   7.9 Reverse Lines of Files
-   7.10 Numbering Lines
-   7.11 Numbering Non-blank Lines
-   7.12 Counting Characters
-   7.13 Counting Words
-   7.14 Counting Lines
-   7.15 Printing the First Lines
-   7.16 Printing the Last Lines
-   7.17 Make Duplicate Lines Unique
-   7.18 Print Duplicated Lines of Input
-   7.19 Remove All Duplicated Lines
-   7.20 Squeezing Blank Lines
- 8 GNU 'sed''s Limitations and Non-limitations
- 9 Other Resources for Learning About 'sed'
- 10 Reporting Bugs
- Appendix A GNU Free Documentation License
- Concept Index
- Command and Option Index



File: sed.info,  Node: Top,  Next: Introduction,  Up: (dir)

# / GNU 'sed'
**************

This file documents version 4.8 of GNU 'sed', a stream editor.

   Copyright (C) 1998-2020 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".

* Menu:

* Introduction::               Introduction
* Invoking sed::               Invocation
* sed scripts::                'sed' scripts
* sed addresses::              Addresses: selecting lines
* sed regular expressions::    Regular expressions: selecting text
* advanced sed::               Advanced 'sed': cycles and buffers
* Examples::                   Some sample scripts
* Limitations::                Limitations and (non-)limitations of GNU 'sed'
* Other Resources::            Other resources for learning about 'sed'
* Reporting Bugs::             Reporting bugs
* GNU Free Documentation License:: Copying and sharing this manual
* Concept Index::              A menu with all the topics in this manual.
* Command and Option Index::   A menu with all 'sed' commands and
                               command-line options.


File: sed.info,  Node: Introduction,  Next: Invoking sed,  Prev: Top,  Up: Top

# /1 Introduction
*****************

'sed' is a stream editor.  A stream editor is used to perform basic text
transformations on an input stream (a file or input from a pipeline).
While in some ways similar to an editor which permits scripted edits
(such as 'ed'), 'sed' works by making only one pass over the input(s),
and is consequently more efficient.  But it is 'sed''s ability to filter
text in a pipeline which particularly distinguishes it from other types
of editors.


File: sed.info,  Node: Invoking sed,  Next: sed scripts,  Prev: Introduction,  Up: Top

# /2 Running sed
****************

This chapter covers how to run 'sed'.  Details of 'sed' scripts and
individual 'sed' commands are discussed in the next chapter.

* Menu:

* Overview::
* Command-Line Options::
* Exit status::


File: sed.info,  Node: Overview,  Next: Command-Line Options,  Up: Invoking sed

2.1 Overview
============

Normally 'sed' is invoked like this:

     sed SCRIPT INPUTFILE...

   For example, to replace all occurrences of 'hello' to 'world' in the
file 'input.txt':

     sed 's/hello/world/' input.txt > output.txt

   If you do not specify INPUTFILE, or if INPUTFILE is '-', 'sed'
filters the contents of the standard input.  The following commands are
equivalent:

     sed 's/hello/world/' input.txt > output.txt
     sed 's/hello/world/' < input.txt > output.txt
     cat input.txt | sed 's/hello/world/' - > output.txt

   'sed' writes output to standard output.  Use '-i' to edit files
in-place instead of printing to standard output.  See also the 'W' and
's///w' commands for writing output to other files.  The following
command modifies 'file.txt' and does not produce any output:

     sed -i 's/hello/world/' file.txt

   By default 'sed' prints all processed input (except input that has
been modified/deleted by commands such as 'd').  Use '-n' to suppress
output, and the 'p' command to print specific lines.  The following
command prints only line 45 of the input file:

     sed -n '45p' file.txt

   'sed' treats multiple input files as one long stream.  The following
example prints the first line of the first file ('one.txt') and the last
line of the last file ('three.txt').  Use '-s' to reverse this behavior.

     sed -n  '1p ; $p' one.txt two.txt three.txt

   Without '-e' or '-f' options, 'sed' uses the first non-option
parameter as the SCRIPT, and the following non-option parameters as
input files.  If '-e' or '-f' options are used to specify a SCRIPT, all
non-option parameters are taken as input files.  Options '-e' and '-f'
can be combined, and can appear multiple times (in which case the final
effective SCRIPT will be concatenation of all the individual SCRIPTs).

   The following examples are equivalent:

     sed 's/hello/world/' input.txt > output.txt

     sed -e 's/hello/world/' input.txt > output.txt
     sed --expression='s/hello/world/' input.txt > output.txt

     echo 's/hello/world/' > myscript.sed
     sed -f myscript.sed input.txt > output.txt
     sed --file=myscript.sed input.txt > output.txt


File: sed.info,  Node: Command-Line Options,  Next: Exit status,  Prev: Overview,  Up: Invoking sed

2.2 Command-Line Options
========================

The full format for invoking 'sed' is:

     sed OPTIONS... [SCRIPT] [INPUTFILE...]

   'sed' may be invoked with the following command-line options:

'--version'
     Print out the version of 'sed' that is being run and a copyright
     notice, then exit.

'--help'
     Print a usage message briefly summarizing these command-line
     options and the bug-reporting address, then exit.

'-n'
'--quiet'
'--silent'
     By default, 'sed' prints out the pattern space at the end of each
     cycle through the script (*note* How 'sed' works: Execution Cycle.).
     These options disable this automatic printing, and 'sed' only
     produces output when explicitly told to via the 'p' command.

'--debug'
     Print the input sed program in canonical form, and annotate program
     execution.
          $ echo 1 | sed '\%1%s21232'
          3

          $ echo 1 | sed --debug '\%1%s21232'
          SED PROGRAM:
            /1/ s/1/3/
          INPUT:   'STDIN' line 1
          PATTERN: 1
          COMMAND: /1/ s/1/3/
          PATTERN: 3
          END-OF-CYCLE:
          3

'-e SCRIPT'
'--expression=SCRIPT'
     Add the commands in SCRIPT to the set of commands to be run while
     processing the input.

'-f SCRIPT-FILE'
'--file=SCRIPT-FILE'
     Add the commands contained in the file SCRIPT-FILE to the set of
     commands to be run while processing the input.

'-i[SUFFIX]'
'--in-place[=SUFFIX]'
     This option specifies that files are to be edited in-place.  GNU
     'sed' does this by creating a temporary file and sending output to
     this file rather than to the standard output.(1).

     This option implies '-s'.

     When the end of the file is reached, the temporary file is renamed
     to the output file's original name.  The extension, if supplied, is
     used to modify the name of the old file before renaming the
     temporary file, thereby making a backup copy(2)).

     This rule is followed: if the extension doesn't contain a '*', then
     it is appended to the end of the current filename as a suffix; if
     the extension does contain one or more '*' characters, then _each_
     asterisk is replaced with the current filename.  This allows you to
     add a prefix to the backup file, instead of (or in addition to) a
     suffix, or even to place backup copies of the original files into
     another directory (provided the directory already exists).

     If no extension is supplied, the original file is overwritten
     without making a backup.

     Because '-i' takes an optional argument, it should not be followed
     by other short options:
     'sed -Ei '...' FILE'
          Same as '-E -i' with no backup suffix - 'FILE' will be edited
          in-place without creating a backup.

     'sed -iE '...' FILE'
          This is equivalent to '--in-place=E', creating 'FILEE' as
          backup of 'FILE'

     Be cautious of using '-n' with '-i': the former disables automatic
     printing of lines and the latter changes the file in-place without
     a backup.  Used carelessly (and without an explicit 'p' command),
     the output file will be empty:
          # WRONG USAGE: 'FILE' will be truncated.
          sed -ni 's/foo/bar/' FILE

'-l N'
'--line-length=N'
     Specify the default line-wrap length for the 'l' command.  A length
     of 0 (zero) means to never wrap long lines.  If not specified, it
     is taken to be 70.

'--posix'
     GNU 'sed' includes several extensions to POSIX sed.  In order to
     simplify writing portable scripts, this option disables all the
     extensions that this manual documents, including additional
     commands.  Most of the extensions accept 'sed' programs that are
     outside the syntax mandated by POSIX, but some of them (such as the
     behavior of the 'N' command described in *note* Reporting Bugs::)
     actually violate the standard.  If you want to disable only the
     latter kind of extension, you can set the 'POSIXLY_CORRECT'
     variable to a non-empty value.

'-b'
'--binary'
     This option is available on every platform, but is only effective
     where the operating system makes a distinction between text files
     and binary files.  When such a distinction is made--as is the case
     for MS-DOS, Windows, Cygwin--text files are composed of lines
     separated by a carriage return _and_ a line feed character, and
     'sed' does not see the ending CR. When this option is specified,
     'sed' will open input files in binary mode, thus not requesting
     this special processing and considering lines to end at a line
     feed.

'--follow-symlinks'
     This option is available only on platforms that support symbolic
     links and has an effect only if option '-i' is specified.  In this
     case, if the file that is specified on the command line is a
     symbolic link, 'sed' will follow the link and edit the ultimate
     destination of the link.  The default behavior is to break the
     symbolic link, so that the link destination will not be modified.

'-E'
'-r'
'--regexp-extended'
     Use extended regular expressions rather than basic regular
     expressions.  Extended regexps are those that 'egrep' accepts; they
     can be clearer because they usually have fewer backslashes.
     Historically this was a GNU extension, but the '-E' extension has
     since been added to the POSIX standard
     (http://austingroupbugs.net/view.php?id=528), so use '-E' for
     portability.  GNU sed has accepted '-E' as an undocumented option
     for years, and *BSD seds have accepted '-E' for years as well, but
     scripts that use '-E' might not port to other older systems.  *Note
     Extended regular expressions: ERE syntax.

'-s'
'--separate'
     By default, 'sed' will consider the files specified on the command
     line as a single continuous long stream.  This GNU 'sed' extension
     allows the user to consider them as separate files: range addresses
     (such as '/abc/,/def/') are not allowed to span several files, line
     numbers are relative to the start of each file, '$' refers to the
     last line of each file, and files invoked from the 'R' commands are
     rewound at the start of each file.

'--sandbox'
     In sandbox mode, 'e/w/r' commands are rejected - programs
     containing them will be aborted without being run.  Sandbox mode
     ensures 'sed' operates only on the input files designated on the
     command line, and cannot run external programs.

'-u'
'--unbuffered'
     Buffer both input and output as minimally as practical.  (This is
     particularly useful if the input is coming from the likes of 'tail
     -f', and you wish to see the transformed output as soon as
     possible.)

'-z'
'--null-data'
'--zero-terminated'
     Treat the input as a set of lines, each terminated by a zero byte
     (the ASCII 'NUL' character) instead of a newline.  This option can
     be used with commands like 'sort -z' and 'find -print0' to process
     arbitrary file names.

   If no '-e', '-f', '--expression', or '--file' options are given on
the command-line, then the first non-option argument on the command line
is taken to be the SCRIPT to be executed.

   If any command-line parameters remain after processing the above,
these parameters are interpreted as the names of input files to be
processed.  A file name of '-' refers to the standard input stream.  The
standard input will be processed if no file names are specified.

   ---------- Footnotes ----------

   (1) This applies to commands such as '=', 'a', 'c', 'i', 'l', 'p'.
You can still write to the standard output by using the 'w' or 'W'
commands together with the '/dev/stdout' special file

   (2) Note that GNU 'sed' creates the backup file whether or not any
output is actually changed.


File: sed.info,  Node: Exit status,  Prev: Command-Line Options,  Up: Invoking sed

2.3 Exit status
===============

An exit status of zero indicates success, and a nonzero value indicates
failure.  GNU 'sed' returns the following exit status error values:

0
     Successful completion.

1
     Invalid command, invalid syntax, invalid regular expression or a
     GNU 'sed' extension command used with '--posix'.

2
     One or more of the input file specified on the command line could
     not be opened (e.g.  if a file is not found, or read permission is
     denied).  Processing continued with other files.

4
     An I/O error, or a serious processing error during runtime, GNU
     'sed' aborted immediately.

   Additionally, the commands 'q' and 'Q' can be used to terminate 'sed'
with a custom exit code value (this is a GNU 'sed' extension):

     $ echo | sed 'Q42' ; echo $?
     42


File: sed.info,  Node: sed scripts,  Next: sed addresses,  Prev: Invoking sed,  Up: Top

# /3 'sed' scripts
******************

* Menu:

* sed script overview::      'sed' script overview
* sed commands list::        'sed' commands summary
* The "s" Command::          'sed''s Swiss Army Knife
* Common Commands::          Often used commands
* Other Commands::           Less frequently used commands
* Programming Commands::     Commands for 'sed' gurus
* Extended Commands::        Commands specific of GNU 'sed'
* Multiple commands syntax:: Extension for easier scripting


File: sed.info,  Node: sed script overview,  Next: sed commands list,  Up: sed scripts

3.1 'sed' script overview
=========================

A 'sed' program consists of one or more 'sed' commands, passed in by one
or more of the '-e', '-f', '--expression', and '--file' options, or the
first non-option argument if zero of these options are used.  This
document will refer to "the" 'sed' script; this is understood to mean
the in-order concatenation of all of the SCRIPTs and SCRIPT-FILEs passed
in.  *Note* Overview::.

   'sed' commands follow this syntax:

     [addr]X[options]

   X is a single-letter 'sed' command.  '[addr]' is an optional line
address.  If '[addr]' is specified, the command X will be executed only
on the matched lines.  '[addr]' can be a single line number, a regular
expression, or a range of lines (*note* sed addresses::).  Additional
'[options]' are used for some 'sed' commands.

   The following example deletes lines 30 to 35 in the input.  '30,35'
is an address range.  'd' is the delete command:

     sed '30,35d' input.txt > output.txt

   The following example prints all input until a line starting with the
word 'foo' is found.  If such line is found, 'sed' will terminate with
exit status 42.  If such line was not found (and no other error
occurred), 'sed' will exit with status 0.  '/^foo/' is a
regular-expression address.  'q' is the quit command.  '42' is the
command option.

     sed '/^foo/q42' input.txt > output.txt

   Commands within a SCRIPT or SCRIPT-FILE can be separated by
semicolons (';') or newlines (ASCII 10).  Multiple scripts can be
specified with '-e' or '-f' options.

   The following examples are all equivalent.  They perform two 'sed'
operations: deleting any lines matching the regular expression '/^foo/',
and replacing all occurrences of the string 'hello' with 'world':

     sed '/^foo/d ; s/hello/world/' input.txt > output.txt

     sed -e '/^foo/d' -e 's/hello/world/' input.txt > output.txt

     echo '/^foo/d' > script.sed
     echo 's/hello/world/' >> script.sed
     sed -f script.sed input.txt > output.txt

     echo 's/hello/world/' > script2.sed
     sed -e '/^foo/d' -f script2.sed input.txt > output.txt

   Commands 'a', 'c', 'i', due to their syntax, cannot be followed by
semicolons working as command separators and thus should be terminated
with newlines or be placed at the end of a SCRIPT or SCRIPT-FILE.
Commands can also be preceded with optional non-significant whitespace
characters.  *Note* Multiple commands syntax::.


File: sed.info,  Node: sed commands list,  Next: The "s" Command,  Prev: sed script overview,  Up: sed scripts

3.2 'sed' commands summary
==========================

The following commands are supported in GNU 'sed'.  Some are standard
POSIX commands, while other are GNU extensions.  Details and examples
for each command are in the following sections.  (Mnemonics) are shown
in parentheses.

'a\'
'TEXT'
     Append TEXT after a line.

'a TEXT'
     Append TEXT after a line (alternative syntax).

'b LABEL'
     Branch unconditionally to LABEL.  The LABEL may be omitted, in
     which case the next cycle is started.

'c\'
'TEXT'
     Replace (change) lines with TEXT.

'c TEXT'
     Replace (change) lines with TEXT (alternative syntax).

'd'
     Delete the pattern space; immediately start next cycle.

'D'
     If pattern space contains newlines, delete text in the pattern
     space up to the first newline, and restart cycle with the resultant
     pattern space, without reading a new line of input.

     If pattern space contains no newline, start a normal new cycle as
     if the 'd' command was issued.

'e'
     Executes the command that is found in pattern space and replaces
     the pattern space with the output; a trailing newline is
     suppressed.

'e COMMAND'
     Executes COMMAND and sends its output to the output stream.  The
     command can run across multiple lines, all but the last ending with
     a back-slash.

'F'
     (filename) Print the file name of the current input file (with a
     trailing newline).

'g'
     Replace the contents of the pattern space with the contents of the
     hold space.

'G'
     Append a newline to the contents of the pattern space, and then
     append the contents of the hold space to that of the pattern space.

'h'
     (hold) Replace the contents of the hold space with the contents of
     the pattern space.

'H'
     Append a newline to the contents of the hold space, and then append
     the contents of the pattern space to that of the hold space.

'i\'
'TEXT'
     insert TEXT before a line.

'i TEXT'
     insert TEXT before a line (alternative syntax).

'l'
     Print the pattern space in an unambiguous form.

'n'
     (next) If auto-print is not disabled, print the pattern space,
     then, regardless, replace the pattern space with the next line of
     input.  If there is no more input then 'sed' exits without
     processing any more commands.

'N'
     Add a newline to the pattern space, then append the next line of
     input to the pattern space.  If there is no more input then 'sed'
     exits without processing any more commands.

'p'
     Print the pattern space.

'P'
     Print the pattern space, up to the first <newline>.

'q[EXIT-CODE]'
     (quit) Exit 'sed' without processing any more commands or input.

'Q[EXIT-CODE]'
     (quit) This command is the same as 'q', but will not print the
     contents of pattern space.  Like 'q', it provides the ability to
     return an exit code to the caller.

'r filename'
     Reads file FILENAME.

'R filename'
     Queue a line of FILENAME to be read and inserted into the output
     stream at the end of the current cycle, or when the next input line
     is read.

's/REGEXP/REPLACEMENT/[FLAGS]'
     (substitute) Match the regular-expression against the content of
     the pattern space.  If found, replace matched string with
     REPLACEMENT.

't LABEL'
     (test) Branch to LABEL only if there has been a successful
     's'ubstitution since the last input line was read or conditional
     branch was taken.  The LABEL may be omitted, in which case the next
     cycle is started.

'T LABEL'
     (test) Branch to LABEL only if there have been no successful
     's'ubstitutions since the last input line was read or conditional
     branch was taken.  The LABEL may be omitted, in which case the next
     cycle is started.

'v [VERSION]'
     (version) This command does nothing, but makes 'sed' fail if GNU
     'sed' extensions are not supported, or if the requested version is
     not available.

'w filename'
     Write the pattern space to FILENAME.

'W filename'
     Write to the given filename the portion of the pattern space up to
     the first newline

'x'
     Exchange the contents of the hold and pattern spaces.

'y/src/dst/'
     Transliterate any characters in the pattern space which match any
     of the SOURCE-CHARS with the corresponding character in DEST-CHARS.

'z'
     (zap) This command empties the content of pattern space.

'#'
     A comment, until the next newline.

'{ CMD ; CMD ... }'
     Group several commands together.

'='
     Print the current input line number (with a trailing newline).

': LABEL'
     Specify the location of LABEL for branch commands ('b', 't', 'T').


File: sed.info,  Node: The "s" Command,  Next: Common Commands,  Prev: sed commands list,  Up: sed scripts

3.3 The 's' Command
===================

The 's' command (as in substitute) is probably the most important in
'sed' and has a lot of different options.  The syntax of the 's' command
is 's/REGEXP/REPLACEMENT/FLAGS'.

   Its basic concept is simple: the 's' command attempts to match the
pattern space against the supplied regular expression REGEXP; if the
match is successful, then that portion of the pattern space which was
matched is replaced with REPLACEMENT.

   For details about REGEXP syntax *note* Regular Expression Addresses:
Regexp Addresses.

   The REPLACEMENT can contain '\N' (N being a number from 1 to 9,
inclusive) references, which refer to the portion of the match which is
contained between the Nth '\(' and its matching '\)'.  Also, the
REPLACEMENT can contain unescaped '&' characters which reference the
whole matched portion of the pattern space.

   The '/' characters may be uniformly replaced by any other single
character within any given 's' command.  The '/' character (or whatever
other character is used in its stead) can appear in the REGEXP or
REPLACEMENT only if it is preceded by a '\' character.

   Finally, as a GNU 'sed' extension, you can include a special sequence
made of a backslash and one of the letters 'L', 'l', 'U', 'u', or 'E'.
The meaning is as follows:

'\L'
     Turn the replacement to lowercase until a '\U' or '\E' is found,

'\l'
     Turn the next character to lowercase,

'\U'
     Turn the replacement to uppercase until a '\L' or '\E' is found,

'\u'
     Turn the next character to uppercase,

'\E'
     Stop case conversion started by '\L' or '\U'.

   When the 'g' flag is being used, case conversion does not propagate
from one occurrence of the regular expression to another.  For example,
when the following command is executed with 'a-b-' in pattern space:
     s/\(b\?\)-/x\u\1/g

the output is 'axxB'.  When replacing the first '-', the '\u' sequence
only affects the empty replacement of '\1'.  It does not affect the 'x'
character that is added to pattern space when replacing 'b-' with 'xB'.

   On the other hand, '\l' and '\u' do affect the remainder of the
replacement text if they are followed by an empty substitution.  With
'a-b-' in pattern space, the following command:
     s/\(b\?\)-/\u\1x/g

will replace '-' with 'X' (uppercase) and 'b-' with 'Bx'.  If this
behavior is undesirable, you can prevent it by adding a '\E'
sequence--after '\1' in this case.

   To include a literal '\', '&', or newline in the final replacement,
be sure to precede the desired '\', '&', or newline in the REPLACEMENT
with a '\'.

   The 's' command can be followed by zero or more of the following
FLAGS:

'g'
     Apply the replacement to _all_ matches to the REGEXP, not just the
     first.

'NUMBER'
     Only replace the NUMBERth match of the REGEXP.

     interaction in 's' command Note: the POSIX standard does not
     specify what should happen when you mix the 'g' and NUMBER
     modifiers, and currently there is no widely agreed upon meaning
     across 'sed' implementations.  For GNU 'sed', the interaction is
     defined to be: ignore matches before the NUMBERth, and then match
     and replace all matches from the NUMBERth on.

'p'
     If the substitution was made, then print the new pattern space.

     Note: when both the 'p' and 'e' options are specified, the relative
     ordering of the two produces very different results.  In general,
     'ep' (evaluate then print) is what you want, but operating the
     other way round can be useful for debugging.  For this reason, the
     current version of GNU 'sed' interprets specially the presence of
     'p' options both before and after 'e', printing the pattern space
     before and after evaluation, while in general flags for the 's'
     command show their effect just once.  This behavior, although
     documented, might change in future versions.

'w FILENAME'
     If the substitution was made, then write out the result to the
     named file.  As a GNU 'sed' extension, two special values of
     FILENAME are supported: '/dev/stderr', which writes the result to
     the standard error, and '/dev/stdout', which writes to the standard
     output.(1)

'e'
     This command allows one to pipe input from a shell command into
     pattern space.  If a substitution was made, the command that is
     found in pattern space is executed and pattern space is replaced
     with its output.  A trailing newline is suppressed; results are
     undefined if the command to be executed contains a NUL character.
     This is a GNU 'sed' extension.

'I'
'i'
     The 'I' modifier to regular-expression matching is a GNU extension
     which makes 'sed' match REGEXP in a case-insensitive manner.

'M'
'm'
     The 'M' modifier to regular-expression matching is a GNU 'sed'
     extension which directs GNU 'sed' to match the regular expression
     in 'multi-line' mode.  The modifier causes '^' and '$' to match
     respectively (in addition to the normal behavior) the empty string
     after a newline, and the empty string before a newline.  There are
     special character sequences ('\`' and '\'') which always match the
     beginning or the end of the buffer.  In addition, the period
     character does not match a new-line character in multi-line mode.

   ---------- Footnotes ----------

   (1) This is equivalent to 'p' unless the '-i' option is being used.


File: sed.info,  Node: Common Commands,  Next: Other Commands,  Prev: The "s" Command,  Up: sed scripts

3.4 Often-Used Commands
=======================

If you use 'sed' at all, you will quite likely want to know these
commands.

'#'
     [No addresses allowed.]

     The '#' character begins a comment; the comment continues until the
     next newline.

     If you are concerned about portability, be aware that some
     implementations of 'sed' (which are not POSIX conforming) may only
     support a single one-line comment, and then only when the very
     first character of the script is a '#'.

     Warning: if the first two characters of the 'sed' script are '#n',
     then the '-n' (no-autoprint) option is forced.  If you want to put
     a comment in the first line of your script and that comment begins
     with the letter 'n' and you do not want this behavior, then be sure
     to either use a capital 'N', or place at least one space before the
     'n'.

'q [EXIT-CODE]'
     Exit 'sed' without processing any more commands or input.

     Example: stop after printing the second line:
          $ seq 3 | sed 2q
          1
          2

     This command accepts only one address.  Note that the current
     pattern space is printed if auto-print is not disabled with the
     '-n' options.  The ability to return an exit code from the 'sed'
     script is a GNU 'sed' extension.

     See also the GNU 'sed' extension 'Q' command which quits silently
     without printing the current pattern space.

'd'
     Delete the pattern space; immediately start next cycle.

     Example: delete the second input line:
          $ seq 3 | sed 2d
          1
          3

'p'
     Print out the pattern space (to the standard output).  This command
     is usually only used in conjunction with the '-n' command-line
     option.

     Example: print only the second input line:
          $ seq 3 | sed -n 2p
          2

'n'
     If auto-print is not disabled, print the pattern space, then,
     regardless, replace the pattern space with the next line of input.
     If there is no more input then 'sed' exits without processing any
     more commands.

     This command is useful to skip lines (e.g.  process every Nth
     line).

     Example: perform substitution on every 3rd line (i.e.  two 'n'
     commands skip two lines):
          $ seq 6 | sed 'n;n;s/./x/'
          1
          2
          x
          4
          5
          x

     GNU 'sed' provides an extension address syntax of FIRST~STEP to
     achieve the same result:

          $ seq 6 | sed '0~3s/./x/'
          1
          2
          x
          4
          5
          x

'{ COMMANDS }'
     A group of commands may be enclosed between '{' and '}' characters.
     This is particularly useful when you want a group of commands to be
     triggered by a single address (or address-range) match.

     Example: perform substitution then print the second input line:
          $ seq 3 | sed -n '2{s/2/X/ ; p}'
          X


File: sed.info,  Node: Other Commands,  Next: Programming Commands,  Prev: Common Commands,  Up: sed scripts

3.5 Less Frequently-Used Commands
=================================

Though perhaps less frequently used than those in the previous section,
some very small yet useful 'sed' scripts can be built with these
commands.

'y/SOURCE-CHARS/DEST-CHARS/'
     Transliterate any characters in the pattern space which match any
     of the SOURCE-CHARS with the corresponding character in DEST-CHARS.

     Example: transliterate 'a-j' into '0-9':
          $ echo hello world | sed 'y/abcdefghij/0123456789/'
          74llo worl3

     (The '/' characters may be uniformly replaced by any other single
     character within any given 'y' command.)

     Instances of the '/' (or whatever other character is used in its
     stead), '\', or newlines can appear in the SOURCE-CHARS or
     DEST-CHARS lists, provide that each instance is escaped by a '\'.
     The SOURCE-CHARS and DEST-CHARS lists _must_ contain the same
     number of characters (after de-escaping).

     See the 'tr' command from GNU coreutils for similar functionality.

'a TEXT'
     Appending TEXT after a line.  This is a GNU extension to the
     standard 'a' command - see below for details.

     Example: Add the word 'hello' after the second line:
          $ seq 3 | sed '2a hello'
          1
          2
          hello
          3

     Leading whitespace after the 'a' command is ignored.  The text to
     add is read until the end of the line.

'a\'
'TEXT'
     Appending TEXT after a line.

     Example: Add 'hello' after the second line (-| indicates printed
     output lines):
          $ seq 3 | sed '2a\
          hello'
          -|1
          -|2
          -|hello
          -|3

     The 'a' command queues the lines of text which follow this command
     (each but the last ending with a '\', which are removed from the
     output) to be output at the end of the current cycle, or when the
     next input line is read.

     As a GNU extension, this command accepts two addresses.

     Escape sequences in TEXT are processed, so you should use '\\' in
     TEXT to print a single backslash.

     The commands resume after the last line without a backslash ('\') -
     'world' in the following example:
          $ seq 3 | sed '2a\
          hello\
          world
          3s/./X/'
          -|1
          -|2
          -|hello
          -|world
          -|X

     As a GNU extension, the 'a' command and TEXT can be separated into
     two '-e' parameters, enabling easier scripting:
          $ seq 3 | sed -e '2a\' -e hello
          1
          2
          hello
          3

          $ sed -e '2a\' -e "$VAR"

'i TEXT'
     insert TEXT before a line.  This is a GNU extension to the standard
     'i' command - see below for details.

     Example: Insert the word 'hello' before the second line:
          $ seq 3 | sed '2i hello'
          1
          hello
          2
          3

     Leading whitespace after the 'i' command is ignored.  The text to
     add is read until the end of the line.

'i\'
'TEXT'
     Immediately output the lines of text which follow this command.

     Example: Insert 'hello' before the second line (-| indicates
     printed output lines):
          $ seq 3 | sed '2i\
          hello'
          -|1
          -|hello
          -|2
          -|3

     As a GNU extension, this command accepts two addresses.

     Escape sequences in TEXT are processed, so you should use '\\' in
     TEXT to print a single backslash.

     The commands resume after the last line without a backslash ('\') -
     'world' in the following example:
          $ seq 3 | sed '2i\
          hello\
          world
          s/./X/'
          -|X
          -|hello
          -|world
          -|X
          -|X

     As a GNU extension, the 'i' command and TEXT can be separated into
     two '-e' parameters, enabling easier scripting:
          $ seq 3 | sed -e '2i\' -e hello
          1
          hello
          2
          3

          $ sed -e '2i\' -e "$VAR"

'c TEXT'
     Replaces the line(s) with TEXT.  This is a GNU extension to the
     standard 'c' command - see below for details.

     Example: Replace the 2nd to 9th lines with the word 'hello':
          $ seq 10 | sed '2,9c hello'
          1
          hello
          10

     Leading whitespace after the 'c' command is ignored.  The text to
     add is read until the end of the line.

'c\'
'TEXT'
     Delete the lines matching the address or address-range, and output
     the lines of text which follow this command.

     Example: Replace 2nd to 4th lines with the words 'hello' and
     'world' (-| indicates printed output lines):
          $ seq 5 | sed '2,4c\
          hello\
          world'
          -|1
          -|hello
          -|world
          -|5

     If no addresses are given, each line is replaced.

     A new cycle is started after this command is done, since the
     pattern space will have been deleted.  In the following example,
     the 'c' starts a new cycle and the substitution command is not
     performed on the replaced text:

          $ seq 3 | sed '2c\
          hello
          s/./X/'
          -|X
          -|hello
          -|X

     As a GNU extension, the 'c' command and TEXT can be separated into
     two '-e' parameters, enabling easier scripting:
          $ seq 3 | sed -e '2c\' -e hello
          1
          hello
          3

          $ sed -e '2c\' -e "$VAR"

'='
     Print out the current input line number (with a trailing newline).

          $ printf '%s\n' aaa bbb ccc | sed =
          1
          aaa
          2
          bbb
          3
          ccc

     As a GNU extension, this command accepts two addresses.

'l N'
     Print the pattern space in an unambiguous form: non-printable
     characters (and the '\' character) are printed in C-style escaped
     form; long lines are split, with a trailing '\' character to
     indicate the split; the end of each line is marked with a '$'.

     N specifies the desired line-wrap length; a length of 0 (zero)
     means to never wrap long lines.  If omitted, the default as
     specified on the command line is used.  The N parameter is a GNU
     'sed' extension.

'r FILENAME'

     Reads file FILENAME.  Example:

          $ seq 3 | sed '2r/etc/hostname'
          1
          2
          fencepost.gnu.org
          3

     Queue the contents of FILENAME to be read and inserted into the
     output stream at the end of the current cycle, or when the next
     input line is read.  Note that if FILENAME cannot be read, it is
     treated as if it were an empty file, without any error indication.

     As a GNU 'sed' extension, the special value '/dev/stdin' is
     supported for the file name, which reads the contents of the
     standard input.

     As a GNU extension, this command accepts two addresses.  The file
     will then be reread and inserted on each of the addressed lines.

'w FILENAME'
     Write the pattern space to FILENAME.  As a GNU 'sed' extension, two
     special values of FILENAME are supported: '/dev/stderr', which
     writes the result to the standard error, and '/dev/stdout', which
     writes to the standard output.(1)

     The file will be created (or truncated) before the first input line
     is read; all 'w' commands (including instances of the 'w' flag on
     successful 's' commands) which refer to the same FILENAME are
     output without closing and reopening the file.

'D'
     If pattern space contains no newline, start a normal new cycle as
     if the 'd' command was issued.  Otherwise, delete text in the
     pattern space up to the first newline, and restart cycle with the
     resultant pattern space, without reading a new line of input.

'N'
     Add a newline to the pattern space, then append the next line of
     input to the pattern space.  If there is no more input then 'sed'
     exits without processing any more commands.

     When '-z' is used, a zero byte (the ascii 'NUL' character) is added
     between the lines (instead of a new line).

     By default 'sed' does not terminate if there is no 'next' input
     line.  This is a GNU extension which can be disabled with
     '--posix'.  *Note* N command on the last line: N_command_last_line.

'P'
     Print out the portion of the pattern space up to the first newline.

'h'
     Replace the contents of the hold space with the contents of the
     pattern space.

'H'
     Append a newline to the contents of the hold space, and then append
     the contents of the pattern space to that of the hold space.

'g'
     Replace the contents of the pattern space with the contents of the
     hold space.

'G'
     Append a newline to the contents of the pattern space, and then
     append the contents of the hold space to that of the pattern space.

'x'
     Exchange the contents of the hold and pattern spaces.

   ---------- Footnotes ----------

   (1) This is equivalent to 'p' unless the '-i' option is being used.


File: sed.info,  Node: Programming Commands,  Next: Extended Commands,  Prev: Other Commands,  Up: sed scripts

3.6 Commands for 'sed' gurus
============================

In most cases, use of these commands indicates that you are probably
better off programming in something like 'awk' or Perl.  But
occasionally one is committed to sticking with 'sed', and these commands
can enable one to write quite convoluted scripts.

': LABEL'
     [No addresses allowed.]

     Specify the location of LABEL for branch commands.  In all other
     respects, a no-op.

'b LABEL'
     Unconditionally branch to LABEL.  The LABEL may be omitted, in
     which case the next cycle is started.

't LABEL'
     Branch to LABEL only if there has been a successful 's'ubstitution
     since the last input line was read or conditional branch was taken.
     The LABEL may be omitted, in which case the next cycle is started.


File: sed.info,  Node: Extended Commands,  Next: Multiple commands syntax,  Prev: Programming Commands,  Up: sed scripts

3.7 Commands Specific to GNU 'sed'
==================================

These commands are specific to GNU 'sed', so you must use them with care
and only when you are sure that hindering portability is not evil.  They
allow you to check for GNU 'sed' extensions or to do tasks that are
required quite often, yet are unsupported by standard 'sed's.

'e [COMMAND]'
     This command allows one to pipe input from a shell command into
     pattern space.  Without parameters, the 'e' command executes the
     command that is found in pattern space and replaces the pattern
     space with the output; a trailing newline is suppressed.

     If a parameter is specified, instead, the 'e' command interprets it
     as a command and sends its output to the output stream.  The
     command can run across multiple lines, all but the last ending with
     a back-slash.

     In both cases, the results are undefined if the command to be
     executed contains a NUL character.

     Note that, unlike the 'r' command, the output of the command will
     be printed immediately; the 'r' command instead delays the output
     to the end of the current cycle.

'F'
     Print out the file name of the current input file (with a trailing
     newline).

'Q [EXIT-CODE]'
     This command accepts only one address.

     This command is the same as 'q', but will not print the contents of
     pattern space.  Like 'q', it provides the ability to return an exit
     code to the caller.

     This command can be useful because the only alternative ways to
     accomplish this apparently trivial function are to use the '-n'
     option (which can unnecessarily complicate your script) or
     resorting to the following snippet, which wastes time by reading
     the whole file without any visible effect:

          :eat
          $d       Quit silently on the last line
          N        Read another line, silently
          g        Overwrite pattern space each time to save memory
          b eat

'R FILENAME'
     Queue a line of FILENAME to be read and inserted into the output
     stream at the end of the current cycle, or when the next input line
     is read.  Note that if FILENAME cannot be read, or if its end is
     reached, no line is appended, without any error indication.

     As with the 'r' command, the special value '/dev/stdin' is
     supported for the file name, which reads a line from the standard
     input.

'T LABEL'
     Branch to LABEL only if there have been no successful
     's'ubstitutions since the last input line was read or conditional
     branch was taken.  The LABEL may be omitted, in which case the next
     cycle is started.

'v VERSION'
     This command does nothing, but makes 'sed' fail if GNU 'sed'
     extensions are not supported, simply because other versions of
     'sed' do not implement it.  In addition, you can specify the
     version of 'sed' that your script requires, such as '4.0.5'.  The
     default is '4.0' because that is the first version that implemented
     this command.

     This command enables all GNU extensions even if 'POSIXLY_CORRECT'
     is set in the environment.

'W FILENAME'
     Write to the given filename the portion of the pattern space up to
     the first newline.  Everything said under the 'w' command about
     file handling holds here too.

'z'
     This command empties the content of pattern space.  It is usually
     the same as 's/.*//', but is more efficient and works in the
     presence of invalid multibyte sequences in the input stream.  POSIX
     mandates that such sequences are _not_ matched by '.', so that
     there is no portable way to clear 'sed''s buffers in the middle of
     the script in most multibyte locales (including UTF-8 locales).


File: sed.info,  Node: Multiple commands syntax,  Prev: Extended Commands,  Up: sed scripts

3.8 Multiple commands syntax
============================

There are several methods to specify multiple commands in a 'sed'
program.

   Using newlines is most natural when running a sed script from a file
(using the '-f' option).

   On the command line, all 'sed' commands may be separated by newlines.
Alternatively, you may specify each command as an argument to an '-e'
option:

     $ seq 6 | sed '1d
     3d
     5d'
     2
     4
     6

     $ seq 6 | sed -e 1d -e 3d -e 5d
     2
     4
     6

   A semicolon (';') may be used to separate most simple commands:

     $ seq 6 | sed '1d;3d;5d'
     2
     4
     6

   The '{','}','b','t','T',':' commands can be separated with a
semicolon (this is a non-portable GNU 'sed' extension).

     $ seq 4 | sed '{1d;3d}'
     2
     4

     $ seq 6 | sed '{1d;3d};5d'
     2
     4
     6

   Labels used in 'b','t','T',':' commands are read until a semicolon.
Leading and trailing whitespace is ignored.  In the examples below the
label is 'x'.  The first example works with GNU 'sed'.  The second is a
portable equivalent.  For more information about branching and labels
*note* Branching and flow control::.

     $ seq 3 | sed '/1/b x ; s/^/=/ ; :x ; 3d'
     1
     =2

     $ seq 3 | sed -e '/1/bx' -e 's/^/=/' -e ':x' -e '3d'
     1
     =2

3.8.1 Commands Requiring a newline
----------------------------------

The following commands cannot be separated by a semicolon and require a
newline:

'a','c','i' (append/change/insert)

     All characters following 'a','c','i' commands are taken as the text
     to append/change/insert.  Using a semicolon leads to undesirable
     results:

          $ seq 2 | sed '1aHello ; 2d'
          1
          Hello ; 2d
          2

     Separate the commands using '-e' or a newline:

          $ seq 2 | sed -e 1aHello -e 2d
          1
          Hello

          $ seq 2 | sed '1aHello
          2d'
          1
          Hello

     Note that specifying the text to add ('Hello') immediately after
     'a','c','i' is itself a GNU 'sed' extension.  A portable,
     POSIX-compliant alternative is:

          $ seq 2 | sed '1a\
          Hello
          2d'
          1
          Hello

'#' (comment)

     All characters following '#' until the next newline are ignored.

          $ seq 3 | sed '# this is a comment ; 2d'
          1
          2
          3


          $ seq 3 | sed '# this is a comment
          2d'
          1
          3

'r','R','w','W' (reading and writing files)

     The 'r','R','w','W' commands parse the filename until end of the
     line.  If whitespace, comments or semicolons are found, they will
     be included in the filename, leading to unexpected results:

          $ seq 2 | sed '1w hello.txt ; 2d'
          1
          2

          $ ls -log
          total 4
          -rw-rw-r-- 1 2 Jan 23 23:03 hello.txt ; 2d

          $ cat 'hello.txt ; 2d'
          1

     Note that 'sed' silently ignores read/write errors in
     'r','R','w','W' commands (such as missing files).  In the following
     example, 'sed' tries to read a file named ''hello.txt ; N''.  The
     file is missing, and the error is silently ignored:

          $ echo x | sed '1rhello.txt ; N'
          x

'e' (command execution)

     Any characters following the 'e' command until the end of the line
     will be sent to the shell.  If whitespace, comments or semicolons
     are found, they will be included in the shell command, leading to
     unexpected results:

          $ echo a | sed '1e touch foo#bar'
          a

          $ ls -1
          foo#bar

          $ echo a | sed '1e touch foo ; s/a/b/'
          sh: 1: s/a/b/: not found
          a

's///[we]' (substitute with 'e' or 'w' flags)

     In a substitution command, the 'w' flag writes the substitution
     result to a file, and the 'e' flag executes the subsitution result
     as a shell command.  As with the 'r/R/w/W/e' commands, these must
     be terminated with a newline.  If whitespace, comments or
     semicolons are found, they will be included in the shell command or
     filename, leading to unexpected results:

          $ echo a | sed 's/a/b/w1.txt#foo'
          b

          $ ls -1
          1.txt#foo


File: sed.info,  Node: sed addresses,  Next: sed regular expressions,  Prev: sed scripts,  Up: Top

# /4 Addresses: selecting lines
*******************************

* Menu:

* Addresses overview::                Addresses overview
* Numeric Addresses::                 selecting lines by numbers
* Regexp Addresses::                  selecting lines by text matching
* Range Addresses::                   selecting a range of lines


File: sed.info,  Node: Addresses overview,  Next: Numeric Addresses,  Up: sed addresses

4.1 Addresses overview
======================

Addresses determine on which line(s) the 'sed' command will be executed.
The following command replaces the word 'hello' with 'world' only on
line 144:

     sed '144s/hello/world/' input.txt > output.txt

   If no addresses are given, the command is performed on all lines.
The following command replaces the word 'hello' with 'world' on all
lines in the input file:

     sed 's/hello/world/' input.txt > output.txt

   Addresses can contain regular expressions to match lines based on
content instead of line numbers.  The following command replaces the
word 'hello' with 'world' only in lines containing the word 'apple':

     sed '/apple/s/hello/world/' input.txt > output.txt

   An address range is specified with two addresses separated by a comma
(',').  Addresses can be numeric, regular expressions, or a mix of both.
The following command replaces the word 'hello' with 'world' only in
lines 4 to 17 (inclusive):

     sed '4,17s/hello/world/' input.txt > output.txt

   Appending the '!' character to the end of an address specification
(before the command letter) negates the sense of the match.  That is, if
the '!' character follows an address or an address range, then only
lines which do _not_ match the addresses will be selected.  The
following command replaces the word 'hello' with 'world' only in lines
_not_ containing the word 'apple':

     sed '/apple/!s/hello/world/' input.txt > output.txt

   The following command replaces the word 'hello' with 'world' only in
lines 1 to 3 and 18 till the last line of the input file (i.e.
excluding lines 4 to 17):

     sed '4,17!s/hello/world/' input.txt > output.txt


File: sed.info,  Node: Numeric Addresses,  Next: Regexp Addresses,  Prev: Addresses overview,  Up: sed addresses

4.2 Selecting lines by numbers
==============================

Addresses in a 'sed' script can be in any of the following forms:
'NUMBER'
     Specifying a line number will match only that line in the input.
     (Note that 'sed' counts lines continuously across all input files
     unless '-i' or '-s' options are specified.)

'$'
     This address matches the last line of the last file of input, or
     the last line of each file when the '-i' or '-s' options are
     specified.

'FIRST~STEP'
     This GNU extension matches every STEPth line starting with line
     FIRST.  In particular, lines will be selected when there exists a
     non-negative N such that the current line-number equals FIRST + (N
     * STEP).  Thus, one would use '1~2' to select the odd-numbered
     lines and '0~2' for even-numbered lines; to pick every third line
     starting with the second, '2~3' would be used; to pick every fifth
     line starting with the tenth, use '10~5'; and '50~0' is just an
     obscure way of saying '50'.

     The following commands demonstrate the step address usage:

          $ seq 10 | sed -n '0~4p'
          4
          8

          $ seq 10 | sed -n '1~3p'
          1
          4
          7
          10


File: sed.info,  Node: Regexp Addresses,  Next: Range Addresses,  Prev: Numeric Addresses,  Up: sed addresses

4.3 selecting lines by text matching
====================================

GNU 'sed' supports the following regular expression addresses.  The
default regular expression is *note* Basic Regular Expression (BRE): BRE
syntax.  If '-E' or '-r' options are used, The regular expression should
be in *note* Extended Regular Expression (ERE): ERE syntax. syntax.
*Note* BRE vs ERE::.

'/REGEXP/'
     This will select any line which matches the regular expression
     REGEXP.  If REGEXP itself includes any '/' characters, each must be
     escaped by a backslash ('\').

     The following command prints lines in '/etc/passwd' which end with
     'bash'(1):

          sed -n '/bash$/p' /etc/passwd

     The empty regular expression '//' repeats the last regular
     expression match (the same holds if the empty regular expression is
     passed to the 's' command).  Note that modifiers to regular
     expressions are evaluated when the regular expression is compiled,
     thus it is invalid to specify them together with the empty regular
     expression.

'\%REGEXP%'
     (The '%' may be replaced by any other single character.)

     This also matches the regular expression REGEXP, but allows one to
     use a different delimiter than '/'.  This is particularly useful if
     the REGEXP itself contains a lot of slashes, since it avoids the
     tedious escaping of every '/'.  If REGEXP itself includes any
     delimiter characters, each must be escaped by a backslash ('\').

     The following commands are equivalent.  They print lines which
     start with '/home/alice/documents/':

          sed -n '/^\/home\/alice\/documents\//p'
          sed -n '\%^/home/alice/documents/%p'
          sed -n '\;^/home/alice/documents/;p'

'/REGEXP/I'
'\%REGEXP%I'
     The 'I' modifier to regular-expression matching is a GNU extension
     which causes the REGEXP to be matched in a case-insensitive manner.

     In many other programming languages, a lower case 'i' is used for
     case-insensitive regular expression matching.  However, in 'sed'
     the 'i' is used for the insert command (*note* insert command::).

     Observe the difference between the following examples.

     In this example, '/b/I' is the address: regular expression with 'I'
     modifier.  'd' is the delete command:

          $ printf "%s\n" a b c | sed '/b/Id'
          a
          c

     Here, '/b/' is the address: a regular expression.  'i' is the
     insert command.  'd' is the value to insert.  A line with 'd' is
     then inserted above the matched line:

          $ printf "%s\n" a b c | sed '/b/id'
          a
          d
          b
          c

'/REGEXP/M'
'\%REGEXP%M'
     The 'M' modifier to regular-expression matching is a GNU 'sed'
     extension which directs GNU 'sed' to match the regular expression
     in 'multi-line' mode.  The modifier causes '^' and '$' to match
     respectively (in addition to the normal behavior) the empty string
     after a newline, and the empty string before a newline.  There are
     special character sequences ('\`' and '\'') which always match the
     beginning or the end of the buffer.  In addition, the period
     character does not match a new-line character in multi-line mode.

   Regex addresses operate on the content of the current pattern space.
If the pattern space is changed (for example with 's///' command) the
regular expression matching will operate on the changed text.

   In the following example, automatic printing is disabled with '-n'.
The 's/2/X/' command changes lines containing '2' to 'X'.  The command
'/[0-9]/p' matches lines with digits and prints them.  Because the
second line is changed before the '/[0-9]/' regex, it will not match and
will not be printed:

     $ seq 3 | sed -n 's/2/X/ ; /[0-9]/p'
     1
     3

   ---------- Footnotes ----------

   (1) There are of course many other ways to do the same, e.g.
     grep 'bash$' /etc/passwd
     awk -F: '$7 == "/bin/bash"' /etc/passwd


File: sed.info,  Node: Range Addresses,  Prev: Regexp Addresses,  Up: sed addresses

4.4 Range Addresses
===================

An address range can be specified by specifying two addresses separated
by a comma (',').  An address range matches lines starting from where
the first address matches, and continues until the second address
matches (inclusively):

     $ seq 10 | sed -n '4,6p'
     4
     5
     6

   If the second address is a REGEXP, then checking for the ending match
will start with the line _following_ the line which matched the first
address: a range will always span at least two lines (except of course
if the input stream ends).

     $ seq 10 | sed -n '4,/[0-9]/p'
     4
     5

   If the second address is a NUMBER less than (or equal to) the line
matching the first address, then only the one line is matched:

     $ seq 10 | sed -n '4,1p'
     4

   GNU 'sed' also supports some special two-address forms; all these are
GNU extensions:
'0,/REGEXP/'
     A line number of '0' can be used in an address specification like
     '0,/REGEXP/' so that 'sed' will try to match REGEXP in the first
     input line too.  In other words, '0,/REGEXP/' is similar to
     '1,/REGEXP/', except that if ADDR2 matches the very first line of
     input the '0,/REGEXP/' form will consider it to end the range,
     whereas the '1,/REGEXP/' form will match the beginning of its range
     and hence make the range span up to the _second_ occurrence of the
     regular expression.

     Note that this is the only place where the '0' address makes sense;
     there is no 0-th line and commands which are given the '0' address
     in any other way will give an error.

     The following examples demonstrate the difference between starting
     with address 1 and 0:

          $ seq 10 | sed -n '1,/[0-9]/p'
          1
          2

          $ seq 10 | sed -n '0,/[0-9]/p'
          1

'ADDR1,+N'
     Matches ADDR1 and the N lines following ADDR1.

          $ seq 10 | sed -n '6,+2p'
          6
          7
          8

     ADDR1 can be a line number or a regular expression.

'ADDR1,~N'
     Matches ADDR1 and the lines following ADDR1 until the next line
     whose input line number is a multiple of N.  The following command
     prints starting at line 6, until the next line which is a multiple
     of 4 (i.e.  line 8):

          $ seq 10 | sed -n '6,~4p'
          6
          7
          8

     ADDR1 can be a line number or a regular expression.


File: sed.info,  Node: sed regular expressions,  Next: advanced sed,  Prev: sed addresses,  Up: Top

# /5 Regular Expressions: selecting text
****************************************

* Menu:

* Regular Expressions Overview:: Overview of Regular expression in 'sed'
* BRE vs ERE::               Basic (BRE) and extended (ERE) regular expression
                             syntax
* BRE syntax::               Overview of basic regular expression syntax
* ERE syntax::               Overview of extended regular expression syntax
* Character Classes and Bracket Expressions::
* regexp extensions::        Additional regular expression commands
* Back-references and Subexpressions:: Back-references and Subexpressions
* Escapes::                  Specifying special characters
* Locale Considerations::    Multibyte characters and locale considrations


File: sed.info,  Node: Regular Expressions Overview,  Next: BRE vs ERE,  Up: sed regular expressions

5.1 Overview of regular expression in 'sed'
===========================================

To know how to use 'sed', people should understand regular expressions
("regexp" for short).  A regular expression is a pattern that is matched
against a subject string from left to right.  Most characters are
"ordinary": they stand for themselves in a pattern, and match the
corresponding characters.  Regular expressions in 'sed' are specified
between two slashes.

   The following command prints lines containing the word 'hello':

     sed -n '/hello/p'

   The above example is equivalent to this 'grep' command:

     grep 'hello'

   The power of regular expressions comes from the ability to include
alternatives and repetitions in the pattern.  These are encoded in the
pattern by the use of "special characters", which do not stand for
themselves but instead are interpreted in some special way.

   The character '^' (caret) in a regular expression matches the
beginning of the line.  The character '.' (dot) matches any single
character.  The following 'sed' command matches and prints lines which
start with the letter 'b', followed by any single character, followed by
the letter 'd':

     $ printf "%s\n" abode bad bed bit bid byte body | sed -n '/^b.d/p'
     bad
     bed
     bid
     body

   The following sections explain the meaning and usage of special
characters in regular expressions.


File: sed.info,  Node: BRE vs ERE,  Next: BRE syntax,  Prev: Regular Expressions Overview,  Up: sed regular expressions

5.2 Basic (BRE) and extended (ERE) regular expression
=====================================================

Basic and extended regular expressions are two variations on the syntax
of the specified pattern.  Basic Regular Expression (BRE) syntax is the
default in 'sed' (and similarly in 'grep').  Use the POSIX-specified
'-E' option ('-r', '--regexp-extended') to enable Extended Regular
Expression (ERE) syntax.

   In GNU 'sed', the only difference between basic and extended regular
expressions is in the behavior of a few special characters: '?', '+',
parentheses, braces ('{}'), and '|'.

   With basic (BRE) syntax, these characters do not have special meaning
unless prefixed with a backslash ('\'); While with extended (ERE) syntax
it is reversed: these characters are special unless they are prefixed
with backslash ('\').

Desired pattern      Basic (BRE) Syntax         Extended (ERE) Syntax
                                                
--------------------------------------------------------------------------
literal '+' (plus         $ echo 'a+b=c' > foo       $ echo 'a+b=c' > foo
sign)                     $ sed -n '/a+b/p' foo      $ sed -E -n '/a\+b/p' foo
                          a+b=c                      a+b=c
                                                
One or more 'a'           $ echo aab > foo           $ echo aab > foo
characters                $ sed -n '/a\+b/p' foo     $ sed -E -n '/a+b/p' foo
followed by 'b'           aab                        aab
(plus sign as                                   
special
meta-character)


File: sed.info,  Node: BRE syntax,  Next: ERE syntax,  Prev: BRE vs ERE,  Up: sed regular expressions

5.3 Overview of basic regular expression syntax
===============================================

Here is a brief description of regular expression syntax as used in
'sed'.

'CHAR'
     A single ordinary character matches itself.

'*'
     Matches a sequence of zero or more instances of matches for the
     preceding regular expression, which must be an ordinary character,
     a special character preceded by '\', a '.', a grouped regexp (see
     below), or a bracket expression.  As a GNU extension, a postfixed
     regular expression can also be followed by '*'; for example, 'a**'
     is equivalent to 'a*'.  POSIX 1003.1-2001 says that '*' stands for
     itself when it appears at the start of a regular expression or
     subexpression, but many nonGNU implementations do not support this
     and portable scripts should instead use '\*' in these contexts.
'.'
     Matches any character, including newline.

'^'
     Matches the null string at beginning of the pattern space, i.e.
     what appears after the circumflex must appear at the beginning of
     the pattern space.

     In most scripts, pattern space is initialized to the content of
     each line (*note* How 'sed' works: Execution Cycle.).  So, it is a
     useful simplification to think of '^#include' as matching only
     lines where '#include' is the first thing on line--if there are
     spaces before, for example, the match fails.  This simplification
     is valid as long as the original content of pattern space is not
     modified, for example with an 's' command.

     '^' acts as a special character only at the beginning of the
     regular expression or subexpression (that is, after '\(' or '\|').
     Portable scripts should avoid '^' at the beginning of a
     subexpression, though, as POSIX allows implementations that treat
     '^' as an ordinary character in that context.

'$'
     It is the same as '^', but refers to end of pattern space.  '$'
     also acts as a special character only at the end of the regular
     expression or subexpression (that is, before '\)' or '\|'), and its
     use at the end of a subexpression is not portable.

'[LIST]'
'[^LIST]'
     Matches any single character in LIST: for example, '[aeiou]'
     matches all vowels.  A list may include sequences like
     'CHAR1-CHAR2', which matches any character between (inclusive)
     CHAR1 and CHAR2.  *Note* Character Classes and Bracket
     Expressions::.

'\+'
     As '*', but matches one or more.  It is a GNU extension.

'\?'
     As '*', but only matches zero or one.  It is a GNU extension.

'\{I\}'
     As '*', but matches exactly I sequences (I is a decimal integer;
     for portability, keep it between 0 and 255 inclusive).

'\{I,J\}'
     Matches between I and J, inclusive, sequences.

'\{I,\}'
     Matches more than or equal to I sequences.

'\(REGEXP\)'
     Groups the inner REGEXP as a whole, this is used to:

        * Apply postfix operators, like '\(abcd\)*': this will search
          for zero or more whole sequences of 'abcd', while 'abcd*'
          would search for 'abc' followed by zero or more occurrences of
          'd'.  Note that support for '\(abcd\)*' is required by POSIX
          1003.1-2001, but many non-GNU implementations do not support
          it and hence it is not universally portable.

        * Use back references (see below).

'REGEXP1\|REGEXP2'
     Matches either REGEXP1 or REGEXP2.  Use parentheses to use complex
     alternative regular expressions.  The matching process tries each
     alternative in turn, from left to right, and the first one that
     succeeds is used.  It is a GNU extension.

'REGEXP1REGEXP2'
     Matches the concatenation of REGEXP1 and REGEXP2.  Concatenation
     binds more tightly than '\|', '^', and '$', but less tightly than
     the other regular expression operators.

'\DIGIT'
     Matches the DIGIT-th '\(...\)' parenthesized subexpression in the
     regular expression.  This is called a "back reference".
     Subexpressions are implicitly numbered by counting occurrences of
     '\(' left-to-right.

'\n'
     Matches the newline character.

'\CHAR'
     Matches CHAR, where CHAR is one of '$', '*', '.', '[', '\', or '^'.
     Note that the only C-like backslash sequences that you can portably
     assume to be interpreted are '\n' and '\\'; in particular '\t' is
     not portable, and matches a 't' under most implementations of
     'sed', rather than a tab character.

   Note that the regular expression matcher is greedy, i.e., matches are
attempted from left to right and, if two or more matches are possible
starting at the same character, it selects the longest.

Examples:
'abcdef'
     Matches 'abcdef'.

'a*b'
     Matches zero or more 'a's followed by a single 'b'.  For example,
     'b' or 'aaaaab'.

'a\?b'
     Matches 'b' or 'ab'.

'a\+b\+'
     Matches one or more 'a's followed by one or more 'b's: 'ab' is the
     shortest possible match, but other examples are 'aaaab' or 'abbbbb'
     or 'aaaaaabbbbbbb'.

'.*'
'.\+'
     These two both match all the characters in a string; however, the
     first matches every string (including the empty string), while the
     second matches only strings containing at least one character.

'^main.*(.*)'
     This matches a string starting with 'main', followed by an opening
     and closing parenthesis.  The 'n', '(' and ')' need not be
     adjacent.

'^#'
     This matches a string beginning with '#'.

'\\$'
     This matches a string ending with a single backslash.  The regexp
     contains two backslashes for escaping.

'\$'
     Instead, this matches a string consisting of a single dollar sign,
     because it is escaped.

'[a-zA-Z0-9]'
     In the C locale, this matches any ASCII letters or digits.

'[^ '<TAB>']\+'
     (Here '<TAB>' stands for a single tab character.)  This matches a
     string of one or more characters, none of which is a space or a
     tab.  Usually this means a word.

'^\(.*\)\n\1$'
     This matches a string consisting of two equal substrings separated
     by a newline.

'.\{9\}A$'
     This matches nine characters followed by an 'A' at the end of a
     line.

'^.\{15\}A'
     This matches the start of a string that contains 16 characters, the
     last of which is an 'A'.


File: sed.info,  Node: ERE syntax,  Next: Character Classes and Bracket Expressions,  Prev: BRE syntax,  Up: sed regular expressions

5.4 Overview of extended regular expression syntax
==================================================

The only difference between basic and extended regular expressions is in
the behavior of a few characters: '?', '+', parentheses, braces ('{}'),
and '|'.  While basic regular expressions require these to be escaped if
you want them to behave as special characters, when using extended
regular expressions you must escape them if you want them _to match a
literal character_.  '|' is special here because '\|' is a GNU extension
- standard basic regular expressions do not provide its functionality.

Examples:
'abc?'
     becomes 'abc\?' when using extended regular expressions.  It
     matches the literal string 'abc?'.

'c\+'
     becomes 'c+' when using extended regular expressions.  It matches
     one or more 'c's.

'a\{3,\}'
     becomes 'a{3,}' when using extended regular expressions.  It
     matches three or more 'a's.

'\(abc\)\{2,3\}'
     becomes '(abc){2,3}' when using extended regular expressions.  It
     matches either 'abcabc' or 'abcabcabc'.

'\(abc*\)\1'
     becomes '(abc*)\1' when using extended regular expressions.
     Backreferences must still be escaped when using extended regular
     expressions.

'a\|b'
     becomes 'a|b' when using extended regular expressions.  It matches
     'a' or 'b'.


File: sed.info,  Node: Character Classes and Bracket Expressions,  Next: regexp extensions,  Prev: ERE syntax,  Up: sed regular expressions

5.5 Character Classes and Bracket Expressions
=============================================

A "bracket expression" is a list of characters enclosed by '[' and ']'.
It matches any single character in that list; if the first character of
the list is the caret '^', then it matches any character *not* in the
list.  For example, the following command replaces the words 'gray' or
'grey' with 'blue':

     sed  's/gr[ae]y/blue/'

   Bracket expressions can be used in both *note* basic: BRE syntax. and
*note* extended: ERE syntax. regular expressions (that is, with or
without the '-E'/'-r' options).

   Within a bracket expression, a "range expression" consists of two
characters separated by a hyphen.  It matches any single character that
sorts between the two characters, inclusive.  In the default C locale,
the sorting sequence is the native character order; for example, '[a-d]'
is equivalent to '[abcd]'.

   Finally, certain named classes of characters are predefined within
bracket expressions, as follows.

   These named classes must be used _inside_ brackets themselves.
Correct usage:
     $ echo 1 | sed 's/[[:digit:]]/X/'
     X

   Incorrect usage is rejected by newer 'sed' versions.  Older versions
accepted it but treated it as a single bracket expression (which is
equivalent to '[dgit:]', that is, only the characters D/G/I/T/:):
     # current GNU sed versions - incorrect usage rejected
     $ echo 1 | sed 's/[:digit:]/X/'
     sed: character class syntax is [[:space:]], not [:space:]

     # older GNU sed versions
     $ echo 1 | sed 's/[:digit:]/X/'
     1

'[:alnum:]'
     Alphanumeric characters: '[:alpha:]' and '[:digit:]'; in the 'C'
     locale and ASCII character encoding, this is the same as
     '[0-9A-Za-z]'.

'[:alpha:]'
     Alphabetic characters: '[:lower:]' and '[:upper:]'; in the 'C'
     locale and ASCII character encoding, this is the same as
     '[A-Za-z]'.

'[:blank:]'
     Blank characters: space and tab.

'[:cntrl:]'
     Control characters.  In ASCII, these characters have octal codes
     000 through 037, and 177 (DEL). In other character sets, these are
     the equivalent characters, if any.

'[:digit:]'
     Digits: '0 1 2 3 4 5 6 7 8 9'.

'[:graph:]'
     Graphical characters: '[:alnum:]' and '[:punct:]'.

'[:lower:]'
     Lower-case letters; in the 'C' locale and ASCII character encoding,
     this is 'a b c d e f g h i j k l m n o p q r s t u v w x y z'.

'[:print:]'
     Printable characters: '[:alnum:]', '[:punct:]', and space.

'[:punct:]'
     Punctuation characters; in the 'C' locale and ASCII character
     encoding, this is '! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \
     ] ^ _ ` { | } ~'.

'[:space:]'
     Space characters: in the 'C' locale, this is tab, newline, vertical
     tab, form feed, carriage return, and space.

'[:upper:]'
     Upper-case letters: in the 'C' locale and ASCII character encoding,
     this is 'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'.

'[:xdigit:]'
     Hexadecimal digits: '0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f'.

   Note that the brackets in these class names are part of the symbolic
names, and must be included in addition to the brackets delimiting the
bracket expression.

   Most meta-characters lose their special meaning inside bracket
expressions:

']'
     ends the bracket expression if it's not the first list item.  So,
     if you want to make the ']' character a list item, you must put it
     first.

'-'
     represents the range if it's not first or last in a list or the
     ending point of a range.

'^'
     represents the characters not in the list.  If you want to make the
     '^' character a list item, place it anywhere but first.

   TODO: incorporate this paragraph (copied verbatim from BRE section).

   The characters '$', '*', '.', '[', and '\' are normally not special
within LIST.  For example, '[\*]' matches either '\' or '*', because the
'\' is not special here.  However, strings like '[.ch.]', '[=a=]', and
'[:space:]' are special within LIST and represent collating symbols,
equivalence classes, and character classes, respectively, and '[' is
therefore special within LIST when it is followed by '.', '=', or ':'.
Also, when not in 'POSIXLY_CORRECT' mode, special escapes like '\n' and
'\t' are recognized within LIST.  *Note* Escapes::.

'[.'
     represents the open collating symbol.

'.]'
     represents the close collating symbol.

'[='
     represents the open equivalence class.

'=]'
     represents the close equivalence class.

'[:'
     represents the open character class symbol, and should be followed
     by a valid character class name.

':]'
     represents the close character class symbol.


File: sed.info,  Node: regexp extensions,  Next: Back-references and Subexpressions,  Prev: Character Classes and Bracket Expressions,  Up: sed regular expressions

5.6 regular expression extensions
=================================

The following sequences have special meaning inside regular expressions
(used in *note* addresses: Regexp Addresses. and the 's' command).

   These can be used in both *note* basic: BRE syntax. and *note
extended: ERE syntax. regular expressions (that is, with or without the
'-E'/'-r' options).

'\w'
     Matches any "word" character.  A "word" character is any letter or
     digit or the underscore character.

          $ echo "abc %-= def." | sed 's/\w/X/g'
          XXX %-= XXX.

'\W'
     Matches any "non-word" character.

          $ echo "abc %-= def." | sed 's/\W/X/g'
          abcXXXXXdefX

'\b'
     Matches a word boundary; that is it matches if the character to the
     left is a "word" character and the character to the right is a
     "non-word" character, or vice-versa.

          $ echo "abc %-= def." | sed 's/\b/X/g'
          XabcX %-= XdefX.

'\B'
     Matches everywhere but on a word boundary; that is it matches if
     the character to the left and the character to the right are either
     both "word" characters or both "non-word" characters.

          $ echo "abc %-= def." | sed 's/\B/X/g'
          aXbXc X%X-X=X dXeXf.X

'\s'
     Matches whitespace characters (spaces and tabs).  Newlines embedded
     in the pattern/hold spaces will also match:

          $ echo "abc %-= def." | sed 's/\s/X/g'
          abcX%-=Xdef.

'\S'
     Matches non-whitespace characters.

          $ echo "abc %-= def." | sed 's/\S/X/g'
          XXX XXX XXXX

'\<'
     Matches the beginning of a word.

          $ echo "abc %-= def." | sed 's/\</X/g'
          Xabc %-= Xdef.

'\>'
     Matches the end of a word.

          $ echo "abc %-= def." | sed 's/\>/X/g'
          abcX %-= defX.

'\`'
     Matches only at the start of pattern space.  This is different from
     '^' in multi-line mode.

     Compare the following two examples:

          $ printf "a\nb\nc\n" | sed 'N;N;s/^/X/gm'
          Xa
          Xb
          Xc

          $ printf "a\nb\nc\n" | sed 'N;N;s/\`/X/gm'
          Xa
          b
          c

'\''
     Matches only at the end of pattern space.  This is different from
     '$' in multi-line mode.


File: sed.info,  Node: Back-references and Subexpressions,  Next: Escapes,  Prev: regexp extensions,  Up: sed regular expressions

5.7 Back-references and Subexpressions
======================================

"back-references" are regular expression commands which refer to a
previous part of the matched regular expression.  Back-references are
specified with backslash and a single digit (e.g.  '\1').  The part of
the regular expression they refer to is called a "subexpression", and is
designated with parentheses.

   Back-references and subexpressions are used in two cases: in the
regular expression search pattern, and in the REPLACEMENT part of the
's' command (*note* Regular Expression Addresses: Regexp Addresses. and
*note* The "s" Command::).

   In a regular expression pattern, back-references are used to match
the same content as a previously matched subexpression.  In the
following example, the subexpression is '.' - any single character
(being surrounded by parentheses makes it a subexpression).  The
back-reference '\1' asks to match the same content (same character) as
the sub-expression.

   The command below matches words starting with any character, followed
by the letter 'o', followed by the same character as the first.

     $ sed -E -n '/^(.)o\1$/p' /usr/share/dict/words
     bob
     mom
     non
     pop
     sos
     tot
     wow

   Multiple subexpressions are automatically numbered from
left-to-right.  This command searches for 6-letter palindromes (the
first three letters are 3 subexpressions, followed by 3 back-references
in reverse order):

     $ sed -E -n '/^(.)(.)(.)\3\2\1$/p' /usr/share/dict/words
     redder

   In the 's' command, back-references can be used in the REPLACEMENT
part to refer back to subexpressions in the REGEXP part.

   The following example uses two subexpressions in the regular
expression to match two space-separated words.  The back-references in
the REPLACEMENT part prints the words in a different order:

     $ echo "James Bond" | sed -E 's/(.*) (.*)/The name is \2, \1 \2./'
     The name is Bond, James Bond.

   When used with alternation, if the group does not participate in the
match then the back-reference makes the whole match fail.  For example,
'a(.)|b\1' will not match 'ba'.  When multiple regular expressions are
given with '-e' or from a file ('-f FILE'), back-references are local to
each expression.


File: sed.info,  Node: Escapes,  Next: Locale Considerations,  Prev: Back-references and Subexpressions,  Up: sed regular expressions

5.8 Escape Sequences - specifying special characters
====================================================

Until this chapter, we have only encountered escapes of the form '\^',
which tell 'sed' not to interpret the circumflex as a special character,
but rather to take it literally.  For example, '\*' matches a single
asterisk rather than zero or more backslashes.

   This chapter introduces another kind of escape(1)--that is, escapes
that are applied to a character or sequence of characters that
ordinarily are taken literally, and that 'sed' replaces with a special
character.  This provides a way of encoding non-printable characters in
patterns in a visible manner.  There is no restriction on the appearance
of non-printing characters in a 'sed' script but when a script is being
prepared in the shell or by text editing, it is usually easier to use
one of the following escape sequences than the binary character it
represents:

   The list of these escapes is:

'\a'
     Produces or matches a BEL character, that is an "alert" (ASCII 7).

'\f'
     Produces or matches a form feed (ASCII 12).

'\n'
     Produces or matches a newline (ASCII 10).

'\r'
     Produces or matches a carriage return (ASCII 13).

'\t'
     Produces or matches a horizontal tab (ASCII 9).

'\v'
     Produces or matches a so called "vertical tab" (ASCII 11).

'\cX'
     Produces or matches 'CONTROL-X', where X is any character.  The
     precise effect of '\cX' is as follows: if X is a lower case letter,
     it is converted to upper case.  Then bit 6 of the character (hex
     40) is inverted.  Thus '\cz' becomes hex 1A, but '\c{' becomes hex
     3B, while '\c;' becomes hex 7B.

'\dXXX'
     Produces or matches a character whose decimal ASCII value is XXX.

'\oXXX'
     Produces or matches a character whose octal ASCII value is XXX.

'\xXX'
     Produces or matches a character whose hexadecimal ASCII value is
     XX.

   '\b' (backspace) was omitted because of the conflict with the
existing "word boundary" meaning.

5.8.1 Escaping Precedence
-------------------------

GNU 'sed' processes escape sequences _before_ passing the text onto the
regular-expression matching of the 's///' command and Address matching.
Thus the follwing two commands are equivalent ('0x5e' is the hexadecimal
ASCII value of the character '^'):

     $ echo 'a^c' | sed 's/^/b/'
     ba^c

     $ echo 'a^c' | sed 's/\x5e/b/'
     ba^c

   As are the following ('0x5b','0x5d' are the hexadecimal ASCII values
of '[',']', respectively):

     $ echo abc | sed 's/[a]/x/'
     Xbc
     $ echo abc | sed 's/\x5ba\x5d/x/'
     Xbc

   However it is recommended to avoid such special characters due to
unexpected edge-cases.  For example, the following are not equivalent:

     $ echo 'a^c' | sed 's/\^/b/'
     abc

     $ echo 'a^c' | sed 's/\\\x5e/b/'
     a^c

   ---------- Footnotes ----------

   (1) All the escapes introduced here are GNU extensions, with the
exception of '\n'.  In basic regular expression mode, setting
'POSIXLY_CORRECT' disables them inside bracket expressions.


File: sed.info,  Node: Locale Considerations,  Prev: Escapes,  Up: sed regular expressions

5.9 Multibyte characters and Locale Considerations
==================================================

GNU 'sed' processes valid multibyte characters in multibyte locales
(e.g.  'UTF-8').  (1)

The following example uses the Greek letter Capital Sigma (U+03A3,
Unicode code point '0x03A3').  In a 'UTF-8' locale, 'sed' correctly
processes the Sigma as one character despite it being 2 octets (bytes):

     $ locale | grep LANG
     LANG=en_US.UTF-8

     $ printf 'a\u03A3b'
     aU+03A3b

     $ printf 'a\u03A3b' | sed 's/./X/g'
     XXX

     $ printf 'a\u03A3b' | od -tx1 -An
      61 ce a3 62

To force 'sed' to process octets separately, use the 'C' locale (also
known as the 'POSIX' locale):

     $ printf 'a\u03A3b' | LC_ALL=C sed 's/./X/g'
     XXXX

5.9.1 Invalid multibyte characters
----------------------------------

'sed''s regular expressions _do not_ match invalid multibyte sequences
in a multibyte locale.

In the following examples, the ascii value '0xCE' is an incomplete
multibyte character (shown here as U+FFFD). The regular expression '.'
does not match it:

     $ printf 'a\xCEb\n'
     aU+FFFDe

     $ printf 'a\xCEb\n' | sed 's/./X/g'
     XU+FFFDX

     $ printf 'a\xCEc\n' | sed 's/./X/g' | od -tx1c -An
       58  ce  58  0a
        X      X   \n

Similarly, the 'catch-all' regular expression '.*' does not match the
entire line:

     $ printf 'a\xCEc\n' | sed 's/.*//' | od -tx1c -An
       ce  63  0a
            c  \n

GNU 'sed' offers the special 'z' command to clear the current pattern
space regardless of invalid multibyte characters (i.e.  it works like
's/.*//' but also removes invalid multibyte characters):

     $ printf 'a\xCEc\n' | sed 'z' | od -tx1c -An
        0a
        \n

Alternatively, force the 'C' locale to process each octet separately
(every octet is a valid character in the 'C' locale):

     $ printf 'a\xCEc\n' | LC_ALL=C sed 's/.*//' | od -tx1c -An
       0a
       \n

   'sed''s inability to process invalid multibyte characters can be used
to detect such invalid sequences in a file.  In the following examples,
the '\xCE\xCE' is an invalid multibyte sequence, while '\xCE\A3' is a
valid multibyte sequence (of the Greek Sigma character).

The following 'sed' program removes all valid characters using 's/.//g'.
Any content left in the pattern space (the invalid characters) are added
to the hold space using the 'H' command.  On the last line ('$'), the
hold space is retrieved ('x'), newlines are removed ('s/\n//g'), and any
remaining octets are printed unambiguously ('l').  Thus, any invalid
multibyte sequences are printed as octal values:

     $ printf 'ab\nc\n\xCE\xCEde\n\xCE\xA3f\n' > invalid.txt

     $ cat invalid.txt
     ab
     c
     U+FFFDU+FFFDde
     U+03A3f

     $ sed -n 's/.//g ; H ; ${x;s/\n//g;l}' invalid.txt
     \316\316$

With a few more commands, 'sed' can print the exact line number
corresponding to each invalid characters (line 3).  These characters can
then be removed by forcing the 'C' locale and using octal escape
sequences:

     $ sed -n 's/.//g;=;l' invalid.txt | paste - -  | awk '$2!="$"'
     3       \316\316$

     $ LC_ALL=C sed '3s/\o316\o316//' invalid.txt > fixed.txt

5.9.2 Upper/Lower case conversion
---------------------------------

GNU 'sed''s substitute command ('s') supports upper/lower case
conversions using '\U','\L' codes.  These conversions support multibyte
characters:

     $ printf 'ABC\u03a3\n'
     ABCU+03A3

     $ printf 'ABC\u03a3\n' | sed 's/.*/\L&/'
     abcU+03C3

*Note* The "s" Command::.

5.9.3 Multibyte regexp character classes
----------------------------------------

In other locales, the sorting sequence is not specified, and '[a-d]'
might be equivalent to '[abcd]' or to '[aBbCcDd]', or it might fail to
match any character, or the set of characters that it matches might even
be erratic.  To obtain the traditional interpretation of bracket
expressions, you can use the 'C' locale by setting the 'LC_ALL'
environment variable to the value 'C'.

     # TODO: is there any real-world system/locale where 'A'
     #       is replaced by '-' ?
     $ echo A | sed 's/[a-z]/-/'
     A

   Their interpretation depends on the 'LC_CTYPE' locale; for example,
'[[:alnum:]]' means the character class of numbers and letters in the
current locale.

   TODO: show example of collation

     # TODO: this works on glibc systems, not on musl-libc/freebsd/macosx.
     $ printf 'cliché\n' | LC_ALL=fr_FR.utf8 sed 's/[[=e=]]/X/g'
     clichX

   ---------- Footnotes ----------

   (1) Some regexp edge-cases depends on the operating system and libc
implementation.  The examples shown are known to work as-expected on
GNU/Linux systems using glibc.


File: sed.info,  Node: advanced sed,  Next: Examples,  Prev: sed regular expressions,  Up: Top

# /6 Advanced 'sed': cycles and buffers
***************************************

* Menu:

* Execution Cycle::          How 'sed' works
* Hold and Pattern Buffers::
* Multiline techniques::     Using D,G,H,N,P to process multiple lines
* Branching and flow control::


File: sed.info,  Node: Execution Cycle,  Next: Hold and Pattern Buffers,  Up: advanced sed

6.1 How 'sed' Works
===================

'sed' maintains two data buffers: the active _pattern_ space, and the
auxiliary _hold_ space.  Both are initially empty.

   'sed' operates by performing the following cycle on each line of
input: first, 'sed' reads one line from the input stream, removes any
trailing newline, and places it in the pattern space.  Then commands are
executed; each command can have an address associated to it: addresses
are a kind of condition code, and a command is only executed if the
condition is verified before the command is to be executed.

   When the end of the script is reached, unless the '-n' option is in
use, the contents of pattern space are printed out to the output stream,
adding back the trailing newline if it was removed.(1)  Then the next
cycle starts for the next input line.

   Unless special commands (like 'D') are used, the pattern space is
deleted between two cycles.  The hold space, on the other hand, keeps
its data between cycles (see commands 'h', 'H', 'x', 'g', 'G' to move
data between both buffers).

   ---------- Footnotes ----------

   (1) Actually, if 'sed' prints a line without the terminating newline,
it will nevertheless print the missing newline as soon as more text is
sent to the same output stream, which gives the "least expected
surprise" even though it does not make commands like 'sed -n p' exactly
identical to 'cat'.


File: sed.info,  Node: Hold and Pattern Buffers,  Next: Multiline techniques,  Prev: Execution Cycle,  Up: advanced sed

6.2 Hold and Pattern Buffers
============================

TODO


File: sed.info,  Node: Multiline techniques,  Next: Branching and flow control,  Prev: Hold and Pattern Buffers,  Up: advanced sed

6.3 Multiline techniques - using D,G,H,N,P to process multiple lines
====================================================================

Multiple lines can be processed as one buffer using the
'D','G','H','N','P'.  They are similar to their lowercase counterparts
('d','g', 'h','n','p'), except that these commands append or subtract
data while respecting embedded newlines - allowing adding and removing
lines from the pattern and hold spaces.

   They operate as follows:
'D'
     _deletes_ line from the pattern space until the first newline, and
     restarts the cycle.

'G'
     _appends_ line from the hold space to the pattern space, with a
     newline before it.

'H'
     _appends_ line from the pattern space to the hold space, with a
     newline before it.

'N'
     _appends_ line from the input file to the pattern space.

'P'
     _prints_ line from the pattern space until the first newline.

   The following example illustrates the operation of 'N' and 'D'
commands:

     $ seq 6 | sed -n 'N;l;D'
     1\n2$
     2\n3$
     3\n4$
     4\n5$
     5\n6$

  1. 'sed' starts by reading the first line into the pattern space (i.e.
     '1').
  2. At the beginning of every cycle, the 'N' command appends a newline
     and the next line to the pattern space (i.e.  '1', '\n', '2' in the
     first cycle).
  3. The 'l' command prints the content of the pattern space
     unambiguously.
  4. The 'D' command then removes the content of pattern space up to the
     first newline (leaving '2' at the end of the first cycle).
  5. At the next cycle the 'N' command appends a newline and the next
     input line to the pattern space (e.g.  '2', '\n', '3').

   A common technique to process blocks of text such as paragraphs
(instead of line-by-line) is using the following construct:

     sed '/./{H;$!d} ; x ; s/REGEXP/REPLACEMENT/'

  1. The first expression, '/./{H;$!d}' operates on all non-empty lines,
     and adds the current line (in the pattern space) to the hold space.
     On all lines except the last, the pattern space is deleted and the
     cycle is restarted.

  2. The other expressions 'x' and 's' are executed only on empty lines
     (i.e.  paragraph separators).  The 'x' command fetches the
     accumulated lines from the hold space back to the pattern space.
     The 's///' command then operates on all the text in the paragraph
     (including the embedded newlines).

   The following example demonstrates this technique:
     $ cat input.txt
     a a a aa aaa
     aaaa aaaa aa
     aaaa aaa aaa

     bbbb bbb bbb
     bb bb bbb bb
     bbbbbbbb bbb

     ccc ccc cccc
     cccc ccccc c
     cc cc cc cc

     $ sed '/./{H;$!d} ; x ; s/^/\nSTART-->/ ; s/$/\n<--END/' input.txt

     START-->
     a a a aa aaa
     aaaa aaaa aa
     aaaa aaa aaa
     <--END

     START-->
     bbbb bbb bbb
     bb bb bbb bb
     bbbbbbbb bbb
     <--END

     START-->
     ccc ccc cccc
     cccc ccccc c
     cc cc cc cc
     <--END

   For more annotated examples, *note* Text search across multiple
lines:: and *note* Line length adjustment::.


File: sed.info,  Node: Branching and flow control,  Prev: Multiline techniques,  Up: advanced sed

6.4 Branching and Flow Control
==============================

The branching commands 'b', 't', and 'T' enable changing the flow of
'sed' programs.

   By default, 'sed' reads an input line into the pattern buffer, then
continues to processes all commands in order.  Commands without
addresses affect all lines.  Commands with addresses affect only
matching lines.  *Note* Execution Cycle:: and *note* Addresses overview::.

   'sed' does not support a typical 'if/then' construct.  Instead, some
commands can be used as conditionals or to change the default flow
control:

'd'
     delete (clears) the current pattern space, and restart the program
     cycle without processing the rest of the commands and without
     printing the pattern space.

'D'
     delete the contents of the pattern space _up to the first newline_,
     and restart the program cycle without processing the rest of the
     commands and without printing the pattern space.

'[addr]X'
'[addr]{ X ; X ; X }'
'/regexp/X'
'/regexp/{ X ; X ; X }'
     Addresses and regular expressions can be used as an 'if/then'
     conditional: If [ADDR] matches the current pattern space, execute
     the command(s).  For example: The command '/^#/d' means: _if_ the
     current pattern matches the regular expression '^#' (a line
     starting with a hash), _then_ execute the 'd' command: delete the
     line without printing it, and restart the program cycle
     immediately.

'b'
     branch unconditionally (that is: always jump to a label, skipping
     or repeating other commands, without restarting a new cycle).
     Combined with an address, the branch can be conditionally executed
     on matched lines.

't'
     branch conditionally (that is: jump to a label) _only if_ a 's///'
     command has succeeded since the last input line was read or another
     conditional branch was taken.

'T'
     similar but opposite to the 't' command: branch only if there has
     been _no_ successful substitutions since the last input line was
     read.

   The following two 'sed' programs are equivalent.  The first
(contrived) example uses the 'b' command to skip the 's///' command on
lines containing '1'.  The second example uses an address with negation
('!') to perform substitution only on desired lines.  The 'y///' command
is still executed on all lines:

     $ printf '%s\n' a1 a2 a3 | sed -E '/1/bx ; s/a/z/ ; :x ; y/123/456/'
     a4
     z5
     z6

     $ printf '%s\n' a1 a2 a3 | sed -E '/1/!s/a/z/ ; y/123/456/'
     a4
     z5
     z6

6.4.1 Branching and Cycles
--------------------------

The 'b','t' and 'T' commands can be followed by a label (typically a
single letter).  Labels are defined with a colon followed by one or more
letters (e.g.  ':x').  If the label is omitted the branch commands
restart the cycle.  Note the difference between branching to a label and
restarting the cycle: when a cycle is restarted, 'sed' first prints the
current content of the pattern space, then reads the next input line
into the pattern space; Jumping to a label (even if it is at the
beginning of the program) does not print the pattern space and does not
read the next input line.

   The following program is a no-op.  The 'b' command (the only command
in the program) does not have a label, and thus simply restarts the
cycle.  On each cycle, the pattern space is printed and the next input
line is read:

     $ seq 3 | sed b
     1
     2
     3

   The following example is an infinite-loop - it doesn't terminate and
doesn't print anything.  The 'b' command jumps to the 'x' label, and a
new cycle is never started:

     $ seq 3 | sed ':x ; bx'

     # The above command requires gnu sed (which supports additional
     # commands following a label, without a newline). A portable equivalent:
     #     sed -e ':x' -e bx

   Branching is often complemented with the 'n' or 'N' commands: both
commands read the next input line into the pattern space without waiting
for the cycle to restart.  Before reading the next input line, 'n'
prints the current pattern space then empties it, while 'N' appends a
newline and the next input line to the pattern space.

   Consider the following two examples:

     $ seq 3 | sed ':x ; n ; bx'
     1
     2
     3

     $ seq 3 | sed ':x ; N ; bx'
     1
     2
     3

   * Both examples do not inf-loop, despite never starting a new cycle.

   * In the first example, the 'n' commands first prints the content of
     the pattern space, empties the pattern space then reads the next
     input line.

   * In the second example, the 'N' commands appends the next input line
     to the pattern space (with a newline).  Lines are accumulated in
     the pattern space until there are no more input lines to read, then
     the 'N' command terminates the 'sed' program.  When the program
     terminates, the end-of-cycle actions are performed, and the entire
     pattern space is printed.

   * The second example requires GNU 'sed', because it uses the
     non-POSIX-standard behavior of 'N'.  See the "'N' command on the
     last line" paragraph in *note* Reporting Bugs::.

   * To further examine the difference between the two examples, try the
     following commands:
          printf '%s\n' aa bb cc dd | sed ':x ; n ; = ; bx'
          printf '%s\n' aa bb cc dd | sed ':x ; N ; = ; bx'
          printf '%s\n' aa bb cc dd | sed ':x ; n ; s/\n/***/ ; bx'
          printf '%s\n' aa bb cc dd | sed ':x ; N ; s/\n/***/ ; bx'

6.4.2 Branching example: joining lines
--------------------------------------

As a real-world example of using branching, consider the case of
quoted-printable (https://en.wikipedia.org/wiki/Quoted-printable) files,
typically used to encode email messages.  In these files long lines are
split and marked with a "soft line break" consisting of a single '='
character at the end of the line:

     $ cat jaques.txt
     All the wor=
     ld's a stag=
     e,
     And all the=
      men and wo=
     men merely =
     players:
     They have t=
     heir exits =
     and their e=
     ntrances;
     And one man=
      in his tim=
     e plays man=
     y parts.

   The following program uses an address match '/=$/' as a conditional:
If the current pattern space ends with a '=', it reads the next input
line using 'N', replaces all '=' characters which are followed by a
newline, and unconditionally branches ('b') to the beginning of the
program without restarting a new cycle.  If the pattern space does not
ends with '=', the default action is performed: the pattern space is
printed and a new cycle is started:

     $ sed ':x ; /=$/ { N ; s/=\n//g ; bx }' jaques.txt
     All the world's a stage,
     And all the men and women merely players:
     They have their exits and their entrances;
     And one man in his time plays many parts.

   Here's an alternative program with a slightly different approach: On
all lines except the last, 'N' appends the line to the pattern space.  A
substitution command then removes soft line breaks ('=' at the end of a
line, i.e.  followed by a newline) by replacing them with an empty
string.  _if_ the substitution was successful (meaning the pattern space
contained a line which should be joined), The conditional branch command
't' jumps to the beginning of the program without completing or
restarting the cycle.  If the substitution failed (meaning there were no
soft line breaks), The 't' command will _not_ branch.  Then, 'P' will
print the pattern space content until the first newline, and 'D' will
delete the pattern space content until the first new line.  (To learn
more about 'N', 'P' and 'D' commands *note* Multiline techniques::).

     $ sed ':x ; $!N ; s/=\n// ; tx ; P ; D' jaques.txt
     All the world's a stage,
     And all the men and women merely players:
     They have their exits and their entrances;
     And one man in his time plays many parts.

   For more line-joining examples *note* Joining lines::.


File: sed.info,  Node: Examples,  Next: Limitations,  Prev: advanced sed,  Up: Top

# /7 Some Sample Scripts
************************

Here are some 'sed' scripts to guide you in the art of mastering 'sed'.

* Menu:


Useful one-liners:
* Joining lines::

Some exotic examples:
* Centering lines::
* Increment a number::
* Rename files to lower case::
* Print bash environment::
* Reverse chars of lines::
* Text search across multiple lines::
* Line length adjustment::

Emulating standard utilities:
* tac::                             Reverse lines of files
* cat -n::                          Numbering lines
* cat -b::                          Numbering non-blank lines
* wc -c::                           Counting chars
* wc -w::                           Counting words
* wc -l::                           Counting lines
* head::                            Printing the first lines
* tail::                            Printing the last lines
* uniq::                            Make duplicate lines unique
* uniq -d::                         Print duplicated lines of input
* uniq -u::                         Remove all duplicated lines
* cat -s::                          Squeezing blank lines


File: sed.info,  Node: Joining lines,  Next: Centering lines,  Up: Examples

7.1 Joining lines
=================

This section uses 'N', 'D' and 'P' commands to process multiple lines,
and the 'b' and 't' commands for branching.  *Note* Multiline
techniques:: and *note* Branching and flow control::.

   Join specific lines (e.g.  if lines 2 and 3 need to be joined):

     $ cat lines.txt
     hello
     hel
     lo
     hello

     $ sed '2{N;s/\n//;}' lines.txt
     hello
     hello
     hello

   Join backslash-continued lines:

     $ cat 1.txt
     this \
     is \
     a \
     long \
     line
     and another \
     line

     $ sed -e ':x /\\$/ { N; s/\\\n//g ; bx }'  1.txt
     this is a long line
     and another line


     #TODO: The above requires gnu sed.
     #      non-gnu seds need newlines after ':' and 'b'

   Join lines that start with whitespace (e.g SMTP headers):

     $ cat 2.txt
     Subject: Hello
         World
     Content-Type: multipart/alternative;
         boundary=94eb2c190cc6370f06054535da6a
     Date: Tue, 3 Jan 2017 19:41:16 +0000 (GMT)
     Authentication-Results: mx.gnu.org;
            dkim=pass header.i=@gnu.org;
            spf=pass
     Message-ID: <abcdef@gnu.org>
     From: John Doe <jdoe@gnu.org>
     To: Jane Smith <jsmith@gnu.org>

     $ sed -E ':a ; $!N ; s/\n\s+/ / ; ta ; P ; D' 2.txt
     Subject: Hello World
     Content-Type: multipart/alternative; boundary=94eb2c190cc6370f06054535da6a
     Date: Tue, 3 Jan 2017 19:41:16 +0000 (GMT)
     Authentication-Results: mx.gnu.org; dkim=pass header.i=@gnu.org; spf=pass
     Message-ID: <abcdef@gnu.org>
     From: John Doe <jdoe@gnu.org>
     To: Jane Smith <jsmith@gnu.org>

     # A portable (non-gnu) variation:
     #   sed -e :a -e '$!N;s/\n  */ /;ta' -e 'P;D'


File: sed.info,  Node: Centering lines,  Next: Increment a number,  Prev: Joining lines,  Up: Examples

7.2 Centering Lines
===================

This script centers all lines of a file on a 80 columns width.  To
change that width, the number in '\{...\}' must be replaced, and the
number of added spaces also must be changed.

   Note how the buffer commands are used to separate parts in the
regular expressions to be matched--this is a common technique.

     #!/usr/bin/sed -f

     # Put 80 spaces in the buffer
     1 {
       x
       s/^$/          /
       s/^.*$/&&&&&&&&/
       x
     }

     # delete leading and trailing spaces
     y/<TAB>/ /
     s/^ *//
     s/ *$//

     # add a newline and 80 spaces to end of line
     G

     # keep first 81 chars (80 + a newline)
     s/^\(.\{81\}\).*$/\1/

     # \2 matches half of the spaces, which are moved to the beginning
     s/^\(.*\)\n\(.*\)\2/\2\1/


File: sed.info,  Node: Increment a number,  Next: Rename files to lower case,  Prev: Centering lines,  Up: Examples

7.3 Increment a Number
======================

This script is one of a few that demonstrate how to do arithmetic in
'sed'.  This is indeed possible,(1) but must be done manually.

   To increment one number you just add 1 to last digit, replacing it by
the following digit.  There is one exception: when the digit is a nine
the previous digits must be also incremented until you don't have a
nine.

   This solution by Bruno Haible is very clever and smart because it
uses a single buffer; if you don't have this limitation, the algorithm
used in *note* Numbering lines: cat -n, is faster.  It works by replacing
trailing nines with an underscore, then using multiple 's' commands to
increment the last digit, and then again substituting underscores with
zeros.

     #!/usr/bin/sed -f

     /[^0-9]/ d

     # replace all trailing 9s by _ (any other character except digits, could
     # be used)
     :d
     s/9\(_*\)$/_\1/
     td

     # incr last digit only.  The first line adds a most-significant
     # digit of 1 if we have to add a digit.

     s/^\(_*\)$/1\1/; tn
     s/8\(_*\)$/9\1/; tn
     s/7\(_*\)$/8\1/; tn
     s/6\(_*\)$/7\1/; tn
     s/5\(_*\)$/6\1/; tn
     s/4\(_*\)$/5\1/; tn
     s/3\(_*\)$/4\1/; tn
     s/2\(_*\)$/3\1/; tn
     s/1\(_*\)$/2\1/; tn
     s/0\(_*\)$/1\1/; tn

     :n
     y/_/0/

   ---------- Footnotes ----------

   (1) 'sed' guru Greg Ubben wrote an implementation of the 'dc' RPN
calculator!  It is distributed together with sed.


File: sed.info,  Node: Rename files to lower case,  Next: Print bash environment,  Prev: Increment a number,  Up: Examples

7.4 Rename Files to Lower Case
==============================

This is a pretty strange use of 'sed'.  We transform text, and transform
it to be shell commands, then just feed them to shell.  Don't worry,
even worse hacks are done when using 'sed'; I have seen a script
converting the output of 'date' into a 'bc' program!

   The main body of this is the 'sed' script, which remaps the name from
lower to upper (or vice-versa) and even checks out if the remapped name
is the same as the original name.  Note how the script is parameterized
using shell variables and proper quoting.

     #! /bin/sh
     # rename files to lower/upper case...
     #
     # usage:
     #    move-to-lower *
     #    move-to-upper *
     # or
     #    move-to-lower -R .
     #    move-to-upper -R .
     #

     help()
     {
             cat << eof
     Usage: $0 [-n] [-r] [-h] files...

     -n      do nothing, only see what would be done
     -R      recursive (use find)
     -h      this message
     files   files to remap to lower case

     Examples:
            $0 -n *        (see if everything is ok, then...)
            $0 *

            $0 -R .

     eof
     }

     apply_cmd='sh'
     finder='echo "$@" | tr " " "\n"'
     files_only=

     while :
     do
         case "$1" in
             -n) apply_cmd='cat' ;;
             -R) finder='find "$@" -type f';;
             -h) help ; exit 1 ;;
             *) break ;;
         esac
         shift
     done

     if [ -z "$1" ]; then
             echo Usage: $0 [-h] [-n] [-r] files...
             exit 1
     fi

     LOWER='abcdefghijklmnopqrstuvwxyz'
     UPPER='ABCDEFGHIJKLMNOPQRSTUVWXYZ'

     case `basename $0` in
             *upper*) TO=$UPPER; FROM=$LOWER ;;
             *)       FROM=$UPPER; TO=$LOWER ;;
     esac

     eval $finder | sed -n '

     # remove all trailing slashes
     s/\/*$//

     # add ./ if there is no path, only a filename
     /\//! s/^/.\//

     # save path+filename
     h

     # remove path
     s/.*\///

     # do conversion only on filename
     y/'$FROM'/'$TO'/

     # now line contains original path+file, while
     # hold space contains the new filename
     x

     # add converted file name to line, which now contains
     # path/file-name\nconverted-file-name
     G

     # check if converted file name is equal to original file name,
     # if it is, do not print anything
     /^.*\/\(.*\)\n\1/b

     # escape special characters for the shell
     s/["$`\\]/\\&/g

     # now, transform path/fromfile\n, into
     # mv path/fromfile path/tofile and print it
     s/^\(.*\/\)\(.*\)\n\(.*\)$/mv "\1\2" "\1\3"/p

     ' | $apply_cmd


File: sed.info,  Node: Print bash environment,  Next: Reverse chars of lines,  Prev: Rename files to lower case,  Up: Examples

7.5 Print 'bash' Environment
============================

This script strips the definition of the shell functions from the output
of the 'set' Bourne-shell command.

     #!/bin/sh

     set | sed -n '
     :x

     # if no occurrence of "=()" print and load next line
     /=()/! { p; b; }
     / () $/! { p; b; }

     # possible start of functions section
     # save the line in case this is a var like FOO="() "
     h

     # if the next line has a brace, we quit because
     # nothing comes after functions
     n
     /^{/ q

     # print the old line
     x; p

     # work on the new line now
     x; bx
     '


File: sed.info,  Node: Reverse chars of lines,  Next: Text search across multiple lines,  Prev: Print bash environment,  Up: Examples

7.6 Reverse Characters of Lines
===============================

This script can be used to reverse the position of characters in lines.
The technique moves two characters at a time, hence it is faster than
more intuitive implementations.

   Note the 'tx' command before the definition of the label.  This is
often needed to reset the flag that is tested by the 't' command.

   Imaginative readers will find uses for this script.  An example is
reversing the output of 'banner'.(1)

     #!/usr/bin/sed -f

     /../! b

     # Reverse a line.  Begin embedding the line between two newlines
     s/^.*$/\
     &\
     /

     # Move first character at the end.  The regexp matches until
     # there are zero or one characters between the markers
     tx
     :x
     s/\(\n.\)\(.*\)\(.\n\)/\3\2\1/
     tx

     # Remove the newline markers
     s/\n//g

   ---------- Footnotes ----------

   (1) This requires another script to pad the output of banner; for
example

     #! /bin/sh

     banner -w $1 $2 $3 $4 |
       sed -e :a -e '/^.\{0,'$1'\}$/ { s/$/ /; ba; }' |
       ~/sedscripts/reverseline.sed


File: sed.info,  Node: Text search across multiple lines,  Next: Line length adjustment,  Prev: Reverse chars of lines,  Up: Examples

7.7 Text search across multiple lines
=====================================

This section uses 'N' and 'D' commands to search for consecutive words
spanning multiple lines.  *Note* Multiline techniques::.

   These examples deal with finding doubled occurrences of words in a
document.

   Finding doubled words in a single line is easy using GNU 'grep' and
similarly with GNU 'sed':

     $ cat two-cities-dup1.txt
     It was the best of times,
     it was the worst of times,
     it was the the age of wisdom,
     it was the age of foolishness,

     $ grep -E '\b(\w+)\s+\1\b' two-cities-dup1.txt
     it was the the age of wisdom,

     $ grep -n -E '\b(\w+)\s+\1\b' two-cities-dup1.txt
     3:it was the the age of wisdom,

     $ sed -En '/\b(\w+)\s+\1\b/p' two-cities-dup1.txt
     it was the the age of wisdom,

     $ sed -En '/\b(\w+)\s+\1\b/{=;p}' two-cities-dup1.txt
     3
     it was the the age of wisdom,

   * The regular expression '\b\w+\s+' searches for word-boundary
     ('\b'), followed by one-or-more word-characters ('\w+'), followed
     by whitespace ('\s+').  *Note* regexp extensions::.

   * Adding parentheses around the '(\w+)' expression creates a
     subexpression.  The regular expression pattern '(PATTERN)\s+\1'
     defines a subexpression (in the parentheses) followed by a
     back-reference, separated by whitespace.  A successful match means
     the PATTERN was repeated twice in succession.  *Note
     Back-references and Subexpressions::.

   * The word-boundery expression ('\b') at both ends ensures partial
     words are not matched (e.g.  'the then' is not a desired match).

   * The '-E' option enables extended regular expression syntax,
     alleviating the need to add backslashes before the parenthesis.
     *Note* ERE syntax::.

   When the doubled word span two lines the above regular expression
will not find them as 'grep' and 'sed' operate line-by-line.

   By using 'N' and 'D' commands, 'sed' can apply regular expressions on
multiple lines (that is, multiple lines are stored in the pattern space,
and the regular expression works on it):

     $ cat two-cities-dup2.txt
     It was the best of times, it was the
     worst of times, it was the
     the age of wisdom,
     it was the age of foolishness,

     $ sed -En '{N; /\b(\w+)\s+\1\b/{=;p} ; D}'  two-cities-dup2.txt
     3
     worst of times, it was the
     the age of wisdom,

   * The 'N' command appends the next line to the pattern space (thus
     ensuring it contains two consecutive lines in every cycle).

   * The regular expression uses '\s+' for word separator which matches
     both spaces and newlines.

   * The regular expression matches, the entire pattern space is printed
     with 'p'.  No lines are printed by default due to the '-n' option.

   * The 'D' removes the first line from the pattern space (up until the
     first newline), readying it for the next cycle.

   See the GNU 'coreutils' manual for an alternative solution using 'tr
-s' and 'uniq' at
<https://gnu.org/s/coreutils/manual/html_node/Squeezing-and-deleting.html>.


File: sed.info,  Node: Line length adjustment,  Next: tac,  Prev: Text search across multiple lines,  Up: Examples

7.8 Line length adjustment
==========================

This section uses 'N' and 'D' commands to search for consecutive words
spanning multiple lines, and the 'b' command for branching.  *Note
Multiline techniques:: and *note* Branching and flow control::.

   This (somewhat contrived) example deal with formatting and wrapping
lines of text of the following input file:

     $ cat two-cities-mix.txt
     It was the best of times, it was
     the worst of times, it
     was the age of
     wisdom,
     it
     was
     the age
     of foolishness,

The following sed program wraps lines at 40 characters:
     $ cat wrap40.sed
     # outer loop
     :x

     # Appead a newline followed by the next input line to the pattern buffer
     N

     # Remove all newlines from the pattern buffer
     s/\n/ /g


     # Inner loop
     :y

     # Add a newline after the first 40 characters
     s/(.{40,40})/\1\n/

     # If there is a newline in the pattern buffer
     # (i.e. the previous substitution added a newline)
     /\n/ {
         # There are newlines in the pattern buffer -
         # print the content until the first newline.
         P

        # Remove the printed characters and the first newline
        s/.*\n//

        # branch to label 'y' - repeat inner loop
        by
      }

     # No newlines in the pattern buffer - Branch to label 'x' (outer loop)
     # and read the next input line
     bx

The wrapped output:
     $ sed -E -f wrap40.sed two-cities-mix.txt
     It was the best of times, it was the wor
     st of times, it was the age of wisdom, i
     t was the age of foolishness,


File: sed.info,  Node: tac,  Next: cat -n,  Prev: Line length adjustment,  Up: Examples

7.9 Reverse Lines of Files
==========================

This one begins a series of totally useless (yet interesting) scripts
emulating various Unix commands.  This, in particular, is a 'tac'
workalike.

   Note that on implementations other than GNU 'sed' this script might
easily overflow internal buffers.

     #!/usr/bin/sed -nf

     # reverse all lines of input, i.e. first line became last, ...

     # from the second line, the buffer (which contains all previous lines)
     # is *appended* to current line, so, the order will be reversed
     1! G

     # on the last line we're done -- print everything
     $ p

     # store everything on the buffer again
     h


File: sed.info,  Node: cat -n,  Next: cat -b,  Prev: tac,  Up: Examples

7.10 Numbering Lines
====================

This script replaces 'cat -n'; in fact it formats its output exactly
like GNU 'cat' does.

   Of course this is completely useless and for two reasons: first,
because somebody else did it in C, second, because the following
Bourne-shell script could be used for the same purpose and would be much
faster:

     #! /bin/sh
     sed -e "=" $@ | sed -e '
       s/^/      /
       N
       s/^ *\(......\)\n/\1  /
     '

   It uses 'sed' to print the line number, then groups lines two by two
using 'N'.  Of course, this script does not teach as much as the one
presented below.

   The algorithm used for incrementing uses both buffers, so the line is
printed as soon as possible and then discarded.  The number is split so
that changing digits go in a buffer and unchanged ones go in the other;
the changed digits are modified in a single step (using a 'y' command).
The line number for the next line is then composed and stored in the
hold space, to be used in the next iteration.

     #!/usr/bin/sed -nf

     # Prime the pump on the first line
     x
     /^$/ s/^.*$/1/

     # Add the correct line number before the pattern
     G
     h

     # Format it and print it
     s/^/      /
     s/^ *\(......\)\n/\1  /p

     # Get the line number from hold space; add a zero
     # if we're going to add a digit on the next line
     g
     s/\n.*$//
     /^9*$/ s/^/0/

     # separate changing/unchanged digits with an x
     s/.9*$/x&/

     # keep changing digits in hold space
     h
     s/^.*x//
     y/0123456789/1234567890/
     x

     # keep unchanged digits in pattern space
     s/x.*$//

     # compose the new number, remove the newline implicitly added by G
     G
     s/\n//
     h


File: sed.info,  Node: cat -b,  Next: wc -c,  Prev: cat -n,  Up: Examples

7.11 Numbering Non-blank Lines
==============================

Emulating 'cat -b' is almost the same as 'cat -n'--we only have to
select which lines are to be numbered and which are not.

   The part that is common to this script and the previous one is not
commented to show how important it is to comment 'sed' scripts
properly...

     #!/usr/bin/sed -nf

     /^$/ {
       p
       b
     }

     # Same as cat -n from now
     x
     /^$/ s/^.*$/1/
     G
     h
     s/^/      /
     s/^ *\(......\)\n/\1  /p
     x
     s/\n.*$//
     /^9*$/ s/^/0/
     s/.9*$/x&/
     h
     s/^.*x//
     y/0123456789/1234567890/
     x
     s/x.*$//
     G
     s/\n//
     h


File: sed.info,  Node: wc -c,  Next: wc -w,  Prev: cat -b,  Up: Examples

7.12 Counting Characters
========================

This script shows another way to do arithmetic with 'sed'.  In this case
we have to add possibly large numbers, so implementing this by
successive increments would not be feasible (and possibly even more
complicated to contrive than this script).

   The approach is to map numbers to letters, kind of an abacus
implemented with 'sed'.  'a's are units, 'b's are tens and so on: we
simply add the number of characters on the current line as units, and
then propagate the carry to tens, hundreds, and so on.

   As usual, running totals are kept in hold space.

   On the last line, we convert the abacus form back to decimal.  For
the sake of variety, this is done with a loop rather than with some 80
's' commands(1): first we convert units, removing 'a's from the number;
then we rotate letters so that tens become 'a's, and so on until no more
letters remain.

     #!/usr/bin/sed -nf

     # Add n+1 a's to hold space (+1 is for the newline)
     s/./a/g
     H
     x
     s/\n/a/

     # Do the carry.  The t's and b's are not necessary,
     # but they do speed up the thing
     t a
     : a;  s/aaaaaaaaaa/b/g; t b; b done
     : b;  s/bbbbbbbbbb/c/g; t c; b done
     : c;  s/cccccccccc/d/g; t d; b done
     : d;  s/dddddddddd/e/g; t e; b done
     : e;  s/eeeeeeeeee/f/g; t f; b done
     : f;  s/ffffffffff/g/g; t g; b done
     : g;  s/gggggggggg/h/g; t h; b done
     : h;  s/hhhhhhhhhh//g

     : done
     $! {
       h
       b
     }

     # On the last line, convert back to decimal

     : loop
     /a/! s/[b-h]*/&0/
     s/aaaaaaaaa/9/
     s/aaaaaaaa/8/
     s/aaaaaaa/7/
     s/aaaaaa/6/
     s/aaaaa/5/
     s/aaaa/4/
     s/aaa/3/
     s/aa/2/
     s/a/1/

     : next
     y/bcdefgh/abcdefg/
     /[a-h]/ b loop
     p

   ---------- Footnotes ----------

   (1) Some implementations have a limit of 199 commands per script


File: sed.info,  Node: wc -w,  Next: wc -l,  Prev: wc -c,  Up: Examples

7.13 Counting Words
===================

This script is almost the same as the previous one, once each of the
words on the line is converted to a single 'a' (in the previous script
each letter was changed to an 'a').

   It is interesting that real 'wc' programs have optimized loops for
'wc -c', so they are much slower at counting words rather than
characters.  This script's bottleneck, instead, is arithmetic, and hence
the word-counting one is faster (it has to manage smaller numbers).

   Again, the common parts are not commented to show the importance of
commenting 'sed' scripts.

     #!/usr/bin/sed -nf

     # Convert words to a's
     s/[ <TAB>][ <TAB>]*/ /g
     s/^/ /
     s/ [^ ][^ ]*/a /g
     s/ //g

     # Append them to hold space
     H
     x
     s/\n//

     # From here on it is the same as in wc -c.
     /aaaaaaaaaa/! bx;   s/aaaaaaaaaa/b/g
     /bbbbbbbbbb/! bx;   s/bbbbbbbbbb/c/g
     /cccccccccc/! bx;   s/cccccccccc/d/g
     /dddddddddd/! bx;   s/dddddddddd/e/g
     /eeeeeeeeee/! bx;   s/eeeeeeeeee/f/g
     /ffffffffff/! bx;   s/ffffffffff/g/g
     /gggggggggg/! bx;   s/gggggggggg/h/g
     s/hhhhhhhhhh//g
     :x
     $! { h; b; }
     :y
     /a/! s/[b-h]*/&0/
     s/aaaaaaaaa/9/
     s/aaaaaaaa/8/
     s/aaaaaaa/7/
     s/aaaaaa/6/
     s/aaaaa/5/
     s/aaaa/4/
     s/aaa/3/
     s/aa/2/
     s/a/1/
     y/bcdefgh/abcdefg/
     /[a-h]/ by
     p


File: sed.info,  Node: wc -l,  Next: head,  Prev: wc -w,  Up: Examples

7.14 Counting Lines
===================

No strange things are done now, because 'sed' gives us 'wc -l'
functionality for free!!!  Look:

     #!/usr/bin/sed -nf
     $=


File: sed.info,  Node: head,  Next: tail,  Prev: wc -l,  Up: Examples

7.15 Printing the First Lines
=============================

This script is probably the simplest useful 'sed' script.  It displays
the first 10 lines of input; the number of displayed lines is right
before the 'q' command.

     #!/usr/bin/sed -f
     10q


File: sed.info,  Node: tail,  Next: uniq,  Prev: head,  Up: Examples

7.16 Printing the Last Lines
============================

Printing the last N lines rather than the first is more complex but
indeed possible.  N is encoded in the second line, before the bang
character.

   This script is similar to the 'tac' script in that it keeps the final
output in the hold space and prints it at the end:

     #!/usr/bin/sed -nf

     1! {; H; g; }
     1,10 !s/[^\n]*\n//
     $p
     h

   Mainly, the scripts keeps a window of 10 lines and slides it by
adding a line and deleting the oldest (the substitution command on the
second line works like a 'D' command but does not restart the loop).

   The "sliding window" technique is a very powerful way to write
efficient and complex 'sed' scripts, because commands like 'P' would
require a lot of work if implemented manually.

   To introduce the technique, which is fully demonstrated in the rest
of this chapter and is based on the 'N', 'P' and 'D' commands, here is
an implementation of 'tail' using a simple "sliding window."

   This looks complicated but in fact the working is the same as the
last script: after we have kicked in the appropriate number of lines,
however, we stop using the hold space to keep inter-line state, and
instead use 'N' and 'D' to slide pattern space by one line:

     #!/usr/bin/sed -f

     1h
     2,10 {; H; g; }
     $q
     1,9d
     N
     D

   Note how the first, second and fourth line are inactive after the
first ten lines of input.  After that, all the script does is: exiting
on the last line of input, appending the next input line to pattern
space, and removing the first line.


File: sed.info,  Node: uniq,  Next: uniq -d,  Prev: tail,  Up: Examples

7.17 Make Duplicate Lines Unique
================================

This is an example of the art of using the 'N', 'P' and 'D' commands,
probably the most difficult to master.

     #!/usr/bin/sed -f
     h

     :b
     # On the last line, print and exit
     $b
     N
     /^\(.*\)\n\1$/ {
         # The two lines are identical.  Undo the effect of
         # the n command.
         g
         bb
     }

     # If the N command had added the last line, print and exit
     $b

     # The lines are different; print the first and go
     # back working on the second.
     P
     D

   As you can see, we maintain a 2-line window using 'P' and 'D'.  This
technique is often used in advanced 'sed' scripts.


File: sed.info,  Node: uniq -d,  Next: uniq -u,  Prev: uniq,  Up: Examples

7.18 Print Duplicated Lines of Input
====================================

This script prints only duplicated lines, like 'uniq -d'.

     #!/usr/bin/sed -nf

     $b
     N
     /^\(.*\)\n\1$/ {
         # Print the first of the duplicated lines
         s/.*\n//
         p

         # Loop until we get a different line
         :b
         $b
         N
         /^\(.*\)\n\1$/ {
             s/.*\n//
             bb
         }
     }

     # The last line cannot be followed by duplicates
     $b

     # Found a different one.  Leave it alone in the pattern space
     # and go back to the top, hunting its duplicates
     D


File: sed.info,  Node: uniq -u,  Next: cat -s,  Prev: uniq -d,  Up: Examples

7.19 Remove All Duplicated Lines
================================

This script prints only unique lines, like 'uniq -u'.

     #!/usr/bin/sed -f

     # Search for a duplicate line --- until that, print what you find.
     $b
     N
     /^\(.*\)\n\1$/ ! {
         P
         D
     }

     :c
     # Got two equal lines in pattern space.  At the
     # end of the file we simply exit
     $d

     # Else, we keep reading lines with N until we
     # find a different one
     s/.*\n//
     N
     /^\(.*\)\n\1$/ {
         bc
     }

     # Remove the last instance of the duplicate line
     # and go back to the top
     D


File: sed.info,  Node: cat -s,  Prev: uniq -u,  Up: Examples

7.20 Squeezing Blank Lines
==========================

As a final example, here are three scripts, of increasing complexity and
speed, that implement the same function as 'cat -s', that is squeezing
blank lines.

   The first leaves a blank line at the beginning and end if there are
some already.

     #!/usr/bin/sed -f

     # on empty lines, join with next
     # Note there is a star in the regexp
     :x
     /^\n*$/ {
     N
     bx
     }

     # now, squeeze all '\n', this can be also done by:
     # s/^\(\n\)*/\1/
     s/\n*/\
     /

   This one is a bit more complex and removes all empty lines at the
beginning.  It does leave a single blank line at end if one was there.

     #!/usr/bin/sed -f

     # delete all leading empty lines
     1,/^./{
     /./!d
     }

     # on an empty line we remove it and all the following
     # empty lines, but one
     :x
     /./!{
     N
     s/^\n$//
     tx
     }

   This removes leading and trailing blank lines.  It is also the
fastest.  Note that loops are completely done with 'n' and 'b', without
relying on 'sed' to restart the script automatically at the end of a
line.

     #!/usr/bin/sed -nf

     # delete all (leading) blanks
     /./!d

     # get here: so there is a non empty
     :x
     # print it
     p
     # get next
     n
     # got chars? print it again, etc...
     /./bx

     # no, don't have chars: got an empty line
     :z
     # get next, if last line we finish here so no trailing
     # empty lines are written
     n
     # also empty? then ignore it, and get next... this will
     # remove ALL empty lines
     /./!bz

     # all empty lines were deleted/ignored, but we have a non empty.  As
     # what we want to do is to squeeze, insert a blank line artificially
     i\

     bx


File: sed.info,  Node: Limitations,  Next: Other Resources,  Prev: Examples,  Up: Top

# /8 GNU 'sed''s Limitations and Non-limitations
************************************************

For those who want to write portable 'sed' scripts, be aware that some
implementations have been known to limit line lengths (for the pattern
and hold spaces) to be no more than 4000 bytes.  The POSIX standard
specifies that conforming 'sed' implementations shall support at least
8192 byte line lengths.  GNU 'sed' has no built-in limit on line length;
as long as it can 'malloc()' more (virtual) memory, you can feed or
construct lines as long as you like.

   However, recursion is used to handle subpatterns and indefinite
repetition.  This means that the available stack space may limit the
size of the buffer that can be processed by certain patterns.


File: sed.info,  Node: Other Resources,  Next: Reporting Bugs,  Prev: Limitations,  Up: Top

# /9 Other Resources for Learning About 'sed'
*********************************************

For up to date information about GNU 'sed' please visit
<https://www.gnu.org/software/sed/>.

   Send general questions and suggestions to <sed-devel@gnu.org>.  Visit
the mailing list archives for past discussions at
<https://lists.gnu.org/archive/html/sed-devel/>.

   The following resources provide information about 'sed' (both GNU
'sed' and other variations).  Note these not maintained by GNU 'sed'
developers.

   * sed '$HOME': <http://sed.sf.net>

   * sed FAQ: <http://sed.sf.net/sedfaq.html>

   * seder's grabbag: <http://sed.sf.net/grabbag>

   * The 'sed-users' mailing list maintained by Sven Guckes:
     <http://groups.yahoo.com/group/sed-users/> (note this is _not_ the
     GNU 'sed' mailing list).


File: sed.info,  Node: Reporting Bugs,  Next: GNU Free Documentation License,  Prev: Other Resources,  Up: Top

# /10 Reporting Bugs
********************

Email bug reports to <bug-sed@gnu.org>.  Also, please include the output
of 'sed --version' in the body of your report if at all possible.

   Please do not send a bug report like this:

     while building frobme-1.3.4
     $ configure
     error-> sed: file sedscr line 1: Unknown option to 's'

   If GNU 'sed' doesn't configure your favorite package, take a few
extra minutes to identify the specific problem and make a stand-alone
test case.  Unlike other programs such as C compilers, making such test
cases for 'sed' is quite simple.

   A stand-alone test case includes all the data necessary to perform
the test, and the specific invocation of 'sed' that causes the problem.
The smaller a stand-alone test case is, the better.  A test case should
not involve something as far removed from 'sed' as "try to configure
frobme-1.3.4".  Yes, that is in principle enough information to look for
the bug, but that is not a very practical prospect.

   Here are a few commonly reported bugs that are not bugs.

'N' command on the last line

     Most versions of 'sed' exit without printing anything when the 'N'
     command is issued on the last line of a file.  GNU 'sed' prints
     pattern space before exiting unless of course the '-n' command
     switch has been specified.  This choice is by design.

     Default behavior (gnu extension, non-POSIX conforming):
          $ seq 3 | sed N
          1
          2
          3
     To force POSIX-conforming behavior:
          $ seq 3 | sed --posix N
          1
          2

     For example, the behavior of
          sed N foo bar
     would depend on whether foo has an even or an odd number of
     lines(1).  Or, when writing a script to read the next few lines
     following a pattern match, traditional implementations of 'sed'
     would force you to write something like
          /foo/{ $!N; $!N; $!N; $!N; $!N; $!N; $!N; $!N; $!N }
     instead of just
          /foo/{ N;N;N;N;N;N;N;N;N; }

     In any case, the simplest workaround is to use '$d;N' in scripts
     that rely on the traditional behavior, or to set the
     'POSIXLY_CORRECT' variable to a non-empty value.

Regex syntax clashes (problems with backslashes)
     'sed' uses the POSIX basic regular expression syntax.  According to
     the standard, the meaning of some escape sequences is undefined in
     this syntax; notable in the case of 'sed' are '\|', '\+', '\?',
     '\`', '\'', '\<', '\>', '\b', '\B', '\w', and '\W'.

     As in all GNU programs that use POSIX basic regular expressions,
     'sed' interprets these escape sequences as special characters.  So,
     'x\+' matches one or more occurrences of 'x'.  'abc\|def' matches
     either 'abc' or 'def'.

     This syntax may cause problems when running scripts written for
     other 'sed's.  Some 'sed' programs have been written with the
     assumption that '\|' and '\+' match the literal characters '|' and
     '+'.  Such scripts must be modified by removing the spurious
     backslashes if they are to be used with modern implementations of
     'sed', like GNU 'sed'.

     On the other hand, some scripts use s|abc\|def||g to remove
     occurrences of _either_ 'abc' or 'def'.  While this worked until
     'sed' 4.0.x, newer versions interpret this as removing the string
     'abc|def'.  This is again undefined behavior according to POSIX,
     and this interpretation is arguably more robust: older 'sed's, for
     example, required that the regex matcher parsed '\/' as '/' in the
     common case of escaping a slash, which is again undefined behavior;
     the new behavior avoids this, and this is good because the regex
     matcher is only partially under our control.

     In addition, this version of 'sed' supports several escape
     characters (some of which are multi-character) to insert
     non-printable characters in scripts ('\a', '\c', '\d', '\o', '\r',
     '\t', '\v', '\x').  These can cause similar problems with scripts
     written for other 'sed's.

'-i' clobbers read-only files

     In short, 'sed -i' will let you delete the contents of a read-only
     file, and in general the '-i' option (*note* Invocation: Invoking
     sed.) lets you clobber protected files.  This is not a bug, but
     rather a consequence of how the Unix file system works.

     The permissions on a file say what can happen to the data in that
     file, while the permissions on a directory say what can happen to
     the list of files in that directory.  'sed -i' will not ever open
     for writing a file that is already on disk.  Rather, it will work
     on a temporary file that is finally renamed to the original name:
     if you rename or delete files, you're actually modifying the
     contents of the directory, so the operation depends on the
     permissions of the directory, not of the file.  For this same
     reason, 'sed' does not let you use '-i' on a writable file in a
     read-only directory, and will break hard or symbolic links when
     '-i' is used on such a file.

'0a' does not work (gives an error)

     There is no line 0.  0 is a special address that is only used to
     treat addresses like '0,/RE/' as active when the script starts: if
     you write '1,/abc/d' and the first line includes the word 'abc',
     then that match would be ignored because address ranges must span
     at least two lines (barring the end of the file); but what you
     probably wanted is to delete every line up to the first one
     including 'abc', and this is obtained with '0,/abc/d'.

'[a-z]' is case insensitive

     You are encountering problems with locales.  POSIX mandates that
     '[a-z]' uses the current locale's collation order - in C parlance,
     that means using 'strcoll(3)' instead of 'strcmp(3)'.  Some locales
     have a case-insensitive collation order, others don't.

     Another problem is that '[a-z]' tries to use collation symbols.
     This only happens if you are on the GNU system, using GNU libc's
     regular expression matcher instead of compiling the one supplied
     with GNU sed.  In a Danish locale, for example, the regular
     expression '^[a-z]$' matches the string 'aa', because this is a
     single collating symbol that comes after 'a' and before 'b'; 'll'
     behaves similarly in Spanish locales, or 'ij' in Dutch locales.

     To work around these problems, which may cause bugs in shell
     scripts, set the 'LC_COLLATE' and 'LC_CTYPE' environment variables
     to 'C'.

's/.*//' does not clear pattern space

     This happens if your input stream includes invalid multibyte
     sequences.  POSIX mandates that such sequences are _not_ matched by
     '.', so that 's/.*//' will not clear pattern space as you would
     expect.  In fact, there is no way to clear sed's buffers in the
     middle of the script in most multibyte locales (including UTF-8
     locales).  For this reason, GNU 'sed' provides a 'z' command (for
     'zap') as an extension.

     To work around these problems, which may cause bugs in shell
     scripts, set the 'LC_COLLATE' and 'LC_CTYPE' environment variables
     to 'C'.

   ---------- Footnotes ----------

   (1) which is the actual "bug" that prompted the change in behavior


File: sed.info,  Node: GNU Free Documentation License,  Next: Concept Index,  Prev: Reporting Bugs,  Up: Top

# /Appendix A GNU Free Documentation License
********************************************

                     Version 1.3, 3 November 2008

     Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
     <https://fsf.org/>

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document "free" in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.  We
     recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it can
     be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     "Document", below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as "you".  You accept
     the license if you copy, modify or distribute the work in a way
     requiring permission under copyright law.

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document's overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in the
     notice that says that the Document is released under this License.
     If a section does not fit the above definition of Secondary then it
     is not allowed to be designated as Invariant.  The Document may
     contain zero Invariant Sections.  If the Document does not identify
     any Invariant Sections then there are none.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images composed
     of pixels) generic paint programs or (for drawings) some widely
     available drawing editor, and that is suitable for input to text
     formatters or for automatic translation to a variety of formats
     suitable for input to text formatters.  A copy made in an otherwise
     Transparent file format whose markup, or absence of markup, has
     been arranged to thwart or discourage subsequent modification by
     readers is not Transparent.  An image format is not Transparent if
     used for any substantial amount of text.  A copy that is not
     "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and standard-conforming
     simple HTML, PostScript or PDF designed for human modification.
     Examples of transparent image formats include PNG, XCF and JPG.
     Opaque formats include proprietary formats that can be read and
     edited only by proprietary word processors, SGML or XML for which
     the DTD and/or processing tools are not generally available, and
     the machine-generated HTML, PostScript or PDF produced by some word
     processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

     The "publisher" means any person or entity that distributes copies
     of the Document to the public.

     A section "Entitled XYZ" means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     "Acknowledgements", "Dedications", "Endorsements", or "History".)
     To "Preserve the Title" of such a section when you modify the
     Document means that it remains a section "Entitled XYZ" according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow the
     conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document's license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the title
     equally prominent and visible.  You may add other material on the
     covers in addition.  Copying with changes limited to the covers, as
     long as they preserve the title of the Document and satisfy these
     conditions, can be treated as verbatim copying in other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a machine-readable
     Transparent copy along with each Opaque copy, or state in or with
     each Opaque copy a computer-network location from which the general
     network-using public has access to download using public-standard
     network protocols a complete Transparent copy of the Document, free
     of added material.  If you use the latter option, you must take
     reasonably prudent steps, when you begin distribution of Opaque
     copies in quantity, to ensure that this Transparent copy will
     remain thus accessible at the stated location until at least one
     year after the last time you distribute an Opaque copy (directly or
     through your agents or retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of copies,
     to give them a chance to provide you with an updated version of the
     Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with the
     Modified Version filling the role of the Document, thus licensing
     distribution and modification of the Modified Version to whoever
     possesses a copy of it.  In addition, you must do these things in
     the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of previous
          versions (which should, if there were any, be listed in the
          History section of the Document).  You may use the same title
          as a previous version if the original publisher of that
          version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled "History", Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on the
          Title Page.  If there is no section Entitled "History" in the
          Document, create one stating the title, year, authors, and
          publisher of the Document as given on its Title Page, then add
          an item describing the Modified Version as stated in the
          previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in the
          "History" section.  You may omit a network location for a work
          that was published at least four years before the Document
          itself, or if the original publisher of the version it refers
          to gives permission.

       K. For any section Entitled "Acknowledgements" or "Dedications",
          Preserve the Title of the section, and preserve in the section
          all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document, unaltered
          in their text and in their titles.  Section numbers or the
          equivalent are not considered part of the section titles.

       M. Delete any section Entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          "Endorsements" or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option designate
     some or all of these sections as invariant.  To do this, add their
     titles to the list of Invariant Sections in the Modified Version's
     license notice.  These titles must be distinct from any other
     section titles.

     You may add a section Entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties--for example, statements of peer review or that the text
     has been approved by an organization as the authoritative
     definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end of
     the list of Cover Texts in the Modified Version.  Only one passage
     of Front-Cover Text and one of Back-Cover Text may be added by (or
     through arrangements made by) any one entity.  If the Document
     already includes a cover text for the same cover, previously added
     by you or by arrangement made by the same entity you are acting on
     behalf of, you may not add another; but you may replace the old
     one, on explicit permission from the previous publisher that added
     the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination all
     of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     "History" in the various original documents, forming one section
     Entitled "History"; likewise combine any sections Entitled
     "Acknowledgements", and any sections Entitled "Dedications".  You
     must delete all sections Entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the documents
     in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow this
     License in all other respects regarding verbatim copying of that
     document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of a
     storage or distribution medium, is called an "aggregate" if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation's users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document's Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled "Acknowledgements",
     "Dedications", or "History", the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense, or distribute it is void,
     and will automatically terminate your rights under this License.

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly and
     finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from you
     under this License.  If your rights have been terminated and not
     permanently reinstated, receipt of a copy of some or all of the
     same material does not give you any rights to use it.

  10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     <https://www.gnu.org/copyleft/>.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If the
     Document does not specify a version number of this License, you may
     choose any version ever published (not as a draft) by the Free
     Software Foundation.  If the Document specifies that a proxy can
     decide which future versions of this License can be used, that
     proxy's public statement of acceptance of a version permanently
     authorizes you to choose that version for the Document.

  11. RELICENSING

     "Massive Multiauthor Collaboration Site" (or "MMC Site") means any
     World Wide Web server that publishes copyrightable works and also
     provides prominent facilities for anybody to edit those works.  A
     public wiki that anybody can edit is an example of such a server.
     A "Massive Multiauthor Collaboration" (or "MMC") contained in the
     site means any set of copyrightable works thus published on the MMC
     site.

     "CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0
     license published by Creative Commons Corporation, a not-for-profit
     corporation with a principal place of business in San Francisco,
     California, as well as future copyleft versions of that license
     published by that same organization.

     "Incorporate" means to publish or republish a Document, in whole or
     in part, as part of another Document.

     An MMC is "eligible for relicensing" if it is licensed under this
     License, and if all works that were first published under this
     License somewhere other than this MMC, and subsequently
     incorporated in whole or in part into the MMC, (1) had no cover
     texts or invariant sections, and (2) were thus incorporated prior
     to November 1, 2008.

     The operator of an MMC Site may republish an MMC contained in the
     site under CC-BY-SA on the same site at any time before August 1,
     2009, provided the MMC is eligible for relicensing.

ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.3
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the "with...Texts." line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of free
software license, such as the GNU General Public License, to permit
their use in free software.


File: sed.info,  Node: Concept Index,  Next: Command and Option Index,  Prev: GNU Free Documentation License,  Up: Top

# /Concept Index
****************

This is a general index of all issues discussed in this manual, with the
exception of the 'sed' commands and command-line options.

 [index ]
* Menu:

* -e, example:                           Overview.            (line  43)
* -e, example <1>:                       sed script overview. (line  37)
* -expression, example:                  Overview.            (line  43)
* -f, example:                           Overview.            (line  43)
* -f, example <1>:                       sed script overview. (line  37)
* -file, example:                        Overview.            (line  43)
* -i, example:                           Overview.            (line  23)
* -n, example:                           Overview.            (line  30)
* -s, example:                           Overview.            (line  37)
* 0 address:                             Reporting Bugs.      (line 114)
* ;, command separator:                  sed script overview. (line  37)
* a, and semicolons:                     sed script overview. (line  56)
* Additional reading about sed:          Other Resources.     (line  13)
* ADDR1,+N:                              Range Addresses.     (line  31)
* ADDR1,~N:                              Range Addresses.     (line  31)
* address range, example:                sed script overview. (line  23)
* Address, as a regular expression:      Regexp Addresses.    (line  13)
* Address, last line:                    Numeric Addresses.   (line  13)
* Address, numeric:                      Numeric Addresses.   (line   8)
* addresses, excluding:                  Addresses overview.  (line  31)
* Addresses, in sed scripts:             Numeric Addresses.   (line   6)
* addresses, negating:                   Addresses overview.  (line  31)
* addresses, numeric:                    Addresses overview.  (line   6)
* addresses, range:                      Addresses overview.  (line  24)
* addresses, regular expression:         Addresses overview.  (line  18)
* addresses, syntax:                     sed script overview. (line  13)
* alphabetic characters:                 Character Classes and Bracket Expressions.
                                                              (line  49)
* alphanumeric characters:               Character Classes and Bracket Expressions.
                                                              (line  44)
* Append hold space to pattern space:    Other Commands.      (line 284)
* Append next input line to pattern space: Other Commands.    (line 257)
* Append pattern space to hold space:    Other Commands.      (line 276)
* Appending text after a line:           Other Commands.      (line  45)
* b, joining lines with:                 Branching and flow control.
                                                              (line 150)
* b, versus t:                           Branching and flow control.
                                                              (line 150)
* back-reference:                        Back-references and Subexpressions.
                                                              (line   6)
* Backreferences, in regular expressions: The "s" Command.    (line  18)
* blank characters:                      Character Classes and Bracket Expressions.
                                                              (line  54)
* bracket expression:                    Character Classes and Bracket Expressions.
                                                              (line   6)
* Branch to a label, if s/// failed:     Extended Commands.   (line  63)
* Branch to a label, if s/// succeeded:  Programming Commands.
                                                              (line  22)
* Branch to a label, unconditionally:    Programming Commands.
                                                              (line  18)
* branching and n, N:                    Branching and flow control.
                                                              (line 105)
* branching, infinite loop:              Branching and flow control.
                                                              (line  95)
* branching, joining lines:              Branching and flow control.
                                                              (line 150)
* Buffer spaces, pattern and hold:       Execution Cycle.     (line   6)
* Bugs, reporting:                       Reporting Bugs.      (line   6)
* c, and semicolons:                     sed script overview. (line  56)
* case insensitive, regular expression:  Regexp Addresses.    (line  47)
* Case-insensitive matching:             The "s" Command.     (line 117)
* Caveat -- #n on first line:            Common Commands.     (line  20)
* character class:                       Character Classes and Bracket Expressions.
                                                              (line   6)
* character classes:                     Character Classes and Bracket Expressions.
                                                              (line  43)
* classes of characters:                 Character Classes and Bracket Expressions.
                                                              (line  43)
* Command groups:                        Common Commands.     (line  91)
* Comments, in scripts:                  Common Commands.     (line  12)
* Conditional branch:                    Programming Commands.
                                                              (line  22)
* Conditional branch <1>:                Extended Commands.   (line  63)
* control characters:                    Character Classes and Bracket Expressions.
                                                              (line  57)
* Copy hold space into pattern space:    Other Commands.      (line 280)
* Copy pattern space into hold space:    Other Commands.      (line 272)
* cycle, restarting:                     Branching and flow control.
                                                              (line  75)
* d, example:                            sed script overview. (line  23)
* Delete first line from pattern space:  Other Commands.      (line 251)
* digit characters:                      Character Classes and Bracket Expressions.
                                                              (line  62)
* Disabling autoprint, from command line: Command-Line Options.
                                                              (line  23)
* empty regular expression:              Regexp Addresses.    (line  22)
* Emptying pattern space:                Extended Commands.   (line  85)
* Emptying pattern space <1>:            Reporting Bugs.      (line 143)
* Evaluate Bourne-shell commands:        Extended Commands.   (line  12)
* Evaluate Bourne-shell commands, after substitution: The "s" Command.
                                                              (line 108)
* example, address range:                sed script overview. (line  23)
* example, regular expression:           sed script overview. (line  28)
* Exchange hold space with pattern space: Other Commands.     (line 288)
* Excluding lines:                       Addresses overview.  (line  31)
* exit status:                           Exit status.         (line   6)
* exit status, example:                  Exit status.         (line  25)
* Extended regular expressions, choosing: Command-Line Options.
                                                              (line 135)
* Extended regular expressions, syntax:  ERE syntax.          (line   6)
* File name, printing:                   Extended Commands.   (line  30)
* Files to be processed as input:        Command-Line Options.
                                                              (line 181)
* Flow of control in scripts:            Programming Commands.
                                                              (line  11)
* Global substitution:                   The "s" Command.     (line  74)
* GNU extensions, /dev/stderr file:      The "s" Command.     (line 101)
* GNU extensions, /dev/stderr file <1>:  Other Commands.      (line 240)
* GNU extensions, /dev/stdin file:       Other Commands.      (line 227)
* GNU extensions, /dev/stdin file <1>:   Extended Commands.   (line  53)
* GNU extensions, /dev/stdout file:      Command-Line Options.
                                                              (line 189)
* GNU extensions, /dev/stdout file <1>:  The "s" Command.     (line 101)
* GNU extensions, /dev/stdout file <2>:  Other Commands.      (line 240)
* GNU extensions, 0 address:             Range Addresses.     (line  31)
* GNU extensions, 0 address <1>:         Reporting Bugs.      (line 114)
* GNU extensions, 0,ADDR2 addressing:    Range Addresses.     (line  31)
* GNU extensions, ADDR1,+N addressing:   Range Addresses.     (line  31)
* GNU extensions, ADDR1,~N addressing:   Range Addresses.     (line  31)
* GNU extensions, branch if s/// failed: Extended Commands.   (line  63)
* GNU extensions, case modifiers in s commands: The "s" Command.
                                                              (line  29)
* GNU extensions, checking for their presence: Extended Commands.
                                                              (line  69)
* GNU extensions, debug:                 Command-Line Options.
                                                              (line  29)
* GNU extensions, disabling:             Command-Line Options.
                                                              (line 102)
* GNU extensions, emptying pattern space: Extended Commands.  (line  85)
* GNU extensions, emptying pattern space <1>: Reporting Bugs. (line 143)
* GNU extensions, evaluating Bourne-shell commands: The "s" Command.
                                                              (line 108)
* GNU extensions, evaluating Bourne-shell commands <1>: Extended Commands.
                                                              (line  12)
* GNU extensions, extended regular expressions: Command-Line Options.
                                                              (line 135)
* GNU extensions, g and NUMBER modifier: The "s" Command.     (line  80)
* GNU extensions, I modifier:            The "s" Command.     (line 117)
* GNU extensions, I modifier <1>:        Regexp Addresses.    (line  47)
* GNU extensions, in-place editing:      Command-Line Options.
                                                              (line  56)
* GNU extensions, in-place editing <1>:  Reporting Bugs.      (line  95)
* GNU extensions, M modifier:            The "s" Command.     (line 122)
* GNU extensions, M modifier <1>:        Regexp Addresses.    (line  75)
* GNU extensions, modifiers and the empty regular expression: Regexp Addresses.
                                                              (line  22)
* GNU extensions, N~M addresses:         Numeric Addresses.   (line  18)
* GNU extensions, quitting silently:     Extended Commands.   (line  36)
* GNU extensions, R command:             Extended Commands.   (line  53)
* GNU extensions, reading a file a line at a time: Extended Commands.
                                                              (line  53)
* GNU extensions, returning an exit code: Common Commands.    (line  28)
* GNU extensions, returning an exit code <1>: Extended Commands.
                                                              (line  36)
* GNU extensions, setting line length:   Other Commands.      (line 207)
* GNU extensions, special escapes:       Escapes.             (line   6)
* GNU extensions, special escapes <1>:   Reporting Bugs.      (line  88)
* GNU extensions, special two-address forms: Range Addresses. (line  31)
* GNU extensions, subprocesses:          The "s" Command.     (line 108)
* GNU extensions, subprocesses <1>:      Extended Commands.   (line  12)
* GNU extensions, to basic regular expressions: BRE syntax.   (line  13)
* GNU extensions, to basic regular expressions <1>: BRE syntax.
                                                              (line  59)
* GNU extensions, to basic regular expressions <2>: BRE syntax.
                                                              (line  62)
* GNU extensions, to basic regular expressions <3>: BRE syntax.
                                                              (line  77)
* GNU extensions, to basic regular expressions <4>: BRE syntax.
                                                              (line  87)
* GNU extensions, to basic regular expressions <5>: Reporting Bugs.
                                                              (line  61)
* GNU extensions, two addresses supported by most commands: Other Commands.
                                                              (line  61)
* GNU extensions, two addresses supported by most commands <1>: Other Commands.
                                                              (line 115)
* GNU extensions, two addresses supported by most commands <2>: Other Commands.
                                                              (line 204)
* GNU extensions, two addresses supported by most commands <3>: Other Commands.
                                                              (line 236)
* GNU extensions, unlimited line length: Limitations.         (line   6)
* GNU extensions, writing first line to a file: Extended Commands.
                                                              (line  80)
* Goto, in scripts:                      Programming Commands.
                                                              (line  18)
* graphic characters:                    Character Classes and Bracket Expressions.
                                                              (line  65)
* Greedy regular expression matching:    BRE syntax.          (line 113)
* Grouping commands:                     Common Commands.     (line  91)
* hexadecimal digits:                    Character Classes and Bracket Expressions.
                                                              (line  88)
* Hold space, appending from pattern space: Other Commands.   (line 276)
* Hold space, appending to pattern space: Other Commands.     (line 284)
* Hold space, copy into pattern space:   Other Commands.      (line 280)
* Hold space, copying pattern space into: Other Commands.     (line 272)
* Hold space, definition:                Execution Cycle.     (line   6)
* Hold space, exchange with pattern space: Other Commands.    (line 288)
* i, and semicolons:                     sed script overview. (line  56)
* In-place editing:                      Reporting Bugs.      (line  95)
* In-place editing, activating:          Command-Line Options.
                                                              (line  56)
* In-place editing, Perl-style backup file names: Command-Line Options.
                                                              (line  67)
* infinite loop, branching:              Branching and flow control.
                                                              (line  95)
* Inserting text before a line:          Other Commands.      (line 104)
* joining lines with branching:          Branching and flow control.
                                                              (line 150)
* joining quoted-printable lines:        Branching and flow control.
                                                              (line 150)
* labels:                                Branching and flow control.
                                                              (line  75)
* Labels, in scripts:                    Programming Commands.
                                                              (line  14)
* Last line, selecting:                  Numeric Addresses.   (line  13)
* Line length, setting:                  Command-Line Options.
                                                              (line  97)
* Line length, setting <1>:              Other Commands.      (line 207)
* Line number, printing:                 Other Commands.      (line 194)
* Line selection:                        Numeric Addresses.   (line   6)
* Line, selecting by number:             Numeric Addresses.   (line   8)
* Line, selecting by regular expression match: Regexp Addresses.
                                                              (line  13)
* Line, selecting last:                  Numeric Addresses.   (line  13)
* List pattern space:                    Other Commands.      (line 207)
* lower-case letters:                    Character Classes and Bracket Expressions.
                                                              (line  68)
* Mixing g and NUMBER modifiers in the s command: The "s" Command.
                                                              (line  80)
* multiple files:                        Overview.            (line  37)
* multiple sed commands:                 sed script overview. (line  37)
* n, and branching:                      Branching and flow control.
                                                              (line 105)
* N, and branching:                      Branching and flow control.
                                                              (line 105)
* named character classes:               Character Classes and Bracket Expressions.
                                                              (line  43)
* newline, command separator:            sed script overview. (line  37)
* Next input line, append to pattern space: Other Commands.   (line 257)
* Next input line, replace pattern space with: Common Commands.
                                                              (line  61)
* Non-bugs, 0 address:                   Reporting Bugs.      (line 114)
* Non-bugs, in-place editing:            Reporting Bugs.      (line  95)
* Non-bugs, localization-related:        Reporting Bugs.      (line 124)
* Non-bugs, localization-related <1>:    Reporting Bugs.      (line 143)
* Non-bugs, N command on the last line:  Reporting Bugs.      (line  30)
* Non-bugs, regex syntax clashes:        Reporting Bugs.      (line  61)
* numeric addresses:                     Addresses overview.  (line   6)
* numeric characters:                    Character Classes and Bracket Expressions.
                                                              (line  62)
* omitting labels:                       Branching and flow control.
                                                              (line  75)
* output:                                Overview.            (line  23)
* output, suppressing:                   Overview.            (line  30)
* p, example:                            Overview.            (line  30)
* paragraphs, processing:                Multiline techniques.
                                                              (line  53)
* parameters, script:                    Overview.            (line  43)
* Parenthesized substrings:              The "s" Command.     (line  18)
* Pattern space, definition:             Execution Cycle.     (line   6)
* Portability, comments:                 Common Commands.     (line  15)
* Portability, line length limitations:  Limitations.         (line   6)
* Portability, N command on the last line: Reporting Bugs.    (line  30)
* POSIXLY_CORRECT behavior, bracket expressions: Character Classes and Bracket Expressions.
                                                              (line 112)
* POSIXLY_CORRECT behavior, enabling:    Command-Line Options.
                                                              (line 105)
* POSIXLY_CORRECT behavior, escapes:     Escapes.             (line  11)
* POSIXLY_CORRECT behavior, N command:   Reporting Bugs.      (line  56)
* Print first line from pattern space:   Other Commands.      (line 269)
* printable characters:                  Character Classes and Bracket Expressions.
                                                              (line  72)
* Printing file name:                    Extended Commands.   (line  30)
* Printing line number:                  Other Commands.      (line 194)
* Printing text unambiguously:           Other Commands.      (line 207)
* processing paragraphs:                 Multiline techniques.
                                                              (line  53)
* punctuation characters:                Character Classes and Bracket Expressions.
                                                              (line  75)
* Q, example:                            Exit status.         (line  25)
* q, example:                            sed script overview. (line  28)
* Quitting:                              Common Commands.     (line  28)
* Quitting <1>:                          Extended Commands.   (line  36)
* quoted-printable lines, joining:       Branching and flow control.
                                                              (line 150)
* range addresses:                       Addresses overview.  (line  24)
* range expression:                      Character Classes and Bracket Expressions.
                                                              (line  18)
* Range of lines:                        Range Addresses.     (line   6)
* Range with start address of zero:      Range Addresses.     (line  31)
* Read next input line:                  Common Commands.     (line  61)
* Read text from a file:                 Other Commands.      (line 219)
* Read text from a file <1>:             Extended Commands.   (line  53)
* regex addresses and input lines:       Regexp Addresses.    (line  84)
* regex addresses and pattern space:     Regexp Addresses.    (line  84)
* regular expression addresses:          Addresses overview.  (line  18)
* regular expression, example:           sed script overview. (line  28)
* Replace hold space with copy of pattern space: Other Commands.
                                                              (line 272)
* Replace pattern space with copy of hold space: Other Commands.
                                                              (line 280)
* Replacing all text matching regexp in a line: The "s" Command.
                                                              (line  74)
* Replacing only Nth match of regexp in a line: The "s" Command.
                                                              (line  78)
* Replacing selected lines with other text: Other Commands.   (line 157)
* Requiring GNU sed:                     Extended Commands.   (line  69)
* restarting a cycle:                    Branching and flow control.
                                                              (line  75)
* Sandbox mode:                          Command-Line Options.
                                                              (line 157)
* script parameter:                      Overview.            (line  43)
* Script structure:                      sed script overview. (line   6)
* Script, from a file:                   Command-Line Options.
                                                              (line  51)
* Script, from command line:             Command-Line Options.
                                                              (line  46)
* sed commands syntax:                   sed script overview. (line  13)
* sed commands, multiple:                sed script overview. (line  37)
* sed script structure:                  sed script overview. (line   6)
* Selecting lines to process:            Numeric Addresses.   (line   6)
* Selecting non-matching lines:          Addresses overview.  (line  31)
* semicolons, command separator:         sed script overview. (line  37)
* Several lines, selecting:              Range Addresses.     (line   6)
* Slash character, in regular expressions: Regexp Addresses.  (line  32)
* space characters:                      Character Classes and Bracket Expressions.
                                                              (line  80)
* Spaces, pattern and hold:              Execution Cycle.     (line   6)
* Special addressing forms:              Range Addresses.     (line  31)
* standard input:                        Overview.            (line  15)
* Standard input, processing as input:   Command-Line Options.
                                                              (line 183)
* standard output:                       Overview.            (line  23)
* stdin:                                 Overview.            (line  15)
* stdout:                                Overview.            (line  23)
* Stream editor:                         Introduction.        (line   6)
* subexpression:                         Back-references and Subexpressions.
                                                              (line   6)
* Subprocesses:                          The "s" Command.     (line 108)
* Subprocesses <1>:                      Extended Commands.   (line  12)
* Substitution of text, options:         The "s" Command.     (line  70)
* suppressing output:                    Overview.            (line  30)
* syntax, addresses:                     sed script overview. (line  13)
* syntax, sed commands:                  sed script overview. (line  13)
* t, joining lines with:                 Branching and flow control.
                                                              (line 150)
* t, versus b:                           Branching and flow control.
                                                              (line 150)
* Text, appending:                       Other Commands.      (line  45)
* Text, deleting:                        Common Commands.     (line  44)
* Text, insertion:                       Other Commands.      (line 104)
* Text, printing:                        Common Commands.     (line  52)
* Text, printing after substitution:     The "s" Command.     (line  88)
* Text, writing to a file after substitution: The "s" Command.
                                                              (line 101)
* Transliteration:                       Other Commands.      (line  11)
* Unbuffered I/O, choosing:              Command-Line Options.
                                                              (line 164)
* upper-case letters:                    Character Classes and Bracket Expressions.
                                                              (line  84)
* Usage summary, printing:               Command-Line Options.
                                                              (line  17)
* Version, printing:                     Command-Line Options.
                                                              (line  13)
* whitespace characters:                 Character Classes and Bracket Expressions.
                                                              (line  80)
* Working on separate files:             Command-Line Options.
                                                              (line 148)
* Write first line to a file:            Extended Commands.   (line  80)
* Write to a file:                       Other Commands.      (line 240)
* xdigit class:                          Character Classes and Bracket Expressions.
                                                              (line  88)
* Zero, as range start address:          Range Addresses.     (line  31)


File: sed.info,  Node: Command and Option Index,  Prev: Concept Index,  Up: Top

# /Command and Option Index
***************************

This is an alphabetical list of all 'sed' commands and command-line
options.

 [index ]
* Menu:

* # (comments):                          Common Commands.     (line  12)
* --binary:                              Command-Line Options.
                                                              (line 114)
* --debug:                               Command-Line Options.
                                                              (line  29)
* --expression:                          Command-Line Options.
                                                              (line  46)
* --file:                                Command-Line Options.
                                                              (line  51)
* --follow-symlinks:                     Command-Line Options.
                                                              (line 125)
* --help:                                Command-Line Options.
                                                              (line  17)
* --in-place:                            Command-Line Options.
                                                              (line  56)
* --line-length:                         Command-Line Options.
                                                              (line  97)
* --null-data:                           Command-Line Options.
                                                              (line 172)
* --posix:                               Command-Line Options.
                                                              (line 102)
* --quiet:                               Command-Line Options.
                                                              (line  23)
* --regexp-extended:                     Command-Line Options.
                                                              (line 135)
* --sandbox:                             Command-Line Options.
                                                              (line 157)
* --separate:                            Command-Line Options.
                                                              (line 148)
* --silent:                              Command-Line Options.
                                                              (line  23)
* --unbuffered:                          Command-Line Options.
                                                              (line 164)
* --version:                             Command-Line Options.
                                                              (line  13)
* --zero-terminated:                     Command-Line Options.
                                                              (line 172)
* -b:                                    Command-Line Options.
                                                              (line 114)
* -e:                                    Command-Line Options.
                                                              (line  46)
* -E:                                    Command-Line Options.
                                                              (line 135)
* -f:                                    Command-Line Options.
                                                              (line  51)
* -i:                                    Command-Line Options.
                                                              (line  56)
* -l:                                    Command-Line Options.
                                                              (line  97)
* -n:                                    Command-Line Options.
                                                              (line  23)
* -n, forcing from within a script:      Common Commands.     (line  20)
* -r:                                    Command-Line Options.
                                                              (line 135)
* -s:                                    Command-Line Options.
                                                              (line 148)
* -u:                                    Command-Line Options.
                                                              (line 164)
* -z:                                    Command-Line Options.
                                                              (line 172)
* : (label) command:                     Programming Commands.
                                                              (line  14)
* = (print line number) command:         Other Commands.      (line 194)
* {} command grouping:                   Common Commands.     (line  91)
* a (append text lines) command:         Other Commands.      (line  45)
* alnum character class:                 Character Classes and Bracket Expressions.
                                                              (line  44)
* alpha character class:                 Character Classes and Bracket Expressions.
                                                              (line  49)
* b (branch) command:                    Programming Commands.
                                                              (line  18)
* blank character class:                 Character Classes and Bracket Expressions.
                                                              (line  54)
* c (change to text lines) command:      Other Commands.      (line 157)
* cntrl character class:                 Character Classes and Bracket Expressions.
                                                              (line  57)
* D (delete first line) command:         Other Commands.      (line 251)
* d (delete) command:                    Common Commands.     (line  44)
* digit character class:                 Character Classes and Bracket Expressions.
                                                              (line  62)
* e (evaluate) command:                  Extended Commands.   (line  12)
* F (File name) command:                 Extended Commands.   (line  30)
* G (appending Get) command:             Other Commands.      (line 284)
* g (get) command:                       Other Commands.      (line 280)
* graph character class:                 Character Classes and Bracket Expressions.
                                                              (line  65)
* H (append Hold) command:               Other Commands.      (line 276)
* h (hold) command:                      Other Commands.      (line 272)
* i (insert text lines) command:         Other Commands.      (line 104)
* l (list unambiguously) command:        Other Commands.      (line 207)
* lower character class:                 Character Classes and Bracket Expressions.
                                                              (line  68)
* N (append Next line) command:          Other Commands.      (line 257)
* n (next-line) command:                 Common Commands.     (line  61)
* P (print first line) command:          Other Commands.      (line 269)
* p (print) command:                     Common Commands.     (line  52)
* print character class:                 Character Classes and Bracket Expressions.
                                                              (line  72)
* punct character class:                 Character Classes and Bracket Expressions.
                                                              (line  75)
* q (quit) command:                      Common Commands.     (line  28)
* Q (silent Quit) command:               Extended Commands.   (line  36)
* r (read file) command:                 Other Commands.      (line 219)
* R (read line) command:                 Extended Commands.   (line  53)
* s command, option flags:               The "s" Command.     (line  70)
* space character class:                 Character Classes and Bracket Expressions.
                                                              (line  80)
* T (test and branch if failed) command: Extended Commands.   (line  63)
* t (test and branch if successful) command: Programming Commands.
                                                              (line  22)
* upper character class:                 Character Classes and Bracket Expressions.
                                                              (line  84)
* v (version) command:                   Extended Commands.   (line  69)
* w (write file) command:                Other Commands.      (line 240)
* W (write first line) command:          Extended Commands.   (line  80)
* x (eXchange) command:                  Other Commands.      (line 288)
* xdigit character class:                Character Classes and Bracket Expressions.
                                                              (line  88)
* y (transliterate) command:             Other Commands.      (line  11)
* z (Zap) command:                       Extended Commands.   (line  85)



Tag Table:
Node: Top726
Node: Introduction2172
Node: Invoking sed2726
Node: Overview3039
Node: Command-Line Options5297
Ref: Command-Line Options-Footnote-112932
Ref: Command-Line Options-Footnote-213124
Node: Exit status13223
Node: sed scripts14125
Node: sed script overview14698
Node: sed commands list17219
Node: The "s" Command22008
Ref: The "s" Command-Footnote-127470
Node: Common Commands27542
Node: Other Commands30567
Ref: insert command33681
Ref: Other Commands-Footnote-139581
Node: Programming Commands39653
Node: Extended Commands40565
Node: Multiple commands syntax44457
Node: sed addresses48774
Node: Addresses overview49203
Node: Numeric Addresses50979
Node: Regexp Addresses52330
Ref: Regexp Addresses-Footnote-156282
Node: Range Addresses56422
Node: sed regular expressions58902
Node: Regular Expressions Overview59751
Node: BRE vs ERE61258
Node: BRE syntax62949
Node: ERE syntax69338
Node: Character Classes and Bracket Expressions70810
Node: regexp extensions75648
Node: Back-references and Subexpressions78036
Node: Escapes80440
Ref: Escapes-Footnote-183457
Node: Locale Considerations83648
Ref: Locale Considerations-Footnote-188271
Node: advanced sed88443
Node: Execution Cycle88802
Ref: Execution Cycle-Footnote-189997
Node: Hold and Pattern Buffers90298
Node: Multiline techniques90486
Node: Branching and flow control93700
Node: Examples101749
Node: Joining lines102949
Node: Centering lines104736
Node: Increment a number105655
Ref: Increment a number-Footnote-1107132
Node: Rename files to lower case107252
Node: Print bash environment110025
Node: Reverse chars of lines110780
Ref: Reverse chars of lines-Footnote-1111811
Node: Text search across multiple lines112028
Node: Line length adjustment115253
Node: tac116990
Node: cat -n117757
Node: cat -b119579
Node: wc -c120328
Ref: wc -c-Footnote-1122238
Node: wc -w122307
Node: wc -l123775
Node: head124020
Node: tail124351
Node: uniq126032
Node: uniq -d126819
Node: uniq -u127530
Node: cat -s128239
Node: Limitations130086
Node: Other Resources130927
Node: Reporting Bugs131828
Ref: N_command_last_line132991
Ref: Reporting Bugs-Footnote-1139136
Node: GNU Free Documentation License139207
Node: Concept Index164362
Node: Command and Option Index191640

End Tag Table
