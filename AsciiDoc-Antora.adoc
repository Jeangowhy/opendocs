= Antora 3.1.x Docs
:doctype: book
:toc:
:toclevel: 1
// :route: New
// :page-toclevels: 0
// :leveloffset: 1
:stem:
:page-component-version: 3.1

https://gitlab.com/antora/antora/-/tree/v3.1.x[Antora 3.1.x]

[source,bash]
-------------
while read -r it
do
if ! [ -a "./docs/$it" ]; then echo "File Not Found: $it"; fi
echo "// /docs/$it" >> $0
cat "./docs/$it" >> $0
done << EOF
    modules/ROOT/nav-start.adoc
    modules/install/nav.adoc
    modules/ROOT/nav-content-sources.adoc
    modules/ROOT/nav-component-versions.adoc
    modules/page/nav.adoc
    modules/asciidoc/nav.adoc
    modules/navigation/nav.adoc
    modules/playbook/nav.adoc
    modules/ROOT/nav-generate.adoc
    modules/ROOT/nav-publish.adoc
    modules/extend/nav.adoc
    modules/ROOT/nav-end.adoc
EOF
-------------

. Some adocs untrack by all nat.adoc
-----------------------------------
    docs/modules
    ├── docs/modules/extend
    │   └── docs/modules/extend/examples
    │       ├── docs/modules/extend/examples/all-pages-report-extension.js
    │       ├── docs/modules/extend/examples/audit-includes-asciidoctor-extension.js
    │       ├── docs/modules/extend/examples/background-fetch-and-publish-readme-extension.js
    │       ├── docs/modules/extend/examples/better-time-generation-extension.js
    │       ├── docs/modules/extend/examples/discovered-component-versions-extension.js
    │       ├── docs/modules/extend/examples/doc-to-pdf-extension.js
    │       ├── docs/modules/extend/examples/exclude-private-content-sources-extension.js
    │       ├── docs/modules/extend/examples/export-content-extension.js
    │       ├── docs/modules/extend/examples/fetch-and-publish-readme-extension.js
    │       ├── docs/modules/extend/examples/humans-txt-extension.js
    │       ├── docs/modules/extend/examples/nojekyll-extension.js
    │       ├── docs/modules/extend/examples/page-unpublish-flag-extension.js
    │       ├── docs/modules/extend/examples/print-compiled-asciidoc-attributes-extension.js
    │       ├── docs/modules/extend/examples/print-defined-asciidoc-attributes-extension.js
    │       ├── docs/modules/extend/examples/resolve-attribute-references-in-attachments-extension.js
    │       ├── docs/modules/extend/examples/set-global-asciidoc-attributes-extension.js
    │       ├── docs/modules/extend/examples/time-generation-extension.js
    │       ├── docs/modules/extend/examples/unlisted-pages-extension.js
    │       └── docs/modules/extend/examples/unpublish-unlisted-pages-extension.js
    ├── docs/modules/install
    │   └── docs/modules/install/partials
    │       └── docs/modules/install/partials/upgrade-checklist.adoc
    ├── docs/modules/page
    │   ├── docs/modules/page/pages
    │   │   ├── docs/modules/page/pages/examples.adoc
    │   │   ├── docs/modules/page/pages/images.adoc
    │   │   ├── docs/modules/page/pages/index.adoc
    │   │   ├── docs/modules/page/pages/partials.adoc
    │   │   ├── docs/modules/page/pages/resource-id.adoc
    │   └── docs/modules/page/partials
    │       └── docs/modules/page/partials/include-directive.adoc
    ├── docs/modules/playbook
    │   ├── docs/modules/playbook/examples
    │   │   ├── docs/modules/playbook/examples/linked-worktree-as-content-source.js
    │   │   └── docs/modules/playbook/examples/system-git-credential-manager.js
    │   └── docs/modules/playbook/partials
    │       ├── docs/modules/playbook/partials/playbook-project-summary.adoc
    │       ├── docs/modules/playbook/partials/playbook-vs-descriptor.adoc
    │       └── docs/modules/playbook/partials/relative-path-rules.adoc
    └── docs/modules/ROOT
        ├── docs/modules/ROOT/examples
        │   ├── docs/modules/ROOT/examples/github-actions-workflow.yml
        │   └── docs/modules/ROOT/examples/github-actions-workflow-with-lunr.yml
        ├── docs/modules/ROOT/pages
        │   ├── docs/modules/ROOT/pages/index.adoc
        └── docs/modules/ROOT/partials
            ├── docs/modules/ROOT/partials/assets-directory.adoc
            ├── docs/modules/ROOT/partials/dont-use-these-attributes.adoc
            ├── docs/modules/ROOT/partials/optional-component-version-keys.adoc
            ├── docs/modules/ROOT/partials/pipeline-steps-list.adoc
            ├── docs/modules/ROOT/partials/required-component-version-keys.adoc
            └── docs/modules/ROOT/partials/videos-directory.adoc
-----------------------------------

// /docs/antora.yml
.Antora configuration docs/antora.yml
[source,yaml]
-------------
    name: antora
    version: '3.2'
    prerelease: '.0-alpha.8'
    title: Antora
    asciidoc:
    attributes:
        release-date: '2024-12-05'
        release-tag: testing
        release-version: '3.2.0-alpha.8'
        source-language: asciidoc@
        xrefstyle: short@
        example-caption: false
        listing-caption: Example@
        version-node-major: '22'
        version-node: '22.12.0'
        version-npm: '10.9.0'
        url-node-releases: https://nodejs.org/en/about/releases/
        url-chat: https://chat.antora.org
        url-repo: https://gitlab.com/antora/antora
        url-asciidoc: https://docs.asciidoctor.org/asciidoc/latest
    nav:
    - modules/ROOT/nav-start.adoc
    - modules/install/nav.adoc
    - modules/ROOT/nav-content-sources.adoc
    - modules/ROOT/nav-component-versions.adoc
    - modules/page/nav.adoc
    - modules/asciidoc/nav.adoc
    - modules/navigation/nav.adoc
    - modules/playbook/nav.adoc
    - modules/ROOT/nav-generate.adoc
    - modules/ROOT/nav-publish.adoc
    - modules/extend/nav.adoc
    - modules/ROOT/nav-end.adoc
-------------

// /docs/modules/ROOT/nav-start.adoc
* xref:#whats-new.adoc[]
** xref:#asciidoctor-upgrade-notes.adoc[]
* xref:#features.adoc[]
* xref:#how-antora-works.adoc[]
* xref:#install-and-run-quickstart.adoc[]

// /docs/modules/install/nav.adoc
.Get Antora
* xref:#linux-requirements.adoc[]
* xref:#macos-requirements.adoc[]
* xref:#windows-requirements.adoc[]
* xref:#install-antora.adoc[]
* xref:#upgrade-antora.adoc[]
* xref:#supported-platforms.adoc[]

// /docs/modules/ROOT/nav-content-sources.adoc
.Set Up Content Sources
* xref:#organize-content-files.adoc[]
* xref:#content-source-repositories.adoc[]
* xref:#content-source-versioning-methods.adoc[]
* xref:#standard-directories.adoc[]
* xref:#symlinks.adoc[]
* xref:#module-directories.adoc[]
** xref:#root-module-directory.adoc[]
** xref:#named-module-directory.adoc[]
** xref:#module-directory-names.adoc[]
** xref:#module-url-segment.adoc[]
* xref:#family-directories.adoc[]
** xref:#pages-directory.adoc[]
** xref:#partials-directory.adoc[]
** xref:#examples-directory.adoc[]
** xref:#images-directory.adoc[]
** xref:#attachments-directory.adoc[]

// /docs/modules/ROOT/nav-component-versions.adoc
.Configure Component Versions
* xref:#component-version.adoc[]
* xref:#component-version-descriptor.adoc[]
* xref:#component-name-and-version.adoc[]
* xref:#component-name-key.adoc[]
* xref:#component-version-key.adoc[]
* xref:#component-title.adoc[]
* xref:#component-display-version.adoc[]
* xref:#component-prerelease.adoc[]
* xref:#component-with-no-version.adoc[]
* xref:#component-attributes.adoc[]
* xref:#component-start-page.adoc[]
* xref:#component-navigation.adoc[]
* xref:#version-facets.adoc[]
* xref:#how-component-versions-are-sorted.adoc[]
* xref:#distributed-component-version.adoc[]

// /docs/modules/page/nav.adoc
. xref:#resource-id.adoc[]
* xref:#resource-id-coordinates.adoc[]

. xref:#index.adoc[]
* xref:#standard-page.adoc[]
* xref:#title-and-metadata.adoc[]
* xref:#attributes.adoc[]
** xref:#define-and-modify-attributes.adoc[]
** xref:#page-attributes.adoc[]
** xref:#intrinsic-attributes.adoc[]
* xref:#start-page.adoc[]
* xref:#xref.adoc[]
** xref:#page-links.adoc[]
** xref:#link-content.adoc[]
//Rename, Move, and Delete Pages
* xref:#reftext-and-navtitle.adoc[]
* xref:#page-aliases.adoc[]
* xref:#page-layout.adoc[]
* xref:#include-a-page.adoc[]
** xref:#page-partial.adoc[]

. xref:#images.adoc[]
* xref:#block-images.adoc[]
* xref:#inline-images.adoc[]
* xref:#image-resource-id-examples.adoc[]
* xref:#image-xref-#and-link.adoc[]

. xref:#partials.adoc[]
* xref:#include-a-partial.adoc[]

. xref:#examples.adoc[]
* xref:#include-an-example.adoc[]

[]
* xref:#attachments.adoc[]

// /docs/modules/asciidoc/nav.adoc
. xref:#index.adoc[AsciiDoc Primer]
* xref:#document-header.adoc[Document Header]
* xref:#section-headings.adoc[Sections]
* xref:#text-and-punctuation.adoc[Text and Punctuation Styles]
** xref:#bold.adoc[Bold]
** xref:#italic.adoc[Italic]
** xref:#monospace.adoc[Monospace]
** xref:#highlight.adoc[Highlight]
** xref:#quotes-and-apostrophes.adoc[Quote Marks and Apostrophes]
** xref:#special-characters-and-symbols.adoc[Special Characters and Symbols]
** xref:#subscript-and-superscript.adoc[Subscript and Superscript]
* xref:#in-page-xref.#adoc[Internal Xrefs#]
* xref:#external-urls.adoc[URLs]
* xref:#lists.adoc[Lists]
** xref:#ordered-and-unordered-lists.adoc[Bullet and Numbered Lists]
** xref:#description-lists.adoc[Description Lists]
** xref:#checklists.adoc[Checklists]
* xref:#embed-video.adoc[Embed a Video]
* xref:#ui-macros.adoc[UI Macros]
// Paragraphs and Blocks
* xref:#source.adoc[Source Blocks]
* xref:#admonitions.adoc[Admonitions]
* xref:#examples.adoc[Examples]
* xref:#sidebar.adoc[Sidebars]
* xref:#comments.adoc[Comments]

// /docs/modules/navigation/nav.adoc
.Navigation
* xref:#index.adoc[]
* xref:#files-and-lists.adoc[]
** xref:#single-list.adoc[]
** xref:#multiple-lists.adoc[]
* xref:#xrefs-and-link-text.adoc[]
* xref:#reference-resources.adoc[]
* xref:#external-links.adoc[]
* xref:#format-content.adoc[]
* xref:#organize-files.adoc[]
* xref:#include-lists.adoc[]
* xref:#register-navigation-files.adoc[]

// /docs/modules/playbook/nav.adoc
.Configure Your Site
* xref:#index.adoc[]
* xref:#set-up-playbook.adoc[]
* xref:#configure-site.adoc[]
** xref:#site-url.adoc[]
** xref:#site-title.adoc[]
** xref:#site-start-page.adoc[]
** xref:#site-robots.adoc[]
** xref:#site-keys.adoc[]
* xref:#configure-content-sources.adoc[]
** xref:#content-source-url.adoc[]
*** xref:#private-repository-auth.adoc[]
** xref:#content-branches.adoc[]
** xref:#content-worktrees.adoc[]
** xref:#content-tags.adoc[]
** xref:#content-source-start-path.adoc[]
** xref:#content-source-start-paths.adoc[]
** xref:#content-source-version.adoc[]
** xref:#content-edit-url.adoc[]
** xref:#content-refname-matching.adoc[]
* xref:#configure-git.adoc[]
** xref:#git-suffix.adoc[]
** xref:#git-fetch-depth.adoc[]
** xref:#git-fetch-concurrency.adoc[]
** xref:#git-read-concurrency.adoc[]
** xref:#git-credentials-path-and-contents.adoc[]
** xref:#git-plugins.adoc[]
* xref:#configure-asciidoc.adoc[]
** xref:#asciidoc-attributes.adoc[]
** xref:#asciidoc-extensions.adoc[]
** xref:#asciidoc-sourcemap.adoc[]
* xref:#configure-ui.adoc[]
** xref:#ui-bundle-url.adoc[]
** xref:#ui-supplemental-files.adoc[]
** xref:#ui-output-dir.adoc[]
** xref:#ui-default-layout.adoc[]
* xref:#configure-urls.adoc[]
** xref:#urls-html-extension-style.adoc[]
** xref:#urls-latest-version-segment.adoc[]
** xref:#urls-latest-prerelease-version-segment.adoc[]
** xref:#urls-latest-version-segment-strategy.adoc[]
** xref:#urls-redirect-facility.adoc[]
* xref:#configure-output.adoc[]
** xref:#output-dir.adoc[]
** xref:#output-provider-archive.adoc[]
** xref:#output-provider-fs.adoc[]
** xref:#output-provider-custom.adoc[]
* xref:#configure-runtime.adoc[]
** Log Keys
*** xref:#runtime-log-level.adoc[]
*** xref:#runtime-log-failure-level.adoc[]
*** xref:#runtime-log-format.adoc[]
*** xref:#runtime-log-destination.adoc[]
** xref:#runtime-fetch.adoc[]
** xref:#runtime-cache-dir.adoc[]
* xref:#configure-network.adoc[]
 ** xref:#network-proxy.adoc[]
* xref:#author-mode.adoc[]
* xref:#use-an-existing-playbook-project.adoc[]
* xref:#environment-variables.adoc[]

// /docs/modules/ROOT/nav-generate.adoc
.Generate Your Site
* xref:#run-antora.adoc[]
* xref:#preview-site.adoc[]
* xref:#cli:index.adoc[]
** xref:#cli:options.adoc[]
** xref:#cli:primer.adoc[]
* xref:#cache.adoc[]
* xref:#antora-container.adoc[]

// /docs/modules/ROOT/nav-publish.adoc
.Publish Your Site
* xref:#how-antora-builds-urls.adoc[]
* xref:#add-404-error-page.adoc[]
* xref:#sitemap.adoc[]
* xref:#publish-to-github-pages.adoc[]
* xref:#publish-to-gitlab-pages.adoc[]

// /docs/modules/extend/nav.adoc
.Extend Antora
* xref:#extensions.adoc[]
** xref:#define-extension.adoc[]
** xref:#register-extension.adoc[]
** xref:#add-event-listeners.adoc[]
** xref:#use-context-variables.adoc[]
** xref:#configure-extension.adoc[]
** xref:#enable-extension.adoc[]
** xref:#extension-helpers.adoc[]
** xref:#class-based-extension.adoc[]
** xref:#asynchronous-listeners.adoc[]
** xref:#replace-generator-functions.adoc[]
** xref:#extension-tutorial.adoc[]
** xref:#generator-events-reference.adoc[]
** xref:#generator-context-reference.adoc[]
** xref:#extension-use-cases.adoc[]
* xref:#supported-components.adoc[]

// /docs/modules/ROOT/nav-end.adoc
* xref:#project:get-help.adoc[]
* xref:#security-bulletins.adoc[]

.Project Governance
* xref:#project:release-schedule.adoc[]
* xref:#project:copyright-and-license.adoc[]
* xref:#project:land-acknowledgement.adoc[]

= Antora README.adoc
// Settings
ifdef::env-gitlab[:outfilesuffix: .adoc]
// Project URLs
:url-project: https://antora.org
:url-docs: https://docs.antora.org
:url-org: https://gitlab.com/antora
:url-repo: {url-org}/antora
:url-demo-repos: {url-org}/demo
:url-ui-repo: {url-org}/antora-ui-default
:url-issues: {url-repo}/issues
:url-ci-pipelines: {url-repo}/pipelines
:url-chat: https://antora.zulipchat.com
:url-twitter: https://twitter.com/antoraproject
:url-twitter-hash: https://twitter.com/hashtag/antora?src=hash
// External URLs
:url-asciidoctor: https://asciidoctor.org
:url-choco: https://chocolatey.org
:url-node-releases: https://nodejs.org/en/about/releases/
:url-nvm: https://github.com/creationix/nvm
:url-nvm-install: {url-nvm}#installation
:url-nvm-windows: https://github.com/coreybutler/nvm-windows
:url-opendevise: https://opendevise.com
:url-git-credential-store: https://git-scm.com/docs/git-credential-store
// Versions:
:version-node-major: 22
:version-node: 22.12.0

{url-project}[Antora] is a modular, single or multi-repository site generator designed for creating documentation sites from content composed in AsciiDoc(R) and processed with {url-asciidoctor}[Asciidoctor].

Antora's toolchain and workflow help documentation and engineering teams create, manage, collaborate on, remix, and publish documentation sites sourced from one or more versioned git repositories without needing expertise in web technologies, build automation, or system administration.

This project includes a command line interface (CLI) and a site generator so you can quickly start publishing documentation sites with Antora.

== Code of Conduct

The Antora project and its project spaces are governed by our xref:CODE-OF-CONDUCT.adoc[Code of Conduct].
By participating, you're agreeing to honor this code.
Let's work together to make this a welcoming, professional, inclusive, and safe environment for everyone.

== Quickstart

This section offers a basic tutorial for evaluating Antora.
More comprehensive installation instructions are in the {url-docs}[Antora documentation].

=== Prerequisites

Antora is built on Node.js and is verified to work on Linux, macOS, and Windows.
To install Antora, you'll need Node.js (including npm, which is bundled with Node.js) on your system.
You may also find the base build tools for your OS helpful (which includes `git`), though they're not required.
We recommend using the active long term support (LTS) release of Node.js.
While you can use other versions of Node.js, Antora is only tested against {url-node-releases}[LTS releases].

To check whether you have Node.js installed, and which version, open a terminal and type:

 $ node -v

If this command fails with an error, it means you don't yet have Node.js installed.
If the command doesn't report a Node.js LTS version (e.g., v{version-node}), you don't have a suitable version of Node.js installed.

The best way to install Node.js is to use {url-nvm}[nvm] (Node Version Manager).
If your package manager provides Node.js and npm packages, _and you're familiar with using the tools installed system-wide_, you may choose to go that route.
However, we believe you'll be more successful if you choose nvm.

NOTE: Most CI environments use nvm to manage the version of Node.js used in the build job.
By using nvm, you can align your local setup with the environment used to generate and publish your production site.

If you're using Linux or macOS, follow {url-nvm-install}[the nvm installation instructions] to set up nvm on your machine.
If you're using Windows, you can install the {url-nvm-windows}[Windows port of nvm] via the {url-choco}[Chocolatey package manager] using `choco install -y nvm`.
Alternatively, you can install the active LTS release of Node.js directly using `choco install -y nodejs-lts`.

Once you've installed nvm, open a *new* terminal and install the active Node.js LTS release using:

 $ nvm install --lts

IMPORTANT: If you're using nvm for Windows, you must enter the full version of Node.js when running commands (e.g., `nvm install {version-node}`, `nvm use {version-node}`).
Run `nvm list available` to see a list of available Node.js versions.

To make Node.js {version-node-major} the default in new terminals (Linux and macOS only), type:

[subs=attributes+]
 $ nvm alias default {version-node-major}

Switch to this version of Node.js using the following command:

[subs=attributes+]
 $ nvm use {version-node-major}

Now that you have Node.js installed, you can install Antora.

=== Install Antora

To generate a site with Antora, you need the Antora CLI and an Antora site generator.
Once these packages are installed, you use the `antora` command to generate your site.
To install these packages globally using npm, in your terminal, type:

 $ npm i -g antora

Verify the `antora` command is available on your PATH by running:

 $ antora -v

For more installation methods and details see the {url-docs}/antora/latest/install/install-antora/[installation documentation].
Now that Antora is installed, you're ready to set up a playbook and generate a documentation site.

=== Run Antora to Generate a Site

To generate a site with Antora, you need a playbook file that points to at least one content source repository and a UI bundle.
The {url-demo-repos}[Antora Demo repositories] are set up as an Antora documentation project, so we can use them for now as your content sources.
Antora also provides a default UI for you to use out of the box.

==== Create a Playbook File

First, create a new directory for your site and switch to it.
Next, add a playbook file named [.path]_antora-playbook.yml_ and populate it with the configuration in the following example.
Alternatively, you can download the playbook file from the {url-demo-repos}/docs-site[Antora demo site's playbook repository].

.antora-playbook.yml
[source,yaml]
----
site:
  title: Antora Demo Site
  url: https://my-antora-demo-site.org
  start_page: component-b::index.adoc
content:
  sources:
  - url: https://@gitlab.com/antora/demo/demo-component-a.git
    branches: HEAD
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: [v2.0, v1.0]
    start_path: docs
ui:
  bundle:
    url: https://gitlab.com/antora/antora-ui-default/-/jobs/artifacts/HEAD/raw/build/ui-bundle.zip?job=bundle-stable
    snapshot: true
----

We're using Antora's default UI as the UI for the site.
Antora will take care of assembling all this input together to produce a documentation site.

The UI bundle can be loaded from a URI or a local filesystem path.
If you want to use your own UI bundle, follow the instructions in the README for the {url-ui-repo}/blob/HEAD/README.adoc[Default UI].

==== Run Antora

To generate the site, simply point the `antora` command at your playbook file.
In your terminal, type:

 $ antora antora-playbook.yml

Antora will clone the content repository, convert the AsciiDoc pages to embeddable HTML, wrap the HTML in a page template from the UI, then assemble the pages together along with the assets into the destination folder, which defaults to [.path]_build/site_.

To view your site, navigate to any HTML page inside the destination folder in your browser.
Using this example, look for the entry point file [.path]_build/site/index.html_.
That file will redirect you to the start page.
A site generated by Antora is designed to be viewable with or without a web server.

==== Troubleshooting

If something goes wrong during generation, you'll see an error message in the terminal.
If this message does not provide enough information to fix the problem, you can ask Antora for more context.
To tell Antora to reveal the calls leading up to the error (i.e., the stacktrace), run the `antora` command again, this time with the `--stacktrace` option:

 $ antora --stacktrace antora-playbook.yml

Share this stacktrace when <<Getting Help,asking for help>>.

==== Using Private Repositories

If any of your content repositories require authentication, Antora will look up the credentials in the default git credential store file or one that you specify using the `--git-credentials-path` CLI option.
See the {url-docs}/antora/latest/playbook/private-repository-auth/[private repository authentication documentation] to learn more.

== Getting Help

Antora is designed to help you easily write and publish your documentation.
However, we can't fully realize this goal without your feedback!
We encourage you to report issues, ask questions, share ideas, or discuss other aspects of this project using the communication tools provided below.

=== Chat

*The project chat is the preferred means of communication for all Antora users.*
This policy helps keep the project sustainable.
If you want to ask for help, share feedback, or exchange ideas with project maintainers and fellow community members in real time, please join us in the project chat.

* {url-chat}[Chat] (Zulip)

The chat is partitioned into streams.
If you find an active discussion that matches the topic of your post, feel free to join that discussion.
Otherwise, please select a stream most relevant to your topic, click "`New Topic`", enter a subject, then write your post.
If you aren't sure where to post, please create a new topic in the `#users` stream and a moderator may choose to reclassify it.

The discussions in the project chat are archived, but there's no guarantee those logs will be saved indefinitely.
Understand that users participate in the project chat voluntarily, so please be respectful of their time and interest.

=== Issues

The issue tracker is used to track changes to the software and for planning releases.
The issue tracker is not a support portal.
Instead, the issue tracker is reserved for reporting problems (verifiable bugs, regressions, and security vulnerabilities) and requesting new features.
If you aren't confident that a change to the software is required, please post to the <<Chat>> instead.

* {url-issues}[Issue tracker] (GitLab)

Any significant change to the software or decision about the project must be logged in the issue tracker.

=== Social

If you want to share your experience with Antora or help promote it, we encourage you to post about it on social media.
When you talk about Antora on Twitter, you can mention the official account for the project:

* {url-twitter}[@antoraproject] -- The official Antora account on Twitter.

You can also use the {url-twitter-hash}[#antora] hashtag to help promote the project or discover other people talking about it.

If you decide you want to get involved to help improve the project, then you'll be interested in the information provided in the <<Contributing>> section.

== Contributing

If you are interested in contributing to this project, please refer to the <<contributing.adoc#,contributing guide>>.
In this guide, you'll learn how to:

* <<contributing.adoc#set-up-workspace,set up your development workspace>>
* <<contributing.adoc#build-project,build the project>>
* <<contributing.adoc#project-rq,submit a merge request>>

Thanks in advance for helping to make this project a success!

== Release Policy and Schedule

The Antora core components include a site generator package, the packages the site generator delegates to, and a CLI package.
These packages are released together and follow semantic versioning rules (*major.minor.patch*).
Only the latest minor release will receive patch releases.

== Copyright and License

Copyright (C) 2017-present by OpenDevise Inc. and the individual contributors to Antora.

Use of this software is granted under the terms of the https://www.mozilla.org/en-US/MPL/2.0/[Mozilla Public License Version 2.0] (MPL-2.0).
See link:LICENSE[] to find the full license text.

== Authors

Development of Antora is led and sponsored by {url-opendevise}[OpenDevise].

== Trademarks

AsciiDoc(R) is a trademark of the Eclipse Foundation, Inc.

// /CODE-OF-CONDUCT.adoc
= Code of Conduct

== Our Pledge

We, as members, contributors, and leaders of the Antora project, are committed to making participation in our community a welcoming and harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.
A community where people feel comfortable is a productive community.

== Our Standards

Examples of behavior that contributes to a positive environment for our community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Being open to ideas that make your ideas better
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and reconciling with those affected by our mistakes, then taking the time to reflect and learn from the situation
* Focusing on what is best not just for us as individuals, but for the overall community
* Leading by example

Examples of unacceptable behavior include:

* Insulting, derogatory, demeaning, shaming, or exclusionary comments
* Public or private harassment or personal attacks
* The use of sexualized language or imagery, and sexual attention or advances of any kind
* Deliberate or repetitive use of a name or pronoun different than what the individual prefers and has clearly declared
* Trolling, spamming, flooding, swarming, flaming, baiting, or other attention-stealing behavior
* Demanding an immediate action or code change, or one that's not aligned with the goals of the project
* Publishing others`' private information, such as a physical or email address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a professional setting or which community leaders have determined to be inappropriate in this setting

This isn't an exhaustive list of unacceptable behavior.
Please be aware of your impact on other people and take responsibility for your own actions.
If someone says they have been harmed by your words or actions, listen carefully and correct your behavior going forward.
Specifically, if someone asks you to stop, then stop.
Persisting or being defensive after being asked to stop is considered harassment.

Please take these standards in the spirit in which they are intended, as guidelines to make our community a harassment-free experience for everyone.

== Differences and Disagreements

We're a worldwide community and we come from many cultures and backgrounds.
Remember that you may not be communicating in someone's primary language.
Give people time to formulate their thoughts and respond.
The idioms and slang you use may not be understood, or worse, may be interpreted as offensive.
Listen and update your language when necessary by considering the needs of others from their point of view.
In general, work to eliminate your own biases, prejudices, and discriminatory practices.

We're not always going to agree, but a disagreement is no excuse for poor behavior.
It's important to resolve disagreements respectfully.
When working to resolve a disagreement, be respectful, remain open to different outcomes, and strive to be teachable.

Architectural, design, and implementation decisions were made using the best information that was available at the time.
Circumstances change, and therefore, a past decision may not always make sense when viewed through the lens of the present.
Trade-offs have to be made and there's seldom one right answer.
Please be considerate of this actuality when stating your case.
Rather than blaming someone for what you perceive to be a mistake, focus on helping to resolve the issue while leaving space for that person to learn from it.
Be direct, constructive, and positive.

== Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.

Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.

== Scope

This Code of Conduct applies within all community spaces managed by the Antora project;
including the project chat; repositories, issue trackers, and merge requests; face-to-face meetings and community events.
It also applies when an individual is officially representing the community in other public spaces.
Examples of representing our community include using an official email address, posting via an official social media account, posting via a social media account on behalf of the community or community project, or acting as an appointed representative at an online or offline event.

== Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at conduct@opendevise.com.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the reporter of any incident.

== Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:

=== 1. Warning

*Community Impact*: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community, whether a single incident or a series of actions.

*Consequence*: A warning from a community leader, referencing this Code of Conduct and citing that reason for why the language or behavior is deemed a violation.
Violating these terms or retaliating against the warning will lead to a temporary suspension or permanent ban.

=== 2. Temporary Suspension

*Community Impact*: A serious or sustained violation of community standards.

*Consequence*: A temporary suspension from any sort of interaction or public communication with the community for a specified period of time.
No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms or retaliating against the warning will lead to a permanent ban.

=== 3. Permanent Ban

*Community Impact*: Demonstrating a pattern of violation, a dismissal of community standards, a disruption of the community, harassment of an individual, or aggression towards or disparagement of a group of individuals.

*Consequence*: A permanent ban from any form of public interaction within the community.

== Attribution

This Code of Conduct is adapted from the https://www.contributor-covenant.org[Contributor Covenant], version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.
Additional text is adapted from the https://www.mozilla.org/en-US/about/governance/policies/participation/[Mozilla Community Participation Guidelines], the https://www.rust-lang.org/conduct.html[Rust Language Code of Conduct], and the https://www.freebsd.org/internal/code-of-conduct/[FreeBSD Community Code of Conduct].
Community Impact Guidelines were inspired by https://github.com/mozilla/diversity[Mozilla's code of conduct enforcement ladder].

// /contributing.adoc
= Contributing
// Settings
:toc-title: Contents
:toclevels: 1
:toc:
// Universal gitlab
:url-gitlab: https://gitlab.com
:url-gitlab-signin: {url-gitlab}/users/sign_in
// Project URIs
:url-org: {url-gitlab}/antora
:url-project: {url-org}/antora
:url-repo: {url-project}.git
:url-issue-tracker: {url-project}/issues
:url-issue-board: {url-project}/boards/368796
:url-issue-labels: {url-project}/labels
:url-ci-pipelines: {url-project}/pipelines
:url-members: {url-project}/-/project_members
// Project documentation URIs (alphabetized)
:url-adrs: {url-project}/tree/main/devdocs/adr
:url-adr-0001: {url-project}/blob/main/devdocs/adr/0001-minimum-node-version.adoc
:url-packages: {url-project}/blob/main/packages
:url-asciidoc-loader-arch: {url-packages}/asciidoc-loader/devdocs/architecture-guidebook.adoc
:url-cli-arch: {url-packages}/cli/devdocs/architecture-guidebook.adoc
:url-content-aggregator-arch: {url-packages}/content-aggregator/devdocs/architecture-guidebook.adoc
:url-content-classifier-arch: {url-packages}/content-classifier/devdocs/architecture-guidebook.adoc
:url-document-converter-arch: {url-packages}/document-converter/devdocs/architecture-guidebook.adoc
:url-nav-builder-arch: {url-packages}/navigation-builder/devdocs/architecture-guidebook.adoc
:url-page-composer-arch: {url-packages}/page-composer/devdocs/architecture-guidebook.adoc
:url-playbook-builder-arch: {url-packages}/playbook-builder/devdocs/architecture-guidebook.adoc
:url-site-generator-arch: {url-packages}/site-generator/devdocs/architecture-guidebook.adoc
:url-site-mapper-arch: {url-packages}/site-mapper/devdocs/architecture-guidebook.adoc
:url-file-publisher-arch: {url-packages}/file-publisher/devdocs/architecture-guidebook.adoc
:url-ui-loader-arch: {url-packages}/ui-loader/devdocs/architecture-guidebook.adoc
// External URLs (alphabetized)
:url-asciidoc-recommended: https://asciidoctor.org/docs/asciidoc-recommended-practices/#one-sentence-per-line
:url-async-func: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function
:url-biome: https://biomejs.dev
:url-chai: http://chaijs.com/api/bdd/
:url-chai-cheerio: https://www.chaijs.com/plugins/chai-cheerio/
:url-chai-fs: https://www.chaijs.com/plugins/chai-fs/
:url-chai-spies: https://www.chaijs.com/plugins/chai-spies/
:url-dirty-chai: https://www.chaijs.com/plugins/dirty-chai/
:url-docker-install: https://docs.docker.com/install/
:url-git: https://git-scm.com
:url-git-dl: {url-git}/downloads
:url-chat: https://antora.zulipchat.com
:url-istanbul: https://istanbul.js.org/
:url-mocha: https://mochajs.org/
:url-node: https://nodejs.org
:url-node-releases: {url-node}/en/about/releases/
:url-nvm: https://github.com/creationix/nvm
:url-nvm-install: {url-nvm}#installation

== You're Invited!

In the spirit of open source software, *everyone* is welcome to contribute to this project!

We believe strongly that developing software in the open produces the best outcome.
In order for that to work, the project relies on your support.
We have big goals for the project and we rely on a variety of talent to achieve those goals.

The best way to get involved is to just show up and make yourself heard.
We pride ourselves on having a very friendly and encouraging culture.

Whether you're a user, writer, designer, developer, architect, devops, system administrator, advocate, project manager, or just someone with an idea about how to improve the project, we welcome your participation.
In return, you'll get to use better software that we built together as a community and a great sense of pride for having been a part of making it.

We want your choice to participate in the Antora project to be the start of an exciting and rewarding journey.
From all of us to you, welcome!

== Code of Conduct

The Antora project and its project spaces are governed by our xref:CODE-OF-CONDUCT.adoc[Code of Conduct].
By participating, you're agreeing to honor this code.
Let's work together to make this a welcoming, professional, inclusive, and safe environment for everyone.

== Project Host

This project is hosted on GitLab under the {url-org}[Antora organization].
This is the official home of the project.
All development, project and issue management, and continuous integration is done here.

////
=== Project Resources

The GitLab project provides the following resources for the project:

* git repository
* issue tracker
* merge requests (MR)
* CI server
////

== Permissions

You do not need a GitLab.com account to browse the issues and merge requests, read the source code and documentation, or view the CI results.
However, you do need a {url-gitlab-signin}[GitLab.com account] to file an issue and/or submit a merge request.

//Issue Tracker and Board
//== Have an Idea? Found an Error?
== Have something to report?

Do you have an idea?
Have you found an error?

*Antora is an issue-driven project.*

If you have an idea for an improvement or have discovered an error or omission, head over to the {url-issue-tracker}[issue tracker].
Review the list of issues to check if someone has already filed an issue about that subject.
If an issue already exists, we welcome you to join the conversation.
If an issue doesn't exist, please don't hesitate to create a new one.

If you want to help complete an issue by contributing code, documentation, or other enhancements, review our <<contribution-workflow,contribution workflow>>, then submit a merge request (MR) for review.
However, please wait until we have agreed on what change to make before submitting an MR.
This avoids the discussion of the change getting lost and saves maintainers from having to address MRs that aren't relevant.

When thinking about how to contribute, please know that while merge requests are welcome, they aren't the first thing that's needed.
In fact, submitting a merge request (without prior discussion) can often slow down progress on an issue because it requires the maintainers to stop, review it, and reconcile it with the proposed design.
What we need more than anything else is help with the requirements and design, which often means making decisions in response to open questions.
Making those decisions is the exceptionally hard part.
Once that's done, writing the code becomes straightforward.
It's either something the maintainers can do or it can serve as an opportunity for someone in the community to contribute code (without the aforementioned disruption).

////
A merge request (MR) must close an issue!
Please study the {url-issue-labels}[issue labels] to understand what they mean and how to apply them.
Issues are organized into categories, represented by the part of the label text in brackets.

You can use the {url-issue-board}[issue board] to track the progress of development (which visualizes labels in the [Progress] category).
Issues move across the board from left (Backlog) to right (Done).
////

[#contribution-workflow]
== Contribution Workflow

*Since Antora is an issue-driven project, a merge request (MR) should always be linked to an open issue.*

NOTE: One exception to this rule is if you're submitting copy edits to the documentation.
If you're fixing grammar or typos that don't otherwise change the focus of the content, you can submit an MR directly.

. Review the issue tracker to see if we're already discussing your idea or problem.
 ** If you don't see an issue that fits your scenario, then you may create a new one.
. Discuss what change to make to resolve the issue in the issue comments.
 ** Please don't submit an MR before there is an agreement on what change should be made.
. If you'd like to submit code, documentation or other enhancements for an issue, review the following information first.
.. Antora's <<project-rq,fork-branch-commit-MR rules>>
.. <<code-workflow,Code workflow and requirements>>
.. Applicable <<arch-gb,architecture guidebooks>>
.. Applicable <<adr,ADRs>>
. Fork the project and name your branch after its issue.
 ** If you're contributing code, you'll want to <<set-up-workspace,set up your development workspace>>.
. Write, code, tinker, and have fun!
 ** Don't forget to <<lint-rq,lint>> and <<test-rq,test>> your code.
. When you're ready for feedback, open a MR.
 ** On the MR form, you must check the box _Allow commits from members who can merge to the target branch._
The MR cannot be accepted unless this box is checked.
If you forget, you can fix it by clicking the Edit button on the MR page.

[#project-rq]
== Fork, Branch, Commit, and Merge Request Rules

To contribute to the project:

. *Fork the project.*
We do not accept merge requests that do not come from a dedicated branch in a fork.

. *Create a dedicated branch in your fork for your changes.*
Name the branch after the issue number it fixes along with a short textual hint.
+
--
Here's an example of a branch name for issue #2, which was to initiate the Gulp build:

 issue-2-init-gulp-build

If you're only working on docs, then add `docs/` to the beginning of the branch name.
Here's an example of a branch name for issue #168, which was to write documentation for the sitemap generation:

 docs/issue-168-document-sitemap

The `docs/` prefix tells the CI server not to run the test suite.
--

. If you're a committer, label the issue as *[Progress] Preparing Change* in the issue tracker and make sure you're assigned to it so that the rest of the team knows you're working on it.
If the issue is already assigned but not labeled as being worked on feel free to reassign it to yourself.
If you are not a committer, you will need to request for these changes to be made to the issue using a comment.

. *Make your changes.*
 .. Use as many commits as you think are necessary, but each commit should consist of a logical change.
 .. Write tests to verify each change.
 .. If not already present, add yourself to the list of contributors in the [.path]_package.json_ file for the package you're modifying.

. *Write concise but explicit commit messages.*
Write the commit message as though the person reading it cannot see the code change.
 .. Write the message in lowercase and imperative tense.
 .. Put the subject on the first line of the commit message (required).
 .. Separate the subject line from the body using a blank line.
 .. The body lines should be structured as an unordered list (Markdown syntax).
 .. In each body line, succinctly identify an important change and/or explain why the change was made (optional).
+
----
rename component descriptor filename to antora.yml

- rename component descriptor from docs-component.yml to antora.yml
- promote component descriptor filename to a constant
----

. Prior to submitting a MR, *rebase your branch against the main branch*, then push the branch to your fork.

. *Create an MR from your branch* (using the URL shown in the terminal when you push).
.. *Begin the title of the MR with the issue it resolves* followed by a restatement of the issue.
+
 resolves #2 initialize gulp build

.. If you're still working on your branch and want feedback on it before it is complete, start the MR with WIP (e.g., `WIP: resolves #2 initialize gulp build`).
When the MR is ready for final review, you can remove `WIP:` from the MR title using the button in the interface.
.. In some select cases, the implementation of an issue might be broken up into separate commits if they can be tested and work in isolation.
This is why only the MR subject mentions the issue being resolved and not the subject of the commit.

. In the issue tracker, mark the issue as *[Progress] In Review*.

. *Your MR must pass the CI pipeline.*
If it fails, update your MR once you've corrected any problems.

. *A project member will be assigned to your MR and review it.*
.. During review, a project member may request changes to your MR, either in a comment on the MR or the associated issue.
.. Checkout the <<mr-approval,MR approval guidelines>> if you want to see how your MR will be evaluated.

. *Append a new commit or rewrite an existing commit*, depending on what you think is most appropriate, if you need to incorporate changes into your MR after you've pushed it.

. When your MR is approved, a project member will merge it using a merge commit with semi-linear history.
.. The maintainer may decide to squash review commits, or request for you to do so.
Only original work is guaranteed to be preserved in the commit history.

[#code-workflow]
== Coding Requirements and Workflow

. Set up your <<set-up-workspace,development workspace>>.
. Review any applicable <<arch-gb,architecture guidebooks>>.
. Make sure your work is consistent with any relevant <<adr,ADRs>>.
. Make sure you've forked the project and <<project-rq,named your branch after the issue you're working on>>.
. Add your code and tests.
.. Make sure your code adheres to the <<lint-rq,Biome style with custom project styles>>.
.. Make sure your tests adhere to the <<test-rq,test requirements>>.
. Update the API documentation.
. Update the applicable architecture guidebooks if your code significantly changes a package's inputs, outputs or primary functionality.
. Run the <<run-tests,test suite>> (which also lints the code) and correct any errors.
. Commit your changes.
. <<run-format,Run the formatter>>.
+
WARNING: The format script will modify your files, so be sure to commit your changes before running it so you can review and rollback if necessary.

. Commit any formatting changes made by the formatter.
. Push to your fork and open a merge request.

=== Documentation requirements

. Generally, imitate the style and formatting of what's already written.
This list is by no means exhaustive.
. Follow the {url-asciidoc-recommended}[one sentence per line] or "`ventilated prose`" formatting.
. Paths should be formatted with [.path]\_antora.yml_
. Reserved words should be formatted with [.term]\*versionless component*
. Quotes should generally be \"`smart quotes`"

[#adr]
=== Architecture Decisions Records

Significant project and technology decisions are outlined in our architecture decision records (ADRs).

The {url-adrs}[ADRs] are numbered in the order they were proposed.

A new ADR should be proposed prior to adding, removing, upgrading or significantly changing software dependencies, frameworks, tools, environments, infrastructure, or CI, CD, and release processes.
A new ADR should also be proposed when considering major administrative, resource, and scope changes to the Antora organization.

[#arch-gb]
=== Component Architecture Guidebooks

Each Antora component has an architecture guidebook.
A guidebook provides an overview of why the component is important and why it's structured as it is.
It outlines:

* the problem a component solves
* its high-level functionality
* its inputs and outputs
* important code, API, and data model requirements
* the consequences of the functions and requirements on the Antora pipeline

Before contributing to a component, make sure you are familiar with its guidebook.
If you make a significant modification to a package, you should also update the guidebook if applicable.

.List of Architecture Guidebooks
[%hardbreaks]
{url-cli-arch}[Command Line Interface]
{url-playbook-builder-arch}[Playbook Builder]
{url-content-aggregator-arch}[Content Aggregator]
{url-content-classifier-arch}[Content Classifier]
{url-asciidoc-loader-arch}[AsciiDoc Loader]
{url-document-converter-arch}[Document Converter]
{url-ui-loader-arch}[UI Loader]
{url-nav-builder-arch}[Navigation Builder]
{url-page-composer-arch}[Page Composer]
{url-site-generator-arch}[Site Generator]
{url-site-mapper-arch}[Site Mapper]
{url-file-publisher-arch}[File Publisher]

[#lint-rq]
=== Code structure and style expectations

We read code more than we edit it, so it's important to have consistency throughout the code base.

Antora's JavaScript code must adhere to the style defined by {url-biome}[Biome].
We've turned off a few of the style rules (e.g., noParameterAssign) to more closely match the style we've become accustomed to.
The style rules are enforced using the biome lint and format commands.

==== Biome

You can find a list of rules on the {url-biome}[Biome] site.
We have modified some of the rules, which are documented in [.path]_biome.json_.

While not enforced by Biome yet, your code should also comply with the following rules:

* Use SCREAMING_SNAKE_CASE for constant names (not any `const` declaration, but rather a formal constant).
// * we might consider defining all constants for a package in lib/constants.js
* Keep all require declarations together at the top of the file (no blank lines), and sort them alphabetically, unless there's a reason they can't be.
* Functions should be defined using the `function` keyword in main code and using `const` with a function shorthand `const fn = () => {}` in tests.
* Functions should be defined at the top of the source file and exports at the bottom.

When you <<build-project,build Antora>>, it will automatically lint (i.e., style check) your JavaScript code.

If you ever want to run the linter separately, you can use the following npm script:

 $ npm run lint

While the lint script checks for syntax, it doesn't cover all the aesthetics of a code style.
We employ Biome's format script to automatically format the code.
Run the formatter *after* you commit all your code changes as the format script will modify your files.

To run the formatter, enter the following npm script:

 $ npm run format

You can also run the linter and formatter together using the tidy script:

 $ npm run tidy

==== Paths

Paths, including both virtual file paths and filesystem paths, have to be handled carefully in Antora.
This section describes what you need to know.

In the virtual file catalog, all files have POSIX paths, which are independent of the platform on which Antora is running.
A POSIX (aka Unix-style) path is a path that uses forward slashes to separate directories and descends from a single root (no drive letter) (e.g., path/to/file.adoc).
They basically look the same as URL paths (the part after the domain).

Only when interfacing with the filesystem (input and output) can the path be platform dependent.
We use a virtual file object (currently Vinyl) to move files between the physical and virtual filesystem.
When reading a file from the physical filesystem into the virtual filesystem, it's *always* necessary to "`posixify`" the path (convert backslashes to forward slashes if the platform's path separator is backslash).
When writing a file to the physical filesystem, the path should be converted from a virtual path using Node's path module.

IMPORTANT: When assigning a POSIX path to a virtual (Vinyl) file, use `history.push` instead of `path =` to circumvent platform-specific normalization.
We eventually want to remove the need for this workaround.

To help make the distinction between virtual and physical paths in the code clear, we've introduced a convention.

When working with path calculations that pertain to virtual files as well as URLs, we must always use the https://nodejs.org/api/path.html#path_path_posix[path.posix] module.
This module exposes the POSIX-specific path operations regardless of the platform on which Antora is running.
The path.posix module should always be imported to the symbol `path`:

[source,js]
----
const { posix: path } = require('path')
----

When working with physical files (i.e., interfacing with the filesystem), we must always use the default path module.
This module provides platform-specific path operations (e.g., is aware of drive letters in Windows, can transparently convert POSIX paths to Windows paths when appropriate, etc).
The default path module should always be imported to the symbol `ospath`:

[source,js]
----
const ospath = require('path')
----

Following this practice ensure it's easy to tell from anywhere in the code whether the path is real (and thus platform-dependent) or virtual (and thus POSIX).

==== Additional style and performance rules

Please adhere to the following style and performance rules which are not currently enforced by the linter.

* Store regular expressions in constants using the suffix `_RX`.
* Use the spread operator to convert an Iterator (or similar) to an Array (e.g., `+[...map.values()]+`).
 ** Do not use `Array.from` since its performance is abysmal in Node.js 10.
* Use the `Array` constructor + `Array#fill` + `Array#map` to populate a new fixed-length array (e.g., `+Array(10).fill(undefined).map(() => <logic>)+`)
 ** Do not use `Array.from` since its performance is abysmal in Node.js 10.
* Use the spread syntax to combine arrays instead of `Array#concat` (e.g., `+[...accum, value]+` or `+[...current, ...more]+`).
 ** The spread syntax is substantially faster across all versions of Node.js.
 ** It's also clearer when you're adding a single value versus combining arrays.
 ** Always make sure the spread operator is used on the first argument.
* Use `Object.assign` to duplicate an object or combine objects (e.g., `+Object.assign({}, object)+` or `+Object.assign({}, more, { key: 'val' })+`.
 ** The performance of the spread operator on objects has degraded significantly in Node.js 12.
 ** Keep in mind that `Object.assign` modifies the first argument.
 ** Place the new object first to reduce the number of arguments, but only do so if the object to append doesn't have those properties.
 ** Prefer object spread in the test suite.
* Avoid the use of the spread syntax during assignment (`+const { prop, ...rest } = obj+`) to delete properties, unless it's executed very few times.
* If reducer function can be run in parallel, append to copy of the accumulator object instead of modifying it.
 ** Appending to a copy of the accumulator is an order of magnitude slower, so it's best to do it only when required.
* Prefer using the second argument of `then()` to define a rejection handler instead of a chained `catch()` (though this is not always possible)
* Use `~str.indexOf(c)` instead of `str.includes(c)`.
* Use `str.charAt() === c` instead of `str.startsWith(c)`
* Use `str.charAt(str.length - 1) === c` instead of `str.endsWith(c)`.
* Use `str.substr` instead of `str.slice` for chopping off leading or trailing characters.
* Use `str.substr(0, str.length - 1)` instead of `str.substr(-1)`
* Use `String()` to convert a primitive to a string (e.g., `String(1)`)
* Use `.toString()` to convert a Buffer to a string (e.g., `buff.toString()`)
* Use ++ instead of += 1 (style rule only)
* Use `v.indexOf() < 0` instead of `!~v.indexOf()` (style rule only)
* Use `err` instead of `e` for the error variable, using an optional prefix (e.g., `cloneErr`).
* If a function is not declared as async, but can return a Promise, always return a Promise (or else it is not guaranteed to response to .then)
 ** It's best to mark functions that return a Promise as async just to be sure.
* Only throw Error and derivatives of Error such as TypeError and user-defined objects that extend Error.
Although JavaScript can throw any type of object, using Error and derivatives of Error is considered a best practice.
Using any other type of value will not generate a stack trace and makes handling errors more difficult.

[#test-rq]
=== Test structure and coverage expectations

Tests should mirror the structure of the application code to make it easy for developers to find the tests that correspond to the application code.
That means each package should have a [.path]_test/_ folder adjacent to the [.path]_lib/_ folder and the test file names should match the file with the function under test.

If you need to add a new test to the suite, you can use a test in one of the packages as a reference (e.g., [.path]_packages/file-publisher/test/publish-files-test.js_).
Those tests already follow the structure of the project and demonstrate how to use mocha, chai, and the numerous helpers provided by the test harness.

Apart from the classic {url-chai}[chai] assertions, several plugins are enabled.
You'll find the documentation for their APIs here:

* {url-chai-spies}[chai-spies] to create and test spies on callbacks
* {url-chai-fs}[chai-fs] to assert files and directory structures
* {url-chai-cheerio}[chai-cheerio] to assert HTML structures (though Antora has its own implementation)
* {url-dirty-chai}[dirty-chai] (more like clean chai) to allow all terminal assertions to end with ()

Here are a few rules when writing tests and assertions:

* Name the test file using the _-test.js_ file extension.
* Always require test-utils, importing at least the `expect` function.
* Require any functions under test using the corresponding module name / path, not a relative path (npm will resolve them).
* Use `describe` to group tests into categories.
* You can use the `await` keyword in any test or before/after function, as long as you add `async` to the function declaration.
* Use BDD-style assertions (e.g., `expect(actual).to.have.property('foo')`).
* All assertions should be a function call (e.g., `to.be.true()`), not a terminal expression (e.g., `to.be.true`).
 ** The functional assertion syntax is provided by the dirty-chai plugin.
* When creating a negated assertion, please write it as `.to.not` instead of `.not.to` (e.g., `expect(actual).to.not.have.property('bar')`).
 ** To help you remember, the assertion should always begin with `.to`.
* Use `.equal` instead of `.eql` to compare strings (e.g., `expect(actual).to.equal('foo')`).
 ** expect#equal is a strict === comparison
* Use `.eql` to compare arrays and objects (e.g., `expect(actual).to.equal(['a', 'b', 'c'])`).
 ** expect#eql compares each item in the array or object, not the instance itself
 ** expect#equal always fails on two different array or object instances
* If the expected result is used many times, consider using a variable named expected.
* If you need to set up mock/spy objects for several tests, consider using `beforeEach()`.
 ** `beforeEach()` is most useful when it's used to setup spies (the call counts get reset for each test).
 ** Giving a name to a spy makes things easy in test logs.
* Place fixtures in the [.path]_fixtures/_ subdirectory of the [.path]_test_ folder.
* Use `trapAsyncError` to trap an expected Error of an async function so you can assert it using `.to.throw(message)`.

You can run the whole <<run-tests,test suite>> manually or continuously.
You can also select individual tests to run.

== Project Organization

Antora is a Node.js project organized as a set of Node.js packages that are published to the npm registry at npmjs.com.
Node.js is a JavaScript runtime based on the V8 JavaScript engine.
A Node.js package is a folder tree described by a [.path]_package.json_ file.

This section describes the organization of the project at a high level so you know where to look for files.

=== Project Structure

Here are some of the files and directories you will see when developing this project:

....
docs/         <.>
node_modules/ <.>
packages/     <.>
  asciidoc-loader/
  cli/
  content-aggregator/ <.>
    devdocs/
      architecture-guidebook.adoc
    lib/
    node_modules/ <2>
    test/
    package.json <.>
  content-classifier/
  document-converter/
  navigation-builder/
  ...
package.json  <.>
package-lock.json <.>
....
<.> The end user documentation for Antora.
<.> A local installation of Node.js modules used for the development of this project.
<.> Discrete software components (i.e., packages) that make up Antora core.
<.> The main code, test code, and architecture documentation for the content aggregator component.
Developer documentation for each software component lives alongside the code.
<.> Defines project information and runtime and development library dependencies for the content aggregator component.
<.> Defines project information, build dependencies, and run scripts.
<.> Tracks the version of resolved dependencies to ensure builds are reproducible.

[#set-up-workspace]
== Development Workspace Setup

This section gives you all the information you need to set up your development workspace and begin hacking on the code.

=== Prerequisites

In order to obtain the source code, run the test suite, and launch Antora, you'll need the following prerequisites:

* git
* Node.js / npm
* Development libraries (e.g., a C compiler)

The following sections describe the prerequisites in detail and provide resources with additional instructions about how to install them.

==== git

The source code of the project is hosted in a git repository.
The first software you'll need on your machine is git (command: `git`).
You'll use git to obtain the source code and push updates to it.

First, check if you have git installed.

 $ git --version

If not, {url-git-dl}[download and install] the git package for your system.

Although Antora doesn't use git at runtime, git is used in the test suite to provide a local git server for testing interactions with remote repositories.

==== Node.js / npm

Antora is built on {url-node}[Node.js] ("`Node`") (command: `node`).
To work with the project, you must have Node.js installed on your machine.
The Node.js installation also provides npm (command: `npm`), which you'll use to install additional Node.js modules.

To see which version of Node.js you have installed, open a terminal and type:

 $ node -v

If `node -v` doesn't return any information, you don't yet have Node.js installed.

The minimum required version of Node.js is *12.21.0*, as indicated in [.path]_package.json_.
However, we recommend using the active LTS release (currently Node.js 16).
These are also the recommended versions of Node.js for development.

.Why Node.js 12 and above?
****
Antora tracks the {url-node-releases}[Node.js release schedule].
This ensures maximum compatibility with dependencies and ensures you always receive the latest security updates.
It also means Antora can leverage the latest and greatest features of ECMAScript to deliver the best features and performance.
****

If you don't yet have Node.js installed, or the version of Node.js you have isn't Node.js 12 or greater, we strongly recommend using {url-nvm}[nvm] (Node Version Manager) to manage your Node.js installations.
Follow the {url-nvm-install}[nvm installation instructions] to set up nvm on your machine.

TIP: Many CI environments use nvm to install the version of Node.js used for the build job.
By using nvm, you can closely align your setup with the environment that is used to generate and publish the production site.

Once you've installed nvm, open a new terminal and install Node.js 16 using:

 $ nvm install 16

The above command will install the latest version of Node.js 16.

If you already have other Node.js versions installed, you can configure Node.js 16 as the default for any new terminal.

 $ nvm alias default 16

You can skip this step if you didn't previously have any Node.js versions installed because `nvm install` automatically adds the default alias to the first version of Node.js you install.

Verify the version of Node.js you have selected using:

 $ node -v

You should also be able to run `npm`:

 $ npm -v

This project uses npm (command: `npm`) to manage various tasks, such as test, lint, format, etc.
These tasks are defined in [.path]_package.json_.
You can list the available scripts by running `npm run` without any arguments:

 $ npm run

The rest of the software you need is installable from Node.js (specifically npm).

==== Development Libraries

Some Node.js packages require development libraries, such as a C compiler, to be available on your machine.
It's very likely you already have these libraries.
If for some reason you don't, you can return to this section to satisfy this prerequisite.

If you're using Linux, install the base build tools package by executing the command below that cooresponds to your Linux distribution.

* Fedora: dnf install @development-tools
* Debian/Ubuntu: apt-get install build-essential
* Arch Linux: pacman -S base-devel
* Alpine Linux: apk add g++ make
* RHEL: yum install gcc-c++ make

If your using macOS, you'll need the Xcode command line tools.
You can trigger installation using the following command:

 $ xcode-select --install

If you're on Windows, there's usually nothing you need to install.

=== Obtain the Source Code

The next step is to obtain the source code of the project, which you'll do by cloning the git repository.
*Remember to fork the repository.*

Clone the source repository using:

[subs=attributes+]
 $ git clone {url-repo} &&
   cd "`basename $_`"

You can copy and paste the above command directly into your terminal.
The command will clone the repository, then switch to the newly created project folder.

=== Install Dependencies

Initializing the project means downloading and installing the dependencies (i.e., the required software) for the project.
That's the job of npm.

[IMPORTANT]
====
You must have at least npm 8 to install the development dependencies for Antora.
If you don't have npm 8, install it into the project using:

 $ mv package.json package~.json && mv package-lock.json package-lock~.json
   npm i --no-package-lock --no-save --no-audit npm@$(node -p 'require("./package~.json").devDependencies.npm')
   rm -f node_modules/.package-lock.json
   mv package~.json package.json && mv package-lock~.json package-lock.json

You can use the version of npm installed in the project by adding `npx` in front of any `npm` command.
For example:

 $ npx npm i

To avoid having to do this, build Antora using Node.js 16 (or better), which ships with at least npm 8.
====

In your terminal, execute the following command from the root folder of the project:

 $ npm i

The command `i` is shorthand for `install`.
The install command uses dependency information defined in [.path]_package.json_ and [.path]_package-lock.lock_ to resolve dependencies, which npm then installs inside the project under the [.path]_node_modules/_ folder (and, in some cases, under the [.path]_node_modules/_ folder inside each package).

After pulling the latest source, you may need to update the dependencies.
It's best to start with a fresh slate by removing the previously install dependencies, then installing them again.
To do so, run the following commands in sequence:

 $ rm -rf node_modules packages/*/node_modules
   npm i

NOTE: If you run into problems while installing dependencies, return to <<Development Libraries>>.

NOTE: It's a good idea to run `npm i` each time after you run `git pull` to make sure your dependencies are up to date.
Running an npm script such as `npm run build` does not install any updated dependencies.

[#build-project]
=== Build the Project

To build Antora, which means running all the primary tasks, use:

 $ npm run build

To see a list of all available npm scripts, run:

 $ npm run

These commands are covered in the sections that follow.

[#run-tests]
=== Run the Test Suite

This project uses {url-mocha}[mocha] to run the tests and the assertion library {url-chai}[chai].
Mocha is configured in [.path]_.mocharc.js_.
The build script is automatically configured to lint your JavaScript code, which it does once all the tests pass.

To run the test suite and linter, use:

 $ npm run build

[TIP]
====
Tests use the Internet to query gitlab.com to download the default UI.
By default, Mocha fails any test that takes more than 2 seconds to complete.
To increase the timeout (up to 30 seconds), set the `CI` variable:

 $ CI=true npm run build
====

If you want to generate a coverage report when running the tests (enabled by default in CI), run the `coverage` script instead:

 $ npm run coverage

A coverage report shows the lines, statements, and branches that the tests exercise.
The report is generated by {url-istanbul}[istanbul] using the nyc command line tool.
You can view the coverage report by opening the HTML file [.path]_reports/lcov-report/index.html_ in your browser.

[TIP]
====
To clear the coverage report and related cache files from a previous run, use:

 $ rm -rf reports .nyc_output node_modules/.cache/nyc
====

If you don't want the `lint` script to run when running tests, call the `test` lifecycle script directly:

 $ npm test

TIP: The command `npm test` is a shorthand for `npm run test` and can be further abbreviated as `npm t`.

If you want to run the linter separately, use the following npm script:

 $ npm run lint

You can run the test suite for a single package by passing the name of the package to the `--package` flag:

 $ npm test --package ui-loader

You can include the linter as well:

 $ npm build --package ui-loader

You can include multiple packages using the syntax `{a,b}` enclosed in single quotes.

 $ npm build --package '{playbook-builder,ui-loader}'

The `--package` filter works for all npm scripts.

If you're working on tests or refactoring the code under test, you can run the test suite continuously by adding the `--watch` option:

 $ npm test --watch

You may want to combine the `--watch` option with the package filter to limit the tests to only the package you're working on:

 $ npm test --package ui-loader --watch

This command runs the test suite each time you save the test or the code under test.

You can pass additional options directly to the `mocha` command by placing them after the `--` separator.
We can use this, for instance, to specify which files to watch:

 $ npm test --package ui-loader --watch -- --watch-files='packages/ui-loader/lib/ui-catalog.js'

Run `npx mocha --help` to discover other options.

If you want to run the code coverage on a single package, use the `--package-filter` option followed by the name of the package offset by an equals sign (not a space).

 $ npm run coverage --package-filter=ui-loader

The `--package` option doesn't work in this instance since it conficts with npx.
In fact, you can always use the `--package-filter` option in all previous examples.

=== Select or Skip Tests

You can run select tests by appending `.only` to the `describe` and/or `it` method calls (e.g., `it.only()`.
You can read more about this feature in the https://mochajs.org/#exclusive-tests[mocha documentation].

You can skip tests by appending `.skip` to the `describe` and/or `it` method calls (e.g., `describe.skip()`).
You can read more about this feature in the https://mochajs.org/#inclusive-tests[mocha documentation].

[#run-format]
=== Run the formatter

The Biome formatter is run by the `format` script.
Don't forget to run the `format` script before you submit a merge request!

To run the formatter on your code, execute the following npm script:

 $ npm run format

You should run the formatter *after* you commit all your code changes.
The format script will modify your files in place.
If you still have changes to make to the code, this formatting can make that tedious.
By committing your code first, then running the formatter and committing those changes as a separate commit, it'll be easier to rollback the changes if you need to.

=== Run the development version

After fixing critical bugs or implementing your wonderful new feature, you'll probably want to test out your local Antora version on your projects.
The code in [.path]_packages_ is already set up to be run from source.
When you ran `npm i` to install the dependencies, it set up a bin stub from [.path]_node_modules/.bin/antora_ to [.path]_packages/cli/bin/antora_.

Therefore, the most convenient way to run your development code is to use the local bin stub:

 $ npx --offline antora /path/to/your/antora-playbook.yml

which is equivalent to running:

 $ ./node_modules/.bin/antora /path/to/your/antora-playbook.yml

[TIP]
====
It might be convenient to turn this script location into an alias so you can execute the development version of Antora from any directory:

 $ alias antora-dev=$HOME/projects/antora/node_modules/.bin/antora

Then you can run:

 $ antora-dev /path/to/your/antora-playbook.yml

You can instruct your shell to register this alias automatically by defining it in your shell profile (e.g., $HOME/.bash_profile).
====

=== Install a prerelease version

If you want to test the most release prerelease version which has been published to the npm registry, you need to refer to the keyword `testing` when installing a package.
Otherwise, the `npm` command (or `yarn` command) will not pick up the prerelease.

If you install packages globally using the `npm i -g` command, append `@testing` to the name of each package:

 $ npm i -g @antora/cli@testing @antora/site-generator@testing

If you install packages from [.path]_package.json_ using the `npm` command, use the keyword `testing` as the version for each entry:

----
"@antora/cli": "testing",
"@antora/site-generator": "testing",
----

Once install, you can run Antora in the normal way.

Alternately, you can use the exact version of the prerelease (e.g., `3.0.0-alpha.7`) in place of the `testing` keyword.

For more detailed instructions for how to install a prerelease, refer to the https://docs.antora.org/antora/latest/install/install-antora[installation guide], then switch to the prerelease version.

=== Continuous Integration

Both the linter and the test suite are run in a continuous integration (CI) environment on every commit to the main branch and on every merge request.
A merge request cannot be merged unless the CI pipeline succeeds.

The CI pipeline is run in the https://docs.gitlab.com/ce/ci/[GitLab CI] environment using the https://store.docker.com/images/node[node:12] docker image.
The pipeline consists of the following stages:

* .pre
 ** lint
* test

These stages, as well as any global configuration settings, are defined in the [.path]_.gitlab-ci.yml_ file at the root of the project.
The CI pipeline essentially boils down to these three commands:

* `npm i`
* `npm run lint`
* `npm test` (or `npm run coverage`)

You can view the results of the pipelines on the {url-ci-pipelines}[pipelines dashboard].

==== Skip the CI Pipeline

If you need to make a change to the repository without triggering the CI pipeline, add `[skip ci]` to the end of your last commit message.
For example:

 fix typo in README [skip ci]

This flag is reserved for small, non-software changes, as suggested by the example.

=== Develop with Docker

After {url-docker-install}[installing Docker], copy the Dockerfile below to a new folder (to limit the build context). The Dockerfile uses the most recent version of Ubuntu.

NOTE: The instructions below are based on linux and have not been tested on other platforms.
It assumes your user id is `1000` (check from command line using `id -u`).
If not, the `Dockerfile` below should be adjusted.

[source,docker]
--
FROM ubuntu:latest

# to allow sourcing of nvm environment scripts
SHELL ["/bin/bash", "-c"]

RUN apt-get update && apt-get install -y \
      curl \
      git \
    && apt-get -y autoclean

RUN groupadd node \
    && useradd -m -u 1000 -g node node # create user as part of node group with home directory

USER node

ENV NVM_DIR "/home/node/.nvm"
ENV NODE_VERSION 12.18.4

RUN mkdir $NVM_DIR \
    && curl --silent -o- "https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh" | bash \
    && source $NVM_DIR/nvm.sh \
    && nvm install $NODE_VERSION \
    && nvm alias default $NODE_VERSION \
    && nvm use default

ENV NODE_PATH $NVM_DIR/v$NODE_VERSION/lib/node_modules
ENV PATH $NVM_DIR/versions/node/v$NODE_VERSION/bin:$PATH

RUN cd $HOME \
    && git clone https://gitlab.com/antora/antora \
    && cd "$(basename "$_")" \
    && npm i # install packages

WORKDIR /home/node/antora

CMD ["bash"]
--

To build the image use

 $ docker build --no-cache -t antora-my-dev:latest .

Now to run a bash console in the container use

 $ docker run -it antora-my-dev bash
 node@bcb6b82c8224:~/antora$

You now have a development environment! You may use e.g. `npm run build` as described previously.

==== Develop from a host machine

If you want to run tests within a container when editing code from a host machine, you may wish to share the code between the container and the host.

However Docker intentionally disallows mounting from the container to the host because it breaks container portability.
// see https://stackoverflow.com/questions/26050899/how-to-mount-host-volumes-into-docker-containers-in-dockerfile-during-build[stackoverflow]
For the sake of development, we can work around this:

1. run a container

 $ docker run --name dev01 -it antora-my-dev bash
 node@bcb6b82c8224:~/antora$

2. transfer data from the container to the host. In another terminal window:

 $ docker cp dev01:/home/node/antora antora

3. exit the first terminal window (by typing `exit` in the bash console) and start a new container with the bind mount for the data  from the host to the container:

 $ docker run -it --mount type=bind,source=$(pwd)/antora,destination=/home/node/antora antora-my-dev bash

The `antora` folder on the host machine can now be opened for development.

////
One can leave e.g. `npm test` running inside the container or `npm run test:watch`

[TIP]
====
If using `npm run test:watch` make sure there are enough file watches allowed on the system. To adjust this on linux (temporarily), use the following command on the host machine:

 $ sudo sysctl fs.inotify.max_user_watches=524288
====
////

To restart the development environment, execute the command described in the 3rd step above from the working folder.

== Project Maintainers

The project maintainers are responsible for:

* managing organization and project permissions
* managing the community and code of conduct
* setting ADR statuses
* merging requests into the main branch
* managing and releasing the pipeline

[#mr-approval]
=== Merge Request Review and Approval Guidelines

Each merge request is assigned at least one reviewer.
The reviewer is responsible for making sure the MR meets the project and issue criteria, for answering questions the contributor may have regarding the MR, and for suggesting ways the MR can be improved if necessary.

*The MR should not be approved if*:

* there was no agreement about what change to make in the linked issue
* it fails the CI pipeline
* it doesn't meet the project's workflow, code, test or documentation requirements
* it doesn't meet the acceptance criteria of its associated issue

*If the MR needs to be modified, notify the contributor and add helpful information to the MR or the issue*.
Once the contributor has modified the MR, evaluate it again.

When the MR meets the project and issue criteria, it can be merged into the main branch.
*When the branch is ready to be merged into the main branch*:

* Rebase the MR if necessary.
* Modify the commit message(s) if necessary.
* Check _remove source branch_.
* Don't squash the commits, except in especially messy-weird situations.
** The maintainer only guarantees to preserve the original work in the MR.
* Modify the default merge commit message; it should only contain two lines.
** The first line should specify the merge number.
** The second line should be the MR subject submitted by the contributor.
For example:
+
----
merge !46

resolves #59 configure lerna and npm workspaces
----
* Press _Merge_.


// /docs/modules/ROOT/pages/whats-new.adoc
[[whats-new.adoc]]
= What's New in Antora {page-component-version}
:description: The new features, changes, and bug fixes included in Antora {page-component-version} and its patch releases.
// :doctype: book
// :route: New
//:page-toclevels: 0
// :leveloffset: 1
:url-releases-asciidoctor: https://github.com/asciidoctor/asciidoctor/releases
:url-releases-asciidoctorjs: https://github.com/asciidoctor/asciidoctor.js/releases
:url-gitlab: https://gitlab.com
:url-issues: {url-repo}/issues
:url-milestone-3-2-0: {url-issues}?scope=all&state=closed&label_name%5B%5D=%5BVersion%5D%203.2.0
//:url-milestone-3-2-1: {url-issues}?scope=all&state=closed&label_name%5B%5D=%5BVersion%5D%203.2.1
:url-mr: {url-repo}/merge_requests

== Antora 3.2.0

_**Release date:** TBD | *Issue label:* {url-milestone-3-2-0}[3.2.0^]_

The primary focus of Antora {page-component-version} is to provide and refine certain API methods and endpoints to support the development of Antora extensions.
This release also added syntax for the inclusion and exclusion matching of worktrees and the ability to use the `ref` placeholder in the `edit_url` key.

You can find a summary of the issues resolved in this release below.

=== Resolved issues

==== Added

Issue {url-issues}/535[#535^]:: Allow linked worktree to be used as content source; automatically resolve main repository location and remap HEAD reference in branches (content-aggregator).
Issue {url-issues}/1006[#1006^]::
* Use value of `versionSegment` property on component version in place of version in output path and URL of pages (content-classifier).
* Set dynamic `activeVersionSegment` property on component version to indicate which version segment is in use (content-classifier).
Issue {url-issues}/1008[#1008^]:: Add `addSplatAlias` method to `ContentCatalog` for adding a splat (i.e., directory) alias (content-classifier).
Issue {url-issues}/1013[#1013^]:: Add support for `ref` placeholder to insert full name of git ref (e.g., `refs/heads/v4.0.x`) in value of `edit_url` key on content source (content-aggregator).
Issue {url-issues}/1015[#1015^]::
* Emit `componentsRegistered` event after all components and versions have been registered (site-generator).
* Store raw files, nav, and startPage data on partially constructed component version until processed (content-classifier).
* Add readable property named `files` to component version in `ContentCatalog#registerComponentVersionStartPage` to get files for component version on access (content-classifier).
* Add readable property named `startPage` to component version in `ContentCatalog#registerComponentVersionStartPage` to look up start page for component version on access (content-classifier).
* Update `ContentCatalog#registerComponentVersionStartPage` to return start page (content-classifier).
Issue {url-issues}/1016[#1016^]:: Add syntax to match current branch of specific worktrees in branches pattern (for inclusion or exclusion) (e.g., `HEAD@5.8.x`) (content-aggregator).
Issue {url-issues}/1021[#1021^]:: Discover implicit site start page in component version promoted to site root (content-classifier).
Issue {url-issues}/1096[#1096^]:: Add `git.read_concurrency` playbook key to control how many git indexes to load into memory at once (playbook-builder).
Issue {url-issues}/1084[#1084^]::
Detect (and skip) Antora extension that's been registered as an AsciiDoc extension and log a warning (asciidoc-loader)
Issue {url-issues}/1084[#1104^]::
Detect (and skip) AsciiDoc extension registered as an Antora extension and log a warning (site-generator)
Issue {url-issues}/1090[#1090^]::
Add `git.fetch_depth` key to control how many recent commits Antora fetches from a remote repository (playbook-builder)

==== Changed

Issue {url-issues}/1009[#1009^]:: Remove invalid trailing slash from value of `site.url` when building playbook and from value of `site.url` after `playbookBuilt` event (i.e., when it's provided by an extension) (playbook-builder).
Issue {url-issues}/1012[#1012^]:: Always assign the value `auth-required` to `origin.private` if the server requests credentials, even when the credentials are embedded in content source URL (content-aggregator).
Issue {url-issues}/1026[#1026^]:: Don't recompute resource ID on file from content aggregate if `src.family` is set (content-classifier).
Issue {url-issues}/1094[#1094^]::
* Fix relative path computation when path is extensionless and to matches parent folder of from (asciidoc-loader).
* Fix result of relativize helper when path is extensionless and to matches parent folder of from (page-composer).
Issue {url-issues}/1096[#1096^]::
* Change default value of `git.fetch_concurrency` to 1 (playbook-builder).
* Flag git clone/fetch error as recoverable if an unexpected network error occurs (content-aggregator).
* Decouple step to load (fetch or clone) repositories from step to scan repositories to discover references and start paths and collect files (content-aggregator).
Issue {url-issues}/1099[#1099^]::
* Preserve all information in wrapped error (content-aggregator, ui-loader, file-publisher)
Issue {url-issues}/1098[#1098^]::
* Upgrade isomorphic-git to incorporate patch for properly handling network error (content-aggregator)
* Add cause in log message when retrying failed fetch/clone operations in series (content-aggregator)
Issue {url-issues}/1101[#1101^]::
* Clear timeout and keep-alive settings on git HTTP connections that don't use custom agent (content-aggregator)
Issue {url-issues}/1121[#1121^]::
Replace new fs.Stats() with plain JavaScript object (content-aggregator, ui-loader)
Issue {url-issues}/1128[#1128^]::
Replace @vscode/gulp-vinyl-zip with low-level zip file reader using yauzl (ui-loader)
Issue {url-issues}/1128[#1129^]::
Replace @vscode/gulp-vinyl-zip with low-level zip file writer using yazl (file-publisher)
Issue {url-issues}/1088[#1088^]::
Log warning if nav entry cannot be resolved (content-classifier)
Issue {url-issues}/1109[#1109^]::
Fix `page.role` assignment to read value from `role` attribute instead of from (non-existent) `docrole` attribute (page-composer)
Issue {url-issues}/1121[#1121^]::
Assign empty object to stat property of output file if file does not have stat property (file-publisher)
Issue {url-issues}/1131[#1131^]::
Replace vinyl-fs#dest with internal implementation (file-publisher)
Issue {url-issues}/1133[#1133^]::
Upgrade vinyl and vinyl-fs to address security and deprecation warnings
Issue {url-issues}/298[#298^]::
Use worktree from local repository even if repository has no commits (content-aggregator)
Issue {url-issues}/1135[#1135^]::
Monkey patch pako module to use zlib.inflate to inflate git objects (content-aggregator)
Issue {url-issues}/1145[#1145^]::
Don't apply camelCase transformation to descendant keys of the `ext` key in component version descriptor (content-aggregator).
Issue {url-issues}/1157[#1157^]::
Switch from ESLint/Prettier to Biome and update code formatting accordingly.
(No issue)::
* Set Node.js 18 as minimum required version of Node.js
* Upgrade @antora/expand-path-helper and @antora/user-require-helper dependencies to 3.0.x in various packages.
* Prefix name of all built-in modules with node: (#1136)
* Don't read git tree twice if start path is empty; add dirname to tree object in same function (content-aggregator).
* Fill in progress bar with incomplete marks if cloning a repository fails (content-aggregator).
* Mention that credentials may have been rejected if server requests them, then sends 404 response (content-aggregator).
* Shorten `urlSegment` fragment in internal property names on ContentCatalog to `segment` (e.g., `latestVersionUrlSegment` -> `latestVersionSegment`) (content-classifier).
* Don't assign fallback value to `url` property on component version if property is already set (content-classifier).
* Print site URL instead of file URI in completion message if CI=true (site-generator).
* Change gulp-vinyl-zip dependency to @vscode/gulp-vinyl-zip (no functional changes) (ui-loader and file-publisher).
* Don't retry failed clone/fetch operation if playbook only has one content source URL (content-aggregator)
* Update description for `extension` CLI option to clarify it may be specified multiple times.
* Don't include file in archive (zip) if contents property is null; matches behavior of fs publisher (file-publisher)
* Include `-` segment in edit URL for file hosted on gitlab.com to avoid redirct.
* Add directory property to repository entry in package files

==== Fixed

Issue {url-issues}/1007[#1007^]:: Set `src.version` to original version segment and `src.rel.version` to actual version on splat alias file (content-classifier).
Issue {url-issues}/1010[#1010^]:: Fix infinite authorization loop if credentials embedded in the content source URL are empty and the repository requires authorization (content-aggregator).
Issue {url-issues}/1018[#1018^]:: Fix crash if value of `worktrees` key on content source is `~` (`null`) and at least one branch is specified (content-aggregator).
Issue {url-issues}/1020[#1020^]:: Add guard to prevent `ContentCatalog#registerSiteStartPage` from registering alias loop (content-classifier).
Issue {url-issues}/1022[#1022^]:: Decouple logic to compute default log format from process environment (playbook-builder).
Issue {url-issues}/1024[#1024^]:: Preserve target when creating static route if target is an absolute URL (redirect-producer).
Issue {url-issues}/1025[#1025^]:: Allow content aggregator to parse value of `content.branches` and `content.tags` playbook keys (playbook-builder).
Issue {url-issues}/1049[#1049^]:: Restore error stack in log output when using pino-std-serializers >= 6.1 (logger).
Issue {url-issues}/1070[#1070^]:: Add hostname to ignore list to prevent hostname property on logged error from modifying logger name (logger)
Issue {url-issues}/1064[#1064^]:: Consider local branches in non-managed bare repository that has at least one remote branch (content-aggregator).
Issue {url-issues}/1092[#1092^]:: Don't fail to load AsciiDoc if target of image macro resolves to an unpublished image (asciidoc-loader).
Issue {url-issues}/1095[#1095^]:: Retry loadUi in isolation after aggregateContent if network connection occurs when retrieving remote UI bundle (site-generator).
Issue {url-issues}/1096[#1096^]:: Retry failed fetch/clone operations in serial if git.fetch_concurrency > 1 and an unexpected error occurs (content-aggregator).
Issue {url-issues}/1112[#1112^]::
Throw clearer error if antora.yml is empty or the data is not an object (content-aggregator)
Issue {url-issues}/1110[#1110^]::
Apply include tag filtering update from Asciidoctor (see https://github.com/asciidoctor/asciidoctor/pull/4233) to ported logic in Antora (asciidoc-loader)
Issue {url-issues}/1114[#1114^]::
Filter out cyclic aliases (i.e., redirect loops) (redirect-producer)
Issue {url-issues}/1134[#1134^]::
Create files streams for file publishers to process eagerly to avoid race condition (file-publisher)
Issue {url-issues}/1137[#1137^]::
Use raw value if attribute value set using `--attribute` option cannot be parsed as YAML (cli)
Issue {url-issues}/1147[#1147^]::
Gracefully handle case when value of `nav` key in component version descriptor is not an array (content-aggregator).
Issue {url-issues}/1159[#1159^]::
Use navtitle as content of orphan breadcrumb entry instead of doctitle (aka page title) (page-composer).
Issue {url-issues}/1158[#1158^]::
Fully support static register method on Class or Object exported by extension (site-generator).
(No issue)::
* Use consistent formatting for error messages in playbook builder (playbook-builder).
* Correctly handle connection error when retrieving remote UI bundle (ui-loader).
* Don't fail to load AsciiDoc if pub or pub.moduleRootPath properties are not set on virtual file (asciidoc-loader).
* Look for IS_TTY on `playbook.env` in site generator to decouple check from process environment (site-generator).

[#thanks-3-2-0]
=== Thank you!

Most important of all, a huge *thank you!* to all the folks who helped make Antora even better.
The {url-chat}[Antora community] has provided invaluable feedback and testing help during the development of Antora {page-component-version}.

We also want to call out the following people for making contributions to this release:

Raphael ({url-gitlab}/reitzig[@reitzig^]):: Fixing an error in the edit URL documentation ({url-mr}/940[!940^]).
{url-gitlab}/stoobie[@stoobie^]:: Documenting how to uninstall Antora globally resolves ({url-issues}/1014[#1014^]).

////
Gautier de Saint Martin Lacaze ({url-gitlab}/jabby[@jabby^])
Alexander Schwartz ({url-gitlab}/ahus1[@ahus1^])::
Andreas Deininger ({url-gitlab}/deining[@deining^])::
Ben Walding ({url-gitlab}/bwalding[@bwalding^])::
Daniel Mulholland ({url-gitlab}/danyill[@danyill^])::
Ewan Edwards ({url-gitlab}/eedwards[@eedwards^])::
George Gastaldi ({url-gitlab}/gastaldi[@gastaldi^])::
Germo Görtz ({url-gitlab}/aisbergde[@aisbergde^])::
Guillaume Grossetie ({url-gitlab}/g.grossetie[@g.grossetie^])::
Hugues Alary ({url-gitlab}/sturtison[@sturtison^])::
Jared Morgan ({url-gitlab}/jaredmorgs[@jaredmorgs^])::
Juracy Filho ({url-gitlab}/juracy[@juracy^])::
Marcel Stör ({url-gitlab}/marcelstoer[@marcelstoer^])::
Paul Wright ({url-gitlab}/finp[@finp^])::
Raphael Das Gupta ({url-gitlab}/das-g[@das-g^])::
Sturt Ison ({url-gitlab}/sturtison[@sturtison^])::
Vladimir Markiev ({url-gitlab}/Grolribasi[@Grolribasi^])::
////

// /docs/modules/ROOT/pages/asciidoctor-upgrade-notes.adoc
[[asciidoctor-upgrade-notes.adoc]]
= Asciidoctor Upgrade Notes

Antora 3 uses Asciidoctor.js 2.2.x (Asciidoctor 2.0.x) instead of Asciidoctor.js 1.5.9 (Asciidoctor 1.5.8) to process content files.
Asciidoctor 2 introduces many new features and a few substantive changes to existing features.

== Asciidoctor 2 feature changes

The following sections describe the new behavior of existing Asciidoctor features and suggest the actions you should take prior to upgrading from Antora 2 to Antora 3.

=== Non-AsciiDoc files and the include directive

|===
|Feature |New behavior |Action

|Including non-AsciiDoc files using the include directive, particularly inside verbatim (listing, literal, or source) blocks
|Trailing space characters aren't removed, tabs aren't expanded, and newlines aren't normalized when including a non-AsciiDoc file using the include directive.
This can change how the output is displayed.
.3+.^a|* Update non-AsciiDoc files that use a mix of tabs and spaces or inconsistent newlines if their content isn't displaying as expected when published.
* Replace any tabs in non-AsciiDoc files if the `indent` attribute is set but not working as expected.
* Remove trailing space characters from non-AsciiDoc files, especially if using callouts in the file content or applying the `indent` attribute.

|Including non-AsciiDoc files with the `indent` attribute set on the include directive or verbatim block into which they're inserted
|Since tabs aren't expanded in the non-AsciiDoc content, the `indent` attribute may not work as expected.

|Including non-AsciiDoc files with callouts into a verbatim block using the include directive
|Since trailing spaces aren't removed, callout numbers may no longer be detected.
|===

=== Listing and source blocks

|===
|Feature |New behavior |Action

|Delimited listing blocks without an explicit style when `source-language` is set
|Delimited listing blocks (`+----+`) that don't have an explicit style are automatically promoted to source blocks if `source-language` is set in the document, component descriptor, or playbook.
This may result in unwanted syntax highlighting.
a|If `source-language` isn't set, you don't need to take any action.

If `source-language` is set, do the following:

* Assign the style `listing` to any unstyled delimited listing blocks that shouldn't be promoted to source blocks.
You can also change them to delimited literal blocks (`+....+`).
* (optional) Remove the style `source` from delimited listing blocks that should be promoted to source blocks.
The `source` style is applied automatically.

See xref:asciidoc:source.adoc[] to learn more.

|Source blocks that aren't assigned a language
|The language `none` is automatically assigned to source blocks (`source`) when no language is set on the block or by `source-language`.

The block is styled like other source blocks, but no syntax highlighting is applied.
a|If this behavior is acceptable, no change is needed.
Otherwise, do one of the following:

* assign the appropriate language to the source block, or
* remove the `source` style and replace it with the `listing` style, or
* remove the `source` style and change the block to a delimited literal block (`+....+`).

See xref:asciidoc:source.adoc[] to learn more.
|===

=== Tables

|===
|Feature |New behavior |Action

|`a` and `l` column modifiers
|Normal substitutions and default header formatting are now correctly applied to the cells in an implicit header row when the AsciiDoc (`a`) and literal (`l`) modifiers are applied to the columns in a table.
|Update tables that use the `a` and `l` modifiers in combination with an implicit header row so your desired output is displayed.

|`v` modifier
|The verse modifier (`v`) is deprecated.
Columns or cells assigned the `v` modifier are now treated as regular table cells.
|No action is needed if it's acceptable for the cell content to be displayed as regular content.

|`table-topbot` CSS class
|The CSS class `table-ends` replaces the deprecated `table-topbot` CSS class.
|If you customized the styles for `table-topbot` in your UI, update the class name to `table-ends` and build a new UI bundle version.

|Table column width
|The rounding used when calculating table column widths changed minutely.
|No action is needed as the change shouldn't be noticeable to site visitors.
|===

=== Lists

|===
|Feature |New behavior |Action

|Description list delimiters (`::`)
|Description list delimiters, that is, double colons (`::`) that are bare or at the start of line are no longer mistaken for a description list item.
|Remove escape syntax around double colons (`::`) that were previously mistaken for description list delimiters.
|===

=== Section and block titles

|===
|Feature |New behavior |Action

|Section and block title substitution order
|The order of substitutions applied to section and block titles now matches the normal substitution order.
This can affect section and block titles that use attribute references.
|Review section and block titles that contain attribute references for errors.
|===

=== Invalid and unresolved references and attributes

|===
|Feature |New behavior |Action

|"`Unresolved include directive`" message in the content
|The message has changed to "`Unresolved directive`".
|No action unless you're using a postprocessor that looks for this message in the output.

|`page` class
|The class `page` for xrefs has been replaced with `xref <family>`, where `<family>` is the name of the family of the resource to which the xref points (e.g., `xref page`).
|You will need to update the selector in your CSS or postprocessor if it attempts to match this class.
You can now find all xref links in the page using the CSS selector `a.xref`.

|`page unresolved` class
|The class `page unresolved` has been replaced with `xref unresolved` when the target of an xref is invalid or could not be resolved.
|You will need to update the selector in your CSS or postprocessor if it attempts to match this class.

|Reference validation for inline anchor
|If Asciidoctor cannot locate a reference to an inline anchor, even if it exists, it will log a message at the info level about a possible invalid reference.
|Define inline anchors using the double square bracket enclosure, and only place them in locations where Asciidoctor scans for them.
Valid locations include anywhere in paragraph text or at the start of a list item or table cell.
You could also ignore these messages or not enable the info log level.

|`attribute-missing`
|The `attribute-missing` setting is now honored when include directives and block macros are processed.
This may reveal new missing include files and references.
|Check the log messages for new warnings and fix any reported errors.
|===

=== Footnotes

|===
|Feature |New behavior |Action

|Footnote macro
|The `footnoteref` macro is deprecated and the structure of the `footnote` macro has changed to be consistent with other AsciiDoc macros.
Previously, the footnote target was placed inside the macro's square brackets.
Now the target is placed directly after the colon (`+footnote:<target>[<optional attributes>]+`).
|Change `footnoteref` to `footnote` and move the footnote target to the correct position.

|Anchors and xrefs in footnotes
|Anchor and xref macros are processed before footnote macros so that footnote macros aren't terminated prematurely.
|Remove escape syntax, such as a backslash (`+\+`), from anchor and xref macros used inside footnote macro attribute lists.
|===

=== Quote block

|===
|Feature |New behavior |Action

|`""` quote block delimiter
|The 2-character `""` quote block delimiter is deprecated.
|Remove the deprecated `""` delimiters and replace with the `quote` block style with the four underscores (`+____+`) block delimiters or quote paragraph syntax.
|===

=== Encoding

|===
|Feature |New behavior |Action

|Encode characters in email address to comply with RFC-3986
|Previously, spaces in an email address were encoded as `%20`.
Now, spaces are encoded as a plus sign (`{plus}`) in email addresses to comply with https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent#Description[RFC-3986].
|This change will not affect the behavior of email links.
|===

== Semantic versioning and Asciidoctor 2

Starting with Asciidoctor 2.0.0, Asciidoctor and Asciidoctor.js switched to semantic versioning.
This allows Antora to automatically pick up the latest patch versions of Asciidoctor.js during installation without having to make a new Antora release available.

NOTE: Ready to upgrade from Antora 2 to Antora {page-component-version}?
See xref:install:upgrade-antora.adoc[] for instructions.

// /docs/modules/ROOT/pages/features.adoc
[[features.adoc]]
= How Antora Can Help You and Your Team
:keywords: Docs as Code, content management system, product team, documentation administration, documentation management, agile documentation, DocOps, documentation operations
:navtitle: How Antora Can Help

== Agile and secure

*Automate the assembly of your secure, nimble static site as changes happen instead of wrestling with a CMS giant.*

Rebuild and deploy your site automatically in a matter of seconds in response to any change.
Never have to worry about patching security holes in your deployed CMS application since you don't have one.
All pages are static--in the JAMstack style.
Need to migrate your site to a different domain?
Just rebuild the site and relaunch it on the new host.
Antora generates sites that are static in the truest sense of the word.
The site can be run on any web server, on any domain or subdomain, inside a subfolder, and even from the local file system.

*Adapt your site to fit seamlessly with your other web properties.*

No site is an island.
Sites must play nice with others to maintain a consistent brand and user experiences.
Static sites generated by Antora are well-suited for this role.
With page templates and a little help from an automated process, you can blend your documentation pages into existing sites, giving the impression it's all part of a single uniform site.

== Tap into a ready-made collaboration workflow

*Use a git-based CI workflow to manage documentation changes, contributions, and initiatives.*

Go where the development is.
Whether it's GitHub, GitLab, Bitbucket, or another code hosting service, you can tap into these platforms to develop *Docs as Code*.
Not only does a git-based CI workflow give you collaboration and review tools for free, it also encourages collaboration to happen across teams.
As a result, the docs become part of the software development process.
And that means many more people feel ready to support the effort to improve the docs.

*Manage teams and permissions by leveraging existing development infrastructure.*

Chances are, your software product already has a well-defined team, permission structure, and contributor community.
You can use the same organization or build on it to manage your docs team.
These platforms can serve as an administrative and management interface for your docs, whether it's to monitor activity or grant access to perform certain actions.

The primary goal of Antora is not necessarily to be the easiest way to write, though that goal is very important to us.
It's about being able to write collaboratively using an efficient workflow that also offers flexibility when it comes to publishing, add-ons, content organization, and content discovery.
There may be easier ways for an individual to write in isolation.
We're looking at the challenge of writing in a distributed, often large team.

//== Publish a site from a simple playbook
== Produce a site from a simple playbook

*Describe what you want to make and Antora takes it from there.*

Antora was built for writers first.
Writers want to write, not fiddle with reconfiguring software.
That's where Antora's playbook comes in.
A playbook is a concise way to describe the site you want to produce.
// , which lives in a configuration-only playbook project,
This description boils down to a) where to get the content, b) what UI to apply to the pages, and c) where to publish it.
That's all Antora needs to know to do its job.
Only when you're looking for additional customization do you need to dive deeper.

*Offline first.*

A site generated using Antora can be viewed entirely offline.
All the references in the site are self-contained (i.e., relative), so you don't need to run a web server to view it.
Just open one of the generated HTML files in your browser and from there you can navigate to all the pages from the UI.
Even redirects work offline by default.
If a web server is available, you can pass additional configuration to tell Antora to take advantage of its capabilities.

// This section feels just a touch discordant to me
////
*No build automation or system administration required.*

Antora likes to keep concerns separate.
The details of how Antora generates and publishes a site aren't mixed up with the instructions to build the site.
Component and version information is stored with the content.
The playbook describes which components to use.
Antora puts the two together.
No internal wires get exposed.
////

== Bring together content from multiple repositories

*Use a single build to aggregate documentation that spans repository boundaries and branches.*

Most site generators are confined to a single branch of a single repository.
Antora, on the other hand, knows how to speak git.
It goes out and gathers up all the content the site needs using its built-in git client.
It then sorts through the files by separating them into versions of components.
This allows you to store the documentation in a way that works best for your organization, whether it means keeping content with code or using separate repositories.
Antora can round up all those disparate projects and repositories and create an integrated site.

*Pick and choose content to handcraft your site.*

You won't always want to include everything in the site.
Sometimes, you just want to build a "`microsite`" that includes a reduced selection of products or versions.
Or perhaps you just need to preview the documentation for the product you're currently working on.
The playbook lets you produce multiple variations of a site from the same content sources simply by tuning which sources you draw from.

== Document all the versions
//== Document multiple versions of your product

*Build each version of the product as part of one site.*

Since software is versioned, the documentation for it needs to be versioned too.
Otherwise, users won't know which version of the software the documentation they're reading covers.
Confusion ensues.
Like with software, you can use branches and tags to manage versions of the documentation.
This content can even be stored with the software itself.
Antora happily gathers all this content and organizes it so users can access each version of the documentation, all under a single site.

*Explore different product versions or navigate between pages across versions.*

With multiple versions of documentation available, the user needs a way to navigate to them.
Antora provides a catalog of documentation components and versions that are presented to the reader as a menu.
The reader can scan the menu and jump right to the version of the documentation they need.
Additionally, each page can self identify as being part of a version sequence, allowing the user to quickly visit older or newer versions of the content on the page.
//References to these other versions can also be added to the main content.

== AsciiDoc: Minimal markup, maximum functionality

*Document using an intuitive syntax designed specifically for technical documentation that's lightweight, yet comprehensive.*

When you write documentation, the last thing you want getting in your way is the markup syntax.
To create the best content, you need to be able to see what you're writing, but still be able to represent different content types appropriately.
That's exactly what AsciiDoc affords.
Its line-oriented, left-aligned syntax is easy to browse and leaves room for applying just enough metadata to build a semantic structure.
AsciiDoc is a documentation writer's best friend.

*Keep your content DRY using reusable attributes, includes, and syntax extensions.*

Every time you type something you've typed before, you're losing efficiency and introducing the risk of divergent content.
AsciiDoc provides several tools to keep you from having to repeat yourself.
You can use attributes to avoid having to type URLs, product names, or definitions multiple times.
You can use includes to extract whole paragraphs, sections, and other reusable content to common files.
And you can introduce extensions to the syntax to reduce commonly repeated patterns, such as references to an issue tracker, or new types of content, such as equations and charts, to shorthand.

*Pages are simply AsciiDoc documents that can be edited in any text editor.*

Creating a page in the documentation is as simple as creating an AsciiDoc document.
The document can be opened and previewed in a text editor, or it can be viewed in the context of the site.
Antora assigns the page an implicit ID so it can be referenced from other pages, and it can reference other pages using the implicit ID of those pages.
Features such as section titles, admonition blocks, and highlighted source listings are styled appropriately.

//(or source-based)
== Source-to-source references

*Create references between pages and other resources using a source-to-source xref system that's concise and easy to construct.*

Instead of relying on generated filenames or URLs, you create references between pages and other resources using the location of the target in the source system.
This makes reasoning about references easy since you only have to think about where the source file is located, not how it gets processed.
In other words, you stay in the source coordinate system.
And you get the benefit of the context of the current source file, so you only need to specify the traits of the target that differ from the current context.

*Source-to-source references provide the necessary information to decouple the site from the filesystem and publishing environment.*

By expressing a reference using a resource ID, Antora can intelligently create a link to the resource in the published output that isn't coupled with the filesystem or publishing environment.
//It can do that since it understands the intent of the reference and is called on to translate it.
That means the generated site can be viewed anywhere, including offline.

== Navigation as content

*Describe the documentation navigation using AsciiDoc lists.*

Writers using Antora can feel right at home when defining navigation.
Why?
Because, like pages, the navigation is just another AsciiDoc document.
But instead of free-form content, the navigation file contains a list hierarchy that gets translated into the navigation trees you see in the navigation menu sidebar.
To add another navigation tree, you simply add an additional list.
//The navigation item content accepts any inline formatting, including links.

*Create navigation links using the same xref system that's used in the main content.*

So how do you create a link to a page from the navigation?
Using an xref, of course.
Since the navigation file is just content, it can use the same xref system that's used by the main content to create links between pages.
Think of a navigation file as a page that doesn't get published.
And since the file is stored with the content, the xrefs can be contextual, meaning you only have to specify the traits of the target that differ from the current context.

== Interchangeable UI

*The site's user interface and theme is maintained separately from the content.*

A key theme in Antora is separation of content and presentation.
This is prominently seen in the UI.
Antora interfaces with a site UI that is stored and managed as a separate project.
// that gets consumed by the site generator.
It passes a UI model to a Handlebars template that the UI provided.
The template then decides what to display from the model, giving the UI full control over the page layout.
The template also decides what CSS and JavaScript to include.
//The template is selected based on the layout assigned to the page.

//*Can be developed independently, giving you maximum freedom to tailor the UI and theme to your needs.*
*Iterate on the UI independently from the content.*

Since the UI and content are maintained separately, they can follow different release cycles.
And no toes get stepped on.
The work done on the UI does not interfere with the work done on the content.
When Antora runs, it fuses the latest content and the latest UI together.
This means it's easy to swap one UI and theme with another, which can be useful for redesigns, A/B testing, or campaigns.
You have maximum freedom to tailor the UI and its theme(s) to your needs.

== Built-in support for page redirects

*Retain URLs of old pages in a transparent way by storing the information in the target document.*

Change happens.
You just need to be ready to deal with it.
// when it does.
One of the most frequent changes in a documentation site are the URLs of pages, which change as the pages get renamed or reorganized.
Antora provides a way to retain the URLs of old pages by declaring page aliases.
Like other features in Antora, this information is stored with the content, in this case in the header of the target AsciiDoc document.

*Redirects are described using aliases, which are simply inbound xrefs; not coupled to URLs.*

As you might expect, a page alias is a source reference, which allows Antora to take care of creating the redirect from the correct URL.
Since not all hosting environments are the same, the facility for performing a redirect isn't either.
Antora generates the appropriate configuration for the redirect facility that the hosting environment provides, falling back to good old-fashioned static bounce pages if no other mechanism is supported.

== Publish sites to multiple destinations

*Publish anywhere, whether local or remote.*

Sites are meant to be published.
Antora helps with that.
Whether the destination is local or remote Antora streams the content there using a built-in or custom provider.
And yet, no matter where the site is published, the site is not coupled to the host environment.
Antora supports as many output streams as you want, which could be a local directory, a local archive, a directory on a remote SSH server, or a web service endpoint like S3, or a combination of destinations.
You can be sure Antora gets the files where they need to go for publishing.
All in a single build.

*No need for a separate step, tool or script in the pipeline.*

Antora's file publisher saves you a step in the pipeline.
Most site generators write the output to a local directory, which you then have to turn around and publish.
Antora sends the output directly to the destinations you specify.
And since the references in the site are not coupled to the publishing environment, you can even preview the site offline by publishing it to a local directory.

== Sensible defaults. Open architecture.

*Start with the default.*

Antora offers an opinionated site generator and UI out of the box so you can get up and running quickly.
You interface with the site generator using the `antora` CLI command, which you can install yourself or invoke using the Docker container.
Just point the command at your playbook and Antora kicks out a multi-component, multi-version documentation site for you.
Once you've had a chance to set up or migrate your documentation for use with Antora, you can graduate from the defaults and start tailoring Antora to fit advanced requirements.

//*Tap into the pipeline to incorporate additional content, perform custom processing, or add your own behavior.*
//*Make Antora yours.*
*Tailor Antora just for you.*

Antora features an open architecture.
What does that mean?
It means you have the ability to teach Antora new tricks.
Perhaps you need to incorporate additional content into Antora's catalog.
Or maybe you want to perform custom processing somewhere along the line.
You can even introduce your own behavior to reconfigure Antora to fit your needs.
Antora was designed so you can use it as a foundation when the provided site generator doesn't suit you.

// Not yet
////
*Reuse the core components to assemble a custom site generator pipeline.*

Let's say you like some of the ideas in Antora, but you want to truly go your own way.
There's no need to start from scratch.
Select some of the components in Antora as a starting point and assemble your own site generator pipeline.
You never know.
Your experiments could make their way back into Antora, allowing you can revert back to a built-in pipeline.
////

// /docs/modules/ROOT/pages/how-antora-works.adoc
[[how-antora-works.adoc]]
= How Antora Works
//The playbook is a configuration file that contains an inventory of documentation component names, branches, and addresses.

Antora's site generator handles all aspects of creating a documentation site, from fetching and aggregating to converting and arranging the content to publishing the files of the generated site.
This page describes that process in detail.

The default pipeline is opinionated to get you started as quickly as possible.
But understand that Antora features a modular, open architecture.
That means this architecture can accommodate specialized use cases by allowing custom Antora components, such as a validators, to be inserted into the pipeline at strategic points as needed.
This page focuses on the core, built-in Antora components and capabilities in Antora.

== Steps in the default generator pipeline

The steps listed in this section describe the operations the site generator performs.
Certain operations are executed asynchronously, so some of the steps below may occur in a different order or happen simultaneously.
For example, the UI is fetched and loaded while the content is being aggregated to optimize use of the network.

Build playbook::
When you're ready to generate a site, you pass Antora a playbook file and tell it to run.
+
A xref:playbook:index.adoc[playbook file is a simple configuration file] that can be written in YAML, JSON, or TOML.
It contains information and settings such as what content to use, how the content should be processed, how the site should be generated, and where to publish the output.
+
Antora reads the playbook file and builds a playbook from it, which it then uses to drive the pipeline.

Load content repositories::
Using the xref:playbook:configure-content-sources.adoc[content sources] listed in the playbook, Antora loads the specified git repositories or local content folders in preparation to scan them for content files.
+
For each remote URL, Antora clones the remote git repository into a local cache using the built-in git client.
If the repository has already been cloned, Antora fetches updates if configured to do so.
+
Finally, Antora determines which references (branches, tags, and start paths) to use from the specified repositories.

Find the content source roots::
Starting at a xref:content-source-repositories.adoc[content source root], Antora identifies a group of files as being part of a component version when it finds a component version descriptor file named [.path]_antora.yml_.
These source files can be stored in a single repository, at the root of a repository or in a subpath, or distributed across multiple repositories.

Transform input files into virtual file objects::
Antora collects all of the files--text, images, samples, and other supporting materials--from each xref:standard-directories.adoc[content source root subtree].
Then it creates a virtual file of each input file.

Assign files to component version buckets::
Antora reads the component version descriptor ( [.path]_antora.yml_) files.
+
A xref:component-version-descriptor.adoc[component version descriptor] associates the files under it with a specified component name and version, that is, a component version.
This allows the files to be decoupled from the repository in which they live and makes Antora's URL agnostic xref:page:xref.adoc[cross references] possible.
+
Antora assigns the descriptor information and other source metadata to the virtual files.
Then it sorts each file into a virtual collection based on the assigned component version data.
+
A xref:component-version.adoc[component version] typically represents a discrete and unique version of the documentation for a project, library, service, or training course.

Compute additional metadata::
Using xref:playbook:configure-site.adoc[site properties] from the playbook and information assigned to the files in the previous step, Antora adds module, family, family-relative path, and other metadata values to each file.
It also computes the output path (disk) and publish path (URL) information for each publishable file.

Organize files into a content catalog::
Antora further sorts the aggregated files into a content catalog that can be queried and transmitted.

// add pages xref when page is available
Convert AsciiDoc files to embeddable HTML::
The AsciiDoc files in the xref:pages-directory.adoc[page family] of the content catalog are converted to embeddable HTML with Asciidoctor.js.

Convert navigation files::
Antora retrieves xref:navigation:index.adoc[navigation files] from the content catalog, translates their contents into navigation items organized in a specified hierarchy (navigation trees grouped inside a navigation menu), and returns a navigation model.

Locate and fetch UI bundle::
Antora finds the xref:playbook:configure-ui.adoc[UI bundle using the URL listed in the playbook] and fetches it.
The UI bundle can be cached locally or remote.

Transform UI files into virtual file objects::
Antora extracts the UI files in the bundle and creates a virtual file object for each file containing the file's contents and path information.

Classify UI files::
Antora identifies the static UI files using the UI descriptor file ([.path]_ui.yml_) and sets the file type to static.
It sets the type for all other files based on their location (asset, layout, helper, partial).

Compute UI file output paths::
For each UI file that is publishable (of type static or asset), Antora computes its output path.

Organize UI files into UI catalog::
The virtual UI files are sorted into a transmittable collection.

Wrap converted AsciiDoc content in page templates::
Antora determines which page template each page requests.
It populates the identified UI template with the page's embeddable HTML, site metadata, context data (component, version) for page, version, and product selectors, and navigation model information for menus and breadcrumbs.
+
Relying on a page template to produce the pages gives the site owner complete control over the construction of the pages, and thus complete control over the UI.

Produce sitemap::
Antora generates a site map that can be used as an internal report or published with the site.
This sitemap is partitioned by component name (using a sitemap index).
The sitemap index links to the sitemap for each component name, which is where the URLs for the individual pages can be found.

Publish site::
Antora writes the generated pages to a default or xref:playbook:output-dir.adoc[user-specified location].
The site can be published in multiple formats to multiple locations over multiple protocols using xref:playbook:configure-output.adoc[built-in and custom destination providers].

It's possible to substitute the default site generator with a custom one.
You first need to create a library or script that exports the function with signature `generateSite(args, env)`.
Within that script, you're free to import core components from Antora to reassemble your own pipeline.
You then activate your pipeline by passing the name of the library or script to the `--generator` option of the xref:cli:index.adoc[Antora CLI].

// /docs/modules/ROOT/pages/install-and-run-quickstart.adoc
[[install-and-run-quickstart.adoc]]
= Install and Run Antora Quickstart
:listing-caption!:
:url-demo: https://gitlab.com/antora/demo

This quickstart walks you through the initial steps required to install Antora and generate your first documentation site.

On this page, you’ll learn:

* [x] How to install Node.js.
* [x] How to install Antora.
* [x] How to create your first Antora playbook.
* [x] How to run Antora to generate a site based on the playbook.

You can skip the installation steps by using the xref:antora-container.adoc[Docker image] provided by the Antora project.
Instead of having to worry about installing Node.js and Antora, all you need is Docker or Podman to run Antora in a container.

[#install-nodejs]
== Install Node.js

Antora requires an active long term support (LTS) release of Node.js.
To see if you have Node.js installed, and which version, open a terminal and type:

 $ node -v

This command should return an {url-node-releases}[active Node.js LTS version number], for example:

[subs=+attributes]
 $ node --version
 v{version-node}

If you have an active Node.js LTS version on your machine, you're ready to <<install-antora,install Antora>>.

If *no version number is displayed in your terminal*, you need to install Node.js.
We recommend using nvm to install Node.js, though you are free to take a different path.
Follow one of these guides to learn how to install nvm and Node.js on your platform.

* xref:install:linux-requirements.adoc#install-nvm[Install nvm and Node.js on Linux]
* xref:install:macos-requirements.adoc#install-nvm[Install nvm and Node.js on macOS]
* xref:install:windows-requirements.adoc[Install nvm and Node.js on Windows]

If *you have Node.js installed, but it isn't an active LTS version*, you need to upgrade Node.js.
To upgrade to the latest Node.js LTS version and set it as your default version, type the following commands in your terminal:

.Linux and macOS
[subs=+attributes]
 $ nvm install --lts
 $ nvm alias default {version-node-major}

.Windows
[subs=+attributes]
 $ nvm install {version-node}
 $ nvm alias default {version-node}

Once you've installed Node.js, it's time to install Antora.

[#install-antora]
== Install Antora

To generate documentation sites with Antora, you need the Antora command line interface (CLI) and the Antora site generator.
To install Antora, begin by making a new directory for your site named [.path]_docs-site_ and switch to it.

 $ mkdir docs-site && cd docs-site

Next, let's initialize a [.path]_package.json_ file and install the required packages within the playbook project so you can run the `antora` command using `npx`.

[subs=+attributes]
 $ node -e "fs.writeFileSync('package.json', '{}')"
ifdef::page-component-version-is-latest[]
 $ npm i -D -E antora
endif::[]
ifndef::page-component-version-is-latest[]
 $ npm i -D -E antora@{page-component-version}
endif::[]

NOTE: Refer to xref:security-bulletins.adoc[] to remediate any security vulnerabilities that are reported.

Verify the `antora` command is available by running:

 $ npx antora -v

If the installation is successful, the command will report the version of the Antora CLI and site generator packages you specified.

[subs=+attributes]
 $ npx antora -v
 @antora/cli: {release-version}
 @antora/site-generator: {release-version}

These versions can also be found in [.path]_package.json_ (pulled in transitively by the antora package), which you can use to upgrade Antora.

You have the option of installing Antora globally so that the `antora` command is available on your PATH.
To do so, pass the `-g` option to `npm i`.

[subs=+attributes]
ifdef::page-component-version-is-latest[]
 $ npm i -g antora
endif::[]
ifndef::page-component-version-is-latest[]
 $ npm i -g antora@{page-component-version}
endif::[]

You can verify that the `antora` command is available on your path by running:

 $ antora -v

We strongly recommend that you install Antora within the playbook project.
This strategy makes it easier to manage the version of Antora.
It also ensures that the version of Antora matches the version for which the playbook was made.

Now you're ready to create your first playbook.

TIP: See xref:install:install-antora.adoc[Install Antora] for more detailed information and additional installation methods.

== Create a playbook with remote sources

To produce a documentation site, Antora needs a playbook, which is defined using a playbook file.
The simplest way to start using Antora is to point the playbook at existing documentation stored in remote repositories (i.e., content sources).
For this example, we'll use the content sources from the {url-demo}[Antora demo repositories].

Using your preferred text editor or IDE, create a new file and populate it with the configuration information <<demo-playbook,listed below>>.
Save this file as [.path]_antora-playbook.yml_ in the [.path]_docs-site_ directory you made in the previous step.

.antora-playbook.yml
[#demo-playbook,yaml]
----
site:
  title: Docs Site
  start_page: component-b::index.adoc # <.>
content:
  sources: # <.>
  - url: https://gitlab.com/antora/demo/demo-component-a.git
    branches: HEAD
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: [v2.0, v1.0]
    start_path: docs
ui: # <.>
  bundle:
    url: https://gitlab.com/antora/antora-ui-default/-/jobs/artifacts/HEAD/raw/build/ui-bundle.zip?job=bundle-stable
    snapshot: true
----
<.> A page from a component version to be used as the home page for your site.
<.> The `sources` category contains the list of git repository locations, branch name patterns, and other repository properties that Antora uses when aggregating the site content.
<.> The `ui` category contains keys that specify the location of the UI bundle and how it should be processed.

TIP: See the xref:playbook:index.adoc[Antora playbook] for more detailed information about the playbook file.

== Run Antora

To generate the site, point the `antora` command at your playbook file.
In the terminal, make sure you're in [.path]_docs-site_ directory, then type:

 $ npx antora antora-playbook.yml

Antora will clone the content and UI repositories and generate your documentation site into the default output directory and report the file URL to that directory in the terminal.

To see the result, navigate to the provided URL in your browser, which renders the [.path]_index.html_ file located in the [.path]_docs-site/build/site_ directory.
Congratulations!
You've successfully built your first site with Antora.

By default, Antora does not sync the repository once it clones it.
Instead, it tries to work offline by using the repository in the cache it previously cloned.
This default can create some confusion when getting started.
Therefore, we recommend including the xref:playbook:runtime-fetch.adoc#fetch-option[`--fetch` option] in the command until you're more familiar with Antora.

 $ npx antora --fetch antora-playbook.yml

You can turn on the fetch behavior permanently by setting the xref:playbook:runtime-fetch.adoc#fetch-key[fetch key] in your playbook.

TIP: For more detailed information about running Antora and troubleshooting help, see xref:run-antora.adoc[Run Antora to generate your site].

== Create a playbook with a local source

Antora also supports local content sources, which are git repositories that have been cloned or otherwise initialized on the current machine.
What that means is that it's possible to create a site from a local repository that contains both the playbook and the content source(s) (i.e., a mono site).
For this example, you can set up everything locally in the [.path]_docs-site_ directory created earlier without having to rely on any remote git repositories.

To start, it's necessary to initialize the [.path]_docs-site_ as a local git repository.

 $ git init
   git commit --allow-empty -m init

If you're adding Antora to an existing local git repository, this step is not required.

Next, create enough of the xref:standard-directories.adoc[standard directory hierarchy] to store a couple of pages, the navigation file, and the component version descriptor for your content source root.
This content source root could be placed at a start path such as [.path]_docs_, but we'll use the root of the repository for now.

 $ mkdir -p modules/ROOT/pages

Using your preferred text editor or IDE, create a the start page for the component version and populate it with a page title and some text.

.modules/ROOT/pages/index.adoc
[,asciidoc]
----
= Welcome!

You are home.
----

Create one additional page so that you can study how the navigation is put together.

.modules/ROOT/pages/new-page.adoc
[,asciidoc]
----
= New Page

You've found a new page.
----

Next, create a navigation file so that each page contains links to navigate to the other pages.

.modules/ROOT/nav.adoc
[,asciidoc]
----
* xref:new-page.adoc[]
----

Notice that the start page for the component version is not included.
That's because it's automatically added as the root of the navigation tree.

To finish putting together the content source root, create the component version descriptor, [.path]_antora.yml_.
This file identifies a content source root and, in turn, defines a component version.
We'll create a versionless component named *project-name*, though you make this a versioned component or even the xref:component-name-key.adoc#root-component[ROOT component].

.antora.yml
[,yaml]
----
name: project-name
version: ~
title: Project Name
nav:
- modules/ROOT/nav.adoc
----

Now that you have a local content source defined, you can create a playbook that uses it.
Save the playbook file as [.path]_antora-playbook.yml_ adjacent to [.path]_antora.yml_ at the root of the [.path]_docs-site_ directory.

.antora-playbook.yml
[,yaml]
----
site:
  title: Docs Site
  start_page: project-name::index.adoc
content:
  sources:
  - url: .
    branches: HEAD
ui:
  bundle:
    url: https://gitlab.com/antora/antora-ui-default/-/jobs/artifacts/HEAD/raw/build/ui-bundle.zip?job=bundle-stable
    snapshot: true
----

This repository defines the start page for the component version we created as the start page for the site.
The `start_page` playbook key (under the `site` key) isn't required if the component version you created is the ROOT component.

Here's how the file and directory structure inside the [.path]_docs-site_ directory should look when you're done.

....
📒 docs-site
  📂 modules
    📂 ROOT
      📂 pages
        📄 index.adoc
        📄 new-page.adoc
      📄 nav.adoc
  📄 antora.yml
  📄 antora-playbook.yml
....

You can now generate the site as you did before.

 $ npx antora antora-playbook.yml

Antora will generate your documentation site to the default output directory and report the file URL to that directory in the terminal.
To see the result, navigate to the provided URL in your browser, which renders the [.path]_index.html_ file located in the [.path]_docs-site/build/site_ directory.

To instruct git to ignore the output directory and any locally installed npm packages, create a [.path]_.gitignore_ file and populate it with the following contents:

..gitignore
----
/build/
/node_modules/
----

To learn more about local content sources, refer to xref:playbook:content-source-url.adoc#local-urls[Use local content repositories].
Local content sources can be mixed with remote content sources in the same playbook, so try adding the remote content sources shown ealier in this quickstart to become familiar with how it works.

== Learn more

* Learn how to xref:organize-content-files.adoc[organize your content files] for Antora.

// /docs/modules/install/pages/linux-requirements.adoc
[[linux-requirements.adoc]]
= Linux Requirements
:platform: Linux
//tag::shared[]
:url-nvm: https://github.com/nvm-sh/nvm
:url-nvm-install: {url-nvm}#installation-and-update

On this page, you'll learn:

* [x] How to install Node.js.

Since Antora is built on Node.js, you'll need Node.js (commands: `node`, `npm`, and `npx`) installed on your machine to install and run Antora.

[#node]
== Node.js

You can use any active LTS or maintenance LTS version of Node.js with Antora, but we recommend using the most recent active LTS version so that you benefit from the latest performance and security enhancements.
The {url-node-releases}[Node.js release schedule^] shows the active Node.js LTS versions.

To see if you have Node.js installed, and which version, open a terminal and type:

 $ node --version

You should see a version string, such as:

[subs=attributes+]
....
v{version-node}
....

If *the command fails with an error*, it means you don't have Node.js installed.
The best way to install Node.js is to use nvm (Node Version Manager).
Skip to <<install-nvm>> to find instructions.

ifeval::["{platform}" == "Linux"]
NOTE: If your package manager provides Node.js and npm packages, _and you're familiar with using the tools installed system-wide_, you may choose to go that route.
However, we believe you'll be more successful if you choose <<install-nvm,nvm>>.
endif::[]

If *the command returns a version that isn't an active LTS version*, upgrade to the latest Node.js LTS version <<upgrade-node,using nvm>> (or your package manager).

If *the command returns an active Node.js LTS version*, make sure that version is set as your default version by typing the following command in your terminal:

[subs=attributes+]
 $ nvm alias default {version-node-major}

Now you're ready to xref:install-antora.adoc[install Antora].

[#install-nvm]
== Install nvm and Node.js

We recommend using the {url-nvm}[Node Version Manager (nvm)^] to manage your Node.js installations, though this is not a requirement.
Follow the {url-nvm-install}[nvm installation guide^] to set up nvm on your machine.
Once you've successfully installed nvm, close your current terminal, open a new one, and return here.

NOTE: If you get `nvm: command not found` after running the install script, then it did not complete successfully.
Be sure to follow all prompts issued by the install script.
Consult the troubleshooting section in the {url-nvm-install}[install guide^] if you run into problems.

TIP: Many CI environments use nvm to manage the version of Node.js used in the build job.
By using nvm, you can align your setup with the environment used to generate and publish your production site.

Once you've installed nvm, open a new terminal and install the active Node.js LTS release.

 $ nvm install --lts

The above command will install the active LTS release of Node.js and automatically set it as your default alias.

Now that you have Node.js set up, you can xref:install-antora.adoc[install Antora].

[#upgrade-node]
== Upgrade Node.js using nvm

If you have nvm installed, but don't have the latest LTS version installed, type the following command in your terminal:

 $ nvm install --lts

To set the latest version of Node.js as the default for any new terminal, type:

[subs=attributes+]
 $ nvm alias default {version-node-major}

Now that you're on the latest LTS version of Node.js, you can xref:install-antora.adoc[install Antora].
//end::shared[]

// /docs/modules/install/pages/macos-requirements.adoc
[[macos-requirements.adoc]]
= macOS Requirements
:platform: macOS
include::page$linux-requirements.adoc[tag=shared]

// /docs/modules/install/pages/windows-requirements.adoc
[[windows-requirements.adoc]]
= Windows Requirements
:url-choco: https://chocolatey.org
:url-nvm-windows: https://github.com/coreybutler/nvm-windows

Antora is a portable application that runs on any Node.js installation.
Since Node.js is distributed for and runs on Windows, that means Antora runs on Windows without any additional requirements.

On this page, you'll learn:

* [x] How to install Chocolatey, the Windows package manager.
* [x] How to install Node.js.

If you've never installed Antora before, you'll need to complete the steps on this page before you can install Antora and use it to generate a documentation site.
Since Antora is built on Node.js, you'll need Node.js (commands: `node`, `npm`, and `npx`) installed on your machine to install and run Antora.

[#node]
== Node.js

You can use any active LTS or maintenance LTS version of Node.js with Antora, but we recommend using the most recent active LTS version so that you benefit from the latest performance and security enhancements.
The {url-node-releases}[Node.js release schedule^] shows the active Node.js LTS versions.

To see if you have Node.js installed, and which version, open PowerShell and type:

 $ node --version

You should see a version string, such as:

[subs=attributes+]
....
v{version-node}
....

If *the command fails with an error*, you don't have Node.js installed.
The best way to install Node.js on Windows is to use Chocolatey.
If you don't have Chocolatey on your machine, go to <<install-choco,install Chocolatey>> to get it set up.
Otherwise, skip directly to <<install-nvm,install nvm and Node>>.

If *the command returns a version that isn't an active LTS version*, upgrade to the active Node.js LTS version <<upgrade-node,using nvm>>.

If *the command returns an active Node.js LTS version*, you're all set to xref:install-antora.adoc[install Antora].

[#install-choco]
== Install Chocolatey

The best way to install the Node Version Manager (nvm) and Node.js is with {url-choco}[Chocolatey^], the package manager for Windows.

. Open a PowerShell terminal and run it as an Administrator by right clicking on the PowerShell icon and selecting menu:Run as Administrator[].

. Type the following command in the terminal:

 $ Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))

You're now ready to install nvm and Node.js.

[#install-nvm]
== Install nvm and Node.js

. Open a PowerShell terminal, right click on the PowerShell icon, and select menu:Run as Administrator[].
+
TIP: If you just installed Chocolatey using the instructions in the proceeding section, use the same terminal (running as Administrator) that you already have open.

. To install the {url-nvm-windows}[Node Version Manager (nvm) for Windows^], enter the following command in the terminal:

 $ choco install -y nvm

. Close the terminal.

. Open a new, regular PowerShell terminal, and install Node.js using nvm.
+
--
[subs=attributes+]
 $ nvm install {version-node}

IMPORTANT: When using nvm for Windows, you must enter an exact version of Node.js (e.g., `{version-node}`) until {url-nvm-windows}/issues/214[nvm-windows#214^] is resolved.
--

Now that Node.js is installed, you're ready to xref:install-antora.adoc[install Antora].

.nvm and CI environments
****
You can install the LTS release of Node.js directly, without installing nvm, by entering the following command in the Administrator PowerShell:

 $ choco install -y nodejs-lts

However, many CI environments use nvm to install the Node.js version used for the build job.
By using nvm, you closely align your setup with the environment used to generate and publish your production site.
****

[#upgrade-node]
== Upgrade Node.js using nvm

If you have nvm installed but your Node.js version is not an active LTS release, type the following command in your terminal:

[subs=attributes+]
 $ nvm install {version-node}

IMPORTANT: When using nvm for Windows, you must enter the full version of Node.js (i.e., `nvm install {version-node}`).

== Learn more

Once you've installed Node.js, you're ready to xref:install-antora.adoc[install Antora].

// /docs/modules/install/pages/install-antora.adoc
[[install-antora.adoc]]
= Install Antora

To generate and publish documentation sites with Antora, you need the Antora command line interface (CLI) and the official Antora site generator or a custom one.
This page explains how to install Antora using its default configuration.

Assumptions:

* [x] You've installed an active Node.js LTS release on your xref:linux-requirements.adoc#node[Linux], xref:windows-requirements.adoc#node[Windows], or xref:macos-requirements.adoc#node[macOS] machine.

On this page, you'll learn:

* [x] How to run Antora without installing it.
* [x] How to install Antora locally (recommended).
* [x] How to install the Antora CLI and site generator packages globally.

== Try before you install

If you're just evaluating Antora, you can use `npx` to run it without having to install it first.

 $ npx antora -v

The `npx` command, provided by Node.js, can run a command directly from a local or remote npm package.
If any required packages are not present in the local project dependencies, npx will install them into a cache folder (typically [.path]_$HOME/.npm/_npx_) before running the command.
If the name of the command matches the name of the package that provides it, you don't have to specify the package name.
In this case, the *antora* package, which bundles the CLI and site generator, provides the *antora* command and the dependencies it needs to run.

Using `npx` without installing any packages is only intended for evaluation, and only works when using Antora by itself.
Once you need additional packages, you'll need to install them along with Antora before running `npx`.

You'll see later that we recommend using the `npx` command to run Antora whenever you have installed it locally.

== Locally vs globally

When we say "`locally`" on this page, we mean within the playbook project (i.e., the directory where the playbook file for the site is located) or any parent folder.
We recommend installing Antora locally, especially if you're managing several documentation sites.
Installing Antora locally makes it easier to manage the version of Antora and ensures that the version of Antora matches the version for which the playbook was made.
It also avoids any permission problems you may run into when trying to install Antora globally.

When we say "`globally`" on this page, it doesn't necessarily imply system-wide.
Rather, it means the location where Node.js is installed.
If you used nvm to install Node.js, this location will be inside your home directory (thus not requiring elevated permissions).
We only recommend installing Antora globally if you're familiar with how Antora works and are comfortable with this setup.

Your best chance for success is to install Antora locally.
At the very least, you should start there.

[#install-dir]
== Install Antora locally

To install Antora locally, begin by switching to the directory of your playbook project (creating it, if necessary).
We'll assume here that the name of this folder is [.path]_docs-site_.

 $ cd docs-site

Next, let's install the CLI package within the playbook project so you can run the `antora` command using `npx`.

[subs=+attributes]
 $ node -e "fs.writeFileSync('package.json', '{}')"
 $ npm i -D -E @antora/cli@{page-component-version}

As an alternative to the first command, you can use `npm init -y`.
However, `npm init` adds a lot of extra keys that you may not need.

The `@antora/cli` package and its dependencies will be installed into the [.path]_node_modules_ folder inside your playbook project.
The optional `-D` option tells `npm` to save the package as a development dependency in [.path]_package.json_.
The `-E` option tells `npm` to store the exact version in [.path]_package.json_ rather than prefixing it with a semver range operator.

IMPORTANT: The `@` at the beginning of the package name informs `npm` that the `cli` package is located under the `@antora` scope.
If you omit this character, `npm` will assume the package name is the name of a git repository on GitHub.

NOTE: The second `@` in the package name designates the start of the requested version number.
Except for prerelease versions, you can specify the major and minor segments only (e.g., `@{page-component-version}`), which ensures you retrieve the latest patch release.

When you install Antora locally, the `antora` command is not placed on your PATH.
Instead, you run the `antora` command using `npx` (i.e., `npx antora`).

Verify the `antora` command is available through `npx` by running `npx antora -v`.

 $ npx antora -v

This command should report the version of the Antora CLI in the terminal.

[subs=attributes+]
 @antora/cli: {release-version}
 @antora/site-generator: not installed

The `npx` command will look for the `antora` command installed within the playbook project or any parent directory of the playbook project.
If you're prompted to install the *antora* package, then the CLI was not found.

If you're using Bash, you can save some typing by creating an alias for `npx antora` named `antora`:

 $ alias antora='npx antora'

Now you can run `antora` without having to remember to prefix it with `npx`:

 $ antora -v

You can bypass this alias by prefixing the command with a backslash, which will search for `antora` on your PATH instead.

 $ \antora -v

Although `npx` finds the `antora` command and reports the CLI version, we're still missing the site generator.
Next, install the site generator package within the playbook project:

[subs=+attributes]
 $ npm i -D -E @antora/site-generator@{page-component-version}

The `@antora/site-generator` package and its dependencies will be installed into the [.path]_node_modules_ folder inside your playbook project.
Antora's CLI will look for the site generator package in this folder first before looking in the global installation folder.

Now when you run `npx antora -v`, you should see the version of both the Antora CLI and the site generator printed in the terminal.

[subs=attributes+]
 @antora/cli: {release-version}
 @antora/site-generator: {release-version}

If you open [.path]_package.json_, you'll see the version of these packages listed there too, as development dependencies.

[,json,subs=+attributes]
----
{
  "devDependencies": {
    "@antora/cli": "{release-version}",
    "@antora/site-generator": "{release-version}"
  }
}
----

You'll also notice an additional file named [.path]_package-lock.json_.
This file stores the resolved version of all packages and their dependencies.
You may choose to commit this file when you commit [.path]_package.json_.

TIP: If you're reinstalling Antora, it's best to first remove the [.path]_node_modules_ folder.
If you also want to get the latest version of each dependency, remove the [.path]_package-lock.json_ file as well.
If you remove the [.path]_node_modules_ folder, be sure to install the CLI package again.
Another option is to use `npm ci`, which will automatically remove [.path]_node_modules_ when reinstalling.

If the `antora` command reports the version of both the CLI and the site generator, and those versions match, that confirms you have installed Antora correctly.

== Install Antora globally

You have the option of installing Antora globally so that the `antora` command is available on your PATH.
To install Antora globally, pass the `-g` option to `npm i`.

[subs=attributes+]
 $ npm i -g antora@{page-component-version}

Verify the `antora` command is available on your PATH by running:

 $ antora -v

If installation was successful, the command should report the version of the Antora CLI and site generator.

[subs=attributes+]
 $ antora -v
 @antora/cli: {release-version}
 @antora/site-generator: {release-version}

The benefit of installing Antora globally is that it is always available in your terminal, no matter what directory you are in.
While this may seem convenient at first, there are problems with this strategy.
The version of Antora you have installed may not match the version of Antora for which the documentation site was made.
And there's no way for Antora or the documentation site to verify these are the same.
So you may end up running into esoteric problems and find yourself struggling to get them in sync.
Installing Antora locally and running it using `npx` will give you the best chance for success and compatibility.

CAUTION: If you're using a system-wide Node.js installation managed by your operating system's package manager, you may run into permission problems when installing packages globally.
In that case, you'll need to <<install-dir,install Antora directly in your project repository>>.

== Uninstall a global Antora installation

To uninstall a global installation of Antora, use the `npm rm` command:

 $ npm rm antora @antora/cli @antora/site-generator

Verify the `antora` command is no longer available on your PATH by running:

 $ antora -v

If the removal was successful, the command should report information similar to the following output snippets in your terminal:

[subs=attributes+]
....
bash: antora: command not found...

Need to install the following packages:
 antora@{release-version}
....

== Learn more

After Antora is installed, you're ready to:

* Set up your own xref:playbook:index.adoc[playbook] or use the Demo playbook.
* Organize your xref:ROOT:organize-content-files.adoc[content source files and repositories] or use Antora's Demo content repositories.
* xref:ROOT:run-antora.adoc[Run Antora] and generate a documentation site.

// /docs/modules/install/pages/upgrade-antora.adoc
[[upgrade-antora.adoc]]
= Upgrade Antora
// https://github.com/npm/cli/releases/tag/

On this page, you'll learn:

* [x] How to upgrade Node.js.
* [x] How to upgrade Antora globally.
* [x] How to upgrade the Antora CLI and site generator individually.

NOTE: If you're already on Antora 3.0 and ready to upgrade to Antora {page-component-version}, skip the next section and go directly to <<node,Upgrade Node.js>>.

include::partial$upgrade-checklist.adoc[]

[#node]
== Upgrade Node.js (optional)

You can use any active LTS or maintenance LTS version of Node.js with Antora, but we recommend using the most recent active LTS version so that you benefit from the latest performance and security enhancements.
The {url-node-releases}[Node.js release schedule^] shows the active Node.js LTS versions.

To check which Node.js version you have installed, open a terminal and run:

 $ node --version

If you need to upgrade to the active Node.js LTS version, run:

.Linux and macOS
 $ nvm install --lts

.Windows
[subs=attributes+]
 $ nvm install {version-node}

Next, to set the latest version of Node.js as the default for any new terminal, run:

.Linux and macOS
[subs=attributes+]
 $ nvm alias default {version-node-major}

.Windows
[subs=attributes+]
 $ nvm alias default {version-node}

Now you're ready to upgrade to the latest version of Antora.

== Upgrade Antora locally

If you installed Antora locally, you will use [.path]_package.json_ to manage the version.
This file tracks which version of Antora you currently have installed.
You can use the file to specify a different version.
The `npm i` command will consult this file to determine which packages and which versions of those packages to install.

. Switch to your playbook project where your Antora playbook file (e.g., [.path]_antora-playbook.yml_) is stored.

. Open the [.path]_package.json_ file.

. Change the version number of the CLI and site generator.
+
[,json,subs=attributes+]
----
{
  "devDependencies": {
    "@antora/cli": "{page-component-version}",
    "@antora/site-generator": "{page-component-version}"
  }
}
----
+
TIP: Unless you're installing a prerelease, we recommend specifying only the major.minor version number so you receive the latest patch update.

. Save the file.

. (Optional) Remove the [.path]_node_modules_ folder and [.path]_package-lock.json_ file.
Although removing the [.path]_node_modules_ folder is not always required, doing so ensures you get a fresh installation.
If you're using at least npm 8, this step is usually unnecessary.

. Upgrade the Antora packages by running the `npm i` command.

 $ npm i

You've now upgraded to the latest version of Antora.

As an alternative to removing the [.path]_node_modules_ folder, you can use `npm upgrade`, which closely mimics a fresh installation.

== Upgrade Antora globally

If you installed Antora globally, you can upgrade them by reinstalling the packages:

In a terminal, run:

[subs=attributes+]
 $ npm i -g antora@{page-component-version}

The `npm i` command will remove any existing packages with the same name and install them anew.

.Do I have Antora installed globally?
****
To list your globally installed Node.js packages, type the following command in your terminal:

 $ npm ls -g --depth=0

If you've installed Antora globally, you'll see entries for the Antora CLI and Antora site generator packages listed in the terminal output alongside their version numbers.

.List of globally installed Node.js packages
[subs=attributes+]
....
/home/user/.nvm/versions/node/v{version-node}/lib
├── @antora/cli@{release-version}
├── @antora/site-generator@{release-version}
├── npm@{version-npm}
└── ...
....
****

== Learn more

Review xref:ROOT:whats-new.adoc[What's New in Antora] for the latest features and potential breaking changes.

// /docs/modules/install/pages/supported-platforms.adoc
[[supported-platforms.adoc]]
= Supported Platforms and System Requirements
:navtitle: Supported Platforms
:test-count: over 2008
:test-coverage: 99%
// URLs
:url-issues: {url-repo}/issues
:emdash: &#8212;{zwsp}

Antora runs on Linux, macOS, and Windows.
Thanks to this broad platform support, Antora is also used on many cloud platforms and continuous integration and delivery servers.

== Platforms

Our general policy is to align Antora's support of a platform version with the upstream project's lifecycle schedule for that version.
When a platform version reaches the end of active support by its maintainers or its end of life (EOL){emdash}which ever comes first{emdash}Antora no longer supports it.

// When we have specific notes about a platform (tweaks and/or links to bugs) add a 3rd column to this table labeled "Good to Know"
[cols="20,25a",width="50%"]
|===
|Supported Platform |Supported Version(s)

|Alpine Linux
|&#8805; 3.13

|Debian
|&#8805; 10.12

|Fedora
|&#8805; 35

|Ubuntu
|[%hardbreaks]
18.04 LTS
20.04 LTS

|macOS
|[%hardbreaks]
Catalina (10.15)
Big Sur (11.6)
Monterey (12.4)

|Microsoft
|[%hardbreaks]
Windows 10
Windows 11
Windows Server 2016
Windows Server 2019

|Chrome
|Latest stable version

|Firefox
|Latest stable version

|MS Edge
|Latest stable version

|Node.js
|[%hardbreaks]
LTS (&#8805; 18)
|===

.About the Antora Test Suite
****
At last count, Antora had {test-count} tests that cover {test-coverage} of the lines.
You could say we're just a teeny-tiny bit obsessed with writing high quality tests and improving test coverage.
****

=== Cloud platforms

Antora should operate as designed on common cloud platforms.
How you provision your cloud instance depends on your workload requirements and remote git repository sizes.
If you're running Antora on a cloud platform, we would love to hear about your experience in Antora's {url-chat}[community chat^].

== Hardware recommendations

Your hardware requirements will depend primarily on the size of the remote git repositories your Antora pipeline fetches content from when it is generating your site.

The first time Antora runs, it fetches and clones all of the remote git repositories specified in a playbook.
The speed of this operation is dictated by the size of the remote repositories, environment input/output parameters, and network performance.
After the initial run, Antora caches the repositories locally.
On subsequent runs, Antora only reconnects to the remote repositories if the xref:playbook:runtime-fetch.adoc[fetch option] is enabled or the xref:playbook:runtime-cache-dir.adoc[cache folder] is removed.

[cols="2s,4",width="75%"]
|===
|RAM
|Memory requirements depend on the size of your Git repositories.
3GB should provide sufficient headroom.

|I/O
|Maximum throughput and minimum latency always make things nicer but aren't required.
|===

=== Tuning the memory limit

Even if the machine you're using has sufficient memory (RAM), not all that memory will be allocated to the Node.js process.
If the Node.js process tries to use more memory than is allocated to it, the system may terminate the Node.js process (SIGKILL).

Node.js starts with a conservative memory limit (typically 2048 MiB, but it depends on the system).
You can allocate more memory to the Node.js process using the `--max-old-space-size` CLI option.
You can pass this option to Node.js when running Antora using the `NODE_OPTIONS` environment variable.

 NODE_OPTIONS="--max-old-space-size=4096"

You'll need to experiment with this value to find the setting that works best for your site.
Refer to https://stackoverflow.com/questions/48387040/how-do-i-determine-the-correct-max-old-space-size-for-node-js[How do I determine the correct "max-old-space-size" for Node.js?^] for more information on this topic.

== Learn more

* xref:upgrade-antora.adoc[Upgrade to the latest Antora release].

* Install Antora for the first time on:

** xref:linux-requirements.adoc[Linux]
** xref:macos-requirements.adoc[macOS]
** xref:windows-requirements.adoc[Windows]

* Try the official xref:ROOT:antora-container.adoc[Antora Docker container].

////
OS Release schedule links

Alpine: https://alpinelinux.org/releases/

Arch: https://www.archlinux.org/releng/releases/

Arch Linux releases once a month, with only the 3 most recent distros being officially available

Debian: https://www.debian.org/releases/

Fedora: https://fedoraproject.org/wiki/Releases

Ubuntu Linux: https://wiki.ubuntu.com/Releases

openSUSE: https://en.opensuse.org/Portal:42.3
Checkout the Open Build Project: http://openbuildservice.org

Windows: https://en.wikipedia.org/wiki/Comparison_of_Microsoft_Windows_versions

Windows Server 2016: Mainstream support: Until January 11, 2022
Windows 10: TBD

MacOS https://en.wikipedia.org/wiki/MacOS_version_history
MacOS 13 probably around Oct/Nov 2022, with EOL of Catalina at same time

MS Edge: replaces IE 11 which is not being developed further; it is the default browser for Windows 10/Server 2016
////

// /docs/modules/ROOT/pages/organize-content-files.adoc
[[organize-content-files.adoc]]
= How to Organize Your Content Files

Antora employs both convention and configuration to aggregate content and generate your site.
Before setting up or migrating your repositories, let's review some key concepts that could impact how you organize your documentation projects and content files to work with Antora.

== Storing your content source files

Antora can retrieve content source files from numerous git repositories by searching for files or their xref:symlinks.adoc[symlinks] under a xref:playbook:content-source-start-path.adoc[start path] or xref:playbook:content-source-start-paths.adoc[multiple start paths] in branches, tags, or a local worktree.
The repositories Antora uses don't have to be reserved exclusively for storing documentation (hence the start path).
Antora can retrieve files from repositories that also host application code, tests, and other materials in sibling hierarchies.
Antora relies on both xref:standard-directories.adoc[convention] and xref:playbook:configure-content-sources.adoc[configuration] to identify the documentation content.

In order to fetch source files from multiple and multi-use repositories, Antora requires that the documentation files be:

* Located under a xref:content-source-repositories.adoc[content source root]
* Labeled with a file named xref:component-version-descriptor.adoc[_antora.yml_]
* Organized into a xref:standard-directories.adoc[standard set of directories]

Although not required, we *strongly* recommend that you always use lowercase for filenames.
Some filesystems are case sensitive, while others are not.
By always using lowercase, you avoid any problems that occur if the filesystem, webserver, or transfer tool does not preserve the casing.

== Classifying your content source files

Once Antora collects the source files from all content source roots, it classifies each file by assigning metadata to it, which is used to uniquely identify the file within the site.
The file's identifier, called a resource ID, is used for creating references from pages, other resources, and the configuration.
This step also implicitly partitions the source files into component versions.

=== Antora's virtual filesystem

Antora decouples source files from their storage locations after it collects them.
For all intents and purposes, the origin of each file is irrelevant.
In other words, Antora never goes back to the filesystem or git repository to read the file once it's discovered and loaded.
Antora bases all of its file operations on the virtual filesystem (VFS) it creates after it collects the files.

The only aspect of a file that maps back to the location on the filesystem is the family-relative path.
And even this association is maintained merely as a convenience for the author.
Aside from the family-relative path, all other parts of the file's identity are based on associative metadata, such as the component name, version, module name, and family.

=== File metadata

So how does a file get this metadata?
All files in the same content source root inherit the component name and version from the component version descriptor file, named _antora.yml_.
These descriptor files help Antora sort and organize all of the collected source files into component versions.
You can think of a component version as all of the documentation for a version of a project.
For example, you're reading a page in the {page-component-title} {page-component-display-version} component version right now.

These _antora.yml_ files are how content that belongs to the same version of a project can be identified by Antora.
It's also how component versions are defined and populated implicitly.

Inside a content source root, files are further grouped into module and family folders, which provide two more facets of a source file's identity.
Finally, the family-relative path is captured to uniquely identify a source file within a family, even across multiple repositories or git references.

=== File locations and URLs

The location of a source file doesn't dictate the location of the published file.
Once a source file is loaded into Antora's VFS, the file's metadata is manipulated, which includes computing the file's output location and URL.
Each family of files has different rules for how these values are computed.
The association between where the source file is found, where the published file is placed in the site, or how that file is accessed isn't hardwired.

//That means the names and URLs of the repositories, branches, tags, and content source roots doesn't have any bearing on a site that's generated from these files.
//
//Except for the relative path of files stored in the family directories, the source files`' storage locations don't impact how they're referenced internally, organized, labeled, and versioned in the published site, or even how their resulting page URLs are constructed when the site is being generated.

See xref:component-version.adoc[What's a component version?] and xref:component-version-descriptor.adoc[What's antora.yml?] to learn how to assign a component name, version and other optional information to groups of content source files.

=== git refnames

git refnames, which includes the names of branches and tags, should only contain characters that do not need to be URL encoded.
This rule is not enforced by git, but violating it can cause subtle problems in Antora.

While the refname does not appear in the URL of published resources, it is used in references back to the file's origin.
Specifically, using characters in the refname which have to be URL encoded complicates the assembly of the edit URL for pages.

As an example, the character `+#+` violates this rule, which would have to be encoded as `%23`.
Although Antora will happily build the edit URL to include this character, the URL will not be interpreted as expected by the browser.
That's because `+#+` marks the boundary between the URL that's sent to the server and the fragment that's only seen by the browser.
The result will be an incomplete URL and thus a 404 page.

It's acceptable to use the universal directory separator, `/`, in refnames.
By doing so, it effectively organizes the refs into a folder structure (e.g., `r/3.0.x`).
However, this strategy can impact refname matching.
The `+*+` character in a refname pattern does not match `/` (it does not cross the boundary of a folder).
Therefore, to match a refname such as `r/3.0.x`, you must use the pattern `+r/*+` instead of `+r*+`.

// /docs/modules/ROOT/pages/content-source-repositories.adoc
[[content-source-repositories.adoc]]
= Repositories and Content Source Roots

Antora collects content source files from directories in branches, tags, and worktrees of git repositories.
These source files are only retrieved and processed correctly if Antora can locate them within a content source root.

[#git-and-content-sources]
== git repositories and content sources

The source files containing a site's content are stored in one or more git repositories.
These repositories can be remote, local, or a combination of both.
In a playbook file, you'll enter several parameters (e.g., url, branches, tags, and start paths) that:

. allow Antora to locate and connect to your content source repositories, and
. provide Antora with the location criteria that resolves to one or more <<content-source-root,content source roots>> within a git repository.

If the repository is local, by default Antora will attempt to use the worktree of that repository if the current branch matches one of the branches defined on the content source.
This behavior is configurable.

Antora requires a local directory to be a git repository, which means the local directory is a git worktree.
The git repository itself can be empty, meaning you don't have to commit any files in order for it to work.
If the local directory is not yet a git repository, you can make it one by running the following commands:

 $ git init . && git commit --allow-empty -m init

Before configuring a site's playbook, you'll want to determine where to set up the content source roots in your repositories.
// to be located and then set up the directories Antora requires.
//to place your content source roots to beet up the required directories and sorted your content source files into them at each content source root.

[#content-source-root]
== What's a content source root?

A [.term]*content source root* is a location in a branch or tag (i.e., a reference) of a repository from where Antora begins looking for content source files.
Think of the content source root as the entrance of the store where Antora shops.
From the content source root, Antora looks for an [.path]_antora.yml_ file, which identifies the component version bucket, then scans for a collection of source files organized in a xref:standard-directories.adoc[standard set of directories] to add to that bucket.

A repository can have many content source roots.
You may have one content source root per branch or tag.
Or you may have multiple content source roots per branch or tag defined using xref:playbook:content-source-start-paths.adoc[multiple start paths].
You can also have a combination of both.
Where you store the content source roots is up to you.

// /docs/modules/ROOT/pages/content-source-versioning-methods.adoc
[[content-source-versioning-methods.adoc]]
= Content Source Versioning Methods
:page-aliases: component-versions.adoc

This page describes several methods you can use for managing versions of your content.
While these recommendations are most applicable to software documentation, they can apply for other content as well.

== Version content using branches

Using this method, you store each xref:component-version.adoc[documentation version] in a branch of a git repository, just like you use branches to store version lines of a software project.
You then set the xref:playbook:content-branches.adoc[branches key] on the content source to tell Antora which branches to use.
The name of the branch itself _does not_ matter.
It's the xref:component-version-key.adoc[version key] in the xref:component-version-descriptor.adoc[component version descriptor] or playbook that determines the version.

Using branches to version content is the method we recommend starting with when using Antora.
Branches are ideally suited for managing multiple versions of the same content.

If you haven't used branches for versioning before, you may have stored versions in folders.
If we were to use version folders to store documentation versions all in a single branch, then we'd have to explicitly copy all the files in a version to a new folder to create a new version.
In doing so, we'd no longer be able to rely on git to compare, manage, and merge different versions of the same document.

If we were to use tags to store documentation versions, then we wouldn't be able to update the documentation once the tag was made, effectively freezing the documentation from receiving updates.

Branches offer the right balance.
By creating a new branch from an existing reference in the repository to hold a new version, the repository only stores what's changed since that branch point.
And that branch can receive updates at any time.
That's what git does best.

Branches map well to the system of references provided by git and are flexible enough to allow documentation to be updated freely.

== Version content using tags

Using this method, you store each xref:component-version.adoc[documentation version] in a tag of a git repository, just like you use tags to store software releases.
You then set the xref:playbook:content-tags.adoc[tags key] on the content source to tell Antora which tags to use.
Tags provide many of the same benefits of branches, but with some notable downsides.

Like branches, tags allow you to compare different instances of a file across versions and the repository only stores what's changed since the previous tag point.
The downside of tags is that, once created, you can't update them like you can with branches.
So, if you find a typo, or need to add an example, you can't edit the content in a tag.
It's frozen.
You'd have to delete and recreate the tag, or create a new tag and point to it, in order to publish your updates.

If you decide to version content using tags, despite the drawbacks, we *strongly* recommend using dedicated tags for documentation (e.g., docs/2.0.1 to follow release/2.0.1).
In doing so, you provide a window to update the documentation after the software tag is created and before the documentation for that software is frozen (by tagging it).
Otherwise, you'd have to ensure all documentation updates are in before the software is released, which is rarely the case.
(The alternative is to release the software so frequently that missing the software release is no big deal).

== Version content using folders

Using this method, you store each xref:component-version.adoc[documentation version] in a folder in a single reference (branch or tag) of a repository.
You then set the xref:playbook:content-source-start-paths.adoc[start_paths key] on the content source to tell Antora which directories to consider to locate those folders and the branches or tags key to point Antora to the reference where the directories are located.
The name of the folder itself _does not_ matter.
It's the xref:component-version-key.adoc[version key] in the xref:component-version-descriptor.adoc[component version descriptor] that determines the version.

We generally recommend against using this method since you lose a lot of the advantages that git affords you, as previously described.
However, it can be useful when the documentation for a lot of different versioned software components coexist in the same repository.
In this scenario, references (branches or tags) don't work well since a reference for a single software component will carry with it unrelated (and likely outdated) documentation from another software component.
That kind of arrangement doesn't fit with git's model.
And it can be confusing for writers.

Using folders to version content is arguably the easiest system for the writer to use.
The writer can clone the content source repository and immediately edit files across all versions without having to do any branch switching.
Although the writer can no longer rely on git to compare, manage, and merge different versions, and each version starts as a complete copy of the previous one, the productivity benefits of having all the files together may win out.
That's why Antora supports this method.
However, keep in mind that by using xref:playbook:content-worktrees.adoc[multiple worktrees], it's possible to achieve a similar setup using branches that doesn't sacrifice the ability to use git's revision control mechanisms.

You should only consider versioning content using folders if either the repository hosts versioned documentation for many different components or your writers are unable to work with branches.

== Documentation versions and software releases

We view documentation as the explanation for the software in a release line.
The documentation describes the software that has been published.
Thus, it should be possible to update the documentation even after the software has been released (perhaps even long after).

The documentation lifecycle isn't bound to the software lifecycle, but rather follows it.
In many cases, the documentation isn't ready when the software release was made and still needs work (otherwise, you end up putting immense, often unreasonable, pressure on the documentation team).
In other cases, new information is discovered about a software release that needs to be added to the documentation for that release.

If the software adheres to https://semver.org[semantic versioning^], we generally recommend mapping the documentation version to the minor version of the software (e.g., 1.0, 1.1, 2.0, etc.).
This mapping is possible when the software is managed using branches that follow a minor release line (e.g., v1.0.x, v1.1.x, v2.0.x, etc.).

Mapping the documentation version to a minor version line of the software works because, generally, documentation isn't tied to patch releases.
Often times, the documentation is updated to include information that was previously missed.
And that information can be added at any time before or after the next patch release.

In summary, we typically advise against building documentation for software releases from tags.
Documentation is the explanation of the software, not the software itself.
It needs to be possible to update documentation after a version of the software is frozen and released.
If you do use tags, we strongly recommend using tags for documentation that are distinct from the tags for the software releases.

=== Tags for prereleases

Where tags fit well is when you're publishing documentation for a prerelease.
In a prerelease line, new features can be added well before the software is published.
Those new features may be accompanied by documentation that describe those features.
As a result, the documentation references features which are not yet available.
If Antora publishes the documentation from the prerelease branch, the user can be misled into thinking certain features are available, when in fact they are not.

To solve this problem, you can pull the documentation from the tag for the last prerelease instead.
By publishing the documentation for a prerelease from a tag, you can lock the documentation to only what was available when the software was released.
That way, you don't publish documentation for features that aren't yet available.

The only caveat is that documentation which doesn't make it in before the prerelease gets tagged won't be available until the next prerelease--the same limitation of using tags as previously described.
However, it's less of a concern in this case since a prerelease is, by it's very nature, not considered complete and can be followed by other prereleases.

== Learn more
// The list items IDs exist because they're the previous section IDs for sections that were originally in the aliased page, but have now become their own pages.

* xref:component-name-and-version.adoc[]
* xref:how-component-versions-are-sorted.adoc[]
* xref:component-with-no-version.adoc[]

////
This section is going to become a new page

== Setting the version for a branch

To assign a version to a component version stored in a particular branch, you set the xref:component-version-key.adoc[version key in the component version descriptor]:

[source,yaml]
----
name: versioned-component
version: '2.1'
title: Versioned Component
----

This component version descriptor communicates that the files taken from this branch contribute to the `2.1` version of the component named `versioned-component`.
The name of the branch where the component version's source files are stored could be _v2.1_ or _v2.1-beta_.
It doesn't matter.

The component version descriptor is the only file you have to update when creating a new branch.
All the page references for that component version should be relative to the version, so you shouldn't need to update any links.
The next time you run Antora on the repository, you'll see a new version in the component explorer drawer.

You may need to add the xref:playbook:configure-content-sources.adoc#branches[branch to your playbook file].
Keep in mind that content sources are filtered by branch name, not by the version they contain.
That's because xref:component-structure.adoc#distributed[a single component version's source files can be located in multiple branches, or even multiple repositories].
////

// /docs/modules/ROOT/pages/standard-directories.adoc
[[standard-directories.adoc]]
= Standard File and Directory Set
:page-aliases: component-structure.adoc
//Antora extracts the metadata that defines a documentation component from its component version descriptor ([.path]_antora.yml_) and the standard set of directories structure used to store the component version's source files.
//Antora also uses this structure to assign preset behavior to the files stored in each directory.

Antora collects and processes content source files according to a set of hierarchical files and directories it expects to find at a content source root.
This page introduces this hierarchy, the reserved directory and file names it employs, and the rules about which files get collected or ignored.

== Hierarchy and reserved names

The set of files and directories, the reserved file and directory names, and their hierarchy that starts at a content source root--collectively referred to as Antora's [.term]*standard file and directory set* -- helps Antora determine which files to collect, the role of each file, how to classify each file, and which files to ignore.
<<ex-standard-dirs-root>> shows the hierarchy Antora expects if all of the required and optional files and directories that make up the standard file and directory set are used.

NOTE: In the following examples, *📒 repository* represents the root of the file tree of a single reference, such as a branch, in a git repository.

.All required and optional files and directories of a standard file and directory set located at a repository root
[listing#ex-standard-dirs-root]
----
📒 repository <.>
  📄 antora.yml <.>
  📂 modules <.>
    📂 ROOT <.>
      📁 attachments <.>
      📁 examples <.>
      📁 images <.>
      📁 pages <.>
      📁 partials <.>
      📄 nav.adoc <.>
    📂 named-module <.>
      📁 pages
      📄 nav.adoc <.>
  📁 packages <.>
----
<.> The repository root and the xref:content-source-repositories.adoc#content-source-root[content source root].
By default, Antora assumes the content source root is at the root of a repository unless the `start_path` or `start_paths` key is assigned a value on a content source in your site's playbook.
<.> A xref:component-version-descriptor.adoc[component version descriptor file], named [.path]_antora.yml_ (reserved file name), is required at each content source root.
An [.path]_antora.yml_ file indicates to Antora that the contents of a directory named [.path]_modules_ should be collected and processed.
<.> Required directory named [.path]_modules_ (reserved directory name).
A [.path]_modules_ directory must be located at the same hierarchical level as an [.path]_antora.yml_ file in a content source root.
That is, the [.path]_antora.yml_ file and [.path]_modules_ directory are siblings.
A [.path]_modules_ directory must contain, at a minimum, either xref:module-directories.adoc[a _ROOT_ module directory or a named module directory].
<.> Optional xref:root-module-directory.adoc[_ROOT_ module directory].
Antora applies special behavior to the publishable resources in a [.path]_ROOT_ module directory.
[.path]_ROOT_ is a reserved directory name and must be in all uppercase letters.
A module directory must contain at least one family directory.
<.> Optional xref:attachments-directory.adoc[_attachments_ family directory] (reserved directory name).
<.> Optional xref:examples-directory.adoc[_examples_ family directory] (reserved directory name).
<.> Optional xref:images-directory.adoc[_images_ family directory] (reserved directory name).
<.> Optional xref:pages-directory.adoc[_pages_ family directory] (reserved directory name).
<.> Optional xref:partials-directory.adoc[_partials_ family directory] (reserved directory name).
<.> Optional navigation file named [.path]_nav.adoc_.
<.> Optional xref:named-module-directory.adoc[named module directory].
You can create as many named module directories as you require.
A module directory must contain at least one family directory.
<.> Optional navigation file named [.path]_nav.adoc_.
<.> Antora won't process the files in this directory because it's located outside the [.path]_modules_ directory.

In <<ex-standard-dirs-root>>, the content source root is located at the root of the repository.
However, a content source root doesn't have to be at the root of a repository.
In <<ex-standard-dirs-sub>>, the content source root is located in a directory of the repository.

.All required and optional files and directories of a standard file and directory set located in a directory of a repository
[listing#ex-standard-dirs-sub]
----
📒 repository <.>
  📁 config <.>
  📂 docs <.>
    📄 antora.yml
    📂 modules
      📂 ROOT
        📁 attachments
        📁 examples
        📁 images
        📁 pages
        📁 partials
        📄 nav.adoc
      📂 named-module
        📁 pages
    📁 notes <.>
  📄 README.adoc <.>
----
<.> Repository root
<.> Antora ignores this directory because it isn't specified as the content source root in the site's playbook (for the purposes of this example).
<.> The xref:content-source-repositories.adoc#content-source-root[content source root] as specified in the site's playbook using the `start_path` or `start_paths` key (for the purposes of this example).
<.> Antora won't process the files in this directory because it's located outside the [.path]_modules_ directory.
<.> Antora ignores this file because it isn't in the content source root.

TIP: By default, Antora assumes the repository root and content source root are the same.
If you've structured a repository where a content source root is located within a directory of the repository, you must specify the path to the directory using the `start_path` or `start_paths` key in your site's playbook.

Many of the directories shown in <<ex-standard-dirs-root>> and <<ex-standard-dirs-sub>> are optional.
You only have to set up one module directory--and it can be a [.path]_ROOT_ or named module directory--if that's all you need.
Also, you only need to set up the family directories in a module directory that best apply to the type and purpose of your source files.
For example, if you aren't inserting any images into the pages stored in a module directory, then you don't need to create an [.path]_images_ directory.

In the <<minimum-requirements,next section>>, you can see two content source examples that meet Antora's minimum requirements of a valid standard file and directory set.

[#minimum-requirements]
== Minimum requirements

From a xref:content-source-repositories.adoc#content-source-root[content source root], Antora must find:

* An [.path]_antora.yml_ file located at the content source root
* A [.path]_modules_ directory located at the same hierarchical level as an [.path]_antora.yml_ file
* At least one module directory in the [.path]_modules_ directory
* At least one family directory containing at least one source file in the module directory

Let's look at two examples showing standard file and directory sets that meet the minimum requirements.
The directory and file set in <<ex-root>> is valid because it contains the required [.path]_antora.yml_ and [.path]_modules_ directory at the content source root.
The [.path]_modules_ directory contains one module directory, in this case the special _ROOT_ module directory.
In turn, the _ROOT_ module directory contains a family directory that contains one source file.

.Valid standard file and directory set containing a ROOT module directory
[listing#ex-root]
----
📒 repository <.>
  📄 antora.yml <.>
  📂 modules <.>
    📂 ROOT <.>
      📂 pages <.>
        📄 page-source-file.adoc <.>
----
<.> In this example, the content source root is at the root of the repository.
<.> Component version descriptor file, with the valid filename [.path]_antora.yml_.
<.> [.path]_modules_ directory.
<.> [.path]_ROOT_ module directory.
<.> [.path]_pages_ family directory.
<.> Source file of a page.

In <<ex-image>>, the content source root is located at the directory [.path]_ops-training_.

.Valid standard file and directory set containing a named module directory
[listing#ex-image]
----
📒 repository
  📂 courses
    📂 ops-training <.>
      📄 antora.yml <.>
      📂 modules <.>
        📂 rz-interface <.>
          📂 images <.>
            📄 image-source-file.ext <.>
----
<.> Content source root.
<.> Component version descriptor file, with the valid filename [.path]_antora.yml_.
<.> [.path]_modules_ directory.
<.> A module directory named [.path]_rz-interface_.
<.> [.path]_images_ family directory.
<.> Source file of an image.

The standard directory and file set in <<ex-image>> is also valid.

[#hidden-files]
== Hidden and unpublished files

A [.term]*hidden file* is any file stored in Antora's standard directory hierarchy that begins with a dot (`.`).
Files that don't have file extensions are also hidden, unless they're stored in an xref:examples-directory.adoc[_examples_ directory] or xref:partials-directory.adoc[_partials_ directory].
Hidden files *do not* get added to Antora's content catalog, and therefore aren't assigned a resource ID, can't be referenced, and aren't published.

.Standard directory set containing hidden files
[listing#ex-hide]
----
📒 repository
  📄 antora.yml
  📂 modules
    📂 ROOT
      📂 examples
        📄 .hidden-example-file.ext <.>
        📄 example-file <.>
      📂 pages
        📄 .hidden-page-file.adoc <.>
        📄 hidden-page-file <.>
----
<.> Antora won't load this example file into the content catalog because its filename begins with a dot (`.`).
<.> Files stored in the [.path]_examples_ directory aren't required to have a file extension, therefore Antora will load this example file into the content catalog.
<.> Antora won't load this page file into the content catalog or publish it because its filename begins with a dot (`.`).
<.> Antora won't load this page file into the content catalog or publish it because it's missing a file extension and page files must have a file extension.

IMPORTANT: Except when it's typical for a file type to not have a file extension, such as [.path]_Dockerfile_, it's a good practice to save example and partial source files with their valid file extensions.
If you don't save partial and example files with their file extensions, you may not be able to use Antora or Asciidoctor extensions that apply additional behavior to partial or example files.

[[unpublished]]An [.term]*unpublished file* is any file stored in Antora's standard directory hierarchy that begins with an underscore (`+_+`).
An unpublished file is added to the content catalog, assigned a resource ID (if applicable), and can be referenced.
However, an unpublished file isn't automatically published, even if it's stored in the folder of a publishable family (that is, [.path]_pages_, [.path]_images_, or [.path]_attachments_).

.Standard directory set containing unpublished files
[listing#ex-unpublished]
----
📒 repository
  📄 antora.yml
  📂 modules
    📂 ROOT
      📂 images
        📄 _unpublished-image-file.ext <.>
      📂 pages
        📄 _unpublished-page-file.adoc <.>
----
<.> An image file with a filename that begins with an underscore (`+_+`) is loaded into the content catalog and can be referenced by an image macro.
However, the image won't be published automatically even though it's stored in the folder of a publishable family.
<.> A page file with a filename that begins with an underscore (`+_+`) is loaded into the content catalog and can be referenced by an include directive.
However, the page can't be referenced by an xref macro because it won't be published as its own page even though it's stored in the folder of a publishable family.

// /docs/modules/ROOT/pages/symlinks.adoc
[[symlinks.adoc]]
= Symlinks

Although Antora requires that files adhere to a xref:standard-directories.adoc[standard hierarchy], it's possible to remap files at an existing location into this hierarchy using symlinks.
This page introduces symlinks and explains how they can be used in Antora to help construct the content hierarchy.

== What is a symlink?

A [.term]*symlink*, short for symbolic link, is a shortcut to a file that itself acts like a file.
In other words, it's a file that points to another file.
The purpose of a symlink is to give a file a second location without having to duplicate it.
A symlink can also point to a directory, which effectively links all the files under that directory to the new location.
And a symlink can even point to another symlink, making it possible to give a file or directory even more locations.

A symlink acts just like a regular file or directory, albeit with some additional metadata.
Applications like Antora that come across a symlink will treat it just like any other file or directory.
This property makes symlinks an ideal tool for remapping files, such as examples and partials, into the Antora hierarchy.
Before we get into that, let's look at where symlinks are supported and how to create them.

== Where are symlinks supported?

While symlinks were once only common in Unix and Unix-like (*nix) operating systems, in modern computing, support for symlinks is universal.
Symlinks can be used on a local filesystem and in a git repository, and they're translated between the two transparently.

In case you're wondering, yes, symlinks work on Windows too.
Since Windows 10, symlinks (and not some imitation) are fully supported on Windows.
See https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10[Symlinks in Windows 10] to learn about the debut of this capability.

NOTE: A symlink in git is actually different than a symlink on the filesystem for the OS.
In git, the symlink is a data file (with a special file mode) that stores a reference to relative path in the repository.
When you check out the branch containing the symlink to a worktree (e.g., `git clone` or `git checkout`), that reference gets converted to a symlink on the local filesystem.
But even if that doesn't happen (`core.symlinks` is not enabled), the symlink is created as a regular file that contains the path reference (just like it is in the git repository).

== How do I make a symlink?

A symlink can point to a file, a directory, or even another symlink.

When you make a symlink, the relationship should always be expressed as a relative path.
If you use an absolute path, it will bind the symlink to the layout of your local filesystem and won't translate into git.

The command you use to make a symlink differs depending on whether you're using a Unix-like operating system or Windows.
However, the result it produces is the same.

=== *nix

To make a symlink on a Unix-like operating system (aka *nix), you use the `ln` command with the `-s` flag.
Here's an example of how to make a symlink to a sibling file:

 $ ln -s target.adoc link.adoc

In this scenario, [.path]_link.adoc_ is a symlink to (i.e., points to) the file [.path]_target.adoc_.

This also works for directories (i.e., folders):

 $ ln -s target link

In this scenario, [.path]_link_ is a symlink to (i.e., points to) the directory [.path]_target_.
The symlink acts as a directory.

More often, you'll want to map to a location outside of the current directory.
That means including one or more directory segments in the path of the symlink target.

To make a symlink to a file in a directory, first navigate to the directory where you want it to be made.
Then, specify the target as the path relative from that directory.
This is going to look backwards, but it will create a pointer starting at link and pointing to target.

 $ ln -s ../../path/to/target.adoc link.adoc

In this scenario, [.path]_link.adoc_ is a symlink to (i.e., points to) the file [.path]_../../path/to/target.adoc_ relative to the directory containing the symlink.
The target could be in a nested directory instead of a parent directory.

You can do the same for directories:

 $ ln -s ../../path/to/target link

In this scenario, [.path]_link_ is a symlink to (i.e., points to) the directory [.path]_../../path/to/target_ relative to the directory containing the symlink.
The symlink acts as a directory.

=== Windows

To make a symlink on Windows, you use the https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/mklink[mklink^] command.
This command can be used to create a symlink to either a file or a directory.
(Using a symlink is preferred over a hard link or a directory junction).

To create a symlink to a file, the syntax is as follows:

 mklink <link> <target>

To create a symlink to a directory, the syntax is as follows:

 mklink /d <link> <target>

NOTE: In Windows, the order of the link and target is reversed when compared to the *nix `ln` command.

Here's an example of how to make a symlink to a sibling file using `mklink`:

 $ mklink link.adoc target.adoc

In this scenario, [.path]_link.adoc_ is a symlink to (i.e., points to) the file [.path]_target.adoc_.

Now let's create a symlink to a sibling folder.

 mklink /d link target

In this scenario, [.path]_link_ is a symlink to (i.e., points to) the directory [.path]_target_.
The symlink acts as a directory.

More often, you'll want to link to a location outside of the current directory.
That means including one or more directory segments in the path of the symlink target.

To make a symlink to a file in a directory, first navigate to the directory where you want it to be made.
Then, specify the target as the path relative from that directory.
This is going to create a pointer starting at link and pointing to target.

 $ mklink link.adoc ..\..\path\to\target.adoc

In this scenario, [.path]_link.adoc_ is a symlink to (i.e., points to) the file [.path]_..\..\path\to\target.adoc_ relative to the directory containing the symlink.
The target could be in a nested directory instead of a parent directory.

You can do the same for directories:

 $ mklink /d link ..\..\path\to\target

In this scenario, [.path]_link_ is a symlink to (i.e., points to) the directory [.path]_..\..\path\to\target_ relative to the directory containing the symlink.
The symlink acts as a directory.

== Symlinks in Antora

Antora fully supports symlinks.
That means you can use symlinks in the worktree and you can use symlinks in the git tree.
(Yes, git supports symlinks, too).

=== How does it work?

When Antora encounters a symlink to a file, it doesn't attempt to preserve it as a symlink.
Rather, it creates a regular virtual file like it would for any other file it encounters.
We can say that within Antora's virtual file system, the file is duplicated, though it may end up being the only instance if it's the only part of the symlink under the Antora hierarchy.

When Antora encounters a symlink to a directory, it reads all the files under the target directory and creates a regular virtual file for each one.
In this case, Antora preserves the path of the symlink, then appends the path to the file from that point.
As far as Antora is concerned, the file lives inside the directory represented by the symlink, as though the symlink were a real directory.
We can say that within Antora's virtual file system, all the files under that directory are duplicated, though they may end up being the only instances of those file if the target directory is not part of the Antora hierarchy.

The takeaway here is that by using symlinks, you can convince Antora that a file or directory is in a different location than it actually is.
If it's a symlink to a file, Antora treats it as though you copied the file there, except you didn't.
If it's a symlink to a directory, Antora treats it as though you copied the directory there recursively, except you didn't.

Let's learn how to make use of this capability.

=== Remap files using symlinks

Let's consider one of the most common uses for the symlink feature in Antora.
You have example files you want to include in your documentation, but those files don't live inside the standard Antora directory structure.
In order to make them available to Antora, you need to remap them into the Antora hierarchy.

Let's get a picture of that layout:

[listing]
----
📒 docs
  📄 antora.yml
  📂 modules
    📂 ROOT
      📂 pages
        📄 index.adoc
      📄 nav.adoc
📒 src
  📒 main
    📒 java
      📒 org
        📒 example
          📄 MyClass.java
----

What we want to do is include the source file [.path]_MyClass.java_ (or some portion of it) in the page [.path]_index.adoc_.
However, that's not currently possible since the source file is not under the Antora hierarchy.
Symlinks to the rescue!

Start by creating the [.path]_examples_ folder under the ROOT module where the symlink will live.

[listing]
----
📒 docs
  📄 antora.yml
  📂 modules
    📂 ROOT
      📂 examples
      📂 pages
        📄 index.adoc
      📄 nav.adoc
📒 src
  📒 main
    📒 java
      📒 org
        📒 example
          📄 MyClass.java
----

Next, let's create a symlink from the [.path]_examples_ folder to [.path]_MyClass.java_ to pull it into the Antora hierarchy.
Start by switching to that directory in your terminal.

 $ cd docs/modules/ROOT/examples

Then, create the symlink using the command appropriate for your operating system.

.*nix
 $ ln -s ../../../src/main/java/org/example/MyClass.java MyClass.java

.Windows
 $ mklink MyClass.java ..\..\..\src\main\java\org\example\MyClass.java

Here's the result.

[listing]
----
📒 docs
  📄 antora.yml
  📂 modules
    📂 ROOT
      📂 examples
        🔗 MyClass.java <.>
      📂 pages
        📄 index.adoc
      📄 nav.adoc
📒 src
  📒 main
    📒 java
      📒 org
        📒 example
          📄 MyClass.java
----
<.> MyClass.java is a symlink to the MyClass.java file under src/main/java/org/example at the repository root

TIP: If you're sourcing your documentation content from a git reference, commit the symlink to the git repository, just like you would any other file.

You can now include the source file in the [.path]_index.adoc_ page using the following include directive:

[source]
----
\include::example$MyClass.java[]
----

You may find it tedious to have to create a symlink for every file you want to include.
That's where directory symlinks come into play.
You can create a symlink to a directory, which effectively grafts that hierarchy into the Antora hierarchy.

Instead of creating a symlink directory to the source file, let's create a symlink to the [.path]_src_ folder.
Again, start by switching to the [.path]_examples_ directory.

 $ cd docs/modules/ROOT/examples

Then, create the symlink using the command appropriate for your operating system.

.*nix
 $ ln -s ../../../src src

.Windows
 $ mklink src ..\..\..\src

Here's the result:

[listing]
----
📒 docs
  📄 antora.yml
  📂 modules
    📂 ROOT
      📂 examples
        🔗 src <.>
      📂 pages
        📄 index.adoc
      📄 nav.adoc
📒 src
  📒 main
    📒 java
      📒 org
        📒 example
          📄 MyClass.java
----
<.> src is a symlink to the src folder at the repository root

TIP: If you're sourcing your documentation content from a git reference, commit the symlink to the git repository, just like you would any other file.
Even though the symlink points to a directory, in git, it's still treated like a file.

You can now include the source file in the [.path]_index.adoc_ page using the following include directive:

[source]
----
\include::example$src/main/java/org/example/MyClass.java[]
----

You can create symlinks for any type of resource, including examples, partials, pages, images, and so forth.
Although the target of the symlink is usually outside of the Antora hierarchy, a symlink can point to a location within the Antora hierarchy if the intent is to duplicate the file or directory.

== Limitations

There are some limitations to be aware of when using symlinks in Antora.

* The target of the symlink must exist.
If Antora can't resolve the symlink, it will throw an error.
* A symlink can't point to itself.
If Antora detects this scenario, it will throw an error.
* A symlink in a git repository can't point to a location outside the git repository.
* A symlink in a git repository can't point to a location in another reference in the git repository.
* The target of the symlink should be relative.
Creating a symlink that targets an absolute path has undefined or non-portable behavior.

Don't map a lot of files into the Antora hierarchy that aren't used in your documentation site.
Doing so adds extra processing for Antora that can slow down your build.
Be as surgical and precise as you can about which files you map into the Antora hierarchy.

// /docs/modules/ROOT/pages/module-directories.adoc
[[module-directories.adoc]]
= Module Directories and Modules
:page-aliases: modules.adoc

[#modules-dir]
== What's the modules directory?

The [.path]_modules_ directory is required wherever a component version descriptor file ([.path]_antora.yml_) is located.

[listing]
----
📒 repository <.>
  📄 antora.yml <.>
  📁 modules <.>
  📁 non-docs-directory <.>
----
<.> Content source root
<.> Required component version descriptor file
<.> Required [.path]_modules_ directory
<.> Antora won't process the files in this directory because it's located outside the [.path]_modules_ directory

Except for [.path]_antora.yml_, the standard directories and their files must reside in a valid hierarchy in the [.path]_modules_ directory.
A [.path]_modules_ directory can contain as many <<module-dir,module directories>> as you require.

The [.path]_modules_ directory keeps documentation source files isolated from configuration files, scripts, application code, tests, and other materials located in the xref:content-source-repositories.adoc#content-source-root[content source root].

[#module-dir]
== What's a module directory?

Module directories must be stored in a <<modules-dir,_modules_ directory>>.
A [.term]*module directory* stores the source files for pages, reusable text and example snippets, images, and other content, in xref:family-directories.adoc[family directories].
The source files stored in a module directory become part of a <<module,module>> in a component version.

[listing]
----
📒 repository
  📂 docs <.>
    📄 antora.yml
    📂 modules
      📂 named-module <.>
        📂 pages <.>
          📄 page-source-file.adoc <.>
        📄 nav.adoc <.>
----
<.> Content source root
<.> A named module directory
<.> _pages_ family directory
<.> A source file for a page
<.> A navigation file

At a minimum, a module directory must contain at least one xref:family-directories.adoc[family directory] with at least one source file.
A module directory may also contain zero or more navigation files.

There are two types of module directories: xref:named-module-directory.adoc[named module directories] and the xref:root-module-directory.adoc[ROOT module directory].
At runtime, Antora collects the source files stored in the ROOT and named module directories and assigns them to modules.
By convention, the <<module,module name>> corresponds to the name of the module folder.

[#module]
== What's a module?

A [.term]*module* is a collection of content in a component version that's related by concept, stage, feature, or other project-specific grouping.
While the module does get represented as a xref:how-antora-builds-urls.adoc#module[URL segment in the published site], it's primarily an organization tool for the writer.
A module cannot be individually configured (meaning it has no metadata of its own).

The [.term]*module name* and the name of the module folder are the same.
Antora assigns the module name to all files found inside the module's folder.

////
[#where-module-name-is-used]
== Where is the module name used?

When inserting or linking to content that belongs to another module, you'll specify the target module's name in the page IDs of cross references and the resource IDs for images, examples, and partials.

In addition to internal processes, Antora uses the module name, except for `ROOT`, as a xref:module-url-segment.adoc[segment in page URLs].
////

////
All of the content that is assigned to a specific module is often stored in a single <<module-dir,module directory>>.
However, a module can also be assembled from files stored at multiple content source root locations as long as the assigned component name and version are the same and the name of each module directory the content is retrieved from is the same.

Antora applies additional preset behavior to the files stored in a [.path]_ROOT_ module directory.

As for named module directories, carefully consider the names you give to these directories because they're used during site configuration and generation.
Antora extracts the name of a module directory and assigns this name as the module coordinate to the source files stored in that directory.

[#nav-files]
== Navigation files

A module can contain none, one, or numerous navigation files.
A xref:navigation:filenames-and-locations.adoc[navigation file] is an AsciiDoc file (e.g., [.path]_nav.adoc_) that is stored in the directory of the module, but not in any of the module's family subdirectories.
In order to be displayed in the xref:navigation:index.adoc[component version's page menu], a navigation file must be xref:component-navigation.adoc[declared in the component version descriptor].
////

// /docs/modules/ROOT/pages/root-module-directory.adoc
[[root-module-directory.adoc]]
= ROOT Module Directory

[#root-dir]
== What's a ROOT module directory?

The [.path]_ROOT_ directory is an xref:module-directories.adoc#module-dir[optional module directory].
A [.path]_ROOT_ module directory is located in a xref:module-directories.adoc#modules-dir[_modules_ directory], and its name must be written in all uppercase letters.
A [.path]_ROOT_ directory stores content source files in one or more of the xref:family-directories.adoc[family directories].

[listing]
----
📒 repository
  📂 docs <.>
    📄 antora.yml <.>
    📂 modules <.>
      📂 ROOT <.>
        📂 pages <.>
          📄 index.adoc <.>
          📄 another-page.adoc <.>
        📄 nav.adoc <.>
----
<.> Content source root
<.> Required [.path]_antora.yml_ file
<.> Required [.path]_modules_ directory
<.> [.path]_ROOT_ module directory
<.> [.path]_pages_ family directory
<.> A source file for the default component version start page
<.> A source file for another page in the ROOT module
<.> A navigation file

If the [.path]_ROOT_ module directory is present, it must contain at least one xref:family-directories.adoc[family directory] with at least one source file.
It can also contain an optional navigation file.

The source files stored in a [.path]_ROOT_ directory become part of a <<root-module,ROOT module>> in a component version.
We recommended that you create a [.path]_ROOT_ module directory because Antora applies special preset behavior to the publishable resources in a <<root-module,ROOT module>>.
For example, the source file [.path]_index.adoc_ in the [.path]_pages_ directory becomes the xref:component-start-page.adoc#default-start-page[default start page] for a component version.
Those familiar with the terminology of HTML web hosting will recognize this as the index page for a component version.

Small documentation projects may never need more than a [.path]_ROOT_ module directory.
However, as your project grows, you can easily add more module directories and gradually reorganize your source files.
While the extra structure seems like overkill now, in the long run, you'll be glad you gave your content the space to grow.

[#root-module]
== What's a ROOT module?

Source files that are stored in a [.path]_ROOT_ directory become part of a module named `ROOT` in a xref:component-version.adoc[component version].
A ROOT module's pages become the top-level pages of a component version.
In other words, unlike other modules, the name of the ROOT module does not get used in the generated site.

You can think of the name "`ROOT`" as an alias for a blank module name (i.e., no module segment).
Using this special value allows all modules to be siblings.

It's important to carefully consider what files you store in a [.path]_ROOT_ module directory since there is a potential for them to conflict with files in the named module directories.
Generally, the ROOT module doesn't use topic folders for this reason.

[#where-root-name-is-used]
== Where's the ROOT module name used?

When you reference content that belongs to a ROOT module from another module or component version, you'll specify the module name `ROOT` in the xref:page:resource-id.adoc[resource IDs] for pages, attachments, images, examples, and partials.
`ROOT` is always written in uppercase letters when it's specified.

Since Antora considers the pages in a ROOT module to be top-level component version pages, the module name `ROOT` isn't displayed in the xref:module-url-segment.adoc#root-module-urls[module segment of its page URLs].

// /docs/modules/ROOT/pages/named-module-directory.adoc
[[named-module-directory.adoc]]
= Named Module Directory

== What's a named module directory?

Named module directories are xref:module-directories.adoc#module-dir[optional module directories] located in a xref:module-directories.adoc#modules-dir[_modules_ directory].
You can create as many named module directories as you need.

.Named module directories
[listing#ex-named]
----
📒 repository
  📂 docs <.>
    📄 antora.yml <.>
    📂 modules <.>
      📂 bears <.>
        📂 pages <.>
          📄 page-source-file.adoc <.>
        📄 nav.adoc <.>
      📂 get-started <.>
        📂 pages
          📄 page-source-file.adoc
----
<.> Content source root
<.> Required [.path]_antora.yml_ file
<.> Required [.path]_modules_ directory
<.> A module directory named [.path]_bears_
<.> [.path]_pages_ family directory
<.> A source file for a page
<.> A navigation file
<.> A module directory named [.path]_get-started_

A named module directory must contain at least one xref:family-directories.adoc[family directory] with at least one source file.
A named module directory can also contain an optional navigation file.

Antora uses a module's directory name to create a <<named-module,module's name>>.
A module name is used for source-to-source referencing and as a URL segment for the publishable resources that belong to the module.
Therefore, the name of the module directory:

* Should be accessible to content writers
* Can't contain characters that aren't permitted in AsciiDoc macros and directives
* Shouldn't contain characters that inhibit web server portability, search engine optimization, or the best practices of your site's search solution
* Should meet your site's accessibility requirements

For the reasons listed above, it's important to carefully consider what you name your named module directories.
See xref:module-directory-names.adoc[] to learn about the prohibited characters and recommended practices.

[#named-module]
== What's a named module?

Source files in each named module directory become part of a named module in a xref:component-version.adoc[component version].
The name of a module corresponds to the name of a module directory.
For instance, source files stored in the [.path]_get-started_ module directory shown in <<ex-named>> will be assigned to the module `get-started`.

////
[#where-name-is-used]
== Where's a module's name used?

When you reference content that belongs to a named module from another module or component version, you specify the module's name in the xref:page:resource-id.adoc[resource IDs] for pages, attachments, images, examples, and partials.

The module's name is also used as a xref:module-url-segment.adoc#named-module-urls[segment in the publishable resource URLs].
////

// /docs/modules/ROOT/pages/module-directory-names.adoc
[[module-directory-names.adoc]]
= Recommendations for Module Directory Names

When you're creating module directories, you need to consider how your team will use the files stored in them and how their names will affect your site's URLs.

== Selecting module folder names

Antora assigns the xref:named-module-directory.adoc#named-module[name of a module] from the name of a xref:module-directories.adoc#module-dir[module folder].
A module name is used as the xref:page:resource-id-coordinates.adoc#id-module[module coordinate in the resource IDs] of pages, images, attachments, examples, and partials.
It's also used in the xref:module-url-segment.adoc#named-module-urls[URLs of the publishable resources assigned to that module] (except for the ROOT module).

When choosing a module folder name, keep the following requirements and recommendations in mind:

* Named module directories *can't contain blank spaces or forward slashes (`/`)*.
These characters aren't permitted in the targets of AsciiDoc cross references, image macros, or include directives.
* If possible, *don't use uppercase letters, underscores (`_`), and other characters that aren't recommended in URLs*.
Such characters can limit web server portability, downgrade site search results, and cause visitor accessibility problems.
* If the module name ends in the name of a built-in macro, such as `link`, that part of the name may need to be escaped when using in an xref macro.
For example, `elink` will have to be written as `e\link` to prevent the AsciiDoc parser from seeing the link macro.
* If your team often references resources across modules, they'll have to type a module's name in the resource IDs, so *don't make the folder name, and hence the module name, too long or hard to remember*.
Good module names are short and descriptive.

<<ex-named>> shows a set of standard directories with three named module directories.

.Three named module directories
[listing#ex-named]
----
📒 repository
  📂 docs
    📄 antora.yml
    📂 modules
      📂 gear <.>
        📂 images
          📄 image-source-file.ext
      📂 la-garita <.>
        📂 pages
          📄 page-source-file.adoc
      📂 ROOT <.>
        📂 pages
          📄 page-source-file.adoc
        📄 nav.adoc
      📂 sdk <.>
        📂 examples
          📄 example-source-file.ext
        📂 pages
          📄 page-source-file.adoc
        📄 nav.adoc
----
<.> Module directory named [.path]_gear_
<.> Module directory named [.path]_la-garita_
<.> [.path]_ROOT_ module directory
<.> Module directory named [.path]_sdk_

Antora will calculate the following module names from the named module directories in <<ex-named>>: `gear`, `la-garita`, and `sdk`.

// /docs/modules/ROOT/pages/module-url-segment.adoc
[[module-url-segment.adoc]]
= Module Segment in Page URLs

[#root-module-urls]
== URLs for ROOT module pages

When a ROOT module's xref:pages-directory.adoc[pages] are published to a site, they become the top-level pages of their assigned xref:component-version.adoc[component version].
That means the xref:root-module-directory.adoc[module name], _ROOT_, never appears in the page's URL.

To demonstrate this concept, let's compare the URLs of two pages, one assigned to a ROOT module and one assigned to a named module.
The xref:standard-directories.adoc[set of standard directories] illustrated in <<ex-modules>> contains content source files for a project named _Hyper Lemur_.

.Two module directories containing content that's part of the Hyper Lemur project
[listing#ex-modules]
----
📒 repository
  📄 antora.yml
  📂 modules
    📂 admin
      📂 pages
        📄 user-management.adoc
      📄 nav.adoc
    📂 ROOT
      📁 images
      📂 pages
        📄 deploy.adoc
        📄 index.adoc
      📄 nav.adoc
----

Notice the file named [.path]_deploy.adoc_ in the [.path]_pages_ folder inside the [.path]_ROOT_ module folder.
When Antora generates a site for Hyper Lemur, the URL for the page created from the [.path]_deploy.adoc_ source file will look like this.

image::root-page-url.svg[ROOT module page URL,role=grow-x]

The base URL, _\https://my-company.com_, xref:playbook:site-url.adoc[is set in the playbook] that Antora used to generate the site.
The component name segment, _hyperlemur_, and version segment, _1.0_, are set in the xref:component-version-descriptor.adoc[component version descriptor].
The page segment, _deploy_, is the family-relative path of the AsciiDoc source file [.path]_deploy.adoc_.
The name of the module, _ROOT_, isn't used in the URL.

Now, let's see what the URL of a page stored in the named module, _admin_, would look like.

[#named-module-urls]
== URLs for named module pages

Using the Hyper Lemur source files in <<ex-modules>>, let's see what the URL for the [.path]_user-management.adoc_ file would look like.
The file is assigned to the _pages_ family of the _admin_ module.

//.URL for user-management.adoc page in a-module
image::module-page-url.svg[Named module page URL,role=grow-x]

Notice that the xref:named-module-directory.adoc#named-module[name of the module], _admin_, is in the URL directly after the component's version.

// /docs/modules/ROOT/pages/family-directories.adoc
[[family-directories.adoc]]
= Family Directories and Families

Antora assigns preset, content-specific behavior to the source files stored in the family directories.

[#family-dir]
== What's a family directory?

A [.term]*family directory* groups source files that share the same function, processing requirements, and publishing rules.
Antora recognizes five standard family directories: [.path]_attachments_, [.path]_examples_, [.path]_images_, [.path]_pages_, and [.path]_partials_.

[listing]
----
📒 repository
  📄 antora.yml
  📂 modules
    📂 named-module
      📁 attachments
      📁 examples
      📁 images
      📁 pages
      📁 partials
----

Each family directory is optional.
You only need to create a family directory if you have source files that should be stored in a specific family directory.
That is, if a module doesn't have any image files, don't create an [.path]_images_ directory.
Set up the family directories you need at the root of a xref:module-directories.adoc#module-dir[module directory].
At runtime, Antora collects the source files stored in the family directories and assigns them to the corresponding <<family,family>>.

[#family]
== What's a family?

A [.term]*family* is a classification Antora applies to each source file collected from a family directory.
The assigned family corresponds to the name of the family directory.
The families are:

* xref:attachments-directory.adoc[attachments]
* xref:examples-directory.adoc[examples]
* xref:images-directory.adoc[images]
* xref:pages-directory.adoc[pages]
* xref:partials-directory.adoc[partials]

Each source file is configured, converted, and published according to the preset behavior associated with its assigned family.

TIP: A source file that is assigned to a family is often referred to as xref:page:resource-id.adoc[resource].
Antora assigns each resource that it catalogs a xref:page:resource-id.adoc#whats-a-resource-id[unique Antora resource ID] that consists of five coordinates.
One coordinate of the resource ID represents the family of the resource.

// /docs/modules/ROOT/pages/pages-directory.adoc
[[pages-directory.adoc]]
= Pages Directory and Files

[#pages-dir]
== Pages family directory

A module directory can contain a xref:family-directories.adoc[family directory] named [.path]_pages_.
The [.path]_pages_ directory can contain subdirectories.
Only AsciiDoc source files with the file extension _.adoc_ should be stored in the [.path]_pages_ directory and its subdirectories because Antora applies preset behavior to page files when it runs.

[listing]
----
📂 modules
  📂 named-module <.>
    📂 pages <.>
      📄 page-source-file.adoc <.>
      📂 subdirectory-of-pages <.>
        📄 page-source-file.adoc
  📂 ROOT <.>
    📂 pages <.>
      📄 page-source-file.adoc
    📄 nav.adoc
----
<.> A named module directory.
<.> A [.path]_pages_ family directory.
Source files stored in [.path]_pages_ are classified as pages.
<.> A page file marked up with the AsciiDoc syntax and saved with the valid _.adoc_ file extension.
<.> A subdirectory in [.path]_pages_.
Source files stored in subdirectories of a [.path]_pages_ directory are classified as pages.
<.> A ROOT module directory.
<.> A [.path]_pages_ family directory.

The [.path]_pages_ directory is optional.
That is, if a module doesn't have any page files, don't create a [.path]_pages_ directory in the module.
If you set up a [.path]_pages_ directory, the [.path]_pages_ directory or a subdirectory of [.path]_pages_ must contain at least one AsciiDoc source file.

[#pages]
== Page files

Antora classifies the source files stored in a [.path]_pages_ directory as pages.
Pages are structured as individual documents with a title, marked up using the AsciiDoc syntax, and saved with the _.adoc_ file extension.
Using a page's resource ID, you can xref:page:xref.adoc[cross reference a page] from other pages, resources, or navigation files in your site or xref:page:include-a-page.adoc[include a page] into other pages or resources in your site.

A page file is a xref:page:resource-id.adoc#publishable[publishable resource] unless it's marked as xref:standard-directories.adoc#hidden-files[hidden or unpublished].
That means Antora automatically converts each page to HTML and publishes it as an individual page in a site, even if the page isn't referenced by another resource or navigation file.
Antora uses the __pages__-relative directory path (if present), filename of the page, and specified HTML extension style when xref:how-antora-builds-urls.adoc[building the URL of a page].

// /docs/modules/ROOT/pages/partials-directory.adoc
[[partials-directory.adoc]]
= Partials Directory and Files

[#partials-dir]
== Partials family directory

A module directory can contain a xref:family-directories.adoc[family directory] named [.path]_partials_.

[listing]
----
📂 modules
  📂 ROOT <.>
    📁 images
    📁 pages
    📂 partials <.>
      📄 partial-source-file.adoc <.>
    📄 nav.adoc
  📂 named-module <.>
    📁 pages
    📂 partials <.>
      📄 partial-source-file.adoc
      📂 subdirectory-of-partials <.>
        📄 partial-source-file.adoc
----
<.> A ROOT module directory.
<.> A [.path]_partials_ family directory.
Antora classifies source files stored in a [.path]_partials_ directory as partials.
<.> A partial file marked up with the AsciiDoc syntax and saved with the _.adoc_ file extension.
<.> A named module directory.
<.> A [.path]_partials_ family directory.
<.> A subdirectory in [.path]_partials_.
Source files stored in subdirectories of a [.path]_partials_ directory are classified as partials.

The [.path]_partials_ directory is optional.
Antora applies preset behavior to the source files stored in the [.path]_partials_ directory when it generates a site.

[#partials]
== Partial files

Antora classifies the source files stored in a [.path]_partials_ directory as partial files, or partials for short.
Partials are usually AsciiDoc files that contain content snippets, such as common descriptions or terminology, that are inserted into one or more pages or partials.
However, Antora doesn't require partials to be AsciiDoc files.

include::page:page$partials.adoc[tag=filename]

A partial isn't required to have a file extension.
Unlike a publishable resource that's treated as a xref:standard-directories.adoc#hidden-files[hidden file] if it's missing a file extension, Antora will load a partial that doesn't have a file extension into its content catalog and assign the partial a resource ID for referencing.

Antora doesn't publish partial files as individual site pages.
A xref:page:include-a-partial.adoc[partial must be referenced by an include directive] from a page, or resource that's eventually included in a page, for the partial's content to be published.

// tag::extension[]
IMPORTANT: Except when it's typical for a file type to not have a file extension, it's a good practice to save your partial source files with their valid file extensions.
// end::extension[]

== Learn more

* xref:page:partials.adoc[]
* xref:page:include-a-partial.adoc[]

// /docs/modules/ROOT/pages/examples-directory.adoc
[[examples-directory.adoc]]
= Examples Directory and Files

[#examples-dir]
== Examples family directory

A module directory can contain a xref:family-directories.adoc[family directory] named [.path]_examples_.

[listing]
----
📂 modules
  📂 ROOT <.>
    📂 examples <.>
      📄 example-source-file.ext <.>
    📁 pages
    📄 nav.adoc
  📂 named-module <.>
    📂 examples <.>
      📄 example-source-file <.>
      📂 subdirectory-of-examples <.>
        📄 example-source-file.ext
    📁 images
----
<.> A ROOT module directory.
<.> An [.path]_examples_ family directory.
Antora classifies source files stored in an [.path]_examples_ directory as examples.
<.> An example source file.
<.> A named module directory.
<.> An [.path]_examples_ family directory.
<.> An example source file without a file extension.
Antora will load example source files without extensions into the content catalog.
<.> A subdirectory in [.path]_examples_.
Source files stored in subdirectories of an [.path]_examples_ directory are classified as examples.

The [.path]_examples_ directory is optional.
Antora applies preset behavior to the source files stored in an [.path]_examples_ directory when it generates a site.

[#examples]
== Example files

Antora classifies the source files stored in an [.path]_examples_ directory as examples.
Example files usually contain content such as source code samples, terminal output, data sets, etc.

include::page:page$examples.adoc[tag=filename]

An example file isn't required to have a file extension.
Unlike a publishable resource that's treated as a xref:standard-directories.adoc#hidden-files[hidden file] if it's missing a file extension, Antora will load an example that doesn't have a file extension into its content catalog and assign the example a resource ID for referencing.

Antora doesn't publish example files as individual site pages.
An xref:page:include-an-example.adoc[example must be referenced by an include directive] from a page, or resource that's eventually included in a page, for the example's content to be published.

IMPORTANT: Except when it's typical for a file type to not have a file extension, such as [.path]_Dockerfile_, it's a good practice to save your example source files with their valid file extensions.
Otherwise, you may not be able to use some Antora or Asciidoctor extensions that apply additional behavior to example files.

TIP: Examples shouldn't be confused with the AsciiDoc example block, though an example file can be inserted into an example block using an include directive.

== Learn more

* xref:page:examples.adoc[]
* xref:page:include-an-example.adoc[]

// /docs/modules/ROOT/pages/images-directory.adoc
[[images-directory.adoc]]
= Images Directory and Files

[#images-dir]
== Images family directory

A module directory can contain an xref:family-directories.adoc[optional family directory] named [.path]_images_.

[listing]
----
📂 modules
  📂 ROOT <.>
    📂 images <.>
      📄 image-source-file.ext <.>
    📁 pages
    📄 nav.adoc
  📂 named-module <.>
    📁 examples
    📂 images <.>
      📄 image-source-file.ext
      📂 subdirectory-of-images <.>
        📄 image-source-file.ext
    📁 pages
----
<.> A ROOT module directory.
<.> An [.path]_images_ family directory.
Antora classifies source files stored in an [.path]_images_ directory as images.
<.> An image source file.
<.> A named module directory.
<.> An [.path]_images_ family directory.
<.> A subdirectory in [.path]_images_.
Source files stored in subdirectories of a [.path]_images_ directory are classified as images.

Antora applies preset behavior to the source files stored in an [.path]_images_ directory when it generates a site.

[#images]
== Image files

xref:page:images.adoc[Images] are resources, such as photographs, diagrams, and screenshots.
The source files for images are stored in an [.path]_images_ family directory.
Antora supports the PNG, JPG, SVG, and GIF (static and animated) image file formats.

Regardless of the component version the image belongs to, the image can be embedded into a page or partial using the image's resource ID and an AsciiDoc xref:page:block-images.adoc[block image macro] or xref:page:inline-images.adoc[inline image macro].

Antora automatically publishes each image file, except when the image file is marked as xref:standard-directories.adoc#hidden-files[hidden or it's missing a file extension].
Antora uses the xref:how-antora-builds-urls.adoc#family[family segment] and xref:how-antora-builds-urls.adoc#relative-path[relative path segment of the image file] when building the URL for an image.

include::partial$assets-directory.adoc[]

// /docs/modules/ROOT/pages/attachments-directory.adoc
[[attachments-directory.adoc]]
= Attachments Directory and Files

[#attachments-dir]
== Attachments family directory

A module directory can contain a xref:family-directories.adoc[family directory] named [.path]_attachments_.

[listing]
----
📂 modules
  📂 ROOT <.>
    📂 attachments <.>
      📄 attachment-source-file.ext <.>
    📁 images
    📁 pages
    📄 nav.adoc
----
<.> A ROOT module directory.
<.> An [.path]_attachments_ family directory.
Antora classifies source files stored in an [.path]_attachments_ directory as attachments.
<.> An attachment source file.

The [.path]_attachments_ directory is optional.
Antora applies preset behavior to the files stored in an [.path]_attachments_ directory when it generates a site.

[#attachments]
== Attachment files

An attachment is typically a file a site visitor views or downloads using their browser, such as a PDF or the ZIP archive of a sample project.

At runtime, Antora automatically:

* Loads each file from an [.path]_attachments_ directory into the Antora content catalog, except for files xref:standard-directories.adoc#hidden-files[marked as hidden or missing a file extension]
* Assigns each loaded attachment file to the attachment family
* Assigns each loaded attachment a xref:page:resource-id.adoc[unique resource ID] for source-to-source referencing
* Publishes each loaded attachment file as an individual page in a site, except for files xref:standard-directories.adoc#unpublished[marked as unpublished]

Using an attachment's resource ID, you can xref:page:attachments.adoc[cross reference an attachment] from other pages, resources, or navigation files in your site.
Antora uses the family directory, __attachments__-relative directory path (if present), filename, and file extension of the attachment when xref:how-antora-builds-urls.adoc[building the URL of an attachment].

=== Binaries and other large files

If your content includes large attachment files, such as sample project binaries, libraries, or PDFs, we don't recommend storing them in a regular git repository.
Instead, host them in a binary repository such as S3, or use git LFS (Large File Storage).

include::partial$assets-directory.adoc[]

== Learn more

* xref:page:attachments.adoc[]

// /docs/modules/ROOT/pages/component-version.adoc
[[component-version.adoc]]
= What's a Component Version?
:mdash: &#8212;

== Component version

A [.term]*component version* represents a discrete version of the documentation for a project, product, library, service, training course, etc.
Antora looks for source files associated with the same xref:component-name-key.adoc[component name] and xref:component-version-key.adoc[version] in multiple content sources and aggregates them together to make a component version.
The xref:component-version-descriptor.adoc[component version descriptor file] (named [.path]_antora.yml_) declares each component version and marks the source files that belong to it.
It also supplies additional configuration for that component version.

[#docs-component]
== Component

A [.term]*component*{mdash}more formally a *documentation component* or shortened to *docs component*{mdash}refers to all component versions that share the same xref:component-name-key.adoc[component name].
A component is never declared directly.
Instead, it gets created by having at least one component version.

If there's only one version of a component, and the version is empty (i.e., a versionless component), then the terms component and component version are effectively interchangeable.

////
move to better location

[#docs-component-vs-site]
== What's the difference between a docs component and a site?

A [.term]*documentation site* or *site* is a website generated by Antora and published to a directory or domain specified in a playbook.
A site typically consists of one or more docs components and each docs component consists of one or more component versions.
////

// /docs/modules/ROOT/pages/component-version-descriptor.adoc
[[component-version-descriptor.adoc]]
= What's antora.yml?
:page-aliases: component-descriptor.adoc

[.path]_antora.yml_ is a configuration file that serves two crucial functions.

. The presence of an [.path]_antora.yml_ file at a content source root signals to Antora that it should find a sibling [.path]_modules_ directory that contains source files that belong to a component version.
. The [.path]_antora.yml_ file at a content source root provides the required and optional component version metadata that Antora assigns to the source files it collects from the standard directories located in the [.path]_modules_ folder.

[#locate-content-source-root-with-antora-yml]
== Why is antora.yml stored at a content source root?
//Why does Antora look for antora.yml at a content source root?
//How does Antora use an antora.yml file to find a component version's source files?

//A xref:playbook:index.adoc[playbook] tells Antora what xref:playbook:configure-content-sources.adoc[remote repositories and local content sources] it should fetch.
Starting at each content source root, Antora looks for an [.path]_antora.yml_ file.
When it finds [.path]_antora.yml_, it searches for a  xref:module-directories.adoc[sibling _modules_ directory] and considers all of its xref:standard-directories.adoc[subdirectories and files] to be part of a xref:component-version.adoc[component version].

If Antora doesn't find [.path]_antora.yml_ at a content source root, it doesn't look for a [.path]_modules_ directory or collect any files from that location.
This minimizes the chances of Antora wasting memory and CPU time to process source files that aren't part of a documentation site.

The [.path]_antora.yml_ files provide the ability to store your content source files anywhere in a directory hierarchy.
As long as the xref:content-source-repositories.adoc#content-source-root[content source root] contains an [.path]_antora.yml_ file, you can maintain and manage your content source files in a repository that also stores application code, tests, and other materials.

[#provide-metadata-with-antora-yml]
== What information does antora.yml provide?

An [.path]_antora.yml_ file is referred to as a [.term]*component version descriptor* because it provides required and optional information that identifies, describes, and configures a xref:component-version.adoc[component version].
In turn, this metadata and configuration is applied to all of the source files that belong to the component version.

This is why Antora can collect files from multiple repositories, directories, branches, and tags, and compile them into a single component version.
Instead of processing files based on their file system or repository location, Antora converts files based on the information assigned to the source files by a component version descriptor file.

An [.path]_antora.yml_ file contains the following required keys:

include::partial$required-component-version-keys.adoc[]

An [.path]_antora.yml_ file can also contain any of the following optional keys:

include::partial$optional-component-version-keys.adoc[]

// /docs/modules/ROOT/pages/component-name-and-version.adoc
[[component-name-and-version.adoc]]
= Define a Component Version
//Define a Component Name and Version
:note-caption: ASSUMPTIONS

On this page, you'll learn:

* [x] The requirements an [.path]_antora.yml_ file must meet.
* [x] How to assign a valid value to the `name` key.
* [x] How to assign a valid value to the `version` key.
* [x] How to define additional keys and values in an [.path]_antora.yml_ file.

NOTE: You understand what a xref:component-version.adoc[component version] is and the purpose of xref:component-version-descriptor.adoc[_antora.yml_].

[#antora-yml-requirements]
== antora.yml requirements

A component version descriptor file must:

* be named [.path]_antora.yml_
* be written in valid YAML
* contain the `name` key with a valid value
* contain the `version` key (unless inherited from the content source in the playbook) with a valid value
* be stored xref:module-directories.adoc[at the same directory level as the _modules_ directory]

The following section provides instructions for creating an [.path]_antora.yml_ file and assigning values to the `name` and `version` keys to define a component version.
For detailed information about the purpose of `name` and `version`, how Antora uses them, their specific requirements, and more usage examples, see xref:component-name-key.adoc[] and xref:component-version-key.adoc[].

[#assign-name-and-version]
== Assign a name and version to a component version

Let's create an [.path]_antora.yml_ file that defines the name and version of a component version.
In this exercise, we'll create a component version for the project _Silver Leaf_.
Its component name will be _silver-leaf_, and its version will be _7.1_.

. Open a new file in your text editor or IDE.
. On the first line, type `name`, directly followed by a colon (`:`).
. Press the kbd:[Spacebar] to insert a space after the colon, and then type the value you want to assign to `name`.
The `name` key doesn't accept certain characters or spaces in its value, see xref:component-name-key.adoc#requirements[name requirements] for details.
+
[,yaml]
----
name: silver-leaf
----

. At the end of the value, press kbd:[Enter] to go to the next line.
. Type `version`, directly followed by a colon (`:`), and then press the kbd:[Spacebar] to insert a space.
. Type the value you want to assign to `version`.
In this example, the value is enclosed in a set of single quote marks (`'`) so it's not interpreted as a number.
+
[,yaml]
----
name: silver-leaf
version: '7.1'
----
+
The `version` key doesn't accept certain characters or spaces in its value, see xref:component-version-key.adoc#requirements[version requirements] for details.
. Save the file as [.path]_antora.yml_ in the xref:content-source-repositories.adoc#content-source-root[content source root].
The [.path]_antora.yml_ file should be located adjacent to the [.path]_modules_ directory, which contains the content files for the component version.

You've now associated a set of source files with a component version!
When Antora runs, all of the xref:standard-directories.adoc[source files stored in the standard set of directories] will be assigned the component name `silver-leaf` and the version `7.1`.
These values will be used as xref:page:resource-id-coordinates.adoc#id-version[resource ID coordinates] and in the URLs of the publishable resources generated from the component version's source files.

TIP: Be sure to always use the same case when declaring the component name if you're defining multiple versions of a component.
If the case differs (e.g., Silver-Leaf versus silver-leaf), Antora will treat these as different components.
See xref:component-name-key.adoc[] and xref:component-version-key.adoc[] for more examples and value requirements.

[#optional-keys]
== Optional antora.yml keys

You can assign additional metadata, designate a component version as a prerelease, apply AsciiDoc attributes, and register a component version's navigation list and start page using the component version descriptor.

include::partial$optional-component-version-keys.adoc[]

To learn more about the capabilities of the `version` key and compare it to the other version facets Antora provides--prerelease version, display version, and symbolic version--see xref:version-facets.adoc[].

// /docs/modules/ROOT/pages/component-name-key.adoc
[[component-name-key.adoc]]
= Name Key

A component name is defined by assigning a value to the `name` key.

== What's a component name?

A [.term]*component name*, also called [.term]*name*, is the value assigned to the `name` key in a component version descriptor file ([.path]_antora.yml_).
A component name typically represents the name of a project, library, service, etc., such as `fauna`, `rudder`, `nrepl`, etc.
The value of a `name` key, in combination with the value of a `version` key, defines a xref:component-version.adoc[component version].

[#usage]
=== How Antora uses name

The component name is fundamental to many of Antora's operations.
Antora uses the name:

* as the xref:how-antora-builds-urls.adoc#component[component segment] in page and asset URLs, unless <<root-component,the name of the component is _ROOT_>>.

Additionally, if the component title key isn't set, Antora uses the name:

* to xref:how-component-versions-are-sorted.adoc[sort component versions]
* for display purposes in the reference UI, which includes the xref:navigation:index.adoc#component-menu[component version page menu], xref:navigation:index.adoc#component-dropdown[component version selector menu], and
the first breadcrumb position on a component version's pages

Note that component name is case sensitive.
This means that if you have two components with the same name that only are different in case, Antora will treat them as different components.

Content writers use the name as the xref:page:resource-id-coordinates.adoc#id-component[component coordinate in resource IDs] when referencing a resource in another documentation component.

[#key]
== name key

The `name` key is required.
It's set and assigned a value in a component version descriptor file ([.path]_antora.yml_).

.antora.yml with defined component name
[,yaml]
----
name: colorado # <.>
----
<.> At the beginning of a new line, type `name`, directly followed by a colon and a space (`:{sp}`).
Then type the value you want assigned to `name`.

[#requirements]
=== name requirements

The value assigned to the `name` key can contain letters, numbers, underscores (`+_+`), hyphens (`-`), and periods (`.`).
To ensure portability between host platforms, letters used in the `name` value should be lowercase.

IMPORTANT: We *strongly* encourage you to select a name that only consists of _lowercase_ characters.
Component names, except for <<root-component,the special _ROOT_ value>>, are used in your site's URLs, therefore, using consistent casing makes the component name, and thus your site, more portable.
That's because some file systems, and thus the web server running on it, can't distinguish between uppercase and lowercase characters.

The value *cannot* contain spaces, forward slashes (`/`), or HTML special characters (`&`, `<`, or `>`).
The value *cannot* be empty.

See xref:component-title.adoc[] to learn how to display a name that contains spaces, uppercase letters, and other characters in your site's UI.

[#root-component]
=== ROOT component

When a component's name is set to _ROOT_ and its version is set to `~` in its [.path]_antora.yml_, then that component will be placed directly at the site's root.
It will not be placed inside a folder named `ROOT`.
This is analogous to how modules named _ROOT_ are placed at the root of their component.

Like other components, a _ROOT_ component must have an [.path]_antora.yml_ file and a [.path]_modules_ folder.
Let's re-use the example from xref:module-url-segment#ex-modules[Module Segment in Page URLs]:

[listing#ex-modules]
----
📒 repository
  📄 antora.yml # name: ROOT and version: ~
  📂 modules
    📂 admin
      📂 pages
        📄 user-management.adoc
      📄 nav.adoc
    📂 ROOT
      📁 images
      📂 pages
        📄 deploy.adoc
        📄 index.adoc
      📄 nav.adoc
----

But now let's instead assume that this component is named _ROOT_ instead of _hyperlemur_, and its version set to `~`.
Here is what the URLs of the pages would be (assuming that `html_extension_style` is set to `default` in your playbook):

[.path]_repository/modules/ROOT/pages/index.adoc_:: \https://my-company.com/index.html (which means it will also be found at \https://my-company.com)
[.path]_repository/modules/ROOT/pages/deploy.adoc_:: \https://my-company.com/deploy.html
[.path]_repository/modules/admin/pages/user-management.adoc_:: \https://my-company.com/admin/user-management.html

Because both the component name _ROOT_ and the module name _ROOT_ are excluded from URLs, the pages in the _ROOT_ component's _ROOT_ module live directly at your site's root, with [.path]_root_component/modules/ROOT/pages/index.adoc_ serving as the site's home page.
That means that the index.adoc page in the ROOT module of the ROOT component acts as the site start page *without* having to specify it (no additional configuration is required).

If the ROOT component were to be versioned (i.e., have a non-empty version), then the files in that component version would be placed inside the version folder at the root of the site.

[CAUTION]
Because the _ROOT_ component's name does not appear in URLs, its modules are effectively scoped under your site's root.
This means it's possible for pages in the _ROOT_ component to conflict with pages in a named component.
For instance, the file [.path]_modules/xyz/pages/index.adoc_ in the (unversioned) _ROOT_ component and the file [.path]_modules/ROOT/pages/index.adoc_ in the (unversioned) _xyz_ component will both resolve to the URL \https://my-company.com/xyz/index.html, which is invalid.
Therefore, you should be mindful of this situation when using modules in the _ROOT_ component.

Since _ROOT_ is not a user-friendly title for a component, you should also set the title in [.path]_antora.yml_, as demonstrated in xref:component-title.adoc[Customize the Title].

////
Antora uses the `name` key when interpreting resource IDs and generating the URLs for the component version's pages.
Unless the xref:component-title.adoc[title key is set], it uses `name` for sorting components in the component version selector and where ever the component's name is displayed in the reference UI, which includes the xref:navigation:index.adoc#component-menu[component version page menu], xref:navigation:index.adoc#component-dropdown[component version selector], and
the first breadcrumb position on a component version's pages.
////

// /docs/modules/ROOT/pages/component-version-key.adoc
[[component-version-key.adoc]]
= Version Key
:description: A version is resolved from the version key in a component version descriptor file (antora.yml) or inherited from a content source in the playbook.
:mdash: &#8212;

A version is defined by assigning a value to the `version` key.
It's important to understand <<usage,how Antora uses the version>> and its related facets before committing to a versioning scheme.

== What's a version?

In Antora, a [.term]*version* is the value resolved from the `version` key in a component version descriptor file ([.path]_antora.yml_) or inherited from the content source in the playbook.
A version is a semantic or named identifier that represents a unique release or instance of the documentation for a project.
The resolved value of the `version` key, in combination with the value of the `name` key, defines a xref:component-version.adoc[component version].

Although the version is typically a literal value, it can also be interpreted.
The version can be defined as xref:component-with-no-version.adoc[unversioned] by assigning a tilde, `~`, to the `version` key.
The version can be configured as the refname in which it resides by assigning `true` to the `version` key.
The version can also be derived from the refname by assigning a map of refname projections to the `version` key.

Occasionally, the value assigned to the `version` key is referred to as the [.term]*actual version* in this documentation when a distinction between version and the other version facets--xref:version-facets.adoc#prerelease[prerelease], xref:version-facets.adoc#display[display], and xref:version-facets.adoc#symbolic[symbolic]{mdash}needs to be made in a description or example.

[#usage]
=== How Antora uses version

The version is fundamental to many of Antora's operations.
Antora uses the version:

* to xref:how-component-versions-are-sorted.adoc[sort component versions]
* identify the xref:how-component-versions-are-sorted.adoc#latest-version[latest version of a component]
* apply routing rules
* as the xref:how-antora-builds-urls.adoc#version[version segment] in publishable resource URLs, except when:
** the assigned value is the xref:component-with-no-version.adoc[tilde (~) that defines an unversioned component version]
** a component version is identified as the latest stable or latest prerelease version and the xref:playbook:urls-latest-version-segment.adoc[latest_version_segment key] or xref:playbook:urls-latest-prerelease-version-segment.adoc[latest_prerelease_version_segment key] is set in the playbook
* for display purposes in the reference UI xref:navigation:index.adoc#component-dropdown[component version selector] and xref:navigation:index.adoc#page-dropdown[page version selector] menus, except when:
** the `display_version` key is set and assigned a value in the component version's [.path]_antora.yml_ file
** the `display_version` key is set by Antora at runtime because the xref:component-prerelease.adoc#identifier[prerelease key is assigned an identifier]

Content writers use the version as the xref:page:resource-id-coordinates.adoc#id-version[version coordinate in resource IDs] when referencing a resource in another component version.

[#key]
== version key

The `version` key accepts a named identifier, such as `jesse`, a semantic identifier, such as `'1.5.0'`, the reserved value `true`, a map of refname projections, such as `+v/(?<version>*): $<version>+`, or the reserved value `~`.
The `~` values defines a component version as unversioned.
To learn how to specify an unversioned component version, see xref:component-with-no-version.adoc[].

If the `version` key is defined in the component version descriptor file for a component version, it takes precedence over a value defined on the content source in the playbook.
If you prefer the playbook to control the value of the `version` key, don't set the `version` key in the component version descriptor file.
// TODO: The above sentence needs to be evaluated.

[#named-identifier]
=== Named identifier as version

The following example shows how to assign a named identifier to the `version` key.

.antora.yml with named identifier assigned to version
[#ex-name,yaml]
----
name: star
version: rigel # <.>
----
<.> On a new line, type `version`, directly followed by a colon and a space (`:{sp}`).
Then type the value you want assigned to `version`.

[#semver-identifier]
=== Semantic identifier as version

A semantic identifier is either an integer or begins with an integer and contains at least one dot (`.`).
`10`, `1.0.0`, and `5.1` are all examples of semantic identifiers.
Although a semantic identifier looks like a number, it's actually a string.
If the semantic identifier matches the syntax of a number (integer or decimal), like the one shown in <<ex-semver>>, you should enclose the value in a pair of single quotes (`'`), which coerces it to a string.

The following example shows how to assign a semantic identifier to the `version` key.

.antora.yml with semantic identifier assigned to version
[#ex-semver,yaml]
----
name: colorado
version: '5.6.0' # <.>
----
<.> Enclose a value that matches the syntax of a number in a pair of single quote marks (`'`).

Antora recognizes semantic identifiers according to https://semver.org[semantic versioning rules].
Semantic versioning is often referred to as semver.
Antora allows a semantic identifier to begin with `v`.
Although this prefix is preserved in the value, Antora will ignore it when sorting versions.
For example, `v9.0.2` will be sorted as though the value is `9.0.2`.

[#refname]
=== refname as version

Since content in Antora is retrieved from a git repository, you may want to use the git refname (branch or tag name) in which the component version descriptor is stored as the version.
To do so, assign the reserved value `true` to the version, as shown in <<ex-refname>>.

.antora.yml with true assigned to version
[#ex-refname,yaml]
----
name: colorado
version: true # <.>
----
<.> The value `true` tells Antora to use the refname as the value.

Antora will substitute the value `true` with the refname automatically.
The value Antora uses is always the short refname (e.g., v1.0), not the full refname (e.g., refs/heads/v1.0).
If the short refname contains any forward slashes, Antora will replace each one with a hyphen.

[#refname-projection]
=== refname projection as version

The refname may not be granular enough to use as the version.
Furthermore, the same git tree could be passed through git references that have different naming schemes, such as feature branches.
In these cases, you want the version to be extracted or derived from the refname rather than using the value as is.
That's when you'd define the version using a refname projection.

A refname projection is expressed as a map of patterns (the keys) and replacements (the values).
The refname projection allows you to match the refname using a pattern, then build a version based on that match.
The pattern tells Antora which entry to use and what parts to extract from it.
The replacement tells Antora how to derive a version from the matched refname.

The following example shows how to use a projection to compute the value of the `version` key from the refname.

.antora.yml with version computed from a refname projection
[#ex-projection,yaml]
----
name: colorado
version:
  v(?<version>+({0..9}).+({0..9})).x: $<version> # <.>
  feature/(*)/*: $1 # <.>
----
<.> Matches the semantic identifier in a refname like `v2.0.x` and extracts it
<.> Extracts the value between the first and second slash for a refname that begins with `feature/`

The key in the projection is a glob pattern (a combination of extglobs, ranges, and some regex constructs).
The pattern has the same matching capabilities as the pattern used to match branches or tags for a content source in the playbook.

The characters between parentheses (i.e., round brackets) in the pattern defines a match group.
If the opening brace begins with `?<name>`, that group is assigned to the name specified between the angle brackets.
Otherwise, the group is assigned to a 1-based index according to the group's position in the pattern.

The match groups can be referenced in the replacement.
A match group reference is preceded by a dollar sign (`$`).
A named group can be referenced using `$<name>`, where the name is once again specified between the angle brackets.
An indexed group can be referenced by its number, such as `$1`.
You can reference the entire refname using `$&`.

If the match group contains any forward slashes, Antora will replace each one with a hyphen.

Antora will use the value of the first pattern it matches.
If none of the patterns match the refname, Antora will fallback to using the refname as the version.

[#requirements]
== Value requirements

A literal value assigned to the `version` key can contain letters, numbers, periods (`.`), underscores (`+_+`), and hyphens (`-`).
To ensure portability between host platforms, letters used in the `version` value should be lowercase.

The value *cannot* contain spaces, forward slashes (`/`), or HTML special characters (`&`, `<`, or `>`).
See xref:component-display-version.adoc[] to learn how to represent a version that contains spaces, uppercase letters, and other characters in the UI menus.

// /docs/modules/ROOT/pages/component-title.adoc
[[component-title.adoc]]
= Customize the Title

The `title` key is used to assign a title to the component version (and, by relation, the component).
The title is the formal, user-facing text for a component version, typically the proper name of the product, project, or subject matter.
The title is also used for xref:how-component-versions-are-sorted.adoc[sorting the versions] in the explore panel of the default UI.

The title doesn't affect page and resource IDs or the component name segment in the page URL.

[#title-key]
== title key

The `title` key is optional.
This key is set in a component version's [.path]_antora.yml_ file.
The value is used by the reference UI wherever the component or component version is referenced, including the xref:navigation:index.adoc#component-menu[component version page menu], xref:navigation:index.adoc#component-dropdown[component version selector], and first breadcrumb position on a component version's pages.

Although the title is set per component version, it should almost always be uniform across all versions of a component.
Antora uses the title of the latest version as the title of the component.
When viewing a specific version, such as in the breadcrumb navigation, the title of that version will be displayed instead.
If the title differs between versions, it may confuse the reader.
If you do need to change the title in a newer version, and you don't want to update older versions, you can customize the UI template to always use the title of the latest version.

If `title` isn't set, the reference UI uses the xref:component-name-key.adoc[component name] (the value of the `name` key) instead.
Unlike `name`, the value of `title` can contain spaces, uppercase letters, and a broader range of characters (e.g., `SUSE Manager`, `APIkit`).

.antora.yml
[,yaml]
----
name: colorado
title: Colorado ∆
version: '5.6'
----

This key is useful when a project's name contains spaces or characters that break Antora's page and resource IDs, prevent portability between web servers, or aren't recommended in URLs.
Also, if the name of your project changes, you can change the value of the `title` key but not have to update page and resource IDs or redirect URLs.

[#assign-title]
== Assign a title to a component version

Let's expand on the [.path]_antora.yml_ example where you previously learned xref:component-name-and-version.adoc#assign-name-and-version[how to assign a component name and version].
The project's official name is _Silver Leaf_, and the team wants this name to be displayed in the UI.
Since `name` can't contain blank spaces, let's set `title` in the component version's [.path]_antora.yml_ file.

. Open the component version's [.path]_antora.yml_ file in the text editor or IDE of your choice.
+
.antora.yml for the component version silver-leaf 7.1
[,yaml]
----
name: silver-leaf
version: '7.1'
----

. On a new line, type `title`, directly followed by a colon (`:`).
. Insert a blank space after the colon, and then type the value you want to assign to `title`.
+
[,yaml]
----
name: silver-leaf
title: Silver Leaf
version: '7.1'
----

. Save the file.

Now, the UI will display _Silver Leaf_ in the component version page menu, component version selector, and page breadcrumbs.

// /docs/modules/ROOT/pages/component-display-version.adoc
[[component-display-version.adoc]]
= Customize the Display Version

The `display_version` key is strictly used for presentation purposes in the reference UI when a version identifier contains uppercase letters, symbols, or blank spaces.
It doesn't affect resource IDs, the version segment in the publishable resource URLs, or xref:how-component-versions-are-sorted.adoc[how component versions are sorted].

[#display-version-key]
== display_version key

The `display_version` key is optional.
It's set in a component version's [.path]_antora.yml_ file and used by the reference UI where ever the version is displayed, including the xref:navigation:index.adoc#component-dropdown[component version selector] and xref:navigation:index.adoc#page-dropdown[page version selector].

If `display_version` isn't set, the reference UI falls back to xref:component-version-key.adoc[the version key].
Unlike `version`, the value of `display_version` can contain spaces, uppercase letters, and most characters (e.g., `3.0 Beta`, `RED WREN!`, `rawhide`).

.antora.yml
[,yaml]
----
name: colorado
title: Colorado ∆
version: '5.6'
display_version: '5.6 EOL' # <.>
----
<.> If the value starts with a number, enclose it in a set of single quote marks (`'`).

The `display_version` key should be used when a version contains spaces or characters that would break Antora's resource IDs, prevent portability between web servers, and aren't recommended in URLs.
It's useful when the component version is a xref:component-prerelease.adoc[prerelease], xref:component-with-no-version.adoc[unversioned], or archived because the value of `display_version` doesn't affect publishable resource URLs and resource IDs.

TIP: The xref:component-prerelease.adoc[prerelease key] provides additional UI routing, sorting, and presentation capabilities.
While the value of the `display_version` key is shown in the UI when both keys are set, the computed prerelease version generated from a xref:component-prerelease.adoc#identifier[prerelease identifier] is used for sorting and routing.

To learn more about how Antora uses the `display_version` key and compare it to the other version facets--actual version, prerelease version, and symbolic version--see xref:version-facets.adoc#display[Version Facets].

[#assign-display-version]
== Assign a display_version to a component version

Let's expand on the [.path]_antora.yml_ example where you previously learned xref:component-name-and-version.adoc#assign-name-and-version[how to assign a component name and version].
The _Silver Leaf_ project team wants the version code name in addition to its version number to be displayed in the UI.
Since `version` can't contain blank spaces, let's set `display_version` in the component version's [.path]_antora.yml_ file.

. Open the component version's [.path]_antora.yml_ file in the text editor or IDE of your choice.
+
.antora.yml for the component version silver-leaf 7.1
[,yaml]
----
name: silver-leaf
title: Silver Leaf
version: '7.1'
----

. On a new line, type `display_version`, directly followed by a colon (`:`).
. Insert a blank space after the colon, and then type the value you want to assign to `display_version`.
Since the value begins with a number, enclose it in a set of single quote marks (`'`).
+
[,yaml]
----
name: silver-leaf
title: Silver Leaf
version: '7.1'
display_version: '7.1 Spiny'
----

. Save the file.

Now, the UI will display _7.1 Spiny_ in the component version selector and page version selector.

// /docs/modules/ROOT/pages/component-prerelease.adoc
[[component-prerelease.adoc]]
= Identify a Prerelease Version
:description: A component version becomes a prerelease when the prerelease key is set in antora.yml and assigned an identifier or the value true.

The `prerelease` key identifies a component version as a prerelease.
The prerelease key does not create a unique version.
Rather, it provides a hint that the version is not a candidate to be the latest version.

[#prerelease-key]
== prerelease key

The `prerelease` key is optional.
//It's set in a component version's [.path]_antora.yml_ file and accepts a user-defined identifier or a boolean value.
A component version is identified as a prerelease when the `prerelease` key is assigned a user-defined identifier, such as `-beta.2`, or the boolean value `true`.
Note that setting the `prerelease` key does not make the version unique.
In fact, that's the whole point.
The identify of the component version remains exactly the same when the `prerelease` key is removed.

Antora doesn't apply the default routing rules to a component version designated as a prerelease, even if it's the <<sort-and-route,latest version in that docs component>> (unless all versions of that docs component are prereleases).
When a component version is ready to graduate from a prerelease to a stable release, change the value of the `prerelease` key to `false` or delete the key and its value from the [.path]_antora.yml_ file.

TIP: To learn more about the capabilities the `prerelease` key provides and compare it to the other version facets--actual version, display version, and symbolic version--see xref:version-facets.adoc#prerelease[Version Facets].

[#identifier]
=== Assign an identifier to prerelease

A component version becomes a prerelease when the `prerelease` key is set in [.path]_antora.yml_ and assigned an identifier.
An [.term]*identifier* is a user-defined, non-empty string such as `.alpha.2`, `-M1`, `SNAPSHOT`, and `-rc.5`.
It can contain uppercase letters and a broad range of characters.
The component version defined in <<ex-append-identifier>> is a prerelease.

.antora.yml with prerelease assigned the identifier -rc.3
[#ex-append-identifier,yaml]
----
name: colorado
title: Colorado ∆
version: '6.0.0'
prerelease: -rc.3 # <.>
----
<.> Assign an identifier to `prerelease` to designate the component version as a prerelease.

When `prerelease` is assigned an identifier, Antora computes an internal prerelease version value for UI sorting and, if `display_version` isn't set, for display purposes.
This computed prerelease version depends on the first character in the prerelease identifier.

Identifiers that begin with a hyphen (`-`) or dot (`.`)::
The computed prerelease version takes the form of _version-identifier_ or _version.identifier_.
Antora directly appends the prerelease identifier to the `version` key's value to compute the prerelease version.
For instance, using <<ex-append-identifier>>, the computed prerelease version would be _6.0.0-rc.3_.

Identifiers that begin with any other valid character::
The computed prerelease version takes the form of _version identifier_.
Antora separates the identifier from the `version` key's value with one blank space to compute the prerelease version.
+
--
.antora.yml with prerelease assigned the identifier Beta
[#ex-compute,yaml]
----
name: colorado
title: Colorado ∆
version: '4.0'
prerelease: Beta
----

Using <<ex-compute>>, the computed prerelease version would be _4.0 Beta_.
--

Unless the `display_version` key is set in [.path]_antora.yml_, Antora assigns the computed prerelease version to `display_version` at runtime.
If `display_version` is defined in [.path]_antora.yml_, then that value is displayed in the UI.
However, the component version is still <<sort-and-route,sorted according to the internally computed prerelease version value>>.

[#true]
=== Assign true to prerelease

A component version becomes a prerelease when the `prerelease` key is set in [.path]_antora.yml_ and assigned the value `true`.

.antora.yml with prerelease defined as true
[#ex-true,yaml]
----
name: colorado
title: Colorado ∆
version: '6.5.0-snapshot'
prerelease: true
----

When `prerelease` is `true`, the component version is sorted by the value of `version` but the <<sort-and-route,default routing rules>> aren't applied to it even if it's the latest version in that docs component.
////
Also, there's no visual cue displayed in the UI that indicates to a visitor that the component version is a prerelease version.
To visually indicate in a site that a component version is a prerelease, you need to either:

* define `prerelease` as `true` and xref:component-display-version.adoc[assign a value to display_version] that provides a prerelease version name or number, or
* <<identifier,assign an identifier>> to `prerelease`.
////

[#sort-and-route]
== Prerelease sorting and routing

Prerelease versions are skipped when Antora selects the xref:how-component-versions-are-sorted.adoc#latest-version[latest version of a docs component] unless all component versions are prereleases, in which case the default rules apply.
They're sorted according to the xref:how-component-versions-are-sorted.adoc#version-schemes[versioning scheme criteria] the computed prerelease version meets.

[#promote-to-stable]
== Promote a prerelease to stable

When a component version is ready to graduate from a prerelease to a stable release, change the value of the `prerelease` key to `false`.

.antora.yml with prerelease defined as false
[#ex-promote,yaml]
----
name: colorado
title: Colorado ∆
version: '6.0.0'
prerelease: false # <.>
----
<.> Remove the previous value and replace it with `false` to promote the component version to a stable release.

The <<sort-and-route,default routing and sorting rules>> are applied to a component version when `prerelease` is set to `false`.
Alternatively, you can delete the key and its value from [.path]_antora.yml_ once it's stable.

// /docs/modules/ROOT/pages/component-with-no-version.adoc
[[component-with-no-version.adoc]]
= Define a Component with No Version

Sometimes the project or process you're documenting isn't versioned.
For example, hosted technology services and team handbooks may only need their content to represent how the service or process works as of right now.
This is where the reserved version value of a tilde, `~`, comes into play.

== Assign ~ to the version key

To define a component version that doesn't have a version, assign a tilde, `~`, to the `version` key.
The `~` is shorthand for the value `null`, which has the same effect.

.antora.yml for a versionless component version
[,yaml]
----
name: component-name
version: ~ # <.>
----
<.> On a new line, type the key `version`, directly followed by a colon and a blank space (`:{sp}`).
Then enter the value `~`.

Antora doesn't apply the same behavior and output rules to an unversioned component version that it does to a component version with a named or semantic version.
For example, Antora doesn't include the version segment in the publishable resource URLs of an unversioned component version (e.g., [.path]_/component-name/module-name/page-name.html_).

[#usage]
== Behavior and output

The `version` key is required for a component version since versioning is central to how Antora works.
The behavior and output rules that are influenced by the version are described in xref:component-version-key.adoc#usage[How Antora uses version].
However, Antora accounts for the fact that some components aren't versioned or have an unversioned version that's co-located with actual versions.
When the `version` key is assigned `~`, defining the component version as unversioned, Antora:

* sorts the unversioned component version above xref:how-component-versions-are-sorted.adoc[other versions that belong to the same component]
* identifies it as the xref:how-component-versions-are-sorted.adoc#latest-version[latest version of a component] or, if the `prerelease` key is set, as the latest prerelease version of a component
* assigns the fallback value `default` to the `display_version` key at runtime for display purposes in the UI menus, except when:
** the `display_version` key is assigned a value in [.path]_antora.yml_, or
** the xref:component-prerelease.adoc#identifier[prerelease key is assigned an identifier] and the `display_version` key isn't set in [.path]_antora.yml_; at runtime, Antora assigns the identifier to the `display_version` key
* doesn't add a xref:how-antora-builds-urls.adoc#version[version segment] to the unversioned component version's publishable resource URLs, even if the xref:playbook:urls-latest-version-segment.adoc[latest_version_segment key] or xref:playbook:urls-latest-prerelease-version-segment.adoc[latest_prerelease_version_segment key] is set in the playbook, unless the `latest_version_segment_strategy` is `redirect:from`

[TIP]
.UI and extension developers
====
When a component version is defined as unversioned:

* the reserved version value, `~` or `null`, is coerced into and stored as an empty string internally
* a version segment isn't added to `pub.url` or `out.path`
====

== Reference an unversioned resource

Because an unversioned component version is often the only version or always the latest component version in a component, Antora automatically routes any incoming references that originate from other components that don't specify a version coordinate to it.
However, in rare cases, such as when referencing an unversioned prerelease from another component version, you can use the reserved keyword `+_+` (an underscore) as the xref:page:resource-id-coordinates.adoc#id-version[version coordinate in the resource ID] (e.g., `\xref:_@component:module:file.adoc[]`) to reference an unversioned component version.

// /docs/modules/ROOT/pages/component-attributes.adoc
[[component-attributes.adoc]]
= Assign Attributes to a Component Version

You can apply attributes to all of the pages in a component version by declaring them in the [.path]_antora.yml_ file for that component version.

== Component version attributes

Attributes that are defined in a component version descriptor are referred to as [.term]*component version attributes*.
Component version attributes can be xref:page:attributes.adoc[built-in, custom, and page attributes].
These attributes are applied and available (or made unavailable if unset) to all of a component version's pages according to the <<precedence-rules,attribute precedence rules>>.
If an attribute was previously xref:playbook:asciidoc-attributes.adoc[hard set or hard unset in the site's playbook], *its declaration in a component version descriptor will have no impact*.

include::playbook:partial$playbook-vs-descriptor.adoc[]

[#hard-set]
== Set attributes in antora.yml

Component version attributes are set in a component version's [.path]_antora.yml_ file.
First, the `asciidoc` and `attributes` keys must be set.
Then, each component version attribute is entered on its own line as a key-value pair under `attributes`.

.Declare attributes in antora.yml
[#ex-hard-set,yaml]
----
name: light
title: Data Light
version: '2.3'
asciidoc: # <.>
  attributes: # <.>
    table-caption: Data Set # <.>
    hide-uri-scheme: '' # <.>
    page-level: Advanced # <.>
    page-category: Statistics; Cloud Infrastructure # <.>
nav:
- modules/ROOT/nav.adoc
----
<.> On a new line, type `asciidoc`, followed by a colon (`:`), and press kbd:[Enter].
<.> Nest the `attributes` key on the line directly underneath the `asciidoc` key.
Type `attributes`, followed by a colon (`:`), and press kbd:[Enter].
<.> Each component version attribute is nested under the `attributes` key and defined on its own line.
Type the name of the attribute, followed by a colon (`:`).
Press the kbd:[spacebar] once after the colon, then type the value of the attribute.
<.> To set an attribute without specifying an explicit value, assign an _empty string_ by entering two consecutive single quotation marks (`''`) in the value part.
For certain built-in attributes, an empty value is equivalent to the default value, though it depends on the attribute.
Although using the boolean value `true` often works in this case, attribute values in AsciiDoc are strings, so it will likely be coerced to the string value `'true'`.
<.> To declare a custom page attribute, type `page-` and the name of your attribute, followed by a colon (`:`).
Press kbd:[spacebar] once after the colon, then enter the value of the attribute.
<.> When an attribute has multiple, independent values, separate each value with a semicolon (`;`).

A set component version attribute is applied and available to every page that belongs to the component version.
The values of custom attributes, such as `page-level`, can be displayed in a page using the attribute reference syntax (e.g., `+{page-level}+`).

The attributes in <<ex-hard-set>> are all hard set.
[.term]*Hard set* component version attributes cannot be overridden from a page.
By default, an attribute is hard set when it's assigned a value that isn't reserved for unsetting the attribute (i.e., `false` or `~`) and doesn't end with a modifier (i.e., `@`).
To allow a page to modify or unset a component version attribute, you need to <<soft-set,soft set the component version attribute>>.

[#soft-set]
=== Soft set attributes

Soft set component version attributes can be overridden from a page.
An attribute is soft set by attaching the `@` modifier to the end of its value.

.Assign soft set precedence to attributes
[#ex-soft-set,yaml]
----
asciidoc:
  attributes:
    table-caption: Data Set@ # <.>
    hide-uri-scheme: '@' # <.>
----
<.> To soft set an attribute that's assigned an explicit value, attach the `@` modifier to the end of its value.
<.> To soft set and assign a built-in attribute's default value, or in the case of a boolean attribute, the _empty string_ value, type an opening single quotation mark, followed by the `@` modifier, and then a closing single quotation mark (`'`).

Since the component version attributes in <<ex-soft-set>> are soft set, a page could modify their values or unset them.

[#references-in-values]
=== Insert the value of another attribute

The value of any component version attribute set earlier in the same [.path]_antora.yml_ file or the value of any xref:playbook:asciidoc-attributes.adoc[site attribute] can be inserted into the value of a component version attribute using an AsciiDoc attribute reference (e.g., `+{site-title}+`, `+{page-level}+`).

.A component version attribute that references the value of another component version attribute
[#ex-attribute-value-references,yaml]
----
name: light
title: Data Light
version: '2.3'
asciidoc:
  attributes:
    table-caption: Data Set
    url-plugins: https://example.com/plugins
    url-data-plugin: {url-plugins}/data-light
nav:
- modules/ROOT/nav.adoc
----

A component version attribute can also be referenced in the value of a xref:page:attributes.adoc[page attribute].

To prevent an attribute reference substitution in an attribute value, insert a backslash in front of the reference (e.g., `+\{not-substituted}+`).
In this case, the attribute reference will not be substituted and the backslash will be omitted.

[#hard-unset]
== Unset attributes in antora.yml

Attributes can also be unset.
Component version attributes are hard unset when they're assigned the reserved tilde symbol (`~`) value.
Each attribute is entered on its own line as a key-value pair under the `attributes` key.

.Hard unset attributes
[#ex-hard-unset,yaml]
----
asciidoc:
  attributes:
    table-caption: ~ # <.>
    hide-uri-scheme: ~ # <.>
----
<.> To hard unset an attribute, assign it the tilde symbol (`~`).
`~` is shorthand in YAML for `nil`, which is a reserved value that hard unsets a site attribute.
<.> Boolean attributes are also hard unset when assigned the tilde symbol (`~`).

[.term]*Hard unset* component version attributes cannot be overridden from a page.
When a component version attribute is hard unset, its behavior is turned off and it isn't available to the component version's pages.

[#soft-unset]
=== Soft unset attributes

Soft unset component version attributes can be overridden from a page.
An attribute is soft unset by assigning it the reserved value `false`.

.Assign soft unset precedence to attributes
[#ex-soft-unset,yaml]
----
asciidoc:
  attributes:
    table-caption: false # <.>
    hide-uri-scheme: false # <.>
----
<.> To soft unset an attribute, assign it the value `false`.
<.> Boolean attributes are also soft unset when assigned `false`.

Since the attributes in <<ex-soft-unset>> are soft unset, a page could reset them.

[#precedence-rules]
== Precedence rules

Antora takes the precedence assigned to xref:playbook:asciidoc-attributes.adoc[site attributes] into account first.
An attribute declared in an [.path]_antora.yml_ file cannot override the same attribute if it's hard set or hard unset in a playbook.
A component version attribute can override a site attribute *only if the site attribute is soft set or unset*.

When component version attributes are declared, you can control whether a page can reset or unset each attribute on a case by case basis.
Assuming that the attribute was soft set or unset, or wasn't previously defined in a playbook, then component version attributes that are hard set or hard unset can't be changed by a page.
However, soft set and unset component version attributes can be overridden from a page.

. <<hard-set,Hard setting>> a component version attribute using a string value with no trailing `@` modifier (e.g., `value` or `''`) prevents a page from changing or unsetting the attribute.
. <<soft-set,Soft setting>> a component version attribute using a string value with a trailing `@` modifier (e.g., `value@` or `'@'`) allows a page to change or unset the attribute.
. <<hard-unset,Hard unsetting>> a component version attribute using the tilde symbol (`~`) prevents a page from setting the attribute.
. <<soft-unset,Soft unsetting>> a component version attribute using a `false` value allows a page to set the attribute.

To learn more about how component version attributes interact with site attributes and page attributes, see xref:playbook:asciidoc-attributes.adoc[] and xref:page:attributes.adoc[].

[#intrinsic]
== Intrinsic component version attributes

Antora defines intrinsic attributes that can be referenced by other attributes defined in the component version descriptor file (i.e., [.path]_antora.yml_).
These attributes are as follows: `antora-component-name` and `antora-component-version`.
The value of these attributes map back to the `name` and `version` keys in [.path]_antora.yml_, respectively.

Antora defines intrinsic page attributes from most of the keys in a component version descriptor file.
For instance, Antora sets the built-in attribute `page-component-title` and assigns it the value specified by the `title` key.
These attributes _cannot_ be referenced by other attributes defined in [.path]_antora.yml_, but can be referenced in any page within the same component version.
See xref:page:intrinsic-attributes.adoc#page-attributes[Intrinsic page attributes] for a complete list of the page attributes Antora automatically declares.

Antora also sets some built-in AsciiDoc attributes, such as `sectanchors`, by default.
See xref:page:intrinsic-attributes.adoc#site-and-configuration-attributes[Site and configuration attributes] for more information.

include::partial$dont-use-these-attributes.adoc[]

// /docs/modules/ROOT/pages/component-start-page.adoc
[[component-start-page.adoc]]
= Choose a Start Page

Each component version needs a start page.
This page can either be the default start page or a page identified by the component version descriptor.
Visitors land on a component version's start page when they click on its entry in the xref:navigation:index.adoc#component-dropdown[component version selector] and when they click on its name at the xref:navigation:index.adoc#component-menu[top of the page menu].

The start page for a component version is separate from the start page for a site.
The start page for a site is where the visitor is directed when they go to the site's main URL.
To configure your site's start page, see xref:playbook:site-start-page.adoc[].

== Default start page

By default, Antora looks for a xref:page:start-page.adoc[page named _index.adoc_] in the ROOT module of a component version and uses it as the component version's start page (e.g., _\https://site-url.org/component-name/version/index.html_).
If Antora doesn't find this page, visitors are directed to a 404 page every time they click on the component version from the xref:navigation:index.adoc#component-dropdown[component version selector] or xref:navigation:index.adoc#component-menu[page menu].

If you set the <<start-page-key,start_page key>> in the component version's [.path]_antora.yml_, Antora will use that page as the start page instead of the [.path]_index.adoc_ page in the ROOT module.
You only have the set the `start_page` key if you want to use an alternate page than the default as the start page.

[#start-page-key]
== start_page key

The `start_page` key must be set in [.path]_antora.yml_ when:

. a component version doesn't have a page named [.path]_index.adoc_ in its ROOT module, or
. when Antora should use an alternate page (that is, not [.path]_index.adoc_, even if it exists) as the component version's start page.

The `start_page` key accepts the xref:page:resource-id.adoc[resource ID of a page] that *belongs to the component version the [.path]_antora.yml_ file describes*.
The resource ID must start from the xref:page:resource-id-coordinates.adoc#id-module[module coordinate] (though the ROOT module is implied if not present).

.antora.yml
[#ex-start,yaml]
----
name: colorado
title: Colorado ∆
version: '5.6'
start_page: get-started:overview.adoc
----

In <<ex-start>>, the component version's start page, `overview.adoc`, is located in the module `get-started`.

If the start page is located in the ROOT module, the module coordinate can be dropped.

.antora.yml
[#ex-start-root,yaml]
----
name: colorado
title: Colorado ∆
version: '5.6'
start_page: overview.adoc
----

In <<ex-start-root>>, the component version's start page, `overview.adoc`, is found in the ROOT module.

// /docs/modules/ROOT/pages/component-navigation.adoc
[[component-navigation.adoc]]
= Assign Navigation Files to a Component Version

On this page, you'll learn:

* [x] How to register navigation files with the `nav` key in [.path]_antora.yml_.
* [x] How registration order affects the component version's page menu.

[#nav-key]
== nav key

The `nav` key is optional.
It's set in a component version's [.path]_antora.yml_ file and accepts a list of xref:navigation:files-and-lists.adoc[navigation files].
Each value specifies the path to a navigation file (e.g., [.path]_modules/module-directory/nav-file.adoc_) relative to [.path]_antora.yml_.

.antora.yml that registers two navigation files
[,yaml]
----
name: colorado
title: Colorado ∆
version: '5.6'
nav: # <.>
- modules/get-started/nav.adoc # <.>
- modules/ROOT/nav.adoc # <.>
----
<.> The `nav` key must be entered on its own line and be directly followed by a colon (`:`).
<.> Value registering a navigation file located in the [.path]_get-started_ module directory.
<.> Value registering a navigation file located in the [.path]_ROOT_ module directory.

Each value listed under `nav` must be structured as follows:

* Don't indent the values.
* Enter each value on its own line.
* Start each value with a hyphen (`-`), followed by a blank space.
* After the blank space, enter the path to an individual navigation file relative to the location of the [.path]_antora.yml_ file.

A navigation file is [.term]*registered* when it's assigned to the `nav` key.
Only the contents of registered navigation files are assembled into and published as the component version's page menu.
The order of the values dictates the order the contents of the navigation files are displayed in the xref:navigation:index.adoc#component-menu[component version's page menu] on your site.

== Learn more

* xref:navigation:index.adoc[]
* xref:navigation:files-and-lists.adoc[]
* xref:navigation:organize-files.adoc[]
* xref:navigation:register-navigation-files.adoc[]

// /docs/modules/ROOT/pages/version-facets.adoc
[[version-facets.adoc]]
= Version Facets

[#actual]
== Actual version

The [.term]*actual version* is an identifier, that when combined with a component name, creates a unique identity for a collection of content and source files that are directly related to one another.
This collection of source files is a xref:component-version.adoc[component version].
A component version always has an actual version.
Even an xref:component-with-no-version.adoc[unversioned component version] has an actual version, defined as an empty string, for internal sorting and routing purposes.

A component version's actual version is assigned to the xref:component-version-key.adoc[version key] in its component version descriptor (_antora.yml_).
Alternatively, the actual version is extracted by Antora from a git refname based on the pattern assigned to the `version` key in [.path]_antora.yml_ or on a content source in a playbook.

Content writers use the actual version to reference pages and assets in other component versions.
Antora uses the actual version:

* to sort component versions
* to identify the latest version of a component
* to apply routing rules
* for display purposes in the UI, except when the component version is unversioned
* as the version segment in the published URLs, except when the component version is unversioned

Each version facet--prerelease, display, and symbolic--described in the following sections, overrides a default behavior where Antora would otherwise use the actual version.

[#prerelease]
== Prerelease version

A version of a project or product that is made available before its final release is often called a [.term]*prerelease version*.
Organizations use semantic versioning identifiers, such as `-alpha.1`, or special names, such as `M1` or `Snapshot`, to communicate that a version is a prerelease to end users.
To compliment a prerelease version of a project, a component version can be designated as a prerelease using the `prerelease` key.

A component version is designated as a prerelease when the `prerelease` key is assigned an xref:component-prerelease.adoc#identifier[identifier] or the reserved value xref:component-prerelease.adoc#true[true] in its [.path]_antora.yml_ file.
Using the `prerelease` key has the following benefits:

* While the component version is a prerelease, Antora won't route incoming page and resource ID references from other component versions to the prerelease version if the version coordinate wasn't specified or can't be determined.
Instead, Antora routes such references to the latest stable version of the component.
* The `prerelease` key allows the actual version (`version`) of the component version to represent the stable version from the inception of the component version.
In other words, the prerelease does not change the actual version.
It only modifies its meaning so Antora doesn't classify it as a stable version.
Therefore, the published URLs of the component version and inbound references from other component versions that specifically target the component version aren't affected when the component version graduates from a prerelease to a stable release.
* Unless the `display_version` key is assigned a value or `prerelease` is assigned `true`, the prerelease identifier is appended to the actual version and displayed in the UI menus, showing end users that the component version is a prerelease.
** If the component version is unversioned, only the prerelease identifier is displayed in the UI menus.

[#display]
== Display version

An actual version can't contain spaces, uppercase letters, or certain characters that cause processing or portability errors.
However, the actual version, when displayed in the UI menus, may not provide the appropriate experience if end users are expecting the version to be displayed with spaces, uppercase letters, or other symbols.
In these circumstances, a display version should be assigned to a component version.

A [.term]*display version* is an identifier that is only used for presentation purposes in the UI menus.
Unlike the actual version, the display version can contain spaces, uppercase letters, and other symbols or characters.
The display version is specified using the xref:component-display-version.adoc[display_version key] in a component version's [.path]_antora.yml_ file.
The display version is used by the UI where the version is displayed, including the xref:navigation:index.adoc#component-dropdown[component version selector] and xref:navigation:index.adoc#page-dropdown[page version selector].
The display version is never used in page or resource IDs, for component version routing and sorting, or in the version segment of URLs.

[#symbolic]
== Symbolic version and symbolic prerelease version

A [.term]*symbolic version* or [.term]*symbolic prerelease version* is a value that replaces the actual version in the version segment of a URL.
The symbolic version or prerelease version are only applied to the URLs of the xref:ROOT:how-component-versions-are-sorted.adoc[latest component version or latest prerelease], respectively.
The symbolic version or prerelease version never applies to unversioned component versions.
Because the symbolic version and symbolic prerelease version apply to all of the latest component versions or prerelease versions in a site, these values are assigned in your playbook, not in an individual component version's [.path]_antora.yml_ file.
The symbolic version is assigned to the xref:playbook:urls-latest-version-segment.adoc[latest_version_segment key] in the playbook.
The symbolic prerelease version is assigned to the xref:playbook:urls-latest-prerelease-version-segment.adoc[latest_prerelease_version_segment key] in the playbook.

== Summary of version facets

[%header,cols="h,1,2,2,1"]
|===
|Facet
|Page and resource IDs
|Sorting order and routing
|Menus in reference UI
|Version segment in URLs

|<<actual,Actual>>
|Yes
|Yes
|Yes

_Exceptions:_

If a value is assigned to `display_version`, the display version is shown instead of the actual version.

If `prerelease` is assigned an identifier and `display_version` isn't set, Antora automatically computes a value for `display_version` by appending the identifier to the actual version.
This computed value is shown instead of the actual version.

If the component version is unversioned, the actual version is never shown.
Instead, the display version, prerelease identifier, or fallback _default_ label is shown depending on the version facets specified in its [.path]_antora.yml_ file.
|Yes

_Exceptions:_

If the component version is unversioned, the page and asset URLs don't contain a version segment.

If a value is assigned to `latest_version_segment`, the actual version is replaced by the symbolic version.
This behavior only applies to the URLs of the latest component versions that aren't unversioned or marked as prereleases.

|<<prerelease,Prerelease>>
|No
|Yes
|Yes

_Exceptions:_

If a value is assigned to `display_version`, the display version is shown instead of the computed prerelease version or fallback value.

If `prerelease` is assigned `true` and `display_version` isn't set, the actual version or, if the component version is unversioned, the fallback label _default_ is displayed.

|No

_Exception:_

If a value is assigned to `latest_prerelease_version_segment`, the actual version is replaced by the symbolic prerelease version.
This behavior only applies to the URLs of the latest prerelease version of a component that isn't defined as unversioned.

|<<display,Display>>
|No
|No
|Yes
|No

|<<symbolic,Symbolic>>
|No
|No
|No
|Only applies to the latest version of a component; doesn't apply to unversioned component versions.

|<<symbolic,Symbolic prerelease>>
|No
|No
|No
|Only applies to the latest prerelease version of a component; doesn't apply to unversioned component versions that are marked as prereleases.
|===

// /docs/modules/ROOT/pages/how-component-versions-are-sorted.adoc
[[how-component-versions-are-sorted.adoc]]
= How Component Versions are Sorted

On this page, you'll learn:

* [x] How Antora sorts components and component versions.
* [x] How Antora selects the latest version of a component.

Understanding how Antora sorts xref:component-version.adoc[component versions] is important when choosing your versioning scheme and its potential presentation and routing results in your site's UI.

[#sort-docs-components]
== Docs component sort order

Antora groups component versions into xref:component-version.adoc#docs-component[documentation components].
The sort order of components in the content catalog is not deterministic.
However, when the docs components are accessed through the UI model (`site.components`), they are sorted in alphabetical order by title.
The title of a component is defined by the xref:component-title.adoc[title key] defined in each component version's [.path]_antora.yml_ file.
If the `title` key isn't set, Antora falls back to the xref:component-name-key.adoc[name key] when sorting the component.
In each component, the versions are sorted according to the <<version-sorting-rules,component version sorting rules>>.

This sorted list of components is typically used by the UI to present a menu widget that the reader can use to navigate between different components and versions.
Antora's default UI provides such a widget.
In the default UI, the list of versions for a given component is shown beneath each component's title.

Antora does not require that components and versions be displayed in this order.
If you want them to be shown in a different order, you need to customize the UI template that generates this list.
When customizing Antora's default UI, you would need to edit the partial named `nav-explore` located at [.path]_src/partials/nav-explore.hbs_ in the UI project.
The key fragment of that template is the iteration over `site.components`:

[,hbs]
----
{{#each site.components}}
...
{{/each}}
----

Antora's default UI uses the order in which components are stored in the UI model.
You can modify this order by passing the list of components to a custom helper function that you must also provide:

[,hbs]
----
{{#each (rearrange site.components 'component-b,component-a'}}
...
{{/each}}
----

You also have the choice of manually creating a menu entry for each component you want displayed.
This strategy would also allow you to exclude certain components.

[#version-schemes]
== Versioning schemes

Antora only considers the value of the `version` key when sorting the component versions of a docs component.
The xref:component-version-key.adoc[value assigned to the version key] determines what versioning scheme, and therefore what order, a component version is placed in under its component title or name in the xref:navigation:index.adoc#component-dropdown[component version selector menu].
The reserved values `~` and `null` define a xref:component-with-no-version.adoc[component version as unversioned].

[cols="1,4,1"]
|===
|Scheme |Valid Identifiers |Example

|Semantic
a|[%hardbreaks]
Integer
String that starts with a number and contains at least one dot (`.`) character
String that starts with `v`, followed by a number, and contains at least one dot (`.`) character
a|[%hardbreaks]
`30`
`2.4`
`v90.3`

|Named
|All values that don't match the semantic scheme or the reserved version values (`~`, `null`)
a|[%hardbreaks]
`edge`
`z4`

|Unversioned
|`~` +
`null`
|`~`
|===

[#version-sorting-rules]
== Component version sorting rules

Antora applies the following rules when sorting the component versions of a component:

. An unversioned component version is displayed in the component version selector menu before named versions if both are present.
. Named versions of a component are displayed in the component version selector menu before semantic versions if both are present.
. Named versions of a component are sorted in reverse alphabetical order (e.g., `z4`, `wish`, `lester`).
.. Version identifiers with uppercase letters aren't recommended in URLs and can prevent portability between web servers.
If you use uppercase letters, they come before lowercase letters (e.g., `A`, `a`).
. Semantic versions of a component are displayed in the component version selector menu after named versions if both are present.
. Semantic versions of a component are sorted in descending order
.. The leading `v` in a semantic identifier is ignored and versions are sorted according to the first number after the `v`.
.. The https://semver.org[semantic versioning ordering rules] are applied.

[#determine-version-order]
=== Determine the version order of a component

Let's assume that the component _RoseyDB_ contains several component versions.
Some versions use the semantic scheme: `v2.5`, `4.0`, and `3.9`.
Some are named: `utopia` and `vivid`.
According to Antora's sorting rules, the _RoseyDB_ component versions will be displayed in the reference UI in the order listed below.

.Sorted RoseyDB component versions
....
vivid
utopia
4.0
3.9
v2.5
....

Bear in mind that if the xref:component-display-version.adoc[display_version key] is defined in a component version's [.path]_antora.yml_ file, the value of `display_version` is shown instead of the `version` key's value.
Regardless of whether or not `display_version` is set, the component version is *always sorted according to the value assigned to its `version` key*.
Thus, to the reader's eyes, the versions may not appear to be sorted in the order described.

For instance, if the `utopia` version of _RoseyDB_ is assigned a `display_version` value of `3.0`, the _RoseyDB_ versions will still be sorted in the same order.
The `utopia` version is just labeled as `3.0` in the reference UI.

....
vivid
3.0
4.0
3.9
v2.5
....

Antora also determines the <<latest-version,latest component version>> of each component.
The latest version for _RoseyDB_ would be `vivid` because it's the first version in the sorted list and not defined as a prerelease.

[#latest-version]
== Latest component version

In addition to sorting the component versions, Antora identifies the most recent, stable component version of each component.
The [.term]*latest component version*, also called the [.term]*latest version*, is the first version in the sorted list that's not a xref:component-prerelease.adoc[prerelease].
If all versions are prereleases, then the first prerelease version in the list is selected.
An xref:component-with-no-version.adoc[unversioned component version] is always considered the latest version or latest prerelease version (if `prerelease` is set).

Antora uses the latest version of a component when qualifying an incoming resource ID reference from another component if the version coordinate wasn't specified or can't otherwise be determined.

TIP: The latest version is available as the property `latest` in the xref:antora-ui-default::templates.adoc#site[UI model].

// /docs/modules/ROOT/pages/distributed-component-version.adoc
[[distributed-component-version.adoc]]
= Distributed Component Versions

While all of a component version's source files are often stored in a single repository, it isn't a requirement.
Antora can collect source files that belong to the same component version from multiple repositories.

== What's a distributed component version?

When a component version's source files are stored in multiple content roots (i.e., multiple repositories, multiple start pages, etc), it's referred to as a [.term]*distributed component version*.
// or, simply, a *distributed component*.

A common use case of a distributed component version is when most of its source files are stored in one repository, but a number of examples ([.path]_examples_ family directory) and tutorials ([.path]_pages_ family directory) are stored in another repository managed by a training team.
Antora has no problem combining the source files from both storage locations into a single component version.
This capability is provided by the simple, but-oh-so-powerful component version descriptor file, [.path]_antora.yml_.

== Managing antora.yml files and keys

Recall that an [.path]_antora.yml_ file specifies the component name and version of a component version.
If Antora discovers two or more [.path]_antora.yml_ files that specify an identical component name and version, it considers all of the files in the subsequent standard directory sets to belong to the same component version, even though the source files were collected from multiple locations.

When the source files of a component version are distributed, only one of the [.path]_antora.yml_ files should specify the optional configuration keys, such as `title` and `nav`, in addition to the required component `name` and `version`.
All of the other [.path]_antora.yml_ files that mark the locations of the component version's source files must only specify the component `name` and `version`.
Conflicting or duplicate optional configuration keys may produce unpredictable results.

== Conflicting files

When setting up a distributed component version, each content source root must contribute a unique set of files (aside from [.path]_antora.yml_).
In other words, the content source roots cannot overlap when combined.

Antora will fail with an error if it finds two or more source files with same resource ID.
These are identical filenames that belong to the same family and module in the distributed component version.
This also occurs if Antora discovers a module that has two or more navigation files with identical filenames.
See xref:page:resource-id.adoc#duplicate-resources[Duplicate resources] for more information about this situation.

//== Playbook content source order

// /docs/modules/page/pages/resource-id-coordinates.adoc
[[resource-id-coordinates.adoc]]
= Resource ID Coordinates

[#id-coordinates]
== Coordinate syntax and order

A xref:resource-id.adoc#whats-a-resource-id[resource ID] contains five coordinates: version, component, module, family, and file.
Antora constructs a resource ID for a source file by assigning values to these coordinates based on the file, xref:ROOT:standard-directories.adoc[standard directory set], and information in the xref:ROOT:component-version-descriptor.adoc[component version descriptor].
You can reference a resource from any other resource--regardless of the component version each resource belongs to--using a sequence of the resource ID coordinates assigned to a resource.

<<fig-full-id>> shows the coordinate types and their sequence in a fully qualified resource ID.

.Fully qualified resource ID
[#fig-full-id]
image::full-resource-id.svg[Diagram of a fully qualified Antora resource ID]

[[full-id]]A [.term]*fully qualified resource ID* is a resource ID with all of its coordinates specified.
You probably won't have to use a resource's fully qualified resource ID that often.
The number of resource ID coordinates you specify when referencing a resource depends on:

* the component version and module of the current page in relation to the target resource,
* the family of the target resource, and
* the AsciiDoc syntax used to reference the target resource.

[[target]]The [.term]*target resource* is the resource source file that's referenced, by specifying its resource ID, in an AsciiDoc macro, include directive, or other syntax.
[[current]]The [.term]*current page* is the page file that contains the AsciiDoc syntax that references the target resource.

.The current page, with the filename satellites.adoc, containing an xref macro referencing a resource
[#fig-target]
image::target-resource.svg[Example of an xref in the current page referencing a target resource]

In <<fig-target>>, [.path]_satellites.adoc_ is the current page and the resource with the filename _modes.adoc_ is the target resource being referenced by the xref macro.
The following sections describe how to determine the value of each coordinate for a target resource and when to use each coordinate.

[#id-version]
== Version coordinate

The version coordinate is the same value as the version of the component to which the <<target,target resource>> belongs.
The value of the version is assigned to the xref:ROOT:component-version-key.adoc[version key].
The `version` key is specified either in the [.path]_antora.yml_ file that defines the resource's component version or on the content source in your playbook that specified from where Antora collected the component version's files.

The version coordinate should be used to reference a resource in a different version of the same component or a specific version of a different component.
When entering a version coordinate in a resource ID, it should always be the first coordinate and end with an at sign (`@`).
If the component coordinate is not specified, the current component will be used.
If the component coordinate is specified without specifying a version coordinate, the latest version of that component will be choosen.

[#id-component]
== Component coordinate

The component coordinate is the name of the component to which the target resource belongs.
The component name is specified by the xref:ROOT:component-name-key.adoc[name key] in the [.path]_antora.yml_ file that defines the resource's component version.

The component coordinate must be used when the target resource and current page belong to different documentation components.
The component name is entered before the module coordinate in a resource ID and is directly followed by one colon (`:`).
If the component coordinate is specified without specifying a version coordinate, the latest version of that component will be choosen.

[#id-module]
== Module coordinate

The module coordinate is the name of the module to which the target resource belongs.
The module name is derived from the xref:ROOT:module-directories.adoc#module[module directory] where the resource is stored.

The module coordinate must be used when the target resource and current page belong to different modules.
The module name is entered before the family coordinate, if the family coordinate is present, or before the file coordinate if the family coordinate isn't present.
The module name is directly followed by one colon (`:`).

When a module coordinate ends with the name of a built-in AsciiDoc macro, such as `link`, `kbd`, `menu`, etc., you may have to escape that portion of the coordinate by prefixing the macro name with a backslash.
For example, module coordinates such as `monolink` and `redmenu` may need to be entered as `mono\link` and `red\menu` in a resource ID.

[#id-family]
== Family coordinate

The family coordinate identifies the name of the family to which the target resource belongs.
The family is derived from the xref:ROOT:family-directories.adoc[family directory] where the resource is stored.
Remove the "`s`" at the end of the family's name and replace it with a dollar sign (`$`) when constructing a resource ID.
The valid family coordinates are `page$`, `image$`, `partial$`, `example$`, and `attachment$`.

Whether the family coordinate needs to be entered in a resource ID depends on:

* the family of the target resource, and
* the AsciiDoc syntax used to reference the target resource.

For example, if you reference a page using the xref macro, the `page$` family coordinate isn't required because the xref macro applies it by default when no family coordinate is specified.
The following table lists when the family coordinate is required depending on the resource being referenced and the syntax that is referencing the resource.

[#reference-syntax-id-requirements]
[cols="2,2,4"]
|===
|Resource being referenced |Syntax referencing the resource |Family coordinate required?

|xref:attachments.adoc[Attachment]
|Xref macro
|*Yes, the `attachment$` coordinate is required*.
See xref:attachments.adoc[].

|xref:examples.adoc[Example]
|Include directive
|*Yes, the `example$` coordinate is required*.
See xref:include-an-example.adoc[].

.3+|xref:images.adoc[Image]
|Block image macro
|No, the family coordinate isn't required.
See xref:block-images.adoc[] and xref:image-resource-id-examples.adoc[].

|Inline image macro
|No, the family coordinate isn't required.
See xref:inline-images.adoc[] and xref:image-resource-id-examples.adoc[].

|Xref macro
|*Yes, the `image$` coordinate is required*.

.2+|xref:index.adoc[Page]
|Xref macro
|No, the family coordinate isn't required.
See xref:xref.adoc[].

|Include directive
|No, the family coordinate isn't required.
See xref:include-a-page.adoc[].

|xref:partials.adoc[Partial]
|Include directive
|*Yes, the `partial$` coordinate is required*.
See xref:include-a-partial.adoc[].
|===

[#id-resource]
== File coordinate

The file coordinate specifies the path, relative to the xref:ROOT:family-directories.adoc[family directory], of the target resource's source file.
The file coordinate must specify the resource's file extension except when:

* the target resource doesn't have a file extension, such as _Dockerfile_, *and*
* the target resource is a xref:partials.adoc[partial] or xref:examples.adoc[example].

The file coordinate for a resource stored at the root of a family directory is the name of the resource's source file and its file extension.

.Resource stored at root of family directory
[listing#ex-family]
----
📂 modules
  📂 admin
    📂 pages <.>
      📄 modes.adoc <.>
----
<.> [.path]_pages_ family directory
<.> Page stored at the root of the [.path]_pages_ directory

For example, the file coordinate for [.path]_modes.adoc_, shown in <<ex-family>>, is `modes.adoc` because it's stored at the root of the [.path]_pages_ family directory.

If the target resource is located in a subdirectory of a family directory, the file coordinate must specify the family-relative directory path to the target resource.

.Resource stored in subdirectory of family directory
[listing#ex-sub]
----
📂 modules
  📂 admin
    📂 pages
      📄 modes.adoc <.>
      📂 fields <.>
        📂 level <.>
          📄 routes.adoc <.>
          📄 terrain.adoc <.>
----
<.> Page stored at the root of the [.path]_pages_ directory
<.> Subdirectory in the [.path]_pages_ directory
<.> Subdirectory in the [.path]_fields_ subdirectory
<.> Page stored in [.path]_level_ subdirectory
<.> Page stored in [.path]_level_ subdirectory

The page [.path]_terrain.adoc_, shown in <<ex-sub>>, is stored in the [.path]_level_ subdirectory.
The file coordinate for [.path]_terrain.adoc_ is `fields/level/terrain.adoc`.
If [.path]_modes.adoc_ (current page) references [.path]_terrain.adoc_ (target resource), the file coordinate specified in the target resource's resource ID is `fields/level/terrain.adoc`.
If [.path]_terrain.adoc_ (current page) references [.path]_modes.adoc_ (target resource), the file coordinate specified in the target resource's resource ID is `modes.adoc`.
*Remember, the file coordinate of the target resource is always calculated from the family directory.*

When the target resource and current page are both located in the same subdirectory of a family directory, the relative path token, `./`, can be used to abbreviate the family-relative directory path of the target resource's file coordinate.

.Resources stored in the same subdirectory
[listing#ex-token]
----
📂 modules
  📂 admin
    📂 pages
      📂 fields
        📂 level
          📄 routes.adoc <.>
          📄 terrain.adoc <.>
----
<.> Page stored in [.path]_level_ subdirectory
<.> Page stored in [.path]_level_ subdirectory

The pages [.path]_routes.adoc_ and [.path]_terrain.adoc_, shown in <<ex-token>>, are both stored in the [.path]_level_ subdirectory.
If [.path]_routes.adoc_ (current page) references [.path]_terrain.adoc_ (target resource), the file coordinate specified in the target resource's resource ID can be specified as `./terrain.adoc` instead of `fields/level/terrain.adoc`.

// /docs/modules/page/pages/standard-page.adoc
[[standard-page.adoc]]
= Set Up a Standard Page
:page-aliases: create-standard-page.adoc
:listing-caption!:

A standard page has two parts, a header and a body.

[#page-header]
== Page header

The page header is a set of contiguous lines that start on the first line of the file.
The header encapsulates the following elements:

* A required xref:title-and-metadata.adoc[page title]
* Optional xref:title-and-metadata.adoc[metadata attributes], such as a page description and author information
* Optional xref:attributes.adoc[built-in attributes], like `xrefstyle` and `page-aliases`
* Optional xref:attributes.adoc[custom attributes] where the attribute name and value are defined by you

.Common elements in a page header
----
= Page Title <.>
:description: A description of the page stored in an HTML meta tag. <.>
:sectanchors: <.>
:url-repo: https://my-git-repo.com <.>
:page-tags: name of a tag, name of a tag <.>
----
<.> Required page title entered on the first line of the file
<.> Optional built-in `description` metadata attribute
<.> Optional built-in AsciiDoc attribute
<.> Optional custom AsciiDoc attribute
<.> Optional custom Antora `page-` attribute

The page title must be defined using an Atx-style (single line) document title that begins with a single equals sign.
Antora does not recognize the legacy Setext-style (two line) document title syntax once supported by AsciiDoc.
If you use the Setext-style syntax, xrefs in the page will not be resolved and other features of AsciiDoc will not be available.

The attribute entries, whether built-in or custom, must each be entered on its own line.
The header can also contain xref:asciidoc:comments.adoc[comment lines].

The page header ends by entering one or more blank lines.

== Page body

The page header is separated from the page body by at least one blank line.
The next line that contains content initiates the body of the page.

----
= Page Title
:description: A description of the page stored in an HTML meta tag.
:sectanchors:
:url-repo: https://my-git-repo.com
:page-tags: name of a tag, name of a tag
<.>
This is the first line of the page body. <.>

== Section heading

This is a paragraph in a section.
----
<.> A blank line ends the page header.
<.> After the blank line, the next line with content starts the body or the page.

The first line of the page body can be any valid AsciiDoc content, such as a section heading, paragraph, table, include directive, image, etc.

== Page filename

A page is stored in a [.path]_pages_ family directory.
The page's filename is used to compute its URL.
If the filename begins with a dot (.) or ends without a file extension, xref:ROOT:standard-directories.adoc#hidden-files[Antora will ignore it].
If the filename starts with an underscore (`+_+`), it will be added to the content catalog, but xref:ROOT:standard-directories.adoc#hidden-files[Antora won't publish it].

== Create a new standard page

. Open a new file in your preferred IDE or plain text editor.

. On the first line of the file, enter a page title.
A page title is specified by one equals sign (`=`), followed by one blank space, and then the text of the title.
+
----
= The Title of My New Page
----

. *The page title is the only required header element.*
Separate the header block from the body block by one blank line.
Write your content.
+
----
= The Title of My New Page

Welcome to my new page!
----

. Save the file with the extension `.adoc` in a [.path]_pages_ directory.
The name you use when saving the file will be used to compute the page's URL.

You've created a standard page!
When you run Antora, it will be converted to an HTML page and published to your site automatically.

The page created in this example is simple.
Using AsciiDoc, a page's header can encompass a wide range of capabilities and its body can handle complex content.

[IMPORTANT]
.Key Points to Remember
====
A page:

* is stored in the [.path]_pages_ directory of a module
* has the _.adoc_ file extension
* has a filename that only contains URL-compliant characters
* has a filename that's all lowercase (optional, but recommended)
* has a filename that does not contain spaces (optional, but recommended)
* has a title (i.e., document title)
* is marked up using valid AsciiDoc syntax

Using spaces in the filename is not recommended.
Spaces have to be encoded in a URL and this can lead to URLs which look unfamiliar to visitors.
It's best to avoid spaces (and only use lowercase letters) when choosing a filename for a page.
====

//If you want a site visitor to locate this page via a component navigation menu, you'll need to add a link to the page (`xref`) to a xref:navigation:index.adoc[navigation file].

// /docs/modules/page/pages/title-and-metadata.adoc
[[title-and-metadata.adoc]]
= Add a Title and Metadata
:page-aliases: asciidoc:page-header.adoc
// URLs
:url-author: {url-asciidoc}/document/author-information/

On this page, you'll learn:

* [x] How to add a page title.
* [x] How to add metadata to a page.
//* [x] How to structure a valid page header.

[#page-title]
== Page title

A page title is specified by one equals sign (`=`), followed by one blank space, and then the text of the title.

----
= Title of This Page
----

Every page should have a page title.
Without a page title, the page lacks a critical part of its identity and certain features in Antora will not work.
If you don't want to display the page title on a certain page, you can add conditional logic in the UI template to hide it.

The page title may contain basic text formatting.
For example:

----
= A _Formatted_ Page Title
----

TIP: If you want the text formatting to be present in the page title, but not in the navigation or other cross references to the page, you can set the xref:reftext-and-navtitle.adoc[navtitle and reftext attributes] on the document, respectively.

The page title **must not** contain resource references, such as an xref or an image.
Unlike other content in the page, the page title is parsed and converted outside the context of a page, so those references do not get rewritten when the page title is rendered.
Furthermore, the page title is used in other contexts (such as the navigation) where the resource references are either not appropriate or not resolvable.
Therefore, these references **are not** permitted.

== Page description and keywords

If set, `description` is output to an HTML `<meta>` tag with the same name.
You can break long values across several lines by ending each line with a backslash `\` that is preceded by a space.

.Description attribute syntax
----
= Page Title
:description: A description of the page stored in an HTML meta tag. This page is \
about all kinds of interesting things.
----

The keywords attribute contains a list of comma-separated values that are assigned to an HTML `<meta>` tag with the same name.

.Keywords attribute syntax
----
= Page Title
:keywords: comma-separated values, stored, in an HTML, meta, tag
----

== Page author

Specifying the author or authors of a page is optional.
The author is listed on the line directly beneath the page’s title.
An optional email address or contact URL can follow an author’s name inside a set of angle brackets (`< >`).
When a page has multiple authors, each author is separated by a semicolon (`;`).

.Multiple authors and author information syntax
----
= Page Title
First Middle Last <author@email.com>; First Last <author@email.com>
----

Author names are output to the HTML `<meta>` tag.
Whether any author information is also displayed on a published page depends on the site's UI templates.

Refer to the AsciiDoc documentation for {url-author}[additional author attributes^] and methods for specifying author information.

////
----
= The Title of My New Page
:attribute-a: value-a

Welcome to my new page!

== This is a section title

This is a paragraph.
----
////

// /docs/modules/page/pages/attributes.adoc
[[attributes.adoc]]
= AsciiDoc Attributes in Antora
:url-attribute-catalog: {url-asciidoc}/attributes/document-attributes-reference/

Like the AsciiDoc processor, Antora uses AsciiDoc document attributes (herein [.term]*attributes*) to circulate information in and out of pages.
These attributes are used to toggle or configure processing settings, control behavior and styles of the output, pass metadata from the source to the UI templates, and pass down information about the page to the content, among a variety of other uses.

In general, there are two kinds of attributes: built-in and custom.
Attributes can also be divided into those that are page attributes and those that are not.
This page introduces these attribute categories and refers you to additional pages to learn about how they're defined and used.

== Built-in attributes

[.term]*Built-in attributes* are AsciiDoc document attributes that either pass information to the page or provide a way for the author to toggle or configure behavior.
Some built-in attributes are read-only, while others are meant to be modified.

Built-in attributes have reserved names and serve a special, predefined purpose.
For example, the `idseparator` attribute is used to control the word separator for auto-generated section IDs.
Although the purpose of a built-in attribute is restricted, like all AsciiDoc attributes, its value can be displayed on the page using an attribute reference (e.g., `+{idseparator}+`).

Many modifiable built-in attributes have a restricted set of acceptable values.
Each value represents either a predefined behavior or a boundary condition.
For example, the `xrefstyle` attribute controls the style of the linked text of internal xrefs using the predefined values basic, short, or full.
The `max-include-depth` attribute specifies how deep includes can be nested.

The AsciiDoc processor defines {url-attribute-catalog}[numerous built-in attributes^].
Antora introduces xref:intrinsic-attributes.adoc[additional built-in attributes] that are specific to the Antora environment.
The purpose of these attributes is to configure the AsciiDoc processor to work with Antora.
In most cases, these attributes are prefixed with `page-`, which makes them intrinsic <<page-attributes,page attributes>>.

Refer to xref:intrinsic-attributes.adoc[Intrinsic attributes] for a list of the read-only attributes defined by Antora.
Refer to the {url-attribute-catalog}[AsciiDoc Document Attributes Reference^] for a list of all built-in attributes defined in AsciiDoc (though keep in mind that not all of them are relevant in the Antora environment).

== Custom attributes

[.term]*Custom attributes* are AsciiDoc document attributes defined by the author.
You may be familiar with using custom attributes in AsciiDoc to store reusable content, such as a URL or product name.
The value of a custom attribute can then be used within the page (or across pages, depending on where it's defined) using an attribute reference.
Custom attributes work the same way in Antora.

See xref:define-and-modify-attributes.adoc#custom-attribute[Define a custom AsciiDoc attribute] and xref:page-attributes.adoc#custom-attribute[Define a custom page attribute] to learn how to define your own custom attributes.

== Page attributes

Where things get interesting is when the name of the attribute starts with `page-`.
With this special designation, the attribute becomes a page attribute.

To the AsciiDoc document, page attributes are just like any other AsciiDoc attribute.
For example, you can refer to the component for the current page using built-in page attribute `+{page-version}+`.
Or you can define your own page attribute named `page-edition` and refer to it in the page using `+{page-edition}+`.
In this context, the `page-` prefix is not significant.

Where this special designation comes into play is when the UI template is applied to the page's contents.
Page attributes get promoted to the page's UI model so they can be accessed using the expression `page.attributes.<name>` within a xref:antora-ui-default::templates.adoc#template-variables[UI template] (e.g., _layouts/default.hbs_).
In effect, a page attribute allows the author to pass metadata defined using attributes either in the page's header or in a configuration file (e.g., the Antora playbook), thus allowing that information to be used outside of the AsciiDoc document.
It's even possible to access page attributes from pages other than the current page in the UI template.
Attributes that are not prefixed with `page-` are not accessible in this way (though it's still possible to access all attributes using a UI helper).

While page attributes are primarily custom attributes, Antora defines a handful of built-in page attributes to control Antora-specific features or get information about the current page.
See xref:page-attributes.adoc[] to learn more about page attributes, and how to define and use them.

// /docs/modules/page/pages/define-and-modify-attributes.adoc
[[define-and-modify-attributes.adoc]]
= Define and Modify Attributes

With the exception of certain intrinsic attributes, which are read-only, any AsciiDoc document attribute (herein [.term]*attributes*) may be defined from the CLI, in the playbook, in the component descriptor, or in the header of a page using an attribute entry.
The precedence matches that order (higher to lower) unless the precedence has been altered for a given attribute using a modifier.
These different scopes give you the ability to define attributes at the level of granularity you need and to be able to override their values for different environments or situations.

This page explains how to define and modify an attribute at the page level using an attribute entry.
Alternately, these attributes can be set at a higher level using the CLI, playbook, or component descriptor.
The result of defining or modifying an attribute is the same (meaning the processor doesn't care how it's defined).

[#attribute-entry]
== What's an attribute entry?

//Before you can use a modifiable built-in attribute or custom attribute, you have to declare it.
An [.term]*attribute entry* is the primary mechanism for defining an attribute for a page and, if applicable, assigning a value to it.
You can think of an attribute entry like a global variable assignment in AsciiDoc.

An attribute entry consists of two parts: a *name* and a *value*.
Each attribute entry must be entered on its own line in a page header.
An attribute entry starts with an opening colon (`:`), directly followed by the attribute's name, and then a closing colon (`:`).
This activates, or [.term]*sets*, the attribute so you can use it in your page.

----
= Page Title
:name-of-an-attribute: <.>
----
<.> The attribute's name is directly preceded with a opening colon (`:`) and directly followed by a closing colon (`:`).

In many cases, you explicitly assign a value to an attribute by entering information after its name in the attribute entry.
The value must be offset from the closing colon (`:`) by at least one space.

----
= Page Title
:name-of-an-attribute: value of the attribute <.>
----
<.> An explicitly assigned value is offset from the closing colon (`:`) by at least one blank space.
At the end of the value, press kbd:[Enter].

[#boolean]
Some built-in AsciiDoc attributes don't require a value to be explicitly assigned in an attribute entry because they're a boolean attribute or have a default value.

----
= Page Title
:name-of-an-attribute: <.>
----
<.> If you don't want to explicitly assign a value to the attribute, press kbd:[Enter] after the closing colon (`:`).

The values of built-in boolean attributes are always blank because their only accepted value is an _empty string_.
Other built-in attributes may have a default value.
If you set a built-in attribute and leave its value blank, Antora assigns the default value (if it has one) to the attribute at processing time.

[#set-attribute]
== Set a built-in attribute

Let's activate the AsciiDoc attribute named `sectanchors`.
The attribute is set by entering its name in an <<attribute-entry,attribute entry>> in the header of the page.

.Set a built-in attribute
----
= Page Title
:sectanchors: <.>
----
<.> The attribute is set in page header by directly preceding its name, `sectanchors`, with an opening colon (`:`) and directly following it with a closing colon (`:`).

When set, `sectanchors` adds an anchor to the left of each xref:asciidoc:section-headings.adoc[section title].
`sectanchors` is a <<boolean,boolean attribute>>, so its value is an _empty string_.

== Assign a value to a built-in attribute

In the next example, let's assign a value to a built-in AsciiDoc attribute.
The attribute `xrefstyle` has three built-in values it can accept, `short`, `full`, and `basic`.

----
= Page Title
:xrefstyle: short <.>
----
<.> Set `xrefstyle` in the page header and assign it the value `short`.
Explicit values must be offset from the closing colon (`:`) by at least one space.

When the `short` value is assigned to `xrefstyle`, any in-page references to blocks with anchors will display the blocks`' label and number, e.g., _Listing 1_, if no link text is specified in the reference.

include::ROOT:partial$dont-use-these-attributes.adoc[]

[#custom-attribute]
== Define a custom attribute

Custom attributes often store frequently used text and URLs.
They're then referenced throughout the page by simply entering their name (instead of repeatedly typing the text or URLs).
Before they can be referenced, custom attributes must have a user-defined name and be assigned a value.

[#naming-rules]
The attribute's name must:

* be at least one character long,
* begin with a word character (A-Z, a-z, 0-9, or _), and
* only contain word characters and hyphens, meaning the name cannot contain a dot (`.`) or a space.

Although uppercase characters are permitted in an attribute name, the name is automatically converted to lowercase before being stored.
A best practice is to only use lowercase letters in the name and avoid starting the name with a number.

Attribute values can:

* be any inline content, and
* contain line breaks, but only if an explicit line continuation (`+`) is used.

In <<ex-custom>>, a custom attribute's name and value are defined using an <<attribute-entry,attribute entry>>.

.Define a custom attribute using an attribute entry
[#ex-custom]
----
= Page Title
:url-repo: https://gitlab.com/antora/demo/docs-site
----

Now, you can reference the attribute wherever needed throughout the page by entering its name inside a set of curly braces (`+{attribute-name}+`).
You can see another example of a custom attribute being used to replace a complex URL in xref:asciidoc:external-urls.adoc#create-custom-attribute[Create an attribute for a URL].

== Unset an attribute

Built-in and custom attributes can be [.term]*unset*, that is, turned off, with a leading or trailing bang symbol (`!`) added to its name in an attribute entry.

----
= Page Title
:!sectanchors:
:table-caption!:
----

Once unset, an attribute's behavior and value are no longer available to the page.

== Precedence rules

Attributes can be xref:playbook:asciidoc-attributes.adoc[scoped to a whole site] by declaring them in a site's playbook file.
You can apply attributes to xref:ROOT:component-attributes.adoc[a single component version] by declaring them in a component descriptor file (i.e., [.path]_antora.yml_).
Attributes which are hard set or hard unset in the playbook or component descriptor take precedence over attributes defined in a page.
This precedence order can be inverted using the xref:playbook:asciidoc-attributes.adoc#precedence-rules[precedence modifier].

xref:intrinsic-attributes.adoc[Intrinsic attributes] can never be modified and are thus considered read-only.

See the precedence rules for xref:playbook:asciidoc-attributes.adoc#precedence-rules[site attributes] and xref:ROOT:component-attributes.adoc#precedence-rules[component version attributes] for more information.

// /docs/modules/page/pages/page-attributes.adoc
[[page-attributes.adoc]]
= Page Attributes

Certain AsciiDoc document attributes provide metadata to the Antora page (for use in the UI template) or control how Antora processes the page.
We refer to these as [.term]*page attributes*.
There are three types of page attributes: custom, predefined, and intrinsic.
This page explains the purpose of each type of page attribute, how they're defined, and how they can be accessed from the UI template using the UI model.

== Purpose and anatomy

Page attributes are all about providing metadata, whether that metadata is for Antora itself, for the UI template, for the user, or for a search index.
By defining page attributes, you can store additional information about the page, which can then be accessed and used throughout the site.

A page attribute is defined just like any other AsciiDoc document attribute, typically using an attribute entry in the document header.
Where a page attribute differs is that the name of the attribute must begin with `page-` (e.g., `page-category`).
The presence of the `page-` prefix allows Antora to identify it as a page attribute.

TIP: If you're wondering whether you need to add the `page-` prefix, ask yourself if you need to access the attribute from the UI template.
If the answer is yes, then you need the prefix.
Otherwise, the prefix is not required.

Here's an example of page that defines two page attributes:

----
= Page Title
:page-category: DevOps
:page-edition: Enterprise

Main content.
----

The `page-` prefix is meant to provide a hint to both Antora and the author as to which attributes comprise the metadata for the page.
By standardizing on the `page-` prefix, Antora is able to isolate page attributes from the numerous built-in and intrinsic attributes in AsciiDoc or defined by the AsciiDoc processor.
The prefix also isolates the page attributes from internal attributes used to store reusable content within the page or site (aka custom content attributes).

[#custom-attribute]
== Define a custom page attribute

To define a page attribute, you add an attribute entry to the page header and start the name with `page-`.
It's important to define the attribute entry in the header.
Otherwise, the page attribute will not be found.

Here's an example of an xref:define-and-modify-attributes.adoc#attribute-entry[attribute entry] that defines a page attribute:

----
= Page Title
:page-name-goes-here: value goes here
----

The name of this page attribute is `name-goes-here` (the `page-` prefix plus the custom name, `name-goes-here`).
Its value is `value goes here`.

The name of the page attribute must adhere to the xref:define-and-modify-attributes.adoc#naming-rules[naming rules] for a document attribute.
The value can be left blank or it can be a string value.
If the value is not blank, it must be offset from the closing colon (`:`) by at least one space.

TIP: Since page attributes are just special AsciiDoc document attributes, they can also be defined xref:playbook:asciidoc-attributes.adoc[site-wide] in the Antora playbook or xref:ROOT:component-attributes.adoc[per component version] in the component version descriptor.

=== Promote a non-page attribute

If you want to make information in an existing document attribute available as a page attribute, you must promote that attribute to a page attribute.
You can promote a document attribute to a page attribute using an attribute reference.

For example, let's say you have the attribute `product-name` defined on the page or site.
You can promote it to a page attribute using the following attribute entry:

----
= Page Title
:product-name: Name of My Product
:page-product-name: {product-name}
----

The attribute reference is resolved immediately, so the page attribute named `page-product-name` now shares the same value as the document attribute named `product-name`.

== Configure a predefined page attribute

Some page attributes receive special treatment in Antora.
These page attributes have reserved names, but accept user-defined values for communicating information about the page to Antora.
Examples include `page-aliases`, `page-layout`, and `page-partial`.

The `page-aliases` attribute allows you to configure alternate resource IDs for the current page.
For example, to claim the old name of a page, you'd use:

----
= Page Title
:page-aliases: old-page-name.adoc
----

Unlike custom page attributes, the `page-aliases` attribute requires the value to conform to a specific syntax (i.e., a comma-separated list of resource IDs).
See xref:page-aliases.adoc[page aliases] to learn about the `page-aliases` attribute and how it can be used to preserve references to a renamed, moved, or deleted page.

The `page-layout` attribute allows you to specify which UI template to apply to the current page.
For example, to apply the `home` layout to the current page, you'd use:

----
= Home Page
:page-layout: home
----

See xref:page-layout.adoc[page layout] to learn about the `page-layout` attribute and how it can be used to define which UI layout is applied to a page.

Additional predefined page attributes may be added in the future to allow similar kinds of functionality to be configured.

[#access-attributes-from-ui-template]
== Access page attributes from the UI template

One of the primary roles of a page attribute is to pass metadata about the page to the UI template via the xref:antora-ui-default::templates.adoc#template-variables[UI model].
The UI template can then use the information provided by the page attributes in a variety of ways, from populating metadata in the published page (i.e, the HTML) to toggling or configuring behavior in the UI.

Let's look at an example.
The default UI allows you do configure the depth of the sidebar TOC using the page attribute named `toclevels` (i.e., `page-toclevels` when defined).

You could set this attribute globally in your playbook (or component descriptor).

[,yaml]
----
asciidoc:
  attributes:
    page-toclevels: 3@
----

The trailing `@` is added so the attribute can still can be overridden in the header of a page.
For example:

[,asciidoc]
----
= Page Title
:page-toclevels: 2
----

Page attributes are accessible in the UI model via the `page.attributes` property.
The value of this property is a map of attributes.

To access the value of the `page-toclevels` attribute in a UI template, you'd use:

[,hbs]
----
{{page.attributes.toclevels}}
----

So where's the `page-` prefix gone?

When a page attribute is promoted to the UI model, the `page-` prefix is dropped from its name.
That's why we often refer to the page attribute using its short name (e.g., `toclevels`).
The `page-` prefix acts as a namespace to identify the attribute as a page attribute.
Thus, a page attribute named `page-toclevels` becomes `toclevels` in the UI model (e.g., `page.attributes.toclevels`).

Let's look at another example that shows how the default UI uses a page attribute to control pagination.
You'll often set this attribute globally in your playbook or component descriptor.
This time, however, we hard set the attribute so it cannot be turned off by a page.

[,yaml]
----
asciidoc:
  attributes:
    page-pagination: ''
----

Now, in the footer-scripts.hbs partial template, we can check whether this attribute is set and include the pagination controls if it is.

[,hbs]
----
{{#unless (eq page.attributes.pagination undefined)}}
<nav class="pagination">
...
</nav>
{{/unless}}
----

Notice we check whether the value is not equal to undefined rather than checking if it truthy.
That's because an empty value in JavaScript is falsy, so we have to make the assertion more specific.
Inside the clause, the template can check whether the attribute has the value next or prev, implying the opposite direction should be turned off.

The `page-` prefix on the attribute name is what hoists it to the UI model.
All other document attributes are still accessible from the UI model, just not as easily.
Here's an example of how to reference a non-page attribute from the UI model:

[,hbs]
----
{{#with (resolvePage page.relativeSrcPath model=false)}}
{{./asciidoc.attributes.policy-number}}
{{/with}}
----

Passing the `page.relativeSrcPath` value to the built-in `resolvePage` helper resolves to the current page.
The `model=false` option instructions the helper to return the virtual file rather than the UI model for the resolved page.
From there, all the AsciiDoc attributes can be access through the nested `asciidoc.attributes` property.

== Intrinsic page attributes
// I have reservations about these examples - SW

Antora automatically sets a number of read-only, intrinsic page attributes at runtime that are derived from existing metadata about the current page.
For example, the name of the current component can be read from the `page-component-name` attribute.

These attributes are defined at the time the page or navigation file is loaded (i.e., parsed)
They are not yet assigned when the attributes in the component descriptor are resolved, and are thus not visible to the component descriptor.

////
One way to use the intrinsic page attributes is to construct references to a page in another product that shares the same version, as shown here:

----
You might also be interested in xref:{page-version}@other-product::index.adoc[other product].
----

Implicit page attributes also come in handy when constructing xref:page-aliases.adoc[page aliases].
////

The intrinsic page attributes are listed on xref:intrinsic-attributes.adoc[].
These attributes are *read-only*, so you should not override their values in the page header.

// /docs/modules/page/pages/intrinsic-attributes.adoc
[[intrinsic-attributes.adoc]]
= Intrinsic Attributes
:page-aliases: page-and-site-attributes.adoc

Antora automatically assigns information about the runtime environment, site configuration, and current page to various document and page attributes.
We refer to these as [.term]*intrinsic attributes*.
Antora uses these attributes to propagate information about the site and current page to the AsciiDoc content, extensions, and UI templates.

Unlike other built-in attributes, such as xref:page-aliases.adoc[page-aliases], intrinsic attributes are meant to be a conduit to pass information from Antora to the page.
Therefore, *intrinsic attributes are intended to be read-only and should not be reassigned*.

These attributes are defined at the time the page or navigation file is loaded (i.e., parsed).
They are not yet assigned when the attributes in the component descriptor are resolved, and are thus not visible to the component descriptor.

[#environment-attributes]
== Intrinsic environment attributes

Intrinsic environment attributes communicate to the document (or document extension) that the document is being processed by Antora.
These attributes are set on every page in the site.

* `env=site`
* `env-site`
* `site-gen=antora`
* `site-gen-antora`

You might use these attributes in an preprocessor conditional to include or exclude content based on whether the document is being process by Antora.
For example:

----
\ifndef::site-gen-antora[]
\include::local-preview-settings.adoc[]
\endif::[]
----

You can define additional environment attributes in the playbook.

[#site-and-configuration-attributes]
== Site and configuration attributes

Antora sets various attributes to configure the AsciiDoc processor.

* `attribute-missing=warn`
* `!data-uri`
* `icons=font`
* `sectanchors`
* `source-highlighter=highlight.js`

These attributes are intended to be reasonable defaults.
Unlike other intrinsic attributes, they *can* be reconfigured using the CLI or playbook.
They can also be redefined in such a way that they can be overridden by the component descriptor or page.

CAUTION: The only syntax highlighter that Antora currently supports for source blocks is highlight.js.
Therefore, it doesn't make sense to change the `source-highlighter` attribute to any other value.
If you'd like to disable syntax highlighting on source blocks, you can disable this attribute.

Antora also passes general site information using attributes.

* `site-title`
* `site-url`

The values of these attributes match the values defined in the playbook.

[#page-attributes]
== Intrinsic page attributes

Antora passes various information about the current page through page attributes.
These attributes are reassigned for each page as well as each xref:navigation:files-and-lists.adoc[navigation file].

[cols="1,2,1"]
|===
|Attribute |Description |Example Output

|`page-component-display-version`
|The xref:ROOT:component-display-version.adoc[display version] of the component version as specified in _antora.yml_.
|7.1 Beta

|`page-component-name`
|The xref:ROOT:component-name-key.adoc[component name] of the component version as specified in _antora.yml_.
|silver-leaf

|`page-component-title`
|The xref:ROOT:component-title.adoc[component title] of the component version as specified in  _antora.yml_.
|Silver Leaf

|`page-component-latest-version`
|The version string of the latest version in the component for the current page.
|7.5

|`page-component-version`
|The xref:ROOT:component-version-key.adoc[version] of the component version as specified in _antora.yml_.
|7.1

|`page-component-version-is-latest`
|Set if the component version for the current page is the latest version in the component for the current page.
|_empty_

|`page-edit-url`
|The URL where the page's source file can be edited.
|\https://gitlab.com/forest-co/silver-leaf/edit/main/modules/ROOT/pages/index.adoc

|`page-module`
|The xref:ROOT:module-directories.adoc#module[name of the page's module].
|ROOT

|`page-origin-branch`
|The name of the repository branch where the page's source file is stored. (mutually exclusive with `page-origin-tag`)
|v7.1.0

|`page-origin-private`
|Set if the origin where the page's source file is stored is private.
|_empty_

|`page-origin-refhash`
|The SHA-1 hash of the reference where the page's source file is stored.
If the file was taken from a git worktree (i.e., local directory), the value is `(worktree)`.
|e8e6f6ba33b1ab3f796907b5a256893a64844cd1

|`page-origin-refname`
|The name of the reference where the page's source file is stored.
|v7.1.0

|`page-origin-reftype`
|The reference type (e.g., tag or branch) where the page's source file is stored.
If the file was taken from a git worktree (i.e., local directory), the value is `branch`.
|branch

|`page-origin-tag`
|The name of the repository tag where the page's source file is stored. (mutually exclusive with `page-origin-branch`)
|v7.1.0

|`page-origin-start-path`
|The start path of the content source where the page's source file is stored.
|docs

|`page-origin-type`
|The type (e.g., git) of content source where the page's source file is stored.
|git

|`page-origin-url`
|The URL, without credentials, of the content source where the page's source file is stored.
|\https://gitlab.com/forest-co/silver-leaf.git

|`page-origin-worktree`
|The absolute path of the git worktree (i.e., local directory).
Only set if the file was taken from a git worktree.
|/user/projects/project-name

|`page-relative-src-path`
|The family-relative path of the page's source file (starting from [.path]_modules/<module>/pages_).
|whats-new-in-spiky.adoc

|`page-version`
|Alias for `page-component-version`.
|7.1
|===

Keep in mind that the AsciiDoc processor also assigns numerous intrinsic attributes to communicate information about the current document (e.g., `docname` and `docfilesuffix`), though these are not page attributes (meaning they are not prefixed with `page-`).

=== Put intrinsic page attributes to work

The value of these page attributes can be accessed in the AsciiDoc content using the attribute reference syntax (e.g., `\{page-component-name}`) or via the page UI model using a template variable (e.g., `page.attributes.component-name`).

.Reference the current page's module name, component title, and version
[listing]
----
This page belongs to the *{page-module}* module in the *{page-component-title} {page-component-version}* component version.
----

The attribute references in the above example output the data (shown below) for the current page, that is, the page you're reading right now.

====
This page belongs to the *{page-module}* module in the *{page-component-title} {page-component-version}* component version.
====

Since these are page attributes, they are promoted to the `page.attributes` map in the page UI model with all other page attributes.
They can be accessed in a UI template using a property expression (e.g., `page.attributes.component-name`).

To learn more about how page attributes work, see xref:page-attributes.adoc[].

// /docs/modules/page/pages/start-page.adoc
[[start-page.adoc]]
= Create a Start Page

You can create a start page named [.path]_index.adoc_ for a component version and Antora will automatically use it as the component version's default start page.
Or you can create a page with the filename of your choice, as long as you specify it as the component version's start page in the component version descriptor.

Visitors land on a component version's start page when they click on its entry in the xref:navigation:index.adoc#component-dropdown[component version selector] and when they click on its name at the xref:navigation:index.adoc#component-menu[top of the page menu].

[#use-default-start-page]
== Use a component version's default start page

To use Antora's default start page option, create an AsciiDoc source file named [.path]_index.adoc_ and save it in the xref:ROOT:pages-directory.adoc[_pages_ directory] of the xref:ROOT:root-module-directory.adoc[_ROOT_ module directory].
Structure and add content to [.path]_index.adoc_ like you would to any other page you write.
Antora will automatically set this page as the start page of the component version when the site is generated.

[#specify-start-page]
== Specify a start page for a component version

You can designate a specific page, regardless of its filename, to be a component version's start page.
*The source file must belong to the component version it will be the starting page for*, and it must be in the `pages` family.
Once you've created the page, assign it as the component version's start page using the xref:ROOT:component-start-page.adoc[start_page key] in [.path]_antora.yml_.

NOTE: The start page for a component version is separate from the start page for a site.
The start page for a site is where the visitor is directed when they go to the site's main URL.
To configure your site's start page, see xref:playbook:site-start-page.adoc[].

// /docs/modules/page/pages/xref.adoc
[[xref.adoc]]
= Xref Macros and Page Links
:page-aliases: page-id.adoc, asciidoc:page-to-page-xref.adoc
:colon: :
// page:page-id.adoc#whats-a-page-id == What's a page ID?
// page:page-id.adoc#important == Why are page IDs important?
//[#whats-a-cross-reference]

To create a page link, you need to know:

* how to structure and use the AsciiDoc xref macro,
* how to assign the resource ID of a page to an AsciiDoc xref macro,
* the resource ID of the page you're linking to (the target page), and
* the resource ID of the page where you want the link to be displayed (the current page).

[#xref-macro]
== AsciiDoc xref macro

An AsciiDoc xref macro is used to create a source-to-source cross reference from a resource to a publishable resource.
The term [.term]*cross reference*, which is often abbreviated to [.term]*xref*, means to use the AsciiDoc xref macro to reference the source file of a publishable resource.
The xref macro accepts an xref:resource-id.adoc[Antora resource ID] specifying a publishable page, attachment, or, occasionally, an image, as a value.
When Antora runs, an xref macro and its value are converted into a link to the target resource's published URL.

[#structure]
=== Xref macro structure

<<fig-xref-macro>> shows the structure of an xref macro.

.Xref macro structure for referencing a page
[#fig-xref-macro]
image::xref-macro-with-resource-id-for-page.svg[Diagram of an AsciiDoc xref macro with an Antora resource ID for a page]

At a minimum, an xref macro consists of the macro's prefix (`xref:`), the resource ID of the target page, and a set of square brackets (`[]`).
// tag::target-current-def[]
[[target]]The [.term]*target page* is the page source file that's being referenced by the current page.
The target page is referenced by assigning its resource ID to an xref macro in the content of the current page.
[[current]]The [.term]*current page* is the page source file containing the xref macro that references the target page.
// end::target-current-def[]
Each part of the xref macro shown in <<fig-xref-macro>> is described in more detail below.

xref{colon}::
An xref macro begins with the macro's name, `xref`, followed by a single colon (`:`).

resource ID of target page::
The xref macro accepts the resource ID of a page as its value.
The value is entered directly after the colon that follows the macro's name (`xref:`).
How many of the target page's xref:resource-id-coordinates.adoc[resource ID coordinates] you need to specify depends on the component version and module of the target page in relation to the current page.
The `page$` family coordinate isn't required in the resource ID when the target resource is a page.
Also, remember that the xref:resource-id-coordinates.adoc#id-resource[file coordinate] of a target page is calculated from the [.path]_pages_ family directory.

[[id-fragment]]#fragment::
A [.term]*fragment* is an element ID that links to a section, block, or inline location within the target page.
Fragments are also referred to as [.term]*deep links*.
A fragment is optional.
The fragment starts with the hash symbol (`#`) and is entered directly after the resource ID of the target page.
A target page's reference text, whether assigned by default or using the `reftext` attribute, isn't used as <<link-text,link text>> when a fragment is specified.

[[link-text]][link text]::
The xref macro is completed with a set of square brackets (`[]`) at the end of the target page's resource ID, or, if specified, at the end of the <<id-fragment,fragment>>.
You can enter optional text between these brackets or leave them empty.
When Antora converts the xref macro and its value into a link, the text entered between the square brackets is displayed in the current page when it's published to your site.
If no link text is specified between the macro's square brackets, and the value of the xref macro doesn't contain a fragment, then the target page's xref:link-content.adoc#default[default reference text] or text assigned to the xref:reftext-and-navtitle.adoc[reftext attribute] is displayed in the current page when it's published.
If a fragment is appended to the resource ID of the target page and no link text is entered between the brackets, then the URL of the published target page is displayed.

The next section explains how to create a cross reference step-by-step.

[#make-link]
== Make a link with the xref macro

Let's break down the xref macro and resource ID coordinates you need to create a cross reference to a page (the <<target,target page>>) from a page that you're currently editing (the <<current,current page>>).

. In your IDE or text editor, open the page where you want to create a cross reference.
For this step and the subsequent steps, let's assume you've opened the file [.path]_satellites.adoc_.
[.path]_satellites.adoc_ is the current page.
+
.satellites.adoc (current page)
----
=== Console options

See the
----

. In the current page, select the location in the content flow where you want the link to the target page to be displayed.
Enter the name of the xref macro followed by one colon, `xref:`.
+
.satellites.adoc (current page)
[listing,subs=+quotes]
----
=== Console options

See the **xref:**
----

. Assign the resource ID of the target page to the xref macro.
In <<ex-target>>, let's use [.path]_modes.adoc_ as the target page and assume that it and the current page, [.path]_satellites.adoc_, belong to the same component version and module.
Therefore, only the file coordinate of the target page needs to be specified.
+
--
.satellites.adoc (current page)
[listing#ex-target,subs=+quotes]
----
=== Console options

See the xref:**modes.adoc**
----

The file coordinate for the [.path]_modes.adoc_ page is `modes.adoc`.
The target page's file coordinate consists solely of its filename and file extension because it's stored at the root of the [.path]_pages_ directory.

NOTE: The resource ID for [.path]_modes.adoc_ doesn't include the `page$` family coordinate.
The xref macro assumes the family coordinate is `page$` when it isn't specified.
--

. Directly after the resource ID of the target page, enter an opening square bracket (`[`), then a closing square bracket (`]`), followed by any subsequent content.
+
--
.satellites.adoc (current page)
[listing,subs=+quotes]
----
=== Console options

See the xref:modes.adoc**[]** for more options.
----

We didn't enter any text between the macro's square brackets because we want the target page's reference text to be used as the link text.
When Antora converts the xref macro and target page's resource ID, it will automatically populate the link text with the target page's xref:link-content.adoc#default[default reference text] or text assigned to the xref:reftext-and-navtitle.adoc[reftext attribute].
--

That's it!
You've created a cross reference to the target page ([.path]_modes.adoc_) from the current page ([.path]_satellites.adoc_) using the AsciiDoc xref macro.

== Learn more

xref:page-links.adoc[] shows how to create xrefs to pages when the target page is stored in a subdirectory or it belongs to another module, component, or version.

The xref macro can also be used to create links to xref:attachments.adoc[attachments] and xref:images.adoc[images].

// /docs/modules/page/pages/page-links.adoc
[[page-links.adoc]]
= Create Page Links
:page-aliases: module-and-page-xrefs.adoc, version-and-component-xrefs.adoc
//This page walks through examples demonstrating how to determine the resource IDs for the target and current pages and how to assign the correct sequence of coordinates to an xref macro to create a valid page link.
//* [x] how to assign the correct sequence of resource ID coordinates to an xref macro to create a valid page link
//* [x] how to determine the resource ID of the target page in relation to the current page when:

On this page, you'll learn how to assign the correct resource ID coordinates to an xref macro when:

* [x] The target page and current page <<pages,belong to the same component version and module>>
* [x] The target page is <<pages-root,stored at the root of the _pages_ directory>>
* [x] The target page is <<relative-path,stored in a subdirectory of the _pages_ directory>>
* [x] The target page and current page are <<relative-path-token,stored in the same subdirectory of the _pages_ directory>>
* [x] The target page and current page <<modules,belong to different modules>>
* [x] The target page and current page <<component-versions,belong to different component versions>>
* [x] The target page and current page don't belong to the same component version, and the page link should always use <<latest-version,the latest version of the target page>>
* [x] The target page and current page belong to the same component, but the target page <<versions,belongs to a different version>>

[NOTE]
====
If you aren't familiar with the Antora resource ID, its coordinates, or how to use an xref macro, see:

* xref:resource-id.adoc[]
* xref:resource-id-coordinates.adoc[]
* xref:xref.adoc[]
====

//[#xref-page-in-module]
[#pages]
== Page links within a module
//Link to a page in the same module
//Xref pages that belong to the same module

Most of the cross references you make will probably be between pages that belong to the xref:ROOT:module-directories.adoc#module[same module] in a component version.
The AsciiDoc xref macro only requires the xref:resource-id-coordinates.adoc#id-resource[file coordinate] of the target page's resource ID when the current page and target page belong to the same component version and module.

[TIP]
====
include::page$xref.adoc[tag=target-current-def]
====

<<ex-file-base>> shows the file coordinate of the target page assigned to an xref macro in the current page.

.current-page.adoc
[#ex-file-base]
----
xref:file-coordinate-of-target-page.adoc[optional link text] <.>

xref:file-coordinate-of-target-page.adoc#fragment[optional link text] <.>
----
<.> For step-by-step instructions on how to set up an xref macro, see xref:xref.adoc#make-link[Make a link with the xref macro].
<.> An optional fragment, representing an element ID in the target page, can be assigned after the target page's file coordinate.

The file coordinate of the <<target,target page>> is always calculated from the root of the [.path]_pages_ family directory.
That means the structure of the target page's file coordinate depends on whether the target page is stored at the root of the [.path]_pages_ family directory or in a subdirectory of the [.path]_pages_ directory.

.File coordinate structure of target page
[#ex-file]
----
xref:target-page-filename.adoc[optional link text] <.>

xref:path/to/target-page-filename.adoc[optional link text] <.>

xref:./target-page-filename.adoc[optional link text] <.>
----
<.> File coordinate of the target page when it's stored at the root of the [.path]_pages_ directory.
<.> File coordinate of the target page when it's stored in a subdirectory of the [.path]_pages_ directory, but the current page isn't stored in the same subdirectory.
<.> File coordinate of the target page when the target page and current page are stored in the same subdirectory of the [.path]_pages_ directory.

The following sections provide examples of the file coordinate structures.

[#pages-root]
=== File coordinate at pages directory root

When the target page is stored at the root of the [.path]_pages_ family directory, the file coordinate is the target page's filename and file extension.

.File coordinate when target page is stored at the root of a pages directory
[#ex-page-base]
----
xref:target-page-filename.adoc[optional link text]
----

Let's use a few of the pages listed in <<ex-co>> as the basis for the examples in this section.

.Directories and files assigned to colorado 5.2
[listing#ex-co]
----
📄 antora.yml <.>
📂 modules
  📂 la-garita <.>
    📂 pages <.>
      📄 ridge.adoc
      📄 willow-creek.adoc
  📂 ROOT <.>
    📂 pages <.>
      📄 index.adoc
      📄 ranges.adoc
----
<.> Defines the component version as _colorado 5.2_
<.> Defines a module named _la-garita_
<.> Defines subsequent files as pages
<.> Defines the _ROOT_ module
<.> Defines subsequent files as pages

Using the two pages that belong to the _la-garita_ module, shown in <<ex-co>> above, let's reference [.path]_willow-creek.adoc_ from [.path]_ridge.adoc_.
That means the source file [.path]_willow-creek.adoc_ is the <<target,target page>> and [.path]_ridge.adoc_ is the <<current,current page>>.
<<ex-page>> shows an xref macro in the [.path]_ridge.adoc_ page that links to the [.path]_willow-creek.adoc_ page.

.ridge.adoc (current page)
[#ex-page]
----
The xref:willow-creek.adoc[trailhead] is north of town.
----

The file coordinate for the [.path]_willow-creek.adoc_ page consists solely of its filename and file extension, `willow-creek.adoc`, because it's stored at the root of the [.path]_pages_ directory.
The file coordinate of the target page is always calculated from the root of the [.path]_pages_ family directory.

Let's look at another xref macro, shown in <<ex-in-root>>, that references the [.path]_ranges.adoc_ page (target page) from the [.path]_index.adoc_ page (current page).

.index.adoc (current page)
[#ex-in-root]
----
The Rocky Mountains consists of xref:ranges.adoc[numerous mountain ranges].
----

Only the file coordinate of the target page needs to be specified in the xref macro because both pages belong to the _ROOT_ module and the _colorado 5.2_ component version.
The file coordinate for [.path]_ranges.adoc_ is `ranges.adoc` because it's stored at the root of the [.path]_pages_ directory.
See <<relative-path>> and <<relative-path-token>> for file coordinate examples when the target page is stored in a subdirectory [.path]_pages_ directory.

[#relative-path]
=== File coordinate with pages-relative directory path
//Link to a page in a subdirectory

The __pages__-relative directory path of the <<target,target page>> is required in its file coordinate when the <<current,current page>> isn't stored in the same subdirectory as the target page.
If both pages are stored in the same subdirectory, see <<relative-path-token>>.

.File coordinate when the target page is stored in a subdirectory of a pages directory
[#ex-subdir-base]
----
xref:path/to/target-page-filename.adoc[optional link text]
----

Let's reference [.path]_faq.adoc_ from [.path]_ranges.adoc_.
As you can see in <<ex-co-subdir>>, both pages belong to the _ROOT_ module of the _colorado 5.2_ component version.

.Directories and files assigned to colorado 5.2
[listing#ex-co-subdir]
----
📄 antora.yml <.>
📂 modules
  📂 ROOT <.>
    📂 pages <.>
      📄 index.adoc
      📄 ranges.adoc
      📂 terms <.>
        📄 faq.adoc
        📄 signs.adoc
----
<.> Defines the component version as _colorado 5.2_
<.> Defines the _ROOT_ module
<.> Defines subsequent source files as pages
<.> A subdirectory in _pages_ containing the source files of pages

The xref macro in <<ex-subdir>> creates a link to the [.path]_faq.adoc_ page (target page) from the [.path]_ranges.adoc_ page (current page).

.ranges.adoc (current page)
[#ex-subdir]
----
See the xref:terms/faq.adoc[].
----

As shown in <<ex-subdir>>, the file coordinate for [.path]_faq.adoc_ is `terms/faq.adoc`.
The file coordinate assigned to the xref macro consists of the target page's __pages__-relative directory path in addition to its filename and file extension because [.path]_faq.adoc_ is stored in the subdirectory [.path]_terms_.
In cases where the current page and target page are stored in the same subdirectory, you can use the relative path token, `./`, in place of the __pages__-relative directory path.

[#relative-path-token]
=== File coordinate with relative path token

If the <<target,target page>> and <<current,current page>> are stored in the same subdirectory in the [.path]_pages_ directory, the __pages__-relative directory path of the target page's file coordinate can be replaced with the relative path token, `./`.

.File coordinate when the target page and current page are stored in the same subdirectory
[#ex-relative-path-token]
----
xref:./target-page-filename.adoc[optional link text]
----

Let's reference [.path]_faq.adoc_ from [.path]_signs.adoc_.
<<ex-co-relative-path-token>> shows that both files are stored in the [.path]_terms_ subdirectory of the [.path]_pages_ directory, and that both files belong to the same module and component version.

.Directories and files assigned to colorado 5.2
[listing#ex-co-relative-path-token]
----
📄 antora.yml
📂 modules
  📂 ROOT <.>
    📂 pages <.>
      📄 index.adoc
      📂 terms <.>
        📄 faq.adoc
        📄 signs.adoc
----
<.> Defines the _ROOT_ module
<.> Defines subsequent source files as pages
<.> A subdirectory in [.path]_pages_ containing the source files of pages

When the target page and current page are stored in the same subdirectory in the [.path]_pages_ directory, the relative path token, `./`, can be used to abbreviate the target page's file coordinate.
The xref macro in <<ex-relative-path-token>> links to the [.path]_faq.adoc_ page (target page) from the [.path]_signs.adoc_ page (current page).

.signs.adoc (current page)
[#ex-relative-path-token-subdir]
----
See the xref:./faq.adoc[].
----

As shown in <<ex-relative-path-token-subdir>>, the file coordinate for [.path]_faq.adoc_, when referenced from [.path]_signs.adoc_, is `./faq.adoc`.
Both pages are stored in the [.path]_terms_ subdirectory, therefore, the __pages__-relative directory path of the target page's file coordinate is replaced with the `./` token.

//[#xref-page-across-modules]
[#modules]
== Page links between modules

When the <<target,target page>> and <<current,current page>> don't belong to the same module, you must specify the xref:resource-id-coordinates.adoc#id-module[module coordinate] and xref:resource-id-coordinates.adoc#id-resource[file coordinate] of the target page in the xref macro.

.Module and file coordinate of target page assigned to an xref macro
[#ex-module-base]
----
xref:module:file-coordinate-of-target-page.adoc[optional link text] <.>
----
<.> Assign the module and file coordinates of the target page to the xref macro when the target page and current page belong to the same component version but not the same module.

Using two pages from the _colorado 5.2_ component version, shown in <<ex-co-mod>>, let's reference [.path]_ranges.adoc_ from [.path]_willow-creek.adoc_.

.Directories and files assigned to colorado 5.2
[listing#ex-co-mod]
----
📄 antora.yml <.>
📂 modules
  📂 la-garita <.>
    📂 pages
      📄 willow-creek.adoc
  📂 ROOT <.>
    📂 pages
      📄 index.adoc
      📄 ranges.adoc
----
<.> Defines the component version as _colorado 5.2_
<.> Defines a module named _la-garita_
<.> Defines the _ROOT_ module

The [.path]_willow-creek.adoc_ page belongs to the _la-garita_ module, but _ranges.adoc_ belongs to the _ROOT_ module.
The xref macro in <<ex-module>> links to [.path]_ranges.adoc_ (target page) from the page [.path]_willow-creek.adoc_ (current page).

.willow-creek.adoc (current page)
[#ex-module]
----
Only xref:ROOT:ranges.adoc[one pass is open] in the winter.
----

As shown in <<ex-module>>, the target page's module coordinate is `ROOT` and its file coordinate is `ranges.adoc`.

//[#xref-page-in-different-docs-component]
[#component-versions]
== Page links between component versions

When the <<target,target page>> and <<current,current page>> belong to different documentation components, you must specify, at a minimum, the target page's xref:resource-id-coordinates.adoc#id-component[component, module, and file coordinates] in the xref macro.
You'll almost always specify the xref:resource-id-coordinates.adoc#id-version[version coordinate], too.

.Version, component, module, and file coordinates assigned to an xref macro
[#ex-component-version-base]
----
xref:version@component:module:file-coordinate-of-target-page.adoc[optional link text] <.>

xref:component:module:file-coordinate-of-target-page.adoc[optional link text] <.>
----
<.> Assign the version, component, module, and file coordinates of the target page to the xref macro when the target page and current page don't belong to the same component versions.
<.> <<latest-version,If the version coordinate isn't specified>>, Antora uses the latest version of the target page's component to complete the resource ID at runtime.
This behavior only applies when the target page and current page belong to different docs components.

Let's reference [.path]_elevation.adoc_ from [.path]_index.adoc_.
The [.path]_index.adoc_ page belongs to the component version _colorado 5.2_ (<<ex-co-v>>).
The [.path]_elevation.adoc_ page belongs to the component version _wyoming 1.0_ (<<ex-wy>>).

.Directories and files assigned to colorado 5.2
[listing#ex-co-v]
----
📄 antora.yml <.>
📂 modules
  📂 la-garita
    📂 pages
      📄 willow-creek.adoc
  📂 ROOT
    📂 pages
      📄 index.adoc
      📄 ranges.adoc
----
<.> Defines the component version as _colorado 5.2_

.Directories and files assigned to wyoming 1.0
[listing#ex-wy]
----
📄 antora.yml <.>
📂 modules
  📂 sierra-madre
    📂 pages
      📄 elevation.adoc
      📄 wilderness-areas.adoc
----
<.> Defines the component version as _wyoming 1.0_

In <<ex-across-components>>, the xref macro links to the [.path]_elevation.adoc_ page (target page) from [.path]_index.adoc_ (current page) .

.index.adoc (current page)
[#ex-across-components]
----
Do you know xref:1.0@wyoming:sierra-madre:elevation.adoc[how elevation is measured]?
----

Because the target page belongs to the _wyoming 1.0_ component version whereas the current page belongs to _colorado 5.2_, the resource ID assigned to the xref macro
specifies the version, component, module, and file coordinates of the target page.
As shown in <<ex-across-components>>, the target page's version coordinate is `1.0`, its component coordinate is `wyoming`, its module coordinate is `sierra-madre`, and its file coordinate is `elevation.adoc`.

In <<ex-across-components-short-root>>, the page [.path]_ranges.adoc_ is referenced from the page [.path]_elevation.adoc_.
The target page, [.path]_ranges.adoc_, belongs to the _ROOT_ module of _colorado 5.2_ whereas the current page belongs to _wyoming 1.0_.

.elevation.adoc (current page)
[#ex-across-components-short-root]
----
xref:5.2@colorado::ranges.adoc[]
----

Notice in <<ex-across-components-short-root>> that the module coordinate `ROOT` seems to be missing from the resource ID.
When a component coordinate is specified in a resource ID, and the target page belongs to the _ROOT_ module, the module coordinate `ROOT` doesn't have to be explicitly specified.
But you must still enter the colon (`:`) that would follow the module coordinate.
You can see this `:` directly before the file coordinate `ranges.adoc`.
This shorthand only works when a component coordinate is specified and the module coordinate of the target page is `ROOT`.
In all other cases where the module coordinate is required, the name of the module must be specified.

//[#xref-latest-version-of-component-version-page]
[#latest-version]
=== Link to the latest version of a page

TIP: This behavior only applies when the target page and current page belong to different docs components!

If a version isn't specified in the resource ID assigned to an xref macro, *and the target page and current page don't belong to the same component*, Antora uses the version coordinate of the xref:ROOT:how-component-versions-are-sorted.adoc#latest-version[latest version] of the target page's component to complete the resource ID at runtime.

Let's reference the [.path]_elevation.adoc_ page (target page) from the [.path]_willow-creek.adoc_ page (current page).
[.path]_elevation.adoc_ belongs to the component version _wyoming 1.0_ (<<ex-wy1>>).
[.path]_willow-creek.adoc_ belongs to component version _colorado 5.2_ (<<ex-co-latest>>) .

.Directories and files assigned to wyoming 1.0
[listing#ex-wy1]
----
📄 antora.yml <.>
📂 modules
  📂 sierra-madre
    📂 pages
      📄 elevation.adoc
      📄 wilderness-areas.adoc
----
<.> Defines the component version as _wyoming 1.0_

.Directories and files assigned to colorado 5.2
[listing#ex-co-latest]
----
📄 antora.yml <.>
📂 modules
  📂 la-garita
    📂 pages
      📄 willow-creek.adoc
----
<.> Defines the component version as _colorado 5.2_

If you always want the xref macro in <<ex-across-components-latest>> to link to the latest version of the [.path]_elevation.adoc_ page, don't specify a version coordinate in the target page's resource ID.

.willow-creek.adoc (current page)
[#ex-across-components-latest]
----
xref:wyoming:sierra-madre:elevation.adoc[How are peaks measured]? <.>
----
<.> Directly after the macro prefix, `xref:`, assign the resource ID of the target page starting with its component coordinate.

When Antora runs, it will identify _wyoming 1.0_ as the latest version of the _wyoming_ component according to its xref:ROOT:how-component-versions-are-sorted.adoc#version-sorting-rules[version sorting rules] and xref:ROOT:how-component-versions-are-sorted.adoc#latest-version[latest version criteria].
Because a version coordinate isn't specified in <<ex-across-components-latest>>, Antora will complete the resource ID assigned to the xref macro using the version coordinate -- `1.0` -- from the latest _wyoming_ component.
Remember, this behavior only applies if the target page and current page belong to different components.

After a few months, let's add the new component version _wyoming 1.5_, shown in <<ex-wy-latest>>, to your site.

.Directories and files assigned to wyoming 1.5
[listing#ex-wy-latest]
----
📄 antora.yml <.>
📂 modules
  📂 sierra-madre
    📂 pages
      📄 elevation.adoc
      📄 wilderness-areas.adoc
----
<.> Defines the component version as _wyoming 1.5_

The next time the site is generated, Antora will determine that _wyoming 1.5_ (not _wyoming 1.0_) is the latest version of the _wyoming_ component.

.willow-creek.adoc (current page)
[#ex-new-latest]
----
xref:wyoming:sierra-madre:elevation.adoc[How are peaks measured]?
----

Because Antora now identifies _wyoming 1.5_ as the latest version of the _wyoming_ component, Antora will complete the resource ID of the target page in <<ex-new-latest>> with the version coordinate -- `1.5` -- of the latest _wyoming_ component at runtime.

WARNING: This behavior of linking to the latest version only applies when the version coordinate is unspecified and the target page and current page belong to different components.
If the version and component coordinates aren't specified in the resource ID, Antora assumes the target page belongs to the same component version as the current page and uses the current page's version and component coordinates to complete the target page's resource ID.

//[#xref-page-in-different-version]
[#versions]
== Page links between versions of a component

When the <<current,current page>> and <<target,target page>> belong to the same component, but the target page belongs to a different version of the component, you'll specify the version, module (if it's different than the current page's module), and file coordinates.

.current-page.adoc
[#ex-version-base]
----
xref:version@module:file-coordinate-of-target-page.adoc[optional link text] <.>

xref:version@file-coordinate-of-target-page.adoc[optional link text] <.>
----
<.> Assign the version, module, and file coordinates of the target page to the xref macro when the target page doesn't belong to the same version and module as the current page.
<.> Assign the version and file coordinates of the target page to the xref macro when the target page doesn't belong to the same version as the current page.

Let's use the pages that belong to _colorado 5.2_ (<<ex-co5>>) and _colorado 6.0_ (<<ex-co6>>) as the basis for the example in this section.

.Directories and files assigned to colorado 5.2
[listing#ex-co5]
----
📄 antora.yml <.>
📂 modules
  📂 get-started
    📂 pages
      📄 tour.adoc
  📂 la-garita
    📂 pages
      📄 willow-creek.adoc
----
<.> Defines the component version as _colorado 5.2_

.Directories and files assigned to colorado 6.0
[listing#ex-co6]
----
📄 antora.yml <.>
📂 modules
  📂 la-garita
    📂 pages
      📄 willow-creek.adoc
----
<.> Defines the component version as _colorado 6.0_

Notice that the _colorado 5.2_ component version in <<ex-co5>> has a [.path]_tour.adoc_ page that belongs to the _get-started_ module.
However, _colorado 6.0_, shown in <<ex-co6>>, has no such module or page.
Let's reference [.path]_tour.adoc_ (target page) from the page [.path]_willow-creek.adoc_ (current page) that belongs to the _colorado 6.0_ component version.
In <<ex-across-versions>>, the resource ID assigned to the xref macro specifies the target page's version, module, and file coordinates because the target page belongs to a different version and module than the current page.

.willow-creek.adoc (current page) in colorado 6.0
[#ex-across-versions]
----
Last year's xref:5.2@get-started:tour.adoc[excursions] were riveting!
----

As shown in <<ex-across-versions>>, the target page's version coordinate is `5.2`, its module coordinate is `get-started`, and its file coordinate is `tour.adoc`.

// /docs/modules/page/pages/link-content.adoc
[[link-content.adoc]]
= Page Link Text

[#default]
== Use the target page's default link text

When an xref doesn't specify any link text, Antora uses the target page's `reftext` value as the link text.
Let's create an xref to the [.path]_resource-id.adoc_ page in Antora's own documentation.

----
See xref:resource-id.adoc[].
----

Notice the xref doesn't have any link text specified.
As you can see in the example output below, Antora automatically fills in the link text using the title of the target page.

====
See xref:resource-id.adoc[].
====

If you click on the link, you'll see that the clickable text and the title of the target page are the same.
A page's title is assigned to the built-in AsciiDoc `reftext` attribute by default.
You can also xref:reftext-and-navtitle.adoc[assign a custom value to the reftext attribute].

CAUTION: When the resource ID of the target page is appended with a xref:xref.adoc#id-fragment[fragment (deep link)] and no link text is specified between the square brackets, like `\xref:page.adoc#fragment[]`, the link text isn't automatically populated.
You'll need to specify the link text in the xref macro when using a fragment.

TIP: Xrefs in a navigation file behave the same way with one additional feature.
Navigation files use the xref:reftext-and-navtitle.adoc#navtitle[navtitle value] to populate missing link text.
If `navtitle` isn't set, then they use the page's `reftext` value.

// /docs/modules/page/pages/reftext-and-navtitle.adoc
[[reftext-and-navtitle.adoc]]
= Customize reftext and navtitle

The `reftext` and `navtitle` attributes are automatically set and assigned default values when Antora runs.
You can customize the values of these attributes by setting them in the header of a page.

[#reftext]
== reftext attribute

A target page's `reftext` value is used as the link text in an xref that originates from a page or resource file.
By default, Antora assigns a page's title to the `reftext` attribute at runtime.
In <<ex-page>>, let's reference the [.path]_install-prerequisites.adoc_ file and leave the link text field empty.

.current-page.adoc
[#ex-page]
----
Make sure you xref:install-prerequisites.adoc[].
----

Now, let's look at the header of the [.path]_install-prerequisites.adoc_ file.

.install-prerequisites.adoc
[#ex-default-reftext]
----
= Installing and Testing Silver Leaf's Prerequisites

Here are the prerequisites:
----

Notice in <<ex-default-reftext>> that `reftext` isn't set in the page's header.
That means its title, _Installing and Testing Silver Leaf's Prerequisites_, will be automatically assigned to `reftext` at runtime and used in <<ex-page>> as the xref's link text.

If you don't want a page's title to be used as its default `reftext`, assign the attribute a custom value with an attribute entry.
<<ex-custom-reftext>> shows the `reftext` attribute being assigned a custom value.

.Assign a custom reftext value
[#ex-custom-reftext]
----
= Installing and Testing Silver Leaf's Prerequisites
:reftext: Install Silver Leaf's Prerequisites

Here are the prerequisites:
----

When the site is generated, the value of `reftext`, _Install Silver Leaf's Prerequisites_, will be used in <<ex-page>> as the xref's link text.
It will also be used as the page's `navtitle` value.

CAUTION: When the resource ID of the target page is appended with a xref:xref.adoc#id-fragment[fragment], the link text isn't automatically populated.
You'll need to specify the xref's link text in such cases.

[#navtitle]
== navtitle attribute

A target page's `navtitle` value is used as the link text in an xref that originates from a xref:navigation:files-and-lists.adoc[navigation file].
By default, Antora assigns the value of a page's `reftext` attribute to `navtitle`.
A <<reftext,page's reftext>> is often automatically assigned the page's title.

In <<ex-nav>>, let's reference the [.path]_get-started.adoc_ file from a navigation file, and leave the link text field empty.

.nav.adoc
[#ex-nav]
----
* xref:index.adoc[]
* xref:get-started.adoc[]
----

Now, let's look at the header of the [.path]_get-started.adoc_ file in <<ex-default-navtitle>>.

.get-started.adoc
[#ex-default-navtitle]
----
= Get Started with Silver Leaf

Let's get started!
----

Notice that neither `reftext` nor `navtitle` are set in it's header.
That means the page's title, _Get Started with Silver Leaf_, will be automatically assigned to `reftext`, and therefore, to `navtitle`, and used to populate the xref link text in the navigation file.

If you don't want a page's default or custom `reftext` value to be assigned as the default `navtitle`, assign the attribute a custom value with an attribute entry.
<<ex-custom-navtitle>> shows the `navtitle` attribute being assigned a custom value.

.Assign a custom navtitle value
[#ex-custom-navtitle]
----
= Get Started with Silver Leaf
:navtitle: Getting Started

Let's get started!
----

When the site is generated, the value of `navtitle`, _Getting Started_, will populate the xref link text in the navigation file.

CAUTION: When the resource ID of the target page is appended with a xref:xref.adoc#id-fragment[fragment] (aka a deep link) and no link text is specified between the square brackets, like `\xref:page.adoc#fragment[]`, the link text isn't automatically populated.
You'll need to specify the link text in the xref macro when using a fragment.

// /docs/modules/page/pages/page-aliases.adoc
[[page-aliases.adoc]]
= Set Up URL Redirects with page-aliases

You can create a redirect from an old page to a new page using Antora's built-in `page-aliases` attribute.
This xref:page-attributes.adoc[page attribute] is useful when you delete a page, rename a page's file, or move a page to a different module or component.
Using the `page-aliases` attribute, a page can claim the identity of one or more other pages.
Antora will then redirect the URLs for those pages to the page in which the aliases are defined.

== Page aliases and bulk URL redirects

Page aliases are designed to address page renames or moves, *particularly within a component version*.
They are *not* a general-purpose URL router.
Although they can be used to create redirects across components or component versions, you need to use this feature with care or else it can become quite noisy and thus confusing.

If you remove a large number of pages, such as if you remove or rename a component or component version, and you want to preserve the existing URLs, you should not attempt to do so using page aliases.
Page aliases were not designed to provide bulk URL redirects.
Instead, we strongly recommended that you use the router provided by your web server or host when you remove or rename a component or component version.
You can do so either using a separate step during publishing or by using an Antora extension.

== page-aliases attribute

The `page-aliases` attribute is set in the xref:standard-page.adoc#page-header[page header] of a target page using an xref:define-and-modify-attributes.adoc#attribute-entry[attribute entry].
[[target-page]]The [.term]*target page* refers to the page you're redirecting a source page to.
[[source-page]]The [.term]*source page* refers to the deleted, renamed, or moved page that you're redirecting from (i.e., the page to claim).
A source page's resource ID--its xref:resource-id.adoc[resource ID] before it was deleted, renamed, or moved--is assigned to the `page-aliases` attribute in a target page.
Multiple resource IDs can be assigned to the attribute in a comma-separated list.

.Header of target page
----
= Title of Target Page
:page-aliases: source-page-filename.adoc, version@component:module:source-page-filename.adoc
----

You can split this list across multiple lines using a line continuation (a space followed by a backslash at the end of the line):

.Page aliases split across multiple lines
----
= Title of Target Page
:page-aliases: source-page-filename.adoc, \
version@component:module:source-page-filename.adoc
----

Antora calculates the URL for a source page's resource ID and generates redirect information so that the source page URL redirects to the target page URL.
Any coordinates, such as xref:resource-id-coordinates.adoc#id-version[version or component], that aren't specified in a resource ID assigned to `page-aliases` are interpolated from the target page's coordinates.
The generated output format of the redirect information is determined by your chosen xref:playbook:urls-redirect-facility.adoc[redirect facility].

A resource ID assigned to a `page-aliases` attribute can be used in an xref.
Therefore, if you delete, rename, or move a page, you don't need to update any references to it in your source files.

//The site start_page, if specified in the playbook, is implemented through the redirect facility.

=== Page alias restrictions

The `page-aliases` attribute can only be applied to pages.
Partials, examples, images, and attachments can't be aliased.
While a resource ID assigned to `page-aliases` works in xrefs, the xref:navigation:index.adoc#page-dropdown[page version selector] in the reference UI does not connect previous versions of the source page to the target page.

//TIP: If you run Antora's Xref Validator with the option `--attribute page-aliases=~`, it will provide a report of any xrefs using aliased resource IDs.

== Create a redirect for a renamed page

If you change a source page's filename from [.path]_old-name.adoc_ to [.path]_new-name.adoc_, assign the file's former resource ID to `page-aliases` in its header.

.new-name.adoc
----
= Title of Target Page
:page-aliases: old-name.adoc
----

This will result in [.path]_\https://base-url.com/component/version/module/old-name.html_ being redirected to [.path]_\https://base-url.com/component/version/module/new-name.html_.
The version, component, and module coordinates that weren't specified in the `old-name.adoc` resource ID are interpolated from the target page's coordinates.
Alternatively, if you assigned xref:playbook:urls-html-extension-style.adoc#indexify-style[indexify] to the `html-extension-style` key in your playbook, [.path]_\https://base-url.com/component/version/module/old-name/_ will redirect to [.path]_\https://base-url.com/component/version/module/new-name/_ .

== Create a redirect for a moved page

When a page is moved from one module to another module in the same component, the aliased resource ID needs to contain the source page's former xref:resource-id-coordinates.adoc#id-module[module coordinate].
In <<ex-module>>, the page `source-1.adoc` has moved from `module-1` to `module-z`.
Both `module-1` and `module-z` are modules in version `5.0` of `component-1`.

.source-1.adoc
[#ex-module]
----
= Title of Target Page
:page-aliases: module-1:source-1.adoc <.>
----
<.> Specify the former module coordinate in addition to the file coordinate when moving a page to another module.

Now, Antora will redirect the URL [.path]_\https://base-url.com/component-1/5.0/module-1/source-1.html_ to the URL [.path]_\https://base-url.com/component-1/5.0/module-z/source-1.html_.

When a page is moved from one component to another component, assign the source page's fully qualified former resource ID to `page-aliases`.
In <<ex-component>>, the page `source-w.adoc` has moved from version `1.4` of `component-8`, `module-u` to version `3.0` of `component-delta`, `ROOT`.

.source-w.adoc
[#ex-component]
----
= Title of Target Page
:page-aliases: 1.4@component-8:module-u:source-w.adoc
----

This will result in the URL [.path]_\https://base-url.com/component-8/1.4/module-u/source-w.html_ being redirected to [.path]_\https://base-url.com/component-delta/3.0/source-w.html_.

== Create a redirect for a deleted page

Sometimes you just need to delete a page.
Before redirecting the deleted page's URL to another page, consider the following:

* Is there a potential target page that would help the visitors who previously used the information on the deleted page?
For instance, the deleted page described feature A, but feature A has been deprecated; users of feature A should now migrate to feature B.
* Is the deleted page a high traffic page?
If so, is there a relevant page that would definitely assist the people looking for the deleted page?

You shouldn't create a redirect to a target page that doesn't have much in common with the deleted page, as this often frustrates visitors.

If it's appropriate to redirect the deleted page's URL to another page, assign the deleted page's ID to the `page-aliases` attribute, making sure to specify the necessary coordinates.

.Target page
[#ex-deleted]
----
= Title of Target Page
:page-aliases: source-page-filename.adoc
----

TIP: It creates a bad user experience (and is a bad SEO practice), to redirect deleted pages to the site's home page or a project's start page.
This policy confuses visitors because they may not realize the page they're looking for no longer exists.
In cases where there isn't a highly relevant target page to redirect the deleted page to, it's better to direct visitors to a custom 404 page.

////
Discussion TODO: While this use case would work, we don't recommend using the built-in attributes in the page-aliases except to the most advanced users and in special (usually migration) situations. Large teams seem to quickly create redirect loops and break redirects because they try to use it for wholesale re-routing or SEO tactics

== Examples

=== Produce a versionless alias for a page using built-in page attributes

To make the redirects concrete, assume the original page coordinates are v2@component1::topic/topic.adoc.

----
:page-aliases: _@{page-component-name}:{page-module}:{page-src-path}
----

For clarity, this is expressed as case 8, everything specified.
Since the component and module are the same as the target, it could equivalently be expressed as case 4:
----
:page-aliases: _@:{page-src-path}
----

static redirect::
+
[,html]
----
<!DOCTYPE html>
<meta charset="utf-8">
<link rel="canonical" href="http://example.com/component1/v2/topic/topic.html">
<script>location="../v2/topic/topic.html"</script>
<meta http-equiv="refresh" content="0; url=../v2/topic/topic.html">
<meta name="robots" content="noindex">
<title>Redirect Notice</title>
<h1>Redirect Notice</h1>
<p>The page you requested has been relocated to <a href="../v2/topic/topic.html">http://example.com/component1/v2/topic/topic.html</a>.</p>
----

netlify redirect::
+
[,text]
----
/component1/topic/topic.html /component1/v2/topic/topic.html 301
----

nginx redirect::
+
[,text]
----
location = /component1/topic/topic.html { return 301 /component1/v2/topic/topic.html; }
----

Discussion TODO: While this use case would work, it wasn't the original intent of the page-aliases attribute. page-aliases was originally created for renaming a file or moving individual pages to other modules and topic folders, etc. It really wasn't meant for wholesale rerouting and I'm not sure we want to recommend it to users as such. Instead, we probably want to recommend an actual router for such bulk URL changes and/or create a discrete routing component for Antora.

However, I'm keeping this content here because we may change our mind after further discussion and/or use at a basis for changes to this feature.

=== Change module using a partial containing the page-aliases

If you've moved a large number of files in a similar way, such as from one module to another, it may avoid duplication to include the page-aliases from a partial.
Suppose your files are now at v3 in new-module, and you want  to redirect from v2 in old-module.
In new-module/partials/alias.adoc, include

----
:page-aliases: v2@{page-component-name}:old-module:{page-src-path}
----

and in each redirect target file add in the headers:

----
\include::partial$alias.adoc[]
----

For example, a file v3@component2:new-module:topic/topic.adoc will be redirected to from v2@component2:old-module:topic/topic.adoc, which translates to component2/v2/old-module/topic/topic.html.
////

// /docs/modules/page/pages/page-layout.adoc
[[page-layout.adoc]]
= Assign UI Templates with page-layout

Antora provides a xref:page-attributes.adoc[page attribute] named `page-layout`.
This attribute applies an alternate UI layout to the contents of a page.

== page-layout attribute

The `page-layout` attribute is optional.
It's defined in the header of a page using an xref:define-and-modify-attributes.adoc#attribute-entry[AsciiDoc attribute entry].

----
= Page Title
:page-layout: tiles
----

The `page-layout` attribute accepts the filename of a UI layout file without the file extension.
For example, if you want a page to use the layout file [.path]_tiles.hbs_, assign the value `tiles` to `page-layout`.
The associated layout file (e.g., [.path]_tiles.hbs_) is expected to be located in the xref:antora-ui-default::templates.adoc[UI bundle's _layouts_ directory].
When the `page-layout` attribute is explicitly set in the header of a page, it overrides the default layout.

== Default page-layout

If `page-layout` isn't defined in a page's header, then the page layout defined by the xref:playbook:ui-default-layout.adoc[default_layout playbook key] is applied when the site is generated.
When neither `page-layout` or `default_layout` are set, Antora automatically assigns the built-in `default` value to `default_layout`.
The `default` page layout applies the [.path]_default.hbs_ layout file to any pages where `page-layout` isn't explicitly set.

// /docs/modules/page/pages/include-a-page.adoc
[[include-a-page.adoc]]
= Include a Page
:page-aliases: asciidoc:include-page.adoc
// URLs
:url-include: {url-asciidoc}/directives/include/
:url-tags: {url-asciidoc}/directives/include-tagged-regions/
:url-leveloffset: {url-asciidoc}/directives/include-with-leveloffset/

A page or portion of a page can be inserted into any other page in your site using the AsciiDoc include directive and the page's resource ID.

== AsciiDoc include directive for pages

An AsciiDoc include directive inserts content from the source file of a page into another page.
The include directive accepts the xref:resource-id.adoc[Antora resource ID] of partials, examples, and pages as a value.

<<ex-base>> shows the structure of an include directive with the fully qualified resource ID of a page.
By default, the include directive assumes the family coordinate is `page$` when a family coordinate isn't specified.

.Include directive assigned the fully qualified resource ID of a page
[#ex-base]
----
\include::version@component:module:file-coordinate-of-target-page.adoc[optional attribute]
----

An include directive consists of the directive's prefix (`include::`), the resource ID of the target page, and a set of square brackets (`[]`).
You can specify optional attributes within the square brackets as key-value pairs separated by commas.
[[target]]The [.term]*target page* is the source file of a page that's being referenced by the current page.
The target page is referenced by assigning its resource ID to an include directive in the content of the current page.
[[current]]The [.term]*current page* is the page source file containing the include directive that references the target page.

When Antora runs, the source content from the target page is inserted into the current page <<placement,at the location where the include directive is entered>>.
The target page's content is converted after it's inserted into the current page.
This means the current page's component version, module, attributes, and other elements are applied to or may impact the content included from the target page.
See xref:partials.adoc#current-context[Current page context and structure] to learn more.

[#pages-root]
== Insert a page into a page

Let's break down the AsciiDoc include directive and resource ID coordinates you need to insert a <<target,target page>> into the <<current,current page>>.

. In your IDE or plain text editor, open the page where you want to include content from the target page.
For this step and the subsequent steps, let's assume you've opened the file [.path]_ranges.adoc_.
+
--
.ranges.adoc (current page)
----
There are three mountain passes in the Sawatch Range.
----

The current page, [.path]_ranges.adoc_, belongs to the component version _colorado 5.2_ and module _ROOT_, shown in <<ex-co>>.

.Directories and files assigned to colorado 5.2
[listing#ex-co]
----
📄 antora.yml <.>
📂 modules
  📂 ROOT <.>
    📂 pages <.>
      📄 cottonwood-pass.adoc
      📄 index.adoc
      📄 ranges.adoc
----
<.> Defines the component version as _colorado 5.2_
<.> Defines the _ROOT_ module
<.> Defines subsequent files as pages
--

. In the current page, select the line where you want the page's content to be inserted.
At the beginning of the line, enter the name of the directive followed by two colons, `include::`.
+
.ranges.adoc (current page)
[listing,subs=+quotes]
----
There are three mountain passes in the Sawatch Range.

**include::**
----

. Let's reference the target page, [.path]_cottonwood-pass.adoc_, from the current page.
Assign the resource ID of the target page to the include directive.
Both [.path]_cottonwood-pass.adoc_ and [.path]_ranges.adoc_ belong to the same component version and module (see <<ex-co>>).
Therefore, only the file coordinate of the target page needs to be specified.
+
--
.ranges.adoc (current page)
[listing,subs=+quotes]
----
There are three mountain passes in the Sawatch Range.

include::**cottonwood-pass.adoc**
----

The file coordinate for the [.path]_cottonwood-pass.adoc_ page is `cottonwood-pass.adoc`.
The target page's file coordinate consists solely of its filename and file extension because [.path]_cottonwood-pass.adoc_ is stored at the root of the [.path]_pages_ directory.

NOTE: You can specify the `page$` family coordinate in the resource ID if you prefer, but it isn't required when including a page into a page.
The include directive assumes the family coordinate is `page$` when it isn't specified.
--

. Directly after the resource ID of the target page, complete the directive with a set of square brackets (`+[]+`).
+
--
.ranges.adoc (current page)
[listing,subs=+quotes]
----
There are three mountain passes in the Sawatch Range.

include::cottonwood-pass.adoc**[]**
----

The brackets of the include directive can contain an optional list of attributes, such as `lines`, `tag`, or `tags`.
The attributes are entered as key-value pairs separated by commas.
See the {url-include}[AsciiDoc include directive documentation^] for full details about the `lines`, `tag`, and `tags` syntax.
--

That's it!
You've created an include directive that will insert the target page into the current page.

The structure of the target page's file coordinate varies depending on whether the target page is stored at the root of the [.path]_pages_ family directory, like in the preceding instructions, or in a subdirectory of the [.path]_pages_ directory.

.current-page.adoc
[#ex-file]
----
include::target-page-filename.adoc[] <.>

include::path/to/target-page-filename.adoc[] <.>

include::./target-page-filename.adoc[] <.>
----
<.> File coordinate of the target page when it's stored at the root of the [.path]_pages_ directory.
<.> File coordinate of the target page when it's stored in a subdirectory of the [.path]_pages_ directory.
<.> File coordinate of the target page when the target page and current page are stored in the same subdirectory of the [.path]_pages_ directory.

The following sections describe how to specify a file coordinate with a <<relative-path,pages-relative directory path>> or <<relative-path-token,relative path token>>.
Also, you'll need to specify additional resource ID coordinates when the target page and current page don't belong to the <<module-or-component,same module>> or <<module-or-component,component version>>.

[#relative-path]
=== File coordinate with pages-relative directory path

The __pages__-relative directory path of the <<target,target page>> is required in its file coordinate when it's stored in a subdirectory of the [.path]_pages_ directory.

.File coordinate when the target page is stored in a subdirectory of a pages directory
[#ex-subdir-base]
----
\include::path/to/target-page-filename.adoc[optional attribute]
----

Let's use the files that belong to the component version in <<ex-co-subdir>> as the basis for the example in this section.

.Directories and files assigned to colorado 5.2
[listing#ex-co-subdir]
----
📄 antora.yml <.>
📂 modules
  📂 ROOT <.>
    📂 pages <.>
      📄 cottonwood-pass.adoc
      📄 index.adoc
      📄 ranges.adoc
      📂 supplies <.>
        📄 gear.adoc
        📄 safety.adoc
----
<.> Defines the component version as _colorado 5.2_
<.> Defines the _ROOT_ module
<.> Defines subsequent files as pages
<.> A subdirectory in _pages_ containing the source files of pages

Let's reference [.path]_safety.adoc_ from [.path]_cottonwood-pass.adoc_.
As you can see in <<ex-co-subdir>> above, the target page and current page belong to the _ROOT_ module.
In <<ex-subdir>>, an include directive in the [.path]_cottonwood-pass.adoc_ page (current page) references the [.path]_safety.adoc_ file (target page).

.cottonwood-pass.adoc (current page)
[#ex-subdir]
----
== Trip planning

\include::supplies/safety.adoc[]
----

As shown in <<ex-subdir>>, the file coordinate for [.path]_safety.adoc_ is `supplies/safety.adoc.adoc`.
The file coordinate for [.path]_safety.adoc_ consists of its [.path]__pages__-relative directory path, filename, and file extension because it's stored in the subdirectory [.path]_supplies_ while the current page, [.path]_cottonwood-pass.adoc_, is stored in the [.path]_pages_ directory.
If the current page and target page were stored in the same subdirectory, you could use the relative path token, `./`, in place of the __pages__-relative directory path.

[#relative-path-token]
=== File coordinate with relative path token

If the <<target,target page>> and <<current,current page>> are stored in the same subdirectory within the [.path]_pages_ directory, the __pages__-relative directory path of the target page's file coordinate can be replaced with the relative path token, `./`.

.File coordinate in include directive when the target page and current page are stored in the same subdirectory
----
\include::./target-page-filename.adoc[]
----

Let's use the pages that belong to the component version shown in <<ex-co-relative-path-token>> as the basis for the examples in this section.

.Directories and files assigned to colorado 5.2
[listing#ex-co-relative-path-token]
----
📄 antora.yml <.>
📂 modules
  📂 ROOT <.>
    📂 pages <.>
      📄 cottonwood-pass.adoc
      📄 index.adoc
      📄 ranges.adoc
      📂 supplies <.>
        📄 gear.adoc
        📄 safety.adoc
----
<.> Defines the component version as _colorado 5.2_
<.> Defines the _ROOT_ module
<.> Defines subsequent files as pages
<.> A subdirectory in _pages_ containing the source files of pages

Let's reference [.path]_gear.adoc_ from [.path]_safety.adoc_.
<<ex-co-relative-path-token>> shows that both files are stored in the [.path]_supplies_ subdirectory of the [.path]_pages_ directory, and that both files belong to the _ROOT_ module of the same component version.
When the target page and current page are stored in the same subdirectory within the [.path]_pages_ directory, the relative path token, `./`, can be used to abbreviate the target page's file coordinate.

In <<ex-relative-path-token-subdir>>, the include directive in the [.path]_safety.adoc_ page (current page) references the [.path]_gear.adoc_ page (target page).

.safety.adoc (current page)
[#ex-relative-path-token-subdir]
----
\include::./gear.adoc[]
----

As shown in <<ex-relative-path-token-subdir>>, the file coordinate for [.path]_gear.adoc_, when referenced from [.path]_safety.adoc_, is `./gear.adoc`.
Both pages are stored in the [.path]_supplies_ subdirectory, therefore, the __pages__-relative directory path of the target page's file coordinate is replaced with the `./` token.

CAUTION: You may find that the include directive resolves the target page when the `./` token isn't used in the file coordinate.
However, we strongly recommend using the `./` token when referencing a target page that is stored in the same subdirectory as the current page.

[#module-or-component]
== Embed a page from another module or component version

You can include a page from any module or component version into another page that belongs to your site by assigning the target page's module coordinate or version, component, and module coordinates, respectively, to the include directive.

.current-page.adoc
[#ex-module-component-base]
----
include::module:file-coordinate-of-target-page.adoc[] <.>

include::version@component:module:file-coordinate-of-target-page.adoc[] <.>

include::component:module:file-coordinate-of-target-page.adoc[] <.>
----
<.> Assign the module and file coordinates of the target page to the include directive when the target page and current page belong to the same component version but not the same module.
<.> Assign the version, component, module, and file coordinates of the target page to the include directive when the target page and current page don't belong to the same component version.
<.> If the version coordinate isn't specified, Antora uses the xref:ROOT:how-component-versions-are-sorted.adoc#latest-version[latest version of the target page's component] to complete the resource ID at runtime.
This behavior only applies when the target page and current page belong to different docs components.

For example, to embed the content of [.path]_cottonwood-pass.adoc_ (target page) into a page (current page) that belongs to a different module of the _colorado 5.2_ component version, specify the target page's module coordinate in the include directive.

.current-page.adoc
[#ex-module]
----
\include::ROOT:cottonwood-pass.adoc[]
----

If the current page belongs to a different component version than [.path]_cottonwood-pass.adoc_ (target page), specify the target page's version, component, module, and file coordinates.

.current-page.adoc
[#ex-components]
----
\include::5.2@colorado:ROOT:cottonwood-pass.adoc[]
----

As shown in <<ex-components>>, the target page's version coordinate is `5.2`, its component coordinate is `colorado`, its module coordinate is `ROOT`, and its file coordinate is `cottonwood-pass.adoc`.

[#placement]
== Include directive placement

An include directive is placed at the beginning of a new line.
The content from the target page will be displayed as a standalone block when you enter an empty line above and below the include directive.
You can attach content from the target page to a block in the current page by placing the include directive on a new line directly adjacent to the content to which it should be attached.

.current-page.adoc
----
A paragraph in the page.

include::resource-id-of-target-page.adoc[tag=value] <.>

A line of content.
include::resource-id-of-target-page.adoc[] <.>
Another line of content.
----
<.> To display the included content as a standalone block, make sure there is an empty line before the include directive and after the include directive.
<.> To attach the included content to a block in the current page, enter the include directive on a new line directly above, between, or below the content lines of the block.

== Learn more

* xref:page-partial.adoc[]
* xref:include-a-partial.adoc[]
* xref:include-an-example.adoc[]
* xref:resource-id.adoc[]

.*AsciiDoc and Asciidoctor resources*
* {url-tags}[Select regions of content with tags^]
* {url-leveloffset}[Offset section headings with leveloffset^]
* {url-include}[AsciiDoc include directive^]

// /docs/modules/page/pages/page-partial.adoc
[[page-partial.adoc]]
= Unset page-partial Globally

As Antora processes each page, it converts the contents of the file from AsciiDoc to HTML.
(Within a component version, pages are typically processed in order by module and relative filename).
The conversion of the contents from AsciiDoc to HTML would normally impact the behavior of the include directive.
Specifically, a page that uses the include directive to include a page that has already been processed would see HTML instead of AsciiDoc.

To rectify this ordering problem, Antora can retain the AsciiDoc source until all pages have been converted.
This behavior is activated by setting the `page-partial` attribute in the document header of the page.
As of Antora 2.2, the `page-partial` attribute is (soft) set globally by default.
(Soft set means that it can still be overridden by the page).
So, really, you don't even have to think of it.
It will just work.

The downside of retaining the AsciiDoc source is that it _may_ increase the peak heap usage of Antora for very large sites by ~ 10%.
If that's a concern, you can revert to the previous "`a la carte`" behavior.
To revert to the previous behavior (prior to Antora 2.2), set the following property in the playbook file:

[,yaml]
----
asciidoc:
  attributes:
    page-partial: false
----

The `page-partial` attribute will no longer be set globally.
Now you *must* set the `page-partial` attribute on any page you want to use in an include directive.
For example:

----
= Shared Page
:page-partial:

Page contents.
----

With the `page-partial` attribute set, you can safely refer to that page using the include directive:

----
\include::shared-page.adoc[]
----

Recall that the `page-partial` attribute in the included page instructs Antora to retain the AsciiDoc source until all pages have been converted.

// /docs/modules/page/pages/block-images.adoc
[[block-images.adoc]]
= Add Block Images
:colons: ::

On this page, you'll learn:

* [x] The structure of the AsciiDoc block image macro.
* [x] How to insert a block image using its resource ID.

== AsciiDoc block image macro

An AsciiDoc block image macro is used to embed the source file of an image into a partial or page.
The block image macro accepts the xref:resource-id.adoc[Antora resource ID] of PNG, JPG, SVG, and GIF (static and animated) image files as a value.

When Antora runs, the image file referenced by the block image macro is embedded and displayed as a discrete element in the published page.
For example, the SVG image below this paragraph is embedded in this page using the block image macro.

image::console.svg[]

=== Block image macro structure

<<ex-block-base>> shows the structure of a block image macro.

.Block image macro
[#ex-block-base]
----
This is a paragraph.

image::resource-id-of-target-image.ext[optional attribute,optional attribute] <.>

This is another paragraph.
----
<.> A block image is designated by two colons (`::`) after the macro name.
It's preceded by an empty line, entered on a line by itself, and then followed by an empty line.

At a minimum, a block image macro consists of the macro's prefix (`image::`), the resource ID of the target image, and a set of square brackets (`[]`).
include::image-resource-id-examples.adoc[tag=target-current-def]

Each part of the block image macro shown in <<ex-block-base>> is described in more detail below.

image{colons}::
An block image macro begins with the macro's name, `image`, followed by two colons (`::`).

resource ID of target image::
The image macro accepts the resource ID of an image source file as its value.
The value is entered directly after the second colon that follows the macro's name (`image::`).
How many of the target image's xref:resource-id-coordinates.adoc[resource ID coordinates] you need to specify depends on the component version and module of the target image in relation to the current page.
When referencing an image from an image macro, you don't need to include the `image$` family coordinate in the target image's resource ID.
It's applied automatically at runtime.

[#attribute]
[optional attribute,optional attribute]::
The block image macro is completed with a set of square brackets (`[]`) at the end of the target image's resource ID.
You can leave the brackets empty, or assign one or more optional attributes as a comma-separated list inside the square brackets.

The next section, <<insert-image>>, explains how to set up an block image macro step-by-step.

[#insert-image]
== Embed a block image

Let's break down the block image macro and resource ID coordinates you need to insert an image (the <<target,target image>>) into a page (the <<current,current page>>) using the block image macro.

. In your IDE or text editor, open the page where you want to insert an image.
For this exercise, we've opened the file [.path]_satellites.adoc_.
[.path]_satellites.adoc_ is the current page.
. In [.path]_satellites.adoc_, let's embed the block image [.path]_console.svg_.

. At the beginning of a new line, enter the macro's name followed by two colons, `image::`.
Make sure there is a blank line between the previous element, such as a paragraph or source block, and the line where you place the image macro.
+
.satellites.adoc (current page)
[listing,subs=+quotes]
----
After scanning your badge, you should see this screen.

**image::**
----

. Enter the resource ID of the target image file directly after the two colons.
In this example, both [.path]_console.svg_ and [.path]_satellites.adoc_ belong to the same component version and module and the target image is stored at the root of the [.path]_images_ family directory.
Therefore, only the filename and extension of [.path]_console.svg_ needs to be assigned as the value of the block image macro.
+
--
.satellites.adoc (current page)
[listing,subs=+quotes]
----
After scanning your badge, you should see this screen.

image::**console.svg**
----

Notice that the resource ID for [.path]_console.svg_ doesn't include its family coordinate.
Antora automatically applies the `image$` family coordinate to a resource ID assigned to an image macro.
--

. Directly after the resource ID of the target image, enter an opening square bracket (`[`) and then a closing square bracket (`]`).
+
--
.satellites.adoc (current page)
[listing,subs=+quotes]
----
After scanning your badge, you should see this screen.

image::console.svg**[]**
----

We didn't apply any optional attributes to the block image macro in this example; however, you can specify one or more attributes as a comma-separated list inside the square brackets.
--

. Press kbd:[Enter] twice after the last square bracket (`]`) to insert a new line after the image macro.
+
.satellites.adoc (current page)
[listing]
----
After scanning your badge, you should see this screen.

image::console.svg[]

Enter the satellite position after the prompt.
----

That's it!
You've finished inserting the target image ([.path]_console.svg_) into the current page ([.path]_satellites.adoc_) using the AsciiDoc block image macro.

== Learn more

To learn how to embed images that belong to other modules, docs components, and versions, see xref:image-resource-id-examples.adoc[Image resource ID examples].

// /docs/modules/page/pages/inline-images.adoc
[[inline-images.adoc]]
= Add Inline Images
:colon: :

On this page, you'll learn:

* [x] The structure of the AsciiDoc inline image macro.
* [x] How to insert an inline image using its resource ID.

== AsciiDoc inline image macro

An AsciiDoc inline image macro is used to embed the source file of an image into a partial or page.
The inline image macro accepts the xref:resource-id.adoc[Antora resource ID] of PNG, JPG, SVG, and GIF (static and animated) image files as a value.

When Antora runs, the image file referenced by the inline image macro is embedded in the flow of another element, such as a sidebar block, and displayed in the published page.
For example, this is an SVG image image:blue-dot.svg[] that's embedded in this paragraph using the inline image macro.

=== Inline image macro structure

<<ex-inline-base>> shows the structure of an inline image macro.

.Inline image macro
[#ex-inline-base]
----
This sentence contains an inline image:resource-id-of-target-image.ext[optional attribute,optional attribute] image. <.>
----
<.> An inline image is entered into the flow of the content.
It's designated by a single colon (`:`) after the macro name.

At a minimum, an inline image macro consists of the macro's prefix (`+image:+`), the resource ID of the target image, and a set of square brackets (`[]`).
include::image-resource-id-examples.adoc[tag=target-current-def]

Each part of the inline image macro shown in <<ex-inline-base>> is described in more detail below.

image{colon}::
An inline image macro begins with the macro's name, `image`, followed by a single colon (`:`).

resource ID of target image::
The image macro accepts the resource ID of an image source file as its value.
The value is entered directly after the colon that follows the macro's name (`+image:+`).
How many of the target image's xref:resource-id-coordinates.adoc[resource ID coordinates] you need to specify depends on the component version and module of the target image in relation to the current page.
When referencing an image from an image macro, you don't need to include the `image$` family coordinate in the target image's resource ID.
It's applied automatically at runtime.

[#attribute]
[optional attribute,optional attribute]::
The inline image macro is completed with a set of square brackets (`[]`) at the end of the target image's resource ID.
You can leave the brackets empty, or assign one or more optional attributes as a comma-separated list inside the square brackets.

The next section, <<insert-image>>, explains how to set up an inline image macro step-by-step.

[#insert-image]
== Embed an inline image

Let's break down the inline image macro and resource ID coordinates you need to insert an image (the <<target,target image>>) into a page (the <<current,current page>>) using the inline image macro.

. In your IDE or text editor, open the page where you want to insert an image.
For this exercise, we've opened the file [.path]_satellites.adoc_.
[.path]_satellites.adoc_ is the current page.
. In [.path]_satellites.adoc_, let's embed the inline image [.path]_blue-dot.svg_.
Select the place in the content flow of the current page where you want the target image to be displayed.
Enter the macro's name followed by one colon (`+image:+`).
+
.satellites.adoc (current page)
[listing,subs=+quotes]
----
Look for the *image:*
----

. Enter the resource ID of the target image file directly after the colon.
In this example, both [.path]_blue-dot.svg_ and [.path]_satellites.adoc_ belong to the same component version and module and the target image is stored at the root of the [.path]_images_ family directory.
Therefore, only the filename and extension of [.path]_blue-dot.svg_ needs to be assigned as the value of the inline image macro.
+
--
.satellites.adoc (current page)
[listing,subs=+quotes]
----
Look for the image:**blue-dot.svg**
----

Notice that the resource ID for [.path]_blue-dot.svg_ doesn't include its family coordinate.
Antora automatically applies the `image$` family coordinate to a resource ID assigned to an image macro.
--

. Directly after the resource ID of the target image, enter an opening square bracket (`[`) and then a closing square bracket (`]`).
+
--
.satellites.adoc (current page)
[listing,subs=+quotes]
----
Look for the image:blue-dot.svg**[]**
----

We didn't apply any optional attributes to the inline image macro in this example; however, you can specify one or more attributes as a comma-separated list inside the square brackets.
--

. Press the kbd:[SPACE] bar once after the last square bracket (`]`) to insert a space after the macro, then continue entering your content.
+
.satellites.adoc (current page)
[listing]
----
Look for the image:blue-dot.svg[] on the console.
----

That's it!
You've finished inserting the target image ([.path]_blue-dot.svg_) into the current page ([.path]_satellites.adoc_) using the AsciiDoc inline image macro.

== Learn more

To learn how to embed images that belong to other modules, docs components, and versions, see xref:image-resource-id-examples.adoc[Image resource ID examples].

// /docs/modules/page/pages/image-resource-id-examples.adoc
[[image-resource-id-examples.adoc]]
= Image Resource ID Examples

You can insert an image into any page in your site, regardless of the module or component version to which the target image file belongs.
On this page, you'll learn how to assign the correct resource ID coordinates to an image macro based on the version, component, and module the image belongs to in relation to the page where you want to embed it.

[NOTE]
====
For an overview of the block image macro and inline image macro and step-by-step instructions on how to add them to a page, see:

* xref:block-images.adoc[]
* xref:inline-images.adoc[]

If you aren't familiar with the Antora resource ID or its coordinates, see:

* xref:resource-id.adoc[]
* xref:resource-id-coordinates.adoc[]
====

TIP: All of the examples on this page, regardless of the image macro they use to demonstrate a concept, apply to both the xref:block-images.adoc[block image macro] and xref:inline-images.adoc[inline image macro].

== Use an image within a module

Most of the images you reference with an image macro will probably belong to the xref:ROOT:module-directories.adoc#module[same module] and xref:ROOT:component-version.adoc[component version] as the current page.
In such circumstances, the AsciiDoc image macros only require the xref:resource-id-coordinates.adoc#id-resource[file coordinate] of the target image's resource ID be assigned as a value.

[NOTE]
====
// tag::target-current-def[]
[[target]]The [.term]*target image* is the image source file that's being referenced by the current page.
The target image is referenced by assigning its resource ID to an inline or block image macro in the content of the current page.
[[current]]The [.term]*current page* is the page source file containing the image macro that references the target image.
// end::target-current-def[]
====

The structure of the target image's file coordinate varies depending on whether the target image is stored at the root of the [.path]_images_ family directory or in a subdirectory of the [.path]_images_ directory.

.current-page.adoc
[#ex-file]
----
image:target-image-filename.ext[optional attribute] <.>

image:path/to/target-image-filename.ext[optional attribute] <.>

image:./target-image-filename.ext[optional attribute] <.>
----
<.> File coordinate of the target image when it's stored at the root of the [.path]_images_ directory.
<.> File coordinate of the target image when it's stored in a subdirectory of the [.path]_images_ directory.
<.> File coordinate of the target image when the target image and current page are stored in a subdirectory with the same family-relative directory path.
_This is an advanced use case._

The following sections provide examples showing the different file coordinate structures.

[#images-root]
=== File coordinate at images directory root

When the target image is stored at the root of the [.path]_images_ family directory, the file coordinate is the target image's filename and file extension.
Remember, the file coordinate of the target image is always calculated from the root of the [.path]_images_ family directory.

.File coordinate in an image macro when the target image is stored at the root of an images directory
[#ex-image-base]
----
image::target-image-filename.ext[optional attribute]
----

Let's use the files that belong to the component version _colorado 5.2_ as the basis for the example in this section.
The component version's source files are assigned to modules and families based on the xref:ROOT:standard-directories.adoc[set of standard directories] listed in <<ex-co>>.

.Directories and files assigned to colorado 5.2
[listing#ex-co]
----
📄 antora.yml <.>
📂 modules
  📂 la-garita <.>
    📂 images <.>
      📄 wilderness-map.jpg
    📂 pages <.>
      📄 ridge.adoc
----
<.> Defines the component version as _colorado 5.2_
<.> Defines a module named _la-garita_
<.> Defines subsequent files as images
<.> Defines subsequent files as pages

Using the two files that belong to the _la-garita_ module, shown in <<ex-co>> above, let's insert the [.path]_wilderness-map.jpg_ image into the [.path]_ridge.adoc_ page.
That means the source file [.path]_wilderness-map.jpg_ is the target image and [.path]_ridge.adoc_ is the current page.

<<ex-image>> shows a block image macro in the [.path]_ridge.adoc_ page (current page) that references, the [.path]_wilderness-map.jpg_ image (target image).
When the target image and current page belong to the same module, only the file coordinate of the target image's resource ID needs to be entered in the image macro.

.ridge.adoc (current page)
[#ex-image]
----
The trailhead is north of town.

image::wilderness-map.jpg[]
----

In <<ex-image>>, the file coordinate for the [.path]_wilderness-map.jpg_ image is `wilderness-map.jpg`.
Its file coordinate consists solely of its filename and file extension because [.path]_wilderness-map.jpg_ is stored at the root of the [.path]_images_ directory.

If the target image is stored in a subdirectory of the [.path]_images_ directory, its file coordinate must specify the __images__-relative directory path, filename, and file extension.
See <<relative-path>> for file coordinate examples when the target image is stored in a subdirectory.

[#relative-path]
=== File coordinate with images-relative directory path

The __images__-relative directory path of the <<target,target image>> is required in its file coordinate when it's stored in a subdirectory of the [.path]_images_ directory.

.File coordinate in an image macro when the target image is stored in a subdirectory of an images directory
[#ex-subdir-base]
----
image::path/to/target-image-filename.ext[optional attribute]
----

Let's use the pages that belong to the component version shown in <<ex-co-subdir>> as the basis for the examples in this section.

.Directories and files assigned to colorado 5.2
[listing#ex-co-subdir]
----
📄 antora.yml <.>
📂 modules
  📂 la-garita <.>
    📂 images <.>
      📂 aerial <.>
        📄 skyline.jpg
    📂 pages <.>
      📄 ridge.adoc
----
<.> Defines the component version as _colorado 5.2_
<.> Defines a module named _la-garita_
<.> Defines subsequent files as images
<.> A subdirectory in _images_ containing the source files of images
<.> Defines subsequent files as pages

Let's reference [.path]_skyline.jpg_ from [.path]_ridge.adoc_.
As you can see in <<ex-co-subdir>> above, the image and page belong to the _la-garita_ module.
In <<ex-subdir>>, an image macro in the [.path]_ridge.adoc_ page (current page) references the [.path]_skyline.jpg_ image (target image).

.ridge.adoc (current page)
[#ex-subdir]
----
= La Garita Ridgeline

image::aerial/skyline.jpg[]
----

As shown in <<ex-subdir>>, the file coordinate for [.path]_skyline.jpg_ is `aerial/skyline.jpg`.
The file coordinate for [.path]_skyline.jpg_ consists of its [.path]__images__-relative directory path, filename, and file extension because it's stored in the subdirectory [.path]_aerial_.

TIP: In special circumstances where the __images__-relative directory path of the target image and the __pages__-relative directory path of the current page are parallel, the __images__-relative directory path of the file coordinate can be replaced with the relative path token, `./`.

//[#use-image-across-modules]
[#modules]
== Use an image from another module

When the <<target,target image>> and <<current,current page>> don't belong to the same module, you must specify the target image's xref:resource-id-coordinates.adoc#id-module[module coordinate] and xref:resource-id-coordinates.adoc#id-resource[file coordinate] in the image macro.

.Module and file coordinates assigned to an image macro
[#ex-module-base]
----
image:module:target-image-filename.ext[optional attribute] <.>

image:module:path/to/target-image-filename.ext[optional attribute] <.>
----
<.> The image macro is assigned the module coordinate and file coordinate of the target image when the target image doesn't belong to the same module as the current page.
The target image's file coordinate is its filename and file extension when the target image is <<images-root,stored at the root of an _images_ family directory>>.
<.> If <<relative-path,the target image is stored in a subdirectory of an _images_ directory>>, the target image's file coordinate must specify its __images__-relative directory path, filename, and file extension.

Let's use the files that belong to the component version shown in <<ex-co-mod>> as the basis for the examples in this section.

.Directories and files assigned to colorado 5.2
[listing#ex-co-mod]
----
📄 antora.yml <.>
📂 modules
  📂 la-garita <.>
    📂 images <.>
      📂 aerial <.>
        📄 skyline.jpg
    📂 pages <.>
      📄 ridge.adoc
      📄 willow-creek.adoc
  📂 ROOT <.>
    📂 images <.>
      📄 peak.svg
    📂 pages <.>
      📄 index.adoc
      📄 ranges.adoc
----
<.> Defines the component version as _colorado 5.2_
<.> Defines a module named _la-garita_
<.> Defines subsequent files as images
<.> A subdirectory in _images_ containing the source files of images
<.> Defines subsequent files as pages
<.> Defines the _ROOT_ module
<.> Defines subsequent files as images
<.> Defines subsequent files as pages

From the _colorado 5.2_ component version, shown in <<ex-co-mod>> above, let's insert the [.path]_peak.svg_ image into the [.path]_willow-creek.adoc_ page.
That means the source file [.path]_peak.svg_ is the target image and [.path]_willow-creek.adoc_ is the current page.

<<ex-module>> shows an inline image macro in [.path]_willow-creek.adoc_ (current page) that references the image file [.path]_peak.svg_ (target image).
The module and file coordinates of the target image's resource ID are assigned to the image macro.
The [.path]_willow-creek.adoc_ page belongs to the _la-garita_ module.
The [.path]_peak.svg_ image belongs to the _ROOT_ module.

.Insert peak.svg (target image) into willow-creek.adoc (current page)
[#ex-module]
----
The elevation is image:ROOT:peak.svg[] 10,067 ft (3,068 m).
----

As shown in <<ex-module>>, the target image's module coordinate is `ROOT` and its file coordinate is `peak.svg`.

In <<ex-module-subdir>>, let's embed the [.path]_skyline.jpg_ image (target image) into [.path]_ranges.adoc_ (current page).
The [.path]_skyline.jpg_ image belongs to the _la-garita_ module and [.path]_ranges.adoc_ belongs to the _ROOT_ module.

.Insert skyline.jpg (target image) into ranges.adoc (current page)
[#ex-module-subdir]
----
image::la-garita:aerial/skyline.jpg[]
----

As shown in <<ex-module-subdir>>, the target image's module coordinate is `la-garita` and its file coordinate is `aerial/skyline.jpg` because it's stored in the [.path]_aerial_ subdirectory of the [.path]_images_ family directory.

//[#use-image-in-different-docs-component]
[#component-versions]
== Use an image from another docs component

When the <<target,target image>> and <<current,current page>> belong to different documentation components, you must specify, at a minimum, the target image's xref:resource-id-coordinates.adoc#id-component[component, module, and file coordinates] in the image macro.
You'll almost always specify the version coordinate, too.

.Version, component, module, and file coordinates assigned to an image macro
[#ex-component-version-base]
----
image:version@component:module:target-image-filename.ext[optional attribute] <.>

image:version@component:module:path/to/target-image-filename.ext[optional attribute] <.>

image:component:module:file-coordinate-of-target-image.ext[optional attribute] <.>
----
<.> The image macro is assigned the version, component, module, and file coordinates of the target image when the target image and current page don't belong to the same component version.
The target image's file coordinate is its filename and file extension when the target image is <<images-root,stored at the root of an _images_ family directory>>.
<.> If <<relative-path,the target image is stored in a subdirectory of an _images_ directory>>, the target image's file coordinate must specify its __images__-relative directory path, filename, and file extension.
<.> If the version coordinate isn't specified, Antora uses the <<latest-version,latest version of the target image's component>> to complete the resource ID at runtime.
This behavior only applies when the target image and current page belong to different docs components.

Let's use the files that belong to the component versions _colorado 5.2_ (<<ex-co-v>>) and _wyoming 1.0_ (<<ex-wy>>) as the basis for the example in this section.

.Directories and files assigned to colorado 5.2
[listing#ex-co-v]
----
📄 antora.yml <.>
📂 modules
  📂 ROOT <.>
    📂 images <.>
      📄 peak.svg
    📂 pages <.>
      📄 index.adoc
      📄 ranges.adoc
----
<.> Defines the component version as _colorado 5.2_
<.> Defines the _ROOT_ module
<.> Defines subsequent files as images
<.> Defines subsequent source files as pages

.Directories and files assigned to wyoming 1.0
[listing#ex-wy]
----
📄 antora.yml <.>
📂 modules
  📂 sierra-madre <.>
    📂 images <.>
      📄 panorama.png
    📂 pages <.>
      📄 elevation.adoc
      📄 wilderness-areas.adoc
----
<.> Defines the component version as _wyoming 1.0_
<.> Defines a module named _sierra-madre_
<.> Defines subsequent files as images
<.> Defines subsequent files as pages

Using files from <<ex-co-v>> and <<ex-wy>>, let's insert [.path]_panorama.png_ (target image) into [.path]_ranges.adoc_ (current page).
The image [.path]_panorama.png_ belongs to the _sierra-madre_ module of _wyoming 1.0_.
In <<ex-across-components>>, the resource ID assigned to the image macro specifies the version, component, module, and file coordinates of the target image because the target image belongs to the _wyoming 1.0_ component version whereas the current page belongs to _colorado 5.2_.

.Insert panorama.png (target image) as a block image into ranges.adoc (current page)
[#ex-across-components]
----
image::1.0@wyoming:sierra-madre:panorama.png[]
----

As shown in <<ex-across-components>>, the target image's version coordinate is `1.0`, its component coordinate is `wyoming`, its module coordinate is `sierra-madre`, and its file coordinate is `panorama.png`.

Now, in <<ex-across-components-root>>, let's insert [.path]_peak.svg_ (target image) into [.path]_wilderness-areas.adoc_ (current page).
The [.path]_peak.svg_ image belongs to the component version _colorado 5.2_.
The [.path]_wilderness-areas.adoc_ page belongs to the component version _wyoming 1.0_.

.wilderness-areas.adoc (current page)
[#ex-across-components-root]
----
image:5.2@colorado::peak.svg[] Bridger Peak is in the Sierra Madre range.
----

Notice in <<ex-across-components-root>> that the module coordinate `ROOT` seems to be missing from the resource ID.
When a component coordinate is specified in a resource ID, and the target image belongs to the _ROOT_ module, the module coordinate `ROOT` doesn't have to be explicitly specified.
But you must still enter the colon (`:`) that would follow the module coordinate.
You can see this `:` directly before the file coordinate `peak.svg`.
This shorthand only works when a component coordinate is specified and the module coordinate of the target image is `ROOT`.
In all other cases where the module coordinate is required, the name of the module must be specified.

You may have noticed that the version coordinate is specified in both <<ex-across-components>> and <<ex-across-components-root>>.
If you don't specify the version, Antora will complete the resource ID of the target image using the version coordinate of the target image's latest component version at runtime.

//[#use-latest-version-of-image]
[#latest-version]
=== Use the latest version of an image

TIP: This behavior only applies when the target image and current page belong to different docs components!

If a version isn't specified in the resource ID, *and the target image and current page belong to different documentation components*, Antora uses the version coordinate of the xref:ROOT:how-component-versions-are-sorted.adoc#latest-version[latest version] of the target image's component to complete the resource ID at runtime.

Let's use the files that belong to _colorado 5.2_ (<<ex-co-v>> in the previous section), _wyoming 1.0_ (<<ex-wy>> in the previous section), and _wyoming 1.5_ (<<ex-wy-latest>> below) as the basis for the example in this section.

.Directories and files assigned to wyoming 1.5
[listing#ex-wy-latest]
----
📄 antora.yml <.>
📂 modules
  📂 sierra-madre
    📂 images
      📄 panorama.png
    📂 pages
      📄 elevation.adoc
      📄 wilderness-areas.adoc
----
<.> Defines the component version as _wyoming 1.5_

Let's reference the [.path]_panorama.png_ image (target image) from [.path]_index.adoc_ (current page).
[.path]_index.adoc_ belongs to the _colorado 5.2_ component version .
There are two files named [.path]_panorama.png_ that belong to the _wyoming_ component, _sierra-madre_ module, and _images_ family.
One [.path]_panorama.png_ belongs to version _1.0_, the other [.path]_panorama.png_ to version _1.5_.

<<ex-across-components-latest>> shows a block image macro referencing [.path]_panorama.png_ (target image) from [.path]_index.adoc_ (current page).
Notice that the target image's version coordinate isn't specified.

.index.adoc (current page)
[#ex-across-components-latest]
----
image::wyoming:sierra-madre:panorama.png[]
----

When Antora runs, it will identify _wyoming 1.5_ as the latest version of the _wyoming_ component according to its xref:ROOT:how-component-versions-are-sorted.adoc#version-sorting-rules[version sorting rules] and xref:ROOT:how-component-versions-are-sorted.adoc#latest-version[latest version criteria].
Because a version coordinate isn't specified in <<ex-across-components-latest>>, Antora will complete the resource ID assigned to the image macro using the version coordinate -- `1.5` -- of the latest _wyoming_ component.

WARNING: This behavior of linking to the latest version only applies when the version coordinate is unspecified and the target image and current page belong to different components.
If the version and component coordinates aren't specified in the resource ID, Antora assumes the target image belongs to the same component version as the current page and uses the current page's version and component coordinates to complete the target image's resource ID.

//[#use-image-in-different-version]
[#versions]
== Use an image from another version of its component

When the <<current,current page>> and <<target,target image>> belong to the same component, but the target image belongs to a different version of the component, you'll specify the version, module (if it's different than the current page's module), and file coordinates.

.current-page.adoc
[#ex-version-base]
----
image:version@module:file-coordinate-of-target-image.ext[optional attribute] <.>

image:version@file-coordinate-of-target-image.ext[optional attribute] <.>
----
<.> The image macro is assigned the version, module, and file coordinates of the target image when the target image doesn't belong to the same version and module as the current page.
<.> The image macro is assigned the version and file coordinates of the target image when the target image doesn't belong to the same version as the current page.

Let's use the files that belong to the component version _colorado 5.2_ (<<ex-co5>>) and the component version _colorado 6.0_ (<<ex-co6>>) as the basis for the example in this section.

.Directories and files assigned to colorado 5.2
[listing#ex-co5]
----
📄 antora.yml <.>
📂 modules
  📂 la-garita
    📂 images
      📄 wilderness-map.jpg
    📂 pages
      📄 index.adoc
      ...
----
<.> Defines the component version as _colorado 5.2_

.Directories and files assigned to colorado 6.0
[listing#ex-co6]
----
📄 antora.yml <.>
📂 modules
  📂 la-garita
    📂 pages
      📄 index.adoc
      📄 ridge.adoc
      📄 willow-creek.adoc
----
<.> Defines the component version as _colorado 6.0_

Notice that the _colorado 5.2_ component version in <<ex-co5>> has the image [.path]_wilderness-map.jpg_.
However, _colorado 6.0_, shown in <<ex-co6>>, has no such image file.

Let's reference the image [.path]_wilderness-map.jpg_ (target image), which belongs to _colorado 5.2_, from the [.path]_ridge.adoc_ page (current page) that belongs to the _colorado 6.0_ component version.
Both resources belong to the _la-garita_ module.
In <<ex-across-versions>>, the image [.path]_wilderness-map.jpg_ (target image) is embedded in the page [.path]_ridge.adoc_ (current page).

.ridge.adoc (current page) in colorado 6.0
[#ex-across-versions]
----
image::5.2@wilderness-map.jpg[]
----

As shown in <<ex-across-versions>>, the target image's version coordinate is `5.2` and its file coordinate is `wilderness-map.jpg`.

////
This needs to either become its own page or be added as section to another page

== Apply attributes to an image

The brackets can contain an list of attributes such as alt text, width, or height.
Attributes are optional.
The attributes are entered as key=value pairs separated by commas.
To add alt text to the image, enter the information between the square brackets (`+[]+`).
+
[subs=+quotes]
----
image::name-of-file.ext**[This is the alt text for this image]**
----
////

// /docs/modules/page/pages/image-xref-and-link.adoc
[[image-xref-and-link.adoc]]
= Resource Links From Images
// URLs
:url-element-id: {url-asciidoc}/attributes/id/
:url-image-attributes: {url-asciidoc}/macros/image-ref/

You can create a link from an image to a page, attachment, image, or element by assigning the `xref` attribute to an inline or block image macro.

== Xref element attribute

The `xref` element attribute can be set in the attribute list of block and inline image macros.
The `xref` attribute is optional.
It's structured and behaves the same way regardless of whether you assign it to a block image macro or inline image macro.

The `xref` attribute accepts the resource ID of a publishable resource--a page, attachment, or image--as a value.

.Set the xref attribute and assign it a resource ID
[#ex-resource-base]
----
image::an-image.jpg[xref=version@component:module:family$file.ext]
----

It also accepts the ID of an element that's specified in the current page.
The element ID must be prefixed with the hash symbol (`#`) when assigned to the `xref` attribute.

.Set the xref attribute and assign is an element ID
[#ex-element-base]
----
image::an-image.gif[xref=#fragment]
----

When your site is published and a visitor selects the embedded image, they'll be linked to the URL of the published resource or jump to the anchor in the current published page that corresponds to the specified element ID.

The `xref` attribute in a named attribute.
If you set positional attributes, such as alt text, width, or height, on the image macro, assign them in the attribute list before setting the `xref` or any other named attributes.

.Optional positional and named attributes assigned to an image macro
[#ex-attributes-base]
----
image:an-image.svg[The image alt text,xref=version@component:module:family$file.ext,title="A tooltip for the image"]
----

Positional and named element attributes are separated by commas in the attribute list of the image macros.

[#page]
== Link to a page from an image

To reference a page from an embedded image, set the `xref` attribute in the attribute list, followed by an equals sign (`=`), and then the resource ID of the target page.
How many of the target page's xref:resource-id-coordinates.adoc[resource ID coordinates] you need to specify depends on the component version and module of the target page in relation to the current page.

.current-page.adoc
[#ex-page]
----
image::console.svg[xref=modes.adoc] <.>
----
<.> The resource ID assigned to `xref` only specifies the file coordinate of the page because, for this example, let's assume the current page and target page belong to the same component version and module.

The block image macro shown in <<ex-page>> will embed the image _console.svg_ into the current page and create a link from the image to the published URL of the target page.

You can also xref:xref.adoc#id-fragment[append a fragment] to the end of the page's resource ID to link to an element within the page.
In <<ex-fragment>>, a fragment that corresponds to the element ID `protocols` that's set in the content of [.path]_modes.adoc_ is appended to the end of the resource ID for [.path]_modes.adoc_.

.current-page.adoc
[#ex-fragment]
----
image::console.svg[xref=modes.adoc#protocols]
----

You can also link to an <<deep-link,element ID in the current page>>.

[#attachment]
== Link to an attachment from an image

To reference an attachment from an embedded image, set the `xref` attribute in the attribute list, followed by an equals sign (`=`), and then the resource ID of the target attachment.
Make sure the family coordinate, `attachment$`, is specified in the value assigned to the `xref` attribute.

<<ex-attachment>> shows an inline image macro with three positional attributes set in the macro's attribute list, followed by the named `xref` attribute.
The `xref` attribute is assigned the resource ID of an attachment.

.current-page.adoc
[#ex-attachment]
----
Select the image:red-dot.jpg[Red circle,40,40,xref=telemetry:attachment$flight-patterns.pdf]. <1> <2>
----
<1> Positional attributes are optional.
If you do set one or more positional attributes on an image macro, assign them in the attribute list before setting `xref` or any other named attributes.
In this example, the positional attributes `alt`, `width`, and `height` are set in the order accepted by the image macros.
<2> The resource ID assigned to `xref` specifies the module, `attachment$`, and file coordinate of the target attachment because, for this example, let's assume the target attachment belongs to a different module than the current page.
The `attachment$` coordinate is always required when the resource is an attachment.

The inline image macro shown in <<ex-attachment>> will embed the image _red-dot.jpg_ into the current page and create a link from the image to the published URL of the target attachment.

[#deep-link]
== Deep link to an element in the current page from an image

To reference an element in the current page, assign the ID of the element to the `xref` attribute.
Prefix the element ID with the hash symbol (`#`) when you assign it to the `xref` attribute.
<<ex-element>> shows a block image macro with an `xref` attribute assigned an element ID that corresponds to an ID on the current page.

.current-page.adoc
[#ex-element]
----
image::panorama.png[xref=#elevation] <.>

The range can be traversed by Cottonwood Pass, Independence Pass, or Hagerman Pass.

[#elevation] <.>
== Pass elevations

The passes usually open in late spring.
----
<.> Set the `xref` attribute in the attribute list, followed by an equals sign (`=`), the hash symbol (`#`), and then an element ID that corresponds to the ID assigned to an element in the current page.
<.> An element ID set on and assigned to a section in the current page.

The block image macro shown in <<ex-element>> will embed the image _panorama.png_ into the current page and create a link from the image to the beginning of the section _Pass elevations_ on the current page.

[#link-self]
== Link to the image itself to open it in its original size

To allow opening an image in its original, unconstrained size (in html output), add the `link=self` attribute.

[#ex-link-self]
----
image::panorama.png[link=self]
----

== Learn more

Refer to the AsciiDoc documentation for {url-image-attributes}[additional image macro attributes^] and more information about {url-element-id}[element IDs^].

// /docs/modules/page/pages/include-a-partial.adoc
[[include-a-partial.adoc]]
= Include a Partial
:page-aliases: asciidoc:include-partial.adoc
// URLs
:url-include: {url-asciidoc}/directives/include/
:url-tags: {url-asciidoc}/directives/include-tagged-regions/
:url-leveloffset: {url-asciidoc}/directives/include-with-leveloffset/

A partial can be inserted into any page or another partial in your site using the AsciiDoc include directive and the partial's resource ID.

[NOTE]
====
If you aren't familiar with the Antora resource ID and its coordinates, see:

* xref:resource-id.adoc[]
* xref:resource-id-coordinates.adoc[]
====

== AsciiDoc include directive for partials

An AsciiDoc include directive inserts content from a partial's source file into another partial or a page.
The include directive accepts the xref:resource-id.adoc[Antora resource ID] of partials, examples, and pages as a value.

Although a partial is typically an AsciiDoc fragment, a partial can be any text document with no restriction on the file's extension.
If the partial is not AsciiDoc, you have to be sure you're inserting into a place in the AsciiDoc document that accepts non-AsciiDoc content, such as a diagram block, a code block, or CSV table.
If the partial is a code example, you're encouraged to store it as an example rather than a partial since an example is a specialized form of a partial.
This page focuses on partials which are AsciiDoc files.

<<ex-base>> shows the structure of an include directive with the fully qualified resource ID of a partial.
Because the include directive is used to reference other resources, the `partial$` family coordinate must be specified in the partial's resource ID when it's assigned to an include directive.

.Include directive assigned the fully qualified resource ID of a partial
[#ex-base]
----
\include::version@component:module:partial$file-coordinate-of-target-partial.adoc[optional attribute]
----

At a minimum, an include directive consists of the directive's prefix (`include::`), the resource ID of the target partial, and a set of square brackets (`[]`).
You can specify optional attributes within the square brackets as key-value pairs separated by commas.
[[target]]The [.term]*target partial* is the source file of a partial that's being referenced by the current page.
The target partial is referenced by assigning its resource ID to an include directive in the content of the current page.
[[current]]The [.term]*current page* is the page source file containing the include directive that references the target partial.

When Antora runs, content from the target partial is inserted into the current page <<placement,at the location where the include directive is entered>>.
The target partial's content is converted after it's inserted into the current page.
This means the current page's component version, module, attributes, and other elements are applied to or may impact the content included from the target partial.
See xref:partials.adoc#current-context[Current page context and structure] to learn more.

[#partials-root]
== Insert a partial into a page

Let's break down the AsciiDoc include directive and resource ID coordinates you need to insert a <<target,target partial>> into the <<current,current page>>.

. In your IDE or plain text editor, open the page where you want to insert the partial.
For this step and the subsequent steps, let's assume you've opened the file [.path]_ranges.adoc_.
+
--
.ranges.adoc (current page)
----
= Hike the Ranges

== Terrain

Above the treeline, the trail becomes a hard scramble.
----

The current page, [.path]_ranges.adoc_, belongs to the component version _colorado 5.2_ and module _ROOT_, shown in <<ex-co>>.

.Directories and files assigned to colorado 5.2
[listing#ex-co]
----
📄 antora.yml <.>
📂 modules
  📂 ROOT <.>
    📂 pages <.>
      📄 index.adoc
      📄 ranges.adoc
    📂 partials <.>
      📄 treeline-warning.adoc
----
<.> Defines the component version as _colorado 5.2_
<.> Defines the _ROOT_ module
<.> Defines subsequent files as pages
<.> Defines subsequent files as partials
--

. In the current page, select the line where you want the partial's content to be inserted.
At the beginning of the line, enter the name of the directive followed by two colons, `include::`.
+
.ranges.adoc (current page)
[listing,subs=+quotes]
----
Above the treeline, the trail becomes a hard scramble.

**include::**
----

. Let's reference the target partial, [.path]_treeline-warning.adoc_, from the current page.
Assign the resource ID of the target partial to the include directive.
Both [.path]_treeline-warning.adoc_ and [.path]_ranges.adoc_ belong to the same component version and module (see <<ex-co>>).
Therefore, only the `partial$` family coordinate and file coordinate of the target partial need to be specified.
+
--
.ranges.adoc (current page)
[listing,subs="+quotes"]
----
Above the treeline, the trail becomes a hard scramble.

include::**partial$treeline-warning.adoc**
----

The file coordinate for the [.path]_treeline-warning.adoc_ partial is `treeline-warning.adoc`.
The target partial's file coordinate consists solely of its filename and file extension because [.path]_treeline-warning.adoc_ is stored at the root of the [.path]_partials_ directory.

NOTE: By default, the include directive assumes the family coordinate is `page$` when the coordinate isn't specified.
If you forget to use the `partial$` coordinate, Antora will report an error because it won't be able to find the partial.
--

. Directly after the resource ID of the target partial, complete the directive with a set of square brackets (`+[]+`).
+
--
.ranges.adoc (current page)
[listing,subs="+quotes"]
----
Above the treeline, the trail becomes a hard scramble.

include::partial$treeline-warning.adoc**[]**
----

The brackets of the include directive can contain an optional list of attributes, such as `lines`, `tag`, or `tags`.
Attributes are entered as key-value pairs separated by commas.
See the {url-include}[AsciiDoc include directive documentation^] for full details about the `lines`, `tag`, and `tags` syntax.
--

That's it!
You've created an include directive that will insert the target partial into the current page.

The preceding instructions showed you how to insert a partial into a page under the most common scenario--the target partial and current page belong to the same component version and module and the target partial is stored at the root of a [.path]_partials_ folder.
However, if the target partial is stored in a subdirectory of the [.path]_partials_ directory, its file coordinate must specify the <<relative-path,partials-relative directory path in addition to its filename and file extension>>.

.current-page.adoc
[#ex-file]
----
include::partial$target-partial-filename.adoc[] <.>

include::partial$path/to/target-partial-filename.adoc[] <.>

include::partial$./target-partial-filename.adoc[] <.>
----
<.> File coordinate of the target partial when it's stored at the root of the [.path]_partials_ directory.
<.> File coordinate of the target partial when it's stored in a subdirectory of the [.path]_partials_ directory.
<.> File coordinate of the target partial when the target partial and current page are stored in subdirectories with parallel family-relative directory paths.
_This is an advanced use case._

Also, you'll need to specify additional resource ID coordinates when the target partial and current page don't belong to the <<modules,same module>> or <<component-versions,component version>>.
The following sections provide examples showing the various resource ID scenarios.

[#relative-path]
=== File coordinate with partials-relative directory path

The __partials__-relative directory path of the <<target,target partial>> is required in its file coordinate when it's stored in a subdirectory of the [.path]_partials_ directory.

.File coordinate when the target partial is stored in a subdirectory of a partials directory
[#ex-subdir-base]
----
\include::partial$path/to/target-partial-filename.adoc[optional attribute]
----

Let's use the files that belong to the component version in <<ex-co-subdir>> as the basis for the example in this section.

.Directories and files assigned to colorado 5.2
[listing#ex-co-subdir]
----
📄 antora.yml <.>
📂 modules
  📂 la-garita <.>
    📂 pages <.>
      📄 ridge.adoc
    📂 partials <.>
      📂 climate <.>
        📄 gear-list.adoc
----
<.> Defines the component version as _colorado 5.2_
<.> Defines a module named _la-garita_
<.> Defines subsequent files as pages
<.> Defines subsequent files as partials
<.> A subdirectory in _partials_ containing the source files of partials

Let's reference [.path]_gear-list.adoc_ from [.path]_ridge.adoc_.
As you can see in <<ex-co-subdir>> above, the partial and page belong to the _la-garita_ module.
In <<ex-subdir>>, an include directive in the [.path]_ridge.adoc_ page (current page) references the [.path]_gear-list.adoc_ file (target partial).

.ridge.adoc (current page)
[#ex-subdir]
----
== Plan your hike

\include::partial$climate/gear-list.adoc[]
----

As shown in <<ex-subdir>>, the family coordinate is `partial$` and the file coordinate for [.path]_gear-list.adoc_ is `climate/gear-list.adoc`.
The file coordinate for [.path]_gear-list.adoc_ consists of its [.path]__partials__-relative directory path, filename, and file extension because it's stored in the subdirectory [.path]_climate_.

TIP: In special circumstances where the __partials__-relative directory path of the target partial and the __pages__-relative directory path of the current page are parallel, the __partials__-relative directory path can be replaced with the relative path token, `./`.

[#modules]
== Include a partial from another module

When the <<target,target partial>> and the <<current,current page>> don't belong to the same module, you must specify the target partial's xref:resource-id-coordinates.adoc#id-module[module], xref:resource-id-coordinates.adoc#id-family[family], and xref:resource-id-coordinates.adoc#id-resource[file coordinates] in the include directive.

.Module, family, and file coordinates assigned to an include directive
[#ex-module-base]
----
include::module:partial$target-partial-filename.adoc[optional attribute] <.>

include::module:partial$path/to/target-partial-filename.adoc[optional attribute] <.>
----
<.> Assign the module, `partial$`, and file coordinates of the target partial to the include directive when the target partial and current page belong to the same component version but not the same module.
The target partial's file coordinate is its filename and file extension when it's <<partials-root,stored at the root of a _partials_ family directory>>.
<.> If <<relative-path,the target partial is stored in a subdirectory of a _partials_ directory>>, the target partial's file coordinate must specify its __partials__-relative directory path, filename, and file extension.

Let's use the files that belong to the component version shown in <<ex-co-mod>> as the basis for the example in this section.

.Directories and files assigned to colorado 5.2
[listing#ex-co-mod]
----
📄 antora.yml <.>
📂 modules
  📂 la-garita <.>
    📂 pages <.>
      📄 ridge.adoc
  📂 ROOT <.>
    📂 partials <.>
      📄 treeline-warning.adoc
----
<.> Defines the component version as _colorado 5.2_
<.> Defines a module named _la-garita_
<.> Defines subsequent files as pages
<.> Defines a module named _ROOT_
<.> Defines subsequent files as partials

Let's insert the [.path]_treeline-warning.adoc_ partial into the [.path]_ridge.adoc_ page.
That means the source file [.path]_treeline-warning.adoc_ is the target partial and [.path]_ridge.adoc_ is the current page.
As shown in <<ex-co-mod>> above, the [.path]_ridge.adoc_ page belongs to the _la-garita_ module, and the [.path]_treeline-warning.adoc_ partial belongs to the _ROOT_ module.

<<ex-module>> shows an include directive in [.path]_ridge.adoc_ that references the partial [.path]_treeline-warning.adoc_.
The module, `partial$`, and file coordinates of the target partial are assigned to the include directive.

.ridge.adoc (current page)
[#ex-module]
----
\include::ROOT:partial$treeline-warning.adoc[]
----

As shown in <<ex-module>>, the target partial's module coordinate is `ROOT`, its family coordinate is `partial$`, and its file coordinate is `treeline-warning.adoc`.

[#component-versions]
== Include a partial from another component

When the <<target,target partial>> and <<current,current page>> don't belong to the same documentation component, specify the partial's xref:resource-id-coordinates.adoc#id-version[version, component, module, family, and file coordinates] in the resource ID assigned to the include directive.

.Version, component, module, family, and file coordinates assigned to an include directive
[#ex-component-version-base]
----
include::version@component:module:partial$target-partial-filename.adoc[] <.>

include::version@component:module:partial$path/to/target-partial-filename.adoc[] <.>

include::component:module:partial$file-coordinate-of-target-partial.adoc[] <.>
----
<.> Assign the version, component, module, family, and file coordinates of the target partial to the include directive when the target partial and current page don't belong to the same component version.
The target partial's file coordinate is its filename and file extension when the target partial is <<partials-root,stored at the root of a _partials_ family directory>>.
<.> If <<relative-path,the target partial is stored in a subdirectory of a _partials_ directory>>, the target partial's file coordinate must specify its __partials__-relative directory path, filename, and file extension.
<.> If the version coordinate isn't specified, Antora uses the <<latest-version,latest version of the target partial's component>> to complete the resource ID at runtime.
This behavior only applies when the target partial and current page belong to different docs components.

Let's use the files that belong to the component versions _colorado 5.2_ (<<ex-co-v>>) and _wyoming 1.0_ (<<ex-wy>>) as the basis for the example in this section.

.Directories and files assigned to colorado 5.2
[listing#ex-co-v]
----
📄 antora.yml <.>
📂 modules
  📂 ROOT <.>
    📂 pages <.>
      📄 index.adoc
    📂 partials <.>
      📄 treeline-warning.adoc
----
<.> Defines the component version as _colorado 5.2_
<.> Defines the _ROOT_ module
<.> Defines subsequent source files as pages
<.> Defines subsequent source files as partials

.Directories and files assigned to wyoming 1.0
[listing#ex-wy]
----
📄 antora.yml <.>
📂 modules
  📂 sierra-madre <.>
    📂 pages <.>
      📄 elevation.adoc
----
<.> Defines the component version as _wyoming 1.0_
<.> Defines a module named _sierra-madre_
<.> Defines subsequent files as pages

Using files from <<ex-co-v>> and <<ex-wy>>, let's reference [.path]_treeline-warning.adoc_ (target partial) from [.path]_elevation.adoc_ (current page).
The [.path]_treeline-warning.adoc_ partial belongs to the component version _colorado 5.2_.
The [.path]_elevation.adoc_ page belongs to the component version _wyoming 1.0_.

The include directive in <<ex-across-components>> will embed the content of the [.path]_treeline-warning.adoc_ partial into the [.path]_elevation.adoc_ page.

.elevation.adoc (current page)
[#ex-across-components]
----
\include::5.2@colorado:ROOT:partial$treeline-warning.adoc[]
----

As shown in <<ex-across-components>>, the target partial's version coordinate is `5.2`, its component coordinate is `colorado`, its module coordinate is `ROOT`, its family coordinate is `partial$`, and its file coordinate is `treeline-warning.adoc`.
You could also specify the resource ID for [.path]_treeline-warning.adoc_ as `5.2@colorado::partial$treeline-warning.adoc` (notice the module coordinate `ROOT` seems to be missing).
When the target partial's component coordinate is specified, and the target partial belongs to the _ROOT_ module, the module coordinate `ROOT` doesn't have to be explicitly specified.
However, you must still enter the colon (`:`) that would follow the module coordinate.
This shorthand only works when a component coordinate is specified and the module coordinate of the target partial is `ROOT`.

[#latest-version]
=== Use the latest version of a partial

TIP: This behavior only applies when the target partial and current page belong to different docs components!

If a version isn't specified in the resource ID assigned to an include directive, *and the target partial and current page don't belong to the same component*, Antora uses the version coordinate of the xref:ROOT:how-component-versions-are-sorted.adoc#latest-version[latest version] of the target partial's component to complete the resource ID at runtime.

Let's use the files that belong to the component versions _colorado 5.2_ (<<ex-co-latest>>), _wyoming 1.0_ (<<ex-wy1>>), and _wyoming 1.5_ (<<ex-wy-latest>>) as the basis for the example in this section.

.Directories and files assigned to colorado 5.2
[listing#ex-co-latest]
----
📄 antora.yml <.>
📂 modules
  📂 la-garita
    📂 pages
      📄 willow-creek.adoc
----
<.> Defines the component version as _colorado 5.2_

.Directories and files assigned to wyoming 1.0
[listing#ex-wy1]
----
📄 antora.yml <.>
📂 modules
  📂 sierra-madre
    📂 pages
      📄 elevation.adoc
    📂 partials
      📄 bears.adoc
----
<.> Defines the component version as _wyoming 1.0_

.Directories and files assigned to wyoming 1.5
[listing#ex-wy-latest]
----
📄 antora.yml <.>
📂 modules
  📂 sierra-madre
    📂 pages
      📄 elevation.adoc
    📂 partials
      📄 bears.adoc
----
<.> Defines the component version as _wyoming 1.5_

Let's reference the [.path]_bears.adoc_ partial (target partial) from the [.path]_willow-creek.adoc_ page (current page).
[.path]_willow-creek.adoc_ belongs to component version _colorado 5.2_.
There are two files named [.path]_bears.adoc_ that belong to the _wyoming_ component, _sierra-madre_ module, and _partials_ family.
One [.path]_bears.adoc_ belongs to version _1.0_, the other [.path]_bears.adoc_ to version _1.5_.

<<ex-across-components-latest>> shows an include directive referencing [.path]_bears.adoc_ (target partial) from [.path]_willow-creek.adoc_ (current page).
Notice that the target partial's version coordinate isn't specified.

.willow-creek.adoc (current page)
[#ex-across-components-latest]
----
\include::wyoming:sierra-madre:partial$bears.adoc[]
----

When Antora runs, it will identify _wyoming 1.5_ as the latest version of the _wyoming_ component according to its xref:ROOT:how-component-versions-are-sorted.adoc#version-sorting-rules[version sorting rules] and xref:ROOT:how-component-versions-are-sorted.adoc#latest-version[latest version criteria].
Because a version coordinate isn't specified in <<ex-across-components-latest>>, Antora will complete the resource ID assigned to the include directive using the version coordinate -- `1.5` -- from the latest _wyoming_ component.

WARNING: This behavior of linking to the latest version only applies when the version coordinate is unspecified and the target partial and current page belong to different components.
If the version and component coordinates aren't specified in the resource ID, Antora assumes the target partial belongs to the same component version as the current page and uses the current page's version and component coordinates to complete the target partial's resource ID.

[#placement]
== Include directive placement

An include directive is placed at the beginning of a new line.
The content from the target partial will be displayed as a standalone block when you enter an empty line above and below the include directive.
You can attach content from the target partial to a block in the current page by placing the include directive on a new line directly adjacent to the content to which it should be attached.

.current-page.adoc
----
A paragraph in the page.

include::partial$cli-options.adoc[tag=compass] <.>

A line of content.
include::partial$addendum.adoc[] <.>
Another line of content.
----
<.> To display the included content as a standalone block, make sure there is an empty line above the include directive and after the include directive.
<.> To attach the included content to a block in the current page, enter the include directive on a new line directly above, between, or below the content lines of the block.

[#include-diagram]
== Include diagram source

If you use diagrams in your pages that are generated from source, you may want to store the diagram's source in a separate file.
It's up to you whether to store that source as an example or partial.
Since the source is not a code example, a partial seems like the more logical place.

Create a folder under the partials directory and name it diagrams.
Then, store the source of your diagram in that folder.
Let's assume the file is named [.path]_partials/diagrams/my-schema.puml_.
You can now include that source into your page as follows:

.Include the source of a diagram
----
[plantuml,my-schema,svg]
....
\include::partial$diagrams/my-schema.puml[]
....
----

You can refer to diagram sources in other modules, versions, or components, just like with other partials.

== Learn more

* xref:include-an-example.adoc[]
* xref:include-a-page.adoc[]
* xref:resource-id.adoc[]

.*AsciiDoc and Asciidoctor resources*
* {url-leveloffset}[Offset section headings with leveloffset^]
* {url-tags}[Select regions of content with tags^]
* {url-include}[AsciiDoc include directive^]

// /docs/modules/page/pages/include-an-example.adoc
[[include-an-example.adoc]]
= Include an Example
:page-aliases: asciidoc:include-example.adoc
// URLs
:url-include: {url-asciidoc}/directives/include/
:url-tags: {url-asciidoc}/directives/include-tagged-regions/
:url-indent: {url-asciidoc}/directives/include-with-indent/

An example can be inserted into any page or partial in your site using the AsciiDoc include directive and the example's resource ID.

[NOTE]
====
If you aren't familiar with the Antora resource ID and its coordinates, see:

* xref:resource-id.adoc[]
* xref:resource-id-coordinates.adoc[]
====

== AsciiDoc include directive for examples

An AsciiDoc include directive inserts content from an example's source file into a partial or a page.
The include directive accepts the xref:resource-id.adoc[Antora resource ID] of examples, partials, and pages as a value.

<<ex-base>> shows the structure of an include directive with the fully qualified resource ID of an example.
Because the include directive is used to reference other resources, the `example$` family coordinate must be specified in the example's resource ID when it's assigned to an include directive.

.Include directive assigned the fully qualified resource ID of an example
[#ex-base]
----
\include::version@component:module:example$file-coordinate-of-target-example.ext[optional attribute]
----

An include directive consists of the directive's prefix (`include::`), the resource ID of the target example, and a set of square brackets (`[]`).
You can specify optional attributes within the square brackets as key-value pairs separated by commas.
[[target]]The [.term]*target example* is the source file of an example that's being referenced by the current page.
The target example is referenced by assigning its resource ID to an include directive in the content of the current page.
[[current]]The [.term]*current page* is the page source file containing the include directive that references the target example.

When Antora runs, content from the target example is inserted into the current page at the location where the include directive is entered.
The target example's content is converted after it's inserted into the current page.
This means the current page's component version, module, attributes, and other elements are applied to or may impact the content included from the target example.

[#examples-root]
== Insert an example into a page

Let's break down the AsciiDoc include directive and resource ID coordinates you need to insert a <<target,target example>> into the <<current,current page>>.

. In your IDE or plain text editor, open the page where you want to insert the example.
For this step and the subsequent steps, let's assume you've opened the file [.path]_phases.adoc_.
+
--
Example files are often inserted into xref:asciidoc:source.adoc[source blocks].
<<ex-code>> shows a source block with a title and an assigned language set up in the current page.

.phases.adoc (current page)
[source#ex-code]
....
.First test phase
[,js]
----

----
....

The current page, [.path]_phases.adoc_, belongs to the component version _mapper 8.0_ and module _testing_, shown in <<ex-map>>.

.Directories and files assigned to mapper 8.0
[listing#ex-map]
----
📄 antora.yml <.>
📂 modules
  📂 testing <.>
    📂 examples <.>
      📄 timer.js
    📂 pages <.>
      📄 index.adoc
      📄 phases.adoc
----
<.> Defines the component version as _mapper 8.0_
<.> Defines the _testing_ module
<.> Defines subsequent files as examples
<.> Defines subsequent files as pages
--

. In the current page, select the line where you want the example's content to be inserted.
At the beginning of the line, enter the name of the directive followed by two colons, `include::`.
+
.phases.adoc (current page)
[source,subs=+quotes]
....
.First test phase
[,js]
----
**include::**
----
....

. Let's reference the target example, [.path]_timer.js_, from the current page.
Assign the resource ID of the target example to the include directive.
Both [.path]_timer.js_ and [.path]_phases.adoc_ belong to the same component version and module (see <<ex-map>>).
Therefore, only the `example$` family coordinate and file coordinate of the target example need to be specified.
+
--
.phases.adoc (current page)
[source,subs=+quotes]
....
.First test phase
[,js]
----
include::**example$timer.js**
----
....

The file coordinate for the [.path]_timer.js_ example is `timer.js`.
The target example's file coordinate consists solely of its filename and file extension because [.path]_timer.js_ is stored at the root of the [.path]_examples_ directory.

NOTE: By default, the include directive assumes the family coordinate is `page$` when the coordinate isn't specified.
If you forget to use the `example$` coordinate, Antora will report an error because it won't be able to find the example.
--

. Directly after the resource ID of the target example, complete the directive with a set of square brackets (`+[]+`).
+
--
.phases.adoc (current page)
[source,subs=+quotes]
....
.First test phase
[,js]
----
include::example$timer.js**[]**
----
....

The brackets of the include directive can contain an optional list of attributes, such as `lines`, `tag`, or `tags`.
The attributes are entered as key-value pairs separated by commas.
See the {url-include}[AsciiDoc include directive documentation^] for full details about the `lines`, `tag`, and `tags` syntax.
--

That's it!
You've created an include directive that will insert the target example into the current page.

The preceding instructions showed you how to insert an example into a page under the most common scenario--the target example and current page belong to the same component version and module and the target example is stored at the root of a [.path]_examples_ folder.
However, if the target example is stored in a subdirectory of the [.path]_examples_ directory, its file coordinate must specify the <<relative-path,examples-relative directory path in addition to its filename and file extension>>.

.current-page.adoc
[#ex-file]
----
include::example$target-example-filename.ext[] <.>

include::example$path/to/target-example-filename.ext[] <.>

include::example$./target-example-filename.ext[] <.>
----
<.> File coordinate of the target example when it's stored at the root of the [.path]_examples_ directory.
<.> File coordinate of the target example when it's stored in a subdirectory of the [.path]_examples_ directory.
<.> File coordinate of the target example when the target example and current page are stored in subdirectories with parallel family-relative directory paths.
_This is an advanced use case._

Also, you'll need to specify additional resource ID coordinates when the target example and current page don't belong to the <<modules,same module>> or <<component-versions,component version>>.
The following sections provide examples showing the various resource ID scenarios.

[#relative-path]
=== File coordinate with examples-relative directory path

The __examples__-relative directory path of the <<target,target example>> is required in its file coordinate when it's stored in a subdirectory of the [.path]_examples_ directory.

.File coordinate when the target example is stored in a subdirectory of an examples directory
[#ex-subdir-base]
----
\include::example$path/to/target-example-filename.ext[optional attribute]
----

Let's use the files that belong to the component version in <<ex-grid-subdir>> as the basis for the example in this section.

.Directories and files assigned to grid-twist 2.5
[listing#ex-grid-subdir]
----
📄 antora.yml <.>
📂 modules
  📂 ROOT <.>
    📂 examples <.>
      📂 providers <.>
        📄 job.yml
    📂 pages <.>
      📄 interface-loader.adoc
----
<.> Defines the component version as _grid-twist 2.5_
<.> Defines a module named _ROOT_
<.> Defines subsequent files as examples
<.> A subdirectory in _examples_ containing the source files of examples
<.> Defines subsequent files as pages

Let's reference [.path]_job.yml_ from [.path]_interface-loader.adoc_.
As you can see in <<ex-grid-subdir>> above, the example and page belong to the _ROOT_ module.
In <<ex-subdir>>, an include directive in the [.path]_interface-loader.adoc_ page (current page) references the [.path]_job.yml_ file (target example).

.interface-loader.adoc (current page)
[source#ex-subdir]
....
[,yaml]
----
\include::example$providers/job.yml[]
----
....

As shown in <<ex-subdir>>, the family coordinate is `example$` and the file coordinate for [.path]_job.yml_ is `providers/job.yml`.
The file coordinate for [.path]_job.yml_ consists of its [.path]__examples__-relative directory path, filename, and file extension because it's stored in the subdirectory [.path]_providers_.

TIP: In special circumstances where the __examples__-relative directory path of the target example and the __pages__-relative directory path of the current page are parallel, the __examples__-relative directory path can be replaced with the relative path token, `./`.

[#modules]
== Include an example from another module

When the <<target,target example>> and the <<current,current page>> don't belong to the same module, you must specify the target example's xref:resource-id-coordinates.adoc#id-module[module], xref:resource-id-coordinates.adoc#id-family[family], and xref:resource-id-coordinates.adoc#id-resource[file coordinates] in the include directive.

.Module, family, and file coordinates assigned to an include directive
[#ex-module-base]
----
include::module:example$target-example-filename.ext[optional attribute] <.>

include::module:example$path/to/target-example-filename.ext[optional attribute] <.>
----
<.> Assign the module, `example$`, and file coordinates of the target example to the include directive when the target example and current page belong to the same component version but not the same module.
The target example's file coordinate is its filename and file extension when it's <<examples-root,stored at the root of a _examples_ family directory>>.
<.> If <<relative-path,the target example is stored in a subdirectory of a _examples_ directory>>, the target example's file coordinate must specify its __examples__-relative directory path, filename, and file extension.

Let's use the files that belong to the component version shown in <<ex-map-mod>> as the basis for the example in this section.

.Directories and files assigned to mapper 8.0
[listing#ex-map-mod]
----
📄 antora.yml <.>
📂 modules
  📂 ROOT <.>
    📂 examples <.>
      📄 warm-up.js
  📂 testing <.>
    📂 examples <.>
      📄 timer.js
    📂 pages <.>
      📄 index.adoc
      📄 phases.adoc
----
<.> Defines the component version as _mapper 8.0_
<.> Defines the _ROOT_ module
<.> Defines subsequent files as examples
<.> Defines the _testing_ module
<.> Defines subsequent files as examples
<.> Defines subsequent files as pages

Let's insert the [.path]_warm-up.js_ example into the [.path]_index.adoc_ page.
That means the source file [.path]_warm-up.js_ is the target example and [.path]_index.adoc_ is the current page.
As shown in <<ex-map-mod>> above, the [.path]_index.adoc_ page belongs to the _testing_ module, and the [.path]_warm-up.js_ example belongs to the _ROOT_ module.

<<ex-module>> shows an include directive in [.path]_index.adoc_ that references the example [.path]_warm-up.js_.
The module, `example$`, and file coordinates of the target example are assigned to the include directive.

.index.adoc (current page)
[source#ex-module]
....
[,js]
----
\include::ROOT:example$warm-up.js[]
----
....

As shown in <<ex-module>>, the target example's module coordinate is `ROOT`, its family coordinate is `example$`, and its file coordinate is `warm-up.js`.

[#component-versions]
== Include an example from another component

When the <<target,target example>> and <<current,current page>> don't belong to the same documentation component, specify the example's xref:resource-id-coordinates.adoc#id-version[version, component, module, family, and file coordinates] in the resource ID assigned to the include directive.

.Version, component, module, family, and file coordinates assigned to an include directive
[#ex-component-version-base]
----
include::version@component:module:example$target-example-filename.ext[] <.>

include::version@component:module:example$path/to/target-example-filename.ext[] <.>

include::component:module:example$file-coordinate-of-target-example.ext[] <.>
----
<.> Assign the version, component, module, family, and file coordinates of the target example to the include directive when the target example and current page don't belong to the same component version.
The target example's file coordinate is its filename and file extension when the target example is <<examples-root,stored at the root of a _examples_ family directory>>.
<.> If <<relative-path,the target example is stored in a subdirectory of a _examples_ directory>>, the target example's file coordinate must specify its __examples__-relative directory path, filename, and file extension.
<.> If the version coordinate isn't specified, Antora uses the <<latest-version,latest version of the target example's component>> to complete the resource ID at runtime.
This behavior only applies when the target example and current page belong to different docs components.

Let's use the files that belong to the component versions _mapper 8.0_ (<<ex-map-v>>) and _grid-twist 2.5_ (<<ex-grid-v>>) as the basis for the example in this section.

.Directories and files assigned to mapper 8.0
[listing#ex-map-v]
----
📄 antora.yml <.>
📂 modules
  📂 ROOT <.>
    📂 examples <.>
      📄 warm-up.js
  📂 testing <.>
    📂 examples <.>
      📄 timer.js
    📂 pages <.>
      📄 index.adoc
      📄 phases.adoc
----
<.> Defines the component version as _mapper 8.0_
<.> Defines the _ROOT_ module
<.> Defines subsequent files as examples
<.> Defines the _testing_ module
<.> Defines subsequent files as examples
<.> Defines subsequent files as pages

.Directories and files assigned to grid-twist 2.5
[listing#ex-grid-v]
----
📄 antora.yml <.>
📂 modules
  📂 ROOT <.>
    📂 examples <.>
      📂 providers <.>
        📄 job.yml
    📂 pages <.>
      📄 interface-loader.adoc
----
<.> Defines the component version as _grid-twist 2.5_
<.> Defines a module named _ROOT_
<.> Defines subsequent files as examples
<.> A subdirectory in _examples_ containing the source files of examples
<.> Defines subsequent files as pages

Using files from <<ex-map-v>> and <<ex-grid-v>>, let's reference [.path]_warm-up.js_ (target example) from [.path]_interface-loader.adoc_ (current page).
The [.path]_warm-up.js_ example belongs to the component version _mapper 8.0_.
The [.path]_interface-loader.adoc_ page belongs to the component version _grid-twist 2.5_.

The include directive in <<ex-across-components>> will embed the content of the [.path]_warm-up.js_ example into the [.path]_interface-loader.adoc_ page.

.interface-loader.adoc (current page)
[source#ex-across-components]
....
[,js]
----
\include::8.0@mapper:ROOT:example$warm-up.js[]
----
....

As shown in <<ex-across-components>>, the target example's version coordinate is `8.0`, its component coordinate is `mapper`, its module coordinate is `ROOT`, its family coordinate is `example$`, and its file coordinate is `warm-up.js`.
You could also specify the resource ID for [.path]_warm-up.js_ as `8.0@mapper::example$warm-up.js` (notice the module coordinate `ROOT` seems to be missing).
When  the target example's component coordinate is specified, and the target example belongs to the _ROOT_ module, the module coordinate `ROOT` doesn't have to be explicitly specified.
However, you must still enter the colon (`:`) that would follow the module coordinate.
This shorthand only works when a component coordinate is specified and the module coordinate of the target example is `ROOT`.

[#latest-version]
=== Use the latest version of an example

TIP: This behavior only applies when the target example and current page belong to different docs components!

If a version isn't specified in the resource ID assigned to an include directive, *and the target example and current page don't belong to the same component*, Antora uses the version coordinate of the xref:ROOT:how-component-versions-are-sorted.adoc#latest-version[latest version] of the target example's component to complete the resource ID at runtime.

Let's use the files that belong to the component versions _mapper 8.0_ (<<ex-map8>>), _mapper 8.1_ (<<ex-map-latest>>), and _grid-twist 2.5_ (<<ex-grid-latest>>) as the basis for the example in this section.

.Directories and files assigned to mapper 8.0
[listing#ex-map8]
----
📄 antora.yml <.>
📂 modules
  📂 ROOT <.>
    📂 examples <.>
      📄 warm-up.js
  📂 testing <.>
    📂 examples <.>
      📄 timer.js
    📂 pages <.>
      📄 index.adoc
      📄 phases.adoc
----
<.> Defines the component version as _mapper 8.0_

.Directories and files assigned to mapper 8.1
[listing#ex-map-latest]
----
📄 antora.yml <.>
📂 modules
  📂 ROOT <.>
    📂 examples <.>
      📄 warm-up.js
  📂 testing <.>
    📂 examples <.>
      📄 timer.js
    📂 pages <.>
      📄 index.adoc
      📄 phases.adoc
----
<.> Defines the component version as _mapper 8.1_

.Directories and files assigned to grid-twist 2.5
[listing#ex-grid-latest]
----
📄 antora.yml <.>
📂 modules
  📂 ROOT <.>
    📂 examples <.>
      📂 providers <.>
        📄 job.yml
    📂 pages <.>
      📄 interface-loader.adoc
----
<.> Defines the component version as _grid-twist 2.5_

Let's reference the [.path]_timer.js_ example (target example) from the [.path]_interface-loader.adoc_ page (current page).
[.path]_interface-loader.adoc_ belongs to component version _grid-twist 2.5_.
There are two files named [.path]_timer.js_ that belong to the _mapper_ component, _testing_ module, and _examples_ family.
One [.path]_timer.js_ belongs to version _8.0_, the other [.path]_timer.js_ to version _8.1_.

<<ex-across-components-latest>> shows an include directive referencing [.path]_timer.js_ (target example) from [.path]_interface-loader.adoc_ (current page).
Notice that the target example's version coordinate isn't specified.

.interface-loader.adoc (current page)
[source#ex-across-components-latest]
....
[,js]
----
\include::mapper:testing:example$timer.js[]
----
....

When Antora runs, it will identify _mapper 8.1_ as the latest version of the _mapper_ component according to its xref:ROOT:how-component-versions-are-sorted.adoc#version-sorting-rules[version sorting rules] and xref:ROOT:how-component-versions-are-sorted.adoc#latest-version[latest version criteria].
Because a version coordinate isn't specified in <<ex-across-components-latest>>, Antora will complete the resource ID assigned to the include directive using the version coordinate -- `8.1` -- from the latest _mapper_ component.

WARNING: This behavior of linking to the latest version only applies when the version coordinate is unspecified and the target example and current page belong to different components.
If the version and component coordinates aren't specified in the resource ID, Antora assumes the target example belongs to the same component version as the current page and uses the current page's version and component coordinates to complete the target example's resource ID.

== Learn more

* xref:include-a-partial.adoc[]
* xref:include-a-page.adoc[]
* xref:resource-id.adoc[]
* xref:asciidoc:source.adoc[]

.*AsciiDoc and Asciidoctor resources*
* {url-tags}[Select regions of content with tags^]
* {url-indent}[Normalize block indentation with indent^]
* {url-include}[AsciiDoc include directive^]

// /docs/modules/page/pages/attachments.adoc
[[attachments.adoc]]
= Attachments
:page-aliases: asciidoc:link-attachment.adoc

Attachments are downloadable resources, such as PDFs or the ZIP archives of sample projects, that are stored in an xref:ROOT:attachments-directory.adoc[_attachments_ family directory].
You create links to attachments using the xref macro.
Although not as common, an example file can be reclassified as an attachment to make it downloadable as well.
Unlike images, attachments cannot be inserted directly into a page.

== AsciiDoc xref macro for attachments

An attachment can be cross referenced from pages, other resources, and navigation files using an xref:xref.adoc#xref-macro[AsciiDoc xref macro] and the attachment's resource ID.

<<ex-base>> shows the structure of an xref macro with an attachment's fully qualified resource ID.

.Xref macro structure for referencing an attachment
[#ex-base]
----
xref:version@component:module:attachment$file-coordinate-of-attachment.ext[optional link text]
----

At a minimum, an xref macro consists of the macro's prefix (`xref:`), the resource ID of the target attachment, and a set of square brackets (`[]`).
[[target]]The [.term]*target attachment* is the attachment source file that's being referenced by the current page.
The target attachment is referenced by assigning its resource ID to an xref macro in the content of the current page.
[[current]]The [.term]*current page* is the page source file containing the xref macro that references the target attachment.

When referencing an attachment, the xref macro is structured and behaves much like when it's assigned the resource ID of a page, with three differences:

* The xref:resource-id.adoc[resource ID of an attachment] must specify the `attachment$` xref:resource-id-coordinates.adoc#id-family[family coordinate] when an attachment is assigned to an xref macro, otherwise Antora will assume the resource ID is that of a page at runtime.
* A fragment (element ID) can't be appended to the end of the attachment's resource ID.
* Attachments don't have default reference text.
If <<link-text,link text>> isn't specified in the xref macro, the target of the xref is displayed as the link text.

How many of the target attachment's xref:resource-id-coordinates.adoc[resource ID coordinates] you need to specify depends on the component version and module of the target attachment in relation to the current page.

[#make-link]
== Make a link to an attachment

Let's break down the xref macro and resource ID coordinates you need to create a cross reference to an attachment (the <<target,target attachment>>) from a page that you're currently editing (the <<current,current page>>).

. In your IDE or text editor, open the page where you want to create a cross reference to an attachment.
For this step and the subsequent steps, let's assume you've opened the source file for a page named [.path]_satellites.adoc_.
[.path]_satellites.adoc_ is the current page.
+
.satellites.adoc (current page)
[listing]
----
= System Satellites

The group maintains five satellites.
----

. Select the place in the content flow of the current page where you want the link to the target attachment to be displayed.
Enter the name of the xref macro followed by one colon, `xref:`.
+
.satellites.adoc (current page)
[listing#ex-prefix,subs="+quotes"]
----
The group maintains five satellites.
See the **xref:**
----

. Let's reference the source file of an attachment with the filename [.path]_flight-patterns.pdf_.
Both [.path]_flight-patterns.pdf_ and [.path]_satellites.adoc_ belong to the same component version and module.
Therefore, only the `attachment$` family coordinate and xref:resource-id-coordinates.adoc#id-resource[file coordinate] of the target attachment needs to be assigned to the xref macro in <<ex-id>>.
Directly after the macro's prefix, enter the resource ID of the target attachment.
+
--
.satellites.adoc (current page)
[listing#ex-id,subs="+quotes"]
----
The group maintains five satellites.
See the xref:**attachment$flight-patterns.pdf**
----

The file coordinate for [.path]_flight-patterns.pdf_ consists solely of its filename and file extension because it's stored at the root of the [.path]_attachments_ directory.
The target attachment's file coordinate is always calculated from the root of the [.path]_attachments_ family directory where the attachment is stored.
If the target attachment is stored in a subdirectory of an [.path]_attachments_ directory, its file coordinate must specify the __attachments__-relative directory path, filename, and file extension.
(See <<ex-component-version-base>> for an example.)
--

. Directly after the resource ID of the target attachment, enter an opening square bracket (`[`), then a closing square bracket (`]`).
+
.satellites.adoc (current page)
[listing,subs="+quotes"]
----
The group maintains five satellites.
See the xref:attachment$flight-patterns.pdf**[]**
----

. Let's add some link text to the xref macro because, unlike pages, attachments don't have default reference text.
Between the macro's square brackets, specify the text you want displayed as a link to the target attachment when the current page is published.
+
--
.satellites.adoc (current page)
[listing,subs="+quotes"]
----
The group maintains five satellites.
See the xref:attachment$flight-patterns.pdf[**flight pattern schedule**]
----

Link text is optional.
See <<link-text>> for more information.
--

. After the closing square bracket (`]`) of the xref macro, continue entering your content.
+
.satellites.adoc (current page)
[listing]
----
The group maintains five satellites.
See the xref:attachment$flight-patterns.pdf[flight pattern schedule] for more details.
----

That's it!
You've created a cross reference to the target attachment, [.path]_flight-patterns.pdf_, from the current page, [.path]_satellites.adoc_, using the AsciiDoc xref macro.

While the previous steps use a target attachment and current page that belong to the same component version and module, you can reference any attachment in your site, regardless of the component version and module it belongs to, from any page.
You'll need to specify xref:resource-id-coordinates.adoc[additional resource ID coordinates] when the target attachment and current page don't belong to the same module or component version.

.Resource ID patterns for a target attachment in relation to a current page
[#ex-component-version-base]
----
xref:attachment$target-attachment-filename.ext[link text] <.>

xref:attachment$path/to/target-attachment-filename.ext[link text] <.>

xref:attachment$./target-attachment-filename.ext[link text] <.>

xref:module:attachment$file-coordinate-of-attachment.ext[link text] <.>

xref:version@component:module:attachment$file-coordinate-of-attachment.ext[link text] <.>

xref:component:module:attachment$file-coordinate-of-attachment.ext[link text] <.>

xref:version@module:attachment$file-coordinate-of-attachment.ext[link text] <.>

xref:version@attachment$file-coordinate-of-attachment.ext[link text] <.>
----
<.> Assign the `attachment$` family coordinate and file coordinate of the target attachment to the xref macro when the target attachment and current page belong to the same component version and module.
The target attachment's file coordinate is its filename and file extension when the target attachment is stored at the root of an _attachments_ family directory.
<.> If the target attachment is stored in a subdirectory of an _attachments_ directory, the target attachment's file coordinate must specify its __attachments__-relative directory path, filename, and file extension.
<.> The file coordinate of the target attachment can be abbreviated with the relative path token (`./`) when the target attachment and current page are stored in subdirectories with parallel family-relative directory paths.
_This is an advanced use case._
<.> Assign the module, `attachment$`, and file coordinates of the target attachment  to the xref macro when the target attachment and current page don't belong to the same module, but they do belong to the same component version.
<.> Assign the version, component, module, `attachment$`, and file coordinates of the target attachment to the xref macro when the target attachment and current page don't belong to the same component version.
<.> If the version coordinate isn't specified, Antora uses the xref:ROOT:how-component-versions-are-sorted.adoc#latest-version[latest version] of the target attachment's component to complete the resource ID at runtime.
This behavior only applies when the target attachment and current page don't belong to the same component version.
<.> Assign the version, module, `attachment$`, and file coordinates of the target attachment to the xref macro when the target attachment doesn't belong to the same version and module as the current page, but it does belong to the same component as the current page.
<.> Assign the version, `attachment$`, and file coordinates of the target attachment to the xref macro when the target attachment doesn't belong to the same version as the current page, but it does belong to the same component and module as the current page.

Attachment links and page links share many similarities.
See xref:page-links.adoc[] for more examples that show how to construct the resource ID of the target resource when it doesn't belong to the same xref:page-links.adoc#modules[module], xref:page-links.adoc#component-versions[component version], or xref:page-links.adoc#versions[version] as the current page.
Just remember to always add the `attachment$` family coordinate to the target attachment's resource ID when you assign it to an xref macro.

[#link-text]
== Link text for attachments

You can specify link text between the square brackets of an AsciiDoc xref macro, or you can leave the square brackets of the xref macro empty.
<<ex-no-text>> shows an xref macro that's assigned the resource ID of an attachment.
No link text has been specified between the xref macro's square brackets.

.Xref macro without specified link text
[#ex-no-text]
----
Download xref:attachment$practice-project.zip[] to try it out!
----

Because the xref macro in <<ex-no-text>> isn't assigned link text, Antora will display the xref target as the link text.

....
Download attachment$practice-project.zip to try it out!
....

Unlike pages, attachments don't have xref:link-content.adoc#default[default reference text], so it's always good to specify link text to ensure a good reader experience.

You can specify link text by entering it between the square brackets of the xref macro.

.Xref macro with specified link text
[#ex-text]
----
Download xref:attachment$practice-project.zip[the sample project] to try it out!
----

When link text is specified in the xref macro, Antora displays the specified content as the link to the attachment in the published page.

[#include-attachment]
== Include an attachment

Instead of linking to an attachment, you can include it into an AsciiDoc page or partial using the include directive.
The only restriction is that the file must be a text file.
Storing a text file as an attachment allows it to be included while still being downloadable.

Here's the full syntax that shows how to include the text of an attachment into a page.

[subs=+quotes]
----
\include::version@component:module:**attachment$**name-of-file.ext[optional attributes]
----

The `attachment$` segment tells Antora to look for the file in the attachments folder.
If the attachment lives in the same component version and module as the page, the target can start with the `attachment$` segment.

----
\include::attachment$name-of-file.ext[optional attributes]
----

You can use the same attachment in both an xref macro and an include directive.

== Learn more

You can also create links to attachments in xref:navigation:reference-resources.adoc[navigation files] and from xref:image-xref-and-link.adoc#attachment[image macros].

// /docs/modules/asciidoc/pages/index.adoc
= AsciiDoc
:page-aliases: asciidoc.adoc

AsciiDoc is Antora's native content markup language.
AsciiDoc is ideal for writing documentation because it's:

* readable
* concise
* comprehensive
* extensible
* easy to learn

This area of the documentation is intended to provide a preliminary introduction to the AsciiDoc Language and highlight some of the syntax that you'll use in Antora on a daily basis.
These pages should not be considered an authoritative or canonical reference for the language.
To find the official user documentation for the AsciiDoc Language, please visit the https://docs.asciidoctor.org/asciidoc/latest/[AsciiDoc Language documentation].
If there's a discrepancy between what's written here and in the linked documentation, the linked documentation takes precedence.

== Syntax

AsciiDoc is a mature, lightweight markup language that supports all the structural and semantic elements necessary for writing technical documentation.

The AsciiDoc syntax is intuitive because it recognizes well-established, plain text conventions for marking up and structuring text.
A person unfamiliar with AsciiDoc should be able to figure out the purpose of most of its syntax elements just by looking at them.
That's because the syntax elements were carefully chosen to look like what they mean.

AsciiDoc only requires a text editor to read or write, thereby offering a very low bar to get started.

== Parser

Asciidoctor.js is the processor that converts AsciiDoc content to HTML and other formats.

=== Speed and security

No coverage of Asciidoctor is complete without mention of its speed.
It loads, parses, and converts documents extremely quickly.
That’s good news for teams and applications that need to process thousands of documentation files in multiple environments on a daily basis.
Asciidoctor also offers several levels of security, further justifying its suitability for server-side deployments.

== The advantages of Open Source

The Asciidoctor project, home to the AsciiDoc syntax, Asciidoctor.js, and its extensions, is open source and made available under the MIT license.
The Antora developers are also the lead Asciidoctor maintainers, which helps ensures a tight integration and keeps both technologies moving forward to address ever-changing documentation requirements and needs.


// /docs/modules/asciidoc/pages/document-header.adoc
[[document-header.adoc]]
= Document Header

On this page, you'll learn:

* How to create a document header
* How to specify a page title
* How to set header attributes

== Document title

In AsciiDoc, attribute entries at the top of the page optionally preceded by a level-0 section title implicitly creates a document header.
The level-0 section title in the document header is referred to as document title, or doctitle for short.
The attribute entries in the document header set (or unset) attributes that are available throughout the document.

The document title in the AsciiDoc document is used as the page title in Antora.

IMPORTANT: Antora only supports AsciiDoc's Atx-style heading syntax, which means the page title must be preceded by an Atx marker, an equals sign marker (`=`) followed by a space.
Antora does not recognize the legacy Setext-style (i.e., underlined) heading syntax once supported in AsciiDoc, nor does it recognize Asciidoctor's Markdown-style heading syntax.
If you don't use the Atx-style syntax, xrefs in the page will not be resolved and other features of AsciiDoc will not be available.

Here's an example of a document header:

[,asciidoc]
----
= Page Title
:description: A description of this page.
----

In Antora, all pages must have a page title.
That means the doctitle, and thus the document header, is required.
See xref:page:title-and-metadata.adoc[] for more information about specifying a page title.

If you need to apply a unique set of CSS to a page, you can add a role to the doctitle, as shown here.

[,asciidoc]
----
= Home Page
:docrole: home
----

Assuming the UI you're using supports it, you can now use the `body.home` selector to configure CSS to target this specific page.

== Header attributes

Header attributes are document-wide AsciiDoc attributes that are associated with the document header, and thus the document metadata.
Some header attributes can be used to control the processing of the page, such as `page-toclevels`.
More commonly, header attributes are used to store reusable inline content for the document.

IMPORTANT: The document header implicitly ends at the first empty line.
Therefore, any attribute entries below this line will not be treated as header attributes.

There are several built-in header attributes you can use to control the metadata in the published page.
See xref:page:title-and-metadata.adoc[] to learn about these attributes.

Header attributes can be promoted to page attributes by prefixing the name with `page-`.
xref:page:page-attributes.adoc[] are accessible from the UI model in the page layout template and can thus control how the page is formed.

// /docs/modules/asciidoc/pages/section-headings.adoc
[[section-headings.adoc]]
= Section Headings
:url-sections: {url-asciidoc}/sections/titles-and-levels/

On this page, you'll learn:

* [x] How to mark up section headings with AsciiDoc.

[#heading-level-syntax]
== Heading syntax and levels

Sections partition a page into a content hierarchy.
In AsciiDoc, sections are defined using section titles.

.Section title syntax
----
== Level 1 Section Title

=== Level 2 Section Title

==== Level 3 Section Title

===== Level 4 Section Title

====== Level 5 Section Title

== Another Level 1 Section Title
----

When a page is converted to HTML, each section title becomes a heading element where the heading level matches the number of equals signs.
For example, a level 1 section (`==`) maps to an `<h2>` HTML tag.

Section headings must be defined using the Atx-style (single line) that begins with one or more equals signs.

IMPORTANT: Antora does not recognize the legacy Setext-style (i.e., underlined) heading syntax once supported in AsciiDoc, nor does it recognize Asciidoctor's Markdown-style heading syntax.
If you don't use the Atx-style syntax, xrefs in the page will not be resolved and other features of AsciiDoc will not be available.

.*AsciiDoc and Asciidoctor resources*
* {url-sections}[Section titles^]

// /docs/modules/asciidoc/pages/text-and-punctuation.adoc
[[text-and-punctuation.adoc]]
= Text Emphasis, Punctuation, and Typography
:keywords: oblique, boldface, typeface

== Visual emphasis

AsciiDoc provides multiple ways to visually emphasize inline text (words, phrases, and characters).

xref:bold.adoc[Bold]::
Text that is bold will stand out against the regular, surrounding text due to the application of a thicker and/or darker font.
Bold is useful when the text needs to catch the attention of a person visually scanning a page.

xref:italic.adoc[Italic]::
Text is often italicized in order to stress a word or phrase, quote a speaker, or introduce a term.
Italic type slants slightly to the right, and depending on the font, may have cursive swashes and flourishes.

xref:monospace.adoc[Monospace]::
Technical content often requires text to be styled in a way that indicates a command or source code.
Such text is usually emphasized using a fixed-width (i.e., monospace) font.

xref:highlight.adoc[Highlight]::
Another way to draw attention to text is to highlight (or mark) it.
This semantic style is used for reference or notation purposes, or to mark the importance of a key subject or point.

== Punctuation

Common punctuation is entered into an AsciiDoc document just as you would in an email or word processor.
Less common punctuation can be entered directly or using AsciiDoc shorthands.

One way to enter less common punctuation is by using the compose key for your operating system (i.e., a special key sequence).
For example, on macOS you can enter an en dash by typing the key sequence kbd:[⌥ Opt,-].

Since key sequences can be hard to remember, AsciiDoc offers a simpler way to enter less common punctuation.
AsciiDoc has a shorthand syntax for entering curved (smart) quotes and offers built-in replacements and attributes for many extended punctuation symbols.

xref:quotes-and-apostrophes.adoc[Quotation and apostrophe marks]::
Quotation marks and apostrophes can be explicitly marked as straight or curved.

// Break up special character and symbols table into punctuation, intellectual property, etc.
// Add category for equations, formulas, sub/superscript

== Symbols, signs, and marks

Special character and symbol replacement is built right into AsciiDoc.

xref:special-characters-and-symbols.adoc[Special characters and symbols]::
AsciiDoc accepts HTML and XML character entities as well as decimal and hexadecimal Unicode code point references.

// Subscript and Superscript

// /docs/modules/asciidoc/pages/bold.adoc
[[bold.adoc]]
= Bold
:url-bold: {url-asciidoc}/text/bold/
:url-formatting: {url-asciidoc}/text/#formatting-marks-and-pairs
:url-constrained: {url-asciidoc}/text/troubleshoot-unconstrained-formatting/

On this page, you'll learn:

* [x] How to make text bold in AsciiDoc.
* [x] Where to modify your site's bold text styling.

Text that is marked up as bold will stand out against the regular, surrounding text due to the application of a thicker or darker font.
Bold is useful when the text needs to catch the attention of a site visitor quickly scanning a page.

== Bold syntax

A word or phrase is marked as bold when it's enclosed in a single set of asterisks (e.g., `+*word*+`) (constrained formatting).
Bounded characters are marked as bold when they're enclosed in a set of double asterisks (e.g., `+char**act**ers+`) (unconstrained formatting).

Bounded characters are characters that are:

* directly preceded by a non-whitespace character, or
* directly followed by a non-whitespace character.

You don't need to use double asterisks when an entire word or phrase marked as bold is directly followed by a common punctuation mark, such as `;`, `"`, and `!`.

.Bold inline formatting
[#ex-bold]
----
A bold *word*, and a bold *phrase of text*.

Bold c**hara**cter**s** within a word.
----

The result of <<ex-bold>> is displayed below.

====
A bold *word*, and a bold *phrase of text*.

Bold c**hara**cter**s** within a word.
====

== Mixing bold with other formatting

You can add multiple emphasis styles to bold text as long as the syntax is placed in the correct order.

.Order of inline formatting syntax
[#ex-order]
----
`*_monospace bold italic phrase_*` & ``**__char__**``acter``**__s__**``
----

xref:monospace.adoc[Monospace syntax] (`{backtick}`) must be the outermost formatting set (i.e., outside the bold formatting set).
xref:italic.adoc[Italic syntax] (`+_+`) is always the innermost formatting set.

The result of <<ex-order>> is displayed below.

====
`*_monospace bold italic phrase_*` & ``**__char__**``acter``**__s__**``
====

== Site styles

How bold text appears on your site depends on the fonts loaded by your UI and any CSS styles applied to the `<strong>` HTML tag.
You can learn more about customizing xref:antora-ui-default::inline-text-styles.adoc#bold[how bold text appears in your site] in the UI documentation.

.*AsciiDoc and Asciidoctor resources*
* {url-bold}[Bold text formatting^]
* {url-formatting}[Formatting marks and pairs^]
* {url-constrained}[Constrained versus unconstrained^]

// /docs/modules/asciidoc/pages/italic.adoc
[[italic.adoc]]
= Italic
:url-italic: {url-asciidoc}/text/italic/
:url-formatting: {url-asciidoc}/text/#formatting-marks-and-pairs
:url-constrained: {url-asciidoc}/text/troubleshoot-unconstrained-formatting/

On this page, you'll learn:

* [x] How to italicize text in AsciiDoc.
* [x] Where to modify your site's italic text styling.

Text is often italicized in order to stress a word or phrase, quote a speaker, or introduce a term.
Italic type slants slightly to the right, and depending on the font, may have cursive swashes and flourishes.

[#italic]
== Italic syntax

A word or phrase is marked as italic when it is enclosed in a single set of underscores (`+_word_+`) (constrained formatting).
Bounded characters are marked as italic when they're enclosed in a set of double underscores (`+char__act__ers+`) (unconstrained formatting).

Bounded characters are characters that are:

* directly preceded by a non-whitespace character, or
* directly followed by a non-whitespace character.

You don't need to use double underscores when an entire word or phrase marked as italic is directly followed by a common punctuation mark, such as `;`, `"`, and `!`.

.Italic inline formatting
[#ex-italic]
----
An italic _word_, and an italic _phrase of text_.

Italic c__hara__cter__s__ within a word.
----

The result of <<ex-italic>> is displayed below.

====
An italic _word_, and an italic _phrase of text_.

Italic c__hara__cter__s__ within a word.
====

== Mixing italic with other formatting

You can add multiple emphasis styles to italic text as long as the syntax is placed in the correct order.

.Order of inline formatting syntax
[#ex-order]
----
`*_monospace bold italic phrase_*` & ``**__char__**``acter``**__s__**``
----

xref:monospace.adoc[Monospace syntax] (`{backtick}`) must be the outermost formatting set.
xref:bold.adoc[Bold syntax] (`+*+`) must be outside the italics formatting set.
Italic syntax is always the innermost formatting set.

The result of <<ex-order>> is displayed below.

====
`*_monospace bold italic phrase_*` & ``**__char__**``acter``**__s__**``
====

== Site styles

How italic text appears on your site depends on the fonts loaded by your UI and any CSS styles applied to the `<em>` HTML tag.
You can learn more about customizing xref:antora-ui-default::inline-text-styles.adoc#italic[how italic text appears in your site] in the UI documentation.

.*AsciiDoc and Asciidoctor resources*
* {url-italic}[Italic text formatting^]
* {url-formatting}[Formatting marks and pairs^]
* {url-constrained}[Constrained versus unconstrained^]

// /docs/modules/asciidoc/pages/monospace.adoc
[[monospace.adoc]]
= Monospace
:url-mono: {url-asciidoc}/text/monospace/
:url-formatting: {url-asciidoc}/text/#formatting-marks-and-pairs
:url-constrained: {url-asciidoc}/text/troubleshoot-unconstrained-formatting/

On this page, you'll learn:

* [x] How to apply monospace formatting to inline text in AsciiDoc.
* [x] Where to modify your site's inline monospace text styling.

Technical content often requires text to be styled in a way that indicates it is a command or source code.
Such text is usually emphasized using a fixed-width, i.e., monospace, font.

== Inline monospace syntax

A word or phrase is marked as monospace when it is enclosed in a single set of backticks (`++`word`++`) (constrained formatting).
Bounded characters are marked as monospace when they're enclosed in a set of double backticks (`++char``act``ers++`) (unconstrained formatting).

Bounded characters are characters that are:

* directly preceded by a non-whitespace character, or
* directly followed by a non-whitespace character.

You don't need to use double backticks when an entire word or phrase marked as monospace is directly followed by a common punctuation mark, such as `;`, `"`, and `!`.

.Monospace inline formatting
[#ex-monospace]
----
A monospace `word`, and a monospace `phrase of text`.

Monospace c``hara``cter``s`` within a word.
----

The result of <<ex-monospace>> is displayed below.

====
A monospace `word`, and a monospace `phrase of text`.

Monospace c``hara``cter``s`` within a word.
====

== Mixing monospace with other formatting

You can add multiple emphasis styles to monospace text as long as the syntax is placed in the correct order.

.Order of inline formatting syntax
[#ex-order]
----
`*_monospace bold italic phrase_*` & ``**__char__**``acter``**__s__**``
----

Monospace syntax is always the outermost formatting set.
xref:bold.adoc[Bold syntax] (`+*+`) must be outside the italic formatting set.
xref:italic.adoc[Italic syntax] (`+_+`) is always the innermost formatting set.

The result of <<ex-order>> is displayed below.

====
`*_monospace bold italic phrase_*` & ``**__char__**``acter``**__s__**``
====

== Site styles

How inline monospace text appears on your site depends on the fonts loaded by your UI and any CSS styles applied to the `<code>` HTML tag.
You can learn more about customizing xref:antora-ui-default::inline-text-styles.adoc#monospace[how monospace text appears in your site] in the UI documentation.

.*AsciiDoc and Asciidoctor resources*
* {url-mono}[Monospace text formatting^]
* {url-formatting}[Formatting marks and pairs^]
* {url-constrained}[Constrained versus unconstrained^]

// /docs/modules/asciidoc/pages/highlight.adoc
[[highlight.adoc]]
= Highlight
:url-highlight: {url-asciidoc}/text/highlight/
:url-formatting: {url-asciidoc}/text/#formatting-marks-and-pairs
:url-constrained: {url-asciidoc}/text/troubleshoot-unconstrained-formatting/

On this page, you'll learn:

* [x] How to highlight text with AsciiDoc.
* [x] Where to modify your site's highlighting styles.

== Highlight syntax

To highlight (or mark) a word or phrase, place a hash (`+#+`) at the beginning and end of the text you wish to format (constrained formatting).
To highlight one or more characters bounded by other characters, place two hashes (`+##+`) before and after the characters (unconstrained formatting).

.Highlight inline formatting
[#ex-highlight]
----
Let's #highlight this phrase# and the i and s in th##is##.
----

The result of <<ex-highlight>> is displayed below.

====
Let's #highlight this phrase# and the i and the s in th##is##.
====

== Site styles

How highlighted text appears on your site depends on the CSS styles applied to the `<mark>` HTML tag.
You can learn more about customizing xref:antora-ui-default::inline-text-styles.adoc#highlight[how highlighted text appears in your site] in the UI documentation.

.*AsciiDoc and Asciidoctor resources*
* {url-highlight}[Highlighted text formatting^]
* {url-formatting}[Formatting marks and pairs^]
* {url-constrained}[Constrained versus unconstrained^]

// /docs/modules/asciidoc/pages/quotes-and-apostrophes.adoc
[[quotes-and-apostrophes.adoc]]
= Quotation Marks and Apostrophes

On this page, you'll learn:

* [x] How to use single and double curved quotation marks.
* [x] How to use curved apostrophes.

== Curved quotation mark syntax

Single and double quotation marks are *not* rendered as curved quotation marks by default.
When entered using the kbd:['] and kbd:["] keys, Asciidoctor outputs straight
quotation marks.

If you want to output curved quotation marks, you need to add a set of backticks (`{backtick}`) contained within a set of single quotes (`'`) or double quotes (`"`).

.Single and double curved quotation marks
[#ex-curved-marks]
----
'`This should be enclosed in curved single quotes when published.`'

"`This should be enclosed in curved double quotes when published.`"
----

The result of <<ex-curved-marks>> is displayed below.

====
'`This should be enclosed in curved single quotes when published.`'

"`This should be enclosed in curved double quotes when published.`"
====

== Curved apostrophe syntax

When entered with the kbd:['] key, an apostrophe that is directly preceded and followed by a character, such as in contractions and possessive singular forms, is automatically output as a curved apostrophe.

However, an apostrophe directly followed by white space, such as the possessive plural form, is not curved by default.

To output an apostrophe as curved when it is not bound by two characters, mark it as you would a single curved quote.

.Curved apostrophes
[#ex-curved-apostrophe]
----
The `'80s.

The students`' books.

I can't find Joey's house.
----

The result of <<ex-curved-apostrophe>> is displayed below.

====
The `'80s.

The students`' books.

I can't find Joey's house.
====

=== Escape a curved apostrophe

If you don't want an apostrophe that is bound by two characters to be curved, escape it by preceding it with a backslash (`{backslash}`).

.Escaped curved apostrophe syntax
[#ex-escape]
----
I can't find Joey\'s house.
----

The result of <<ex-escape>> is rendered below.

====
I can't find Joey\'s house.
====

// /docs/modules/asciidoc/pages/special-characters-and-symbols.adoc
[[special-characters-and-symbols.adoc]]
= Special Characters and Symbols
:table-caption!:
:url-special-chars: {url-asciidoc}/subs/special-characters/
:url-symbols: {url-asciidoc}/subs/replacements/
:url-char-attrs: {url-asciidoc}/attributes/character-replacement-reference/

On this page, you'll learn:

* [x] How to add special characters (<, >, &) with AsciiDoc.
* [x] How to add symbols, such as (C) and =>, with AsciiDoc.
* [x] How to use HTML and XML entities with AsciiDoc.

Special character and symbol replacement is built into Asciidoctor.

During conversion, the characters in the table below are replaced with the appropriate character or Unicode entity.
Replacement of special characters and symbols occurs in all inline and block elements except for comments and certain passthroughs.
The three special characters, `<`, `>`, and `&`, are always replaced first.

HTML and XML character entities as well as decimal and hexadecimal Unicode code point references are also recognized and replaced.

For example, to produce the `&#167;` symbol you can use `\&sect;` (HTML output only), `\&#x00A7;`, or `\&#167;`.
When the document is processed, the replacements substitution will replace the section symbol reference, regardless of whether it is a character entity reference or a numeric character reference, with `\&#167;`.
In turn, `\&#167;` will display as `&#167;`.

[#replacements,cols="2,^1l,1,1,2"]
|===
|Name |Syntax |Replacement |Rendered |Notes

|Ampersand
|&
|\&amp;
|&
|

|Apostrophe, curved
|Sam's
|Sam\&#8217;s
|Sam's
|The vertical form apostrophe is replaced with the curved form apostrophe.

|Copyright
|(C)
|\&#169;
|(C)
|

|Ellipsis
|...
|\&#8230;
|...
|

|Em dash
|--
|\&#8212;
|{empty}--{empty}
|Only replaced if between two word characters, between a word character and a line boundary, or flanked by spaces.

When flanked by space characters (e.g., `+a -- b+`), the normal spaces are replaced by thin spaces (`\&#8201;`).

|Greater than
|>
|\&gt;
|>
|

|Left double arrow
|<=
|\&#8656;
|<=
|

|Left single arrow
|<-
|\&#8592;
|<-
|

|Less than
|<
|\&lt;
|<
|

|Registered
|(R)
|\&#174;
|(R)
|

|Right double arrow
|=>
|\&#8658;
|=>
|

|Right single arrow
|->
|\&#8594;
|->
|

|Trademark
|(TM)
|\&#8482;
|(TM)
|
|===

.*AsciiDoc and Asciidoctor resources*
* {url-special-chars}[Special characters^]
* {url-symbols}[HTML, XML, and Unicode symbols^]
* {url-char-attrs}[Predefined attributes for character replacements^]

// /docs/modules/asciidoc/pages/subscript-and-superscript.adoc
[[subscript-and-superscript.adoc]]
= Subscript and Superscript
:url-stem: {url-asciidoc}/stem/stem/

On this page, you'll learn:

* [x] How to mark up a subscript character or word with AsciiDoc.
* [x] How to mark up a superscript character or word with AsciiDoc.

TIP: You can write equations and formulas with AsciiDoc {url-stem}[using the stem document attribute^].

== Subscript syntax

Text is subscripted when enclosed in a set of tildes (`{tilde}`).

.Subscript
[#ex-sub]
----
The chemical formula for water is H~2~O.
----

The result of <<ex-sub>> is rendered below.

====
The chemical formula for water is H~2~O.
====

== Superscript syntax

Text is superscripted when enclosed in a set of carets (`{caret}`).

.Superscript
[#ex-super]
----
What is the answer to E=mc^2^?
----

The result of <<ex-super>> is rendered below.

====
What is the answer to E=mc^2^?
====

// /docs/modules/asciidoc/pages/in-page-xref.adoc
[[in-page-xref.adoc]]
= Internal Xrefs
:url-anchor: {url-asciidoc}/attributes/ids/

Internal xrefs are references to other elements within the same page.
You can reference sections, blocks, or inline elements.
These xrefs only require specifying the anchor (aka ID).

== Reference a section in the same page

Section title IDs are automatically generated when AsciiDoc pages are processed, so you can use them as links by referencing the section's title.
However, the title must begin with an uppercase letter (in basic Latin) without any leading formatting marks.

To link to the beginning of a section in the same page, use the in-page cross reference which is designated by a set of double angled brackets (`<< >>`).

.Link to section title in the same page
----
This is an in-page cross reference: <<Reference a section in the same page>>. <.>

This is an in-page cross reference:
<<reference-a-section-in-the-same-page,Check it out>>! <.>
----
<.> In-page xref to a section using the section's title.
<.> In-page xref to a section using the section's implicit ID.

== Reference a block or inline element in the same page

To link to a block or inline element in the same page, you must define an ID at that location.

.Create an ID
----
[#playbook] <.>
Here's an example of a playbook.

This is an [#name-me]#inline ID#. <.>
----
<.> An ID can be placed on a paragraph (i.e., block).
<.> An ID can be placed inline.

There are some exceptions, see the {url-anchor}[defining an anchor section in the Asciidoctor manual^] for more use cases.

To link to that ID, use the same in-page xref syntax you use for section headings.

.Link to an ID
----
We'll walk through a <<playbook,detailed example>> of a playbook in this tutorial.
----

// /docs/modules/asciidoc/pages/external-urls.adoc
[[external-urls.adoc]]
= URLs
:underscore: _
:url-autolink: {url-asciidoc}/macros/autolinks/
:url-email: {url-asciidoc}/macros/email-macro/
:url-macro: {url-asciidoc}/macros/url-macro/
:url-attributes: {url-asciidoc}/macros/link-macro-ref/
:url-prevent-subs: {url-asciidoc}/macros/complex-urls/
:url-peak: https://www.google.com/maps/place/Antora+Peak/@38.3249976,-106.2355882,14z/data=!3m1!4b1!4m5!3m4!1s0x871572433f469bd7:0xd2bdf15e615cd269!8m2!3d38.3249994!4d-106.2180786!5m1!1e4

On this page, you'll learn:

* [x] When you should use a URL versus a cross reference.
* [x] How to create links with and without link text.
* [x] How to escape a URL.
* [x] How to handle complex URLs.

== URL or cross reference?

Use AsciiDoc's URL syntax when you need to create a link to an external URL.
External URLs are links to webpages that aren't built as part of your documentation site by your Antora pipeline.

When you want to link to a page, image, or attachment that is part of your documentation site, use the xref:page:xref.adoc[AsciiDoc xref macro and the resource's resource ID] instead.

[#url-syntax]
== URL syntax

To create a link to an external URL, all you need to do is add the URL prefixed with its scheme.

.Raw URL syntax
[#ex-raw]
Chat with other documentation writers at {url-chat}.

Links that begin with official schemes, such as `https`, `ftp`, `mailto`, etc., are automatically turned into hyperlinks when they're processed.
Here's the result of <<ex-raw>>.

====
Chat with other documentation writers at {url-chat}.
====

To attach a URL to text, enclose the text in square brackets (`[]`) at the end of the URL.

.URL with link text syntax
[#ex-text,subs=attributes+]
----
Looking for help?
Visit the {url-chat}[Antora chat room].
----

The result of <<ex-text>> is displayed below.

====
Looking for help?
Visit the {url-chat}[Antora chat room^].
====

== Escape a URL

When you want to display a URL but you don't want it to be active, you can escape it by prepending it with a backslash (`\`).

.Escape syntax
[#ex-escape]
----
This URL is displayed, \https://gitlab.com, but isn't clickable.
----

Here's the result of <<ex-escape>>.

====
This URL is displayed, \https://gitlab.com, but isn't clickable.
====

== Troubleshooting URLs

A URL may not display correctly when it contains characters such as underscores (`{underscore}`) or carets (`{caret}`) because these characters get interpreted as text formatting markup.

There are two ways to solve this situation.

[no-bullet]
* Option 1: Create a custom attribute for the URL.
* Option 2: Use the inline pass macro with `macros` enabled.

[#create-custom-attribute]
=== Create an attribute for a URL

Let's make an xref:page:define-and-modify-attributes.adoc#custom-attribute[attribute] for a complex URL.
Creating an attribute for a URL is also a good strategy when the URL is long; it keeps the source text clean for writers and editors.

.Custom AsciiDoc attribute syntax
[#ex-attribute]
----
= Page Title
:url-peak: https://www.google.com/maps/place/Antora+Peak/@38.3249976,-106.2355882,14z/data=!3m1!4b1!4m5!3m4!1s0x871572433f469bd7:0xd2bdf15e615cd269!8m2!3d38.3249994!4d-106.2180786!5m1!1e4 <.>

{url-peak}[This URL] was complicated, but a page attribute came to our rescue! <.>
----
<.> Create an attribute, with the name of your choice, in the header of your source file.
Assign the URL to it.
<.> When you want to create a link to that URL in your text, use the attribute (i.e., reference that attribute), as you would have used the URL.

The result of <<ex-attribute>> is displayed below.

====
{url-peak}[This URL^] was complicated, but a page attribute came to our rescue!
====

=== Use the pass macro

If you want to display a complex URL and ensure it doesn't get caught up in any text formatting, put it inside a pass macro and enable the macros substitution, which is what substitutes links.

Here's how a pass macro with the macros substitution enabled is constructed:

----
pass:macros[URL goes between these brackets]
----

Here's a pass macro in action:

.Pass macro with macros substitution syntax
[#ex-pass]
----
Anyone want to climb this 13er with me? (pass:macros[https://www.14ers.com/13ers/peak.php?peakkey=4740])
----

The result of <<ex-pass>> is displayed below.

====
Anyone want to climb this 13er with me? (pass:macros[https://www.14ers.com/13ers/peak.php?peakkey=4740])
====

.*AsciiDoc and Asciidoctor resources*
* {url-autolink}[Autolink syntax^]
* {url-macro}[URL macro^]
* {url-email}[Mailto macro^]
* {url-attributes}[URL attributes^]
* {url-prevent-subs}[Troubleshooting URLs and preventing substitutions^]

// /docs/modules/asciidoc/pages/lists.adoc
[[lists.adoc]]
= Lists

With AsciiDoc you can create several types of lists that contain a variety content, such as images, example blocks, and notices.
You can even mix the different list item types into one list.

But first, some terminology.

A *list* is an AsciiDoc block element that contains list items.

A *list item* is content, which can include multiple paragraphs or blocks, that may be preceded by a marker, number, letter, or symbol depending on the list type and options assigned to list.

== List types

xref:checklists.adoc[Checklist]::
Also known as a task or punch list, these lists contain items marked by either an empty ballot box (&#9744;) or a checked box (&#9745;).
You can even create clickable task lists with AsciiDoc.

xref:description-lists.adoc[Description list]::
A list of terms and their corresponding descriptions and definitions.

xref:ordered-and-unordered-lists.adoc#ordered[Ordered list]::
A list of enumerated items preceded by a number or letter in a sequence.

xref:ordered-and-unordered-lists.adoc#unordered[Unordered list]::
A list of items typically preceded by a bullet (&#8226;), and therefore also known as bullet points or bulleted lists.
xref:navigation:files-and-lists.adoc[Navigation files] also contain unordered AsciiDoc lists.

// /docs/modules/asciidoc/pages/ordered-and-unordered-lists.adoc
[[ordered-and-unordered-lists.adoc]]
= Ordered and Unordered Lists
:keywords: enumerated sequence, bullet points, bulleted list, ol, ul
:url-continuation: {url-asciidoc}/lists/continuation/
:url-ordered: {url-asciidoc}/lists/ordered/
:url-unordered: {url-asciidoc}/lists/unordered/

On this page, you'll learn:

* [x] How to mark up an ordered list with AsciiDoc.
* [x] How to mark up an unordered list with AsciiDoc.
* [x] How to add other AsciiDoc elements to a list item.
* [x] How to mix ordered and unordered items in the same list.

[#ordered]
== Ordered list syntax

Ordered lists are useful when you need to number list items.
First level list items are created with a single dot (a period) and nested items by using two or more dots in front of each the item.
The dot (or dots) is separated from the content of the list item by a single space.

.Ordered list with nested levels
----
. Step 1
. Step 2
.. Details
... Mini-details
.... Micro-details
..... We're really down in the weeds now.
.. More details
. Step 3
----

You can nest unordered lists to any depth.
A different numbering or lettering scheme (e.g., arabic, alpha, roman, etc) used to identify each nesting level.
However, the depth at which a unique scheme is applied depends on the stylesheet.
The scheme will fallback to the browser default (arabic numbering) beyond that depth.

. Step 1
. Step 2
.. Details
... Mini-details
.... Micro-details
..... We're really down in the weeds now.
.. More details
. Step 3

You can control the numbering scheme using the list style.

[lowergreek]
. alpha
. beta
. gamma

You can control the start value using the start attribute.

[start=4]
. Picking up where we left off.
. Add one more ingredient.
. Mix and serve!

[#unordered]
== Unordered list syntax

When your list doesn't need to be numbered, use an unordered list.
First level list items are marked using an asterisk (`+*+`) and nested items by two or more asterisk.

.Unordered list with nested levels
----
* Item A
* Item B
** Item B1
*** Details
**** More details
***** Details about the details
** Item B2
* Item C
----

You can nest unordered lists to any depth.
Unordered lists use a bullet or other illustrative marker in front of each list item to identify each nesting level.
However, the depth at which a unique marker is applied depends on the stylesheet.
The scheme will fallback to the browser default (a square bullet) beyond that depth.

* Item A
* Item B
** Item B1
*** Details
**** More details
***** Details about the details
** Item B2
* Item C

You'll use AsciiDoc's unordered list syntax to xref:navigation:files-and-lists.adoc[structure your site's navigation] as well.

[#complex]
== Complex ordered and unordered lists

List items can be any AsciiDoc element.
You can also mix ordered and unordered list items.
Let's look at an example that contains a variety of content and list item types.

//Don't replace the callouts in this block with <.> or remove source
[source]
....
* A list item can contain two or more paragraphs or blocks of content.
+ <1>
[source,yaml]
----
  artifacts:
    expire_in: 1 week
----
+ <1>
====
An example block
====

** A literal paragraph doesn't require a list continuation.

 $ antora antora-playbook.yml

* You can also mix list item types in the same list.
** Unordered list item
... Ordered list item
.... Another ordered list item
+ <1>
term:: A description list term and content.
....
<1> A [.term]*list continuation* is a plus symbol (`{plus}`) on a line by itself that is immediately adjacent to the block being attached.

To add additional paragraphs or blocks to a list item, you must attach them with a list continuation (`{plus}`).

Here's how the complex list above is rendered.

--
* A list item can contain two or more paragraphs or blocks of content.
+
[,yaml]
----
  artifacts:
    expire_in: 1 week
----
+
====
An example block
====

** A literal paragraph doesn't require a list continuation.

 $ antora antora-playbook.yml

* You can also mix list item types in the same list.
.. Ordered list item
*** Unordered list item
.... Another ordered list item
+
term:: A description list term and content.
--

Alternatively, when a list item contains multiple blocks, you can wrap them in a delimited open block (`+--+`).
Then you only need a single list continuation line to attach the open block to the list item.

//Don't replace the callouts in this block with <.> or remove source
.Use an open block instead of multiple list continuations
[source,line-comment=]
....
* A list item that includes several blocks wrapped in an open block.
+ <1>
-- <2>
[source,yaml]
----
  artifacts:
    expire_in: 1 week
----

====
An example block
====

Another paragraph
-- <2>
....
<1> Single list continuation attaching the open block to the list item.
<2> Open block delimiters wrapping multiple blocks.

Here's how that example looks when rendered.

* A list item that includes several blocks wrapped in an open block.
+
--
[,yaml]
----
  artifacts:
    expire_in: 1 week
----

====
An example block
====

Another paragraph
--

You can find xref:description-lists.adoc#complex[another complex list example] on the description list page.

.*AsciiDoc and Asciidoctor resources*
* {url-ordered}[Basic and complex ordered lists^]
* {url-unordered}[Basic and complex unordered lists^]
* {url-continuation}[List continuation^]

// /docs/modules/asciidoc/pages/description-lists.adoc
[[description-lists.adoc]]
= Description Lists
:keywords: definition list, association list, labeled list, dl, dt, dd
:url-labeled: {url-asciidoc}/lists/description/
:url-continuation: {url-asciidoc}/lists/continuation/

On this page, you'll learn:

* [x] How to mark up a description list with AsciiDoc.
* [x] How to add other AsciiDoc elements to the description content.

Description lists, also known as definition lists, provide a list of terms or phrases and their descriptions.

== Description list syntax

Each item in a description list consists of a term or phrase followed by:

* a separator of two consecutive colons (`::`),
* then at least one space or endline,
* and finally, the description or definition of the item.

=== Basic description list

Here's an example of a description list with two terms and their content.

----
Keyboard::
Used to enter text or control items on the screen. <.>
Mouse:: Used to point to and select items on your computer screen. <.>
----
<.> The term and its description can be placed on separate lines.
<.> The term and its description can be placed on the same line as long as there is at least one blank space between the `::` and description content.

The description of each item is displayed below the term when rendered.

Keyboard::
Used to enter text or control items on the screen.
Mouse:: Used to point to and select items on your computer screen.

The content of a description list can be any AsciiDoc element.
It can even contain other list types.

[#complex]
=== Complex description list

Let's look at an example that includes content other than a single paragraph.

.A description list including complex content
[#ex-complex]
----
term 1::
This description needs two paragraphs.
To attach them both to term 1, use a list continuation (+) on the line separating the paragraphs.
+
This is the second paragraph for term 1.

term 2:: This description includes an admonition block.
Like additional paragraphs, blocks also need to be connected with a +.
+
NOTE: An admonition block that is part of term 2's description.

term 3::
* unordered list item
.. ordered list item
... another ordered list item
----

Here's the result of <<ex-complex>>.

term 1::
This description needs two paragraphs.
To attach them both to term 1, use a list continuation (`{plus}`) on the line separating the paragraphs.
+
This is the second paragraph for term 1.

term 2:: This description includes an admonition block.
Like additional paragraphs, blocks also need to be connected with a `+`.
+
NOTE: An admonition block that is part of term 2's description.

term 3::
* unordered list item
.. ordered list item
... another ordered list item

Additional xref:ordered-and-unordered-lists.adoc#complex[complex list examples and information about attaching multiple blocks to a list item] are on the ordered and unordered lists page.

.*AsciiDoc and Asciidoctor resources*
* {url-labeled}[Basic and complex description lists^]
* {url-continuation}[List continuation^]

// /docs/modules/asciidoc/pages/checklists.adoc
[[checklists.adoc]]
= Checklists
:keywords: check list, tick, ballot, punch list, O mark, tally, X mark
:url-task: {url-asciidoc}/lists/checklist/

On this page, you'll learn:

* [x] How to mark up a checklist with AsciiDoc.
* [x] How to create an clickable checklist with AsciiDoc.

== Checklist syntax

Task lists are xref:ordered-and-unordered-lists.adoc#unordered[unordered lists] that have list items marked as checked or not checked.

Here’s an example:

.Checklist syntax
[#ex-checklist]
----
* [*] checked
* [x] also checked
* [ ] not checked
----

The result of <<ex-checklist>> is rendered below.

* [*] checked
* [x] also checked
* [ ] not checked

If you want to make the checkbox clickable, add the `interactive` option to the checklist, which is shown here using the shorthand syntax (`%`) for `options`.

.Interactive checklist syntax
[#ex-interactive]
----
[%interactive]
* [ ] Binge watch Death in Paradise
* [ ] Visit a tropical island
----

The result of <<ex-interactive>> is rendered below.
Go ahead, click a box.

[%interactive]
* [ ] Binge watch Death in Paradise
* [ ] Visit a tropical island

.*AsciiDoc and Asciidoctor resources*
* {url-task}[Checklists^]

// /docs/modules/asciidoc/pages/embed-video.adoc
[[embed-video.adoc]]
= Embed a Video
:url-video-formats: https://developer.mozilla.org/en-US/docs/Web/HTML/Supported_media_formats#Browser_compatibility
:url-video: {url-asciidoc}/macros/audio-and-video/
:url-options: {url-asciidoc}/macros/audio-and-video/#audio-and-video-attributes-and-options

On this page, you'll learn:

//* [x] How to embed a video in a page.
* [x] How to embed a YouTube or Vimeo video in a page.

////
== Add a video to a page

You can embed self-hosted videos or videos shared on YouTube and Vimeo.

Video format support is dictated by the user's browser and/or system.
For a list of the web video formats each browser supports, see the {url-video-formats}[Mozilla Developer Supported Media Formats documentation^].

.Embedded self-hosted video syntax
----
video::video-file.mp4[]
----

Let's break this down.
You start with the video macro prefix, `video::`.
Next is the target.
Put the path of the video relative to the xref:ROOT:modules.adoc#videos-dir[video catalog] in that slot (no need for an attribute prefix).
Finally, end with a pair of square brackets (`+[]+`).
////

== Add a YouTube or Vimeo video

To embed a video hosted on YouTube or Vimeo, put the video's ID in the macro target and the name of the hosting service (`youtube`, `vimeo`) between the brackets.

.Embedded YouTube video syntax
----
video::rPQoq7ThGAU[youtube]
----

TIP: Insert animated GIFs with the xref:page:images.adoc[image macro].

.*AsciiDoc and Asciidoctor resources*
* {url-video}[Video macro^]
* {url-options}[Video macro options and attributes^]

// /docs/modules/asciidoc/pages/ui-macros.adoc
[[ui-macros.adoc]]
= User Interface Macros

On this page, you'll learn:

* [x] How to mark up a button (press btn:[Submit]) with AsciiDoc.
* [x] How to mark up a keybindings (kbd:[Ctrl+Shift+N]) with AsciiDoc.
* [x] How to mark up a menu (menu:View[Zoom > Reset]) with AsciiDoc.

== Set the experimental attribute

The attribute `experimental` must be set as a xref:page:define-and-modify-attributes.adoc[page attribute], xref:ROOT:component-attributes.adoc[component version attribute], or xref:playbook:asciidoc-attributes.adoc[site attribute] to enable the UI macros styles in the reference UI.

[#button]
== Button syntax

Communicate that a user should press a button with the button macro.

.Button UI macro
[#ex-btn]
----
Press the btn:[Submit] button when you are finished the survey.

Select a file in the file navigator and click btn:[Open].
----

The result of <<ex-btn>> is displayed below.

====
Press the btn:[Submit] button when you are finished the survey.

Select a file in the file navigator and click btn:[Open].
====

[#keybinding]
== Keybinding syntax

Create keyboard shortcuts with the keybinding macro.

.Keybinding UI macro
[#ex-kbd]
----
Press kbd:[esc] to exit insert mode.

Use the shortcut kbd:[Ctrl+T] to open a new tab in your browser.

kbd:[Ctrl+Shift+N] will open a new incognito window.
----

The result of <<ex-kbd>> is displayed below.

====
Press kbd:[esc] to exit insert mode.

Use the shortcut kbd:[Ctrl+T] to open a new tab in your browser.

kbd:[Ctrl+Shift+N] will open a new incognito window.
====

[#menu]
== Menu syntax

Show readers how to select a menu item with the menu macro.

.Menu UI macro
[#ex-menu]
----
To save the file, select menu:File[Save].

Select menu:View[Zoom > Reset] to reset the zoom level to the default setting.
----

The result of <<ex-menu>> is displayed below.

====
To save the file, select menu:File[Save].

Select menu:View[Zoom > Reset] to reset the zoom level to the default setting.
====

// /docs/modules/asciidoc/pages/source.adoc
[[source.adoc]]
= Source Blocks
// URLs
:url-highlightjs: https://highlightjs.org

On this page, you'll learn:

* [x] How to create an AsciiDoc source block.
* [x] How to specify a source language for a source block.
* [x] How to specify a global source language using `source-language`.
* [x] How to disable syntax highlighting for source blocks.

== What's a source block?

An [.term]*AsciiDoc source code block*, or [.term]*source block* for short, displays snippets of content that are written in a given programming, data, configuration, or markup language.
The content of a source block is colorized using a syntax highlighter when it's rendered in a site.
A source block is created by assigning the attribute `source` and the name of a valid source language to a block.

== source and source language attributes

The style `source` is a positional element attribute.
It's assigned to a block using the first position in an attribute list.

.Directly assign source and a source language using an attribute list
[#ex-direct]
----
[source,name-of-language] <.>
----
<.> An attribute list with `source` assigned to the first position and a source language name, such as `bash`, `cpp`, etc., assigned to the second position.

The name of a source language is assigned to the second position in an attribute list or using the `source-language` document attribute.
The source language is the name of a programming, data, configuration, or markup language in which the block's content is written.

Specifying a source language serves two purposes.
First, it communicates to the site visitor which language runtime or data format reader is needed to interpret the code displayed in the block.
Second, it allows a syntax highlighter to colorize the source content properly, such as emphasizing language types and keywords.
Finally, by assigning a language to a block, you can implicitly assign `source` to the block at the same time.
As shown in <<ex-implicit>>, by assigning the name of a valid source language to the second position of an attribute list, you implicitly assign `source` to the first position.

.Assign a source language to the second position of an attribute list
[#ex-implicit]
----
[,name-of-language] <.>
----
<.> To assign a source language to the second position of an attribute list without assigning `source` directly to the first position, enter a comma (`,`) immediately after the opening square bracket, then enter the name of a source language.

The language name is written in lowercase letters and must be a language recognized by the <<source-highlighter,syntax highlighter Antora uses>> for the content to be colorized correctly.
If most of your source blocks use the same language, you can assign the name of the language to the <<source-language,source-language document attribute>>.

When `source` is specified but a language isn't specified in the attribute list of a source block or by the `source-language` document attribute, Antora applies the language `none` at runtime.
The block is styled like other source blocks, but no syntax highlighting will be applied to its content.

== Create a source block

Source blocks are most often created from delimited listing and literal blocks as well as paragraphs.
A block becomes a source block in the following scenarios:

* a language name is assigned to the second position in a block's attribute list, which implicitly assigns `source` to the first position in the attribute list
* `source` is assigned directly to the first position in a block's attribute list, and a language name is assigned to the second position or to the `source-language` document attribute
* the document attribute `source-language` is set, which automatically promotes all delimited listing blocks that aren't assigned another style to source blocks

When `source` is assigned to a block using any of these methods, the content of the block is colorized according to the assigned source language by the syntax highlighter.

=== Assign source implicitly

Because `source` is assigned to a block using the first position of an attribute list, you can assign it implicitly by entering a comma (`,`) directly after the opening bracket, followed by the name of a source language.
The comma is required, otherwise the language would be assigned to the first position of the attribute list.
<<ex-source-position>> shows the `source` attribute being applied implicitly to a listing block.

.Apply source implicitly to a listing block
[source#ex-source-position]
....
[,name-of-language] <.>
---- <.>
Content of source block <.>
  Content of source block

Content of source block
---- <.>
....
<.> Directly after the opening square bracket (`[`) of the attribute list, enter a comma (`,`), followed by the name of the source language in which the block's content is written.
Complete the attribute list with a closing square bracket (`]`) and select kbd:[Enter] to go to the next line.
<.> On the new line directly below the attribute list, enter the opening delimiter of a listing block (`----`) and then select kbd:[Enter] to go to the next line.
<.> On the lines below the opening delimiter, insert your code snippet.
<.> On a new line, enter the closing delimiter of the listing block (`----`).

You can use `source` implicitly on other block types to create a source block.
<<ex-source-paragraph>> shows the `source` attribute being applied implicitly to a paragraph.

.Apply source style to a paragraph
[#ex-source-paragraph]
----
A regular paragraph.

[,name-of-language] <.>
Content of source block <.>

A regular paragraph.
----
<.> After the opening square bracket (`[`) of the attribute list, enter a comma (`,`), followed by the name of the source language in which the block's content is written.
Complete the attribute list with a closing square bracket (`]`) and select kbd:[Enter] to go to the next line.
<.> On the line directly below the attribute list, enter the block's content on one or more continuous lines.

In <<ex-haskell>>, `source` is assigned implicitly and `haskell` is assigned as the language.

.Assign source and the language haskell to a block
[source#ex-haskell]
....
[,haskell]
----
main :: IO ()
main = putStrLn "Hello, World!"
----
....

<<ex-haskell-result>> shows how the source block appears when displayed in a site.

.Rendered source block with syntax highlighting applied
[source#ex-haskell-result,haskell]
----
main :: IO ()
main = putStrLn "Hello, World!"
----

The content in <<ex-haskell-result>> is colorized, and when you hover over the block, the language name _HASKELL_ appears in its upper right corner.

=== Assign source directly

In some cases, you may prefer to assign `source` directly to a block.
In a block's attribute list, `source` is entered in the first position in the list, followed by a comma (`,`), and then the name of a language, such as `clojure`, `json`, `xml`, etc.
<<ex-source-direct>> shows the `source` attribute being applied directly to a delimited literal block (`+....+`).

.Apply source style directly to a block
[#ex-source-direct]
----
[source,name-of-language] <.>
....
Content of source block
  Content of source block

Content of source block
....
----
<.> In the attribute list, assign `source` to the first position, followed by a comma (`,`), and then the name of the source language in which the block's content is written.

In <<ex-sql>>, `source` is assigned to the first position and `sql` is assigned as the language to the second position.

.Assign source and the language sql to a block
[source#ex-sql]
....
[source,sql]
----
IF EXISTS (SELECT name FROM myobjects WHERE name = 'hello')
----
....

<<ex-sql-result>> shows how the source block appears when displayed in a site.

.Rendered source block with syntax highlighting applied
[source#ex-sql-result,sql]
----
IF EXISTS (SELECT name FROM myobjects WHERE name = 'hello')
----

The content in <<ex-sql-result>> is colorized, and when you hover over the block, the language name _SQL_ appears in the upper right corner.

To assign an element ID, role, or option to a source block using their applicable shorthand syntax, specify the `source` attribute and append the ID, role, or options to the attribute.
<<ex-source-id>> shows the `source` attribute and an element ID being assigned to a listing block.

.Assign an element ID to a source block
[source#ex-source-id]
....
[#element-id,name-of-language] <.> <.>
----
Content of source block
  Content of source block
----
....
<.> In the attribute list, specify the element ID in the first position.
An element ID is directly appended to the style (which is empty in this case) using the hash symbol (`+#+`) followed by the ID name.
The `source` style is implied since a language is specified in the second position.
<.> Directly after the element ID, enter a comma (`,`), and then the name of the source language in which the block's content is written.

Now let's look at a source block that's created with a delimited literal block and is assigned an element ID using the shorthand hash symbol (`+#+`).
In <<ex-diff>>, an element ID is appended to the implicit `source` style with a `+#+`.
The line comparison syntax, `diff`, is assigned to the second position.

.Assign source, an element ID, and the language diff to a block
[#ex-diff]
----
[#temper-change,diff]
....
-   temperDestination(destination)
+   if (destination instanceof Boom) moderateDestination(destination)
  }
  rootLoggerHolder.set(undefined, addFailOnExitHooks(logger, failureLevel))
....
----

<<temper-change>> shows how the source block appears when displayed in a site.

.Rendered source block with syntax highlighting applied
[source#temper-change,diff]
....
-   temperDestination(destination)
+   if (destination instanceof Boom) moderateDestination(destination)
  }
  rootLoggerHolder.set(undefined, addFailOnExitHooks(logger, failureLevel))
....

The content in <<temper-change>> is colorized, and when you hover over the block, the language name _DIFF_ appears in the upper right corner of the block.

[#source-language]
=== Promote listing blocks with source-language

You can define a source language globally, either at the page, component version, or site level, by setting the `source-language` document attribute.
When `source-language` is set, all delimited listing blocks that aren't assigned a style are automatically promoted to source blocks.
The `source-language` attribute is set and assigned a value in the document header of a page, component version descriptor file, or playbook.
In <<ex-source-document>>, the `source-language` attribute is set in the header of a page and assigned the name of a language.

.Set source-language in the document header
[#ex-source-document]
----
= Title of Page
:source-language: name-of-language <.>

A paragraph.

---- <.>
Content of source block
---- <2>

A paragraph.

.... <.>
Content of a literal block.
.... <3>
----
<.> On a new line in the header of the page, set the built-in document attribute `source-language` and assign it the name of a language as a value.
<.> Because `source-language` is set, this listing block is automatically promoted to a source block.
<.> This literal block remains a literal block.
Only listing blocks are automatically promoted to source blocks when `source-language` is set.

When `source-language` is set, you may want some listing blocks to not be promoted to source blocks or to assign a different language to a few of them.
<<ex-source-override>> shows how to prevent a listing block from being promoted to a source block and how to override the language assigned to the `source-language` attribute.

.Override source-language on select blocks
[source#ex-source-override]
....
= Title of Page
:source-language: java <.>

A paragraph.

---- <.>
Content of source block
---- <2>

A paragraph.

[listing] <.>
----
Content of listing block
----

[,yaml] <.>
----
Content of source block
----
....
<.> The document attribute `source-language` is set in the header of the page and assigned the value `java`.
All of the listing blocks on this page that aren't directly assigned a style will be promoted to source blocks and all source blocks that aren't directly assigned a source language will be assigned the language `java`.
<.> This listing block is automatically promoted to a source block and assigned the language `java`.
It's content will be identified as _JAVA_ and colorized accordingly.
<.> This listing block is assigned the style `listing`, therefore it isn't promoted to a source block and its contents will not be colorized.
<.> This source block is directly assigned the language `yaml`.
Therefore, the block's content will be identified as _YAML_ and colorized accordingly.

We'll look at how colorization gets added in the <<source-highlighter,next section>>.

[#source-highlighter]
== Syntax highlighting

Syntax highlighting is a technique of colorizing the code to make it easier to read by emphasizing types, keywords, and other language constructs.
Syntax highlighting of source blocks is enabled using the `source-highlighter` attribute.
Antora sets `source-highlighter` site-wide by default (see xref:page:intrinsic-attributes.adoc#site-and-configuration-attributes[site and configuration attributes]), therefore, you don't need to do anything to enable this feature.
Antora uses highlight.js to automatically add syntax highlighting to source blocks that specify a source language.

Syntax highlighting also requires a contribution from the UI.
The reference Antora UI bundles the highlight.js library (both the JavaScript and the CSS) and adds it to each page.
The names of the languages that are currently supported are listed in the https://gitlab.com/antora/antora-ui-default/-/raw/HEAD/src/js/vendor/highlight.bundle.js[highlight.bundle.js file in Antora's UI repository^].

You can disable or override the `source-highlighter` attribute in the playbook or a component version descriptor.
To disable syntax highlighting, unset the `source-highlighter` attribute in your playbook.

.Disable source-highlighter attribute in antora-playbook.yml
[,yaml]
----
asciidoc:
  attributes:
    source-highlighter: ~
----

Currently, the only `source-highlighter` value Antora supports when using the reference UI is `highlight.js`.
If you set the value to `rouge`, `pygments`, or `coderay`, Antora will fail.
That's because these built-in, build-time syntax highlighters are not available in the Antora environment (and specifically Asciidoctor.js).

You can use other client-side (also known as browser) libraries, such as prettify or prism.
However, to use them, you'll need to modify the UI to bundle and add the library to each page, like the reference UI does for highlight.js.

In the future, it will be possible to register additional adapters to plug in other syntax highlighters.
However, that feature is not currently available in Antora.

== Learn more

The content of a source block is often inserted using an include directive.
See xref:page:include-an-example.adoc[] to learn more.

// /docs/modules/asciidoc/pages/admonitions.adoc
[[admonitions.adoc]]
= Admonitions
:url-admonition: {url-asciidoc}/blocks/admonitions/

On this page, you'll learn:

* [x] How to mark up an admonition with AsciiDoc.
* [x] How to create an admonition with complex content.

== Admonition styles

An admonition, also known as a notice, helps draw attention to content with a special label or icon.
There are five built-in admonition labels.

* NOTE
* TIP
* IMPORTANT
* CAUTION
* WARNING

== Basic admonition

If the admonition content is not interrupted by blank lines, start the first line  with a style label.
The label must be all uppercase and followed by a colon (`:`) and a single blank space.

.Basic admonition syntax
[#ex-admonitions]
----
CAUTION: Don't stick forks in electric sockets.

TIP: After someone sticks a fork in a socket, you'll need to reset the circuit in the dark basement.

WARNING: Never go into the basement.

IMPORTANT: A monster lives in the basement.

NOTE: If you go into the basement, see if you can find Kenny's parka.
----

The result of <<ex-admonitions>> is displayed below.

CAUTION: Don't stick forks in electric sockets.

TIP: After someone sticks a fork in a socket, you'll need to reset the circuit in the dark basement.

WARNING: Never go into the basement.

IMPORTANT: A monster lives in the basement.

NOTE: If you go into the basement, see if you can find Kenny's parka.

[#complex]
== Complex admonition

If the admonition content includes elements separated by blank lines, place the content in a xref:examples.adoc#delimited[delimited example block] (`pass:[====]`).
This behavior is referred to as masquerading.
Place the appropriate label, in all uppercase, on the block in an attribute list (`[]`).

.Complex admonition syntax
[#ex-masquerade]
----
[IMPORTANT]
.Optional Title
====
Use an example block to create an admonition that contains complex content, such as (but not limited to):

* Lists
* Multiple paragraphs
* Source code
* Images
====
----

The result of <<ex-masquerade>> is displayed below.

[IMPORTANT]
.Optional Title
====
Use an example block to create an admonition that contains complex content, such as (but not limited to):

* Lists
* Multiple paragraphs
* Source code
* Images
====

.*AsciiDoc and Asciidoctor resources*
* {url-admonition}[Admonition paragraphs and blocks^]

// /docs/modules/asciidoc/pages/examples.adoc
[[examples.adoc]]
= Example Blocks

On this page, you'll learn:

* [x] How to mark up an example with AsciiDoc.

== Example syntax

An example paragraph or delimited block is useful for visually delineating content that illustrates a concept or showing the result of an operation.
An example can contain any type of content and AsciiDoc syntax.
Normal substitutions are applied to example content.

=== Example paragraph

If the example content is contiguous, i.e., not interrupted by blank lines, the block name `example` can be placed directly on top of the text in an attribute list (`[]`).

.Example paragraph syntax
[#ex-name]
----
.Optional title
[example]
This is an example paragraph.
----

Here's the result of <<ex-name>>.

.Optional title
[example]
This is an example paragraph.

[#delimited]
=== Delimited example block

If the example content contains elements separated by blank lines, place the content between delimiter lines consisting of four equals signs (`pass:[====]`).
You don't need to set the block name when you use a delimited block.

.Delimited example block syntax
[#ex-block]
----
.Onomatopoeia
====
The book hit the floor with a *thud*.

He could hear doves *cooing* in the pine trees`' branches.
====
----

Here's the result of <<ex-block>>.

.Onomatopoeia
====
The book hit the floor with a *thud*.

He could hear doves *cooing* in the pine trees`' branches.
====

TIP: xref:admonitions.adoc#complex[Complex admonitions] use the delimited example block syntax.

// /docs/modules/asciidoc/pages/sidebar.adoc
[[sidebar.adoc]]
= Sidebars

On this page, you'll learn:

* [x] How to mark up a sidebar with AsciiDoc.

== Sidebar syntax

A sidebar can contain any type of content such as quotes, equations, and images.
Normal substitutions are applied to sidebar content.

=== Sidebar paragraph

If the sidebar content is contiguous, the block name `sidebar` can be placed directly on top of the text in an attribute list (`[]`).

.Sidebar paragraph syntax
[#ex-style]
----
[sidebar]
Sidebars are used to visually separate auxiliary bits of content
that supplement the main text.
----

The result of <<ex-style>> is displayed below.

[sidebar]
Sidebars are used to visually separate auxiliary bits of content that supplement the main text.

=== Delimited sidebar block

A sidebar block is delimited by a set of four consecutive asterisks (`pass:[****]`).
You don't need to set the block name when you use a delimited block.

.Delimited sidebar block syntax
[source#ex-block]
....
.Optional Title
****
Sidebars are used to visually separate auxiliary bits of content
that supplement the main text.

TIP: They can contain any type of content.

.Source code block in a sidebar
[,js]
----
const { expect, expectCalledWith, heredoc } = require('../../../test/test-utils')
----
****
....

The result of <<ex-block>> is displayed below.

.Optional Title
****
Sidebars are used to visually separate auxiliary bits of content that supplement the main text.

TIP: They can contain any type of content.

.Source code block in a sidebar
[,js]
----
const { expect, expectCalledWith, heredoc } = require('../../../test/test-utils')
----
****

// /docs/modules/asciidoc/pages/comments.adoc
[[comments.adoc]]
= Comments

On this page, you'll learn:

* [x] How write a comment line or block in an AsciiDoc file.

== Comment syntax

You can use a comment line or comment block when you want to add text to an AsciiDoc source file, but don't want that text to be displayed when the file is converted to an HTML page.
Comments inside blocks that have the verbatim (e.g., listing) or raw (e.g., pass) content model are not interpreted.

A comment line is denoted by two consecutive forward slashes (`//`) at the beginning of a line.

.Comment line syntax
----
// This is a line that is commented out.
----

A comment block is delimited by a set of four consecutive forward slashes (`////`).

.Comment block syntax
----
////
This is a comment block.

All of the text, including any AsciiDoc syntax, won't be visible when the file is converted to HTML.
////
----

// /docs/modules/navigation/pages/index.adoc
[[index.adoc]]
= Navigation Assembly
:description: An introduction to how Antora creates site, component version, and page menus and dropdown selectors for multiple documentation products and versions.
:keywords: navigate between documentation versions, navigate between projects, navigate to other versions of a page, add page links to a menu, add page links to a sidebar, add page links to an AsciiDoc list, set up website navigation with Antora, multi-version navigation, create a navigation menu with AsciiDoc, UI, theme
// Filters
:page-collections: core concepts
:page-tags: UI menu, component versions, page versions

With Antora, you can create a component version's navigation with AsciiDoc and store it alongside your source files.

== Navigation assembly requirements

The navigation for a site requires:

* at least one navigation file that contains at least one unordered AsciiDoc list,
* at least one navigation file registered in the component version descriptor file, and
* a UI bundle, such as Antora's reference UI, that can apply styles and interaction behavior to the menus Antora generates.

image::navigation-assembly.svg[Antora navigation assembly diagram showing the required source files and the resulting menus where the content from the source files is displayed,600]

Let's take a brief look at each of the numbered items in this diagram.

=== image:one.svg[,18,role=conum is-hidden-toc] Navigation files (Source)

The navigation for a component version is described by xref:files-and-lists.adoc[at least one AsciiDoc file].
However, as you can see in the diagram, you can assemble a component version's navigation from multiple files.
Creating a navigation file per module is a common organizational structure, but it isn't required.

A navigation file contains xref:files-and-lists.adoc#list-structure[one or more bulleted lists].
Each item in a list can be the cross reference to a page, URL to a website that isn't part of the site, or unlinked text such as a category title that groups a nested set of list items.
You can xref:include-lists.adoc[compose the navigation from multiple files].

When you want the contents of a navigation file to be published to a component version's page menu, you need to register the file in the corresponding component version descriptor file.

=== image:two.svg[,18,role=conum is-hidden-toc] Navigation registration (Source)

Navigation files are xref:register-navigation-files.adoc[registered in a component version descriptor file] under the `nav` key.
List the navigation files in the order you want them to be displayed in the published component version page menu on your site.
When Antora runs, it only uses the registered navigation files to create the component version page menu.

[#component-menu]
=== image:three.svg[,18,role=conum is-hidden-toc] Component version page menu (Site)

Antora collects the contents of each registered navigation file, puts the contents in the order the files are listed under the `nav` key, and publishes a fully assembled menu of pages for the component version.
The behavior and style of the component version page menu is dictated by the xref:playbook:configure-ui.adoc[UI bundle specified in your playbook].

image::component-navigation-menu.png[Screenshot of the component version page menu in an Antora documentation site,660]

[#component-dropdown]
=== image:four.svg[,18,role=conum is-hidden-toc] Component version selector (Site)

When your site has several components or component versions, Antora assembles an aggregated list of the components and their versions.
This menu of components and their component versions is the component version selector.
Antora automatically lists the components in alphabetical order.
Each component version is xref:ROOT:how-component-versions-are-sorted.adoc[ordered from the greatest or latest].

image::component-version-selector.png[Screenshot of the component version selector dropdown menu in an Antora documentation site,660]

In the reference UI, this list is displayed in the "`drawer`" located at the bottom of any component version page menu.
When a visitor clicks on the drawer, it expands upwards and the reader can then select the component version they want to see.

[#page-dropdown]
=== image:five.svg[,18,role=conum is-hidden-toc] Page version selector (Site)

If a page is available in more than one version of a component, a dropdown selector is visible on that page in the reference UI.
From this selector, a visitor can navigate between other versions of that page.
Antora automatically populates this selector when multiple versions of a page are available.

image::page-version-selector.png[Screenshot of the page version selector dropdown menu in an Antora documentation site,660]

////
== What's next?

*Summit Stats*: All the details about each concept.

* xref:filenames-and-locations.adoc[Navigation source file names, format, and storage locations]
* xref:register-navigation-files.adoc[The nav key and registering navigation files]
* xref:list-structures.adoc[Navigation list structures: list item and title nesting, single list file, multi-list file]
* xref:link-syntax-and-content.adoc[Navigation list item syntax: xrefs, URLs, text styles, images, icons, and more]
////
//* Navigation files and the AsciiDoc include directive
//* Component navigation menu, home icon, and the index / start page
//* Breadcrumbs
//* Component version selector menu
//* Page version selector menu

//*Base Jumps*: Workflows and tutorials.

//* xref:create-a-navigation-file.adoc[Create and register a basic navigation file]

//* Create a navigation file that contains multiple AsciiDoc lists
//* Add xrefs to pages in topic folders and other modules
//* Insert one module's navigation between the lists or list items of another module's navigation

//* Set up a new navigation file and add different types of content to it.
//* Organize navigation files in a component.
//* Select the order the navigation lists should be displayed in a published site.

// In addition to xrefs, the lists can contain normal text, images, icons, and URLs to other sites.
// You don't need to know any special syntax just for creating navigation menus, it's just regular AsciiDoc.
// There's no special syntax or file structure for creating navigation menus or UI template logic to learn.
// It then publishes the output to a navigation menu for each component version.
// describe and control the navigation structure as a content concern; navigation stored with the content; author-controlled, yet can still be manipulated by the UI / designer

// /docs/modules/navigation/pages/files-and-lists.adoc
[[files-and-lists.adoc]]
= Navigation Files and Lists
:page-aliases: list-structures.adoc

All of the source files that belong to a component version's `pages` family are automatically published to your site by Antora.
That means visitors can find a page using search tools, links on other site pages, and in some scenarios, through dropdown menus such as the page version selector.
In order for visitors to locate and go to a page using a component version page menu, a cross reference targeting that page must be entered into a list in a navigation file.

[#whats-a-nav-file]
== What's a navigation file?

A [.term]*navigation file* is one or more lists of page cross references, external URLs, and other content that is marked up in AsciiDoc and stored at the base of a xref:ROOT:module-directories.adoc[module directory].
If registered in an [.path]_antora.yml_ file, the contents of the navigation file will be incorporated into a component version page menu and published to a site.

=== Filename and format

Navigation files must end with the AsciiDoc file extension (_.adoc_).
They're typically named [.path]_nav.adoc_; however, you can use any name that is meaningful to you.
Name your navigation files [.path]_kaboom.adoc_ if that makes your team happy.

[#list-structure]
== List structure

A navigation list is an xref:asciidoc:ordered-and-unordered-lists.adoc#unordered[unordered AsciiDoc list].
Each top-level list item can nested items up to level five (`+*****+`).

.Single list structure
----
* Top level item
** Second level item
*** Third level item
*** Third level item
** Second level item
*** Third level item
**** Fourth level item
***** Fifth level item
* Top level item
* Top level item
----

A top-level list item is a list title, which is denoted by a dot (`.`), or, when there isn't a list title, each list item that's marked by a single asterisk (`+*+`).
When a xref:multiple-lists.adoc[file contains multiple lists], each list must be initiated with a list title.

.Multiple list structure
----
.List title and top level item
* List item

.List title and top level item
* List item
** List item
----

If a navigation file only contains one list, a list title is optional.
In a xref:single-list.adoc[single list navigation file], each item with a single asterisk marker (`+*+`) effectively becomes a top-level item.

You can compose your navigation by combining files using the include directive.
Each included file must be located in a partials directory.
If you want the navigation list in the included file to be added as a child of the current item, you should enclose the include directive in an open block.
See xref:include-lists.adoc[] to learn how to create a navigation list using multiple files and include directives.

== List titles and items

List titles and items in a navigation file can contain several types of content, such as cross references to pages, links to external sites, and regular and formatted text.
The most common items in a navigation file are xrefs to pages that belong to the same component version and module, but a target resource ID can be for pages in other modules and components, too.

----
.The Special Project <.>
* xref:index.adoc[] <.>
** xref:ROOT:get-started.adoc[] <.>
** xref:team::contributing.adoc[] <.>

._Support_ <.>
* https://support.project.com[Get Help] <.>
* xref:help.adoc[*Troubleshooting*] <.>
----
<.> Regular, unlinked text.
<.> Xref to a page that belongs to the same module as the navigation file.
Antora will apply the target page's xref:xrefs-and-link-text.adoc[default navigation link text] when the site is generated.
<.> Xref to a page that doesn't belong to the same module as the navigation file.
<.> Xref to a page that doesn't belong to the same component as the navigation file.
<.> Unlinked text with xref:format-content.adoc[inline formatting].
<.> xref:external-links.adoc[Link to an external website].
<.> Xref with formatted link text.

List items can xref:reference-resources.adoc[reference attachments], too.

// /docs/modules/navigation/pages/single-list.adoc
[[single-list.adoc]]
= Create a Navigation File with One List

== Single list structure

A single list navigation file contains one xref:asciidoc:ordered-and-unordered-lists.adoc#unordered[unordered AsciiDoc list].
An unordered list is made up of list items.

----
* List item <.>
* List item <.>
** Nested item <.>
<.>
* List item
// Comment line <.>
* List item
** Nested item <.>
*** Nested item
----
<.> List item preceded by an unordered AsciiDoc list marker (`+*+`).
<.> Each list item must be entered on its own line.
<.> Enter a blank space between the last asterisk of a marker and the content of your list item.
<.> List items can be interspersed by blank lines.
<.> List items can be interspersed by comment lines.
<.> A nested list item.

Each list item is preceded by a marker.
An unordered AsciiDoc list's marker can range from one asterisk (`+*+`) to five asterisks (`+*****+`).

You can separate list items with blank lines or comment lines.
The blank lines are removed from the HTML when the list is published as a component version page menu, and the comments aren't visible to site visitors.

=== Top-level list items and nesting

The top-level list item in a single list navigation file is marked by either a single asterisk (`+*+`) or, when the first item is a list title, a dot (`.`).
A list title is optional.
Unlike list items, there must be *no spaces* between the `.` and the content of the title.

----
.List title <.>
* List item
* Another list item
** A nested list item
----
<.> A list title becomes the top-level item for the entire list.

When converted into a component version page menu, the list title becomes the top-level item for all of the other list items (`+*+` through `+*****+`) in that file.
Therefore, all of the other list items will be nested beneath the title.

When a list doesn't have a title, each item with a single asterisk marker (`+*+`) becomes a top-level item to any list items that are nested directly under it.

----
* List item <.>
** A nested list item <.>
* Another list item <.>
----
<.> A top-level list item.
<.> This list item is nested under the preceding top-level list item.
<.> A top-level list item.

The greatest nesting depth allowed is level five (`+*****+`).
Each list item can have as many nested items as you need.

== Create a single list navigation file

Let's create a navigation file named [.path]_nav.adoc_ that defines a single navigation list for the pages in a module.
The most common items in a navigation list are xrefs to pages xref:organize-files.adoc[that belong to the same module as the navigation file].
The exercise below assumes that the navigation file will belong to the same component version and module as the pages it is referencing.
That means the resource IDs won't need to specify version, component, or module coordinates.

. Open a new file in the text editor or IDE of your choice.
. On the first line, type an asterisk (`+*+`), directly followed by a blank space.
Then type an xref macro prefix and the resource ID of the target page.
+
----
* xref:get-started.adoc
----

. At the end of the resource ID, complete the macro with a set of square brackets (`+[]+`).
Press kbd:[Enter] to go to the next line.
+
--
----
* xref:get-started.adoc[]
----

Since there isn't any link text specified inside the square brackets, Antora will use the value of the target page's xref:xrefs-and-link-text.adoc#default-link-text[default link text] when it generates the site.
--

. Let's add a nested list item.
Type two asterisks (`+**+`), followed by a blank space, and then an xref.
This time, enter link text inside the set of square brackets (`+[]+`).
+
--
----
* xref:get-started.adoc[]
** xref:install.adoc[Installation Setup and Steps]
----

The link text, _Installation Setup and Steps_, will be displayed in the component version page menu.
--

. Let's create another top-level item that's only text, i.e., it isn't a page reference.
On the next line, type an asterisk (`+*+`), a blank space, and then your text.
+
----
* xref:get-started.adoc[]
** xref:install.adoc[Installation Setup and Steps]
* CLI Commands and Options
----

. Now, nest a list item under the previous top-level item.
This item is a cross reference that will use the target page's default link text.
+
----
* xref:get-started.adoc[]
** xref:install.adoc[Installation Setup and Steps]
* CLI Commands and Options
** xref:commands.adoc[]
----

. Finally, nest a list item under the previous item.
Type three asterisks (`+***+`), followed by a blank space, and then an xref.
+
----
* xref:get-started.adoc[]
** xref:install.adoc[Installation Setup and Steps]
* CLI Commands and Options
** xref:commands.adoc[]
*** xref:commands-in-action.adoc[]
----

. Save the file as [.path]_nav.adoc_ in the xref:ROOT:module-directories.adoc#module-dir[module directory] that contains the page source files referenced in the list.
The navigation file should be located at the same hierarchy level as the [.path]_pages_ directory.
*Don't save it in the [.path]_pages_ folder!*
+
--
[listing]
----
📂 modules
  📂 a-module
    📂 pages
    📄 nav.adoc
----

You can also save the file with the filename of your choice, as long as the extension is _.adoc_.
--

You've now create a navigation file for a module!
Make sure you xref:register-navigation-files.adoc[register it in _antora.yml_] so it becomes part of the component version page menu.

// /docs/modules/navigation/pages/multiple-lists.adoc
[[multiple-lists.adoc]]
= Create a Navigation File with Multiple Lists

== Structuring multiple lists

A navigation file can contain more than one xref:asciidoc:ordered-and-unordered-lists.adoc#unordered[unordered AsciiDoc lists].
When a navigation file contains multiple lists:

* each list must start with a list title, and
* each list must be separated by at least one blank line.

----
.List title <.>
* List item
<.>
.Second list title <.>
* List item <.>
----
<.> Required list title.
A list title is preceded by a dot (`.`).
There must be *no spaces* between the `.` and the content of the title.
<.> Required blank line between lists.
<.> Required list title.
<.> List item.

When converted to HTML, the list titles become top-level items and all of their list items are nested under them in cascading order.
The blank line between the lists is not present in the published menu.

Each navigation list is made up of list items.

.Navigation file with multiple lists
----
.List title <.>
* List item <.>
* List item <.>
** Nested item <.>

.List title <.>
* List item
** Nested item

.List title
* List item
----
<.> A list title becomes the top-level list item of a list.
<.> A list item preceded by an unordered AsciiDoc list marker (`+*+`).
<.> Each list item must be entered on its own line.
<.> Enter a blank space between the last asterisk of a marker and the content of your list item.
<.> A list title, indicating the start of another navigation list.

Each list item is preceded by a marker.
An unordered AsciiDoc list's marker can range from one asterisk (`+*+`) to five asterisks (`+*****+`).

== Create a navigation file with two lists

Let's create a navigation file that contains two navigation lists for the pages in a module.
The most common items in a navigation list are xrefs to pages xref:organize-files.adoc[that belong to the same module as the navigation file].
The exercise below assumes that the navigation file will belong to the same component version and module as the pages it is referencing.
That means the resource IDs won't need to specify version, component, or module coordinates.

. Open a new file in the text editor or IDE of your choice.
. On the first line, type a dot (`.`), directly followed by an xref macro prefix and the resource ID of the target page.
+
----
.xref:get-started.adoc
----

. At the end of the resource ID, complete the macro with a set of square brackets (`+[]+`).
Press kbd:[Enter] to go to the next line.
+
--
----
.xref:get-started.adoc[]
----

Since there isn't any link text specified inside the square brackets, Antora will use the value of the target page's xref:xrefs-and-link-text.adoc#default-link-text[default link text] when it generates the site.
--

. Let's add a list item.
Type an asterisk (`+*+`), followed by a blank space, and then an xref.
This time, enter link text inside the set of square brackets (`+[]+`).
Press kbd:[Enter]
+
--
----
.xref:get-started.adoc[]
* xref:install.adoc[Installation Setup and Steps]
----

The link text, _Installation Setup and Steps_, will be displayed in the component version page menu.
--

. Let's start a new list.
Press kbd:[Enter] to insert a blank like between the lists.
On a new line, type a dot (`.`), directly followed by regular text.
This list title won't reference a page.
+
----
.xref:get-started.adoc[]
* xref:install.adoc[Installation Setup and Steps]

.CLI Commands and Options
----

. On the next line, type an asterisk (`+*+`), a blank space, and then an xref macro.
This item is a cross reference that will use the target page's default link text.
+
----
.xref:get-started.adoc[]
* xref:install.adoc[Installation Setup and Steps]

.CLI Commands and Options
* xref:commands.adoc[]
----

. Finally, nest a list item under the previous item.
Type two asterisks (`+**+`), followed by a blank space, and then an xref.
+
----
.xref:get-started.adoc[]
* xref:install.adoc[Installation Setup and Steps]

.CLI Commands and Options
* xref:commands.adoc[]
** xref:commands-in-action.adoc[]
----

. Save the file as [.path]_nav.adoc_ in the xref:ROOT:module-directories.adoc#module-dir[module directory] that contains the page source files referenced in the list.
The navigation file should be located at the same hierarchy level as the [.path]_pages_ directory.
*Don't save it in the [.path]_pages_ folder!*
+
--
[listing]
----
📂 modules
  📂 a-module
    📂 pages
    📄 nav.adoc
----

You can also save the file with the filename of your choice, as long as the extension is _.adoc_.
--

You've now create a navigation file for a module!
Make sure you xref:register-navigation-files.adoc[register it in _antora.yml_] so it becomes part of the component version page menu.

// /docs/modules/navigation/pages/xrefs-and-link-text.adoc
[[xrefs-and-link-text.adoc]]
= Page Xrefs and Link Text in Navigation Files
:navtitle: Page Xrefs and Link Text
:page-aliases: link-syntax-and-content.adoc
//Page Xrefs and Link Text

== Page xrefs

Cross references to pages in a navigation list are constructed using the xref:page:xref.adoc[AsciiDoc xref macro] and the resource ID of a page.

The xrefs in a navigation file's list most often target pages xref:organize-files.adoc[that belong to the same module as the navigation file].
In these cases, the resource IDs don't require the version, component, or module coordinates.
However, regardless of what component version a navigation file belongs to, you can still link to any page in the site from any navigation list, whether they belong to a xref:page:page-links.adoc#modules[different modules] or xref:page:page-links.adoc#component-versions[components].

.nav.adoc
----
* xref:filename.adoc[Optional link text] <.>
* xref:module:filename.adoc[] <.>
* xref:version@component:module:filename.adoc[] <.>
----
<.> Xref targeting a page in the same module.
The xref also specifies link text.
<.> Page in the same component version, but a different module.
<.> Page in another docs component.

Xrefs in navigation files can use the target page's <<default-link-text,default navigation link text>> or have link text specified inside the macro's square brackets (`+[]+`).
The link text is displayed in the component version's page menu.
When a visitor clicks on the link text, they're routed to the target page specified by the resource ID in the xref.
The link text, regardless of whether it's the default link text or specified in the xref, is also displayed in the breadcrumbs at the top of the target page.

[#default-link-text]
== Use the default navigation link text

Xrefs in a navigation file don't need to specify link text.

.nav.adoc
----
* xref:get-started.adoc[] <.>
----
<.> Xref that doesn't have any link text specified inside the macro's square brackets (`+[]+`).

Antora uses the value assigned to the optional xref:page:reftext-and-navtitle.adoc#navtitle[navtitle attribute] in the target page when the link text is unspecified.
When `navtitle` isn't set in the target page's header, Antora automatically assigns it the value of the page's reference text, which may either be the target page's xref:page:link-content.adoc#default[default reference text] or text assigned to the xref:page:reftext-and-navtitle.adoc#navtitle[reftext attribute].

NOTE: Antora doesn't populate an xref's link text when a xref:page:xref.adoc#id-fragment[fragment is appended to the resource ID of a page].
In such cases, you still need to explicitly specify the link text.

== Specify link text in an xref

You can enter link text directly in the xref macro and override the default link text supplied by the target page.

.nav.adoc
----
.The Special Project
* xref:index.adoc[What's Silver Leaf] <.>
** xref:ROOT:get-started.adoc#prereqs[Installation Prerequisites] <.>
** xref:team::contributing.adoc[] <.>

.Support
* xref:help.adoc[*Troubleshooting*] <.>
----
<.> Enter the link text between the xref macro's square brackets (`+[]+`).
<.> Xrefs where the target page's resource ID is appended with a fragment should specify link text.
<.> This xref will use the target page's default navigation link text.
<.> Specified link text can be marked up with inline formatting syntax.

The link text specified in the xref macros will be displayed in the component version page menu.

// /docs/modules/navigation/pages/reference-resources.adoc
[[reference-resources.adoc]]
= Attachment Xrefs in Navigation Files
:navtitle: Attachment Xrefs and Link Text

To xref:page:attachments.adoc[reference an attachment], use the AsciiDoc xref macro and the resource ID of the attachment.
The `attachment$` family coordinate must be specified in the attachment's resource ID.

.nav.adoc
[#ex-base]
----
* xref:attachment$filename.pdf[Our Brochure] <.>
* xref:version@component:module:attachment$filename.epub[Our Book] <.>
----
<.> Xref targeting an attachment that belongs to the same component version and module as the navigation file.
<.> Xref where the resource ID specifies an attachment that is in a different component version than the navigation file.

If you don't specify link text in an xref macro that targets an attachment, Antora displays the URL of the attachment as the link in the component version's page menu.

.nav.adoc
[#ex-no-text]
----
* xref:attachment$sample-project.zip[]
----

The computed URL resulting from <<ex-no-text>>, _+https://docs.example.com/component/version/module/_attachments/sample-project.zip+_, would display as a link in the page menu.

You can specify link text by entering it between the square brackets of the xref macro.

.nav.adoc
[#ex-text]
----
* xref:attachment$sample-project.zip[Practice Project]
----

Using <<ex-text>>, Antora would display the text _Practice Project_ as a link in the page menu.
When a visitor clicks on the link, their browser will download or display the published attachment depending on the file format of the attachment and their browser's settings.

// /docs/modules/navigation/pages/external-links.adoc
[[external-links.adoc]]
= Add Links to External Sites

A navigation list can contain links to external websites.
External links are links to websites or materials that aren't built as part of your site's Antora pipeline.
That is, the target doesn't belong to a component version.

== External links

Links to external websites and materials are created using the xref:asciidoc:external-urls.adoc#url-syntax[AsciiDoc URL syntax].
AsciiDoc's URL syntax requires that the target have a valid URI scheme (e.g., `https://`) and address.

----
* xref:get-started.adoc[]
** xref:install.adoc[]
* Support
** https://external-website.com[Link text]
** https://another-external-website.com
----

If you don't add a set of square brackets (`+[]+`) directly to the end of the URL and insert link text, the raw URL will be displayed in the component version page menu when the site is generated.

// /docs/modules/navigation/pages/format-content.adoc
[[format-content.adoc]]
= Format List Content

Link text and unlinked text can be formatted with AsciiDoc's inline formatting syntax.

== Unlinked text

You don't have to link all of the content in a navigation list to a page, resource, or external site.

.nav.adoc
----
* Unlinked Text
** xref:a-page.adoc[Linked Text]
* _Formatted Unlinked Text_
----

Unlinked text can be formatted using AsciiDoc's inline formatting syntax.

== Link text

Link text that's entered into an xref, link, or URL macro can be formatted using inline AsciiDoc syntax.

.nav.adoc
----
* xref:index.adoc[*Bold link text*]
* https://external-website.com[Some __ita__lic letters]
----

To format a page's default link text, you'll need to xref:page:reftext-and-navtitle.adoc#navtitle[markup the value assigned to navtitle].

// /docs/modules/navigation/pages/organize-files.adoc
[[organize-files.adoc]]
= Navigation File Locations
:page-aliases: filenames-and-locations.adoc
:description: An overview of the purpose of an Antora navigation source file, its file format, its naming parameters, and storage location patterns.
// Filters
:page-collections: core concepts
:page-tags: docs component

[#storage]
== File location

A common pattern is for each module directory to contain its own navigation file.
xref:ROOT:module-directories.adoc#module[Modules already represent logical groups of concepts or objectives], so it's likely that you'd arrange the xrefs to that module's pages into a continuous, hierarchical flow of navigation menu entries.
This also reduces the number of coordinates the resource IDs in the xrefs require when you add a page to the navigation file.

Navigation files should be stored at the base of a module directory, i.e., at the same level as a [.path]_pages_ family directory.
*Don't save navigation files inside a [.path]_pages_ folder*, otherwise the navigation files will be converted to pages and published as pages.

== Multiple files per module

A module directory can contain more than one navigation file.
This functionality helps you finely tune the navigation list order when you xref:register-navigation-files.adoc[register the navigation files] in an [.path]_antora.yml_ file.

== Alternative storage patterns

Storing a navigation file in the module it references simplifies the page cross references entered into it.
It also helps writers locate the navigation that's affected when they add pages to or remove pages from a module.
However, xrefs to other modules`' pages (and even other component versions`' pages) can be entered into any module's navigation file.
You just need to xref:page:page-links.adoc#modules[add the module coordinate] (or xref:page:page-links.adoc#component-versions[component name and version coordinates]) to the cross references you create in the navigation file.
For example, you could store a single navigation file in a component version's ROOT module, and, instead of having navigation files in each module in the component version, you could just add the cross references to pages in those other modules directly to the ROOT module's navigation file.

//A component menu is created when, at runtime, Antora combines one or more navigation files as instructed by a component descriptor file, converts the assembled navigation lists into HTML, wraps the HTML with a UI template, and publishes the resulting component navigation menus to your site.
//A component navigation menu allows site visitors to discover and navigate between a component's pages.
//Antora allows for a variety of use cases so that you can create, store, and assemble the navigation source files to suit your documentation requirements.
//The pages in the Site Navigation category describe the fundamentals of creating and storing navigation files in a documentation component.
// source nesting depth versus published nesting depth, titled versus non-titled lists

// /docs/modules/navigation/pages/include-lists.adoc
[[include-lists.adoc]]
= Compose Navigation Files

If you want to compose a navigation list from various files, perhaps to reuse the lists, organize them so they can be maintained by different people, or simply break them up, you can use the include directive.

== Include one navigation file into another

You can include one navigation file into another using the AsciiDoc include directive.
The target of the include directive must be a file that Antora classifies, meaning it must either be a page or a partial.
(Antora does not classify files located at the root of the module or in the modules folder).

Let's assume that one of the navigation lists is defined in the file [.path]_modules/ROOT/partials/getting-started.adoc_.

.modules/ROOT/partials/getting-started.adoc
----
.Getting Started
* xref:download.adoc[]
* xref:install.adoc[]
* xref:run.adoc[]
----

You can include this partial navigation file into the main navigation file, [.path]_modules/ROOT/nav.adoc_, as follows:

.modules/ROOT/nav.adoc
----
.Overview
* xref:index.adoc[]
* xref:contribute.adoc[]

\include::partial$getting-started.adoc[]
----

The _Getting Started_ list will be read from the partial file and included in the navigation after the _Overview_ list.

== Include a nested list

In some circumstances, you aren't sure where the partial list will be included in the navigation tree, and you cannot assume it's being added at the top level.
What you want is for the navigation list from the include to be a level below the current list item.

In order to accomplish this layout, wrap the included list in an open block:

----
* xref:parent.adoc[]
+
--
\include::partial$children.adoc[]
--
----

Antora will recognize this relationship and fuse the included list as a child of the list item to which it is attached.
(The open block container is discarded).

Let's assume that the getting started items are defined in the [.path]_modules/ROOT/partials/getting-started.adoc_ file as an anonymous list.

.modules/ROOT/partials/getting-started.adoc
----
* xref:download.adoc[]
* xref:install.adoc[]
* xref:run.adoc[]
----

Now we can include this list as a child of a _Getting Started_ item in the main navigation file.

.modules/ROOT/nav.adoc
----
* xref:index.adoc[]
* xref:contribute.adoc[]
* Getting Started
+
--
\include::partial$getting-started.adoc[]
--
* xref:reference.adoc[]
----

The list items from the partial file will be children of the _Getting Started_ item.

// /docs/modules/navigation/pages/register-navigation-files.adoc
[[register-navigation-files.adoc]]
= Register Navigation Files
:description: How to enlist navigation files in a component version descriptor so that Antora assembles them into a component version page menu.
// Filters
:page-tags: UI menu, antora.yml, component keys

== nav key

The `nav` key is set in a xref:ROOT:component-version-descriptor.adoc[component version descriptor file] ([.path]_antora.yml_).
It accepts a list of navigation files as values.
Each value specifies the path to an individual navigation file relative to [.path]_antora.yml_.
If you aren't familiar with how to set the `nav` key and assign it values, see xref:ROOT:component-navigation.adoc[].

== Register navigation files

When a navigation file is assigned to the `nav` key, this file is [.term]*registered*.
Only the contents of registered navigation files are assembled into, and published as, a xref:index.adoc#component-menu[component version page menu].

In <<ex-register>>, two navigation files have been registered.

.Register two navigation files in an antora.yml file
[#ex-register,yaml]
----
name: component-b
title: Component B
version: '1.0'
nav:
- modules/ROOT/nav.adoc # <.>
- modules/module-one/nav.adoc # <.>
----
<.> Value registering a navigation file located in the _ROOT_ directory.
<.> Value registering a navigation file located in the _module-one_ directory

The navigation lists in the two registered files will be published into a single component version page menu for _Component B 1.0_.

[#registration-order]
=== Registration order

The order of the `nav` key's values dictates the order the contents of the registered navigation files are assembled in the published component version page menu.
In <<ex-register>>, the contents of the ROOT module's navigation file will be at the top of the component version page menu and the contents of Module One's navigation file will be appended to the end of the ROOT navigation list.

// /docs/modules/playbook/pages/index.adoc
[[index.adoc]]
= Antora Playbook Introduction

On this page, you'll learn:

* [x] The purpose of an Antora playbook.
* [x] Where the playbook file is located.
* [x] The playbook file formats Antora accepts.
//* [x] How a playbook drives an Antora pipeline.

== What's an Antora playbook?

An Antora playbook makes it easy for technical writers to control what content is included in your site, what user interface (UI) is applied to it, and where the site is published using a playbook file.
The settings in the playbook file, in combination with CLI options and environment variables, tell Antora how to operate.

Specifically, a playbook tells Antora:

* [x] What information should be applied to the xref:configure-site.adoc[site globally], such as its title and URL.
* [x] The page that sits at the root of the site (i.e., xref:site-start-page.adoc[home or landing page content]).
* [x] Which xref:configure-content-sources.adoc[content repositories, branches, and tags] to feed into Antora.
* [x] What xref:asciidoc-attributes.adoc[AsciiDoc attributes] and xref:asciidoc-extensions.adoc[Asciidoctor extensions] should be applied site wide.
* [x] Which xref:configure-ui.adoc[UI bundle] to use to control the visual layout, style, and behavior of the pages.
* [x] Where the site should be xref:configure-output.adoc[published and in what output format].
* [x] How and when Antora should handle xref:configure-runtime.adoc[source repository updates, artifact updates, and its cache].

Additionally, certain settings in the playbook file can be overridden using xref:cli:options.adoc[CLI options] or xref:environment-variables.adoc[environment variables], which allows an operations team to tailor the behavior for specific environments, such as production.

== Where is a playbook stored?

include::partial$playbook-project-summary.adoc[]

== Playbook file formats

Playbooks can be written in YAML, JSON, and TOML.
YAML is a common configuration language for defining automated tasks and most of the playbook examples in this documentation use YAML.
But you're free to use any of these formats.

Regardless of its format, a playbook contains structured key-value pairs for specifying general site properties, content and UI input sources, and published output destinations and providers.

== Relative paths in a playbook

By default, Antora resolves relative paths in the playbook from the current working directory.
For example, the path [.path]_public_ is effectively [.path]_$PWD/public_.
If, instead, you want Antora to resolve relative paths from the directory where the playbook file is located, prepend `./` to the path (e.g., [.path]_./public_).

By starting relative paths with `./`, you make your playbook more portable.
It means you can run the `antora` command from any directory on the filesystem and the behavior will be the same.

If you don't start relative paths with `./`, the path Antora resolves is dependent on the current working directory.
To get portable behavior, you have to switch to the directory where the playbook file is located before running the `antora` command.

Only use bare relative paths if you intend the path to be tied to the current working directory.

//== How is a playbook created?

//== How does Antora get a playbook?

////
== Why does Antora need a playbook?

A playbook is the configuration object for Antora.
It tells an Antora pipeline what content to use, how the content should be processed, how the site should be generated, and where to publish the output.
The playbook is populated using a combination of a playbook file, CLI options, and environment variables.
////

// /docs/modules/playbook/pages/set-up-playbook.adoc
[[set-up-playbook.adoc]]
= Set Up a Playbook
:page-aliases: playbook-schema.adoc

Let's create a basic playbook file in the YAML format.
The steps in the following sections will walk you through setting up a playbook that configures a site title and URL, fetches source files from the Demo Component A and Demo Component B repositories, and applies Antora's reference UI to the converted pages.

== Configure your site's properties

First, let's configure your site's title and URL.

. Open a new file in the text editor or IDE of your choice.
You'll typically name this file [.path]_antora-playbook.yml_.
. On the first line, type `site:` and
press kbd:[Enter] to go to the next line.
+
--
[,yaml]
----
site:
----

The xref:configure-site.adoc[site key] accepts a map of key-value pairs that define global site properties.
--

. The xref:site-title.adoc[title key] is a child of `site`.
Type `title:{sp}` and then the text that will become the title of your site.
Press kbd:[Enter].
+
[,yaml]
----
site:
  title: My Demo Site
----

. Type `url:{sp}` and then the base URL of your site.
+
--
[,yaml]
----
site:
  title: My Demo Site
  url: https://docs.demo.com
----

Assigning an xref:site-url.adoc[absolute URL to the url key] activates secondary features such as the sitemap.
--

. On the next line, enter `start_page:{sp}` and the page ID of the page Antora should use as the site's home page.
+
--
[,yaml]
----
site:
  title: My Demo Site
  url: https://docs.demo.com
  start_page: component-b::index.adoc
----

The xref:site-start-page.adoc[start_page value] in the example above is the page ID for the latest version of the file [.path]_index.adoc_ that belongs to _Component B_.
In order for Antora to use this page, you need to tell Antora where to find the source files that belong to Component B.
--

In the next section, let's define the content sources URLs, branches, and start paths.

== Configure your site's content sources

Antora needs to know what git repositories, branches, and tags it should locate and fetch source files from, as well as the location of any content source roots that aren't at the root of a repository.
Let's define these keys in the playbook file you started in the previous section.

. Type `content:` flush against the left side of the file.
Press kbd:[Enter] to go to the next line.
+
[,yaml]
----
# ...
  start_page: component-b::index.adoc
content:
----

. The `sources` key is a child of `content`.
Type `sources:` and press kbd:[Enter].
+
--
[,yaml]
----
# ...
  start_page: component-b::index.adoc
content:
  sources:
----

The xref:configure-content-sources.adoc#sources-key[sources key] requires at least one `url` key be assigned a xref:content-source-url.adoc[remote repository URL or filesystem path].
Let's assign the URL for a remote repository named _Demo Component A_ to `url` in the next step.
--

. Type a hyphen (`-`) followed by a blank space.
Then type `url:{sp}` and the URL of a content source repository.
+
--
[,yaml]
----
# ...
  start_page: component-b::index.adoc
content:
  sources:
  - url: https://gitlab.com/antora/demo/demo-component-a.git
----

Now, Antora can locate the _Demo Component A_ repository.
But it also needs to know what branches and tags it should fetch.

The xref:content-branches.adoc#default[default branches filter] is applied at runtime when a `url` key doesn't have a `branches` or `tags` key set on it.
Since the _Demo Component A_ repository only has one branch, and that branch's name (`main`) falls within the parameters of the default filter, you don't need to explicitly set `branches` on this `url` key.
--

. Let's add the URL for the _Demo Component B_ repository.
On a new line, type `- url:{sp}` and the repository's URL.
+
--
[,yaml]
----
# ...
  start_page: component-b::index.adoc
content:
  sources:
  - url: https://gitlab.com/antora/demo/demo-component-a.git
  - url: https://gitlab.com/antora/demo/demo-component-b.git
----

The _Demo Component B_ repository uses branches for versioning.
The content source files in the branches `v1.0` and `v2.0` are ready for publishing.
However, you can't use the xref:content-branches.adoc#default[default branches filter] on this `url` because the files in the `main` branch shouldn't be published to the site.
Instead, you'll have to tell Antora what branches it should fetch from the _Demo Component B_ repository.
--

. On the next line, type `branches:{sp}` and an opening square bracket (`+[+`).
Inside the `+[+`, type each branch name that Antora should fetch.
Separate the values with commas.
It doesn't matter what order you list the branch names.
At the end of the list, type a closing square bracket (`+]+`).
Press kbd:[Enter].
+
--
[,yaml]
----
# ...
  start_page: component-b::index.adoc
content:
  sources:
  - url: https://gitlab.com/antora/demo/demo-component-a.git
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: [v2.0, v1.0]
----

Make sure to indent `branches` enough so the _u_ in `url` and _b_ in `branches` are lined up.

TIP: The `branches` key also accepts shell glob patterns.
For instance, you could define `branches: v*` on the `url` key for _Demo Component B_ to specify that Antora fetch the branches with the names `v1.0` and `v2.0`.

You're not done configuring the keys for the _Demo Component B_ repository just yet.
The xref:ROOT:content-source-repositories.adoc#content-source-root[content source root] in each branch isn't at the root of the repository, https://gitlab.com/antora/demo/demo-component-b/-/tree/main/docs[it's at _docs_].
You'll need to set the `start_path` key on `url` so Antora can locate the content source root.
--

. Type `start_path:{sp}` and the repository root relative path.
+
--
[,yaml]
----
# ...
  start_page: component-b::index.adoc
content:
  sources:
  - url: https://gitlab.com/antora/demo/demo-component-a.git
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: [v2.0, v1.0]
    start_path: docs
----

Don't add leading or trailing slashes to the path.
--

Now, you're ready to configure the final set of required keys that will tell Antora what UI it should apply to the site.

== Configure your site's UI bundle

Antora needs a xref:ui-bundle-url.adoc[UI bundle] in order to generate a site.
Let's tell Antora to use it's reference UI bundle by defining the required keys in the playbook file you worked on in the previous sections.

. Flush against the left side of the file, type `ui:`.
Press kbd:[Enter] to go to the next line.
+
[,yaml]
----
# ...
    start_path: docs
ui:
----

. The `bundle` key is a child of `ui`.
Type `bundle:` and press kbd:[Enter].
+
[,yaml]
----
# ...
    start_path: docs
ui:
  bundle:
----

. The `url` key is a child of `bundle`.
Type `url:{sp}` and then the URL of Antora's reference UI bundle.
+
--
[,yaml]
----
# ...
    start_path: docs
ui:
  bundle:
    url: https://gitlab.com/antora/antora-ui-default/-/jobs/artifacts/HEAD/raw/build/ui-bundle.zip?job=bundle-stable
----

Antora's reference UI archive changes over time, but its URL doesn't, so you need to activate the xref:ui-bundle-url.adoc#snapshot[snapshot key].
--

. On the next line, enter `snapshot:{sp}` and the value `true`.
+
--
[,yaml]
----
# ...
    start_path: docs
ui:
  bundle:
    url: https://gitlab.com/antora/antora-ui-default/-/jobs/artifacts/HEAD/raw/build/ui-bundle.zip?job=bundle-stable
    snapshot: true
----

When `snapshot` is set to `true`, Antora will download the UI bundle whenever xref:runtime-fetch.adoc[fetch] is activated in the playbook or from the CLI.
--

You're almost done!
Here's the entire playbook file you've assembled so far.

[,yaml]
----
site:
  title: My Demo Site
  url: https://docs.demo.com
  start_page: component-b::index.adoc
content:
  sources:
  - url: https://gitlab.com/antora/demo/demo-component-a.git
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: [v2.0, v1.0]
    start_path: docs
ui:
  bundle:
    url: https://gitlab.com/antora/antora-ui-default/-/jobs/artifacts/HEAD/raw/build/ui-bundle.zip?job=bundle-stable
    snapshot: true
----

This playbook will generate a site named _My Demo Site_ using the content files from the specified repository branches and the UI files from the specified UI bundle.

All you've got to do before running Antora on this playbook is save it.
Playbook files are often saved with the filename [.path]_antora-playbook.yml_ or a related filename, such as [.path]_local-antora-playbook.yml_, depending on the context in which it's used.

Once you've saved the playbook file, you're ready to xref:ROOT:run-antora.adoc[run Antora].

TIP: You can also get this playbook from the https://gitlab.com/antora/demo/docs-site[Demo Docs Site repository].

// /docs/modules/playbook/pages/configure-site.adoc
[[configure-site.adoc]]
= Site Keys

The playbook keys configured under `site` manage the site's published identity and how it interacts with certain applications once it's published.

[#site-key]
== site key

Global generated site files, service accounts, and other common properties are defined under the `site` key in a playbook file.
These settings are applied to the entire site when it's generated.

[,yaml]
----
site: # <.>
  title: Docs Site # <.>
  url: https://docs.example.org # <.>
  start_page: component-b::index.adoc # <.>
  robots: allow # <.>
  keys: # <.>
    google_analytics: XX-123456 # <.>
----
<.> Required `site` key
<.> Required `title` key
<.> Optional `url` key
<.> Optional `start_page` key
<.> Optional `robots` key
<.> Optional `keys` key
<.> Example `google_analytics` key

The `title` key in the `site` category is required.
The `url` key is optional, but recommended.
See xref:site-url.adoc#when-should-the-site-url-be-set[When should the site URL be set?] for details.
The other keys are optional; Antora will use default values if they're not specified.
Alternatively, `title`, `start_page`, and `keys` can be xref:cli:options.adoc[assigned from the CLI].
The `url` key can be assigned from the xref:cli:options.adoc#site-url[CLI] or using an xref:environment-variables.adoc[environment variable].

[#site-reference]
== Available site keys

[cols="3,6,1"]
|===
|Site Keys |Description |Required

|xref:site-keys.adoc[keys]
|Account and API keys for reference by the UI templates or extensions.
Accepts a map of name-value pairs that specify account identifiers for service integrations such as Google Analytics.
|No

|xref:site-robots.adoc[robots]
|Specifies whether Antora generates a _robots.txt_ file.
Accepts the values `allow`, `disallow`, and a custom, multi-line string.
Ignored if the sibling `url` key is not set.
|No

|xref:site-start-page.adoc[start_page]
|Accepts the resource ID of a page that specifies the start page of a site.
|No

|xref:site-title.adoc[title]
|Specifies the title of a site.
|Yes

|xref:site-url.adoc[url]
|Specifies the base URL of a site.
|No
|===

// /docs/modules/playbook/pages/site-url.adoc
[[site-url.adoc]]
= Site URL

[#url-key]
== url key

The `url` key for the site, defined under the xref:configure-site.adoc[site key] in the playbook, is optional, but recommended.
If this key isn't set, certain features of the site that require a site URL are automatically deactivated.
See <<when-should-the-site-url-be-set>> for details.

.antora-playbook.yml
[,yaml]
----
site:
  title: Site Title
  url: https://docs.example.com
----

The `url` key defines the location where the site can be accessed once it's published.
The value of the `url` key can either be an absolute URL (_\https://docs.example.com_, _\https://example.com/docs_) or a root-relative URL (_/products_).
*Do not include a trailing forward slash* in the `url` value unless the value is a single forward slash (_/_).

The site URL appears in the generated site wherever an absolute URL or a root-relative URL is required.
See xref:ROOT:how-antora-builds-urls.adoc[] to learn more.

Alternatively, the `url` key can be assigned from the CLI using a xref:cli:options.adoc#site-url[--url option] or using the  xref:environment-variables.adoc#site-url[URL environment variable].

[#absolute-site-url]
== Configure an absolute site URL

An absolute URL value starts with a URL scheme directly followed by a colon and two forward slashes (`https://`) and a domain (`docs.example.org`).
*Do not put a trailing forward slash at the end of the URL.*

.antora-playbook.yml
[,yaml]
----
site:
  title: Docs for Example Site
  url: https://docs.example.com
----

Absolute site URLs can include a subpath (e.g., _\https://example.com/docs_, _\https://example.com/path/to/subfolder_).
The [.term]*subpath*, also known as a *path segment* or *pathname*, represents the location from the root of the domain where the site managed by Antora is published.
If your site is published to a subfolder of your domain, then the absolute site URL must include this path.
The subpath has the same syntax as a root-relative URL.

.antora-playbook.yml
[,yaml]
----
site:
  title: Docs for Example Site
  url: https://example.com/docs
----

When an absolute site URL has a subpath, Antora extracts the subpath and assigns it to the xref:ROOT:how-antora-builds-urls.adoc#pathname[site pathname] (_/docs_, _/path/to/subfolder_) for use wherever a xref:ROOT:how-antora-builds-urls.adoc#domain-relative[domain-relative URL] is required.

See <<subpath>> for more information about publishing your site to a domain subfolder.

[#root-relative-site-url]
== Configure a root-relative site URL

The root-relative URL is a URL that's relative to the domain, but without having to specify the domain itself.
A root-relative URL must start with a forward slash (_/products_).

.antora-playbook.yml
[,yaml]
----
site:
  title: Docs Hosted Somewhere
  url: /products
----

You might use a root-relative URL instead of an absolute URL if identical sites must be published to or accessible via multiple domains.
By using a root-relative URL, you can take advantage of many of the benefits of assigning a site URL.
However, Antora deactivates any feature that depends on an absolute site URL when the value assigned to `url` isn't absolute.

Antora assigns the root-relative URL directly to the xref:ROOT:how-antora-builds-urls.adoc#pathname[site pathname] for computing xref:ROOT:how-antora-builds-urls.adoc#domain-relative[domain-relative URLs].
If you want to set `url` to a root-relative URL, but want the site pathname to be empty, set the value to a single forward slash.

.antora-playbook.yml
[,yaml]
----
site:
  title: The Docs
  url: /
----

[#when-should-the-site-url-be-set]
== When should the site URL be set?

An Antora site is designed to be viewable offline and from a local filesystem.
For this reason, the site URL is not required to build the site.

However, there are certain features related to publishing that require a site URL, some even an absolute URL.
When the site URL is not set, these features are automatically deactivated without notice.
This section identifies these features and which kind of site URL they require.

[#site-url-features]
=== Features that depend on the site URL

When the site URL is set to any allowable value, the following features are enabled:

* The `site-url` attribute is set on every AsciiDoc document.
* The `site.url` property is set in the UI model (using the value of the `site.url` key in the playbook).
* The xref:ROOT:how-antora-builds-urls.adoc#pathname[site pathname] property, `site.path`, is set in the UI model (derived from the `site.url` key in the playbook).
* The 404 page is generated.
* The [.path]_robots.txt_ file is generated if `site.robots` is also defined in the playbook.
* xref:urls-redirect-facility.adoc[Redirects] include the site pathname (`site.path`), if non-empty.
This does not affect the static redirect facility, which uses relative URLs.
* The link in the top-left corner of the navbar points to the site URL instead of a relative path (behavior specific to the default UI).

When the site URL is set to an absolute URL, the following additional features are enabled:

* The sitemap files are generated.
* The `page.canonicalUrl` is set in the UI model, which gets used by the reference UI to create the canonical link tag in the head.

If the site URL is not set, all the aforementioned features are deactivated.

[#subpath]
=== When should the site URL include a subpath?

The subpath of a site URL represents the location from the root of the domain where the site managed by Antora is located.
In other words, the site URL takes the visitor to the URL where the redirect for the site start page is located.
If your site is published to a subfolder of your domain, then the site URL should include this path (e.g., _/path/to/subfolder_).

When required, Antora uses the site URL to construct absolute and domain-relative URLs to pages in your site, which will always include the subpath, if specified.
This includes URLs in the sitemap (absolute URLs) as well as rewrite rules (domain-relative URLs).

Let's consider an example of how the subpath is used when creating a server redirect rule.
Assume the following conditions are true:

* The site is published to the [.path]_docs_ subfolder of the example.com domain.
* The page [.path]_new-page.adoc_ in the ROOT module of the versionless _component-a_ component defines the xref:page:page-aliases.adoc[page alias] [.path]_old-page.adoc_ (meaning [.path]_old-page.adoc_ was renamed to [.path]_new-page.adoc_).
* The xref:urls-redirect-facility.adoc[redirect facility] is set as `nginx`.
* You set the site `url` key to `\https://example.com` (the incorrect value) in your playbook.

When you run Antora, it generates the following redirect rule:

.A redirect entry that does not includes a subpath
[listing]
----
/component-a/old-page.html /component-a/new-page.html 301!
----

Notice that the domain-relative URLs in the redirect rule don't include the leading `/docs` segment.
That means if you visit _\https://example.com/docs/component-a/old-page.html_, you are *not* redirected to the new page, because the rule won't match.
Let's fix that.

Edit your playbook and set the `url` key to `\https://example.com/docs`.
Now when you run Antora, it generates the correct redirect rule:

.A redirect entry that includes a subpath
[listing]
----
/docs/component-a/old-page.html /docs/component-a/new-page.html 301!
----

Notice the leading `/docs` segment is present in the domain-relative URLs.
Now, when you visit _\https://example.com/docs/component-a/old-page.html_, you're redirected to the new page.

It's important to include the path in the <<absolute-site-url,absolute site URL>> if your site is published to a subfolder of your domain.
If you don't want to couple your site to a specific domain, assign a <<root-relative-site-url,root-relative site URL>> instead.
Either way, if you're publishing your site to a subfolder of your domain, you should include the subpath in the value you assign to the `url` key of the site.

== Canonical URL

Antora provides built-in support for canonical URLs.
A [.term]*canonical URL* is the absolute URL of the preferred version of a page; the page you want a search engine to index.

If you assign an absolute URL to the site URL, Antora computes and assigns the canonical URL to the `page.canonicalUrl` property in the UI model for any applicable page.
An applicable page is any publishable page in a component that has at least one non-prerelease version.
If the site URL is not set to an absolute URL, or the page is not in a component with at least one non-prerelease version, Antora does not populate the canonical URL.

The canonical URL is the absolute URL of the newest, non-prerelease version of a page.
The canonical URL is computed by prepending the site URL (including the subpath) to the (root-relative) URL of that page.

The canonical URL points to the current page only if the current page is the newest non-prerelease version.
Otherwise, the canonical URL points to the newest, non-prerelease version of the current page.

CAUTION: If the page has been deleted, the newest version of a page may not be in the latest version of the component.

=== Canonical URL link tag

In order for the canonical URL to be picked up by the search crawler, the UI template must include it in the page.
The canonical URL should be declared as the value of the `href` attribute on a `<link rel="canonical">` tag inside the `<head>` tag of the page.
Antora's default UI does this for you.
Here's the template logic from Antora's default UI that generates this `<link>` tag:

[,hbs]
----
{{#with page.canonicalUrl}}
<link rel="canonical" href="{{{this}}}">
{{/with}}
----

Here's how the canonical URL appears in the generated page:

[,html]
----
<link ref="canonical" href="https://docs.example.org/component-name/2.0/page-name.html">
----

Assuming the page to which the canonical URL refers is present in all versions of the component, all versions of the page will contain the same `<link>` tag.
If the page is in a prerelease version, it will refer back to the page in the latest (non-prerelease) version.

TIP: It's up the creator of a custom UI to decide whether to include the canonical URL in the page template.
Antora merely makes the information available via the UI page model.
Antora's default UI includes the required tag in the page template.

=== How the canonical URL works

The purpose of the canonical URL is to help search engines correlate versions of the same page and to suggest which version of the page is preferred (i.e., the version to index).
When the search engine comes across a page which has a canonical URL that's different from the current URL, the search engine should not index that page, but rather index the page to which the canonical URL points.
By defining the canonical URL, it should ensure that old versions of a page do not show up in search results.

One caveat is that if a page is present in old versions of a component, but not the latest version, the canonical URL will point to a page in an older version, and thus be indexed.
If you do not want this to happen, make sure that another page in the latest version of the component claims that page using a page alias.
That way, Antora will configure the canonical URL to point to the page that claims that page, thus avoiding the old page from being indexed.

Use the https://support.google.com/webmasters/answer/9012289?hl=en[URL inspection tool] to see what canonical URL Google has detected for a page, and whether a page is indexed.
See https://developers.google.com/search/docs/advanced/crawling/consolidate-duplicate-urls[Consolidating duplicate URLs] and https://support.google.com/webmasters/answer/10347851?hl=en[Canonical URL] to learn more about canonical URLs and how search engines like Google interpret them.

// /docs/modules/playbook/pages/site-title.adoc
[[site-title.adoc]]
= Site Title

[#title-key]
== title key

The `title` key is required.
It's configured under the xref:configure-site.adoc[site key] in a playbook.

.antora-playbook.yml
[,yaml]
----
site:
  title: Site Title
  url: https://example.org
----

The `title` key accepts a string that's displayed wherever the UI calls the site's title.
The `title` key can also be xref:cli:options.adoc#title[assigned from the CLI].

[#add-site-title]
== Add a site title

Use the `title` key to add a title to your site.

.antora-playbook.yml
[,yaml]
----
site:
  title: Demo Docs Site
----

The title is displayed wherever the site's UI calls this key.
Antora's reference UI displays the site title in the top left corner of the global navigation bar.

// /docs/modules/playbook/pages/site-start-page.adoc
[[site-start-page.adoc]]
= Site Start Page

When you assign the valid resource ID of a page to the `start_page` key in your playbook, site visitors will be redirected from the site's index page at the xref:site-url.adoc[site URL] to the URL of the start page.

[#start-page-key]
== start_page key

The `start_page` key is optional.
It's configured under the xref:configure-site.adoc[site key] in a playbook.

.antora-playbook.yml
[,yaml]
----
site:
  title: Site Title
  url: https://example.org
  start_page: component:module:file-coordinate-of-page.adoc
----

You can use any page that belongs to a component version as the index page for your site.
The `start_page` key accepts the resource ID of a page as a value.
*The resource ID must include the xref:page:resource-id-coordinates.adoc#id-component[component, module, and file coordinates]*.
The xref:page:resource-id-coordinates.adoc#id-version[version coordinate] can be specified if you want to use a specific version of a page instead of the latest version.
Alternatively, `start_page` can be assigned from the xref:cli:options.adoc#start-page[CLI].

If your site has an xref:ROOT:component-name-key.adoc#root-component[unversioned component named ROOT] (i.e., name: ROOT, version: +~+), that component will be published to the root of the site.
The component name will not appear in the URL of those pages.
That means that the index.adoc page in the ROOT module (i.e., modules/ROOT/pages/index.adoc) of the unversioned ROOT component implicitly acts as the site start page without having to specify it in the playbook.
In other words, the site start page is effectively `ROOT::index.adoc`.
If you specify a different site start page in this case, it will be ignored since the site already has a start page.

== Use a page's latest version

To have the `start_page` key always point to the xref:ROOT:how-component-versions-are-sorted.adoc#latest-version[latest version] of the specified page, don't enter the version coordinate in the resource ID of the page.

.antora-playbook.yml
[,yaml]
----
site:
  title: Demo Docs Site
  url: https://demo.antora.org
  start_page: component-b::index.adoc
----

For this example, let's say that version 2.0 is the latest version of Component B.
In this case, _\https://demo.antora.org/index.html_ will redirect to _\https://demo.antora.org/component-b/2.0/index.html_.

== Use a specific version of a page

If you want the site's start page to be a specific version of the designated page, include the xref:page:resource-id-coordinates.adoc#id-version[version coordinate in the resource ID].

.antora-playbook.yml
[,yaml]
----
site:
  title: Demo Docs Site
  url: https://demo.antora.org
  start_page: 1.0@component-b::index.adoc
----

In this example, _\https://demo.antora.org/index.html_ will redirect to _\https://demo.antora.org/component-b/1.0/index.html_.

NOTE: To configure a start page for a component version, see xref:ROOT:component-start-page.adoc[].

// /docs/modules/playbook/pages/site-robots.adoc
[[site-robots.adoc]]
= Robots
:url-robots-standard: https://en.wikipedia.org/wiki/Robots_exclusion_standard

Antora can generate a {url-robots-standard}[robots.txt file] to control which paths site crawlers can visit.

[#robots-key]
== robots key

The `robots` key is optional.
It's configured under the xref:configure-site.adoc[site key] in a playbook.
Its accepted values are:

`allow`:: Allow all user agents to access all paths in the published site.
`disallow`:: Disallow all user agents from accessing all paths in the published site.
custom multi-line string:: Non-empty, user-specified string that's used as the contents of the generated [.path]_robots.txt_ file.

.antora-playbook.yml
[,yaml]
----
site:
  title: Site Title
  url: https://example.org
  robots: disallow
----

Antora will generate the [.path]_robots.txt_ file at the root of the site.

The `robots` key depends on the sibling `url` key.
If the `url` key isn't assigned a value, Antora won't generate a [.path]_robots.txt_ file even if `robots` is set to an allowable value.

[#allow-or-disallow-robots]
== Assign allow or disallow to robots

Let's assume the `url` and `robots` keys are defined as follows:

.antora-playbook.yml
[,yaml]
----
site:
  title: Demo Docs Site
  url: https://demo.antora.org
  robots: allow
----

This will generate a [.path]_robots.txt_ file that allows user agents access to all of the site's paths.

.Generated robots.txt
....
User-agent: *
Allow: /
....

Similarly, if the `url` and `robots` keys are defined as follows:

.antora-playbook.yml
[,yaml]
----
site:
  title: Demo Docs Site
  url: https://demo.antora.org
  robots: disallow
----

This will generate a [.path]_robots.txt_ file that disallows access to all paths.

.Generated robots.txt
....
User-agent: *
Disallow: /
....

== Generate robots.txt with custom content

Any other non-empty value assigned to `robots` will be used as the contents of the [.path]_robots.txt_ file.
For example, let's assume the `robots` key is declared as follows:

.antora-playbook.yml
[,yaml]
----
site:
  title: Demo Docs Site
  url: https://demo.antora.org
  robots: |
    User-agent: *
    Disallow: /private/
----

This will result in the following [.path]_robots.txt_ file being generated.

.Generated robots.txt
....
User-agent: *
Disallow: /private/
....

// /docs/modules/playbook/pages/site-keys.adoc
[[site-keys.adoc]]
= Account and API Keys

The `keys` key accepts a map of name-value pairs that specify account identifiers used for service integrations such as Google Analytics or search tools.

[#keys-key]
== keys key

The `keys` key is optional.
You define the `keys` key under the xref:configure-site.adoc[site key] in a playbook.
`keys` accepts a list of name-value pairs (aka subkeys) that specify account identifiers.

.antora-playbook.yml
[,yaml]
----
site:
  title: Site Title
  url: https://example.org
  keys:
    name-of-account-key: 'identifier'
    google_analytics: 'XX-123456'
----

The value of these keys can then be accessed by a UI template from the `site.keys` property in the UI model.
When assigned to the UI model, the name is converted to camelCase (regardless of whether words in the name are separated using hyphens or underscores).
For example, you can access the keys defined in the example above as `site.keys.nameOfAccountKey` and `site.keys.googleAnalytics`, respectively.

Site keys can also be configured from the xref:cli:options.adoc#key[CLI].

[#google-analytics-key]
== Add a Google Analytics account

The `google_analytics` key assigns a Google Analytics account to the site.
Setting this option implicitly enables the Google Analytics / Tag Manager embed code when using the default UI.

.antora-playbook.yml
[,yaml]
----
site:
  title: Demo Docs Site
  url: https://demo.antora.org
  keys:
    google_analytics: 'XX-123456'
----

We recommend enclosing the value in single quotation marks (`'`) to prevent it from being mangled by the YAML parser.
The `google_analytics` key can also be configured from the xref:cli:options.adoc#key[CLI] and using the xref:environment-variables.adoc[GOOGLE_ANALYTICS_KEY environment variable].

// /docs/modules/playbook/pages/configure-content-sources.adoc
[[configure-content-sources.adoc]]
= Content Keys

The playbook keys configured under `content` and `sources` define the locations of the content source repositories and how they're processed.

[#content-key]
== content key

The `content` category key encapsulates the list of content sources (i.e., git repositories) in an Antora site.
The content sources are defined using the `sources` key.
The `branches`, `tags`, and `edit_url` keys can be used to define default values for all content sources.
These keys can be redefined per content source, alongside other keys that are specific to a content source.

[,yaml]
----
content: # <.>
  branches: [v2.0, v2.5, v3.0] # <.>
  tags: [release/*, '!release/*-patch'] # <.>
  edit_url: '{web_url}/blob/{refname}/{path}' # <.>
  sources: # <.>
  - url: https://git-service.com/org/repo-z.git # <.>
    start_path: path-to/content-source-root # <.>
  - url: https://git-service.com/org/repo-y.git # <.>
----
<.> Required `content` key
<.> Optional `branches` key
<.> Optional `tags` key
<.> Optional `edit_url` key
<.> Required `sources` key
<.> Required `url` key
<.> Optional `start_path` key
<.> Another `url` key

The `content` and `sources` keys are required.
The `sources` key must contain at least one entry with the `url` key defined.
All other keys are optional.
The xref:content-branches.adoc#default[branches] and xref:content-edit-url.adoc#default[edit_url] keys have built-in values Antora automatically applies at runtime if they're not explicitly set in the playbook.

Keys-value pairs that are specified directly under `content` are applied to all of the `url` key entries under `sources`, unless the key is also specified on a specific `url`.

[#sources-key]
== sources key

The `sources` key is required and nested under the `content` key.
The `sources` key contains a list of source entries.
Each entry, designated by a hyphen, consists of a git repository location (URL or filesystem path), patterns to match branches and/or tags, an optional start path or paths, and other repository properties that Antora uses when aggregating the site content.

[,yaml]
----
content: # <.>
  sources: # <.>
  - url: https://git-service.com/org/repo-z.git # <.>
    branches: [v1.*, v2.*, !v1.2] # <.>
    start_paths: path-to/content-source-root-{item..item} # <.>
  - url: https://git-service.com/org/repo-y.git # <.>
    branches: [] # <.>
    tags: [release/*, '!release/*-patch'] # <.>
    start_path: path-to/content-source-root # <.>
    edit_url: '{web_url}/blob/{refname}/{path}' # <.>
  - url: https://git-service.com/org/repo-x.git # <.>
    branches: v* # <.>
    version: true # <.>
----
<.> Required `content` key
<.> Required `sources` key
<.> Required `url` key
<.> Optional `branches` key
<.> Optional `start_paths` key
<.> Another `url` key
<.> Optional `branches` key
<.> Optional `tags` key
<.> Optional `start_path` key
<.> Optional `edit_url` key
<.> Another `url` key
<.> Optional `branches` key
<.> Optional `version` key

The `sources` key must contain at least one entry with the `url` key defined.
All other keys are optional.
The xref:content-branches.adoc#default[branches] and xref:content-edit-url.adoc#default[edit_url] keys have built-in values Antora automatically applies at runtime if they're not explicitly defined in the playbook.

NOTE: If no git references (branches or tags) are matched for a content source entry, Antora will log a message at the info level.
You must have the log severity level set to at least info to see this message.
We recommend configuring Antora's logger accordingly to aid with debugging.

The `version` key provides a fallback value for the `version` key in the xref:ROOT:component-version-descriptor.adoc[component version descriptor (_antora.yml_)].
You should only use it if you're matching a single reference or you want the value to be derived from the refname.

[#content-reference]
== Available content keys

The following keys can be defined under the `content` key.
With the exception of the `sources` key, which contains the source entries themselves, these keys are used to provide default values for each source entry.

[cols="3,6,1"]
|===
|Content Keys |Description |Required

|xref:content-branches.adoc[branches]
|Accepts a list of exact branch names and name patterns to use from the repository specified in the content source.
|No

|xref:content-edit-url.adoc[edit_url]
|Accepts a URL pattern for building the URL that maps to the source view for the current page.
Accommodates the following placeholder segments: `+{web_url}+`, `+{refname}+`, `+{refhash}+`, and `+{path}+`.
|No

|xref:content-source-url.adoc[sources]
|Accepts a list of content source entries that specify which repositories and repository references to use as content.
|Yes

|xref:content-tags.adoc[tags]
|Accepts a list of exact tag names and name patterns to use from the repository specified in the content source.
|No
|===

[#content-source-reference]
== Available content source keys

[cols="3,6,1"]
|===
|Content Keys |Description |Required

|xref:content-branches.adoc[branches]
|Accepts a list of exact branch names and name patterns to use from the repository specified in the content source.
If not specified, defaults to the value of the `branches` key defined on the `content` key.
|No

|xref:content-edit-url.adoc[edit_url]
|Accepts a URL pattern for building the URL that maps to the source view for the current page.
Accommodates the following placeholder segments: `+{web_url}+`, `+{refname}+`, `+{refhash}+`, and `+{path}+`.
|No

|xref:content-source-start-path.adoc[start_path]
|Specifies the relative path in the repository to a content source root's location.
|No

|xref:content-source-start-paths.adoc[start_paths]
|Accepts a list of repository relative path patterns to content source root locations, either as exact paths or shell glob patterns.
Single values are coerced into an array.
|No

|xref:content-tags.adoc[tags]
|Accepts a list of exact tag names and name patterns to use from the repository specified in the content source.
|No

|xref:content-source-url.adoc[url]
|Accepts the URL of a git repository, which can either be an HTTPS URL or a local filesystem path.
|Yes

|xref:content-source-version.adoc[version]
|Provides a fallback value for the `version` key in the component version descriptor for all references matched.
|No

|xref:content-worktrees.adoc[worktrees]
|Accepts a keyword or list of exact branch names or name patterns to control which corresponding worktrees Antora should use.
|No
|===

// /docs/modules/playbook/pages/content-source-url.adoc
[[content-source-url.adoc]]
= URLs for Content Sources

The `url` key tells Antora where to find a content source repository.

[#url-key]
== url key

Antora can connect to public and private git repositories that are defined be a `url` key in a playbook.
At least one `url` key must be specified under the `sources` key.
You can add as many `url` keys as you need.
Each `url` key tells Antora where to find a git repository that contains content source files.

.antora-playbook.yml
[,yaml]
----
content:
  sources:
  - url: https://git-service.com/org/repo.git
  - url: /absolute/path/to/local-repo
----

The `url` key accepts any URI that git supports, including a local filesystem path.

Like with git, Antora differentiates between a local filesystem path and a remote URI based on certain characters in the value.
If the value matches either of the two rules listed below, the value will always be handled as a remote URI, *not* a local filesystem path.

* The value contains a colon that's not followed by a forward slash or backslash (`host:repo`).
* The value contains a colon that's followed by two forward slashes (`://`).

//A colon is permitted when it's part of a Windows drive letter (e.g., `c:/`).

[#remote-urls]
== Use remote content repositories

All remote content repositories must be accessible via a URL (a web address that's fetched using either the basic or encrypted HTTP protocol) (i.e., http:// or https://).
The repository location can be expressed using a URL, an SSH URI, or a git URI.
Internally, that location is always converted to a URL.

[,yaml]
----
content:
  sources:
  - url: https://git-service.com/org/repo-z.git
  - url: git@git-service.com:org/repo-y.git
  - url: git://git-service.com/org/repo-x.git
----

Whether the [.path]_.git_ extension is required depends on the settings of the git host.
It's not needed for repositories hosted on GitHub, required for repositories hosted on GitLab, and forbidden for repositories hosted on Team Foundation Server (TFS) or Azure DevOps, to cite a few scenarios (and to exhibit the nature of the problem).
That's why the xref:git-suffix.adoc[ensure_git_suffix key] is provided for you, which is enabled by default.

Antora can connect to private git repositories as long as a xref:private-repository-auth.adoc[supported authentication method] is specified for the private content source repositories.

[#local-urls]
== Use local content repositories

Antora permits the value of `url` to be a relative or absolute filesystem path to a local repository (even if the repository has no commits).

[,yaml]
----
content:
  sources:
  - url: /absolute/path/to/local-repo # <.>
  - url: https://git-service.com/org/repo-z.git
  - url: ./another-local-repo # <.>
----
<.> Absolute path to git repository
<.> Relative path to git repository (starting from the directory of the playbook)

include::partial$relative-path-rules.adoc[]

[#git-worktree]
== Use the git worktree

When the URL for a content source is a local repository, and the xref:content-branches.adoc[branches filter] matches the branch that's currently checked out (aka the worktree branch), Antora reads files from the worktree (i.e., the working directory on the local filesystem) *instead of* from the git index.
This behavior is central to the xref:author-mode.adoc[author mode] in Antora.
It means you *don't have to commit files locally* before Antora can use them.

.Use files from the worktree
[,yaml]
----
content:
  sources:
  - url: ./demo-component-b
    branches: main
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: v1.0, v2.0
----

Instead of specifying the name of the current branch explicitly, you can use the symbolic name `HEAD` as an alias for the current branch name.
This saves you the trouble of having to update your playbook when you switch branches.

.Use files from the worktree
[,yaml]
----
content:
  sources:
  - url: ./demo-component-b
    branches: HEAD
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: v1.0, v2.0
----

CAUTION: If the branches filter matches both the worktree branch and another branch that contains the same files for the same component version, Antora will fail to run because it does not permit duplicate files.

== Bypassing the git worktree

To ensure Antora *doesn't* use files from the worktree, even if the branch filter matches the worktree branch, you can point the URL directly at the [.path]_.git_ directory.
This effectively hides the worktree from Antora so it won't get used.

.Refers directly at the .git folder to bypass files in the worktree
[,yaml]
----
content:
  sources:
  - url: ./demo-component-b/.git
    branches: HEAD
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: v1.0, v2.0
----

A better way to bypass the git worktree is to set the `worktrees` key to `false`.

.Sets worktrees to false to bypass files in the worktree
[,yaml]
----
content:
  sources:
  - url: ./demo-component-b
    branches: HEAD
    worktrees: false
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: v1.0, v2.0
----

Keep in mind that, in this case, *all files must be committed locally* in order for Antora to use them.

// /docs/modules/playbook/pages/private-repository-auth.adoc
[[private-repository-auth.adoc]]
= Private Repository Authentication
:url-create-personal-token-github: https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token
:url-create-installation-token-github: https://docs.github.com/en/apps/creating-github-apps/authenticating-with-a-github-app/generating-an-installation-access-token-for-a-github-app
:url-create-personal-token-gitlab: https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html
:url-create-deploy-token-gitlab: https://docs.gitlab.com/ee/user/project/deploy_tokens/
:url-create-app-pass-bitbucket: https://support.atlassian.com/bitbucket-cloud/docs/app-passwords/
:url-credential-store: https://git-scm.com/docs/git-credential-store
:url-credential-manager-plugin: https://github.com/isomorphic-git/isomorphic-git/blob/v0.78.5/docs/plugin_credentialManager.md
:url-oauth2-formats: https://isomorphic-git.org/docs/en/authentication
:url-github-pat-example: https://rmoff.net/2023/12/19/deploying-antora-with-github-actions-and-a-private-github-repo/
:url-github-iat-example: https://rmoff.net/2024/01/17/antora-deployment-to-cloudflare-across-private-repositories-with-github-actions/

In order for Antora to access private repositories, you must supply it with authentication credentials for any private repository URL you use in your playbook.
These credentials can be externalized so they don't have to be hard-coded into the playbook.
This page covers various ways you can pass the credentials to Antora, including the built-in git credential store, a custom credential store, and even your own credential manager.

Let's start by looking at the authentication credential types Antora accepts by default, then move on to how to set them up and put them to use.

== Credential types

Antora can authenticate with private repositories using HTTP Basic authentication.
HTTP Basic authentication requires sending credentials to the server (over HTTPS) to verify your identity.
Authentication credentials consist of either a username/password pair or an access (OAuth 2.0) token.

The username/password pair is usually what you use to log in to the service (GitHub, GitLab, etc.) where the repository is hosted.
If the username or password contains characters which have special meaning in a URL, such as `/`, `#`, and `:`, these characters must be URL encoded (i.e., percent encoded) so they aren't misinterpreted by the URL parser.
Keep in mind that while some git hosts support this means of authentication, others do not.
You may have better luck using an access token.

When two-factor authentication (2FA) is enabled on your account, you can't use the username/password pair to authenticate with a private repository.
You'll receive the error _401 HTTP Basic: Access Denied_ when you try.

Regardless of the reason, if the git host does not allow you to authenticate using a username/password pair, you'll need to use an access token instead.

There are two types of access tokens: personal access tokens and deploy tokens.

* A [.term]*personal access token* is bound to the user and grants access to any private repository that your account can access (subject to the scope settings of the token itself).
* A [.term]*deploy token* (not a deploy key) is bound to the project (i.e., repository) and grants access to a single repository (subject to the scope settings on the token itself).

Deploy keys _cannot_ be used with Antora since they require the use of <<ssh-auth>>, which the git client in Antora does not support.

You typically use a single personal access token on your own machine and one or more deploy tokens on a CI server.

=== GitHub

To create an access token for *GitHub*, see {url-create-personal-token-github}[Creating a personal access token (PAT) for the command line^].
GitHub has two types of access tokens, fine-grained and classic.
Both are supported by Antora, though the fine-grained token must be granted the Contents permission to the repositories you want to use.

GitHub also supports {url-create-installation-token-github}[Installation Access Tokens (IAT)^], which are bound to an application instead of user.
These access tokens are more suitable for use in an organization.

GitHub does not support deploy tokens at this time.

To learn more about how to create access tokens for use with GitHub, refer to the articles {url-github-pat-example}[Antora with GitHub PAT^] and {url-github-iat-example}[Antora with GitHub IAT^].

=== GitLab

To create an access token for *GitLab*, see {url-create-personal-token-gitlab}[Personal Access Tokens^] and {url-create-deploy-token-gitlab}[Deploy Tokens^].

=== Bitbucket

For *Bitbucket*, you'll need to create an {url-create-app-pass-bitbucket}[app password^] with read access to repositories.
An app password is a user-based access token.

Now let's see how to supply these credentials to Antora's built-in credential manager via the default git credential store.

== Supply credentials using the default git credential store

By default, Antora's built-in credential manager automatically checks for credentials in the {url-credential-store}[git credential store^] (a database file).
The default path for the git credential store is _$HOME/.git-credentials_, or _$XDG_CONFIG_HOME/git/credentials_ if the first location doesn't exist.
Note that this path is a *file*, not a directory.

Since Antora consults the credential manager automatically when credentials are requested by the git host (aka on demand), you don't have to specify credentials directly in your playbook.
In fact, the content sources in your playbook that are private will look just like content sources that are public.
Here's how a private content source in your playbook might look:

[,yaml]
----
content:
  sources:
  - url: https://hostname/your-org/private-repository
----

When Antora is notified by the git host that a URL requires authentication, it will look for a matching entry in the credentials store.
Antora looks for a match using the URL as the key.
If a protocol (e.g., `https`) and hostname (and, optionally, the repository path) are found in the credentials store, those credentials are returned to Antora's credential manager and passed on to the git server.

The credential store contains zero or more line-based entries.
If you need to specify multiple credentials for a single hostname (such as multiple deploy tokens), put each entry on its own line.
The structure of each entry is as follows:

[listing]
----
https://<credentials>@<hostname>
----

`<credentials>` is either a username/password pair (`username:password`) or an access token (`token:`).
`<hostname>` is the address of the git server (e.g., `github.com`).

[IMPORTANT]
====
If the username or password contains characters which have special meaning in a URL, such as `/`, `#`, or `:`, these characters must be URL encoded.
(The `@` does not have special meaning in a username or password).
It's usually safe to always URL encode the username and password components in the URL.
This requirement only applies for URLs that are defined in the git credential store.

To URL encode a component, open the JavaScript console in your browser, and run `encodeURIComponent('<component>')`, where `<component>` is the username or password value.
Use the printed result in place of your username or password, if different.
For example, the URL encoded version of `my#password` is `my%23password`.
====

You can populate the credential store interactively using the system `git` command or by editing the credential store directly.
Let's start with the interactive approach.

[#populate-credentials-interactively]
=== Populate the credential store interactively

You can use the `git` command to populate the credential store interactively.
This approach is especially useful since it allows you to verify that your credentials are accepted by the git server.

First, select the URL of a private repository you want to use with Antora.
Next, in your terminal, run the following command for each private repository you need to access from Antora:

 $ echo -n 'Repository URL: ' && read REPLY && \
   git -c credential.helper=store ls-remote -h $REPLY > /dev/null

This command performs the following steps:

. Prompts you for the URL of a private repository.
. Communicates with the private repository, triggering a prompt for your credentials.
+
NOTE: If you aren't prompted for your credentials, it means your credentials are already stored.

. Stores the credentials in the [.path]_$HOME/.git-credentials_ file (and assigns it the appropriate permissions).

If this script succeeds, you can use the applicable private repositories in Antora without any further configuration.

If the interactive approach didn't work for you, you can populate the credential store directly.
Let's give that a shot.

[#populate-credentials-directly]
=== Populate the credential store directly

To add credentials to the git credential store directly, create the file (not directory) [.path]_$HOME/.git-credentials_ and open it in your editor.
Put each unique set of credentials (i.e., username/password pair or access token plus hostname and optional repository path) on its own line.
If you're using a single git host and a personal access token, you only need one entry.
If you're using multiple git hosts or multiple deploy tokens, you'll need more than one entry.

Here's an example entry that uses a username/password pair:

[listing]
----
https://octocat:ilovegit@github.com
----

Here's an example that uses a token (pay attention to the trailing `:` after the token):

[listing]
----
https://abcdefg0123456:@github.com
----

To use different credentials for a given repository on the same git host, you can append a repository path (i.e., `<repo>`) to the entry to make the matching more strict.
(The `.git` file extension in the repository path is optional).

[listing]
----
https://<credentials>@<hostname>/<repo>
----

Here's an example of an entry for a specific repository path:

[listing]
----
https://octocat:ilovegit@github.com/octocat/Hello-World
----

Here are examples for several popular git hosts (for which you'd substitute the placeholders in bold with the real values):

.Formats supported by popular Git hosts for embedding credentials in the URL
[listing#host-credential-structure,subs=+quotes]
----
https://**TOKEN**:@github.com/org/project-docs
https://oauth2:**TOKEN**@gitlab.com/org/project-docs.git
https://gitlab+deploy-token-**TOKEN_ID**:**TOKEN**@gitlab.com/org/project-docs.git
https://x-oauth-token:**TOKEN**@bitbucket.org/org/project-docs.git
https://**USERNAME**:**APP_PASSWORD**@bitbucket.org/org/project-docs.git
----

NOTE: Specifying the repository path in the URL is optional.
If you don't include it, that credential pair will be used for all URLs that share the same git host.

CAUTION: You may need to append the `.git` file extension depending on which URL format you use for your content sources and whether you've configured the xref:git-suffix.adoc[ensure_git_suffix key] in your playbook.

NOTE: Notice that the tokens are located in different locations in the URL depending on the git host.
See {url-oauth2-formats}[OAuth2 formats^] for more details.
If you're using a Bitbucket app password, notice you must include your own username (using the format `USERNAME:APP_PASSWORD`).

To ensure the credentials file is protected, immediately set its file permissions so it cannot be read by others.

 $ chmod 600 $HOME/.git-credentials

[#custom-credential-path]
== Specify a custom git credential store path

Instead of using the credential store at the default path(s), you can instruct Antora to look for the file in a different location using either the `--git-credentials-path` CLI option or `GIT_CREDENTIALS_PATH` environment variable, both of which set the `git.credentials.path` playbook key at runtime.

Here's an example that uses the CLI option to specify a path relative to the playbook file:

 $ antora --git-credentials-path=./.git-credentials antora-playbook.yml

To learn more about how to use the `git.credentials.path` playbook key, including how to set it directly in the playbook, consult the reference for the xref:git-credentials-path-and-contents.adoc#path-key[git.credentials.path key].

[#git-credentials-environment-variable]
== Pass credentials via an environment variable

Instead of reading the credentials from a file, you can have Antora read the credentials directly from the environment variable named `GIT_CREDENTIALS`, which sets the `git.credentials.contents` playbook key at runtime.

Here's an example that demonstrates the concept:

 $ export GIT_CREDENTIALS='https://octocat:ilovegit@github.com'
 $ antora antora-playbook.yml

You can even reduce this to a single line (which only defines the environment variable for the scope of the command):

 $ GIT_CREDENTIALS='https://octocat:ilovegit@github.com' antora antora-playbook.yml

When using the Windows command prompt, you need to define the environment variable using the `set` command:

 C:\> set "GIT_CREDENTIALS=https://octocat:ilovegit@github.com" && antora antora-playbook.yml

This strategy is most useful in a CI environment where environment variables can be secured.
It's also a quick and informal way of passing credentials to Antora when generating the site on your own machine.

When using the environment variable, multiple entries may be separated either by a comma or a newline character.
For example:

 $ GIT_CREDENTIALS='https://my-github-token:@github.com,https://oauth2:my-gitlab-token@gitlab.com' antora antora-playbook.yml

Exporting the environment variable saves you from having to type it each time you run Antora.

To learn more about how to use the `git.credentials.contents` playbook key, including how to set it directly in the playbook, consult the reference for the xref:git-credentials-path-and-contents.adoc#contents-key[git.credentials.contents key].

== Encode credentials in a URL (not recommended)

Another option for passing credentials to the credential manager is to encode them directly in the URL listed in the playbook.
Since this option doesn't trigger the challenge-response workflow, Antora automatically assumes the repository is private.

WARNING: This strategy is not recommended unless you're using a placeholder to inject the real credentials, as described at the end of this section.

Antora will extract the credentials that precede the hostname (i.e., `username:password@` or `token@`) and use them to perform authentication on your behalf if requested by the server.

Here are examples for several popular git hosts (for which you'd substitute the placeholders in bold with the real values):

.antora-playbook.yml (fragment)
[,yaml,subs=+quotes]
----
content:
  sources:
  - url: https://**TOKEN**:@github.com/org/project-docs
  - url: https://oauth2:**TOKEN**@gitlab.com/org/project-docs.git
  - url: https://gitlab+deploy-token-**TOKEN_ID**:**TOKEN**@gitlab.com/org/project-docs.git
  - url: https://x-oauth-token:**TOKEN**@bitbucket.org/org/project-docs.git
  - url: https://**USERNAME**:**APP_PASSWORD**@bitbucket.org/org/project-docs.git
----

NOTE: Notice that the tokens are located in different locations in the URL depending on the git host.
See {url-oauth2-formats}[OAuth2 formats^] for more details.
If you're using a Bitbucket app password, notice you must include your own username (using the format `USERNAME:APP_PASSWORD`).

The drawback of this approach is that it requires putting the credentials directly into the playbook file.
Unfortunately, Antora does not yet support resolving environment variables located in the playbook file.
However, you can emulate this behavior by using a script to substitute references to an environment variable in the playbook file with its value.

Let's assume you have the following source defined in your playbook file:

.antora-playbook.yml (fragment)
[,yaml]
----
content:
  sources:
  - url: https://$GITHUB_TOKEN:@github.com/org-name/project-docs
----

If you're using multiple private repositories that require the same credentials, you can instead define the credentials once under the `git` key as follows:

.antora-playbook.yml (fragment)
[,yaml]
----
git:
  credentials:
    contents: https://$GITHUB_TOKEN:@github.com
----

You can then use the following script to expand the references to the environment variable, which you may run in CI prior to invoking Antora:

 $ sed -i s/\$GITHUB_TOKEN/$GITHUB_TOKEN/ antora-playbook.yml
 $ antora antora-playbook.yml

Despite this workaround, we still recommend using the credential store integration described earlier.

[#custom]
== Configure a custom credential manager

The git client used by Antora, isomorphic-git, provides a {url-credential-manager-plugin}[pluggable credential manager^] for looking up authentication credentials.
Antora provides a default implementation of this plugin.
As you've seen in previous sections, this implementation assumes Antora can access the credentials directly, in plain text, either via a file or environment variable.
If this arrangement does not meet your security requirements, you can replace the built-in credential manager with your own.

To write a custom credential manager, export a JavaScript object that implements the following methods:

.API for custom git credential manager
[,js]
----
configure ({ config, startDir })
async fill ({ url })
async approved ({ url })
async rejected ({ url, auth })
status ({ url })
----

The method that looks up the credentials is `fill`.
It must return either a `{ username, password }` or `{ token }` data object.
The `approved` and `rejected` methods are called when the credentials are approved or rejected by the server, respectively.

The optional `configure` and `status` methods are specific to Antora, extending the capabilities of what a credential manager in isomorphic-git typically provides.
If defined, the `configure` method is called each time Antora starts, providing an opportunity to perform initialization steps such as defining properties.
The `status` method, if available, is used by Antora to look up whether authentication was requested for a given URL.

To activate your custom credential manager, first write your implementation in a dedicated JavaScript file and configure it as the default export:

.custom-git-credential-manager.js
[,js]
----
module.exports = {
  async fill ({ url }) { ... },
  async approved ({ url }) { ... },
  async rejected ({ url, auth }) { ... },
}
----

Then register the credential manager with the playbook as follows:

[,yaml]
----
git:
  plugins:
    credential_manager: ./custom-git-credential-manager.js
----

Alternately, you can configure the plugin to self register:

.custom-git-credential-manager.js
[,js]
----
'use strict'

const git = require('isomorphic-git')

if (!git.cores) git.cores = new Map()
git.cores.set('antora', new Map().set('credentialManager', {
  async fill ({ url }) { ... },
  async approved ({ url }) { ... },
  async rejected ({ url, auth }) { ... },
}))
----

Notice that in this case, the plugin name is `credentialManager` rather than `credential_manager`.
That's because the playbook builder automatically camelCases the key name for us, which is the key name that git client expects.

When using a self-registering credential manager, you pass it to Antora using the `-r` option instead of registering it with the playbook:

 $ antora -r ./custom-git-credential-manager.js antora-playbook.yml

If you've installed Antora globally using `npm`, you may run into problems getting your self-registering credential manager to work.
Either you'll encounter the error `Cannot find module 'isomorphic-git'` or your custom credential manager won't be called.
To fix this problem, set the `NODE_PATH` environment variable to tell Node.js where to look for Antora's dependencies:

 $ NODE_PATH=$(npm -g list --parseable=true @antora/site-generator)/node_modules \
   antora -r ./custom-git-credential-manager.js antora-playbook.yml

The alternate solution is to install Antora locally (i.e., add the Antora packages to the dependencies in [.path]_package.json_ file and run `npm i`).

Since self-registering a plugin is more complex, we'll proceed with the example of registering the plugin in the playbook.

=== Get credentials from git

Git offers a command named `git credential` that serves as a simple interface for storing and retrieving credentials from system-specific helpers in the same manner as git itself.
It can also prompt the user for a username and password.
We can use this command in a custom credential manager to allow Antora to delegate to git to look up credentials (and thus integrate with the user's own git settings).

Let's start by creating a helper function that interfaces with the system git via `git credentials fill` to retrieve the credentials for a URL:

.system-git-credential-manager.js
[,js]
----
'use strict'

include::example$system-git-credential-manager.js[tag=call-git-credential-fill]
----

Next, let's create a credential manager that uses this function to fill the credentials for a URL:

[,js]
----
// ...

include::example$system-git-credential-manager.js[tag=exports]
----

Finally, we need to register the credential manager with the playbook:

[,yaml]
----
git:
  plugins:
    credential_manager: ./system-git-credential-manager.js
----

Antora will now delegate to the system git to fill the credentials for a URL:

 $ antora antora-playbook.yml

It's left up to an exercise for the reader to store or erase the credentials based on whether they were approved or rejected by the server (hint: use the `approved` and `rejected` methods to invoke `git credential` again).

[#ssh-auth]
== SSH authentication

Since 2.0, Antora no longer supports public/private key authentication over SSH using an SSH agent.
Instead, Antora transparently converts git SSH URLs in the playbook to HTTPS URLs and uses the credential manager for authentication.
That means you can use SSH URLs and HTTPS URLs interchangeably in your playbook file, but ultimately the git client will communicate over HTTPS.
If, for some reason, this automatic translation doesn't work, you'll need to update your playbook file to use the correct HTTPS URL.

// /docs/modules/playbook/pages/content-branches.adoc
[[content-branches.adoc]]
= Branches

The `branches` key accepts a list of exact branch names and patterns for matching branch names.
When the `branches` key isn't specified globally or on a content source, Antora will apply the <<default,default branches filter>>.

[#branches-key]
== branches key

The `branches` key is optional.
It can be specified directly on the `content` key (which changes the default value for all content sources) or on a content source (which overrides the default value).
The `branches` key accepts a list of branch name patterns to use from the specified `url`.
Each value can be an exact branch name (e.g., `v2.3`, `main`, etc.) or a pattern (e.g., `+v2.*+`, `+v@({1..9})*({0..9}).+({0..9}).x+`, etc.).
The list of branches can also be a combination of these value types.

.antora-playbook.yml
[,yaml]
----
content:
  sources:
  - url: https://git-service.com/org/repo-z.git
    branches: [rawhide, 90.0, 93.0, dev] # <.>
  - url: https://git-service.com/org/repo-y.git
    branches: main # <.>
  - url: https://git-service.com/org/repo-x.git
    branches: [edge, v*, '!v1.*'] # <.>
----
<.> Enclose multiple values in a set of square brackets (`+[]+`).
Separate each value with a comma (`,`).
If a value begins with a symbol (e.g., `+*+`), enclose it in single quotation marks (`'`) per YAML rules.
<.> A single value doesn't need to be enclosed in square brackets, but, if it begins with a number (e.g., `2.0`), enclose it in single quotation marks (`'`).
If the value begins with a symbol (e.g., `+*+`), enclose it in single quotation marks (`'`) per YAML rules.
<.> Exact branch names and branch name patterns can be assigned to a `branches` key.

These value patterns are case insensitive.
That means the characters are matched regardless of their case.
The values can be specified in a comma-separated list or as single items on individual lines.
As a general rule of thumb when using YAML, it's always best to enclose values in single quotation marks.

.branches values listed on individual lines
[#ex-value-list,yaml]
----
content:
  sources:
  - url: https://git-service.com/org/repo-x.git
    branches:
    - edge # <.>
    - '2.0' # <.>
    - v*
    - '!v1.*' # <.>
----
<.> Enter each value on its own line with a leading hyphen and blank space.
<.> Value that start with number should be enclosed in single quotation marks (`'`).
<.> Negated values, i.e., values that start with the bang symbol (`!`), should be enclosed single quotation marks (`'`).

[#default]
== Default branches filter

When the `branches` key isn't set on the `content` key or a content source, Antora will inherit the [.term]*default branches filter*, `+[HEAD, v{0..9}*]+`.
That means Antora will use files from the current (for local) or default (for remote) branch (e.g., `main`) as well as any branch that begins with the letter `v` followed immediately by a number (e.g., `v2.0.x`).
You can override this inherited value per content source by setting the `branches` key.

.antora-playbook.yml
[,yaml]
----
content:
  sources:
  - url: https://git-service.com/org/repo-z.git
    branches: [rawhide, 90.0, 93.0, dev] # <.>
  - url: https://git-service.com/org/repo-y.git # <.>
  - url: https://git-service.com/org/repo-x.git
    branches: [edge, v*, '!v1.*'] # <.>
----
<.> This content source will use the exact branch names specified.
<.> This content source will use the default branches filter.
<.> This content source will use the `edge` branch name as well as the branch names that begin with `v` that are matched by the refname pattern.

=== Modify the default branches filter

If you want to modify the default branches filter, assign a value to the `branches` key directly on the `content` key.

.Change the default branches filter
[,yaml]
----
content:
  branches: v* # <.>
  sources:
  - url: https://git-service.com/org/repo-z.git # <.>
  - url: https://git-service.com/org/repo-x.git
    branches: [edge, v*, '!v1.*'] # <.>
  - url: https://git-service.com/org/repo-y.git # <.>
----
<.> Specify `branches` under the `content` key to change the default branches filter.
<.> This content source will use the custom default branches filter, i.e., `branches: v*`.
<.> This content source will use the specified branches filter instead of the default one.
<.> This content source will also use the custom default branches filter.

The new default branches filter will be applied to all of the `url` entries that don't have a `branches` key explicitly defined on them.

[#exact-name]
== Specify branches by name

Branches can be specified by their exact name.

[,yaml]
----
content:
  sources:
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: [main, sneaky-chinchilla, 1.0, 1.5]
----

[#glob-pattern]
== Specify branches by pattern

Antora provides a facility to include and exclude branch names in bulk using pattern matching.
For example, branches can be specified using the wildcard operator (`+*+`).

.Select branches using a wildcard
[,yaml]
----
content:
  sources:
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: [v2.*, v3.*, v4.*]
----

For an in depth look at using wildcards (`+*+`), see xref:content-refname-matching.adoc#wildcards[Wildcards].
Antora also supports matching branch names using exclusions, braces, alternation, ranges, and repetition patterns.
See xref:content-refname-matching.adoc[].

== Exclude branches by pattern

You can unselect branches that were matched by a previous pattern by prefixing the value with `!`.
Here's how you'd exclude all branches that begin with `v` and end with `-beta`:

.Excluding branches using a wildcard
[,yaml]
----
content:
  sources:
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: [v*, '!v*-beta']
----

If the negated pattern appears first in the list, the meaning slightly changes.
A negated pattern in this position implies that there's a `*` entry before it (e.g., `+'*', '!main'+`).

.Include all branches that aren't excluded by name
[,yaml]
----
content:
  sources:
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: ['!main']
----

We recommend against using this inverted selection since it can pull in branches you probably don't want.
It's best to be specific about the branches you want to match, then use exclusions to reduce that list.

[#current-local-branch]
== Use the current, local branch

When working with a local repository, you may find yourself switching between branches often.
To save you from having to remember to update the playbook file to point to the current branch, you can use the reserved value, `HEAD`.

[,yaml]
----
content:
  sources:
  - url: ./workspace/project-a
    branches: HEAD
----

The value `HEAD` is equivalent to using the name of the current branch.

// /docs/modules/playbook/pages/content-worktrees.adoc
[[content-worktrees.adoc]]
= Worktrees

To complement branches, Antora can use the worktree that is linked to each branch it discovers in a local repository.
This behavior is controlled using the `worktrees` key.
The `worktrees` key accepts a keyword or a list of exact branch names or glob patterns.

Worktrees are only relevant for branches, not tags.

== worktrees key

The `worktrees` key is optional.
If not specified, Antora will automatically use the main (i.e., primary) worktree of a local repository if the current branch of that repository is among the branches matched by the `branches` key.
If such a match is made, Antora will take the files from the worktree instead of the files from the git tree for that branch.

By default, Antora only uses the main worktree (not to be confused with the main branch), not linked worktrees.
To customize this behavior, you can set the `worktrees` key.

NOTE: The main worktree is not necessarily linked to the main branch, but rather to the current branch of the local repository.

The `worktrees` key is specified on the entry for a content source.
The key accepts a keyword or a list of branch name patterns.
Each branch name pattern can either be an exact branch name or a positive or negative glob pattern.

To enable the use of all worktrees, simply set the `worktrees` key to the keyword value `true`.

.antora-playbook.yml
[,yaml]
----
content:
  sources:
  - url: /path/to/repo-a/main
    branches: [v1.0, v2.0, main]
    worktrees: true
----

In order for Antora to discover linked worktrees, the `url` key must point to the location of the main worktree (where the [.path]_.git_ folder is located).
If the `url` points directly to a linked worktree, Antora will not recognize it as a valid git repository.

=== Linked worktree as content source

It's possible to get Antora to support using a linked worktree as a content source with the help of an extension.
The following Antora extension will detect when the `url` key of a content source points to a linked worktree, then reconfigure the content source to point to the main worktree instead.

[,js]
----
include::example$linked-worktree-as-content-source.js[]
----

Save this file next to your playbook file and load it using `--extension ./linked-worktree-as-content-source.js` when invoking Antora.
Once https://gitlab.com/antora/antora/-/issues/535[#535] is resolved, this patch will no longer be necessary.

== Specify worktrees by keyword

The `worktrees` key accepts the following keyword values:

true:: Use all worktrees (the main worktree and all linked worktrees).
false (or ~):: Do not use any worktrees (not the main worktree and not any linked worktrees).
.:: Use only the main worktree. (default)
*:: Use only the linked worktrees.

If you want Antora to bypass all worktrees, set the value of the `worktrees` key to the keyword `false`.

.antora-playbook.yml
[,yaml]
----
content:
  sources:
  - url: /path/to/repo-a/main
    branches: [v1.0, v2.0, main]
    worktrees: false
----

== Specify worktrees by glob pattern

If you want more fine-grained control over which worktrees Antora uses, you can specify a list of glob patterns.
You refer to worktrees by the branch name to which they are linked.
Thus, the glob pattern works the same as described on the xref:content-branches.adoc[] page.
If you want to refer to the current branch, you do so using the `.` keyword.
If present, that entry must appear first in the list.

Let's configure Antora to use the main worktree as well as the linked worktree for the v2.0 branch.
The files for the v1.0 branch will be read from the git tree, even if there is a linked worktree associated with that branch.

.antora-playbook.yml
[,yaml]
----
content:
  sources:
  - url: /path/to/repo-a/main
    branches: [v1.0, v2.0, main]
    worktrees: [., v2.0]
----

== Configure multiple worktrees

To learn how to configure multiple worktrees, refer to xref:author-mode.adoc#multiple-worktrees[this guide] on the Author Mode page.

// /docs/modules/playbook/pages/content-tags.adoc
[[content-tags.adoc]]
= Tags

The `tags` key accepts a list of exact tag names and patterns for matching tag names.

WARNING: We generally recommend against pulling documentation from tags.
If you do use tags, we recommend using dedicated documentation tags rather than reusing tags for software releases.
You can read more about our philosophy regarding documentation versioning on the xref:ROOT:content-source-versioning-methods.adoc[] page.

[#tags-key]
== tags key

The `tags` key is optional and can be specified directly on the `content` key or on a `url` key.
It accepts a list of tag name patterns.
Each value can be an exact tag name (e.g., `v2.3.1`, `v3.9.4`, etc.) or a pattern (e.g., `+v2.*+`, `+v@({1..9})*({0..9}).+({0..9}).x+`, etc.).
The list of tags can also be a combination of these value types.

.antora-playbook.yml
[,yaml]
----
content:
  sources:
  - url: https://git-service.com/org/repo-z.git
    tags: [90.0, 93.0] # <.>
  - url: https://git-service.com/org/repo-x.git
    tags: [95.0, releases/*, '!v1.*'] # <.>
    branches: ~ # <.>
----
<.> Enclose multiple values in a set of square brackets (`+[]+`).
Separate each value with a comma (`,`).
<.> Exact tag names and glob patterns can be assigned to a `tags` key.
<.> Disable the default branches filter by setting `branches` and assigning it the tilde (`~`) value.

WARNING: Setting the `tags` key does not automatically disable the xref:content-branches.adoc#default[default branches filter]!

These value patterns are case insensitive.
That means the characters are matched regardless of their case.
The values can be specified in a comma-separated list or as xref:content-branches.adoc#ex-value-list[single items on individual lines].

[#add-default-tags-filter]
== Add a default tags filter

The `tags` key isn't used by default (unlike the `branches` key and its default filter).
To apply the same tag filter to all the `url` entries that don't declare the a `tags` key explicitly, specify a `tags` key directly on the `content` key.

.Assign a default tags filter
[,yaml]
----
content:
  tags: v* # <.>
  branches: ~ # <.>
  sources:
  - url: https://git-service.com/org/repo-z.git # <.>
  - url: https://git-service.com/org/repo-x.git
    tags: [v*, '!v1.*'] # <.>
  - url: https://git-service.com/org/repo-y.git # <.>
----
<.> Specify `tags` under the `content` key to create a default tags filter.
<.> Disable the default branches filter on all `url` keys.
<.> This `url` will use the default tags filter.
<.> The value assigned to this `tags` key will be applied to the `url` it's specified on, overriding the default tags filter.
<.> This `url` will use the default tags filter.

With the creation of the default tags filter, Antora will now discover and use tags that begin with the letter `v` for all content sources that don't explicitly declare a `tags` key.

[#mix-branches-and-tags]
== Use tags and branches from the same repository

In this example, we'll load the `main` branch of a content repository as well as tags starting with the letter `v`.

[,yaml]
----
content:
  sources:
  - url: https://git-service.com/org/repo-x.git
    branches: [main, sneaky-chinchilla]
    tags: v*
----

For an in depth look at using wildcards (`+*+`), see xref:content-refname-matching.adoc#wildcards[Wildcards].
Antora also supports matching tag names using exclusions, braces, alternation, ranges, and repetition patterns.
See xref:content-refname-matching.adoc[].

////
.Assign a default tags filter
[,yaml]
----
content:
  tags: v*
  sources:
  - url: https://gitlab.com/antora/demo/demo-component-a.git
  - url: https://gitlab.com/antora/demo/demo-component-b.git
----
////

// /docs/modules/playbook/pages/content-source-start-path.adoc
[[content-source-start-path.adoc]]
= Single Start Path

The `start_path` key identifies where the [.path]_antora.yml_ file is located in a repository or local worktree relative to the root of the repository.
This key doesn't need to be set on a `url` if the content source root and root of the repository are the same.

[#default]
== Default start path

By default, Antora assumes that the root of a content source repository  or local worktree (i.e., the value of a `url` key) is also the xref:ROOT:content-source-repositories.adoc#content-source-root[content source root].
When [.path]_antora.yml_ is stored at the root of a content source repository, *you don't need to set the `start_path` key for the `url` you're configuring*.

[#start-path-key]
== start_path key

If [.path]_antora.yml_ isn't stored at the root of a content source repository assigned to a `url` key, then use the `start_path` key to tell Antora where to find the xref:ROOT:content-source-repositories.adoc#content-source-root[content source root].
A `start_path` key can only be configured per `url` key (it can't be set directly on `content`).

.antora-playbook.yml
[,yaml]
----
content:
  sources:
  - url: https://git-service.com/org/repo.git
    branches: [main, v1.0]
    start_path: path/to/content-source-root
----

The `start_path` key accepts a repository root relative path.
*Don't add leading or trailing slashes to the path.*

[#start-path-for-url]
== Specify start_path for a url key

The value of the `start_path` key is the repository relative path to a content source root.
Let's define a `start_path` value for the repository shown in <<ex-root>>.

.Content source root isn't located at the repository root
[listing#ex-root]
----
📒 repository <.>
  📂 packages
    📂 docs <.>
      📄 antora.yml <.>
      📂 modules
        📂 a-named-module
        📂 ROOT
----
<.> Root of a content source repository
<.> Content source root
<.> _antora.yml_ file stored at the content source root

In order for Antora to locate the content source root in <<ex-root>>, the value of the `start_path` key needs to point to the directory where [.path]_antora.yml_ is located.

.Assign start_path value
[#ex-root-start,yaml]
----
content:
  sources:
  - url: https://gitlab.com/org/repo.git
    branches: [v1.0, v2.6]
    start_path: packages/docs # <.>
----
<.> Repository relative path to the content source root

Using the `start_path` specified in <<ex-root-start>>, Antora would use the path _\https://gitlab.com/org/repo/-/tree/vx.x/packages/docs_ per branch to locate the content source root.

//== Specify a start path for all sources

// /docs/modules/playbook/pages/content-source-start-paths.adoc
[[content-source-start-paths.adoc]]
= Multiple Start Paths
//The `start_paths` feature lets you register more than one Antora component version within a single repository.
//If one repository branch or tag contains multiple [.path]_antora.yml_ component descriptors, you can specify the multiple start paths for a single repository URL using the `start_paths` key.

On this page, you'll learn:

* [x] How to use the `start_paths` key to specify multiple start paths for a branch of a single content source `url`.
* [x] What patterns the `start_paths` key supports for matching directories.
* [x] How to exclude directories matched by previous patterns.

[#start-paths-key]
== start_paths key

The `start_paths` key allows you to specify multiple content source roots for a single reference of a repository.
In other words, you can put multiple component versions, components, or distributed components--each having its own [.path]_antora.yml_ file--in a single branch of a repository, then refer to all those content source roots using the same content source entry.
When you organize content this way, this feature has the potential of drastically reducing the verbosity of the content sources in your playbook.

=== Relationship to the start_path key

The xref:content-source-start-path.adoc[start_path key] only lets you specify _a single path_ in your playbook for a given content source.
In contrast, the `start_paths` key lets you specify _multiple paths_.
The multiple paths can be even further consolidated using xref:content-refname-matching.adoc[wildcards, exclusions, braces, alternation, ranges, and repetition patterns].
Antora will resolve the patterns to one or more fixed paths.

The `start_paths` key is mutually exclusive with the `start_path` key.
If both the `start_path` and `start_paths` keys are present on a content source, only the `start_paths` key is used.

=== Relationship to git references

Like with the singular start path, the start paths are searched per git reference (i.e., branches, tags, and worktrees).
That means a xref:ROOT:component-version-descriptor.adoc[component version descriptor] must be found at each start path for each reference.

Typically, when using multiple start paths, you'll only be using a single reference anyway (e.g., `main`).
If you do use multiple references in this scenario, the assumption is that each reference shares the same layout.

== Use cases

Multiple start paths are designed primarily to accommodate two use cases:

* Documentation that's versioned using folders instead of branches.
* Documentation for multiple products in a single repository branch (e.g., a monorepo).

=== Component versions as folders

You can use `start_paths` to store all versions of a component in a single repository branch using folders instead of using multiple branches.
Although you may miss out on some advantages of the version control system, this arrangement can make it easier on writers who are frequently updating multiple versions of the documentation at once.

In this scenario, you'd provide a single value for the `branches` key and use the `start_paths` key to tell Antora which directories in the branch to use as content roots.
If the version folders are named consistently, it becomes easy to match them using a pattern.

Here's an example of a repository layout that uses folders to store documentation versions:

[listing]
----
📒 repository
  📂 docs
    📂 v1.0
      📄 antora.yml
    📂 v1.1
      📄 antora.yml
    📂 v2.0
      📄 antora.yml
----

=== Components as folders

You can take it a step further and store all components in a single repository branch using folders instead of using multiple repositories.
If those components have versions, you'd likely use subfolders to store the versions as well.
This arrangement works best if all the documentation is maintained by the same team or individual and the distributed nature of git just gets in the way.
It might also be used for a monorepo, in which the source code for multiple products is stored in the same repository.
Antora can discover the documentation wherever it starts within that structure.

In this scenario, you'd again provide a single value for the `branches` key and use the `start_paths` key to tell Antora which directories in the branch to use as content roots.
Only this time, the content source roots will match different components (and possibly versions), not just versions of a single component.

Here's an example of a repository layout that uses folders to store components:

[listing]
----
📒 repository
  📂 product-a
    📂 docs
      📄 antora.yml
  📂 product-b
    📂 docs
      📄 antora.yml
  📂 product-c
    📂 docs
      📄 antora.yml
----

Naturally, the repository may have many other files and folders that do not pertain to the documentation.

[#exact-paths]
== Exact paths

If you only have a couple of paths to register, you might find that using exact path patterns is suitable.

.antora-playbook.yml
[,yaml]
----
content:
  sources:
  - url: https://github.com/org/repo1
    start_paths: docs # <.>
  - url: https://github.com/org/repo2
    start_paths: docs, more-docs # <.>
  - url: https://github.com/org/repo3
    start_paths: [docs, more-docs] # <.>
  - url: https://github.com/org/repo4
    start_paths:
    - docs # <.>
    - more-docs
----
<.> A single path (which is equivalent to using `start_path`).
<.> A comma-separated list of exact path values.
<.> An array on a single line, delimited by square brackets (`+[]+`).
<.> An array on multiple lines, each delimited by a leading `-`.

[#path-globbing]
== Path globbing

Along with the methods described in <<exact-paths>>, you can use many (<<globbing-restrictions,but not all>>) https://github.com/micromatch/picomatch#globbing-features[basic and advanced path globbing features^] to implement pattern matching.
A diverse combination of wildcards, braces, and negated patterns are supported.
Antora uses these glob patterns to resolve exact paths from which to read the content.

[#globbing-restrictions]
=== Globbing restrictions

The following restrictions apply to how Antora implements path globbing against the full range of supported basic and advanced globbing rules:

* Wildcards in expressions only match directories, not files.
For example, an expression like `product-a/docs/*/index.adoc` is not supported.
* Brace expressions must have at least two entries, even if a wildcard is present.
For example, `+docs/product-{a*,b}+` is recognized as a brace expression, but not `+docs/product-{a*}+`.
* Single brace expressions that match multiple characters do not work when following a segment that contains a wildcard.
For example, `+*/v{0..99}+` matches the start path [.path]_product-a/v2_ but not [.path]_product-a/v99_.
Instead, use a repetition operation, such as `+*/v+({0..9})+`, or a nested brace expression for each length permutation, such as `+*/v{{1..9},{1..9}{0..9}}+`.
* Double globstar patterns such as `**/docs` are not supported.
A glob matches a single level in the hierarchy.

=== Wildcards

Wildcard matching reduces the number of values you need to assign to a `start_paths` key.
For instance, if you have multiple components stored in a branch, you could list them all in a comma-separated list like the one shown in <<ex-no-wildcard>>.

.antora-playbook.yml
[#ex-no-wildcard,yaml]
----
content:
  sources:
  - url: https://github.com/org/repo1
    branches: main
    start_paths: docs/product-a, docs/product-b, docs/product-c
----

Or, as shown in <<ex-wildcard>>, you could use a wildcard segment and reduce the number of values you need to declare.

.antora-playbook.yml
[#ex-wildcard,yaml]
----
content:
  sources:
  - url: https://github.com/org/repo1
    branches: main
    start_paths: docs/product-*
----

Wildcard matching offers the possibility of registering new content source roots as you add them, providing you keep the pattern consistent.

=== Braces

Brace expressions can specify an explicit list of items separated by commas to expand (`docs/product-{a,b,c,f}`) or a range of items to expand (`docs/product-{a..f}`).
A brace expression *may not* consist of only a single item, even if that item contains a wildcard (e.g., `+docs/product-{a}+` and `docs/product-{a*}` are not brace expressions).

Brace expressions may be nested (e.g., `+docs-*/v{{1..9},{1..9}{0..9}+` matches the subfolders v1 through v99 of root folders that match the name docs-*).
In this case, each permutation for each nested brace expression is tested.

When you use braces in a `start_paths` value, all entries within the braces must exist when expanded (unless the segment is preceded by a wildcard segment).

If you specify `docs/product-{a,b}` as a `start_paths` value, the following paths must be present within the repository:

* [.path]_docs/product-a_
* [.path]_docs/product-b_

You can use a prefix in your file path before a brace expression to simplify what Antora checks for in the expression.

.antora-playbook.yml
[,yaml]
----
content:
  sources:
  - url: https://github.com/org/repo1
    branches: main
    start_paths: docs/v{1..9}
----

You can also use wildcards in brace expressions to help expand values.

.antora-playbook.yml
[#ex-wild-braces,yaml]
----
content:
  sources:
  - url: https://github.com/org/repo1
    branches: main
    start_paths: docs/product-v{1*,2*}
----

The `start_paths` pattern in <<ex-wild-braces>> would match the following paths:

* docs/product-v1.1
* docs/product-v1.2
* docs/product-v1.2.1
* docs/product-v2.0
* docs/product-v2.1.1

=== Negated globs

Use negated patterns to exclude patterns previously matched.
This approach is useful if you want to match all directories except for those that match a certain pattern.

.antora-playbook.yml
[,yaml]
----
content:
  sources:
  - url: https://github.com/org/repo1
    start_paths:
    - docs/user/*
    - docs/dev/*
    - !**/*-beta.* # <.>
----
<.> Negated path globbing patterns must follow any path inclusions, and must be declared after locations that have already been matched.

== Ignored directories

Hidden directories (i.e., directories that begin with `.`) are ignored by default.
To include them in a `start_paths` path globbing pattern, use a `+.*+` in the pattern.
For example, use `docs/.*-{a,b}` to include all hidden directories with the suffix of `-a` or `-b`.

== Optional matches

A non-wildcard segment that follows a wildcard segment is considered optional.
This exception is intended to simplify directory matching logic.

For example, `docs/product-*/client` would match [.path]_product-a/client_ but disregard [.path]_product-b_ if it does not contain a [.path]_client_ folder.

Another valid example would be `docs/product/*/client` where the `+*+` represents different version directories (v1.0, v1.1, etc) of client documentation.
If the [.path]_client_ folder does not exist in one of the version directories, Antora ignores it from a validation perspective.

If the final segment of a file path pattern contains an unmatched brace pattern, Antora treats it as optional from a validation perspective.

For example, `docs/product-*/{client,b2b}` will not fail validation if [.path]_docs/product-a/b2b_ is not present.

// /docs/modules/playbook/pages/content-source-version.adoc
[[content-source-version.adoc]]
= Fallback Version

The `version` key provides a way to control the component version that corresponds to a content source directly from the playbook.
The `version` key on the content source is a fallback value.
If a component version descriptor (an [.path]_antora.yml_ file) defines the `version` key for a component version, the value of that key takes precedence.

== version key

The `version` key is optional.
The `version` key accepts a named identifier, such as `jesse`, a semantic identifier, such as `'1.5'`, the reserved value `~` (for unversioned), the reserved value `true`, or a map of refname projections, such as `+v/(?<version>*): $<version>+`.

A content source can match multiple git references.
Thus, a fixed value should only be used if the content source is configured to match a single reference, or if all the references it matches contribute files to the same component version.
Otherwise, the value of this key should be `true` or a map of refname projections.

If you want the playbook to be able to control the value of the `version` key, don't set the `version` key in xref:ROOT:component-version-descriptor.adoc[the component version descriptor (_antora.yml_ file)].

=== Fixed value as version

The following example shows how to assign a fixed fallback value to the `version` key.
A fixed value can be a named identifier, a semantic identifier, or the value `~` for unversioned.

.Content source with a fixed value assigned to version
[#ex-name,yaml]
----
content:
  sources:
  - url: https://git-service.com/org/repo-a.git
    branches: v2.0.x # <.>
    version: '2.0' # <.>
----
<.> Only match a single reference when using a fixed value.
<.> Assign a fixed value, such as a named identifier, semantic identifier, or the value `~`.

When Antora looks for the component version descriptor in the specified branch (i.e., `v2.0`), it will not expect to find the `version` key defined in that file.
Instead, it will use the fixed value of the `version` key specified on the content source (i.e., `2.0`).

=== refname as version

Since content in Antora is retrieved from a git repository, you may want to use the git refname (branch or tag name) for the content source (where the xref:ROOT:component-version-descriptor.adoc[component version descriptor is stored]) as the version.
To do so, assign the reserved value `true` to the `version` key.
Antora will substitute the value `true` with the refname automatically.

The following example shows how to use the refname as the fallback value of the `version` key.

.Content source that uses the refname as the version
[#ex-refname,yaml]
----
content:
  sources:
  - url: https://git-service.com/org/repo-b.git
    branches: v* # <.>
    version: true # <.>
----
<.> Match any number of references.
<.> The value `true` tells Antora to use the matched refname as the value.

When Antora looks for the component version descriptor in the specified branch (i.e., `v2.0`), it will not expect to find the `version` key defined in that file.
Instead, it will use the refname instead.
The value Antora uses is always the short refname (e.g., v1.0), not the full refname (e.g., refs/heads/v1.0).
If the short refname contains any forward slashes, Antora will replace each one with a hyphen.

=== refname projection as version

The refname may not be granular enough to use as the fallback version.
Furthermore, the same git tree could be passed through git references that have different naming schemes, such as feature branches.
In these cases, you want the version to be extracted or derived from the refname rather than using the value as is.
That's when you'd define the fallback version using a refname projection.

A refname projection is expressed as a map of patterns (the keys) and replacements (the values).
The refname projection allows you to match the refname using a pattern, then build the version based on that match.
The pattern tells Antora which entry to use and what parts to extract from it.
The replacement tells Antora how to derive a version from the matched refname.

The following example shows how to use a projection to compute the value of the `version` key from the refname.

.Content source that derives version from refname
[#ex-projection,yaml]
----
content:
  sources:
  - url: https://git-service.com/org/repo-c.git
    branches: [v*, feature/*] # <.>
    version:
      v(?<version>+({0..9}).+({0..9})).x: $<version> # <.>
      feature/(*)/*: $1 # <.>
----
<.> Match any number of references with different naming patterns.
<.> Matches the semantic identifier in a refname like `v2.0.x` and extracts it.
<.> Extracts the value between the first and second slash for a refname that begins with `feature/`

The key in the projection is a glob pattern (a combination of extglobs, ranges, and some regex constructs).
The pattern has the same matching capabilities as the pattern used to match branches or tags for a content source in the playbook.

The characters between parentheses (i.e., round brackets) in the pattern defines a match group.
If the opening brace begins with `?<name>`, that group is assigned to the name specified between the angle brackets.
Otherwise, the group is assigned to a 1-based index according to the group's position in the pattern.

The match groups can be referenced in the replacement.
A match group reference is preceded by a dollar sign (`$`).
A named group can be referenced using `$<name>`, where the name is once again specified between the angle brackets.
An indexed group can be referenced by its number, such as `$1`.
You can reference the entire refname using `$&`.

If the match group contains any forward slashes, Antora will replace each one with a hyphen.

Antora will use the value of the first pattern it matches.
If none of the patterns match the refname, Antora will fallback to using the refname as the version.

TIP: Antora supports matching refnames using wildcards, exclusions, braces, alternation, ranges, and repetition patterns.
See xref:content-refname-matching.adoc[].

// /docs/modules/playbook/pages/content-edit-url.adoc
[[content-edit-url.adoc]]
= Edit URL
:page-aliases: configure-edit-url.adoc
// placeholders that are fulfilled by the file's origin information
//https://gitlab.com/antora/antora/blob/main/docs/modules/cli/pages/index.adoc

On this page, you'll learn:

* [x] How Antora builds the edit URL for each page.
* [x] How to customize the edit URL.
* [x] How to disable the edit URL.

[#default]
== Antora's default edit URL assignment

Antora automatically derives an edit URL for all files sourced from the _hosted_ GitLab (gitlab.com), GitHub (github.com), Bitbucket (bitbucket.org), and Pagure (pagure.io) services (SAAS).
It does so by first converting the content source URL to a web URL, then using the reference and path information of the current file to construct a URL to the edit mode of that file in the hosted repository.

In the default UI, Antora uses this value (if set) to create an *Edit this Page* link in the upper right corner of each page.
That link directs the visitor to the edit interface of that file provided by the hosted git service.
For example, if you click the *Edit this Page* link on this page, your browser will go to GitLab's file editing interface (on gitlab.com) and load the AsciiDoc source that was used to create this page.

One exception is if the repository is private.
In this case, the default UI does not show the *Edit this Page* link.
However, you can force the default UI to show the link by setting the `FORCE_SHOW_EDIT_PAGE_LINK` environment variable (e.g., `FORCE_SHOW_EDIT_PAGE_LINK=true`) when building the site.
Alternately, you can customize the UI template to change the logic.

Another exception is if the page originates from the local filesystem (i.e., a worktree).
In this case, the default UI uses the local file:// URI for the *Edit this Page* link.
You can force the default UI to always use the edit URL by setting the `CI` environment variable (e.g., `CI=true`) when building the site.
(This environment variable is already set in most CI environments).
The assumption is that if the `CI` environment variable is set, the site is being published to a remote server where a file:// URI would not be accessible.
Rather than setting this environment variable, you can customize the UI template to change the logic.

That covers how the edit URL is used.
Let's now look at how you can customize the value.

[#edit-url-key]
== Customize the edit URL

The `edit_url` key is useful when you're using an unrecognized git solution, or you want <<source-view,Edit this Page to link to an alternate view>>, such as the raw or rendered display, of a page's source file.

The `edit_url` key is set in the playbook and can be applied to all of the content sources or customized per individual source.
The key accepts a URL pattern that contains the URL segments of the git solution or source file view plus several placeholder segments, `+{web_url}+`, `+{refname}+`, `+{reftype}+`, `+{refhash}+`, and `+{path}+`.
Antora automatically fulfills these placeholders with the file's origin information at processing time.

.edit_url key and value
[#ex-key,yaml]
----
edit_url: '{web_url}/blob/{refname}/{path}' # <.>
----
<.> Enclose the value of `edit_url` in single quotation marks (`'`) when it starts with a curly bracket (`{`).

<<ex-key>> shows a hypothetical edit URL pattern containing several placeholders.
The word _blob_ is an example of a URL segment that isn't represented by a placeholder.
In the following section, we'll explain the role of the these placeholders.

=== How does Antora assemble an edit URL for a page?

When `edit_url` is set, either by default or explicitly, Antora computes the value of the `+{web_url}+`, `+{refname}+`, `+{reftype}+`, `+{refhash}+`, and `+{path}+` placeholders for each page according to its content source and file origin information.
Then, using the pattern assigned to the `edit_url` key, it assembles each page's unique edit URL.

web_url:: The `+{web_url}+` placeholder is the corresponding web URL for the content source repository that Antora automatically computes from its git URL.
For example, [.path]_\https://gitlab.com/cave/sneaky.git_ is converted to [.path]_\https://gitlab.com/cave/sneaky_.
This placeholder can be omitted if you use a web URL that differs from the one Antora computes.

refname:: The `+{refname}+` is the name of the git reference (e.g., v2.1.x, main, rawhide).

reftype:: The `+{reftype}+` is the type of the git reference (i.e., tag or branch).

refhash:: The `+{refhash}+` is the commit hash of the git reference (e.g., aab0e5684afe0d4e05955fbef72b6e5538bb1ec5).

path:: The `+{path}+` is the path of the source file relative to the root of the repository.
It includes the `start_path` if one is specified.

To see an example of the values Antora would compute for the placeholders, we'll use the content source, branches, and edit URL pattern inputs shown in <<ex-value>>.

.edit_url placeholders
[#ex-value,yaml]
----
content:
  sources:
  - url: https://app.company.com/the-group/zap.git
    branches: v1.2.5, next
    edit_url: '{web_url}/_src/{refname}/u890/{path}'
----

Let's determine what the edit URL would look like for the page generated from a file named [.path]_index.adoc_.
This [.path]_index.adoc_ file is stored in branch v1.2.5 of the zap repository in the pages directory of the ROOT module.
Using the pattern assigned to `edit_url` in <<ex-value>>, Antora would compute the edit URL shown in <<ex-value-result>> for [.path]_index.adoc_.

.Edit URL for index.adoc using the inputs from <<ex-value>>
[listing#ex-value-result]
----
https://app.company.com/the-group/zap/_src/v1.2.5/u890/modules/ROOT/pages/index.adoc
----

Antora replaces `+{web_url}+` with the content source's web URL.
In this case, the _.git_ is dropped from the end of the value of `url`.
`+{refname}+` is replaced with the _v1.2.5_ git branch reference.
Finally, `+{path}+` is replaced by the path to the source file, relative to the root of the repository.
Since this source doesn't have a specified start path, the resulting path is [.path]_modules/ROOT/pages/index.adoc_.

When a content source has an assigned `start_path`, Antora prepends it to `+{path}+`.

.Content source with start_path and edit_url set
[#ex-start,yaml]
----
content:
  sources:
  - url: https://app.company.com/the-group/zap.git
    branches: v1.2.5, next
    start_path: learn/docs
    edit_url: '{web_url}/_src/{refname}/u890/{path}'
----

Using the inputs from <<ex-start>>, the edit URL for [.path]_index.adoc_ would be:

.Edit URL for index.adoc using the inputs from <<ex-start>>
[listing#ex-start-result]
----
https://app.company.com/the-group/zap/_src/v1.2.5/u890/learn/docs/modules/ROOT/pages/index.adoc
----

== Apply the same edit_url to multiple content sources

When all or most of your content sources use the same `edit_url`, you can set it directly on the `content` key.

.Set edit_url on the content key
[#ex-content,yaml]
----
content:
  edit_url: '{web_url}/_src/{refname}/u890/{path}' # <.>
  sources:
  - url: https://app.company.com/the-group/zap.git
    branches: v1.2.5, next
  - url: https://app.company.com/city/team-l/zonk.git
    branches: v2.*
----
<.> When `edit_url` is set directly on the `content` key, as it is here, its value is applied to all of the content sources unless the key is reset or disabled on an individual content source.

As seen in <<ex-source>>, the `edit_url` key can be set on an individual content source even when it's set on the `content` key.

.Set edit_url on the content key and an individual source
[#ex-source,yaml]
----
content:
  edit_url: '{web_url}/_src/{refname}/u890/{path}' # <.>
  sources:
  - url: https://app.company.com/the-group/zap.git # <.>
    branches: v1.2.5, next
  - url: https://git.secretbase.org/ack/boom
    branches: dev
    edit_url: '{web_url}/{refname}/ping/0/{path}' # <.>
  - url: https://app.company.com/city/team-l/zonk.git # <.>
    branches: v2.*
----
<.> This `edit_url` key is set directly on the `content` key.
Its value is applied to all of the content sources unless the key is reset or disabled on an individual content source.
<.> This content source will inherit the value of the `edit_url` key set directly on the `content` key.
<.> When `edit_url` is set on an individual content source, that value will be used instead of the value assigned to the `edit_url` key set on the `content` key.
<.> This content source will inherit the value of the `edit_url` key set directly on the `content` key.

[#source-view]
== Change the source file view linked to Edit this Page

By default, a page's edit URL links to the file editing interface of the git service where the repository is hosted.
This works as long as long as the content source is stored in one of the _hosted_ git services that Antora recognizes, which includes GitLab (gitlab.com), GitHub (github.com), Bitbucket (bitbucket.org), and Pagure (pagure.io).
If the repository is not stored in one of these hosted services (e.g., a self-hosted GitLab or Bitbucket instance), you can use the `edit_url` key to configure how this URL is constructed.
For instance, in <<ex-view>>, each page's computed edit URL will now be the URL for GitLab's rendered file view of the corresponding source file.

.Route the edit URL to an alternate source file view
[#ex-view,yaml]
----
content:
  edit_url: '{web_url}/blob/{refname}/{path}' # <.>
  sources:
  - url: https://gitlab.com/cave/sneaky.git
    branches: v2.0, v1.0
----
<.> The `edit_url` key is assigned the URL pattern for GitLab's rendered file view.

Using the inputs in <<ex-view>>, the *Edit this Page* link on each page sourced from the _\https://gitlab.com/cave/sneaky.git_ repository will link to the rendered view of the corresponding source file on GitLab.

NOTE: To change the link text of *Edit this Page* or replace it with an image, you'll need to update your UI.

[#disable-edit-url]
== Disable the edit URL

If the repository is private, the default UI will not show the *Edit this Page* link for the current page, even though the edit URL is defined.
However, if the repository is public, and you want to disable the link, or nullify the edit URL for any other reason, you can do so using the playbook.

The `edit_url` key can turn off the edit URL feature on all of your content sources or per individual content source.
To disable the edit URL, assign a tilde (`~`) or the word `false` to the `edit_url` key.

[,yaml]
----
content:
  branches: v*
  edit_url: ~ # <.>
  sources:
  - url: https://app.company.com/the-group/zap.git
  - url: https://gitlab.com/cave/sneaky.git
----
<.> Disable the edit URL feature for all content sources by setting `edit_url` on the `content` key and assigning it a value of `~`.
The tilde (`~`) disables the edit URL feature.
An edit URL won't be produced for any of the pages sourced from the content sources unless `edit_url` is reset per individual content source.

The `edit_url` can also be disabled on an individual content source.

[,yaml]
----
content:
  branches: v*
  sources:
  - url: https://app.company.com/the-group/zap.git
    edit_url: ~ # <.>
  - url: https://gitlab.com/cave/sneaky.git # <.>
----
<.> The `edit_url` key is set on this individual content source and assigned a value of `~`.
<.> Since `edit_url` isn't explicitly set on the `content` key or on this content source, it will use the default edit URL behavior built into Antora.

== Revert a content source to the default edit URL behavior

You can revert to the <<default,default edit URL behavior>> for an individual content source even when you've set or disabled the `edit_url` key at the `content` key level.
On the source, set `edit_url` and assign it the value `true`.

.Reset edit_url to the default behavior
[#ex-reset,yaml]
----
content:
  branches: v*
  edit_url: '{web_url}/_src/{refname}/u890/{path}' # <.>
  sources:
  - url: https://app.company.com/the-group/zap.git
  - url: https://gitlab.com/cave/sneaky.git
    edit_url: true # <.>
  - url: https://app.company.com/city/team-l/zonk.git
----
<.> When `edit_url` is set directly on the `content` key, its value is applied to all of the content sources unless the key is reset or disabled on an individual content source.
<.> Assign the value `true` to the `edit_url` key to revert a content source to the default edit URL behavior.

In <<ex-reset>>, the _zap_ and _zonk_ content sources will use the `edit_url` set on the `content` key while the _sneaky_ source will use the default edit URL behavior built into Antora.

// /docs/modules/playbook/pages/content-refname-matching.adoc
[[content-refname-matching.adoc]]
= Refname Matching in Content Sources
:source-language: yaml

At the heart of Antora is the gathering of content stored in references across various git repositories.
The playbook provides several keys to instruct Antora which reference names (i.e., refnames) to consider, including branches, tags, and worktrees, and which start paths within those references to scan.
One way to configure this filter is to list each refname individually.
However, since content often moves very quickly, that approach can be burdensome and static.
That's why Antora provides a facility to include and exclude refnames in bulk using pattern matching.
The pattern matching approach has the benefit of simplifying the configuration and automatically discovering new refnames as they become available.

This page describes the value types and syntax you can use for matching refnames in a content source.

== Value types

The keys covered on this page accept two kinds of values:

* a string (i.e., a character sequence)
* an array of strings

A string value will be split a commas, preferably followed by space, if present.
For example, the string `v1.0.x, v2.0.x` will become an array of two strings, `v1.0.x` and `v2.0.x`.

It's usually best to enclose the string values in single quotes to avoid conflicts between characters in the value and special syntax in YAML (or your chosen configuration language).

CAUTION: If you're matching refnames using patterns, we strongly encourage you to use the array syntax.
The single or comma-separated string syntax is intended to be used for exact matching only.
Otherwise, you might get unexpected behavior.

== Exact match

The simplest approach to matching refnames is to specify them as exact names.
For example, you can match a single branch named `main` as follows:

[,yaml]
----
branches: main
----

If you want to also add branch names for older release lines, you can separate them by commas:

[,yaml]
----
branches: v1.0.x, v2.0.x, main
----

You can also express the value as an array to make it explicit:

[,yaml]
----
branches: [v1.0.x, v2.0.x, main]
----

When we say "`exact match`", we're referring to a match against the shortname of the reference.
You aren't matching remotes/origin/v1.0.x or heads/v1.0.x, for instance, but rather v1.0.x.
The reason for this is that Antora looks for both remote and local references, preferring the local references, and only selects one per unique shortname.

While it appears that the exact match is a literal value, it is, in fact, a pattern.
And a pattern always matches from the beginning to the end of the refname.
However, most refnames don't contain any characters which have meaning in the pattern matching syntax (not even `.`).
So it acts like a literal value that looks for a refname that matches exactly.
But keep the fact that it's a pattern in the back of your mind if you find that it is not matching the refname you expect it to match.

[#wildcards]
== Wildcards (basic globbing)

Having to maintain a list of exact refnames in your playbook can be tedious and noisy.
That's why Antora allows you to match refnames in bulk using pattern matching.

The most basic pattern matching tool is the wildcard (`*`).
The use of this pattern is often referred to as globbing, since you use it to capture a glob of items.

You can glob all refnames that exist using a lone wildcard:

----
branches: '*'
----

But it's rare that you'll want to do that.
Let's say, instead, that we want to match all refnames that start with `v`.
We can do that by placing an asterisk after the letter.

----
branches: v*
----

The `*` means "`any number of characters`".
In this case, it matches any number of characters the follow a `v` at the start of the rename.

You can also use the wildcard between two parts of a string to match any number of characters between the two parts.
Let's use it to match version numbers more precisely.

----
branches: v*.*.x
----

This pattern will match `v1.0.x`, `v2.0.x`, and even `v20.10.x`.
However, it will only match numbers if the refnames themselves only have number.
That means it could also match `very.last.x`.
While we'll be able to address that problem later when we get into more advanced patterns, it does bring us to the problem of overmatching and the need for exclusions.

[#exclusions]
== Exclusions

So far we've talked about refnames we want to match, or inclusions.
When you start using patterns, you can run into the problem of matching too many items.
You can take away from previously matched items using one or more exclusion.
An exclusion entry always begins with `!`.

Let's say you want to match all version-like refnames, but you want to exclude the version before you started using Antora.

----
branches: [v*.*.x, '!v1.0.x']
----

Notice that we've switched the value to the array syntax, as recommended.
It's also necessary to enclose an exclusion entry in single quotes so it does not confuse the YAML parser.
When in doubt, enclose string values in single quotes.
It never hurts to do it.

Let's throw away that non-version refname that we inadvertently matched:

----
branches: [v*.*.x, '!v1.0.x', '!very.last.x']
----

You can also use wildcards in the exclusion pattern to bulk match what you've already matched and remove those matches.

----
branches: [v*.*.x, '!v1.*.x', '!very.last.x']
----

The wildcard is a useful tool, but it's very loose with what characters it matches.
You may find that you need to get more precise.
That's where braces come in.

[#braces]
== Braces

Braces, also known as brace expressions, are patterns enclosed in curly braces (`{}`).
There are three kinds of brace expressions supported in Antora:

* a comma-separated list of alternate character sequences
* an alpha or numeric range
* a numeric range with a step

[#alternation]
=== Alternation

A comma-separated list of alternate characters, such as `{this,that}` should be read as "`this or that`".
This can be useful for matching specific numbers in a version.
Let's assume that we only want to match a very limited number of major version refnames.
We can identify them using an alternation brace expression:

----
branches: v{5,6}.*.x
----

This expression will match `v5.0.x`, `v5.1.x`, and `v6.0.x`.

You can use an alternation expression to match the absence of a character or segment using an empty entry.
Let's consider of making the `v` prefix optional.

----
branches: '{,v}{5,6}.*.x'
----

You can also use wildcards in the alternation entry.
For example, we might want to match prereleases this way:

----
branches: '{,v}{5,6}.*.x{,-*}'
----

Let's consider another case of matching specific minor versions for a given major version refname:

----
branches: v5.{7,8}.x
----

It's also possible to match refnames that do not start with a `v` (or other leading character).

----
branches: 5.{7,8}.x
----

As you can imagine, if you're specifying a bunch of numbers, they may start to form a range.
You can consolidate the alternation using the range syntax.

[#range]
=== Range

If the characters you are matching are members of a range, you can specify them using the start and end values only and separating them with two periods (`..`).
A range is another kind of alternation in which each item is considered.

Let's revisit our version pattern so it only considers matches that have numbers.

----
branches: v{1..9}.{0..9}.x
----

Now we will no longer match `very.last.x`.
However, it will no longer match `v20.10.x` either.
We can fix that by expanding the range, which is not limited to single-digit numbers.

----
branches: v{1..99}.{0..99}.x
----

However, there are more efficient ways of writing this, which we'll get into in the extended globbing section.

Returning to our other example, let's say that `5.9.x` was just released and we want to add it to our Antora-era version number pattern.
We can switch from a basic alternation to a range.

----
branches: 5.{7..9}.x
----

Alternately, we could use an exclusion to express this match the opposite way.

----
branches: ['5.*.x', '!5.{0..6}.x']
----

By default, a range considers each item.
You can skip over items using steps.

[#steps]
=== Steps

You can adjust the step size of a range by appending a third parameter, offset by two periods.
The step size tells the pattern matcher how far to go when moving to the next item in the range.
You can match all even major versions from 2 to 8 using the following pattern:

----
branches: v{2..8..2}.*.x
----

By changing the beginning value, you can match odd major versions instead:

----
branches: v{1..9..2}.*.x
----

////
=== Nested

TODO: Add content for this section?
////

On their own, braces have limited ability to express complex patterns.
To make brace expressions truly powerful, you need to combine them with extended globbing.

[#extended]
== Extended globbing and repetition

So far we've been matching single occurrences of segments, whether they're character sequences, alternations, or ranges.
We can take our patterns further by specifying how many times these segments must occur, if at all.
An extended glob allows you to enclose a pattern or pattern list inside a pair of round brackets, then assign a repetition operator to it.

The pattern matching in Antora supports the following operators:

* `*` - zero or more times
* `+` - one or more times (i.e., at least once)
* `?` - zero or one time (i.e., optional)
* `@` - exactly once (implied if no operator is specified)
* `!` - must not be present

The following extended glob is a more formal way of writing `{0..9}`:

----
@({0..9})
----

Here's an extended glob that matches any sequence of numbers.

----
*({0..9})
----

This use of repetition is *far* more efficient than the following range, which you should avoid using:

----
{0..100}
----

WARNING: While you can put `*` after the pattern list, we don't recommend it.
Repetition operations should always be placed before the pattern list.

We can use extended globbing make our version matcher precise in matching all minor versions refnames, beginning with `v1.0.0`:

----
branches: v@({1..9})*({0..9}).+({0..9}).x
----

or, to be more concise:

----
branches: v{1..9}*({0..9}).+({0..9}).x
----

We're saying that the major version must not start with 0.
Then, it can be followed by any number of digits (e.g., 1, 10, etc.).
The minor version can have one or more digits (e.g., 0, 99, 101, etc.).

We can use the negation operator to exclude while we're including instead of using a separate exclusion entry:

----
branches: 5.!({0..5}).x
----

Brace expressions can be nested in order to specify two branches of matching.
Here's how we can exclude those early minor versions while still matching any still to come.

----
branches: '5.{{6..9},{1..9}+({0..9})}.x'
----

We want to caution against making your pattern too complex.
While it may be possible to craft a pattern that can do all the matching you need to do, it becomes increasingly harder to read and maintain.
That's why we encourage you to use as many inclusion and exclusion patterns as you need to comfortably match the refnames for your site.

Let's wrap up with a full example of matching a very specific range of version numbers with all milestone versions removed.

----
tags:
- '{5,6}.+({0..9}).+({0..9}){,-*}'
- '!5.{0..5}.*'
- '!*-M+({0..9})'
----

// TODO document which options we use for picomatch
// TODO mention matching across path segments
// TODO brace expression with single entry is ignored {foo}
// TODO globstar??

// /docs/modules/playbook/pages/configure-git.adoc
[[configure-git.adoc]]
= Git Keys

The playbook keys configured under `git` control the behavior of the git client used by Antora.

[#git-key]
== git key

The `git` key holds all the git-related playbook keys, such as the git credentials, automatic URL suffix, and plugins.

.antora-playbook.yml
[,yaml]
----
git: # <.>
  fetch_concurrency: 3 # <.>
  fetch_depth: 0 # <.>
  ensure_git_suffix: false # <.>
  credentials: # <.>
    path: ./.git-credentials # <.>
  plugins: # <.>
    credential_manager: ./system-git-credential-manager.js # <.>
  read_concurrency: 5 # <.>
----
<.> Optional `git` category key
<.> Optional `fetch_concurrency` key to limit number of concurrent fetch operations
<.> Optional `fetch_depth` key to control how many recent commits Antora fetches from a repository
<.> Optional `ensure_git_suffix` key
<.> Optional `credentials` category key
<.> `path` key to specify the location of optional credentials; mutually exclusive with the `contents` key
<.> Optional `plugins` category key
<.> Optional `credential_manager` key
<.> Optional `read_concurrency` key to limit number of concurrent read operations (after repositories are fetched)

The `git` category key and the child keys it accepts are all optional.
When the `git` key isn't present in the playbook, Antora falls back to using the default configuration for the git client.

[#git-reference]
== Available git keys

[cols="3,6,1"]
|===
|Git Keys |Description |Required

|xref:git-credentials-path-and-contents.adoc[credentials.contents]
|Accepts git credentials data matching the format used by the git credential store.
|No

|xref:git-credentials-path-and-contents.adoc[credentials.path]
|Accepts a filesystem path to a git credentials file matching the format used by the git credentials store.
|No

|xref:git-fetch-concurrency.adoc[fetch_concurrency]
|`1` by default.
Accepts any positive integer or zero.
When non-zero, limits the number of concurrent fetch operations to the specified value.
When zero, does not limit the number of concurrent fetch operations.
|No

|xref:git-fetch-depth.adoc[fetch_depth]
|`1` by default (latest commit).
Accepts any positive integer or zero.
When non-zero, limits the preferred number of recent commits that are fetched to the specified value.
When zero, fetches all commits.
|No

|xref:git-plugins.adoc#credential-manager[plugins.credential_manager]
|Accepts a require request that specifies the location of the code that provides a custom credential manager.
|No

|xref:git-plugins.adoc#http[plugins.http]
|Accepts a require request that specifies the location of the code that provides a custom HTTP request handler.
|No

|xref:git-suffix.adoc[ensure_git_suffix]
|`true` by default.
When `true`, this key instructs the git client to automatically append [.path]_.git_ to content sources repository URLs if absent.
|No

|xref:git-read-concurrency.adoc[read_concurrency]
|`0` by default (effectively no limit).
Accepts any positive integer or zero.
When non-zero, limits the number of read operations to the specified value.
When zero, does not limit the number of read operations.
|No
|===

// /docs/modules/playbook/pages/git-suffix.adoc
[[git-suffix.adoc]]
= Git Repository URL Suffix

The `ensure_git_suffix` key tells Antora whether it should append the [.path]_.git_ extension, if absent, to the URL of a remote content source.
If you're using GitHub or GitLab, you don't need to define this key in your playbook as the default will suffice.
However, if you're using Team Foundation Server (TFS) or Azure DevOps, read on.

[#default]
== Default git repository URL suffix

By default, the `ensure_git_suffix` key is assigned the value `true`.
When `ensure_git_suffix` is `true`, Antora instructs the git client to automatically append [.path]_.git_ to any remote content sources repository URLs that are missing the suffix.

Some git services don't recognize the URL if it contains the [.path]_.git_ extension.
Therefore, it's necessary for this behavior to be configurable.

[#ensure-git-suffix-key]
== ensure_git_suffix key

The optional `ensure_git_suffix` key is set under the xref:configure-git.adoc[git key] in a playbook.
It accepts a boolean value.

false:: Antora won't append [.path]_.git_ to any xref:content-source-url.adoc[URL for a remote content source] that are missing the [.path]_.git_ suffix.

true:: Default value.
Antora will append [.path]_.git_ to any remote content sources repository URLs that are missing the [.path]_.git_ suffix.

If you use Team Foundation Server (TFS) or Azure DevOps, you may need to set `ensure_git_suffix` to `false` if your content sources repositories fail to clone.

.antora-playbook.yml
[,yaml]
----
git:
  ensure_git_suffix: false
----

// /docs/modules/playbook/pages/git-fetch-depth.adoc
[[git-fetch-depth.adoc]]
= Git Fetch Depth

The `fetch_depth` key tells Antora how much of the history of a remote repository to fetch.

[#default]
== Default git fetch depth

By default, Antora will only fetch the latest commit when cloning a repository.
When fetching, Antora will only fetch as many commits as needed to get the latest commit.

[#fetch-depth-key]
== fetch_depth key

If you want to increase the number of recent commits Antora fetches from a remote repository, set the `fetch_depth` key to a positive integer.

.antora-playbook.yml
[,yaml]
----
git:
  fetch_depth: 10
----

If you want Antora to fetch the full history, set the value of this key to `0`.

.antora-playbook.yml
[,yaml]
----
git:
  fetch_depth: 0
----

// /docs/modules/playbook/pages/git-fetch-concurrency.adoc
[[git-fetch-concurrency.adoc]]
= Git Fetch Concurrency Limit

The `fetch_concurrency` key tells Antora how many concurrent fetch operations to allow when retrieving content from remote git repositories.
This covers both the `fetch` and `clone` operations (since `clone` first does a `fetch`).
When the number of concurrent operations reaches this limit, Antora will wait for an active operation to complete before adding another one to queue.

See the xref:git-read-concurrency.adoc[] to learn how to control how many repositories Antora reads from at once.

== Default fetch concurrency

By default, Antora limits the fetch concurrency to 1, which means it will only fetch from one repository at a time.
If you want to allow Antora to fetch all the repositories at once, you can change this value to `0`.

Fetching a lot of repositories at once can put a heavy burden on the network.
Additionally, some git hosting services place a quota on concurrent requests, especially anonymous onces (called rate limiting).
That may lead to the git client being throttled (or even barred) by the git server.
In the worst case, the server may hang up on the network connection, which will cause Antora to fail.
To alleviate this situation, Antora allows you to tune the fetch concurrency limit.

[#fetch-concurrency-key]
== fetch_concurrency key

The optional `fetch_concurrency` key is set under the xref:configure-git.adoc[git category] in the playbook.
This key accepts a positive integer value or `0` for no limit.

.antora-playbook.yml
[,yaml]
----
git:
  fetch_concurrency: 5
----

The purpose of the `fetch_concurrency` key is to allow you to control (i.e., limit) how many network connections are being made at once by the content aggregator, thus circumventing the problem of rate limiting enforced by the git host.
If the git server is extremely aggressive with resetting paused connections, such as the case with GitHub, you're advised to set this value to `1`.

You may find that by limiting the number of concurrent operations, it reduces the time it takes the fetch operations to complete.
Presumably, this is because the git server does not throttle the requests.
However, fetching repositories in serial could also increase the amount of time it takes to fetch the repositories in total.
You will need to experiment with this value to find the setting that works best for your site.

For interactive terminals, limiting the fetch concurrency also limits the number of progress bars that appear at once in the terminal.

== Relationship to repository scanning

Once a repository is fetched, or if a fetch is not required, Antora puts the repository into a pool to be scanned.
By default, Antora does not place a limit on how many repositories are scanned concurrently.
You can control this behavior using the xref:git-read-concurrency.adoc[] key.
Antora only starts reading from repositories once all fetch (or clone) operations are complete.
The limit is only applied to the fetch step.

Antora fetches content from a remote repository if it has not previously cloned the repository or the xref:runtime-fetch.adoc[runtime.fetch key] is set.

// /docs/modules/playbook/pages/git-read-concurrency.adoc
[[git-read-concurrency.adoc]]
= Git Read Concurrency Limit

Similar to the xref:git-fetch-concurrency.adoc[], the `read_concurrency` key tells Antora how many content repositories (local or managed) to read from at once.
This key effectively controls how many git indexes are loaded into memory at once (a git index is the backing storage for files in a git repository).

Antora only reads repositories once all fetch/clone operations on those repositories are complete.
Thus, the fetch and read are separate steps.

== Default read concurrency

By default, Antora does not limit the read concurrency (value `0`), which means it will load all repositories into memory at once when scanning for and collecting files.
Loading a lot of large repositories at once can consume a lot of memory.
To alleviate this situation, Antora allows you to tune the read concurrency limit.

NOTE: The read concurrency does not impact the xref:git-fetch-concurrency.adoc[fetch concurrency] or the network traffic.

[#read-concurrency-key]
== read_concurrency key

The optional `read_concurrency` key is set under the xref:configure-git.adoc[git category] in the playbook.
This key accepts a positive integer value or `0` for no limit.

.antora-playbook.yml
[,yaml]
----
git:
  read_concurrency: 4
----

When working with a lot of repositories, an optimal value is somewhere between 2 and 5.

The purpose of the `read_concurrency` key is to allow you to control how much memory is consumed when reading files from the content repositories.
Once a git index is loaded into memory, Antora uses unlimited concurrency to read the tree of each reference to collect files into the precursor of the content catalog (creating the content catalog is a subsequent step).

== Related to memory usage

While the residual memory will equate to the size of all content files collected, the git index that contains those files could be substantially larger.
This is especially true when the documentation is co-located with the source files of a software project.
Antora has to load the git index even if it is only taking a fraction of the files.

You may find that by limiting the number of concurrent operations, it reduces the time it takes the content aggregator to complete.
This is presumably because Antora has to do less context switching.
You will need to experiment with this value to find the setting that works best for your site.

// /docs/modules/playbook/pages/git-credentials-path-and-contents.adoc
[[git-credentials-path-and-contents.adoc]]
= Git Credentials Path and Contents
:url-credential-store: https://git-scm.com/docs/git-credential-store

In order for Antora to access private repositories, you must supply it with authentication credentials in order to access these private repositories.
By default, Antora will look for these authentication credentials in the default git credentials store.
When you're using an alternate git credential store location or haven't populated the default store with credentials, you can use the `credentials.path` or `credentials.contents` keys to pass your credentials to Antora.

[#default]
== Default git credentials store and path

When a git host requests authentication for a private xref:content-source-url.adoc[content source repository], Antora's built-in credential manager automatically checks for credentials in the {url-credential-store}[default git credential store^].
The default path for the git credential store is _$HOME/.git-credentials_ (or _$XDG_CONFIG_HOME/git/credentials_, if the previous location doesn't exist).

[#credentials-key]
== credentials key

The `credentials` key is set under the xref:configure-git.adoc[git key].

.antora-playbook.adoc
[,yaml]
----
git: # <.>
  credentials: # <.>
----
<.> Enter the parent key `git`, followed by a colon (`:`), and then press kbd:[Enter].
<.> The `credentials` key is a child of `git`.
Enter the key's name, `credentials`, followed by a colon (`:`), and then press kbd:[Enter].

The `credentials` key accepts a key-value pair that specifies an alternate filesystem path (`path`) to a git credentials file or the contents of the git credentials file (`contents`).
The `contents` key and the `path` key are mutually exclusive.
That is, you can only set one or the other in your playbook.

[#path-key]
=== path key

Instead of using the credential store at the default path, you can instruct Antora to look for the file in a different location.
The `path` key specifies a filesystem path where Antora can locate the git credential store.
This path is configured under the `git` and `credentials` keys in a playbook.
The `path` key accepts an absolute filesystem path or a filesystem path relative to the playbook file.

.antora-playbook.yml
[,yaml]
----
git:
  credentials: # <.>
    path: /home/user/.git-credentials # <.>
----
<.> The `path` key is nested under `credentials`
<.> Type the key name `path`, followed by a colon (`:`).
After the colon, enter a blank space, and then the filesystem path to the git credential store.

You can also specify an alternate git credentials path using the xref:private-repository-auth.adoc#custom-credential-path[--git-credentials-path CLI option or GIT_CREDENTIALS_PATH environment variable].

[#contents-key]
=== contents key

IMPORTANT: Instead of using the `contents` key, we highly recommend xref:private-repository-auth.adoc#populate-credentials-interactively[populating the default credential store] with your credentials or passing them using the xref:private-repository-auth.adoc#git-credentials-environment-variable[GIT_CREDENTIALS environment variable].
This key is really only intended for an auto-generated playbook file.

The `contents` key accepts one set of credentials or the credentials for one git host using the `contents` key.
To specify more than one set of credentials or access private repositories on different git hosts, you need to xref:private-repository-auth.adoc#populate-credentials-interactively[populate the credential store interactively] or xref:private-repository-auth.adoc#populate-credentials-interactively[directly].
You can also pass more than one set of credentials using the xref:private-repository-auth.adoc#git-credentials-environment-variable[GIT_CREDENTIALS environment variable].

The `contents` key is configured under the `git.credentials` key in a playbook.
The value of `contents` depends on the git host that serves the private content sources repository.
In general, the value takes the form of `\https://<credentials>@<hostname>`, where `<credentials>` is a placeholder that references an environment variable (`$ENV_VARIABLE`), a username/password pair (`username:password`), or an access token (`token`).
`<hostname>` is the address of the git server (e.g., `gitlab.com`).

WARNING: We don't recommend directly entering your git host username/password pair or access token into a playbook!
You could accidentally expose them by pushing your playbook to a remote repository or CI server.

In the example below, a reference to an environment variable named `GITHUB_TOKEN` is placed where the host GitHub expects to locate an access token.
The xref:private-repository-auth.adoc#host-credential-structure[credentials structure and location] depends on the git host.
For instance, GitHub requires a colon (`:`) be placed at the end of the token.

.antora-playbook.yml
[,yaml]
----
git:
  credentials:
    contents: https://$GITHUB_TOKEN:@github.com
----

Unfortunately, Antora does not yet support resolving environment variables located in the playbook file.
However, you can emulate this behavior by using the following script to substitute the environment variable reference with a value prior to invoking Antora:

 $ sed -i s/\$GITHUB_TOKEN/$GITHUB_TOKEN/ antora-playbook.yml &&
   antora antora-playbook.yml

Despite this workaround, we still recommend populating the git credential store or passing your credentials using the `GIT_CREDENTIALS` environment variable instead of using the `contents` key.

// /docs/modules/playbook/pages/git-plugins.adoc
[[git-plugins.adoc]]
= Git Plugins
:url-http-plugin-apidoc: https://isomorphic-git.org/docs/en/http#implementing-your-own-http-client

The `plugins` category key is used to specify the location of plugins to load into the git client.
The set of plugins is fixed and are referenced using predetermined names.
These plugins offer some degree of control over how the git client used by Antora operates.
The set of plugins may grow over time.

== plugins key

The `plugins` key is set under the xref:configure-git.adoc[git category key].

.antora-playbook.yml
[,yaml]
----
git: # <.>
  plugins: # <.>
----
<.> Enter the parent key `git`, followed by a colon (`:`), and then press kbd:[Enter].
<.> The `plugins` category key is nested under the `git` category key.
Enter the key's name, `plugins`, followed by a colon (`:`), and then press kbd:[Enter].

The `plugins` key accepts a map (i.e., key-value pairs) that specifies the location of predetermined plugins to load into the git client.

[#credential-manager]
=== credential_manager key

The `credential_manager` key is a child of the `git.plugins` category key.
It provides a way to specify a custom credential manager for the git client to use.
The credential manager plugin is called each time the git client interacts with a repository that requires authentication.

.antora-playbook.yml
[,yaml]
----
git:
  plugins: # <.>
    credential_manager: ./my-git-credential-manager-plugin.js # <.>
----
<.> The `credential_manager` category key is nested under the `git.plugins` category key.
<.> Type the key name, `credential_manager`, followed by a colon (`:`).
After the colon, entry a space followed by the require request that identifies where the code for the credential manager plugin is located.

When the `credential_manager` key is set, Antora will use the require request to locate and load the code of the plugin and register it with the git client.
The API of the credential manager plugin, and how it works, is described in xref:private-repository-auth.adoc#custom[Configure a custom credential manager].

[#http]
=== http key

The `http` key is a child of the `git.plugins` category key.
It provides a way to specify a custom HTTP request handler for the git client to use.
The http plugin is called each time the git client communicates with a git repository (which is all done over HTTP).

.antora-playbook.yml
[,yaml]
----
git:
  plugins: # <.>
    http: ./my-git-http-plugin.js # <.>
----
<.> The `http` category key is nested under the `git.plugins` category key.
<.> Type the key name, `http`, followed by a colon (`:`).
After the colon, entry a space followed by the require request that identifies where the code for the http plugin is located.

When the `http` key is set, Antora will use the require request to locate and load the code of the plugin and register it with the git client.

The API of the http plugin is covered by the {url-http-plugin-apidoc}[isomorphic-git documentation^].
It amounts to exporting an async function named `request` that accepts the url, method, headers, and body as parameters and returns the result of the request as an object with url, method, headers, body, statusCode, and statusMessage properties.
In that function, you can use your own HTTP client to fulfill the request.

// /docs/modules/playbook/pages/configure-asciidoc.adoc
[[configure-asciidoc.adoc]]
= AsciiDoc Keys

The playbook keys configured under `asciidoc` apply attributes, Asciidoctor extensions, and additional behavior to the AsciiDoc processor.

[#asciidoc-key]
== asciidoc key

The `asciidoc` key specifies the attributes that are assigned and made available to all of the site's pages.
It also registers Asciidoctor extensions and activates additional AsciiDoc syntax error reporting features.

.antora-playbook.yml
[,yaml]
----
asciidoc: # <.>
  sourcemap: true # <.>
  attributes: # <.>
    table-caption: ~ # <.>
  extensions: # <.>
  - ./lib/custom-block.js # <.>
----
<.> Optional `asciidoc` key
<.> Optional `sourcemap` key
<.> Optional `attributes` key
<.> Defined built-in AsciiDoc attribute
<.> Optional `extensions` key
<.> Path to a local extension script

[#asciidoc-reference]
== Available AsciiDoc keys

[cols="3,6,1"]
|===
|AsciiDoc Keys |Description |Required

|xref:asciidoc-attributes.adoc[attributes]
|Accepts a map of built-in, custom, and page attributes that are applied to and made available to all of the site's pages.
|No

|xref:asciidoc-extensions.adoc[extensions]
|Accepts a list of Asciidoctor extensions.
Depending on the capabilities of the extension, the extension will either be registered globally or be scoped to the AsciiDoc processor instance for a page.
|No

|xref:asciidoc-sourcemap.adoc[sourcemap]
|When `true`, provides additional file and line number information about AsciiDoc blocks to Antora's logger and Asciidoctor extensions.
The default value is `false`.
|No
|===

// /docs/modules/playbook/pages/asciidoc-attributes.adoc
[[asciidoc-attributes.adoc]]
= Assign Attributes to a Site

You can apply attributes to all of the pages in a site by declaring them in a site's playbook file.

== Site attributes

Attributes declared in a playbook are referred to as [.term]*site attributes*.
These attributes are set and available (or unavailable if unset) to all the pages in the site.
The pages in a site are defined as all pages that Antora finds in the content sources specified in the playbook for a single run of Antora.
Site attributes can be xref:page:attributes.adoc[built-in, custom, and page attributes].
The <<precedence-rules,attribute precedence rules>> determine whether site attributes can be overridden at a more granular level.

In addition to being declared site-wide in a playbook, attributes can be xref:ROOT:component-attributes.adoc[defined per component version] in an [.path]_antora.yml_ file or xref:page:attributes.adoc[directly on a page in the page's header].
However, when an attribute is hard set or hard unset in the site's playbook, it overrides any subsequent declarations of the same attribute in a component version descriptor or page.
Site attributes can also be xref:cli:options.adoc#attribute[configured from the CLI].

include::partial$playbook-vs-descriptor.adoc[tags=**;!note-for-extension-writers]

[#attributes-key]
== attributes key

Site attributes are mapped under the `attributes` key in a playbook.
The attributes key must be set under the `asciidoc` key.

.antora-playbook.yml
[,yaml]
----
asciidoc:
  attributes:
    hide-uri-scheme: ''
    page-team: Coco B
    table-caption: ~
    listing-caption: Snippet@
----

Site attributes are applied and available to all of a site's pages according to the <<precedence-rules,attribute precedence rules>>.

[#hard-set]
== Set attributes in the playbook

Each site attribute is entered on its own line as a key-value pair under the `attributes` key.

.Declare attributes in the playbook
[#ex-hard-set,yaml]
----
asciidoc: # <.>
  attributes: # <.>
    listing-caption: Snippet # <.>
    hide-uri-scheme: '' # <.>
    page-team: Coco B # <.>
    db: graphical-peaks-pack.db # <.>
----
<.> Enter the `asciidoc` key, followed by a colon (`:`), and press kbd:[Enter].
<.> The `attributes` key is nested under the `asciidoc` key.
Enter `attributes`, followed by a colon (`:`), and press kbd:[Enter].
<.> Site attributes are nested under the `attributes` key.
Enter the name of the attribute, followed by a colon (`:`).
Press kbd:[spacebar] once after the colon, then enter the value of the attribute.
<.> To set an attribute without specifying an explicit value, assign an _empty string_ by entering two consecutive single quotation marks (`''`) in the value part.
For certain built-in attributes, an empty value is equivalent to the default value, though it depends on the attribute.
Although using the boolean value `true` often works in this case, attribute values in AsciiDoc are strings, so it will likely be coerced to the string value `'true'`.
<.> To declare a custom page attribute, type `page-` and the name of your attribute, followed by a colon (`:`).
Press kbd:[spacebar] once after the colon, then enter the value of the attribute.
<.> This custom attribute, like the previous three attributes, is hard set.

The attributes in <<ex-hard-set>> are all hard set.
[.term]*Hard set* site attributes cannot be overridden from a component version descriptor or a page.
By default, an attribute is hard set when it's assigned a value that isn't reserved for unsetting the attribute (i.e., `false` or `~`) and doesn't end with a modifier (i.e., `@`).
To allow a component version or page to modify or unset a site attribute, you need to <<soft-set,soft set the site attribute>>.

Attributes set in the playbook are site-wide and, thus, available to every page in your site.
The values of custom attributes, such as `page-team` and `db` can be displayed in a page using the AsciiDoc attribute reference syntax (e.g., `+{page-team}+`, `+{db}+`).
Site attributes can also be referenced from the <<references-in-values,value of another site attribute>>, xref:ROOT:component-attributes.adoc#references-in-values[component version attribute], or xref:page:attributes.adoc[page attribute].

[#soft-set]
=== Soft set attributes

Soft set site attributes can be overridden from a component version descriptor or page.
An attribute is soft set in a playbook by attaching the `@` modifier to the end of its value.

.Assign soft set precedence to attributes
[#ex-soft-set,yaml]
----
asciidoc:
  attributes:
    page-team: Coco B@ # <.>
    hide-uri-scheme: '@' # <.>
----
<.> To soft set an attribute that's assigned an explicit value, attach the `@` modifier to the end of its value.
<.> To soft set and assign a built-in attribute's default value, or in the case of a boolean attribute, the _empty string_ value, type an opening single quotation mark, followed by the `@` modifier, and then a closing single quotation mark (`'`).

Since the site attributes in <<ex-soft-set>> are soft set, a component version descriptor or page could modify their values or unset them.

[#references-in-values]
=== Insert the value of another attribute

The value of any site attribute set earlier in the playbook or from the CLI can be inserted into the value of a site attribute using an AsciiDoc attribute reference (e.g., `+{page-team}+`).

.A site attribute that references the value of another site attribute
[#ex-attribute-value-references,yaml]
----
asciidoc:
  attributes:
    page-team: Coco B@
    db: graphical-peaks-pack.db
    test-server: http://localhost:9090/{db}
----

A site attribute can also be referenced in the value of a xref:ROOT:component-attributes.adoc#references-in-values[component version attribute] or xref:page:attributes.adoc[page attribute].

To prevent an attribute reference substitution, insert a backslash in front of the reference (e.g., `+\{not-substituted}+`).
In this case, the attribute reference will not be substituted and the backslash will be omitted.

[#hard-unset]
== Unset attributes in the playbook

Site attributes can also be unset in a playbook.
Site attributes are hard unset when they're assigned the reserved tilde symbol (`~`) value.
Each site attribute is entered on its own line as a key-value pair under the `attributes` key.

.Hard unset site attributes in the playbook
[#ex-hard-unset,yaml]
----
asciidoc:
  attributes:
    figure-caption: ~ # <.>
    hide-uri-scheme: ~ # <.>
----
<.> To hard unset an attribute, assign it the tilde symbol (`~`).
`~` is shorthand in YAML for `nil`, which is a reserved value that hard unsets a site attribute.
<.> Boolean attributes are also hard unset when assigned the tilde symbol (`~`).

[.term]*Hard unset* site attributes cannot be overridden from a component version descriptor or a page.
When a site attribute is hard unset, its behavior is turned off and it isn't available to the site's pages.

[#soft-unset]
=== Soft unset attributes

Soft unset site attributes can be overridden from a component version descriptor or page.
An attribute is soft unset in a playbook by assigning it the reserved value `false`.

.Assign soft unset precedence to attributes
[#ex-soft-unset,yaml]
----
asciidoc:
  attributes:
    figure-caption: false # <.>
    hide-uri-scheme: false # <.>
----
<.> To soft unset an attribute, assign it the value `false`.
<.> Boolean attributes are also soft unset when assigned `false`.

Since the site attributes in <<ex-soft-unset>> are soft unset, a component version descriptor or page could reset them.

[#precedence-rules]
== Precedence rules

Antora takes the precedence assigned to attributes in the site's playbook into account first.
Site attributes that are hard set and hard unset can't be changed by a component version descriptor file or a page.
However, soft set and unset site attributes can be overridden from the component version descriptor or a page.

. <<hard-set,Hard setting>> a site attribute using a string value with no trailing `@` modifier (e.g., `value` or `''`) prevents a component version descriptor or page from changing or unsetting the attribute.
. <<soft-set,Soft setting>> a site attribute using a string value with a trailing `@` modifier (e.g., `value@` or `'@'`) allows a component version descriptor or page to change or unset the attribute.
. <<hard-unset,Hard unsetting>> a site attribute using the tilde symbol (`~`) prevents a component version descriptor or page from setting the attribute.
. <<soft-unset,Soft unsetting>> a site attribute using the `false` value allows a component version descriptor or page to set the attribute.

To learn more about how site attributes interact with component version attributes and page attributes, see xref:ROOT:component-attributes.adoc[] and xref:page:attributes.adoc[].

[#intrinsic]
== Intrinsic site attributes

Antora defines intrinsic site and page attributes from some of the keys in a playbook file.
For instance, Antora sets the built-in attribute `site-title` and assigns it the value specified by the `site.title` key.
Antora also sets some built-in AsciiDoc attributes, such as `sectanchors`, by default.
See xref:page:intrinsic-attributes.adoc#site-and-configuration-attributes[Site and configuration attributes] and xref:page:intrinsic-attributes.adoc#page-attributes[Intrinsic page attributes] for more information.

include::ROOT:partial$dont-use-these-attributes.adoc[]

// /docs/modules/playbook/pages/asciidoc-extensions.adoc
[[asciidoc-extensions.adoc]]
= Asciidoctor Extensions

The `asciidoc` key can be used to register Asciidoctor extensions.

== Install extension code

Before registering an extension in your playbook, you need to install the extension code.
You can install it globally, declare it as a dependency of the project, or add the extension script to the playbook project.

[#extensions-key]
== extensions key

An Asciidoctor extension is registered using the `extensions` key.
The `extensions` key accepts a list of node module names (i.e., npm package names) and relative or absolute filesystem paths.

IMPORTANT: When registering an Asciidoctor extension, make sure you're using the nested key `asciidoc.extensions` and not `antora.extensions`.
The latter key is for registering Antora extensions, which use a different extension facility.

.antora-playbook.yml
[,yaml]
----
asciidoc:
  extensions:
  - name-of-node-module
  - ./path/to/extension
----

IMPORTANT: If you're trying to require a Node.js module (e.g., a package installed from npmjs.com) whose name ends with a file extension, such as `.js`, you must append a trailing forward slash.
For example, the Node.js module `highlight.js` must be written as `highlight.js/`.
This suffix tells Antora to resolve the request as the name of a module, not as a local file.
Without this suffix, Antora assumes the request is a local file.
If it's not a local file, this can result in the error message _Cannot find module_.
If the request is already a local file, the suffix is not needed.

[#global-extensions]
== Global Asciidoctor extensions

Global extensions are registered once, before any pages are converted.
These extensions are shared by all documents Antora converts using Asciidoctor (including navigation files).
A global extension is a node module or script that exports a function when required.
Antora passes this function directly to the `register` method of Asciidoctor's static extension registry.

To register a global extension, all you need to do is reference its name (if it's a node module on the require path) or path (if it's a local script) in the `extensions` key.

.Register a global extension provided by a node module
[,yaml]
----
asciidoc:
  extensions:
  - asciidoctor-emoji-macro
----

In this case, `asciidoctor-emoji-macro` is the name of an installed node module and is thus available on the require path (either in the [.path]__node_modules__ directory in the playbook project or in the global [.path]__node_modules__ directory).

.Register a global extension from a local script
[,yaml]
----
asciidoc:
  extensions:
  - ./lib/shout-block
----

In this case, the extension is a script located at the path [.path]_lib/shout-block.js_ relative to the playbook file.

Here's an example that shows how to register multiple global extensions:

.Register multiple global extensions
[,yaml]
----
asciidoc:
  extensions:
  - asciidoctor-emoji-macro
  - ./lib/shout-block
----

[#scoped-extensions]
== Scoped Asciidoctor extensions

Rather than requiring an extension globally, you may want to register an extension per instance of the AsciiDoc processor.
The benefit of this approach is that it allows the extension to hook into the Antora lifecycle.
The other difference is that scoped extensions are only registered and used for pages, not for navigation files.

In order to register a scoped extension, the extension must support this mode of usage.
Specifically, the extension must export a `register` function that accepts an extension registry on which it self registers.
The function is called with a scoped (per-processor) extension registry and a context object.
The context object includes the current file, the content catalog, and the AsciiDoc configuration object from the playbook.

Here's an example of a `register` function for a scoped extension:

.Scoped Asciidoctor extension register function
[,js]
----
module.exports.register = function (registry, context) {
  registry.block('shout', createShoutBlock(context))
}
----

A scoped extension is registered in the playbook in exactly the same way as a global extension.

.Register a scoped extension from the require path
[,yaml]
----
asciidoc:
  extensions:
  - asciidoctor-kroki
----

.Register a scoped extension from a local script
[,yaml]
----
asciidoc:
  extensions:
  - ./lib/equation-macro
----

The main difference is that if the extension exports the `register` function, it gets scoped to the processor instance instead of being registered globally.

//Perhaps we should require #register at the end of the extension; hmmm

[#preload-extensions]
== Preloading extensions

Instead of registering extensions using the playbook, you can preload extensions using the xref:cli:options.adoc#require[-r or --require CLI option].
The value of this option may be either a path to a file (relative to the current directory), or a node module name.
The `-r` option may be specified multiple times.

This option gives site authors the ability to load additional code into the runtime before Antora begins executing, in fact, before Antora is even loaded.
The option follows the module resolution rules of the `require()` function in Node.js.
A common use case for this option is to register Asciidoctor extensions globally.

If the node module or script is an Asciidoctor extension, it must self-register with Asciidoctor's static extension registry when required in order for the extension to be used.
(Antora merely requires the script.
It does not invoke its exported function).

Here's an example showing how to use the Antora CLI to preload multiple Asciidoctor extensions:

 $ antora -r ./lib/shout-block -r asciidoctor-emoji-macro antora-playbook.yml

The `-r` option can also be used for other purposes, such as to alter global state or override Antora components.

For more information about the CLI, see xref:cli:index.adoc[].

// /docs/modules/playbook/pages/asciidoc-sourcemap.adoc
[[asciidoc-sourcemap.adoc]]
= File and Line Number Information
// Sourcemap
// Sourcemap Information
// AsciiDoc File and Line Number Information
// Report AsciiDoc File and Line Number Information
// File and Line Information with Sourcemap

The `sourcemap` key, when activated, provides additional file and line number information about AsciiDoc blocks to Antora's logger and Asciidoctor extensions.

== What is the sourcemap?

The sourcemap is an AsciiDoc processor feature that tracks and stores the file and line number for each parsed AsciiDoc block.
Some Asciidoctor extensions rely on this information to run successfully or return the correct output.
Antora's logger uses this information to add line number and include directive source file location context to the error, warning, and info messages it logs that concern the AsciiDoc syntax.
For example, when the AsciiDoc processor's sourcemap is turned on (activated), Antora's logger can provide the line number where an unresolved xref is located in a file.
If the sourcemap is turned off, the logger can only provide the location of the page file that contains the broken xref.

The sourcemap feature is turned on by activating the `sourcemap` key in your playbook or using the <<sourcemap-option,--asciidoc-sourcemap option>>.

////
When the `sourcemap` key is activated (turned on), the AsciiDoc processor computes and stores additional file and line number information about AsciiDoc blocks during the generation of your site.
Some Asciidoctor extensions rely on this information being available while processing your source content.
It also provides more context about AsciiDoc syntax errors when they're logged.
For example, when `sourcemap` is turned on, error messages about unresolved xrefs include the line number where the broken xref is located in a file's content.
////

[#default]
== Default sourcemap value

The `sourcemap` key is set to `false` by default.
That is, it's deactivated (turned off) at runtime unless activated in the playbook or from the CLI using the <<sourcemap-option,--asciidoc-sourcemap option>>.

=== Why isn't sourcemap turned on by default?

Antora doesn't activate the `sourcemap` key by default because it adds additional processing and object allocation to the build process.
This may increase the time it takes to generate your site.

[#sourcemap-key]
== sourcemap key

The optional `sourcemap` key is mapped to the xref:configure-asciidoc.adoc[asciidoc key].

.antora-playbook.yml
[,yaml]
----
asciidoc:
  sourcemap: true
----

To activate the `sourcemap` key, assign it the value `true` in the playbook file.

[#sourcemap-option]
== AsciiDoc sourcemap option

You don't have to modify the playbook file directly to activate or deactivate this key.
To activate the sourcemap from the CLI, use the xref:cli:options.adoc#sourcemap[--asciidoc-sourcemap option].

 $ antora --asciidoc-sourcemap antora-playbook.yml

The `--asciidoc-sourcemap` option overrides a value assigned to the `sourcemap` key in the playbook file.

When the `sourcemap` key is activated in a playbook file, it cannot be deactivated from the command line.
The CLI can only activate it.

// /docs/modules/playbook/pages/configure-ui.adoc
[[configure-ui.adoc]]
= UI Keys

The playbook keys configured under `ui` define the location of the UI bundle and control how it's processed.

[#ui-key]
== ui key

The `ui` key specifies the UI bundle's location, state, default page template name, and output directory.

.antora-playbook.yml
[,yaml]
----
ui: # <.>
  bundle: # <.>
    url: https://example.org/docs-ui/download/latest/ui-bundle.zip # <.>
    snapshot: true # <.>
    start_path: dark # <.>
  default_layout: base # <.>
  output_dir: _/dark # <.>
----
<.> Required `ui` key
<.> Required `bundle` key
<.> Required `url` key
<.> Optional `snapshot` key
<.> Optional `start_path` key
<.> Optional `default_layout` key
<.> Optional `output_dir` key

The `ui`, `bundle`, and `url` keys are required.
Alternatively, the `url` key can be assigned from the xref:cli:options.adoc#ui-bundle[CLI].
The other keys are optional; Antora uses their default values if they're not specified.

[#ui-reference]
== Available UI keys

[cols="3,6,1"]
|===
|UI Keys |Description |Required

|xref:ui-bundle-url.adoc#snapshot[bundle.snapshot]
|Indicates whether the URL points to a snapshot.
|No

|xref:ui-bundle-url.adoc#start-path-key[bundle.start_path]
|Accepts a path inside the UI bundle from which files should be selected.
|No

|xref:ui-bundle-url.adoc[bundle.url]
|Accepts a URL or filesystem path to a UI bundle archive.
|Yes

|xref:ui-default-layout.adoc[default_layout]
|Applies a layout template to pages that don't specify a page layout.
|No

|xref:ui-output-dir.adoc[output_dir]
|Accepts a filesystem path to the output directory where Antora writes the published site's UI files.
|No

|xref:ui-supplemental-files.adoc[supplemental_files]
|Supplemental files (aka supplemental UI) to overlay onto the UI bundle.
|No
|===

// /docs/modules/playbook/pages/ui-bundle-url.adoc
[[ui-bundle-url.adoc]]
= UI Bundle URL
:url-zip-file-format: https://en.wikipedia.org/wiki/Zip_(file_format)

A UI bundle is a {url-zip-file-format}[ZIP archive] or directory that contains one or more UIs for a site.
The only required file in the UI bundle is the default layout for pages (e.g., [.path]_layouts/default.hbs_) (and, if the 404 page is enabled, [.path]_layouts/404.hbs_ as well).
Antora automatically fetches and loads a UI bundle when generating a site.

[#url-key]
== url key

The `url` key is required.
This key is configured under the xref:configure-ui.adoc[bundle key] of the ui category key in a playbook.
The `url` key accepts a URL or filesystem path from where Antora can locate and fetch the site's UI bundle.
The filesystem path must point to a ZIP archive or a local directory where the ZIP archive has been extracted.

.antora-playbook.adoc
[source,yaml]
----
ui: # <.>
  bundle: # <.>
    url: https://repo.org/path/to/a-ui-bundle.zip # <.>
----
<.> Enter the parent key `ui`, followed by a colon (`:`), and then press kbd:[Enter].
<.> The `bundle` key is a child of `ui`.
Enter the key's name, `bundle`, followed by a colon (`:`), and then press kbd:[Enter].
<.> The `url` key is a child of `bundle`.
Enter `url`, followed by a colon and a blank space (`:{sp}`), and then enter a URL or filesystem path value.

Alternatively, the `url` key can be assigned from the xref:cli:options.adoc#ui-bundle[CLI].

The UI bundle can be augmented using a xref:ui-supplemental-files.adoc[supplemental UI].

[#remote-bundle]
== Load a remote bundle

When the value of `url` is a remote URL, Antora downloads and caches the UI bundle the first time it runs.
In this case, the target must be a ZIP archive.

.Remote UI bundle
[,yaml]
----
ui:
  bundle:
    url: https://repo.org/path/to/a-ui-bundle.zip
----

The UI bundle is cached based on the signature of the URL.
On subsequent runs, Antora loads the bundle from the cache as long as the value of `url` remains unchanged.
This saves Antora from having to download the bundle each time you generate your site.

[#snapshot]
=== Use a snapshot

Antora won't download the UI bundle again if it exists in the cache, even when xref:runtime-fetch.adoc[fetch] is enabled.
If the `url` value remains the same, but the archive it points to changes over time, the UI bundle needs to be identified as a snapshot to bypass this cache.

In order to retrieve UI bundle updates without changing the `url` value, you need to enable the `snapshot` key adjacent to the `url` key.
By default, snapshot is not enabled (set to `false`).
When snapshot is set to `true`, Antora will download the UI bundle whenever the xref:runtime-fetch.adoc#fetch-key[fetch key] under the `runtime` category of the playbook is enabled.
The xref:runtime-fetch.adoc#fetch-key[fetch key] instructs Antora to retrieve updates (including the UI bundle snapshot).

.Remote UI bundle marked as a snapshot
[,yaml]
----
ui:
  bundle:
    url: https://gitlab.com/antora/antora-ui-default/-/jobs/artifacts/HEAD/raw/build/ui-bundle.zip?job=bundle-stable
    snapshot: true
----

TIP: If you're using Antora's reference UI bundle, you should mark the bundle as a snapshot because its URL never changes.

If you want to control when Antora retrieves updates, pass the `--fetch` option when invoking the `antora` command.
To make this setting permanent, set the `runtime.fetch` key in the playbook to `true`.

.Fetch updates as persistent setting
[,yaml]
----
runtime:
  fetch: true
----

The snapshot key is only required if you're referring to a remote bundle (which Antora caches by default).
If you're referencing a bundle from the filesystem, Antora will always use the file specified.

[#local-bundle]
== Load a bundle from the filesystem

The `url` key can reference a local UI bundle using an absolute or relative filesystem path.

.Relative UI bundle path
[,yaml]
----
ui:
  bundle:
    url: ./../docs-ui/build/ui-bundle.zip
----

include::partial$relative-path-rules.adoc[]

Here's the path to the same UI bundle, but using an absolute path instead.

.Absolute UI bundle path
[,yaml]
----
ui:
  bundle:
    url: /home/user/projects/docs-ui/build/ui-bundle.zip
----

Here's the path to the location where the UI bundle has been extracted (or it was organized with the same layout as an extracted archive).

.Extracted UI bundle path
[,yaml]
----
ui:
  bundle:
    url: ./../docs-ui/build/ui-bundle-extracted
----

Loading the UI bundle from a local directory is a good way to debug the UI templates.

If you're using the default UI, you can run `npx gulp build` instead of `npx gulp bundle` (thus skipping the bundle step), then point Antora to the directory of the UI files ready to be bundled.

.Extracted UI bundle path
[,yaml]
----
ui:
  bundle:
    url: ./../docs-ui/public/_
----

You could also configure the UI project to automatically detect changes and run the `npx gulp build` step on demand.

[#start-path-key]
== start_path key

The `start_path` key is mapped to the `bundle` key.
It accepts a the relative path inside the UI bundle from where Antora should start reading files.
This key is useful when a UI bundle packages multiple UIs (e.g., light, dark, etc.).

.Select UI from start_path
[,yaml]
----
ui:
  bundle:
    url: /home/user/projects/docs-ui/build/ui-bundle-with-themes.zip
    start_path: dark
----

In this example, Antora will ignore all of the files in the UI bundle that fall outside the [.path]_dark_ directory.

// /docs/modules/playbook/pages/ui-supplemental-files.adoc
[[ui-supplemental-files.adoc]]
= Supplemental UI

You can specify supplemental UI files to augment the UI bundle.
These files are referred to collectively as the [.term]*supplemental UI* because they supplement the files provided by the UI bundle.

The supplemental UI is useful for customizing an existing UI bundle without having to create a new one.
It should not, however, be used as a replacement for developing a custom UI bundle.
Rather, it should be used to make a few minor adjustments or additions to suit a particular environment.
One such example is a favicon.
Since the favicon is part of the brand identity, you may want to use an off-the-shelf UI bundle, but add your own favicon to it.
You can use the supplemental UI to accomplish this goal.

== How it works

The supplemental UI is overlaid onto the files in the loaded UI bundle.
If the path of a file in the supplemental UI does not match the path of a file in the UI bundle, that file is added to the files from the UI bundle.
If the path of a file in the supplemental UI matches the path of a file in the UI bundle, the file from the supplemental UI replaces the file from the UI bundle.
The files in the supplemental UI are not otherwise processed.

[#supplemental-files-key]
== supplemental_files key

The supplemental UI is configured using the `supplemental_files` key under the `ui` category key.
The key accepts either the path of a directory that contains the supplemental files or a map of virtual files.
Currently, these two value types are mutually exclusive.

=== Directory

If the value of the `supplemental_files` key is a string, Antora assumes this value is the path of a directory.
The value may be specified as a relative or absolute filesystem path.
include::partial$relative-path-rules.adoc[]

[#ex-dir,yaml]
----
ui:
  supplemental_files: ./supplemental-ui
----

Antora scans this directory for files and adds them to the loaded UI bundle.
The directory is assumed to be the root of the UI hierarchy.
Therefore, the UI path is the path of the file relative to this directory.

Let's assume you want to replace the [.path]_head-meta_ partial with your own.
Create the file at [.path]_supplemental-ui/partials/head-meta.hbs_ relative to the playbook file.
Next, populate it with HTML and any optional template logic that you want to include.

.supplemental-ui/partials/head-meta.hbs
[,hbs]
----
{{#with site.keys.googleSiteVerification}}
<meta name="google-site-verification" content="{{this}}">
{{/with}}
----

Antora will now use this partial in place of the [.path]_head-meta_ partial provided by the UI.

=== Virtual files

As an alternative to a directory, you can specify the supplemental UI files directly in the playbook as virtual files.
If the value of the `supplemental_files` key is an array, Antora assumes that each entry is a virtual file.
A virtual file entry consists of two keys, `path` and `contents`.
The `path` key is the relative path of the file in the UI (e.g., [.path]_partials/head-meta.hbs_).
The contents can be the specified directory or sourced from a file on the filesystem.

If the value of the `contents` key is a single line and ends with a file extension (e.g., `.hbs`), Antora assumes the value is the path of a file specified as a relative or absolute filesystem path.
Otherwise, Antora uses the value as entered as the contents.
If Antora determines the value is a file path, it reads the file and assigns the contents to the virtual file.
If you omit the `contents` key, Antora will create an empty file.

Let's assume you want to replace the [.path]_head-meta_ partial with your own.
You can define it as a virtual file in the playbook:

[,yaml]
----
ui:
  supplemental_files:
  - path: partials/head-meta.hbs
    contents: |
      {{#with site.keys.googleSiteVerification}}
      <meta name="google-site-verification" content="{{this}}">
      {{/with}}
----

You could also put the contents in a file and reference it from the virtual file entry:

[,yaml]
----
ui:
  supplemental_files:
  - path: partials/head-meta.hbs
    contents: ./supplemental-ui/partials/head-meta.hbs
----

If you are only defining a few small files, you can usually manage to define them directly in the playbook.
If the files are larger, or you need to share them between multiple playbooks, its best to store them in separate files.

== Static files

By default, publishable assets provided by the supplemental UI, such as images and JavaScript files, are published to the xref:ui-output-dir.adoc[UI output directory].
It's possible to configure certain files to be published to the root of the published site.
These files are referred to as [.term]*static files*.
Static files are identified using the UI descriptor, [.path]_ui.yml_, which also must be provided by the supplemental UI.
The UI descriptor is a YAML file that configures certain aspects of the UI.

To create a static file, first create a file in the supplemental UI, typically outside of any of the standard folders.
A good example of a static file is the favicon, [.path]_favicon.ico_, at the root of the site.
Let's assume you have put a favicon in the [.path]_supplemental-ui_ directory.
If you're loading the supplemental UI from a path, add a [.path]_ui.yml_ file with the following contents:

.ui.yml
[,yml]
----
static_files:
- favicon.ico
----

The `static_files` key accepts an array of strings.
Each entry is the relative path to the file within the UI (it should not begin with a forward slash).
Antora will pick up this file, see that that favicon is a static file, and publish it to the root of the site instead of the UI output directory.

If you're defining the supplemental UI as virtual files, you need to add an entry for both the favicon and [.path]_ui.yml_ file.

.antora-playbook.yml
[,yml]
----
ui:
  supplemental_files:
  - path: favicon.ico
    contents: ./supplemental-ui/favicon.ico
  - path: ui.yml
    contents: |
      static_files:
      - favicon.ico
----

WARNING: If the UI bundle contains a [.path]_ui.yml_ file, you will need to replicate its contents when redefining it for the supplemental UI.
That's because the file in the supplemental UI overwrites the file provided by the UI bundle.

Although the supplemental UI provides a convenient way to add static files to the site, you may want to consider using an xref:extend:extensions.adoc[extension] instead.

// /docs/modules/playbook/pages/ui-output-dir.adoc
[[ui-output-dir.adoc]]
= UI Output Directory

[#default]
== Default UI output directory

The UI files are published to a directory labeled with a single underscore, [.path]_++_++_ , located relative to the site's xref:output-dir.adoc[output directory].
For instance, when the site is published to the default site output directory ([.path]_build/site_), and no UI `output_dir` is specified, the UI files are written to [.path]_++build/site/_++_.

[#output-dir-key]
== output_dir key

The `output_dir` key allows you to specify an alternate directory where Antora should publish the UI files.
The path is relative to the root of the published site.

.Relative UI output path
[,yaml]
----
ui:
  bundle:
    url: /home/user/projects/docs-ui/build/ui-bundle-with-themes.zip
    start_path: dark
  output_dir: _/dark
----

In this example, the site will be written to the default destination directory, therefore, the UI files will be published [.path]_++build/site/_/dark++_.

Antora will automatically reconfigure all references to the UI files, regardless of what value you use.
This is thanks in part to the use of the `+{{uiRootPath}}+` placeholder in the UI templates.

In the next example, the site's output directory (`dir`) is specified in addition to the UI output directory.

.Custom site and UI output directories
[,yaml]
----
ui:
  bundle:
    url: /home/user/projects/docs-ui/build/ui-bundle-with-themes.zip
    start_path: dark
  output_dir: _/dark
output:
  dir: ./public
----

The UI files will be published to [.path]_++public/_/dark++_.

// /docs/modules/playbook/pages/ui-default-layout.adoc
[[ui-default-layout.adoc]]
= Default Layout for Pages

[#default]
== Default page layout

Unless the `default_layout` key is specified in the playbook, Antora applies the `default` layout to any page where the `page-layout` attribute isn't set.
The `default` layout corresponds to the [.path]_default.hbs_ file that Antora expects to find in the [.path]_layouts_ directory of the UI bundle.

You can instruct Antora to apply a custom layout to all of the pages in a site with the `default_layout` key.
//A default page layout can be applied to all pages that don't have a layout explicitly assigned in the page header (using the `page-layout` attribute).
//If not specified, this key defaults to the value `default`.

[#default-layout-key]
== default_layout key

The `default_layout` key is mapped to the `ui` key.
It accepts a value that's the stem of a layout file (i.e., the name of the file without the file extension).
The specified layout file is expected to be located in the UI bundle's [.path]_layouts_ directory.

For example, if you want the layout file [.path]_article.hbs_ to be used as the default page layout, you'd set `default_layout` to `article`.

.Default layout value
[,yaml]
----
ui:
  bundle:
    url: ./../docs-ui/build/ui-bundle.zip
  default_layout: article
----

The layout `article` will be applied to every page in the site, except for any page that has the xref:page:page-layout.adoc[page-layout attribute defined in its header].

// /docs/modules/playbook/pages/configure-urls.adoc
[[configure-urls.adoc]]
= URLs Keys

The playbook keys configured under `urls` manage the site's published URLs and redirects.

[#urls-key]
== urls key

The global properties of your site's published URLs and redirect facility are defined under the `urls` key in a playbook file.

[,yaml]
----
urls: # <.>
  html_extension_style: drop # <.>
  redirect_facility: nginx # <.>
  latest_version_segment_strategy: redirect:to # <.>
  latest_version_segment: stable # <.>
  latest_prerelease_version_segment: unstable # <.>
----
<.> Optional `urls` key
<.> Optional `html_extension_style` key
<.> Optional `redirect_facility` key
<.> Optional `latest_version_segment_strategy` key
<.> Optional `latest_version_segment` key
<.> Optional `latest_prerelease_version_segment` key

Antora uses the default values for the `html_extension_style` and `redirect_facility` keys if they're not specified.
The `html_extension_style` and `redirect_facility` keys are also configurable from the xref:cli:options.adoc[Antora CLI].

[#urls-reference]
== Available urls keys

[cols="3,6,1"]
|===
|URLs Keys |Description |Required

|xref:urls-html-extension-style.adoc[html_extension_style]
|Specifies the user-facing URL extension used for HTML pages.
Accepts the values `default`, `drop`, and `indexify`.
|No

|xref:urls-latest-prerelease-version-segment.adoc[latest_prerelease_version_segment]
|Symbolic prerelease version that Antora uses to replace the actual version in the version segment of page and asset URLs.
Only applies to the latest prerelease component version.
|No

|xref:urls-latest-version-segment.adoc[latest_version_segment]
|Symbolic version that Antora uses to replace the actual version in the version segment of page and asset URLs.
Only applies to the latest component version.
|No

|xref:urls-latest-version-segment-strategy.adoc[latest_version_segment_strategy]
|Controls the replacement and redirect direction between URLs containing the actual version and URLs containing the symbolic version.
Only applies to the latest component version or latest prerelease component version.
Accepts the values `replace`, `redirect:to`, and `redirect:from`.
|No

|xref:urls-redirect-facility.adoc[redirect_facility]
|Specifies whether Antora generates redirects as static HTML refresh pages or redirect configuration files.
Accepts the values `disabled`, `gitlab`, `httpd`, `netlify`, `nginx`, and `static`.
|No
|===

// /docs/modules/playbook/pages/urls-html-extension-style.adoc
[[urls-html-extension-style.adoc]]
= HTML Extension Styles

Antora allows you to customize the file extension used in the URL of HTML pages.
By default, the URL will end with [.ext]_.html_, mirroring the name of the published file.
If you want to "`prettify`" the URL by hiding the extension for SEO or other reasons, you can configure Antora to do so.
You either have the option to drop the extension outright or to replace the extension with forward slash (a technique known as indexify).
When using either of these options, Antora will also drop the last URL segment if the source page is named [.path]_index.adoc_.
This page explains how to control this setting.

[#html-extension-style-key]
== html_extension_style key

The `html_extension_style` key is optional.
It's configured under the xref:configure-urls.adoc[urls key] in a playbook.

.antora-playbook.yml
[,yaml]
----
urls:
  html_extension_style: indexify
----

It accepts the following built-in values:

`default`:: Published page URLs are displayed with the _.html_ extension, i.e., [.path]_\https://base-url.com/component/version/module/my-file.html_.
Antora automatically applies this style when `html_extension_style` isn't set in the playbook or via the CLI.

`indexify`:: The _.html_ extension is dropped and a forward slash (`/`) is appended to the end of the published page URLs, i.e., [.path]_\https://base-url.com/component/version/module/my-file/_.
This is the preferred style if you don't want the _.html_ extension to appear in URLs.

`drop`:: The _.html_ extension is dropped from the end of the published page URLs, i.e., [.path]_\https://base-url.com/component/version/module/my-file_.
This style requires support from the web server and should only be used if you're comfortable applying the necessary web server configuration.

[#default]
== Using the default style

Antora will automatically assign the value `default` to the `html_extension_style` key at runtime if it isn't set in the playbook or in the CLI using the xref:cli:options.adoc#html-extension[--html-url-extension-style option].
The default style appends the _.html_ extension to the end of every published page's URL.
For example, the resulting URL for the page [.path]_my-file.adoc_ would be displayed in a browser with _.html_ appended to the end, i.e., [.path]_\https://base-url.com/component/version/module/my-file.html_.

[#indexify-style]
== Apply the indexify style

Let's assign `indexify` to the `html_extension_style` key.

.antora-playbook.yml
[,yaml]
----
site:
  title: Site Title
  url: https://example.org
urls:
  html_extension_style: indexify
----

When `indexify` is applied, the site's published URLs don't end with the extension _.html_.
Instead, a forward slash (`/`) is appended directly to the end of the page stem.
This results in the URL for the page [.path]_my-file.adoc_ to be displayed in a browser as [.path]_\https://example.com/component/version/module/my-file/_.

To locally preview all the features of a site, such as redirects and the 404 page, when `html_extension_style` is assigned `indexify`, you'll need to xref:ROOT:preview-site.adoc[run a local server].

[#drop-style]
== Apply the drop style

Let's assign `drop` to the `html_extension_style` key.

.antora-playbook.yml
[,yaml]
----
site:
  title: Site Title
  url: https://example.org
urls:
  html_extension_style: drop
----

When `drop` is applied, the site's published URLs don't end with the extension _.html_.
This results in the URL for the page [.path]_my-file.adoc_ to be displayed in a browser as [.path]_\https://example.com/component/version/module/my-file_.
In order for the site to work properly when using this style, you must view the site through a web server.
You also need to configure the web server to look for a file with the _.html_ extension.

WARNING: Not all web servers have the ability to support extensionless HTML URLs.

If you're using nginx, you need to add the following directive to the `location /` stanza in the configuration for your host:

[,nginx]
----
location / {
  # ...
  try_files $uri $uri.html $uri/index.html = 404;
}
----

This directive tells nginx to first look for the requested file, then look for the same file with the _.html_ extension added, then look for a file named [.path]_index.html_ in a directory that matches the requested file.
These attempts match the layout of the published files.

// /docs/modules/playbook/pages/urls-latest-version-segment.adoc
[[urls-latest-version-segment.adoc]]
= Latest Version Segment

The `latest_version_segment` key replaces the actual version with the symbolic version in the published URLs of the latest component versions.
As the key's name implies, it only applies to the latest version of each component version in a site.

[#key]
== latest_version_segment key

The `latest_version_segment` key is configured in the playbook under the `urls` key.

.antora-playbook.yml
[#ex-replace,yaml]
----
urls: # <.>
  latest_version_segment: current # <.>
----
<.> Type the parent key `urls`, followed by a colon (`:`), and press kbd:[Enter] to go to a new line.
<.> The `latest_version_segment` key must be nested under the `urls` key.
Type `latest_version_segment`, followed by a colon (`:`), and then type the symbolic version value.

The value assigned to the `latest_version_segment` key is the [[symbolic]][.term]*symbolic version*.
Antora replaces the xref:ROOT:version-facets.adoc#actual[actual version] in the version segment of a URL with the symbolic version.
The symbolic version is only applied to the URLs of pages and assets that belong to the xref:ROOT:how-component-versions-are-sorted.adoc[latest version of a component].
Depending on the strategy assigned to the xref:urls-latest-version-segment-strategy.adoc[latest_version_segment_strategy key], Antora may apply additional redirect rules when routing to or from symbolic and actual version URLs.

=== Value requirements

The same requirements that apply to the value of the `version` key also apply to the `latest_version_segment` key.
The value can contain letters, numbers, periods (`.`), underscores (`+_+`), and hyphens (`-`).
To ensure portability between host platforms, use lowercase letters.

The value of the `latest_version_segment` key *cannot* contain spaces, forward slashes (`/`), or HTML special characters (`&`, `<`, or `>`).
The value cannot be `null` (which also means it cannot be missing or `~`).
The value can only be an empty string if the value of `latest_version_segment_strategy` is `redirect:to` or `replace`.
The value *cannot* be an empty string if the value of `latest_version_segment_strategy` is `redirect:from`.
This restriction is due to the fact that adding a redirect on the parent folder could prevent access to other versions.

== Specify a latest version segment

This section explores the results of assigning a <<symbolic,symbolic version>> to the `latest_version_segment` key.
The examples in this section use the component versions defined by the component version descriptor files shown in <<ex-actual>> and <<ex-latest>>.
<<ex-actual>> defines a component version with the name `colorado` and version `5.2`.

.Component version descriptor (antora.yml file) defining the colorado 5.2 component version
[#ex-actual,yaml]
----
name: colorado
version: '5.2' # <.>
----
<.> The `version` key in [.path]_antora.yml_ defines the component's actual version as `5.2`.

<<ex-latest>> defines a component version with the name `colorado` and version `5.6`.

.Component version descriptor (antora.yml file) defining the colorado 5.6 component version
[#ex-latest,yaml]
----
name: colorado
version: '5.6' # <.>
----
<.> The `version` key in [.path]_antora.yml_ defines the component's actual version as `5.6`.

Both component versions have a page named [.path]_tour.adoc_ that belongs to the module _get-started_.

First, let's review the URLs Antora makes by default.
That is, when the `latest_version_segment` key isn't set in the playbook.
<<ex-site>> specifies the site URL, assigned to the `url` key, that Antora uses when building absolute URLs and when the URLs are displayed in a browser address bar.

.Playbook (antora-playbook.yml file) showing site url value
[#ex-site,yaml]
----
site:
  title: The Ranges
  url: https://docs.example.com
content:
  # ...
----

Assuming <<ex-actual>> and <<ex-latest>> are the only component versions in the site, Antora identifies _colorado 5.6_ as the latest version of the _colorado_ component.
Antora determines the latest component version and order of versions based on its xref:ROOT:how-component-versions-are-sorted.adoc#version-schemes[semantic and named version sorting rules].
Using information from the playbook and [.path]_antora.yml_ files, Antora constructs the following URLs for the [.path]_tour.adoc_ page in each component version.

As shown in <<result-default>>, the version segment uses the actual version _5.2_ for the [.path]_tour.adoc_ page that belongs to the _colorado 5.2_ component version.

.URL for colorado 5.2 tour.adoc page
[listing#result-default]
----
https://docs.example.com/colorado/5.2/get-started/tour.html
----

In <<result-default-latest>>, the version segment uses the actual version _5.6_ for the [.path]_tour.adoc_ page that belongs to the _colorado 5.6_ component version.

.URL for colorado 5.6 tour.adoc page
[listing#result-default-latest]
----
https://docs.example.com/colorado/5.6/get-started/tour.html
----

While there's nothing in the URL to signify version _5.6_ as the latest version of the component _colorado_, Antora applies the default sorting order in the reference UI, so version _5.6_ is listed first under the _colorado_ component name in the xref:navigation:index.adoc#component-dropdown[component version selector] and first in the listed versions in the xref:navigation:index.adoc#page-dropdown[page version selector].

Now, let's assign a symbolic version to replace the actual version in the page and asset URLs of the latest component versions.
The `latest_version_segment` key is configured in the playbook file, not the component version descriptor files, because it applies to all of the latest component versions in a site.
<<ex-playbook>> shows a truncated playbook file with the `latest_version_segment` key defined.

.Playbook (antora-playbook.yml file) defining a symbolic version
[#ex-playbook,yaml]
----
site:
  title: The Ranges
  url: https://docs.example.com
urls:
  latest_version_segment: stable # <.>
content:
  # ...
----
<.> The `latest_version_segment` is set under the `urls` key and assigned the value `stable`.

Using the component versions defined in <<ex-actual>> and <<ex-latest>> and the playbook in <<ex-playbook>>, Antora constructs the following URLs for the [.path]_tour.adoc_ page in each component version.

In <<result-not-latest>>, the version segment uses the actual version because _colorado 5.2_ isn't the latest version of the _colorado_ component.

.URL for colorado 5.2 tour.adoc page when latest_version_segment is set
[listing#result-not-latest]
----
https://docs.example.com/colorado/5.2/get-started/tour.html
----

However, in <<result-latest>>, the version segment uses the symbolic version, _stable_, because Antora determined _colorado 5.6_ is the latest version of the _colorado_ component.

.URL for colorado 5.6 tour.adoc page when latest_version_segment is set
[listing#result-latest]
----
https://docs.example.com/colorado/stable/get-started/tour.html
----

The actual version, _5.6_, is still displayed in the reference UI menus.
The symbolic version, _stable_, is only used in the URLs.
To customize the value displayed in the reference UI menus, use the xref:ROOT:component-display-version.adoc[display_version key].

If you want to drop the version segment from the URL, you can do so by setting the value to empty string (which is different from no value, which represents `null`).

.Playbook that defines an empty symbolic version
[#ex-playbook-empty,yaml]
----
site:
  title: The Ranges
  url: https://docs.example.com
urls:
  latest_version_segment: '' # <.>
content:
  # ...
----
<.> Set the value of the `latest_version_segment` to empty string to drop the version segment from the URL.

A page in the latest version will now be accessible from a URL that does not include the version segment.

.URL for colorado 5.6 tour.adoc page when latest_version_segment is empty
[listing#result-latest-empty]
----
https://docs.example.com/colorado/get-started/tour.html
----

The version is no longer present in the URL.
The actual version, _5.6_, is still displayed in the reference UI menus.
Recall that you cannot set the `latest_version_segment` to empty string if the `latest_version_segment_strategy` is `redirect:from`.

The examples in this section assumed the `latest_version_segment_strategy` key wasn't set.
Therefore, when Antora detected the `latest_version_segment` key, it automatically set the `latest_version_segment_strategy` key and assigned it the `replace` strategy at runtime.
See xref:urls-latest-version-segment-strategy.adoc[] to learn how the `redirect:to` and `redirect:from` strategies work with the `latest_version_segment` key.

// /docs/modules/playbook/pages/urls-latest-prerelease-version-segment.adoc
[[urls-latest-prerelease-version-segment.adoc]]
= Latest Prerelease Version Segment

The `latest_prerelease_version_segment` key replaces the actual version in the URL of resources in the latest prerelease with a symbolic prerelease version.

WARNING: In order for a version be classified as a prerelease, the component must also have at least one non-prerelease version.
If a component only has prerelease versions, the latest version is not classified as a prerelease even if the `prerelease` key is set in the component descriptor.
When a component only has prerelease versions, then the value of the `latest_version_segment` is used instead.
This behavior may change in the future.

[#key]
== latest_prerelease_version_segment key

The `latest_prerelease_version_segment` key is configured in the playbook under the `urls` key.

.antora-playbook.yml
[#ex-replace,yaml]
----
urls:
  latest_prerelease_version_segment: unstable
----

The value assigned to the `latest_prerelease_version_segment` key is the [[symbolic]][.term]*symbolic prerelease version*.
Antora replaces the xref:ROOT:version-facets.adoc#actual[actual version] in the version segment of the latest prerelease component versions`' URLs with the symbolic prerelease version.
A component version must be xref:ROOT:component-prerelease.adoc[designated as a prerelease] and Antora must determine that it is the xref:ROOT:how-component-versions-are-sorted.adoc[latest prerelease of a component] for the value assigned to the `latest_prerelease_version_segment` key to be applied to its page and asset URLs.
Depending on the strategy assigned to the xref:urls-latest-version-segment-strategy.adoc[latest_version_segment_strategy key], Antora may apply additional redirect rules when routing to or from symbolic and actual version URLs.

=== Value requirements

The same requirements that apply to the value of the `version` key also apply to the `latest_prerelease_version_segment` key.
The value can contain letters, numbers, periods (`.`), underscores (`+_+`), and hyphens (`-`).
To ensure portability between host platforms, use lowercase letters.

The value of the `latest_prerelease_version_segment` key *cannot* contain spaces, forward slashes (`/`), or HTML special characters (`&`, `<`, or `>`).
The value can only be empty if the value of `latest_version_segment_strategy` is `redirect:to` or `replace`.
The value *cannot* be empty if the value of `latest_version_segment_strategy` is `redirect:from`.
This restriction is due to the fact that redirecting from the parent folder could prevent access to other versions.

== Specify a latest prerelease version segment

This section explores the results of assigning a symbolic prerelease version to the `latest_prerelease_version_segment` key.
The examples in this section use the component version defined by the component version descriptor file shown in <<ex-actual>>.
<<ex-actual>> defines a component version with the name `colorado` and version `6.0`.

.Component version descriptor (antora.yml file) defining the colorado 6.0 component version
[#ex-actual,yaml]
----
name: colorado
version: '6.0' # <.>
prerelease: -beta.2 # <.>
----
<.> The `version` key in [.path]_antora.yml_ defines the component's actual version as `6.0`.
<.> The `prerelease` key and assigned identifier, `-beta.2`, informs Antora that the component version is a prerelease.

The _colorado 6.0_ component version has a page named [.path]_tour.adoc_ that belongs to the module _get-started_.
First, let's review the URL Antora makes by default.
That is, when the `latest_prerelease_version_segment` key isn't set in the playbook.
By default, Antora uses the actual version in the version segment of page and asset URLs, even when the component version is a xref:ROOT:component-prerelease.adoc#identifier[prerelease with an identifier].
<<result-default>> shows the default URL for the [.path]_tour.adoc_ page that belongs to the `colorado 6.0` component version.

.URL for colorado 6.0 tour.adoc page
[listing#result-default]
----
https://docs.example.com/colorado/6.0/get-started/tour.html
----

Now, let's assign a symbolic prerelease version to the latest prerelease component versions in this site.
The `latest_prerelease_version_segment` key is configured in the playbook file, not the component version descriptor files, because it applies to all of the latest prerelease component versions in a site.
<<ex-playbook>> shows a truncated playbook file with the `latest_prerelease_version_segment` key defined.

.Playbook (antora-playbook.yml file) defining a symbolic prerelease version
[#ex-playbook,yaml]
----
site:
  title: The Ranges
  url: https://docs.example.com
urls:
  latest_prerelease_version_segment: next # <.>
content:
  # ...
----
<.> The `latest_prerelease_version_segment` is set under the `urls` key and assigned the value `next`.

Let's assume that, according to its xref:ROOT:how-component-versions-are-sorted.adoc#version-schemes[semantic and named version sorting rules], Antora determines that _colorado 6.0_ is the latest prerelease version of the _colorado_ component.
Using information from the playbook and the component version's [.path]_antora.yml_ file, Antora constructs the following URL for the [.path]_tour.adoc_ page.

Now, in <<result-latest>>, the version segment contains the symbolic prerelease version, _next_.

.URL for colorado 6.0 tour.adoc page when latest_prerelease_version_segment is set
[listing#result-latest]
----
https://docs.example.com/colorado/next/get-started/tour.html
----

The actual version with appended prerelease identifier, _6.0-beta.2_, is still displayed in the reference UI menus.
The symbolic prerelease version, _next_, is only used in the URLs.
To customize the value displayed in the reference UI menus, use the xref:ROOT:component-display-version.adoc[display_version key].

The examples in this section assumed the `latest_version_segment_strategy` key wasn't set.
Therefore, when Antora detected the `latest_prerelease_version_segment` key, it automatically set the `latest_version_segment_strategy` key and assigned it the `replace` strategy at runtime.
See xref:urls-latest-version-segment-strategy.adoc[] to learn how the `redirect:to` and `redirect:from` strategies work with the `latest_prerelease_version_segment` key.

// /docs/modules/playbook/pages/urls-latest-version-segment-strategy.adoc
[[urls-latest-version-segment-strategy.adoc]]
= Latest Version Segment Strategy

The `latest_version_segment_strategy` key controls the replacement and redirect direction between publishable URLs containing the actual version and URLs containing the symbolic version.
As the key's name implies, the selected strategy only applies to the latest version or latest prerelease version of a component version.

[#key]
== latest_version_segment_strategy key

The `latest_version_segment_strategy` key is optional.
It's configured under the xref:configure-urls.adoc[urls key] in the playbook.
The xref:urls-latest-version-segment.adoc[latest_version_segment key] or xref:urls-latest-prerelease-version-segment.adoc[latest_prerelease_version_segment key] must be set as well, otherwise Antora deactivates the specified strategy as there isn't a symbolic version to replace the actual version with in the URLs.
The specified strategy and symbolic version are only applied to the xref:ROOT:how-component-versions-are-sorted.adoc[latest version or latest prerelease version of each component] in your site.
The URLs for all other component versions use the actual version in the version segment of the URL.

.antora-playbook.yml
[,yaml]
----
urls: # <.>
  latest_version_segment_strategy: redirect:to # <.>
  latest_prerelease_version_segment: next # <.>
----
<.> Type the parent key `urls`, followed by a colon (`:`), and press kbd:[Enter] to go to a new line.
<.> The `latest_version_segment_strategy` key must be nested under the `urls` key.
Type `latest_version_segment_strategy`, followed by a colon and a space (`:{sp}`), then type the built-in strategy value you want Antora to use, and press kbd:[Enter].
This example uses the value `redirect:to`.
<.> Type `latest_prerelease_version_segment`, followed by a colon and a space (`:{sp}`), and then type your symbolic version value.
This example uses the symbolic version `next` for the latest prerelease version segment.

The `latest_version_segment_strategy` key accepts the following built-in values:

`redirect:from`:: Sets up redirects from the URLs using the symbolic version to the URLs using the actual version, which may be empty.
The actual version is replaced by the symbolic version specified by the `latest_version_segment` key or `latest_prerelease_version_segment` key in the latest component versions`' page and asset URLs.
This strategy is currently ignored when the redirect facility is `static`.

`redirect:to`:: Sets up redirects from the URLs using the non-emtpy actual version to the URLs using the symbolic version.
The actual version is replaced by the symbolic version specified by the `latest_version_segment` key or `latest_prerelease_version_segment` key in the latest component versions`' page and asset URLs.
No change is made to the URL if the version is empty.
This strategy is transparently changed to `replace` when the redirect facility is `static`.

`replace`:: _Default_.
The non-empty actual version is replaced by the symbolic version specified by the `latest_version_segment` key or `latest_prerelease_version_segment` key in the latest component versions`' page and asset URLs.
`replace` is the default value when the `latest_version_segment_strategy` key isn't set, but the `latest_version_segment` key or `latest_prerelease_version_segment` key is assigned a value in the playbook.
No change is made to the URL if the version is empty.

Antora creates temporary redirects (302) when the strategy is `redirect:to` or `redirect:from`.
The format of the rules and redirect configuration file is determined by the xref:urls-redirect-facility.adoc[redirect facility] you specify using the `redirect_facility` key.
Note that when the `redirect_facility` key isn't defined in the playbook or CLI, Antora assigns the xref:urls-redirect-facility.adoc#static-value[static value] to the key at runtime.
Since creating temporary redirect rules is only something a web server can do, when using the static redirect facility, the `redirect:from` strategy is ignored and the `redirect:to` strategy effectively becomes the `replace` strategy.

If the value of `latest_version_segment_strategy` key is `redirect:from`, the value of the `latest_version_segment` and `latest_prerelease_version_segment` *cannot* be empty.
This restriction is due to the fact that redirecting from the parent folder could prevent access to other versions.
For the same reason, the `redirect:to` and `replace` strategies have no affect if the actual version is empty.

[#default]
== Enable the replace strategy automatically

When `replace` is your preferred strategy, you don't need to set the `latest_version_segment_strategy` key as long as you assign a value to the `latest_version_segment` key or `latest_prerelease_version_segment` key in the playbook.

.Use replace by default at runtime
[#ex-replace,yaml]
----
  # ...
urls:
  latest_version_segment: stable
content:
  # ...
----

When Antora reads the playbook in <<ex-replace>> and detects that the xref:urls-latest-version-segment.adoc[latest_version_segment key] is set and assigned a value but that the `latest_version_segment_strategy` key isn't, Antora automatically sets `latest_version_segment_strategy` and assigns it `replace` at runtime.
Likewise, if only the xref:urls-latest-prerelease-version-segment.adoc[latest_prerelease_version_segment key] is set and assigned a value, Antora automatically sets `latest_version_segment_strategy` and assigns it `replace` at runtime.

[#redirect-to]
== Redirect to the symbolic version URLs

This section explores the results of using the `redirect:to` strategy to redirect the URLs using the actual version of the latest component versions to the URLs using the symbolic version.
The examples in this section use the component versions defined by the component version descriptor files shown in <<ex-actual>> and <<ex-latest>>.
<<ex-actual>> defines a component version with the component name `colorado` and the version `5.2`.

.Component version descriptor (antora.yml file) defining the colorado 5.2 component version
[#ex-actual,yaml]
----
name: colorado
version: '5.2' # <.>
----
<.> The `version` key in [.path]_antora.yml_ defines the component's actual version as `5.2`.

<<ex-latest>> defines a component version with the name `colorado` and the version `5.6`.

.Component version descriptor (antora.yml file) defining the colorado 5.6 component version
[#ex-latest,yaml]
----
name: colorado
version: '5.6' # <.>
----
<.> The `version` key in [.path]_antora.yml_ defines the component's actual version as `5.6`.

Both component versions have a page named [.path]_tour.adoc_ that belongs to the module _get-started_.

Now, let's assign a latest version segment strategy and a latest version URL segment to the latest component versions.
This information is provided to Antora using your site's playbook file.
The `latest_version_segment_strategy` and `latest_version_segment` keys are configured in the playbook file (not the component version descriptor file) under the `urls` key.
<<ex-playbook>> shows these keys defined in a playbook file.

.Playbook (antora-playbook.yml file) defining a latest version segment strategy
[#ex-playbook,yaml]
----
site:
  title: The Ranges
  url: https://docs.example.com
urls:
  latest_version_segment_strategy: redirect:to # <.>
  latest_version_segment: current # <.>
  redirect_facility: nginx # <.>
content:
# ...
----
<.> Antora will use the `redirect:to` strategy when generating the redirect rules for the latest component version URLs.
<.> Antora will replace the actual version with the symbolic version, `current`, in the URLs of the latest component versions.
<.> Antora will generate an nginx redirect file and place it at the root of the generated site at [.path]_.etc/nginx/rewrite.conf_.

Assuming <<ex-actual>> and <<ex-latest>> are the only component versions in the site, Antora identifies _colorado 5.6_ as the latest version of the _colorado_ component.
Antora determines the latest component version and order of versions based on its xref:ROOT:how-component-versions-are-sorted.adoc#version-schemes[semantic and named version sorting rules].

As shown in <<result-not-latest>>, the version segment uses the actual version because _colorado 5.2_ isn't the latest version of the _colorado_ component.

.URL for colorado 5.2 tour.adoc page
[listing#result-not-latest]
----
https://docs.example.com/colorado/5.2/get-started/tour.html
----

However, in <<result-latest>>, the version segment uses the symbolic version, _current_, because _colorado 5.6_ is the latest version of the _colorado_ component.

.URL for colorado 5.6 tour.adoc page
[listing#result-latest]
----
https://docs.example.com/colorado/current/get-started/tour.html
----

In addition to replacing the actual version with the symbolic version in the URLs of the latest component versions, Antora creates temporary redirects from the URLs using the actual version to the URLs using the symbolic version.
The playbook in <<ex-playbook>> assigns the xref:urls-redirect-facility.adoc#nginx[nginx value] to the `redirect_facility` key, therefore Antora writes the redirect rules to an nginx rewrite configuration file named [.path]_rewrite.conf_ and places it in the site at [.path]_.etc/nginx/rewrite.conf_.
Any request for a URL using the actual version of a latest component version, as long as the version is not empty, is redirected to the URL with the symbolic version.
For example, if the URL _\https://docs.example.com/colorado/5.6/get-started/tour.html_ is requested, the URL redirects to _\https://docs.example.com/colorado/current/get-started/tour.html_.

=== What happens when a new component version is added to the site?

Continuing the scenario presented in the <<redirect-to,previous section>>, let's explore what happens when a new component version is added to the site.
<<ex-new>> defines a component version with the name `colorado` and the actual version `6.0`.

.Component version descriptor (antora.yml file) defining the colorado 6.0 component version
[#ex-new,yaml]
----
name: colorado
version: '6.0'
----

The site uses the same playbook in <<ex-playbook>>.
During generation, Antora determines that highest version of the _colorado_ component is version _6.0_, therefore _colorado 6.0_ becomes the latest version of the _colorado_ component.
Using the component versions defined in <<ex-actual>> (_colorado 5.2_), <<ex-latest>> (_colorado 5.6_), <<ex-new>> (_colorado 6.0_), and the playbook in <<ex-playbook>>, Antora constructs the following URLs for the [.path]_tour.adoc_ page in each component version.

<<result-oldest>> shows that the [.path]_tour.adoc_ page URL in the component version _colorado 5.2_ remains the same.

.URL for colorado 5.2 tour.adoc page
[listing#result-oldest]
----
https://docs.example.com/colorado/5.2/get-started/tour.html
----

Unlike the <<result-latest,URL for colorado 5.6 in the previous section>>, <<result-old>> shows that the version segment for [.path]_tour.adoc_ now contains the actual version because _colorado 5.6_ is no longer the latest version of the _colorado_ component.

.URL for colorado 5.6 tour.adoc page
[listing#result-old]
----
https://docs.example.com/colorado/5.6/get-started/tour.html
----

Nor does Antora set up temporary redirects from URLs with _5.6_ to URLs with _current_.
A request for _\https://docs.example.com/colorado/5.6/get-started/tour.html_ is served exactly as requested.

In <<result-new>>, the version segment uses the symbolic version, _current_, because _colorado 6.0_ is the latest version of the _colorado_ component.

.URL for colorado 6.0 tour.adoc page
[listing#result-new]
----
https://docs.example.com/colorado/current/get-started/tour.html
----

Antora sets up new temporary redirects for URLs using the actual version of the latest component version, `6.0`, and redirects them to URLs with the symbolic version.
For example, if the URL _\https://docs.example.com/colorado/6.0/get-started/tour.html_ is requested, the URL redirects to _\https://docs.example.com/colorado/current/get-started/tour.html_.

// /docs/modules/playbook/pages/urls-redirect-facility.adoc
[[urls-redirect-facility.adoc]]
= Redirect Facility Key
:page-aliases: configure-redirect-facility.adoc
:url-netlify-redirects: https://docs.netlify.com/routing/redirects/
:url-nginx-rewrites: https://nginx.org/en/docs/http/ngx_http_rewrite_module.html#return
:url-htaccess: https://httpd.apache.org/docs/current/howto/htaccess.html
:url-meta-tag: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta

Antora sets up automatic routing for start pages, symbolic latest versions, and page aliases according to the redirect facility you have specified.

By default, Antora generates a static HTML file for each URL alias to redirect the visitor to the target page.
Antora also has the ability to generate web server-specific configuration files that leverage the web server's redirect/rewrite facility to handle the routing instead.

IMPORTANT: Antora won't generate any redirect files (e.g., [.path]_++_redirects++_) if the site does not define any redirects.

Antora derives these URL routes from the site and component version start pages, latest version aliases, and xref:page:page-aliases.adoc[page aliases] defined using the `page-aliases` attribute.
For page aliases, the xref:page:page-aliases.adoc#target-page[target page] is the page to which the source page is redirected.
The target page is also where page aliases are defined.
The xref:page:page-aliases.adoc#source-page[source page] is the alias page that's being redirected (i.e., the claimed page).

[#redirect-facility-key]
== redirect_facility key and its values

The playbook key `redirect_facility` is optional.
It can be configured in the playbook or via the xref:cli:options.adoc#redirect-facility[CLI] and accepts one of the following built-in values:

disabled::
No redirect files are generated.
If the site does not define any redirects, this becomes the effective value.
gitlab::
A redirect file for GitLab Pages named [.path]_++_redirects++_ is generated and placed at the root of the published site.
httpd::
A redirect file for Apache httpd named [.path]_.htaccess_ is generated and placed at the root of the published site.
netlify::
A redirect file for Netlify named [.path]_++_redirects++_ is generated and placed at the root of the published site.
nginx::
A redirect file for nginx named [.path]_rewrite.conf_ is generated and placed at the location [.path]_.etc/nginx/rewrite.conf_ in the published site.
+
CAUTION: By default, nginx will not know to look for the file in this location.
You either need to move it to where nginx can find it or configure nginx to use it at this location.
[[static-value]]static::
(default) A static HTML file with the `http-equiv` meta element set to `refresh` is generated at the source page's URL.
The file provides a redirect notice and routes the source page URL to the target page URL.

Antora automatically assigns the value `static` to the `redirect_facility` key unless you explicitly configure it.

=== Configure the redirect facility from the playbook

The `redirect_facility` key is configured in the playbook under the `urls` key.

.antora-playbook.yml
[,yaml]
----
urls:
  redirect_facility: netlify
----

=== Configure the redirect facility from the CLI

The `redirect_facility` key can also be configured from the xref:cli:options.adoc[CLI].

 $ antora --redirect-facility netlify antora-playbook.yml

The CLI option overrides the value specified in the playbook.

== Choosing a redirect facility configuration

How your site's URL redirects should be configured depends on the web server or service you use to serve your site.

If you use the default redirect facility, Antora will generate HTML pages that use the meta refresh feature of HTML to route the visitor to the target page (i.e., bounce page).
When you inspect the output of your site, you will find pages that end with [.ext]_.html_ that include a `<meta http-equiv="refresh">` tag inside a minimal HTML structure.
If you have specified a start page for your site, this will include a [.path]_index.html_ page at the root of your published site.

If you use any other redirect facility, Antora will not generate these bounce pages.
(In other words, don't expect to find the [.path]_index.html_ page at the root of your published site).
Instead, Antora relies on the web server to apply the redirect rules that it generates.
For details about these rules and where they are written, see the sections below.

Redirect rules for start pages and page aliases are defined using the 301 HTTP status code, which means the redirect is considered permanent.
Redirect rules for the latest version aliases are defined using the 302 HTTP status code, which means the redirect is considered temporary.

The locations in the web server-specific redirect/rewrite rules match the URL of the pages as they are accessed in the site, and thus depend on the value of the xref:urls-html-extension-style.adoc[urls.html-extension-style] key.
By default, locations will end with _.html_.
If the HTML URL extension style is changed to _indexify_, the locations will end with _/_.

[#netlify]
=== Netlify

{url-netlify-redirects}[Redirect rules for sites served by Netlify] are configured in a plain text file named [.path]_++_redirects++_.
When the assigned redirect facility value is `netlify`, Antora generates the [.path]_++_redirects++_ file and places it at the root of the generated site.

._redirects file for Netlify generated by Antora
[listing]
----
/index.html /component/version/index.html 301!
/ /component/version/index.html 301!
/component/version/module/old-name.html /component/version/module/new-name.html 301!
----

The example output above shows redirect rules for two scenarios.
The first scenario, which is handled by the first two rules, routes the user from the root domain to the URL of the site start page using a 301 HTTP status code.
The second scenario, which is handled by the last rule, routes the user from the URL of a renamed page to its new URL using a 301 HTTP status code.

[#gitlab]
=== GitLab

{url-netlify-redirects}[Redirect rules for sites served by GitLab Pages] are configured in a plain text file named [.path]_++_redirects++_.
The format of this file is a modified version of the one for Netlify.
When the assigned redirect facility value is `gitlab`, Antora generates the [.path]_++_redirects++_ file and places it at the root of the generated site.

._redirects file for GitLab Pages generated by Antora
[listing]
----
/index.html /component/version/index.html 301
/ /component/version/index.html 301
/component/version/module/old-name.html /component/version/module/new-name.html 301 <1>
----
<1> Unlike the redirect file for the `netlify` redirect facility, the rule does not end with `!`.

The example output above shows redirect rules for two scenarios.
The first scenario, which is handled by the first two rules, routes the user from the root domain to the URL of the site start page using a 301 HTTP status code.
The second scenario, which is handled by the last rule, routes the user from the URL of a renamed page to its new URL using a 301 HTTP status code.

[#nginx]
=== nginx

Antora generates an {url-nginx-rewrites}[nginx rewrite configuration file] named [.path]_rewrite.conf_ and places it in the generated site at [.path]_.etc/nginx/rewrite.conf_.

.nginx rewrite configuration file generated by Antora
[,nginx]
----
location = /index.html { return 301 /component/version/index.html; }
location = /component/version/module/old-name.html { return 301 /component/version/module/new-name.html; }
----

The example output above shows redirect rules for two scenarios.
The first scenario, which is handled by the first rule, routes the user from the root domain to the URL of the site start page using a 301 HTTP status code.
The second scenario, which is handled by the last rule, routes the user from the URL of a renamed page to its new URL using a 301 HTTP status code.

When using the nginx redirect facility, Antora assumes that nginx is configured in a way similar to the configuration shown in <<ex-nginx-conf>>.
The path [.path]_/srv/www_ refers to the location of the generated site.

.nginx configuration that loads the rewrite configuration generated by Antora
[#ex-nginx-conf,nginx]
----
server {
  listen       80;
  server_name  _;
  root         /srv/www;

  location = /.etc/nginx/rewrite.conf {
    deny    all;
    return  404;
  }

  include /srv/www/.etc/nginx/rewrite.conf;

  location / {
      index  index.html;
      # uncomment the next line if using --html-url-extension-style=drop
      #try_files $uri $uri.html $uri/index.html = 404;
  }

  error_page  404  /404.html;
}
----

Adjust the configuration if your site is accessible from a different hostname or port or is served from a different root.

[#httpd]
=== httpd

Antora generates an {url-htaccess}[.htaccess] file containing redirect rules and places it at the root of the generated site.

..htaccess file generated by Antora
[,nginx]
----
Redirect 301 /index.html /component/version/index.html
Redirect 301 /component/version/module/old-name.html /component/version/module/new-name.html
----

The example output above shows redirect rules for two scenarios.
The first scenario, which is handled by the first rule, routes the user from the root domain to the URL of the site start page using a 301 HTTP status code.
The second scenario, which is handled by the last rule, routes the user from the URL of a renamed page to its new URL using a 301 HTTP status code.

When using the httpd redirect facility, Antora assumes that Apache httpd is configured to load the [.path]_.htaccess_ file at the root of the hosted site.

[#static]
=== Static (meta refresh)

The `static` redirect value is useful for sites deployed on services, such as GitLab Pages and GitHub Pages, that don't accept or provide access to URL redirection configuration files.
This setting is also helpful when you build a site on your local machine to test your start pages and page aliases.

Antora generates a static https://en.wikipedia.org/wiki/Meta_refresh[meta refresh] page for each aliased source page that redirects a visitor to the corresponding target page.
Each refresh page contains:

. The canonical URL of the xref:page:page-aliases.adoc#target-page[target page].
. The `http-equiv` meta attribute assigned the value `refresh`.
. The `content` meta attribute assigned the value `0` and the URL of the relative target page that the visitor will be redirected to.
The `0` indicates that the visitor will be redirected to the target page in 0 seconds.
. A redirect notice, letting the visitor know that the xref:page:page-aliases.adoc#source-page[source page] no longer exists and providing a link to the target page.

.Static meta refresh page for old-name.html that redirects to new-name.html
[,html]
----
<!DOCTYPE html>
<meta charset="utf-8">
<link rel="canonical" href="https://base-url.com/component/version/module/new-name.html">
<script>location="new-name.html"</script>
<meta http-equiv="refresh" content="0; url=new-name.html">
<meta name="robots" content="noindex">
<title>Redirect Notice</title>
<h1>Redirect Notice</h1>
<p>The page you requested has been relocated to <a href="new-name.html">https://base-url.com/component/version/module/new-name.html</a>.</p>
----

// /docs/modules/playbook/pages/configure-output.adoc
[[configure-output.adoc]]
= Output Keys

The playbook keys configured under `output` define where the site files are written and control how they're processed.

[#output-key]
== output key

The `output` key contains common output settings and a list of destination specifications.

.antora-playbook.yml
[,yaml]
----
output: # <.>
  clean: true # <.>
  dir: ./public # <.>
  destinations: # <.>
  - provider: archive # <.>
    path: ./public/blue.zip # <.>
----
<.> Optional `output` key
<.> Optional `clean` key
<.> Optional `dir` key
<.> Optional `destinations` key
<.> Optional `provider` key
<.> Optional `path` key

The `output` key and the key-value pairs it can accept are optional.
When `output` isn't set in a playbook, Antora uses the `fs` provider and publishes the site to the output directory [.path]_build/site_ by default.

[#destinations-key]
== destinations and provider keys

The `output` key accepts the `destinations` key and its nested list of key-value pairs.
The `destinations` key is required when you want to xref:output-provider-archive.adoc[publish the site files as an archive], use a xref:output-provider-custom.adoc[custom provider], or publish a site to xref:output-provider-fs.adoc#publish-to-multiple-destinations[multiple destinations].

The `destinations` key accepts a list of specifications that tell Antora which provider(s) to use to publish the site and where the generated files should be saved.
When `destinations` is set, one or more `provider` keys must be defined under it.

A [.term]*provider* determines which transport protocol (local, SSH, HTTP, etc.) Antora should use when publishing the site and manages the low-level details of publication.
Antora has two built-in providers, `fs` (filesystem) and `archive` (ZIP archive).
`provider` is also an extension point that can be used to delegate to a custom provider, such as SSH, S3, etc.

[#disable-publishing]
=== Disable site publishing

To disable publishing the site files entirely, including to the default output directory, set `destinations` to an empty array (`[]`).

[#output-reference]
== Available output keys

[cols="3,6,1"]
|===
|Output Keys |Description |Required

|xref:output-dir.adoc#clean-key[clean], xref:output-provider-fs.adoc#clean-key[destinations++[n]++.clean]
|When set to `true`, the `clean` key removes the output directory or filesystem provider path recursively before generating the site.
|No

|destinations[n].path
|Designates the target location where the output file(s) are written.
See xref:output-provider-fs.adoc[Filesystem provider and path] and xref:output-provider-archive.adoc[Archive provider and path].
|No

|destinations[n].provider
|Specifies the transport protocol Antora uses to publish the site.
Accepts the built-in xref:output-provider-fs.adoc[fs] or xref:output-provider-archive.adoc[archive] values.
xref:output-provider-custom.adoc[Custom providers] can also be specified.
Multiple providers can be specified under `destinations`.
|No

|xref:output-dir.adoc[dir]
|Specifies an output directory when the site is published using the default provider or first `fs` provider specified under `destinations`.
|No
|===

// /docs/modules/playbook/pages/output-dir.adoc
[[output-dir.adoc]]
= Output Directory

The `dir` key specifies the directory where the generated site files are published.
It provides a simpler way to use the default `fs` provider without having to set the more formal `destinations` and `provider` keys.

[#default]
== Default output directory

The default output directory is [.path]_build/site_.
If `dir` isn't set and an `fs` provider `path` isn't specified, the site files are written to this default directory.

[#dir-key]
== dir key

The `dir` key is configured under the xref:configure-output.adoc#output-key[output key] in a playbook.
The `dir` key specifies the directory where the generated site files are published.
It accepts a relative or absolute filesystem path.
include::partial$relative-path-rules.adoc[]

The `dir` key can be used in combination with the xref:configure-output.adoc#destinations-key[destinations key].
If both an `fs` provider `path` and `dir` are specified, the value assigned to `dir` overrides xref:output-provider-fs.adoc#path-key[the first fs provider path].
When the output directory is specified from the CLI using the xref:cli:options.adoc#to-dir[--to-dir option], it also overrides the `dir` and first `fs` provider `path` in a playbook.

[#relative-path]
=== Specify a relative path

In <<ex-rel>>, the site will be published to a folder named [.path]_launch_ relative to the playbook file.

.Assign a relative path to the dir key
[#ex-rel,yaml]
----
output:
  dir: ./launch
----

[#absolute-path]
=== Specify an absolute path

In <<ex-abs>>, the site will be published to [.path]_home/dev/docs-site/beta_, regardless of where the playbook is located.

.Assign an absolute path to the dir key
[#ex-abs,yaml]
----
output:
  dir: /home/dev/docs-site/beta
----

[#clean-key]
== Clean the output directory

The `clean` key is optional and is deactivated (assigned the value `false`) by default.
When it's assigned the value `true` in a playbook, it removes the path assigned to `dir` recursively before generating the site.

.Activate the clean key
[#ex-clean,yaml]
----
output:
  clean: true # <.>
----
<.> `clean` is activated with the value `true` and deactivated with `false`.

This key only applies to the filesystem provider.

[WARNING#clean-warning]
====
Use this key with great care.
For example, if you set `dir` to your [.path]_home_ directory and `clean` to `true`, you'll delete ALL of the folders and files in [.path]_home_.
====

The `clean` key can also be activated via the CLI using the xref:cli:options.adoc#clean[--clean option].

// /docs/modules/playbook/pages/output-provider-archive.adoc
[[output-provider-archive.adoc]]
= Archive Provider
:url-zip-file-format: https://en.wikipedia.org/wiki/Zip_(file_format)

In order to publish a site's files as a ZIP archive, your playbook must set the `output`, `destinations` and `provider` keys.

[#archive-provider]
== archive provider

The `provider` value `archive` publishes a site to a {url-zip-file-format}[ZIP] file.

.antora-playbook.yml
[,yaml]
----
output:
  destinations: # <.>
  - provider: archive # <.>
----
<.> The `provider` key must be configured under the `destinations` key.
<.> Under `destinations`, type a hyphen (`-`) and a blank space, then the key name `provider`, followed by a colon (`:`).
After the colon, enter a blank space, and then the built-in value name `archive`.

Unless the `path` key is specified, the default output target for the `archive` provider is [.path]_build/site.zip_.

[#path-key]
== path key

The optional `path` key designates the target path and filename of the generated ZIP archive.
If `path` isn't specified, Antora uses the default archive path value, [.path]_build/site.zip_.

The `path` key accepts a relative or absolute filesystem path.
The provider will create any interim directories as needed.
include::partial$relative-path-rules.adoc[]

[#relative-path]
=== Specify a relative path

In <<ex-rel>>, the site will be published to
the target file [.path]_blue.zip_ relative to the playbook file.

.Assign a relative path to the path key
[#ex-rel,yaml]
----
output:
  destinations:
  - provider: archive
    path: ./blue.zip
----

[#absolute-path]
=== Specify an absolute path

In <<ex-abs>>, the site will be published to [.path]_/home/user/projects/launch/blue.zip_, regardless of where the playbook is located.

.Assign an absolute path to the path key
[#ex-abs,yaml]
----
output:
  destinations:
  - provider: archive
    path: /home/user/projects/launch/blue.zip
----

// tag::multiple[]
[#publish-to-multiple-destinations]
== Publish to multiple destinations

In <<ex-multiple>>, Antora is running on a playbook file in the [.path]_tmp_ directory and publishing the site to two locations, one relative and one absolute.

.Specify multiple providers
[#ex-multiple,yaml]
----
output:
  destinations:
  - provider: fs
    path: ./releases/red
    clean: true
  - provider: archive
    path: /home/user/projects/docs-site/blue.zip
----

The site files published using the `fs` are written to the directory [.path]_tmp/releases/red_.
This directory will be removed prior to publishing since the `clean` key is assigned `true`.
The site is also published as an archive to [.path]_/home/user/projects/docs-site/blue.zip_ by the `archive` provider.
//end::multiple[]

// /docs/modules/playbook/pages/output-provider-fs.adoc
[[output-provider-fs.adoc]]
= Filesystem Provider

In order to publish a site to multiple  destinations, including one or more filesystem destinations, your playbook must set the `output`, `destinations` and `provider` keys.

[#fs-provider]
== fs provider

The `provider` value `fs` publishes the site to a directory on a filesystem.
It's the formal equivalent to specifying the output directory using the `dir` key.

.antora-playbook.yml
[,yaml]
----
output:
  destinations: # <.>
  - provider: fs # <.>
----
<.> The `provider` key must be configured under the `destinations` key.
<.> Under `destinations`, type a hyphen (`-`) and a blank space, then the key name `provider`, followed by a colon (`:`).
After the colon, enter a blank space, and then the built-in value name `fs`.

Unless the `path` key or xref:output-dir.adoc[dir key] is specified, the default path for the `fs` provider is [.path]_build/site_.

[#path-key]
== path key

The optional `path` key designates the target location where the output files are to be written.
The `fs` provider treats this value as a target directory.

The `path` key accepts a relative or absolute filesystem path.
The provider will create any interim directories as needed.
include::partial$relative-path-rules.adoc[]

If `path` isn't specified, it gets populated with the default value, [.path]_build/site_, or, in the case of the first `fs` provider, the value of `dir`.
When the xref:output-dir.adoc[dir key] is specified, its value is assigned to (or overrides) the first `fs` provider `path`.
When the output directory is specified from the CLI using the xref:cli:options.adoc#to-dir[--to-dir option], it also overrides the first `fs` provider `path` (as well as `dir`) in a playbook.

[#relative-path]
=== Specify a relative path

In <<ex-rel>>, the site will be published to a folder named [.path]_launch_ relative to the playbook file.

.Assign a relative path
[#ex-rel,yaml]
----
output:
  destinations:
  - provider: fs
    path: ./launch
----

[#absolute-path]
=== Specify an absolute path

In <<ex-abs>>, the site will be published to [.path]_home/dev/site/beta_, regardless of where the playbook is located.

.Assign an absolute path
[#ex-abs,yaml]
----
output:
  destinations:
  - provider: fs
    path: /home/dev/site/beta
----

[#clean-key]
=== clean key

The `clean` key is optional and is deactivated (assigned the value `false`) by default.
It can be applied as part of an `fs` provider configuration instead of xref:output-dir.adoc#clean-key[directly under the output key].

.antora-playbook.yml
[,yaml]
----
output:
  destinations:
  - provider: fs
    path: /home/dev/site/beta
    clean: true # <.>
----
<.> `clean` is activated with the value `true` and deactivated with `false`.

When `clean` is assigned the value `true`, it removes the destination `path` recursively before generating the site.
This key only applies to the `fs` provider.

[#clean-warning]
WARNING: Use this key with great care.
For example, if you set `path` to your [.path]_home_ directory and `clean` to `true`, you'll delete ALL of the folders and files in [.path]_home_.

include::page$output-provider-archive.adoc[tag=multiple]

// /docs/modules/playbook/pages/output-provider-custom.adoc
[[output-provider-custom.adoc]]
= Custom Provider

WARNING: The custom provider is an alpha API and subject to change.

== Use a custom output provider

If the `provider` key doesn't specify a recognized built-in provider, Antora will attempt to require it as a Node.js module.
This allows you to supply a custom provider.

If the value begins with a dot (`.`), Antora will require the path relative to the playbook file.
Otherwise, Antora will require the value as a Node.js module installed in the playbook project.

The custom provider is a JavaScript function that matches the following signature:

[,js]
----
async function (destConfig, files, playbook)
----

Here's a template you can use to get started.

.custom-output-provider.js
[,js]
----
'use strict'

module.exports = async function (destConfig, files, playbook) {
  const to = destConfig.path || '_site'
  console.log(`Publishing files to ${to}`)
  for await (const file of files) {
    console.log(`Writing file to ${file.path}`)
  }
  return {}
}
----

The destConfig argument is an object containing key-value pairs that correspond to the properties of the xref:configure-output.adoc#destinations-key[destination specification].
The files argument is a `ReadableStream` of virtual files (use `for await` to iterate over it).
Each file is a `Vinyl` object that contains the properties `contents`, `path`, and `stat`.
The playbook argument is the object containing key-value pairs from the playbook as a whole.

// /docs/modules/playbook/pages/configure-runtime.adoc
[[configure-runtime.adoc]]
= Runtime Keys

The playbook keys configured under the `runtime` key manage Antora's logger, as well as its console output, caching, and remote repository update behavior.

[#runtime-key]
== runtime key

The global log, console output, fetch, and cache directory properties are defined under the `runtime` key in a playbook file.
These settings are applied to the Antora pipeline when it starts.

.antora-playbook.yml
[,yaml]
----
runtime: # <.>
  cache_dir: ./.cache/antora # <.>
  fetch: true # <.>
  log: # <.>
    level: error # <.>
  quiet: true # <.>
----
<.> Optional `runtime` key
<.> Optional `cache_dir` key
<.> Optional `fetch` key
<.> Optional `log` key
<.> Optional `level` key
<.> Optional `quiet` key

The `runtime` key and the key-value pairs it accepts are optional.
If `runtime` isn't set in the playbook, Antora uses the default cache directory, fetch, and log settings.
Alternatively, these keys can be assigned from the xref:cli:options.adoc#generate-options[CLI] or, except for `fetch`, using xref:playbook:environment-variables.adoc[environment variables].

[#log-key]
== log key

The `log` key is optional.
If you do set it in the playbook, you must nest it under the <<runtime-key,runtime key>>.
The `log` key accepts a list of built-in key-value pairs that configure the log level (`level`), failure level (`failure_level`), and display format (`format`).

.antora-playbook.yml
[,yaml]
----
runtime:
  log: # <.>
    format: json # <.>
    failure_level: warn # <.>
    level: all # <.>
    level_format: number # <.>
    destination: # <.>
      file: ./antora.log # <.>
      append: true # <.>
      buffer_size: 4096 # <.>
      sync: false # <.>
----
<.> The optional `log` category key is nested under the `runtime` category key.
<.> The optional `format` key is nested under the `log` category key.
<.> The optional `failure_level` key is nested under the `log` category key.
<.> The optional `level` key is nested under the `log` category key.
<.> The optional `level_format` key is nested under the `log` category key.
<.> The optional `destination` category key is nested under the `log` category key.
<.> The optional `file` key is nested under the `destination` category key.
<.> The optional `append` key is nested under the `destination` category key.
<.> The optional `buffer_size` key is nested under the `destination` category key.
<.> The optional `sync` key is nested under the `destination` category key.

If `level`, `failure_level`, `format`, or `level_format` are set in the playbook, they must be nested under the `log` category key.
The xref:runtime-log-level.adoc#default[level], xref:runtime-log-failure-level.adoc#default[failure_level], xref:runtime-log-format.adoc#default[format], and xref:runtime-log-format.adoc#level-format-key[level_format] keys have default values that are automatically applied when Antora runs if they're not explicitly defined in the playbook or using the corresponding the xref:cli:options.adoc#generate-options[command line options] or xref:playbook:environment-variables.adoc[environment variables].

If `file`, `append`, `buffer_size`, or `sync` are set in the playbook, they must be nested under the `destination` category key.

IMPORTANT: The log settings are not honored if a fatal error is thrown before Antora fully configures the playbook.
In such cases, the error message is only printed directly to standard error (stderr) using a preconfigured logger.

[#quiet-key]
== quiet key

The `quiet` key is optional.
If you do set it in the playbook, you must nest it under the <<runtime-key,runtime key>>.
The `quiet` key accepts a boolean value.
If the value is true, informational messages such as the git progress and build completion message are not written to stdout (i.e., the standard output stream) of the console.
In short, no messages are written directly stdout when this key is set to true.

.antora-playbook.yml
[,yaml]
----
runtime:
  quiet: true # <.>
----
<.> The optional `quiet` key is nested under the `runtime` category key.

This flag does not impact messages written to stderr.
Messages will still be written to the log, which may then be routed to stdout depending on the log configuration.

[#silent-key]
== silent key

The `silent` key is optional.
If you do set it in the playbook, you must nest it under the <<runtime-key,runtime key>>.
The `silent` key accepts a boolean value.
If the value is true, the log level is set to `silent` (and cannot be overridden) and any messages written directly to stdout and stderr are suppressed.
In short, all messages to the console and log are suppressed.

.antora-playbook.yml
[,yaml]
----
runtime:
  silent: true # <.>
----
<.> The optional `silent` key is nested under the `runtime` category key.

You should not expect to see any messages in the console when the value of this key is true.

[#runtime-reference]
== Available runtime keys

[cols="3,6,1"]
|===
|Runtime Keys |Description |Required

|xref:runtime-cache-dir.adoc[cache_dir]
|Specifies the directory where the remote content sources git repositories and UI bundles are cached.
|No

|xref:runtime-fetch.adoc[fetch]
|When set to `true`, the `fetch` key refreshes the files in the cache each time Antora runs.
|No

|xref:runtime-log-failure-level.adoc[log.failure_level]
|Sets the log level tolerance that, when met or exceeded, causes Antora to fail on exit with a non-zero exit code.
Accepts the values `warn`, `error`, `fatal`, and `none`.
The default value is `fatal`.
The value `none` causes Antora to always exit with a zero exit code.
|No

|xref:runtime-log-format.adoc[log.format]
|Sets the format of log messages.
Accepts the values `pretty` and `json`.
The default value is `json` in a CI environment and `pretty` in all other environments.
|No

|xref:runtime-log-level.adoc[log.level]
|Sets the minimum severity threshold level that must be met for a message to be logged.
Accepts the values `all`, `debug`, `info`, `warn`, `error`, `fatal`, and `silent`.
The default value is `warn`.
The value `silent` turns the logger off.
|No

|xref:runtime-log-format.adoc#level-format-key[log.level_format]
|Sets the format of how the log levels are expressed.
Only applies when `log.format` is `json`.
Accepts the values `label` and `number`.
The default value is `label`.
|No

|xref:runtime-log-destination.adoc#file-key[log.destination.file]
|Sets the destination file or stream where log messages are written.
The default value (either `stdout` or `stderr`) depends on the log format.
|No

|xref:runtime-log-destination.adoc#append-key[log.destination.append]
|Configures whether to truncate (i.e., clear) the file before writing to it.
The default value is `false`, which means to truncate the file.
|No

|xref:runtime-log-destination.adoc#buffer-size-key[log.destination.buffer_size]
|Sets the amount of memory to use to buffer log messages.
Once the buffer reaches this size, the buffered messages are written to the destination in a batch.
The default value is `0`, which turns off this behavior.
|No

|xref:runtime-log-destination.adoc#sync-key[log.destination.sync]
|Configures whether to use a sync or async operation to write log messages to the destination.
The default value is `true`, which means log messages are written synchronously (blocking).
|No

|quiet
|Prevents any messages from being written to stdout.
The default value is `false` (messages are written to stdout).
|No

|silent
|Suppresses all messages, including log messages (by forcefully setting the log level to silent).
The default value is `false`.
|No
|===

// /docs/modules/playbook/pages/runtime-log-level.adoc
[[runtime-log-level.adoc]]
= Log Severity Level

The log `level` key specifies a severity threshold, such as `debug` or `error`, that must be met for a message to be logged.

[#default]
== Default log level

Explicitly assigning a value to the `level` key is optional.
If it isn't set in your playbook or specified using the <<level-option,--log-level option>> or xref:playbook:environment-variables.adoc#log-level[ANTORA_LOG_LEVEL variable], Antora assigns the value `warn` to the key at runtime.
When the default value is applied, all messages that meet or exceed the `warn` threshold are logged.

[#level-key]
== level key

The `level` key is configured under the xref:configure-runtime.adoc[runtime and log] keys in a playbook.

.antora-playbook.yml
[,yaml]
----
runtime:
  log:
    level: error
----

[#severity-levels]
The `level` key accepts the following built-in values:

fatal:: Catastrophic errors that force Antora to shut down abruptly.
Your site was not generated.
+
NOTE: If a fatal error is thrown before Antora configures the playbook, Antora only prints the message to standard error (STERR).
The error message isn't routed through the logger as configured by the user.

error:: Serious issues that indicate an important operation failed to occur or wasn't completed successfully.
An error may not cause Antora to shut down, but your site probably wasn't generated or published as expected.
warn:: _Default value._
Incorrect AsciiDoc syntax such as missing AsciiDoc attributes, playbook or component configurations, and other problematic or unusual situations that are likely to affect the usability, performance, or appearance of the generated site.
info:: Informational messages that highlight Antora's normal operations and milestones.
debug:: Diagnostic messages that provide detailed context about Antora's activities, events, warnings, and errors as they occurred.
This level is useful when you need additional information about a warning or error.
all:: All of the information and details about Antora's operations and the results of those operations are logged.
silent:: The logger is turned off and no messages are logged.

Messages that meet or exceed the severity threshold are logged.
Messages that don't meet the severity threshold are not reported.

== Specify a log level

Let's assign the value `info` to the `level` key in the playbook shown in <<ex-level>>.

.Assign info severity threshold to level key
[#ex-level,yaml]
----
runtime: # <.>
  log: # <.>
    level: info # <.>
----
<.> In your playbook file, type the parent key `runtime`, followed by a colon (`:`), and press kbd:[Enter].
<.> The `log` key is a child of `runtime`.
Type the key's name, `log`, followed by a colon (`:`), and press kbd:[Enter].
<.> The `level` key is a child of `log`.
Type `level`, followed by a colon and a blank space (`:{sp}`), then type the value `info`.

When Antora runs and `level` is assigned `info`, messages that meet or exceed the `info` threshold are logged.
Messages that don't meet the `info` severity level aren't reported.

[#level-option]
== Log level option

You don't have to modify the playbook file directly to set the `level` key.
You can use the `--log-level` option from the xref:cli:options.adoc#log-level[CLI].

 $ antora --log-level=debug antora-playbook.yml

The `--log-level` option overrides the value assigned to the `level` key or to the xref:playbook:environment-variables.adoc#log-level[ANTORA_LOG_LEVEL environment variable].

// /docs/modules/playbook/pages/runtime-log-failure-level.adoc
[[runtime-log-failure-level.adoc]]
= Log Failure Level

The `failure_level` key specifies the severity threshold that, when met or exceeded, causes Antora to exit with a non-zero (i.e., failure) exit code.

To be clear, this setting doesn't stop Antora from running.
Rather, it merely impacts the exit code value of the process in which Antora is running.
It's up to the shell to interpret this value, as most CI environments do.

[#default]
== Default failure level

Explicitly assigning a value to the `failure_level` key is optional.
If it isn't set in the playbook or specified using the <<failure-level-option,--log-failure-level option>> or xref:playbook:environment-variables.adoc#failure-level[ANTORA_LOG_FAILURE_LEVEL variable], Antora assigns the value `fatal` to the key at runtime.
If a logged message meets the `fatal` severity threshold, Antora will exit with a non-zero exit code.

[#failure-level-key]
== failure_level key

The `failure_level` key is configured under the xref:configure-runtime.adoc[runtime and log] keys in a playbook.

.antora-playbook.yml
[,yaml]
----
runtime:
  log:
    failure_level: error
----

The key accepts the following built-in values:

* `fatal` (default)
* `error`
* `warn`
* `none`

These values correspond to the xref:runtime-log-level.adoc#severity-levels[severity levels] Antora assigns to log messages.
Except when the value is `none`, Antora exits with a non-zero exit code if a message is logged that meets or exceeds the value assigned to `failure_level`.
When the value is `none`, Antora always exits with zero exit code, even when an unhandled error is thrown.
Note that when Antora's logger is turned off, the `failure_level` key and its value aren't applied.

=== Force zero exit code

When the `failure_level` key is assigned the value `none`, Antora always exits with the exit code zero (0), even if a fatal error is encountered.

== Specify a failure level

Let's assign the value `warn` to the `failure_level` key in the playbook shown in <<ex-failure>>.

.Assign warn severity threshold to failure_level key
[#ex-failure,yaml]
----
runtime:
  log:
    failure_level: warn
----

Antora will finish generating the site, as long as it doesn't encounter any fatal errors, and exit with a non-zero exit code if any messages are logged with a severity of `warn` or greater.
If no warning, error, or fatal messages are logged, Antora exits with a zero (0) exit code.
That is, your site built successfully without any errors or potential problems!

[#failure-level-option]
== Log failure level option

Alternatively, you can use the xref:cli:options.adoc#failure-level[--log-failure-level option from the CLI] to assign a failure threshold.

 $ antora --log-failure-level=warn antora-playbook.yml

The `--log-failure-level` option overrides the value assigned to the `failure_level` key or the xref:playbook:environment-variables.adoc#failure-level[ANTORA_LOG_FAILURE_LEVEL environment variable].

// /docs/modules/playbook/pages/runtime-log-format.adoc
[[runtime-log-format.adoc]]
= Log Format

The log `format` key specifies the format of the log messages.

IMPORTANT: The log format, and all other log settings, are not honored if a fatal error is thrown before Antora fully configures the playbook.
Instead, the error message is printed directly to standard error (STDERR).

[#default]
== Default log format

Explicitly assigning a value to the `format` key is optional.
When `format` isn't set, Antora assigns one of the key's accepted values, either `json` or `pretty`, based on the environment it detects at runtime.
Antora assigns the value `pretty` to the `format` key when Antora is running in a <<ci,continuous integration environment (CI=true)>>, the `IS_TTY` environment variable is `true`, or the terminal is interactive (TTY) and the `IS_TTY` environment variable is not `false`.
In all other cases, Antora uses the `json` value.

[#format-key]
== format key

The `format` key is configured under the xref:configure-runtime.adoc[runtime and log] keys in a playbook.

.antora-playbook.yml
[,yaml]
----
runtime:
  log:
    format: json
----

The `format` key accepts the following built-in values:

json:: _Default if the `CI` environment variable is not set (not running in a CI environment variable), `IS_TTY=false`, or the terminal is not interactive._
The structured log messages are emitted in JSON format to the standard out stream (STDOUT) so they can be piped to other applications and processed.
The output adheres to the https://jsonlines.org[JSON Lines] (jsonl) text format (also known as Newline delimited JSON, or ndjson).
Each message is output on its own line using UTF-8 encoding and each line is a valid JSON value.
The levels of the messages are expressed as labels, _error_, _info_, etc., by default.
The level format can be changed to numbers by setting the <<level-format-key,log.level_format key>> and assigning the value `number` to it.

pretty:: _Default if `CI=true`, `IS_TTY=true`, or the terminal is interactive._
The log messages are formatted for readability and emitted to the standard error stream (STDERR).

The `format` key can also be specified using the <<format-option,--log-format option>> or xref:playbook:environment-variables.adoc#log-format[ANTORA_LOG_FORMAT variable].

.CI environment variable
[#ci]
****
Continuous integration (CI) environments, such as Netlify, GitHub Actions, GitLab CI, and many others, typically set the continuous integration environment variable (`CI`) to `true`.
Antora uses this environment variable to determine when it's running in a CI environment and change its behavior accordingly.
****

[#pretty]
=== Prettified

To emit formatted log messages, assign the `pretty` value to the `format` key in your playbook.

.Assign pretty value to format key
[#ex-pretty,yaml]
----
runtime:
  log:
    format: pretty
----

Now when you run Antora, it will emit log messages to STDERR.
Antora tries to be smart about the use of color.
When Antora writes log messages to a standard stream, such as STDERR, it will colorize the prettified log messages if the terminal supports color.

If you run Antora from your terminal, the formatted log messages are displayed there.
<<result-pretty>> shows a prettified log message (without color) for an xref error.

.Log message output using pretty format
[listing#result-pretty]
----
[16:03:00.691] ERROR (asciidoctor): target of xref not found: a-page.adoc
    file: /home/computer/my-projects/project/docs/modules/module-name/pages/index.adoc:54 <.>
    source: /home/computer/my-projects/project (refname: my-branch <worktree>, start path: docs)
----
<.> To display the line number where an error occurs, set the xref:asciidoc-sourcemap.adoc[sourcemap key].

You can prevent Antora from colorizing the prettified log messages by setting the `NO_COLOR` environment variable when you run Antora.

 $ NO_COLOR=1 antora antora-playbook.yml

Antora will never apply color to the log message if the `NO_COLOR` environment variable is set, regardless of the capabilities of the terminal.
If you want to force Antora to apply color, even if it doesn't detect color support in the terminal, set the `FORCE_COLOR` environment variable instead (e.g., `FORCE_COLOR=1`).

[#json]
=== JSON

To emit structured log messages in JSON format, assign the `json` value to the `format` key in your playbook.

.Assign json value to format key
[#ex-json,yaml]
----
runtime:
  log:
    format: json
----

When Antora runs, any log messages are emitted to STDOUT.
<<result-json>> shows a structured log message about an xref error.

.Log message output in JSON
[#result-json,json]
----
{"level":"error","time":1627682525543,"name":"asciidoctor","file":{"path":"/home/computer/my-projects/project/docs/modules/module-name/pages/index.adoc","line":54},"source":{"url":"https://gitlab.com/org/project.git","worktree":"/home/computer/my-projects/project","refname":"my-branch","startPath":"docs"},"msg":"target of xref not found: a-page.adoc"}
----

A structured log message is made up of a series of key-value pairs.
Each key indicates a log message field, such as _level_, and each value records the logging information for that field, such as _error_.

==== Process JSON messages

JSON formatted messages can be directed to a separate application or sent to log ingestion services for parsing, search, and analysis.
A popular tool for working with JSON messages is jq.
https://stedolan.github.io/jq[jq] is a JSON processor; a command line tool to select, filter, and reshape JSON messages.

Here's an example that shows how to pipe JSON formatted log messages generated by Antora to jq.

 $ antora antora-playbook.yml | jq

<<result-jq>> shows the result of structured log message for an xref error that's been piped to jq to make it easier to read.

.Log message output piped to jq
[#result-jq,json]
----
{
  "level": "error",
  "time": 1627683497637,
  "name": "asciidoctor",
  "file": {
    "path": "/home/user/projects/project/docs/modules/module-name/pages/index.adoc",
    "line": 54
  },
  "source": {
    "url": "https://gitlab.com/org/project.git",
    "worktree": "/home/user/projects/project",
    "refname": "my-branch",
    "startPath": "docs"
  },
  "msg": "target of xref not found: a-page.adoc"
}
----

You can also use jq to filter messages.
For example, if you only want to see xref errors from Asciidoctor, ignoring all other errors, you can add a select filter to the jq command.

 $ antora --log-level=error antora-playbook.yml | \
   jq 'select(.name == "asciidoctor" and (.msg | contains(" not found:")))'

If you're only building part of your site, and you want to filter out warnings to "`offsite`" pages, you can add an ignore filter to the jq command.

 $ antora antora-playbook.yml | \
   jq 'select(.msg | contains(" not found: missing-component-name:") | not)'

You can pipe to jq multiple times to select or ignore additional messages.
See the reference documentation for the https://stedolan.github.io/jq/manual/#select%28boolean_expression%29[select] function to learn more about how to use it.

If you want the result set from jq to be displayed in prettified format, you can pipe that result to `pino-pretty`.
Since `pino-pretty` is a dependency of Antora, you can invoke it using `npx`.

 $ antora antora-playbook.yml | jq -cM | npx pino-pretty

The `-c` option tells jq to keep the output in JSON lines format and the `-M` option turns off color in the data passed to `pino-pretty`.
The prettified messages aren't quite as pretty as the output Antora produces, though it is possible to customize pino-pretty to achieve a similar result.

[#format-option]
== Log format option

You don't have to modify the playbook file directly to set the `format` key.
You can use the `--log-format` option from the xref:cli:options.adoc#log-format[CLI].

 $ antora --log-format=json antora-playbook.yml

The `--log-format` option overrides the value assigned to the `format` key or to the xref:playbook:environment-variables.adoc#log-format[ANTORA_LOG_FORMAT environment variable].

However, recall that if you pipe the output to another program, and the log format has not been specified, Antora will automatically switch to the JSON format.

[#level-format-key]
== level_format key

When the log format is JSON (`json`), each log level correlates to a label and a number.
The JSON format expresses a level as a label, such as _error_ or _info_, by default.
However, some tools require the level to be a number.
The format of the level can be configured with the `level_format` key.
The `level_format` key is configured under the xref:configure-runtime.adoc[runtime and log] keys in a playbook.

.Assign number value to level_format key
[#ex-number,yaml]
----
runtime:
  log:
    format: json
    level_format: number
----

The `level_format` key accepts the built-in values `label` and `number`.
The default value is `label`.
If the log format is `pretty`, the value assigned to the `level_format` key is ignored and levels are always expressed as labels.

[#level-format-option]
== Level format option

You don't have to modify the playbook file directly to set the `level_format` key.
You can use the `--log-level-format` option from the xref:cli:options.adoc#log-level-format[CLI].

 $ antora --log-format=json --log-level-format=number antora-playbook.yml

The `--log-level-format` option overrides the value assigned to the `level_format` key or to the xref:playbook:environment-variables.adoc#log-level-format[ANTORA_LOG_LEVEL_FORMAT environment variable].

// /docs/modules/playbook/pages/runtime-log-destination.adoc
[[runtime-log-destination.adoc]]
= Log Destination

The `destination` category under the `runtime.log` category provides keys that allow you to control where Antora writes log messages.
You can configure Antora to write messages to a standard stream or a file.
You can also control when and how Antora writes those log messages.

[#default]
== Default destination

The default destination file is correlated with the log format.
If the log format is xref:runtime-log-format.adoc#pretty[pretty], the default destination is the standard error stream (stderr).
If the log format is xref:runtime-log-format.adoc#json[json], the default destination is the standard output stream (stdout).
In either case, the messages will appear in the output of your terminal.

The `file` key allows you to control which standard stream Antora selects or to configure Antora to route the log messages to a local file.

[#file-key]
== file key

The `file` key is configured under the `destination` category key of the xref:configure-runtime.adoc#log-key[log category key] in a playbook.
The `file` key is optional.
The value of this key can be a path to a local file, the value `stdout` (or 1) for the standard output stream, or the value `stderr` (or 2) for the standard error stream.

.antora-playbook.yml
[,yaml]
----
runtime:
  log:
    destination:
      file: ./antora.log
----

If this key is set, the specified destination is used instead of the <<default,default destination>>, regardless of the log format.

The resolution rules for `file` are the same as for any path in the playbook.
include::partial$relative-path-rules.adoc[]

If the value of the `file` key is the path of a local file rather than a standard stream, and the log format is pretty, the messages are not colorized.
Keep in mind that if you route log messages to a file, you will not see those messages in your terminal anymore.
You will have to check the log file to see if Antora wrote any log messages to it.

By default, Antora truncates the file before writing to it.
You can alter this behavior using the `append` key.

[#append-key]
== append key

The `append` key is configured under the `destination` category key of the xref:configure-runtime.adoc#log-key[log category key] in a playbook.
The `append` key is optional.
The value of this key can either be `true` or `false`.
By default, the value is `false`.
If you set the value to `true`, Antora will not truncate (i.e., clear) the file before writing to it.
That means the log messages from a previous run of Antora will be preserved.

.antora-playbook.yml
[,yaml]
----
runtime:
  log:
    destination:
      file: ./antora.log
      append: true
----

This key is only relevant if the `file` key is specified as the path of a local file.

By default, Antora will write log messages to the destination immediately.
You can control this behavior using the `buffer_size` and `sync` keys.

[#buffer-size-key]
== buffer_size key

The `buffer_size` key is configured under the `destination` category key of the xref:configure-runtime.adoc#log-key[log category key] in a playbook.
The `buffer_size` key is optional.
The value of this key can be 0 or a positive integer.
The value represents the number of bytes to buffer (e.g., 4096 is 4K).

By default, the value is 0, which means Antora does not buffer log messages.
If the value is greater than 0, then Antora will batch log messages until they reach the specified size in bytes.
Once the resident size of the buffered log messages meet or exceed this value, Antora will flush the buffer to the destination.

.antora-playbook.yml
[,yaml]
----
runtime:
  log:
    destination:
      buffer_size: 4096
----

If you're routing log messages to a file, the `buffer_size` key provides a way to avoid an excessive number of writes.
You usually only need to use this key if you are encountering a resource problem when running Antora.

The `sync` key offers an additional way to control writes.

[#sync-key]
== sync key

The `sync` key is configured under the `destination` category key of the xref:configure-runtime.adoc#log-key[log category key] in a playbook.
The `sync` key is optional.
The value of this key can either be `true` or `false`.
By default, the value is `true`, which means Antora writes to the destination using a synchronous operation.
If you set the value to `false`, Antora will switch to writing to the destination using an asynchronous operation.
This means log messages will be written the next time the Node.js process can perform an I/O operation.

.antora-playbook.yml
[,yaml]
----
runtime:
  log:
    destination:
      file: ./antora.log
      sync: false
----

Setting the `sync` key to `false` prevents a log event from pausing the program to complete the write.
Instead, those writes are put onto a queue and performed the next time the Node.js process is idle, such as when it's performing a network operation.
In other words, the writes are naturally batched.
If generating your site produces a lot of log messages, this can help Antora perform more optimally.

You can combine the `sync` key with the `buffer_size` key to maximize how much log message writes are deferred.

// /docs/modules/playbook/pages/runtime-fetch.adoc
[[runtime-fetch.adoc]]
= Fetch Updates

Use the `fetch` key whenever you want to retrieve updates from the remote content sources repositories and UI bundle snapshots.

== Fetch operations

Activating the `fetch` key from a playbook or the CLI causes Antora to perform both of the following actions each time it runs:

. Run a fetch operation for all remote content sources repositories Antora has cloned, or clone them otherwise.
. Download the remote UI bundle if it's marked as a xref:ui-bundle-url.adoc#snapshot[snapshot], even if it has already been downloaded.

Antora only fetches updates for remote content sources since the clones are managed by Antora.
Antora never fetches updates for local content sources (i.e., local git repositories).
In other words, Antora does not run `git fetch` or `git pull` on a local git repository.
Doing so would runs the risk of putting them into an inconsistent state or otherwise interfering with the author's work.
Antora leaves managing the state of local content repositories up to the author.

[#fetch-key]
== fetch key

The first time Antora runs a playbook, it clones any remote content sources git repositories and downloads the UI bundle into the xref:runtime-cache-dir.adoc[Antora cache directory].
On subsequent runs, Antora resolves these resources in the cache folder, effectively running offline.

You can instruct Antora to refresh the cache by setting the optional `fetch` key to `true`.
The `fetch` key is configured under the xref:configure-runtime.adoc[runtime key] in a playbook.

.antora-playbook.yml
[,yaml]
----
runtime:
  fetch: true
----

[#fetch-option]
== Fetch option

You don't have to modify the playbook file directly to set this key.
You can use the `--fetch` option from the xref:cli:options.adoc#fetch[CLI].

 $ antora --fetch antora-playbook.yml

The `--fetch` option overrides the value assigned to the `fetch` key in the playbook file.

// /docs/modules/playbook/pages/runtime-cache-dir.adoc
[[runtime-cache-dir.adoc]]
= Cache Directory

The first time Antora runs, it caches any remote content sources git repositories and UI bundles.
On subsequent runs, Antora resolves these resources from the cache folder, effectively running offline.

[#default]
== Default cache directory

The remote resources are stored in Antora's default cache location unless an alternate location is configured using the `cache_dir` key.
The default location for the cache varies by operating system.

Linux:: [.path]_$XDG_CACHE_HOME/antora_ or [.path]_$HOME/.cache/antora_ if `$XDG_CACHE_HOME` isn't set
macOS:: [.path]_$HOME/Library/Caches/antora_
Windows:: [.path]_$APPDATA/antora/Caches_

Before downloading remote resources, Antora will first look for them in the cache folder.
If you want to update your cache, configure Antora to xref:runtime-fetch.adoc[fetch updates].
Another option is to locate the Antora cache directory on your system and manually delete it.

[#cache-dir-key]
== cache_dir key

The optional `cache_dir` key is configured under the xref:configure-runtime.adoc[runtime key] in a playbook.
`cache_dir` specifies the directory where the remote repositories should be cloned and the remote UI bundle should be downloaded.
It accepts a relative or absolute filesystem path.

.antora-playbook.yml
[,yaml]
----
runtime:
  cache_dir: ./.cache/antora
----

In this case, the value resolves to the folder [.path]_.cache/antora_ relative to the location of the playbook file.
We know the resolved location is relative to the playbook file because it starts with `./`.

The resolution rules for `cache_dir` are the same as for any path in the playbook.
include::partial$relative-path-rules.adoc[]

The cache directory can also be configured from the CLI with the xref:cli:options.adoc#cache-dir[--cache-dir option] or using the xref:environment-variables.adoc[ANTORA_CACHE_DIR variable].

// /docs/modules/playbook/pages/configure-network.adoc
[[configure-network.adoc]]
= Network Keys

The playbook keys configured under `network` control the network requests initiated by Antora.
These requests, at present, include those made by the git client in the content aggregator and the HTTP client in the UI loader.

NOTE: In most cases, users will choose to use the environment variables mapped to the keys in this category (`http_proxy`, `https_proxy`, and `no_proxy` ) instead of defining them in the playbook.
However, being able to set them in the playbook or via the mapped CLI option does offer the possibility of controlling these settings per Antora run.
Recall that environment variables take precedence over keys defined in the playbook file, but get overridden by the CLI option for that same key.

[#network-key]
== network key

The `network` key holds as the network-related playbook keys, such as the proxy settings.

.antora-playbook.yml
[,yaml]
----
network: # <.>
  http_proxy: github.com # <.>
  https_proxy: github.com # <.>
  no_proxy: gitlab.com # <.>
----
<.> Optional `network` category key
<.> Optional `http_proxy` key through which to route HTTP requests
<.> Optional `https_proxy` key through which to route HTTPS requests
<.> Optional `no_proxy` key for HTTP or HTTPS domain request that should bypass proxy

The `network` category key and the child keys it accepts are all optional.
When the `network` key isn't present in the playbook (and not set via environment variables), Antora falls back to using the default mode for HTTP requests.

[#network-reference]
== Available network keys

[cols="3,6,1"]
|===
|Git Keys |Description |Required

|xref:network-proxy.adoc#http-proxy[http_proxy]
|Accepts a URL (e.g., `\http://localhost:3128`) through which to route HTTP requests.
Honors the value of the `http_proxy` environment variable, if set.
|No

|xref:network-proxy.adoc#https-proxy[https_proxy]
|Accepts a URL (e.g., `\http://localhost:3128`) through which to route HTTPS requests.
Honors the value of the `https_proxy` environment variable, if set.
|No

|xref:network-proxy.adoc#no-proxy[no_proxy]
|Accepts a comma-separate list of domains of HTTP or HTTPS requests that should not be proxied.
Set the value to `*` to bypass the proxy entirely.
Honors the value of the `no_proxy` environment variable, if set.
|No
|===

// /docs/modules/playbook/pages/network-proxy.adoc
[[network-proxy.adoc]]
= Network Proxy

The purpose of network proxy-related keys in the playbook is to allow Antora to be used behind an HTTP/HTTPS proxy, such as in a typical corporate environment.
The requests these keys impact, at present, include those made by the git client in the content aggregator and the HTTP client in the UI loader.

== Automatic configuration

By default, Antora respects the industry-standard `http_proxy`, `https_proxy`, and `no_proxy` environment variables, if set.
That means Antora may automatically proxy network requests, even if these keys are not set in the playbook file.
This reflects a noteworthy change in behavior from Antora 2.

The `http_proxy` and `https_proxy` environment variables specify a URL through which Antora should route HTTP and HTTP requests, respectively.
The `no_proxy` environment variable allows for requests to certain domains or subdomains to bypass the proxy (i.e., exclusions).

NOTE: It's not possible to configure different proxies for different URLs using this approach.
The only URL-specific configuration is to disable the proxy for certain domains or subdomains using `no_proxy`.

By honoring these environment variables, Antora is fulfilling the standard contract in network programming for working with proxies without having to modify the settings at the application level.
This is the contract by which network-based software is developed.
If the connection still cannot be made when these environment variables are set, it's an IT issue.

If it's necessary to configure the proxy settings without the use of environment variables, then, and only then, do you need to specify them in the playbook file.
If that's the case, read on.

[#http-proxy]
== http_proxy key

The `http_proxy` key accepts a URL through which to route HTTP requests.
The URL should only contain the protocol (http or https), domain (root domain or subdomain), and a port.
When set, all HTTP requests made by Antora will be routed through this URL.

.antora-playbook.yml
[,yaml]
----
network:
  http_proxy: http://localhost:3128
----

The protocol of the proxy URL does not have to match the protocol of the original URL.

[#https-proxy]
== https_proxy key

The `https_proxy` key accepts a URL through which to route HTTPS requests.
The URL should only contain the protocol (http or https), domain (root domain or subdomain), and a port.
When set, all HTTPS requests made by Antora will be routed through this URL.

.antora-playbook.yml
[,yaml]
----
network:
  https_proxy: http://localhost:3128
----

The protocol of the proxy URL does not have to match the protocol of the original URL.

[#no-proxy]
== no_proxy key

The `no_proxy` key specifies proxy exclusions.
These exclusions are expressed as a comma-separated list of domains or subdomains.
If the URL of a request matches one of these values, it will not be routed through the proxy, even if a proxy is configured for the protocol of the URL (http or https).

.antora-playbook.yml
[,yaml]
----
network:
  no_proxy: gitlab.com,github.com
----

To turn off the proxy for all requests, set this value to `*`.

.antora-playbook.yml
[,yaml]
----
network:
  no_proxy: '*'
----

Antora 2 didn't honor the `http_proxy` and `https_proxy` environment variables.
If you're migrating from Antora 2 to Antora 3, and you encounter a network error (Bad response: 503), the automatic proxy support in Antora 3 may be the culprit.
If the proxy is standing in the way of Antora connecting to an endpoint, you may need to bypass the proxy using the `no_proxy` key.
If you want to avoid modifying your playbook, you can specify this key using a CLI option:

 $ antora --noproxy '*' antora-playbook.yml

However, if this is necessary, you may want to understand why the proxy is failing to route the request.

// /docs/modules/playbook/pages/author-mode.adoc
[[author-mode.adoc]]
= Use Author Mode
:url-git-worktree: https://git-scm.com/docs/git-worktree

* [x] How to activate author mode.

Although the primary function of Antora is to generate a site for publishing, it also serves as a tool for the author.
By configuring Antora to use a local repository, you can preview local content, including content you haven't committed.

== Activate author mode

Author mode is activated when you configure the playbook to use a local clone for one or more of the content repositories.
Antora will use the repository as it is on your local machine instead of cloning it from its remote location.
This scenario assumes you've already cloned a repository and want to incorporate it into the site generation.

To begin, create a folder named [.path]_workspace_ in your project.

 $ mkdir workspace

Switch to the newly created directory and clone one of the repositories:

 $ git clone https://github.com/my-antora-demo/server-docs workspace/server-docs

Next, make a copy of your playbook file for local use.
In the example below, [.path]_antora-playbook.yml_ is copied and the new file is named [.path]_local-antora-playbook.yml_.

 $ cp antora-playbook.yml local-antora-playbook.yml

Next, open your new playbook file and configure it to use the cloned repository instead of the remote repository.
You can specify the repository either as a xref:content-source-url.adoc#local-urls[path relative to the playbook file or as an absolute path].

.local-antora-playbook.yml
[,yaml]
----
content:
  sources:
  - url: ./workspace/server-docs
    branches: HEAD # <.>
----
<.> In author mode, you usually want to use the currently checked out HEAD of the local repository

Build your Antora site using the new playbook file.

 $ antora local-antora-playbook.yml

The contents of your local repository will be incorporated into the pipeline.

NOTE: If your [.path]_workspace_ directory is inside of your playbook repository, it is best to add it to your `.gitignore` file so as not to push it to the remote.

[#multiple-worktrees]
== Use multiple worktrees

In the previous section, you learned how to configure Antora to use a local repository with a single worktree.
If your repository only has a single content branch, this setup works great.
However, once you start working with multiple branches, using a single worktree is not ideal.
It means having to switch branches each time you need to read or update files in a different component version, making shuffling files between versions very difficult.
That's where multiple worktrees comes into play.

A local git repository can support multiple worktrees.
The location of the local repository still acts as the main worktree.
Using the {url-git-worktree}[`git worktree`^] command, you can associate additional worktrees with the repository, each mapped to a discrete branch.
The new worktree is called a [.term]*linked worktree*.
It lives in a directory that's separate from the main worktree.
That means you can effectively have more than one branch checked out at a time for a single repository.

Antora recognizes linked worktrees attached to a local content source, provided you have enabled this feature, and will use them if they match one of the branch patterns specified in the playbook.
To enable this feature, add `worktrees: true` to the entry for the content source in the Antora playbook.

Follow these steps to set up a local content source with multiple worktrees:

. Clone the playbook repository.
. In the folder that git creates for the clone, make a folder named [.path]_workspace_.
. Switch to the [.path]_workspace_ folder and make another folder to hold the worktrees for your content repository (e.g., [.path]_workspace/software-with-docs_) (Note that this is not a git repository).
. Switch to that folder.
. Clone the content repository to the folder main (or whatever your default branch is) (e.g., `git clone \https://github.com/my-antora-demo/server-docs main`)
. Switch to that folder.
. Now create a worktree for each branch you want to edit using git worktree.
For example: `git worktree add ../6.0 6.0`.
The first argument to `git worktree add` is the location of the worktree and the second is the name of the branch.
Typically, you'll name the worktree folder using the name of the branch.
. Now return to the playbook repository (where [.path]_antora-playbook.yml_ is located) and open the author playbook named [.path]_local-antora-playbook.yml_ as described in the previous section, creating it if necessary.
. In your playbook file, change the URL for the content repository to point to the cloned repository inside the workspace (e.g., ./workspace/software-with-docs/main).
You have to point Antora to the main worktree, not one of the linked worktrees.
. In that same content source entry, enable the xref:content-worktrees.adoc[worktrees feature] by adding `worktrees: true`.

Repeat steps 3-10 for each content repository you want to work with.

Now when Antora scans for branches, it will automatically discover the worktrees you have linked and read the files from it (instead of reading them from the git tree).
With this setup, you can use the playbook repository as your home base and organize all your content repositories and branches underneath it for authoring.

TIP: You could create a script in the playbook repository to automate the process of setting up this authoring environment.

To learn more about git worktrees and how to use them, refer to the {url-git-worktree}[git-worktree page^] in the git documentation.

== Author mode order of operations

You may be wondering what branches the generator selects when the repository is local and whether it will pick up your uncommitted changes.
Here's how a local repository is handled:

* The repository contents on your local machine are used instead of the contents from its remote storage location.
//being cloned from its remote storage location  into build/sources.
* The local repository is not updated from its remote storage location; Antora assumes the author will manage the repository (explicitly calling `git fetch` or `git pull` on the repository as needed).

Here's how the branches are selected in author mode:

* Both local branches and remote branches associated with the remote `url` are considered.
* If a local branch has the same name as a remote branch, the local branch is chosen.
* The contents of the worktree get used in place of the files from the current branch.
Aside from its name, the current branch is effectively ignored.
* The current branch of your worktree must match the `branches` filter configured on the `url` entry.
If not, the working tree will be ignored.
You can use the xref:content-branches.adoc#current-local-branch[reserved HEAD value] to ensure the current working tree is always used.

If you want to use multiple worktrees, simply clone the repository multiple times and configure multiple entries in the playbook.
You can use the `branches` key to xref:content-branches.adoc[filter out the names of branches you don't want].

// /docs/modules/playbook/pages/use-an-existing-playbook-project.adoc
[[use-an-existing-playbook-project.adoc]]
= Use an Existing Playbook Project

*This page is for people joining a documentation project that already uses Antora.*

include::partial$playbook-project-summary.adoc[]

Before you can generate a site with Antora, you'll need to fetch the playbook project for your site.

== Fetch the playbook project

To start, open a terminal and clone the playbook project using git:

 $ git clone your-playbook-repo && cd "`basename $_`"

// Good place to put in demo info

The command clones an existing playbook project and then switches to the project folder.

If the project contains a [.path]_package-lock.json_ file, it means it is requesting that you install Antora locally.
To do so, run the following command:

 $ npm ci

When Antora is installed locally, you will use `npx antora` to run Antora install of `antora`.
The `npx` command will look for the `antora` command installed within the playbook project or any parent directory of the playbook project.

== Learn more

* xref:ROOT:run-antora.adoc[Run Antora] to generate the site.
* Modify the playbook to configure the xref:configure-site.adoc[site properties] or the site's xref:configure-content-sources.adoc[content sources].

////
Stay in this project folder in order to initialize the project using Yarn.

== Install Antora

Initializing a playbook project means downloading and installing Antora and its dependencies.
These tasks are managed by Yarn.
Make sure you've xref:ROOT:install-prerequisites.adoc[installed Antora's prerequisites] before running Yarn.

In your terminal, execute the following command from the root folder of the playbook project to install Antora and its dependencies:

 $ yarn

//The default command in Yarn is `install`, so running `yarn` by itself is the equivalent of running `yarn install`.
The install command uses dependency information defined in [.path]_package.json_ and [.path]_yarn.lock_ to resolve dependencies.
Yarn installs these dependencies inside the project under the [.path]_node_modules_ folder.

Once you've installed Antora and its dependencies, you can xref:ROOT:run-antora.adoc[generate your site] with your playbook.

=== Refresh dependencies

You must run the `yarn` command each time the `yarn.lock` file is changed.
This refreshes the dependencies, fetching any dependencies you don't yet have installed and cleaning out old ones.
Since Yarn runs very quickly, it doesn't hurt to run it each time you run `git pull`.

=== About dependencies

A playbook project only has one top-level dependency, which is (pending release) _antora_.
You can see that this is the only dependency declared in [.path]_package.json_:

.package.json (excerpt)
[,json,subs=attributes+]
----
"devDependencies": {
  "antora": "{uri-antora-repo}#v1.0.3"
},
----

*You do not need to clone the Antora repository listed in this excerpt*.
Yarn does that for you.

Antora has its own transitive dependencies, but those are fetched automatically by Yarn.

=== Generate the Site

To generate the site using the default configuration, run the following command:

 $ node generate

You can preview the site locally by navigating to the [.path]_build/site_ in your browser.
////

// /docs/modules/playbook/pages/environment-variables.adoc
[[environment-variables.adoc]]
= Environment Variables

Antora recognizes a number of environment variables that map to keys in the playbook.
These environment variable can be used to configure Antora for different environments without having to modify the playbook file.

== What is an environment variable?

An environment variable is a persistent variable (i.e., key=value pair) in your terminal which becomes available to all commands you execute at the prompt.
This facility allows the behavior of commands to be altered based on which environment they are running in.
For example, you may use an environment variable in a continuous integration (CI) or publishing environment to enable a behavior which may not be enabled by default.

You can output the current value of an environment variable using the `echo` command.
In a Linux or macOS terminal, type:

 $ echo $PATH

In the Windows command prompt, type:

 $ echo %PATH%

And in Windows Powershell, type:

 $ echo $env:PATH

Environment variables are not required for using Antora.
You can configure these variables using the corresponding command line options or in your playbook with the matching keys.

== Precedence

Environment variables take precedence over keys defined in the xref:index.adoc[playbook file].
However, the xref:cli:options.adoc[CLI option] for a key takes precedence over the environment variable for that key.

If an environment variable (such as `URL` or `https_proxy`) is already set in your environment, and you wish to unset it temporarily when you run the `antora` command (i.e., a single invocation), you can do so using the `env` command:

 $ env -u URL antora antora-playbook.yml

Another option is to run the `antora` command in a subshell.
Inside a subshell, you can unset an environment variable without it affecting the environment of your main shell or operating system.

 $ (unset URL; antora antora-playbook.yml)

Remember that environment variables take precedence over keys defined in your playbook file.
So if you're getting results you don't expect, always check your environment variables to find out if they are the culprit.

== Variables and formats

The following table summarizes the environment variables you can use to control the operation of Antora.

[cols="4,2,2,4"]
|===
|Variable |Format |Default |Learn More

|[[cache-dir]]`ANTORA_CACHE_DIR`
|String
|[.path]_<user cache>/antora_
|See xref:runtime-cache-dir.adoc[cache_dir key] and xref:cli:options.adoc#cache-dir[--cache-dir option]

|[[failure-level]]`ANTORA_LOG_FAILURE_LEVEL`
|String
|Not set
|See xref:runtime-log-failure-level.adoc[failure_level key] and xref:cli:options.adoc#failure-level[--log-failure-level option]

|[[log-file]]`ANTORA_LOG_FILE`
|String
|Not set
|See xref:runtime-log-destination.adoc#file-key[file key] and xref:cli:options.adoc#log-file[--log-file option]

|[[log-format]]`ANTORA_LOG_FORMAT`
|String
|`pretty` if CI=true or terminal is interactive, otherwise `json`
|See xref:runtime-log-format.adoc[format key] and xref:cli:options.adoc#log-format[--log-format option]

|[[log-level]]`ANTORA_LOG_LEVEL`
|String
|`warn`
|See xref:runtime-log-level.adoc[level key] and xref:cli:options.adoc#log-level[--log-level option]

|[[log-level-format]]`ANTORA_LOG_LEVEL_FORMAT`
|String
|`label`
|See xref:runtime-log-format.adoc#level-format-key[level_format key] and xref:cli:options.adoc#log-level-format[--log-level-format option].
Only applies when the log format is `json`.

|`GIT_CREDENTIALS`
|String
|Not set
|See xref:playbook:private-repository-auth.adoc[]

|`GIT_CREDENTIALS_PATH`
|String
|Not set
|See xref:playbook:private-repository-auth.adoc#custom-credential-path[git credentials file path] and xref:cli:options.adoc#git-credentials-path[--git-credentials-path option]

|`GOOGLE_ANALYTICS_KEY`
|String
|Not set
|See xref:playbook:site-keys.adoc#google-analytics-key[Google Analytics key]

|`http_proxy`
|String
|Not set
|See xref:playbook:network-proxy.adoc#http-proxy[http_proxy key] and xref:cli:options.adoc#http-proxy[--http-proxy option]

|`https_proxy`
|String
|Not set
|See xref:playbook:network-proxy.adoc#https-proxy[https_proxy key] and xref:cli:options.adoc#https-proxy[--https-proxy option]

|`no_proxy`
|String
|Not set
|See xref:playbook:network-proxy.adoc#no-proxy[no_proxy key] and xref:cli:options.adoc#noproxy[--noproxy option].
Note the name of the CLI option differs from the name of the environment variable and playbook key.

|[[site-url]]`URL`
|String
|Not set
|See xref:site-url.adoc[site url key] and xref:cli:options.adoc#site-url[--url option]
|===

// /docs/modules/ROOT/pages/run-antora.adoc
[[run-antora.adoc]]
= Run Antora to Generate Your Site
:navtitle: Run Antora
:listing-caption!:
:url-demo: https://gitlab.com/antora/demo
:url-demo-project: {url-demo}/docs-site
:url-demo-playbook: {url-demo-project}/raw/main/antora-playbook.yml
:url-demo-component-a: {url-demo}/demo-component-a
:url-demo-component-b: {url-demo}/demo-component-b
:url-default-ui: https://gitlab.com/antora/antora-ui-default

Assumptions:

* [x] You've xref:install:install-antora.adoc[installed the Antora CLI and a site generator pipeline].
* [x] You have your own xref:playbook:index.adoc[playbook], or you're using the Demo playbook.
* [x] Your playbook is configured to access at least one of your own  xref:content-source-repositories.adoc[repositories containing content source files] or Antora's Demo content repositories.
* [x] Your playbook is configured to use a xref:playbook:configure-ui.adoc[custom UI bundle or Antora's default UI bundle].

On this page, you'll learn:

* [x] How to run Antora and generate a site.

== Antora demo playbook and content repositories

You don't need to set up a playbook file, xref:component-version.adoc[component version], or UI to evaluate Antora.
Instead, you can use the Antora demo playbook and content repositories.

The demo consists of a {url-demo-project}[playbook repository] containing a playbook file and content repositories ({url-demo-component-a}[component-a] and {url-demo-component-b}[component-b]) to which that playbook refers.
It also uses the UI bundle produced by the {url-default-ui}[default UI project].

Once you've xref:install:install-antora.adoc[installed Antora], you can run Antora using the demo materials to explore its capabilities.
The instructions and examples on this page will guide you through the process.

== Choose a playbook

To produce a documentation site, Antora needs a playbook.
But first, you'll need to create or choose a directory where you'll store the playbook and where the generated site files will be saved (assuming you use the default output configuration).

For the examples on this page, we'll use the demo playbook and content repositories.

. Open a terminal and make a new directory named [.path]_demo-site_.

 ~ $ mkdir demo-site

. Switch (`cd`) into the directory you just made.

 ~ $ cd demo-site

. Using your preferred text editor or IDE, create a new playbook file named [.path]_antora-playbook.yml_ and populate it with the contents of the following example.
Or, you can download {url-demo-playbook}[the playbook file] from the demo project repository.
+
.antora-playbook.yml
[,yaml]
----
site:
  title: Antora Demo Site
  url: https://my-antora-demo-site.org # <.>
  start_page: component-b::index.adoc # <.>
content:
  sources:
  - url: https://gitlab.com/antora/demo/demo-component-a.git
    branches: HEAD
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: [v2.0, v1.0]
    start_path: docs
ui:
  bundle:
    url: https://gitlab.com/antora/antora-ui-default/-/jobs/artifacts/HEAD/raw/build/ui-bundle.zip?job=bundle-stable
    snapshot: true
----
<.> The 404 page and sitemap files are only generated if the site `url` key is set.
The sitemap files are only generated if the value of the site `url` key is an absolute URL.
<.> The site `start_page` key accepts the same resource ID syntax that's used in xrefs.

. Save the playbook as [.path]_antora-playbook.yml_ in the [.path]_demo-site_ directory you made in Step 1.

[#run-antora]
== Run Antora

. To generate the site with the default Antora site generator, point the `antora` command at your playbook file.
In the terminal, type:
+
--
 demo-site $ antora antora-playbook.yml

If Antora is installed locally, you'll need to prefix the Antora command with `npx`:

 demo-site $ npx antora antora-playbook.yml

Antora will clone the content repositories.
The cloning progress of each repository is displayed in the terminal.

.Repository cloning progress
....
[clone] https://gitlab.com/antora/demo/demo-component-a.git [################]
[clone] https://gitlab.com/antora/demo/demo-component-b.git [################]
....

Once cloning is complete, Antora converts the AsciiDoc pages to embeddable HTML, wraps the HTML in the UI page templates, then assembles the pages into a site under the destination folder, which defaults to _build/site_.
--

. Antora has completed generation when the command prompt (`$`) reappears in the terminal.
If the terminal is interactive (TTY), Antora will also print a message that the site generation is complete.
The message will include the URL where you can view the site locally.
(You can override Antora's TTY detection by setting the `IS_TTY` environment variable to `true` or `false`).
+
[TIP#error-stacktrace]
====
If something goes wrong during generation, you'll see an error message in the terminal.

....
error: a message that summarizes what went wrong
....

If this message does not provide enough information to fix the problem, you can ask Antora for more context.
To tell Antora to reveal the calls leading up to the error (i.e., the stacktrace), run the `antora` command again, this time with the `--stacktrace` option:

 demo-site $ antora --stacktrace antora-playbook.yml

Share this stacktrace when xref:project/get-help.adoc[asking for help].
====

. Switch into the site folder (`cd`) and list (`ls`) its contents.
+
--
 demo-site $ cd build/site/

Inside the [.path]_build/site_ folder, run:

 site $ ls -1

You should see the following list of files and directories:

....
_
404.html
component-a
component-b
index.html
sitemap-component-a.xml
sitemap-component-b.xml
sitemap.xml
....

NOTE: The 404 page and sitemap files will be missing if the `site.url` property is not defined in your playbook.
The main sitemap file is actually a sitemap index.
That file links to the sitemap for each component, which is where the URL for the individual pages can be found.

This list includes the entry point of your documentation site, [.path]_index.html_.
--

. On some operating systems, you can open the site directly from the command line by typing `open`, followed by the name of the HTML file.
+
--
 site $ open index.html

Or, you can navigate to an HTML page inside the destination folder in your browser.
If you've been following along with the Demo materials, once you find the demo-site directory, navigate to the file [.path]_build/site/index.html_.
--

[#using-private-repositories]
== Private git repositories

Antora can authenticate with private repositories using HTTP Basic authentication over HTTPS.
See xref:playbook:private-repository-auth.adoc[Private repository authentication] to learn more.

== Repositories with large pack files

Antora may fail to read a git repository if it contains very large pack files (those > 2g).
If this situation occurs, you will get the following error:

....
FATAL (antora) : Cannot read properties of null (reading 'slice')
....

This failure is caused by a https://github.com/isomorphic-git/isomorphic-git/issues/1163[known limitation] of the git client Antora uses (isomorphic-git).
The limitation is due to a hard limit in the memory settings of the Node.js runtime.
Here's the underlying error message:

....
RangeError [ERR_FS_FILE_TOO_LARGE]: File size is greater than 2 GiB
....

2g is the max buffer size in Node.js.
In other words, Node.js has an upper limit to the size of a file it's able to read into memory.
If the pack file exceeds this size, Node.js and, in turn, isomoprhic-git, will fail.
In order to read larger files, isomorphic-git would have to switch to streams instead of putting the whole file in a buffer, if that's even feasible.

For a local git repository, the workaround is to configure git so it caps the size of any pack files it creates locally.
This is done using the `pack.packSizeLimit` config setting.

 $ git config pack.packSizeLimit 1g && git gc

You can find information about this setting on the https://www.git-scm.com/docs/git-pack-objects[git-pack-objects] help page in the git documentation.

Keep in mind that this workaround will only help with a local repository (a repository that is already cloned and configured).
Changing the pack size of the local repository isn't going to change the storage settings of the remote repository.
The `pack.packSizeLimit` needs to be adjusted on the git server as well so git doesn't attempt to send pack files that are too large over the wire.

////
The script loads and executes Antora and passes any trailing configuration flags and switches.

#Move this to a fragment or file in the playbook module#
For example, you can specify a custom playbook as follows:

 $ node generate --playbook=custom-site

Depending on your internet connection speed, it may take anywhere from a few seconds to several minutes to complete the generation process the first time you run it.
That's because, first, Antora has to download (i.e., `git clone`) all the repositories specified in the playbook.

When you run Antora again, the repositories are automatically updated (i.e., `git pull`).
These subsequent runs complete much faster because only the changes to the repositories have to be downloaded.

The repositories are cached under the [.path]_build/sources/_ directory.
If you remove the [.path]_build/_ directory, the repositories will have to be downloaded again from scratch.
////

// /docs/modules/ROOT/pages/preview-site.adoc
[[preview-site.adoc]]
= Preview Your Site
:page-aliases: preview-a-site.adoc

On this page, you'll learn:

* [x] How to preview a site locally.
* [x] How to run an optional local server to preview a site locally.

== Local site preview

Since Antora generates static sites, *you do not have to publish the site to a web server to view it*.
A site generated by Antora works just as well using the browser's local file: protocol.
This characteristic of an Antora site is an essential tool for previewing your work.

To view the site locally, navigate to any HTML page inside the destination folder in your browser.
If you're following along with the Demo, look for the file [.path]_build/site/index.html_ in your project.
You will be viewing the HTML pages through the file: protocol of the browser, which you can see in the location bar.

== Run a local server (optional)

Although the site is viewable without a web server, you may still need to view your site through a web server to test certain features, such as indexified URLs, caching, or scripts that don't work over the file: protocol.
You can use the *http-server* package for this purpose.
https://yarnpkg.com/en/package/http-server[http-server] is a simple, static web server for Node.js.

The most straightforward way to use *http-server* is to invoke it using npx:

 demo-site $ npx http-server -v

If you prefer, you can install the package globally using npm instead.

 demo-site $ npm i -g http-server

That puts a command by the same name on your PATH so you don't need to prefix it with `npx`.
We'll assume for the purpose of this tutorial that you are calling *http-server* using `npx`.

Now launch the web server by pointing it at the location of the generated site.
In the terminal, type the command name, `npx http-server`, followed by the location of the generated site (i.e., the output dir).
We also recommend adding the `-c-1` flag to disable caching.

 demo-site $ npx http-server build/site -c-1

Upon launching the command, the local address of the web server will be displayed in your terminal.
You should see the following output in your terminal:

[.output]
....
Starting up http-server, serving build/site
Available on:
  http://127.0.0.1:8080
  http://192.168.1.8:8080
Hit CTRL-C to stop the server
....

Paste the first provided URL into the location bar of your browser to view your site through a local web server.

Press kbd:[Ctrl,C] to stop the server.

TIP: If you get a port conflict when starting the server (i.e., `listen EADDRINUSE: address already in use`), you can use the `-p <port>` option to change to another port.
For example, append `-p 5000` to the command to switch to port 5000.

 demo-site $ npx http-server build/site -c-1 -p 5000

////
When generation is complete, you'll see a URL in the terminal that is specific to your machine.

[.output]
....
Loading theme bundle from GitHub release: ...
Using content from repository: ...
...
Finished in 0:00:45
Site can be viewed at file:///home/user/projects/docs-site/build/site
....

You can follow this URL to preview the site locally in your browser.

Depending on what you built, you may have to navigate to an HTML file from that location to see the actual site.
////

// /docs/modules/cli/pages/index.adoc
[[index.adoc]]
= Antora CLI Commands

This page introduces you to the Antora CLI and how you can use it to configure and run Antora.

== What's the Antora CLI?

The Antora command line interface (Antora CLI) is a simple tool (named `antora`) that enables you to execute and optionally configure Antora and any registered extended components and extensions from the command prompt of your terminal application.

Antora's CLI is the primary user-facing entry point for Antora.
Therefore, you'll frequently see it referenced in the documentation as the recommended way to interact with Antora.

TIP: If you aren't familiar with the command line, the xref:primer.adoc[] provides a basic overview of command anatomy, navigating working directories, and terminal application concepts.

By default, Antora looks in the provided playbook for its configuration settings.
When using the Antora CLI, you can specify optional configuration overrides as necessary using CLI options or environment variables.

[#usage]
== Usage

When you interact with a CLI, you type a command into the prompt of your terminal application, then press kbd:[Enter] to execute it.
The command consists of the program name (or program path) followed by zero or more options and arguments.
In the next few sections, we'll break down these parts for the Antora CLI.

NOTE: For certain programs, like Antora, a command can also refer to the primary argument of the program.
This can be confusing because you'll see the term *command* used to represent two distinct concepts.
One is the whole command you type at the prompt and the other is the program's primary argument.

Every command starts with the base call (i.e., program name or path).

.antora base call
[#ex-base]
 $ antora

In the case of the Antora CLI, the base call is `antora`.
This assumes that the Antora CLI is available on the `PATH` (e.g., installed globally).
Otherwise, the base call must be the path to the `antora` bin script (e.g., `npx antora`).
The base call must be offset from any command (for the program), options, or arguments by at least one space.

If you run the base call without specifying any command, options, or arguments, as shown in <<ex-base>>, you will be presented with a usage statement (i.e., help text).

.Usage statement
....
$ antora
Usage: antora [options] [[command] [args]]

A modular, single or multi-repository documentation site generator for AsciiDoc.

Options:
  -v, --version                  Output the version of the CLI and default site generator.
  -r, --require <library>        Require library (aka node module) or script before executing command.
  --stacktrace                   Print the stacktrace to the console if the application fails.
  -h, --help                     Output usage information.

Commands:
  generate [options] <playbook>  Generate a documentation site specified in <playbook>.

Run 'antora <command> --help' to see options and examples for a command (e.g., antora generate --help).
....

.Windows troubleshooting
[TIP]
====
You may get the message "`running scripts is disabled`" when running the `antora` command in Powershell.
If you do, you can work around this problem by running the following command in PowerShell as an administrator:

 Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachine

An alternate workaround is to run Antora using the Windows Command Prompt.
====

The usage statement provides an overview of the `antora` program, which includes:

* the command syntax,
* a description,
* a list of global options,
* a list of commands, and
* a suggestion for how to request additional help.

The usage statement begins with the following hint:

....
Usage: antora [options] [[command] [args]]
....

That's the cue to learn more about the options, commands, and args (i.e., arguments) it recognizes.

[#commands]
== Commands

The commands supported by the Antora CLI are summarized in the following table.
In this context, the term [.term]*command* refers to the primary argument accepted by the `antora` base call (as opposed to the command as a whole).

[cols="1,2",width=80%]
|===
|Command |Purpose

|`generate`
|Generates a site using the specified playbook file.
Antora runs `generate` automatically with the default Antora pipeline unless an alternate command is specified.
The command requires the path to a playbook file, relative to the working directory, be specified in the command's only argument.

|`help`
|Outputs the usage statement for the Antora CLI.
Note that this command is not shown in the usage statement.

|`version`
|Outputs the version number of the Antora CLI.
Note that this command is not shown in the usage statement.
|===

`help` and `version` are meta commands that show information about the Antora CLI itself.
The Antora CLI currently only supports one functional command, which is `generate`.
Since `generate` is the primary function of the Antora CLI, you don't have to specify it explicitly.
The `generate` command will always be implied if no command is specified (unless you execute the base call by itself).

////
Although only one command is shown in this table, the Antora CLI is designed to accommodate additional commands, which will likely be added in future releases.

Since the Antora CLI currently only supports a single command, you don't have to specify it explicitly.
The `generate` command will always be implied if no command is specified (unless you execute the base call by itself).
////

[#generate-command]
=== generate command

The simplest way to execute Antora using the Antora CLI is to specify the required base call (`antora`) followed by the path to a playbook file, as shown in <<ex-simple>>.

.antora base call with playbook argument
[#ex-simple]
 $ antora antora-playbook.yml

You've learned that the `generate` command is implied if not present.
Therefore, <<ex-simple>> is equivalent to the command shown in <<ex-with-command>>.

.antora base call with explicit command and playbook argument
[#ex-with-command]
 $ antora generate antora-playbook.yml

Let's break down this command:

. The command assumes that the Antora CLI is available on the `PATH` (e.g., installed globally).
Otherwise, it would be necessary to replace `antora` with the path to the `antora` bin script (e.g., `npx antora`).
. The base call, `antora`, tells the Antora CLI to run, which reads the remaining command and argument.
. The command specified (implicitly or explicitly) is `generate`.
You don't see the command in <<ex-simple>> because it's optional, but Antora implies it's there if not present.
The options and arguments that follow the command apply to the command, so control changes hands to the command at this point.
. The `generate` command requires an explicit argument that <<specify-playbook,specifies the filesystem path of a playbook file>> relative to the current working directory.
In <<ex-simple>>, the relative filesystem path to the playbook file is [.path]_antora-playbook.yml_.
That is, the command is being executed from the same directory where the playbook file is located.

[#specify-playbook]
== Specify a playbook

The `generate` command, whether implicit or explicitly entered, requires an argument that specifies the filesystem path of a playbook file relative to the xref:primer.adoc#working-directory[current working directory].

For the next example, let's use a playbook file named [.path]_antora-playbook.yml_ that's located in [.path]_home/my-projects/a-project/docs-site_.
As shown directly before the command prompt (`$`) in <<ex-working>>, the working directory is [.path]_docs-site_.
That means the processes associated with the `antora` and `generate` commands as well as the playbook argument will be interpreted relative to [.path]_docs-site_.
Since the playbook file, [.path]_antora-playbook.yml_, happens to be located in the working directory, only the playbook's file name needs to be specified.

.Specify a playbook located in the working directory
[#ex-working]
 docs-site $ antora antora-playbook.yml

When the playbook isn't stored in the working directory, the playbook argument must include the path relative to the working directory or the full path to the playbook file from the filesystem's root directory.

The working directory in <<ex-relative>> is [.path]_my-projects_.
The playbook file is stored in [.path]_home/my-projects/a-project/docs-site_.

.Specify the filesystem path to the playbook
[#ex-relative]
 my-projects $ antora a-project/docs-site/antora-playbook.yml

In <<ex-relative>>, the playbook's filesystem path relative to the working directory is entered as the command's sole argument.

=== Playbook file extension

The file extension of the playbook doesn't need to be specified.
Antora auto-detects the file extension as long as the playbook argument includes the file's stem (e.g., [.path]_antora-playbook_).

The playbook argument in <<ex-detect>> doesn't have a file extension, so Antora will look for a file matching the playbook's file stem relative to the working directory.

.Auto-detection of the playbook file extension
[#ex-detect]
 docs-site $ antora antora-playbook

Antora's search order for playbook file formats is YAML, then JSON, and then TOML.

NOTE: You can see more examples of the `antora` and `generate` commands in xref:ROOT:run-antora.adoc#run-antora[Run Antora].

[#help]
== Display the Antora CLI help

If you've read this whole page, you already know how to display the main help text for the Antora CLI.
Just type `antora` by itself and press kbd:[Enter].
But there's a more idiomatic way to do it.

The Antora CLI accepts xref:options.adoc[options].
One such option is the help option, `-h` or `--help`.
This option will short-circuit the execution of the program and instead display the <<usage,usage statement>>.
The usage statement contains information about the program and its commands, options, and arguments.

The command in <<ex-base-help>> will display help for the `antora` program.

.Display help for the antora base call
[#ex-base-help]
 $ antora -h

Another way to display the help is to use the implicit `help` command:

 $ antora help

As suggested at the end of the usage statement, you can also display help for the `generate` command by including the name of the command to the base call and moving the `-h` option after it.

.Display help for the generate command
 $ antora generate -h

You can also write this command using the implicit `help` command:

 $ antora help generate

There are many more options supported by the Antora CLI, which are covered in xref:options.adoc[].

// /docs/modules/cli/pages/options.adoc
[[options.adoc]]
= CLI Options

You can configure the behavior of the Antora CLI and various playbook keys directly from your terminal using command line options.
This page lists these options, how to specify them, and how they are used.

== Precedence

The CLI options will override the value of corresponding keys defined in the playbook file as well as any environment variables.

== Global options

The options in the table below apply to the xref:index.adoc#usage[antora base call] and impact the behavior of the Antora CLI as a whole.

[cols="2,2,2,4"]
|===
|Option |Default |Values |Notes

|`-h`, `--help`
|_Not applicable_
|_Not applicable_
|Displays information about the command usage and its options and arguments.
See xref:index.adoc#help[Display Antora CLI help].

|[[require]]`-r`, `--require`
|Not set
|Node.js package (i.e., module) name or filesystem path to a script
|Requires additional code (a Node.js module or a local JavaScript file) before Antora is loaded.
May be specified multiple times.
See xref:playbook:asciidoc-extensions.adoc#preload-extensions[Preload Asciidoctor extensions].

|`--stacktrace`
|`false`
|<<boolean-value,Boolean>>
|Prints the stacktrace to the console if the application fails.
See <<ex-boolean-true>> and xref:ROOT:run-antora.adoc#error-stacktrace[Show error stacktrace].

|`-v`, `--version`
|_Not applicable_
|_Not applicable_
|Displays the version of the CLI and default site generator.
|===

[#generate-options]
== generate command options

The options in the table below apply only to the `generate` command.

[cols="2,2,2,4"]
|===
|Option |Default |Values |Notes

|[[sourcemap]]`--asciidoc-sourcemap`
|`false`
|<<boolean-value,Boolean>>
|See xref:playbook:asciidoc-sourcemap.adoc[].

|[[attribute]]`--attribute`
|Not set
|AsciiDoc attribute in the form `<name>` or `<name=value>`
|May be specified multiple times.
See xref:playbook:asciidoc-attributes.adoc[] and <<ex-name-value-pair>>.

|[[cache-dir]]`--cache-dir`
|xref:playbook:runtime-cache-dir.adoc#default[Varies by operating system]
|Filesystem path
|See xref:playbook:runtime-cache-dir.adoc[] and
xref:playbook:environment-variables.adoc[ANTORA_CACHE_DIR variable].

|[[clean]]`--clean`
|`false`
|<<boolean-value,Boolean>>
|This option xref:playbook:output-dir.adoc#clean-warning[erases entire folders and their files]; use it with great care!
See xref:playbook:output-dir.adoc#clean-key[clean key], <<ex-multiple-options>>, and <<ex-boolean-true>>.

|[[extension]]`--extension`
|Not set
|Filesystem path or extension ID
|May be specified multiple times.
See xref:extend:register-extension.adoc[].

|[[fetch]]`--fetch`
|`false`
|<<boolean-value,Boolean>>
|See xref:playbook:runtime-fetch.adoc[].

|`--generator`
|`@antora/site-generator`
|Node.js package (i.e., module) name or filesystem path to a script
|Substitutes Antora's default site generator with an alternate implementation exported by the specified module or script.
Intended for advanced users comfortable with the inner workings of Antora.

|[[git-credentials-path]]`--git-credentials-path`
|_$HOME/.git-credentials_ or +
_$XDG_CONFIG_HOME/git/credentials_
|Filesystem path
|See xref:playbook:private-repository-auth.adoc#custom-credential-path[git credentials file path] and xref:playbook:environment-variables.adoc[GIT_CREDENTIALS_PATH variable].

|`-h`, `--help`
|_Not applicable_
|_Not applicable_
|Displays information about the command usage and its options and arguments.
See xref:index.adoc#help[Display Antora CLI help].

|[[html-extension]]`--html-url-extension-style`
|`default`
a|[%hardbreaks]
`default`
`drop`
`indexify`
|The user-facing URL extension Antora uses for HTML pages.
See xref:playbook:urls-html-extension-style.adoc[].

|[[http-proxy]]`--http-proxy`
|Not set
|A URL that consists of a protocol, domain, and port.
|The URL of the proxy to use when making requests to HTTP URLs.
See xref:playbook:network-proxy.adoc#http-proxy[http_proxy].

|[[https-proxy]]`--https-proxy`
|Not set
|A URL that consists of a protocol, domain, and port.
|The URL of the proxy to use when making requests to HTTPs URLs.
See xref:playbook:network-proxy.adoc#https-proxy[https_proxy].

|[[key]]`--key`
|Not set
|API key in the form `<name=value>`
|May be specified multiple times.
See xref:playbook:site-keys.adoc[] and <<ex-multiple-values>>.

|[[failure-level]]`--log-failure-level`
|`fatal`
a|[%hardbreaks]
`fatal`
`error`
`warn`
`none`
|See xref:playbook:runtime-log-failure-level.adoc[] and xref:playbook:environment-variables.adoc#failure-level[ANTORA_LOG_FAILURE_LEVEL variable].

|[[log-file]]`--log-file`
|`stderr` if format is `pretty`, `stdout` otherwise
a|
[%hardbreaks]
`stdout` (or `1`)
`stderr` (or `2`)
Filesystem path
|See xref:playbook:runtime-log-destination.adoc#file-key[file key] and xref:playbook:environment-variables.adoc#log-file[ANTORA_LOG_FILE variable].

|[[log-format]]`--log-format`
|`pretty` if CI=true or terminal is interactive, otherwise `json`
a|[%hardbreaks]
`json`
`pretty`
|See xref:playbook:runtime-log-format.adoc[format key] and xref:playbook:environment-variables.adoc#log-format[ANTORA_LOG_FORMAT variable].

|[[log-level]]`--log-level`
|`warn`
a|[%hardbreaks]
`fatal`
`error`
`warn`
`info`
`debug`
`all`
`silent`
|See xref:playbook:runtime-log-level.adoc[] and xref:playbook:environment-variables.adoc#log-level[ANTORA_LOG_LEVEL variable].

|[[log-level-format]]`--log-level-format`
|`label`
a|[%hardbreaks]
`label`
`number`
|See xref:playbook:runtime-log-format.adoc#level-format-key[level_format key] and xref:playbook:environment-variables.adoc#log-level-format[ANTORA_LOG_LEVEL_FORMAT variable].
Only applies when the <<log-format,log format>> is `json`.

|[[noproxy]]`--noproxy`
|Not set
|A comma-separated list of domains or `*`
|Domains of HTTP or HTTPS requests that should not be proxied.
See xref:playbook:network-proxy.adoc#no-proxy[no_proxy].

|`--quiet`
|`false`
|<<boolean-value,Boolean>>
|Messages aren't written to stdout.

|[[redirect-facility]]`--redirect-facility`
|`static`
a|[%hardbreaks]
`disabled`
`gitlab`
`httpd`
`netlify`
`nginx`
`static`
|See xref:playbook:urls-redirect-facility.adoc[] and <<ex-multiple-options>>.

|`--silent`
|`false`
|<<boolean-value,Boolean>>
|Suppresses all messages, including warnings and errors.

|[[start-page]]`--start-page`
|Not set
|Antora page ID
|See xref:playbook:site-start-page.adoc[].

|[[title]]`--title`
|Not set
|Title of the site
|See xref:playbook:site-title.adoc[] and <<ex-option-quotes>>.

|[[to-dir]]`--to-dir`
|[.path]_build/site_
|Filesystem path
|Be careful specifying this option in combination with `--clean`.
See xref:playbook:output-dir.adoc[] and <<ex-option-value>>.

|[[ui-bundle]]`--ui-bundle-url`
|Not set
|URL or filesystem path
|See xref:playbook:ui-bundle-url.adoc[] and <<ex-multiple-options>>.

|[[site-url]]`--url`
|Not set
|Absolute or pathname base URL of site
|See xref:playbook:site-url.adoc[] and xref:playbook:environment-variables.adoc[URL variable].
|===

== Pass options to the CLI

You can specify multiple options to a command.
A command must start with the xref:index.adoc#usage[antora base call] and end with the xref:index.adoc#specify-playbook[playbook file argument].
The xref:index.adoc#generate-command[generate command] is implied if not present, so it doesn't have to be specified explicitly.
Remember that the command you type executes relative to the xref:primer.adoc#working-directory[current working directory].

.Pass multiple options to the CLI
[#ex-multiple-options]
 $ antora --ui-bundle-url ./../ui-bundle.zip --redirect-facility nginx --clean antora-playbook

In <<ex-multiple-options>>, the option `--ui-bundle-url` is assigned a value that specifies a local filesystem path relative to the working directory.
The `--redirect-facility` is assigned the built-in value `nginx`.
The <<boolean-value,boolean option>>, `--clean`, is enabled by entering its name without a value.

Some options can be specified multiple times.
These are keys that correspond to a map of values.
Examples include `--key` and `--attribute`.
Each value must be preceded by the option's flag.

.Specify an option multiple times
[#ex-multiple-values]
 $ antora --key support=587tyr999 --key tracer=ID-${spawn} antora-playbook

In <<ex-multiple-values>>, the `--key` option has been assigned two values in <<name-value,the form name=value>>.

== Value types

There are two ways to assign a value to an option.
The option flag and its value can be written with a single space between them: `--option value`.
Or, it can be written using an equals sign (`=`) between the option flag and the value: `--option=value`.
Which form you choose is a personal preference.

TIP: To assign an empty value, you must use the form `--option ''` or `--option=`.
You cannot use the form `--option` by itself as this will be interpreted as a boolean option.

In <<ex-option-value>>, the option `--to-dir` is assigned the value `prod`.
When Antora runs, a folder named [.path]_prod_ will be created relative to the working directory and the site files written to it.

.Assign a value to an option
[#ex-option-value]
 $ antora --to-dir prod antora-playbook

Values that contain spaces must be surrounded by quotation marks: `--option 'Value with Spaces'` or `--option='Value with Spaces'`.
In <<ex-option-quotes>>, the option `title` is assigned the value `My Docs`.
The generated site's title will be _My Docs_.

.Assign a value containing spaces to an option
[#ex-option-quotes]
 $ antora --title 'My Docs' antora-playbook

[#name-value]
=== Name=value values

The `--attribute` and `--key` options accept values in the form `name=value`, where `name` represents the name of the AsciiDoc attribute or API key, respectively.
In <<ex-name-value-pair>>, the attribute `page-team` is assigned the value `Coco B`.
The `@` at the end of the value indicates that the attribute is xref:ROOT:component-attributes.adoc#soft-set[soft set].

.Assign a name=value value to an option
[#ex-name-value-pair]
 $ antora --attribute page-team='Coco B@' antora-playbook

[#boolean-value]
=== Boolean values

Boolean options turn a behavior on or off.
To activate a boolean option, type it on the command line.

.Activate a boolean option
[#ex-boolean-true]
 $ antora --stacktrace antora-playbook

When a boolean option is activated in a playbook file, it cannot be deactivated from the command line.

// /docs/modules/cli/pages/primer.adoc
[[primer.adoc]]
= CLI Primer

If you aren't familiar with command line interfaces, the following sections provide some basic information about command line and terminal concepts used in this documentation.

== Command inputs and structure

The Antora CLI accepts command inputs in the form of a base call, a command (for the program), options, and arguments.
Once entered in a terminal, the command is executed using the specified inputs.

 $ antora <command> [options] <arguments>

base call:: The Antora CLI command starts with the xref:index.adoc#usage[base call], which is the name of the program (i.e., `antora`).
This tells the command interpreter to execute the Antora CLI.
If the system cannot find the program name by itself, you must specify the path to the `antora` bin script instead (e.g., `npx antora`).

command:: A xref:index.adoc#commands[command] tells Antora what operation to perform.
Only one command can be specified at a time.

option:: One or more xref:options.adoc[options] can be specified after a command.
The full name of an option is prefixed with two hyphens (`--`); a shorthand name is prefixed with one hyphen (`-`).
+
Some options toggle behavior on or off and others accept values.
Options that accept values can be written using a single space between the option's name and value (`--option value`) or using an equals sign between the name and value (`--option=value`).

argument:: An argument is entered after the base call and any options.
You can think of an argument as an anonymous options.
The `generate` command only accepts a single argument, which is the xref:index.adoc#specify-playbook[path to the playbook file].

environment variable:: xref:playbook:environment-variables.adoc[Environment variables] (which are not present in the command itself) are read from your terminal's state.
An environment variable overrides the corresponding key in the playbook file, but is itself overridden by the corresponding CLI option.

[#terminal-conventions]
== Terminal conventions

If you're new to terminal applications, here are the common conventions used in this documentation that represent a terminal and describe how you'll interact with it.

Prompt (`$`)::
The terminal command prompt is shown as a dollar sign (`$`) in the examples throughout this documentation.
The prompt you see when you open your terminal depends on the terminal application you use.
*Don't include the `$` prompt when you type or copy commands.*

[[working-directory]]Working directory::
+
--
Every command is run from a current working directory.
The processes associated with a command's inputs are interpreted relative to the working directory.
Your current working directory is often displayed directly to the left of the terminal's command prompt (`$`), however, this is dependent on the terminal application you're using and how its configured.

A few examples in this documentation show the name of the working directory in front of the prompt as a helpful hint.

 name-of-working-directory $ antora antora-playbook

*Don't include this text or the prompt when copying the command.*
--

Replaceable input::
Many options are defined according to your content, environment, and site requirements.
Some command line examples in this documentation call out the input you define with a set of angle brackets (`< >`).
The text inside the brackets describes the input or represents a common input format, e.g., `--require <path/to/library-script>`, `--title '<Title of Your Site>'`.
When composing the command in your terminal, replace the representative text with your input and don't enclose it in angle brackets (`< >`).

Command output::
If a command returns information, the output is displayed in your terminal on the lines beneath the executed command.
The command prompt (`$`) is not displayed on the output lines.

// /docs/modules/ROOT/pages/cache.adoc
[[cache.adoc]]
= Configure Antora's Cache

== About Antora's cache

When Antora runs the first time, it will save resources it fetches over the network in a local cache.
Antora caches two types of resources:

* cloned git repositories
* downloaded UI bundles

Antora stores these resources in the cache directory, which are further organized under the [.path]_content_ and [.path]_ui_ folders, respectively.
The xref:playbook:runtime-cache-dir.adoc#default[default cache directory] varies by operating system.

== Override the default cache location

You can override the default cache location--listed here in order of precedence--using:

* the xref:cli:options.adoc#cache-dir[--cache-dir] option from the CLI,
* the xref:playbook:environment-variables.adoc[ANTORA_CACHE_DIR environment variable], or
* the xref:playbook:runtime-cache-dir.adoc[cache_dir key] in the playbook.

== Update the cache

If you want Antora to update the cache on subsequent runs, pass the xref:cli:options.adoc#fetch[--fetch option] to the Antora CLI or set the xref:playbook:runtime-fetch.adoc[fetch key] to `true` in the playbook.
This switch will force Antora to run a fetch operation on each repository it previously cloned.
It will also force Antora to download a fresh copy of the UI bundle, if the URL is remote and the xref:playbook:ui-bundle-url.adoc#snapshot[snapshot key] is `true`.

== Clear the cache

If you want to clear the cache altogether, locate the Antora cache directory on your system and delete it.

// /docs/modules/ROOT/pages/antora-container.adoc
[[antora-container.adoc]]
= Run Antora in a Container
// URLs
:url-docs-job: https://gitlab.com/antora/docs.antora.org/blob/main/.gitlab-ci.yml
:url-docker: https://docs.docker.com
:url-podman: https://podman.io
:url-docker-hub: https://hub.docker.com/r/antora/antora
:url-kroki-npm: https://www.npmjs.com/package/asciidoctor-kroki

The Antora project provides a Docker image that you can use to run the `antora` command inside a container (a process known as [.term]*containerization*).
The benefit of this approach is that you can bypass installing Antora and get right down to running it.
All you need is Docker or Podman.

Assumptions:

* [x] You have {url-docker}[Docker] (command: `docker`) or {url-podman}[Podman] (command: `podman`) installed on your machine.
* [x] The Docker daemon is running on your machine (not required when using Podman).
* [x] You have configured your own xref:playbook:index.adoc[playbook] or you're using the Demo playbook.

On this page, you'll learn:

* [x] How to run Antora inside a container using the official Docker image for Antora.
* [x] How to give the container access to a local directory.
* [x] How to extend the Docker image for Antora to create your own image.

== Docker image for Antora

{url-docker}[Docker] is a tool for running container images (officially OCI images).
You can think of a container image as an application in a box.
Inside that box is everything you need to run the application, including the code, the runtime, the settings, and even the operating system itself.
Containers not only isolate software from the host environment, they also make it easy to get up and running quickly.
And that's a perfect way to discover and explore Antora!

The Antora project provides an official Docker (OCI) image named `antora/antora` for running Antora inside a container.
This image is published to the {url-docker-hub}[antora/antora project on Docker Hub^].

This image is a drop-in replacement for the `antora` command.
Rather than installing the `antora` command on your own computer or in a CI environment, you simply run the command by running the container.
In fact, the {url-docs-job}[CI job for the Antora documentation site] uses this image to generate the documentation you're currently reading.

Let's find out how to run it.

== Run the Antora image

To demonstrate how to use this image, we'll be using the Antora demo site.
Start by cloning the playbook repository for the demo site, then switch to the newly created folder:

 ~ $ git clone https://gitlab.com/antora/demo/docs-site.git && cd "$(basename $_ .git)"

Next, execute the `docker run` command to invoke the entrypoint command (i.e., `antora`) for this image using the {url-docker}[Docker client]:

 docs-site $ docker run -u $(id -u) -v $PWD:/antora:Z --rm -t antora/antora antora-playbook.yml

This command spins up a new container from the image, mounts the current directory as the path [.path]_/antora_ inside the container, runs the `antora` command (as the current user), then stops and removes the container.
It's exactly like running a locally installed `antora` command, only you're using container superpowers to do it!

[#permission-denied-error]
.Fix the permission denied error when accessing /.cache
****
If your local uid (i.e., `$(id -u)`) is not 1000, you may encounter the following error when running Antora in the container:

[.output]
....
error: EACCES: permission denied, mkdir '/.cache'
....

This happens because the default cache directory is resolved relative to the user's home directory and the home directory of an unmapped user is [.path]_/_.
That's why you see the path [.path]_/.cache_ in the message, which is not a writable location.

The solution to this problem is to <<cache-dir,modify the location of the cache directory>>.
****

Alternately, you can execute the `podman run` command to invoke the entrypoint command for this image using {url-podman}[Podman]:

 docs-site $ podman run -v $PWD:/antora:Z --rm -t antora/antora antora-playbook.yml

The advantage of Podman is that it's more secure.
It runs in user space and does not rely on a daemon.
To continue using Podman, replace `docker` with `podman` (and drop the `-u` option) in any of the commands below.

=== Align with local paths

If you use the volume mapping `$PWD:/antora:Z`, you may notice that local paths reported by Antora don't map back to your system.
That's because, as far as Antora is concerned, [.path]_/antora_ is the current working directory.
To remedy this problem, you need to map your current working directory into the container, then switch to it before running Antora.
To do so, use this volume mount instead:

 -v $PWD:$PWD:Z -w $PWD

Notice the addition of the `-w` option.
This option tells Antora to switch from [.path]_/antora_ to the directory you have mapped.
Now, when Antora reports local paths, they will match paths on your host system.

=== Option flags

Here are explanations for some of the option flags used in the run command:

`-t`::
This flag allocates a pseudo-TTY, which is required if you want to see progress bars for git operations.
If you don't need to see these progress bars, you can omit this flag.

`-u $(id -u)`::
This option tells Docker to run the entrypoint command (i.e., `antora`) as the current user.
If you use the `:Z` modifier on the volume mount without specifying this option, the generated files are (most likely) written as the root user (and thus become rather tricky to delete).
This option is _not required_ when using Podman.

`-v`::
A volume mount that maps the current directory on your local system (represented by `$PWD`) to the [.path]_/antora_ directory inside the container.
This allows files written by the container to be visible on your local system, which is the whole point of using the container.

`:Z` (on the volume mount)::
This flag is only required if you're running a Linux distribution that has SELinux enabled, such as Fedora.
This option allows you to use volume mounts when running SELinux.

`-w`::
This option tells Docker to switch to the specified directory (i.e., `$PWD`) before invoking the entrypoint command.
You will use this option if you want to run the `antora` command from a directory other than [.path]_/antora_ inside the container.

CAUTION: Although tempting, the `--privileged` flag is not needed.
To learn more about using volume mounts with SELinux, see the blog post http://www.projectatomic.io/blog/2015/06/using-volumes-with-docker-can-cause-problems-with-selinux/[Using Volumes with Docker can Cause Problems with SELinux].

[#cache-dir]
=== Cache directory location

If Antora cannot write the default xref:cache.adoc[cache directory], or you simply want the cache directory to be located inside the mounted directory, specify a playbook-relative directory using the `--cache-dir` option:

 docs-site $ docker run -u $(id -u) -v $PWD:/antora:Z --rm -t antora/antora --cache-dir=./.cache/antora antora-playbook.yml

An alternate approach is to override the HOME directory of the container user:

 docs-site $ docker run -u $(id -u) -e HOME=/antora -v $PWD:/antora:Z --rm -t antora/antora antora-playbook.yml

In both cases, all files either cached or generated by Antora are neatly contained inside the mounted directory and owned by the current user.
This configuration also has the benefit that the cache will be preserved between runs, so it's a good idea to use regardless.

== Enter the container

If you want to shell into the container instead of having it run the `antora` command, append the name of the shell (`ash`) to the container run command:

 docs-site $ docker run -u $(id -u) -v $PWD:/antora:Z --rm -it antora/antora ash

Now you can run the `antora` command from anywhere inside the running container.
This mode is useful to use while editing.
Since the container continues to run, you can quickly execute the `antora` command.

If the base Antora image doesn't include everything you need for your site, you can extend it.

== Extend the Antora image

You can use this image as a base for your own Docker image.
The image comes preconfigured with Yarn so you can install additional extension libraries, such as {url-kroki-npm}[Asciidoctor Kroki] (`asciidoctor-kroki`) for adding diagram support to AsciiDoc.

. Clone the docker-antora repository and switch to it:

 ~ $ git clone https://gitlab.com/antora/docker-antora.git && cd "$(basename $_ .git)"

. Create a custom Dockerfile file named [.path]_Dockerfile.custom_.
. Populate the file with the following contents:
+
.Dockerfile.custom
[,docker]
----
FROM antora/antora

RUN yarn global add asciidoctor-kroki # <.>
----
<.> Adds a custom extension to the base image.

. Build the image using the following command:

 docker-antora $ docker build -t local/antora:custom -f Dockerfile.custom .

Once the build is finished, you'll have a new image available on your machine named `local/antora:custom`.
To see a list of all your images, run the following command:

 $ docker images

To run this image, switch back to your playbook project and run the container as follows:

 docs-site $ docker run -u $(id -u) -v $PWD:/antora:Z --rm -t local/antora:custom antora-playbook.yml

If you want to share this image with others, you'll need to publish it.
Consult the {url-docker}[Docker documentation] to find out how.

// /docs/modules/ROOT/pages/how-antora-builds-urls.adoc
[[how-antora-builds-urls.adoc]]
= How Antora Builds URLs

Antora builds the URLs for publishable resources--pages, attachments, and images--using information from resource IDs, the site URL, and URL settings in the site's playbook.

[#site]
== The site URL

_User-defined._
_Optional._

A [.term]*site URL* identifies the location where your site is published.
A site URL is defined by assigning an allowable value to the xref:playbook:site-url.adoc[site.url key in the playbook], xref:cli:options.adoc#site-url[--url command line option], or xref:playbook:environment-variables.adoc#site-url[URL environment variable].
There are two types of allowable site URLs: absolute and root-relative.

Antora is designed to generate sites that are viewable offline and from a local filesystem.
For this reason, Antora doesn't require a site URL to build a site.
However, when Antora doesn't detect an allowable site URL value, it automatically deactivates certain publishing features.
See xref:playbook:site-url.adoc#site-url-features[Features that depend on the site URL] for a complete list of affected features.

[#absolute-site]
=== Absolute site URL

An absolute site URL begins with _https://_ and is followed by the site domain or subdomain.

.Absolute site URL
[#fig-absolute]
image::ROOT:site-url-absolute.svg[Diagram of an absolute site URL]

If you're publishing your site to a subfolder, the site domain is followed by a subpath.

.Absolute site URL with subpath
[#fig-subpath]
image::ROOT:site-url-subpath.svg[Diagram of an absolute site URL with a subpath]

The [[subpath-def]][.term]*subpath*, also known as a *path segment* or *pathname*, represents the location from the root of the domain where the site managed by Antora is located.
That is, if your site is published to a subfolder of your domain, then the absolute site URL should include this path.
See xref:playbook:site-url.adoc#absolute-site-url[Configure an absolute site URL] and xref:playbook:site-url.adoc#subpath[When should the site URL include a subpath?] for more information about using an absolute site URL with a subpath.

[#root-relative]
=== Root-relative site URL

A root-relative site URL begins with a forward slash (`/`) and, if more than one character, is the <<subpath-def,subpath>>.

.Root-relative site URL
[#fig-root]
image::ROOT:site-url-root-relative.svg[Diagram of a root-relative site URL]

See xref:playbook:site-url.adoc#root-relative-site-url[Configure a root-relative site URL] for more information.

[#pathname]
=== Site pathname

_Computed._

The site pathname represents an internal property, `site.path`, that Antora uses when a publishing feature requires URLs that are relative to the root of your site.
Antora computes the site pathname based on the site URL.
The site pathname value is typically empty except when an absolute site URL contains a subpath or the site URL is a root-relative site URL.
If `site.url` is an absolute site URL that contains a subpath, Antora extracts the subpath and uses it as the site pathname.
For example, using the absolute site URL in <<fig-subpath>>, Antora extracts the subpath, `/docs`, and assigns it to `site.path`.
When the value assigned to `site.url` is a root-relative site URL, Antora extracts the entire value and uses it as the site pathname.
Antora appends the <<resource,resource URLs>> to the site pathname to create a <<domain-relative,domain-relative URLs>> when a feature, such as redirects, requires the computed URLs be relative to the site domain or site root.

== Right URL, right place

Antora generates and manages all URLs in your site.
Antora builds the <<resource,resource URLs>> for publishable resources as absolute paths relative to the <<pathname,site pathname>>.
Then, the resource URLs are converted to URLs relative to the current page, the site URL (site-pathname/resource-URL), or absolute URLs (absolute-site-URL/resource-URL) depending on the context and feature in which the URL is used.

[#resource]
=== Resource URL

_Computed._

Antora computes a resource URL for each publishable resource in a site.
A [[publishable-def]][.term]*publishable resource* is a source file that belongs to the pages, images, and attachments families.
Resource URLs are computed as absolute paths relative to the <<pathname,site pathname>> so they are normalized across the application.

A resource URL begins with a forward slash (`/`) and contains segments that Antora derives from the ID of a resource and the URL settings in the playbook.
These segments often represent the component name, version, module, and resource file name.

.Resource URL computed by Antora
[#fig-resource]
image::ROOT:resource-url.svg[Diagram of the resource URL computed by Antora]

Certain playbook keys can modify, add, or remove portions of a resource URL.
Some resource URL segments are added or absent if a resource isn't a page or it belongs to a _ROOT_ component, an unversioned component version, or a _ROOT_ module.
See <<segments>> for information about each segment and from where Antora extracts their values.

Antora assigns the computed resource URL of a resource to the internal property, `pub.url`, where `pub` is the property group for properties that pertain to publishing.

=== Relativized URL

_Computed._

Antora converts the references to resources into relative URLs.
Antora refers to this translation as [.term]*relativize*.

Where the relativize translation occurs depends on the resource, which can be a page, image, attachment, or UI resource.
For xrefs and images in AsciiDoc, Antora calls relativize internally in the extended HTML converter for Asciidoctor.
For navigation entries, breadcrumbs, pagination links, and the page version selector, the UI uses the relativize helper to convert a resource URL into a relative URL from the current page.
For UI resources, the UI uses the `uiRootPath` variable to create a relative URL to the resource.

There are two reasons Antora creates relative URLs to link to resources.
First, it keeps the length of the URL as short as possible to curb the size of the generated HTML.
More importantly, it ensures that the URL is portable between environments.
It's a key reason why an Antora site works when viewed directly from the filesystem.
The relative references don't rely on a web server to resolve the URL.
Instead, they start from the current page and walk up and down the filesystem to the target resource, which works everywhere.
For the same reason, it simplifies publishing because the site is not bound to a given domain or site root.

[#domain-relative]
=== Domain-relative URL

_Computed_.

Antora computes domain-relative URLs when creating rewrite rules for page aliases, component version start pages, and the latest version segment `redirect:to` and `replace` strategies.
If a non-empty value is assigned to the site pathname, Antora prepends the site pathname to the resource URL.
When the site pathname is empty, a resource URL is already equivalent to the domain-relative URL.
For example, using the resource URL in <<fig-resource>>, and the site pathname `/docs`, Antora computes the domain-relative URL shown in <<fig-domain-relative>>.

.Domain-relative URL computed by Antora
[#fig-domain-relative]
image::ROOT:domain-relative-url.svg[Diagram of a domain-relative URL computed by Antora]

If the `site.url` key isn't set, Antora doesn't compute domain-relative URLs and the publishing features that require them are automatically deactivated at runtime.

=== Absolute URL

_Computed_.

An absolute URL is the full URL for a publishable resource.
To compute an absolute URL, Antora starts with an <<absolute-site,absolute site URL>> and appends a resource URL.
For example, using the site URL in <<fig-subpath>> and resource URL in <<fig-resource>>, Antora computes the absolute URL shown in <<fig-pub-absolute>>.

.Absolute URL computed by Antora
[#fig-pub-absolute]
image::ROOT:published-absolute-url.svg[Diagram of an absolute URL computed by Antora]

<<fig-pub-absolute>> is an example of how a page's URL is displayed in the browser address bar or in the sitemap.
Antora computes absolute URLs when generating sitemaps and computing the canonical URL for the meta tag in the head of each page.
If the `site.url` key isn't assigned an absolute site URL, the publishing features that require absolute URLs are automatically deactivated at runtime.

[#segments]
== Resource URL segments

The following sections describe each segment of a resource URL and from where Antora extracts the value of each segment.
The segments of resource URLs for published pages are typically organized into the sequence shown in <<fig-page>>.

.Resource URL segments for a published page
[#fig-page]
image::ROOT:page-url-segments.svg[Diagram of the page URL segments assembled by Antora]

The resource URLs for images and attachments contain an additional family segment, `_images` or `_attachments`, respectively.
The family segment follows the module segment as shown in <<fig-image>>.

.Resource URL segments for a published image
[#fig-image]
image::ROOT:resource-url-segments-with-family.svg[Diagram of the resource URL segments for an image assembled by Antora]

[#component]
=== Component segment

The component segment of the URL is the name of the component the published resource belongs to.
When the resource belongs to the specially named `ROOT` component, the component segment is dropped from the URL.
A component name is specified by the xref:ROOT:component-name-key.adoc[name key] in an xref:ROOT:component-version-descriptor.adoc[_antora.yml_ file].

The <<resource,resource URL>> that Antora computes and assigns to the `pub.url` property of a resource always starts with this segment.

[#version]
=== Version segment

The version segment of a URL is the actual version or symbolic version of the component version the published resource belongs to.
The [.term]*actual version* is the value assigned to the xref:ROOT:component-version-key.adoc[version key] in a component version's xref:ROOT:component-version-descriptor.adoc[_antora.yml_ file] or to the `version` key for a content source that's specified in the playbook.
All component versions have an actual version, though that version may be defined as unversioned.
When a component version is xref:ROOT:component-with-no-version.adoc[unversioned], the version segment is dropped from the URLs of its resources.

The [.term]*symbolic version* is an optional configuration setting that only applies to the version segment if the resource belongs to the latest version or latest prerelease version of a component.
The symbolic version replaces the actual version in the URL.
A symbolic version is defined using the `latest_version_segment` key or `latest_prerelease_version_segment` key in the playbook.
The symbolic version doesn't apply to component versions that are unversioned; the version segment is always dropped from their resources`' published URLs.

[#module]
=== Module segment

Antora derives the module segment from the xref:ROOT:module-directories.adoc#module[module directory name] where a resource's source file is stored.
When the resource belongs to the specially named `ROOT` module, the module segment is dropped from the URL.
See xref:ROOT:module-url-segment.adoc[] for examples and more information.

[#family]
=== Family segment

The family segment only applies to the resource URLs of images and attachments.
Image and attachment URLs include a family segment that's prepended with an underscore (`_`).
For images, this segment is `_images`.
For attachments, this segment is `_attachments`.
The URLs for pages do not contain a family segment.

[#relative-path]
=== Relative path segment

The relative path segment is derived from the family-relative path of the resource's source file.
For pages, the _.adoc_ extension is dropped and replaced with _.html_ or the specified HTML extension style.
The URLs for other resources maintain the original file extension, such as _.svg_ or _.pdf_.

=== HTML extension

The _.html_ extension and `html_extension_style` key only applies to the URLs of pages.
By default, Antora appends the _.html_ extension to page URLs.
The xref:playbook:urls-html-extension-style.adoc[html_extension_style] playbook key or xref:cli:options.adoc#html-extension[--html-url-extension-style option] modifies this behavior.
The extension can be dropped (`drop`) or dropped and replaced with a forward slash (`indexify`).

The URLs of non-page resources use the file extension of their source files, regardless of the value assigned to `html_extension_style`.

// /docs/modules/ROOT/pages/add-404-error-page.adoc
[[add-404-error-page.adoc]]
= Add a 404 Error Page

Don't worry, you haven't landed on a missing page.
This page is _about_ the 404 error page and how to add it to your published site.

[#about]
== What is a 404 error page?

If the web server cannot locate the page for a URL, it returns a 404 status code to the browser (instead of the normal 200 status code).
This can happen if a visitor clicks on a broken link from within the site or a search engine or by mistyping the URL in the browser location bar.

Rather than showing the visitor a blank page or a low-level error message, the web server will typically display the contents of the 404 error page (herein, the 404 page).

To serve the 404 page, the web server looks for the file [.path]_404.html_ located at the root of the published site.
The contents of this file is used in place of the HTML the visitor would have seen.
The visitor is not redirected to another page, so the original URL is still visible in the browser location bar.

Let's learn how to define the 404 page and add it to your Antora site.

[#define]
== Define the 404 page

In an Antora site, the 404 page is created using a layout template provided by the UI.
For this to work, the UI must define a layout template named *404* located at the path [.path]_layouts/404.hbs_.
Antora uses this template to generate the [.path]_404.html_ file, which it then outputs to the root of your published site.

If you use or extend the xref:antora-ui-default::index.adoc[default UI], the layout template for the 404 page is already provided for you.

The 404 layout template is compiled with a reduced UI model that does not include any information about the current page (since there isn't one) except for `page.title` and `page.layout`.
The template has access to all other variables in the UI model, such as `uiRootPath` and `site.components`.

Unlike for regular pages, the `uiRootPath` and `siteRootPath` template variables are root-relative paths in the 404 template (they begin with /).
This is necessary for the 404 page to work correctly when served by the server.
That's because the 404 page content is served from whatever URL the visitor originally requested, not necessarily where the 404 page is located.

[#activate]
== Activate the 404 page

Antora only generates the 404 page if the `site.url` key in the playbook has a value.
The assumption is that if the site URL is specified, the site is going to be published to a web server.

The value of the `site.url` key can either be an absolute URL or a root-relative path, as explained on the xref:playbook:site-url.adoc[site URL page].
The path segment can be non-empty, which will be addressed in the <<subpath,next section>>.

IMPORTANT: If Antora does not find a layout template in the UI bundle (or supplemental UI) with the name *404*, it will not generate a 404 page for your site (even if the `site.url` key is set in the playbook).

[#subpath]
== Configure the 404 page when publishing to a subpath

Normally, there's nothing else you need to do make the 404 page work.
The web server automatically picks up the [.path]_404.html_ file at the root of the published site and uses it when the visitor lands on a missing page.

However, if you're publishing your site to a subpath of a domain (e.g., _\https://example.org/site-a_), additional configuration is required.

When the URL of your site includes a path segment, the 404 page for your site will no longer be located at the web server root.
Instead, it will be located under a subpath with the rest of the files.
The problem is, the web server doesn't know this subpath is significant (meaning it doesn't know the subpath is the boundary of a discrete site).
As a result, the web server will not know to serve this 404 page in place of a missing page.
So we have to tell it to do so.
We must configure the web server to use the 404 page under the subpath (e.g., _/site-a/404.html_) instead of the one at the default location (i.e., _/404.html_) when serving files for the site.

Here are the three steps required to get this set up.
We'll assume the domain is *example.com*, the subpath is *site-a*, and the web server is *nginx*.

. Define site.url with the subpath in the playbook file, either using an absolute URL:
+
--
[,yaml]
----
site:
  url: https://example.com/site-a
----

or a root-relative path:

[,yaml]
----
site:
  url: /site-a
----

IMPORTANT: The site URL defined in the playbook *must* include the subpath.
Otherwise, the URLs in the 404 page will not be correct (e.g., the URL for the CSS file).
--

. Configure nginx to use the 404.html from the subpath folder for any missing URL that falls under that subpath:
+
--
[listing]
----
location /site-a/ {
  error_page 404 /site-a/404.html;
}
----

NOTE: Adjust the subpath location to match the subpath for your site.
--

. Copy the site files generated by Antora to the subpath under the web server root:
+
--
 $ rsync -r --delete build/site/ /usr/share/nginx/html/site-a

In other words, the subpath folder must be located in the web server root or the root of the virtual host.
--

The Antora demo is an example of this configuration (except the GitLab Pages server automatically maps the 404 page from the subpath for you).
See https://antora.gitlab.io/demo/docs-site/component-b/2.0/no-such-page.html.
Notice that the URL for the CSS file is the root-relative path [.path]_/demo/docs-site/_/css/site.css_.

// /docs/modules/ROOT/pages/sitemap.adoc
[[sitemap.adoc]]
= Automatic Sitemap

If the value of the site URL defined in the playbook is an absolute URL, Antora will automatically generate a sitemap and output it to the root of the generated site.

== Sitemap structure

The sitemap that Antora produces consists of several files.
Rather than just a single [.path]_sitemap.xml_ file, Antora partitions the sitemap into multiple files.
The [.path]_sitemap.xml_ file is a sitemap index that lists each of the individual component sitemap files.
The sitemap files are placed at the root of the published site, where a search engine will expect to find them.

....
404.html
index.html
robots.txt
sitemap.xml
sitemap-colorado.xml
sitemap-wyoming.xml
...
....

Each component sitemap file is named [.path]_sitemap-<name>.xml_, where `<name>` is the component name.
The file contains a `<url>` entry for each publishable page in the site.
No other type of resource is included in the sitemap.

The value of the `<loc>` tag for a `<url>` is the absolute URL to that page.
The `<url>` value is constructed by combining the site URL (including the subpath) with the (root-relative) URL of the page.
The value of the `<lastmod>` tag for a `<url>` is the date the site was generated.

The entries are sorted merely to ensure that the order remains stable between runs.

== Example

Let's look at an example.
We'll assume that your site has two components, named colorado and wyoming, and the site URL is `\https://docs.example.org`.
Here's how the [.path]_sitemap.xml_ might look:

[,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
<sitemap>
<loc>https://docs.example.org/sitemap-colorado.xml</loc>
</sitemap>
<sitemap>
<loc>https://docs.example.org/sitemap-wyoming.xml</loc>
</sitemap>
</sitemapindex>
----

Here's how the [.path]_sitemap-colorado.xml_ might look:

[,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
<url>
<loc>https://docs.example.org/colorado/6.0/index.html</loc>
<lastmod>2021-12-24T23:00:00.123Z</lastmod>
</url>
...
</urlset>
----

// /docs/modules/ROOT/pages/publish-to-github-pages.adoc
[[publish-to-github-pages.adoc]]
= Publish to GitHub Pages

Antora is designed to create sites that run anywhere, whether it be on a static web host or the local filesystem.
However, some hosts offer "`features`" that mess with Antora's output.
GitHub Pages is one of those hosts.

== Jekyll and underscore files

By default, GitHub Pages runs all files through another static site generator named Jekyll (even if your repository is not set up to use Jekyll).
Since Antora already produces a ready-made site, there's absolutely no need for this step.
But it's more than just the wasted effort.

Jekyll has the nasty side effect of removing all files that begin with an underscore (`+_+`).
Why is this a problem?
By default, Antora puts UI files in a folder named `+_+`.
It also places images inside the folder named `+_images+`.
When Jekyll comes through, it wipes out these folders.
As a result, you get no UI and no images.

== .nojekyll

Fortunately, there's a way to disable this "`feature`" of GitHub Pages.
The solution is to add a [.path]_.nojekyll_ file to the root of the published site (i.e., the output directory configured in your playbook).

The presence of the [.path]_.nojekyll_ file at the root of the `gh-pages` branch tells GitHub Pages not to run the published files through Jekyll.
The result is that your Antora-made site will work as expected.

Let's look at two ways to create the [.path]_.nojekyll_ file when you run Antora.

=== Touch the file manually

One way to add this file is to touch the [.path]_.nojekyll_ file in the output directory after Antora runs, but before committing the files to GitHub Pages.
For example:

 $ touch build/site/.nojekyll

Fortunately, there's way to do this without having to run a separate command.

=== Use the supplemental UI

To avoid the need for the extra command, the other way to do it is to inject the file using Antora's xref:playbook:ui-supplemental-files.adoc[supplemental UI] feature.
To do so, add the following `supplemental_files` block under the `ui` category in your playbook file:

.antora-playbook.yml that adds .nojekyll file using supplemental UI
[,yaml]
----
ui:
  bundle:
    url: <url-of-bundle-goes-here>
  supplemental_files:
  - path: ui.yml
    contents: |
      static_files:
      - .nojekyll
  - path: .nojekyll
----

This configuration defines files from memory.
The first file, [.path]_ui.yml_, tells Antora which files to promote to the root of the site (outside the UI folder) using the `static_files` key.
The second file, [.path]_.nojekyll_, gets written to the root of the published site.
Since the `contents` key is absent, Antora will create an empty file (the equivalent of the `touch` command from above).

== Using GitHub Actions

If your playbook repository is hosted on GitHub, you can configure a GitHub Actions workflow to build and publish your site to GitHub Pages.
The benefit of using GitHub Actions is two-fold.
First, you don't have to worry about copying the published files to the gh-pages branch for publishing.
Second, you don't have to worry about the [.path]_.nojekyll_ file since the action handles it for you.
Let's get started!

<<github-actions-workflow>> shows an example of a GitHub Actions workflow that uses the latest stable release of Antora to build and publish your site to GitHub Pages.
This workflow assumes that the name of the default branch of your playbook repository is _main_, that the name of your playbook file is [.path]_antora-playbook.yml_, and that Antora is configured to publish the files to the [.path]_build/site_ directory.
If your site uses different settings, you'll need to update the values in the workflow file accordingly.

..github/workflows/publish.yml builds the Antora site and deploys it to GitHub Pages using GitHub Actions
[#github-actions-workflow,yaml]
----
include::example$github-actions-workflow.yml[]
----

As <<github-actions-workflow>> shows, you can install and invoke Antora directly from the workflow.
This workflow installs a specific release of Antora (both the CLI and site generator packages) and then uses the Antora CLI in the workflow.
The workflow then uses the peaceiris/actions-gh-pages action to publish the site, along with the required [.path]_.nojekyll_ file, to GitHub Pages.

To install and use a different version of Antora, append a version to the package name, such as `antora@3.0.3`.

Let's now take this a step further by adding the https://gitlab.com/antora/antora-lunr-extension[Antora Lunr Extension] to incorporate a search widget in the built site.
First, you need to update your playbook repository and UI to meet the minimum requirements of the Antora Lunr Extension as described in the https://gitlab.com/antora/antora-lunr-extension#usage[README] for that project.
Once that's done, return to the GitHub Actions workflow and configure it to install the extension at the same time it installs Antora.
The result is shown in <<github-actions-workflow-with-lunr>>.

..github/workflows/publish.yml includes the Antora Lunr Extension
[#github-actions-workflow-with-lunr,yaml]
----
include::example$github-actions-workflow-with-lunr.yml[]
----

To install and use a different version of the Antora Lunr Extension, append a version to the package name, such as `@antora/lunr-extension@1.0.0-alpha.5`.

== Using a custom domain

You can serve your site from a different URL than the default <username>.github.io using a Github Pages custom domain.

If you're publishing your site <<Using GitHub Actions>> as the source, then you can configure your custom domain from the menu:Settings[Pages] configuration screen in the GitHub web interface.
No other action is required in the CI workflow.

On the other hand, if you're publishing your site from a branch (e.g., gh-pages), then you need to write the custom domain to a CNAME file at the root of the site.
In order to do so, add the following step to your GitHub Actions workflow file (or the equivalent for whatever CI pipeline you're using) after running Antora.

[,yaml]
----
- name: Create CNAME file
  run: echo my-domain-name.com > build/site/CNAME
----

Alternately, you can use a supplemental UI to add the CNAME file, similar to how the .nojekyll file was added earlier.

.antora-playbook.yml that adds CNAME file using supplemental UI
[,yaml]
----
ui:
  bundle:
    url: <url-of-bundle-goes-here>
  supplemental_files:
  - path: ui.yml
    contents: |
      static_files:
      - CNAME
  - path: CNAME
    contents: |
      my-domain-name.com
----

This configuration defines files from memory.
The first file, [.path]_ui.yml_, tells Antora which files to promote to the root of the site (outside the UI folder) using the `static_files` key.
The second file, [.path]_CNAME_, gets written to the root of the published site and contains the custom domain name, as required by GitHub Pages when publishing from a branch.
The benefit of this approach is that it does not require an extra step in the CI workflow.

Refer to https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site[Managing a custom domain for your GitHub Pages site^] in the GitHub documentation for more information about using a custom domain and how to activate it.

// /docs/modules/ROOT/pages/publish-to-gitlab-pages.adoc
[[publish-to-gitlab-pages.adoc]]
= Publish to GitLab Pages
:url-gitlab: https://gitlab.com
:url-gitlab-docs: https://docs.gitlab.com
:url-gitlab-redirects: {url-gitlab-docs}/ee/user/project/pages/redirects.html
:url-gitlab-ci-cd-concepts: {url-gitlab-docs}/ee/ci/introduction/
:url-gitlab-ci-yml: {url-gitlab-docs}/ee/ci/yaml/gitlab_ci_yaml.html
:url-gitlab-deploy-tokens: {url-gitlab-docs}/ee/user/project/deploy_tokens/

{url-gitlab}[GitLab] is a DevOps platform that provides everything you need to publish your Antora-based documentation to the web.
On this page, we'll explore how to use GitLab to publish your first documentation site using Antora.

== GitLab overview

Each GitLab project provides code hosting (a git repository), continuous integration (GitLab CI), and static web hosting with {url-gitlab-redirects}[redirect support] (GitLab Pages).
GitLab is thus suitable to manage your entire Antora-based documentation site end-to-end, from source to published site.

To use GitLab CI/CD for publishing an Antora site, you need:

* A playbook project, which starts as a local git repository that stores the Antora playbook file.
* Zero or more content projects, each with a git repository that hosts the content files.
* A file named [.path]_.gitlab-ci.yml_ in the root of the git repository in your playbook project, which provides the CI/CD configuration.

Before proceeding, we recommend studying core {url-gitlab-ci-cd-concepts}[CI/CD concepts] and the overview of the {url-gitlab-ci-yml}[.gitlab-ci.yml file] in the GitLab documentation.

== Get started

Begin by creating a new project on GitLab to host your playbook project.
Follow the instructions on that page to push your local git repository to GitLab.
If your playbook refers to other content source repositories, make sure to push those to GitLab as well.

Next, you'll need to configure CI/CD.
You only need to set up GitLab CI/CD in the default branch of your playbook repository.
Antora will fetch content from other repositories that are declared in your playbook automatically.

We'll start with a basic GitLab CI/CD configuration file that uses the Antora Docker image to build a site with Antora and publish it to GitLab Pages.

..gitlab-ci.yml to build and deploy an Antora site
[source,yaml]
----
image:
  name: antora/antora
pages:
  stage: deploy
  interruptible: true
  script:
  - antora --fetch --redirect-facility=gitlab --to-dir=public antora-playbook.yml
  artifacts:
    paths:
    - public
----

Commit the [.path]_.gitlab-ci.yml_ file to git and push it to the remote repository.
That will trigger the first CI/CD pipeline.
If the pipeline succeeds, your site will be accessible at the URL listed on the Pages settings page.

By default, GitLab Pages automatically enables the *Use unique domain* option, which adds a unique number to the URL where the site is hosted.
Chances are, this is not what you want.
It's not only an obscure URL, it can disrupt the use of a custom domain.
Follow these steps to correct it:

. Navigate to the menu:Deploy[Pages] menu option from the project repository.
. De-select the *Use unique domain* option.
. Click btn:[Save changes].

The URL for the GitLab Pages site will now follow this pattern:

 https://<group-name>.gitlab.io/<project-name>

The site will be public even if the project is private.

You can refer to the https://gitlab.com/antora/demo/docs-site[playbook project] for the Antora demo to see another example of building and publishing an Antora site using GitLab Pages that taps into a few additional capabilities of GitLab CI/CD.

== Customize the build

So far, we've relied on the Antora Docker image to run Antora in CI/CD.
The Antora Docker image only provides the Antora core components.
It does not include any extensions.

While using the Antora Docker image is a convenient way to get up and running quickly, we strongly recommend declaring the dependencies of your site within your playbook project (or extending the Docker image).
By doing so, you keep your build self-contained and portable.
This is especially important if you rely on additional packages such as the *@antora/lunr-extension* and *asciidoctor-kroki*.

Let's assume you have the following [.path]_package.json_ file in your playbook project that declares a dependency on Antora, the Antora Lunr Extension, and Asciidoctor Kroki.

.package.json
[,json]
----
{
  "name": "my-docs-site",
  "description": "My Docs Site",
  "private": true,
  "devDependencies": {
    "antora": "~3.0",
    "@antora/lunr-extension": "1.0.0-alpha.8",
    "asciidoctor-kroki": "0.15.4"
  }
}
----

You'll first want to run `npm i` to generate the [.path]_package-lock.json_ file and commit both files.

With that configuration in place, you can modify your GitLab CI/CD configuration to be based on *node:18-alpine*, the base image used by Antora Docker.
You'll then need to fetch the dependencies on each build since the base image does not provide Antora.

..gitlab-ci.yml
[source,yaml]
----
image:
  name: node:18-alpine # <1>
variables:
  ANTORA_CACHE_DIR: .cache/antora # <2>
  NODE_OPTIONS: --max-old-space-size=4096 # <3>
before_script:
- npm ci # <4>
pages:
  stage: deploy
  interruptible: true
  rules:
  - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH # <5>
  cache:
    paths:
    - .cache # <2>
  script:
  - npx antora --fetch --redirect-facility=gitlab --to-dir=public antora-playbook.yml # <6>
  artifacts:
    paths:
    - public # <7>
----
<1> The base image used by Antora Docker, which you can use if you're installing packages locally to the playbook project.
<2> Stores the repository and UI bundle cache between runs.
<3> (optional) Increases the memory reserved for the Node.js to allow Antora to process heavier builds.
<4> Installs dependencies defined in the [.path]_package-lock.js_ file.
Using `npm ci` instead of `npm i` ensures that the versions of your dependencies remain stable between runs.
<5> Only run on the default branch for this repository.
<6> Call Antora using `npx`, which will locate and run the `antora` command installed within the project.
The `--fetch` flag ensure Antora fetches updates into the cache saved from a previous run.
The `--redirect-facility` option makes use of the server-side facility provided by GitLab Pages for performing URL redirects.
The `--to-dir` option ensures the site is published to the location where GitLab Pages looks for files to deploy.
<7> The [.path]_public_ directory is the predefined folder for publishing as site to GitLab Pages.
Note that this value must match the value of the `--to-dir` option passed to the Antora CLI.

If any of your content repositories are private, you can define a `GIT_CREDENTIALS` CI/CD variable that holds the credentials to give Antora access to those repositories in this environment.
You can set up {url-gitlab-deploy-tokens}[deploy tokens] in your content repository to give the CI/CD pipeline in your playbook project (and thus Antora) read-only access to those repositories.

If you want Antora to fail the CI/CD pipeline if there are any warnings or non-fatal errors, add `--log-failure-level=warn` to the `antora` command.
Alternately, you can set the `runtime.log.failure_level` key in the playbook to make it a permanent setting.

// /docs/modules/extend/pages/extensions.adoc
[[extensions.adoc]]
= Antora Extensions

Antora provides an event-based extension facility you can tap into to augment or influence the functionality of the generator.
This extension facility is designed for users of all experience levels.
This page provides a high-level summary of how the extension facility works and introduces you to the concepts and terminology you need to know to create or use extensions.
Subsequent pages step you through creating your first extension.

== Generator events

As described in xref:ROOT:how-antora-works.adoc[], Antora's site generator is a sequence of discrete, functional steps that progressively work to generate a static site.
This pipeline of steps begins with reading the playbook and gathering the source material.
It ends with publishing the HTML files and web assets to the output destination.
Antora's extension facility, which is implemented by Antora's site generator, provides a way to hook custom code into the generator's build process.

Antora's extension facility is event-driven, meaning it works by emitting events.
Events are emitted (aka fired) to notify extension code (i.e., event listeners) of interesting transitions that occur during site generation (i.e., the execution of Antora).
Specifically, once each discrete step in the generator is complete, and at other key transition points, Antora emits a named event (e.g., `contentAggregated`).

Events are handled by functions called listeners, which must be registered with that event.
To hook your code into the operation of Antora, you register extensions that listen to one or more of these events.
These listeners are defined in the register function of the extension.

The listeners of an event can be synchronous or asynchronous, but are called synchronously and in sequence.
Any value returned by an event listener is ignored.
Once all the listeners for an event have finished running, the generator proceeds to the next step.

In brief, Antora extensions register listeners that respond to transition events emitted by the site generator.
Subsequent pages go into detail about how to set up listeners, which events those listeners can observe, and how to access context variables.

== The generator context

The extension facility in Antora is loosely based on the EventEmitter in Node.js.
Antora uses an abstraction over this eventing system called the GeneratorContext, which adapts the EventEmitter for this use case.

When the generator starts, it creates an instance of the GeneratorContext, called the [.term]*generator context*.
This object is then bound to each extension and its event listeners.
The generator context is responsible for keeping track of event listeners, storing the generator functions, managing context variables as they flow through the generator, notifying listeners of an event, and providing helpers to make writing extensions easier.
It's, quite literally, the context of the generator's execution.

Most of the time, you'll interact with the `on` method provided by the generator context to bind your event listener to an event.
You can also use the generator context to provide custom generator functions.

== What's an event listener?

An [.term]*event listener* is a callback function that's invoked (i.e., notified) when an event is emitted.
This callback mechanism provides a way to insert code between any two discrete steps of the generator.
Antora will wait for the listener to run to completion, even if it's async, before proceeding.

A listener can modify the state of in-scope variables in the generator, add new variables, or replace existing variables.
More times than not, a listener will add additional files to one or more of the catalogs for processing or publishing.

Listeners of the same event are invoked in sequence to prevent them from interfering with one another.

== What's a generator function?

Generator functions are the predefined, discrete steps the generator performs.
Although most extensions will listen for generator events, an extension can also replace one or more of these generator functions.
This capability is used when you want to alter the built-in behavior in Antora, such as how the navigation is built.
As with event listeners, generator functions are configured on the generator context.
To hook your own generator functions into the operation of Antora, you register an extension that assigns those functions to the generator context.

== What are context variables?

An extension wouldn't be much use if it couldn't access any of the configuration, content, or other data being processed by the generator.
That's where context variables come in.

The [.term]*context variables* provide access to the in-scope objects flowing through the generator.
These variables are stored on the generator context, hence the name context variables.

A listener can pick any of those variables out of the generator context and work with them.
In fact, a listener can read the same variables that the generator itself can read.
The listener can also push new or replacement variables into the context, as long as those variables are not locked.

== What can an extension do?

To give you an idea of the kinds of extensions you can write and what's possible, here's a glimpse at the things an extension can do to affect the operation of the generator:

* Modify the configuration (i.e., playbook)
* Change the state of a context variable, such as adding a new file to a catalog
* Push a new variable into the context
* Replace or proxy context variables
* Replace or proxy generator functions
* Introduce new steps (in a listener or custom generator function)
* Raise custom events
* Log messages
* Require user code
* Postprocess content, such as replacing strings in HTML files
* Publish new files
* Unpublish files
* Stop processing

In general, an extension taps into the generator and tunes its behavior rather than doing a wholesale replacement of it.
There are some limitations with this approach, but it's a trade-off for providing something that's broadly accessible.

== What can't an extension do?

An extension can't change the order of steps (i.e., generator functions) that the generator performs.
It also can't make the generator skip steps.
However, it can replace an existing step with an empty or custom function.

The most drastic thing an extension can do is to stop the processing early.
This action is useful if the work of an extension is complete and no additional processing is necessary.
For example, an extension may only need to report on the content in the site, in which case it can stop the generator before the publishing step.

// /docs/modules/extend/pages/define-extension.adoc
[[define-extension.adoc]]
= Define an Extension
:url-strict-mode: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode
:url-object-destructuring: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#object_destructuring

An Antora extension is an exported JavaScript function named `register`.
Antora invokes the function as soon as the generator starts (after the playbook is built).
This function will typically add event listeners that listen for xref:generator-events-reference.adoc[generator events].
The event listeners hook into the lifecycle of the Antora generator to do the bulk of the work of the extension.

To define an extension, start by creating a new JavaScript file (herein: _extension file_).
We'll name this extension [.path]_my-extension.js_.
In the extension file, create a function and assign it to the `register` property of the module's exports.
We refer to this export as the register function.
Exporting the function allows Antora to access it.

.my-extension.js
[,js]
----
'use strict'

module.exports.register = () => {
}
----

You can split out the function definition from the export statement, if you prefer that style.

.my-extension.js
[,js]
----
'use strict'

const register = () => {
}

module.exports = { register }
----

Alternately, you can define your extension as a xref:class-based-extension.adoc[class-based extension].

It's good practice to start your extension file with the statement `'use strict'`.
This statement enables strict mode across all versions of Node.js.
{url-strict-mode}[Strict mode^] activates a restricted variant of JavaScript that catches common programming errors.
We'll exclude it from the remaining examples in this area of the documentation, but assume it's ever present.

TIP: This example defines the register function using the https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions[arrow function^] syntax.
You can also use the more formal `function () {}` syntax, which you'll need to do in order to access the generator context.

Put the script in your playbook repository.
Later, you can publish it to a package repository such as npmjs.com to share it between different sites or branches.

So far, our extension doesn't actually do anything.
Since the register function is a kind of listener, you can use it as an opportunity to perform an action immediately after the playbook is built.
Let's use it to say hi.

.my-extension.js
[,js]
----
module.exports.register = () => {
  console.log('Hello from Antora!')
}
----

While that's a fun trick, it's not really what we're after.
What we want to do is tie deeper into the mechanics of the generator so we can do some real work, perhaps even modify the content that Antora is processing.
For that, we need to grab the generator context.

If the register function can be bound, meaning it's defined using the `function` keyword or equivalent, Antora will bind the generator context to its `this` keyword.
The `this` keyword is one way the extension can access the generator context.

.my-extension.js
[,js]
----
module.exports.register = function () {
  this.on(...)
}
----

Alternately, if the function accepts the generator context as the first parameter (using any name that begins with a letter), Antora will pass it as the first argument of the function instead of binding it to the `this` keyword.

.my-extension.js without binding
[,js]
----
module.exports.register = (context) => {
  context.on(...)
}
----

The generator context is what you use to register event listeners.
Before we get there, let's look at the optional parameter for accessing context variables.

The first positional parameter of the register function (or the second, if the function declares the generator context as the first parameter) is an object of context variables.
This object includes the playbook and extension config.
You should use {url-object-destructuring}[object destructuring^] to pick individual variables out of this object.

All event listeners can retrieve the playbook, but you might need it earlier when registering listeners.
Here's how you can access the playbook from the register function:

.my-extension.js
[,js]
----
module.exports.register = function ({ playbook }) {
  console.log(`Antora is building the ${playbook.site.title}.`)
}
----

Now, let's now xref:register-extension.adoc[register our extension], then xref:add-event-listeners.adoc[add event listeners].

// /docs/modules/extend/pages/register-extension.adoc
[[register-extension.adoc]]
= Register an Extension

An extension is not active until registered with Antora.
There are two ways to register an extension.
You can specify it using the `--extension` CLI option or you can list it as an entry in the `extensions` key under the `antora` category key in the playbook file.

Once registered, Antora invokes the xref:define-extension.adoc[register function] of the extension in the order it's listed in the playbook file or passed to the CLI.
The extensions in the playbook file are registered before the extensions passed to the CLI, though this order can be changed by xref:enable-extension.adoc[enabling a registered extension on request].

[#extension-option]
== CLI option

A quick way to register (and enable) an extension without modifying the playbook file is to specify it using the `--extension` option provided by the `antora` CLI.
The `--extension` CLI option adds entries to the `extensions` key in the Antora playbook at runtime.

Here's an example of how to use this CLI option to register our extension.

 --extension ./my-extension.js

If you have more than one extension to register, you can specify this option multiple times.

Using the CLI option requires you to type a longer command each time you run Antora.
For that reason, it's often better to specify it in the playbook file, particularly if you're going to always use it.
Later on you'll learn that even if you do add it to the playbook file, it's still possible to control when it's activated using the CLI.

[#extensions-key]
== Playbook key

An Antora extension can be registered in the playbook file using the `extensions` key.
The `extensions` key is specified under the `antora` category key.
The value of the `extensions` key must be an array.
Each entry in the array is either a string or a map (key/value pairs).

When the value is a string, the value is assumed to be a require request (i.e., path or module name) that resolves to the extension script.
When the value is a map, the require request must be specified using the `require` key.
Using a map leaves room for additional configuration keys, both predefined (like `enabled`) and custom.

If you were to publish the extension to a package repository, then the require request would be the name of that package (i.e., its module name).
In that case, ensure that the package is configured as a dependency of the playbook project so that Node.js fetches it.
Antora doesn't download npm packages for you.

=== Without configuration

Let's register our extension in the playbook file so we can see it in action.
In its simplest form, the extension entry is the require request (i.e., path) to the extension script.

.antora-playbook.yml with extension
[,yaml]
----
antora:
  extensions:
  - ./my-extension.js
----

We prefix the path with `./` to indicate that its location is relative to the playbook file.
See the https://gitlab.com/antora/user-require-helper/blob/main/README.adoc#user-content-usage[@antora/user-require-helper usage] to learn how Antora resolves require requests in the playbook file.

When you run Antora, you should now see a line like this in your terminal:

[.output]
....
Antora is building the Example Docs.
....

=== With configuration

If you need to specify configuration settings for the extension, then you must change the entry type from a string to a map.
When making this change, the require request must now be specified on the `require` key.

.antora-playbook.yml with extension specified using require key
[,yaml]
----
antora:
  extensions:
  - require: ./my-extension.js
    optional_behavior: true
----

By using a map, additional keys can be added as siblings of the `require` key in order to pass configuration to the extension.
You can find an example of how to use these additional keys to configure an extension on the xref:configure-extension.adoc[] page.

Our next step is to add xref:add-event-listeners.adoc[event listeners] to our extension.

// /docs/modules/extend/pages/add-event-listeners.adoc
[[add-event-listeners.adoc]]
= Add Event Listeners
:url-event-emitter: https://nodejs.org/api/events.html#events_class_eventemitter

The bulk of the work of an Antora extension is done by the event listeners.
An event listener is a function that's called whenever an event it's listening for is emitted.
Any value returned by the listener is ignored.
The register function is responsible for associating these listener functions with particular events.
It does so by passing the event name and the listener function to the `on` method of the generator context, called adding a listener.
The xref:generator-context-reference.adoc[API of the generator context] follows that of a Node.js {url-event-emitter}[EventEmitter^].

Let's build on the extension we have defined by updating it to add an event listener.
We'll listen for the `playbookBuilt` and `sitePublished` events, which are the first and last events to be emitted by the generator.
This gives us the opportunity to roughly measure how long it took to generate and publish the site.

.time-generation-extension.js
[#ex-listen,js]
----
include::example$time-generation-extension.js[]
----

In <<ex-listen>>, we use the `on` method of the generator context to add two listeners, one for when the `playbookBuilt` event is emitted and one for when the `sitePublished` event is emitted.
The `on` method returns the generator context, so we can use it to chain calls, as show in the previous example.

[TIP]
====
Since built-in events are only emitted once, you can register the listener for a built-in event using `once` instead of `on`.

[,js]
----
this.once('playbookBuilt', () => { ... })
----

Using `once` provides a very slight optimization.
It allows the event emitter to deactivate itself once there are no more listeners remaining.
====

By default, listeners are invoked in the order they are added.
To guarantee our timer starts before listeners from other extensions are called, our `playbookBuilt` listener should be called before other listeners of the `playbookBuilt` event and our `sitePublished` listener should be called after other listeners of the `sitePublished` event.
There are two changes we must make to get this to work.

First, we can use the `prependListener` method as an alternative to `on` to add the `playbookBuilt` listener before other listeners that have already been associated with that event.

.time-generation-extension.js
[,js]
----
include::example$better-time-generation-extension.js[]
----

Second, we should list our extension last in the playbook.
Taking these two steps ensures our timer runs around all other listeners.

[TIP]
====
If you want to time a specific stage of the generator, you can update this extension to listen to xref:generator-events-reference.adoc[other generator events].
To extend the timer all the way to when Node.js exits, you can listen for the `exit` event on the Node.js process object.

[,js]
----
process.on('exit', () => {
  console.timeEnd('generation time')
})
----

To learn more about the `exit` event and other events emitted by the Node.js process, see https://nodejs.org/api/process.html#process-events[Node.js process events].
====

The EventEmitter API, which the generator context inherits, also allows listeners to be retrieved, removed, and added again.
That opens up the possibility that one extension can rearrange listeners added by other extensions, if the need arises.
Extensions can also emit and listen for custom events using the same methods.

To do something more interesting than time the execution and print messages to the console, we need to xref:use-context-variables.adoc[use context variables].
Let's learn how that's done next.

// /docs/modules/extend/pages/use-context-variables.adoc
[[use-context-variables.adoc]]
= Use Context Variables
:url-object-destructuring: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#object_destructuring

The main goal of Antora extensions is to allow you to write code that hooks into the generation process at key transition points and to access variables that are flowing through the system at that time.
The fun with extensions really starts once you start to access these context variables.

[#access]
== Access context variables

A context variable is a variable that is in scope at the time an event is emitted and that the generator binds to the generator context.
By accessing a context variable from an extension, you can:

* read properties from the object,
* call methods on the object, or
* modify properties on the object (provided the object is not frozen).

In <<update>>, you'll learn how to replace the variable with a proxy of the object, which is another option.

The first positional parameter of each event listener is an object of context variables.
You should use {url-object-destructuring}[object destructuring^] to pick individual variables out of this object (e.g., `{ playbook }`).
The in-scope variables for each event are defined on the xref:generator-events-reference.adoc[] page.

Let's build on our extension to retrieve the site catalog and add a [.path]_.nojekyll_ file to it as an alternative to using the supplemental UI for this purpose.

.nojekyll-extension.js
[#ex-nojekyll,js]
----
include::example$nojekyll-extension.js[]
----

In <<ex-nojekyll>>, the site catalog is retrieved from the context using `{ siteCatalog }`.
To retrieve multiple variables, separate the variable names using commas (e.g., `{ playbook, siteCatalog }`).

Context variables can also be retrieved directly from the generator context using the `getVariables` method:

[,js]
----
const { siteCatalog } = this.getVariables()
----

In addition to the xref:generator-events-reference.adoc[built-in context variables], your extension can also access context variables documented and published by other extensions.

[#update]
== Update context variables

While most extensions read context variables and interact with the methods of the referenced object, they can also add or replace context variables.
One use case is to define new variables that other extensions or listeners of the same extension can access.
This is one way to pass additional data through the generator.
Another use case is to replace a built-in variable used by the generator, perhaps by proxying it.
You may want to do this if you need to drastically alter Antora's behavior and you can't do it by adding or removed files from a catalog.

Let's consider the use case where we want to proxy the content catalog to prevent it from registering any aliases.
In <<ex-proxy>>, we listen for the `contentClassified` event, retrieve the `contentCatalog` context variable, and replace the variable with a proxy of the object.

.Replace variable with a proxy of the object
[#ex-proxy,js]
----
module.exports.register = function () {
  this.on('contentClassified', function ({ contentCatalog }) {
    contentCatalog = new Proxy(contentCatalog, {
      get(target, property) {
        return property === 'registerPageAlias' ? () => undefined : target[property]
      },
    })
    this.updateVariables({ contentCatalog })
  })
}
----

TIP: <<ex-proxy>> gives you the starting point to replace the `registerPageAlias` function with your own implementation.

Notice that the previous example uses the formal `function` keyword to declare the listener instead of an arrow function.
Defining the function this way gives us access to the standard `this` keyword, which is a reference to the generator context.
When the listener is registered, Antora binds the function to the generator context, making the generator context accessible within the function using the standard `this` keyword.

[#locking]
== Context variable locking

Once a built-in context variable is deemed established, which is typically after the event in which it was introduced is emitted, that variable becomes locked.
There are exceptions to this rule, but by-in-large it holds.
A variable that is locked can't be replaced.
Any attempt to do so results in an error.

The built-in variables that are locked, and when they're locked, are indicated on the xref:generator-events-reference.adoc[] page.

The reason built-in variables are locked is two fold.
First, it signals when a variable should be replaced if it must be.
Second, it allows the site generator and other extensions to store a local reference to that variable without having to worry about checking whether it was replaced.

A locked variable only prevents that variable itself from being replaced.
It's still possible to modify the object that the variable references, such as to add, update, or remove a property of the object.
The one exception is the playbook, which is a frozen object.

// /docs/modules/extend/pages/configure-extension.adoc
[[configure-extension.adoc]]
= Configure an Extension

An extension that you write or use may require additional settings to configure its behavior.
While the extension could tap into information already available in the playbook or the content sources Antora is building, it may be necessary to configure the extension directly.
An extension can accept an arbitrary number of properties, which may be nested, that are specified in the entry in the playbook file.
These properties are accessible via a context variable named `config` that's passed to the extension's register function.

== Basic configuration

Let's assume that we want to publish a file named [.path]_humans.txt_ to give credit to the people who make the documentation site possible.
We'll name our extension [.path]_humans-txt-extension.js_.
Of course, the extension won't know who to credit, so we'll need to pass it some configuration.

Let's start by registering our new extension in the playbook and passing in the list of people using the `names` key.
The value of this key will be an array of names.

[,yaml]
----
antora:
  extensions:
  - require: ./humans-txt-extension.js
    names:
    - Doc Writer
    - Dr. Austen
    - Emily Story
----

To make room for the additional keys, we've converted the entry for the extension from a single (string) value to a map.
The require request value slides into the `require` key.
That leaves room to define additional keys, in this case `names`.

Now let's write an extension that accepts this configuration and uses it to create the [.path]_humans.txt_ file:

.humans-txt-extension.js
[,js]
----
include::example$humans-txt-extension.js[]
----

The `config` object for the extension is accessed using object destructuring just like any other context variable.
Thanks to variable scoping in JavaScript, we can still access that variable in our listener for the `beforePublish` event.
We use the information it provides to populate the contents of the [.path]_humans.txt_ file and add it to the site catalog.
Antora will then include [.path]_humans.txt_ file in the published site.

== Configuration key transformation

In YAML, key names use the snake_case naming convention.
In JavaScript, property names use the camelCase naming convention.
To help bridge the naming convention mismatch between YAML and JavaScript, Antora automatically transforms snake_case key names in the playbook file into camelCase properties on the configuration object.
For example, Antora transforms `cache_dir` to `cacheDir`.
Most of the time, this isn't a problem.
However, if your extension passes configuration or data on to another application, this transformation can be problematic.

=== Configuration data

To bypass this configuration, you can tuck keys away inside the `data` key.
Any keys inside the `data` key (at any depth) are passed through without being modified.

Let's assume that we want to specify structured content for our [.path]_humans.txt_ file.
We don't need Antora to transform this structured content, so we can store it inside a key named `data`.

[,yaml]
----
antora:
  extensions:
  - require: ./humans-txt-extension.js
    data:
      TEAM:
      - Lead Writer: Doc Writer
        Contact: doc [at] example.org
        Location: Denver, CO
      - Information Architect: Dr. Austen
        Location: Winchester, Hampshire, England
      - Narrator: Emily Story
        Location: Antwerp, Belgium
----

Now, the extension can iterate over the keys in `config.data` and layout the contents of the [.path]_humans.txt_ file.

[,js]
----
const contents = Buffer.from(
  Object.entries(config.data).reduce((accum, [category, entries]) => {
    if (accum.length) accum.push('')
    accum.push(`/* ${category} */`)
    entries.forEach((entry) => {
      accum.push('')
      for (const [key, val] of Object.entries(entry)) accum.push(`${key}: ${val}`)
    })
    return accum
  }, []).join('\n')
)
----

// /docs/modules/extend/pages/enable-extension.adoc
[[enable-extension.adoc]]
= Enable an Extension

By default, if you register an extension in the playbook file, Antora will enable it automatically.
One way to enable an extension only on request is to specify it using the CLI option (`--extension`).
However, that alone doesn't allow you to provide configuration keys or influence the load order.
That's where extension enablement comes into play.

You can register an extension in the playbook file, along with optional configuration, then tell Antora not to enable it.
You can then use the CLI option (`--extension`) to enable it, and it will be registered relative to other extensions in the order listed in the playbook.

To prevent Antora from enabling an extension specified in the playbook file, set the predefined configuration key `enabled` to the value `false`.
When Antora sees that the `enabled` key has a value of `false`, it will not register the extension.

.An extension that is not enabled
[,yaml]
----
antora:
  extensions:
  - require: ./my-extension.js
    enabled: false
    custom: value
----

You can use the `enabled` key to quickly turn off an extension without having to remove it from the playbook.
More likely, though, you mark it this way so that it can be enabled using the CLI option.
However, in order to do that, you need a way to reference it.
That's the purpose of the predefined configuration key `id`.
The `id` key specifies a value you can reference using the `--extension` CLI option to enable an extension that's marked as not enabled in the playbook file.

First, let's give our extension an ID:

.An extension with an ID that is not enabled
[,yaml]
----
antora:
  extensions:
  - id: my-extension
    require: ./my-extension.js
    enabled: false
    custom: value
----

Now we can now enable this extension from the CLI as follows:

 $ antora --extension=my-extension antora-playbook.yml

Whereas normally the value of the `--extension` CLI option is a require request, in the case when you are enabling an extension, the value is the ID of the extension entry in the playbook file.

If Antora can't locate an entry with an ID that matches the value of the `--extension` CLI option, it falls back to treating the value as a require request.

// /docs/modules/extend/pages/extension-helpers.adoc
[[extension-helpers.adoc]]
= Extension Helpers

The generator context provides several utility methods that make writing extensions easier.
These utility methods are called [.term]*helpers* because they help you to write extensions.

== Access helpers

The helpers are located on the generator context, which provides the xref:generator-context-reference.adoc[GeneratorContext API].
Thus, to use the helpers, you need a reference to the generator context.

There are two ways to get the generator context.
If the listener functions are defined within the `register` function for the extension, they can access the generator context from the register function by way of variable scoping.
Otherwise, the listener function can reference the generator context using the standard `this` keyword.
The generator context is bound to the listener function when the listener function is registered.

[#get-variables]
== getVariables()

One way to access context variables is to accept them via the first parameter of the register function or event listener function using object destructuring (e.g., `{ playbook }`).
However, there may be situations where a context variable is only needed conditionally.
To simplify the function signature, you can retrieve context variables directly from the generator context using the `getVariables` helper.

Here's an example of how to access context variables from the generator context (bound to `this`) using the `getVariables` method:

[,js]
----
const { playbook, contentCatalog } = this.getVariables()
----

Note that parameter destructuring is still the only way for the register function to access the config object for an extension.

[#update-variables]
== updateVariables(Object)

The `updateVariables` helper method provides a means for adding or replacing context variables.
The method accepts a single argument of type Object, where the keys of the object are the variable names and the values are the variable values.
This method doesn't return a value.

If you want to remove a variable, specify the value as `undefined`.
Keep in mind that locked variables can't be replaced.

Here's an example that shows how to replace the `playbook` and `siteCatalog` variables from a listener:

[,js]
----
playbook = JSON.parse(JSON.stringify(playbook))
siteCatalog = new Proxy(siteCatalog, {})
this.updateVariables({ playbook, siteCatalog })
----

You can also use the `updateVariables` method to introduce new variables into the context.
The site generator will not recognize or use these variables.
However, other extensions, or listeners in the same extension, can use them.

[#stop]
== stop(Integer)

The `stop` helper method provides a way to stop the operation of the generator using an orderly shutdown.
This method accepts an optional exit code value and doesn't return a value.

When called, this method causes the context to emit the `contextStopped` and `contextClosed` events.
If any messages are logged that exceed the xref:playbook:runtime-log-failure-level.adoc[failure level threshold], Antora will exit with a non-zero exit code.
Otherwise, Antora will exit with the specified exit code or, if no exit code is specified, a zero exit code (i.e., successfully).

The `stop` helper is useful if you only need to run Antora partially and don't want to throw an error to make Antora stop.
You might use it for warming up a cache or performing reference validation.
Keep in mind that if you call `stop` in any listener before the `sitePublished` event, Antora won't publish the site.

Here's an example that shows how to signal to Antora in a listener to stop processing:

[,js]
----
console.log('Our work is done here. Wrap it up.')
this.stop()
----

[#get-logger]
== getLogger(String)

The `getLogger` helper method allows you to retrieve an instance of the logger.

Here's an example that shows how to retrieve an instance of the logger and use it in a listener:

[,js]
----
module.exports.register = function () {
  const logger = this.getLogger('extension-name')
  this.on('playbookBuilt', () => {
    logger.info('Let it be known. The playbook has been built!')
  })
}
----

You'll see the following message in your terminal when you run Antora with this extension enabled (and the `--log-level=info` option):

[.output]
....
[12:24:37.731] INFO (extension-name): Let it be known. The playbook has been built!
....

[#require]
== require(String)

The `require` helper method allows you to require libraries within the context of the Antora installation.
This method accepts a single argument of type String, which is a require request (i.e., the name of a Node.js module or a source file within a module).
This method returns the object that the specified module or source file exports.
If the request can't be resolved, the method throws an Error with code `MODULE_NOT_FOUND`.

From time to time when writing extensions, you may need to access code provided by Antora.
Examples include the logger, the ContentCatalog, or a utility function like `parseResourceId`.
This method allows you to require this code without having to declare a dependency on Antora.
That dependency is implicit since the extension runs within the context of Antora.
This method provides a way to require that code.

Here's an example that shows how to get the version of the site generator that is currently running from a listener:

[,js]
----
const { name, version } = this.require('@antora/site-generator/package')
console.log(`Running ${name} version ${version}`)
----

Since the extension is already running in the context of the site generator, here's a slightly simpler way to achieve the same result:

[,js]
----
const { name, version } = this.require('../package')
console.log(`Running ${name} version ${version}`)
----

For a more practical example, you can use the `require` helper method to create a child logger for your extension.
Typically, you'd do so in the `register` function, then access the same instance of the logger throughout your extension.

[,js]
----
module.exports.register = function () {
  const logger = this.require('@antora/logger')('extension-name')
  this.on('playbookBuilt', () => {
    logger.info('Let it be known. The playbook has been built!')
  })
}
----

You'll see the following message in your terminal when you run Antora with this extension enabled (and the `--log-level=info` option):

[.output]
....
[12:24:37.731] INFO (extension-name): Let it be known. The playbook has been built!
....

A simpler way to retrieve a logger instance is to use the <<get-logger>> method.

// /docs/modules/extend/pages/class-based-extension.adoc
[[class-based-extension.adoc]]
= Class-Based Extension

If your extension is going to listen for multiple events and keep track of state, you may want to consider defining your extension as a JavaScript class.
A class is a template for creating an object.
It encapsulates both data and the methods that operate on that data.
This encapsulation can help keep your extension more organized.
The challenge is to work out how to define a class in such a way that it can be used as an Antora extension.
This page shows you how.

== Extension class structure

The basic structure of a class-based extension is as follows:

* Define a class named after your extension (e.g., MyExtension)
* Add a static register method that Antora can call
* Define listeners as instance methods (e.g., `onPlaybookBuilt ({ playbook })`)
* Add a constructor that accepts the generator context and registers listeners from the class
* Export the class definition

Here's the skeleton of our extension class:

[,js]
----
class MyExtension {
}
----

Let's fill in the details.

== The register method and instantiation

Antora won't create an instance of your class, but you can use the static register method on the class to do so.
If you're coming from Java, you can think of it like the main method of the class.
Here's how that entry point looks:

[,js]
----
class MyExtension {
  static register () {
    new MyExtension(this)
  }
}

module.exports = MyExtension
----

All Antora will see is the register method on the exported class definition, which Antora will invoke to get the process started.
The remainder of the work happens in the extension instance.

Notice how the static register method has transitioned us from a static function to an instance of the extension class.
The register method passes the generator context to constructor of the extension class so it can access and store a reference to it.

== Listener methods

Listeners are defined as methods on the extension class.
They will get invoked just like any other listener function, only they will have a reference to both the current instance of the class (`this`) and the generator context (`this.context`).
That way, they can access both properties on the extension (extension state) and context variables in the generator.
Here's the extension class again with the listeners defined as methods:

[,js]
----
class MyExtension {
  static register () {
    new MyExtension(this)
  }

  onPlaybookBuilt () {
    this.startTime = +new Date
  }

  onSitePublished () {
    const elapsed = (+new Date - this.startTime) / 1000
    const logger = this.context.getLogger('my-extension')
    logger.info(`elapsed time: ${elapsed}s`)
  }
}

module.exports = MyExtension
----

Now all that's left is to wire these listeners to events.

== The constructor and adding listeners

The next step is to create a constructor the accepts the generator context and adds listeners.
Here's the extension class again with the constructor:

[,js]
----
class MyExtension {
  static register () {
    new MyExtension(this)
  }

  constructor (generatorContext) {
    ;(this.context = generatorContext)
      .on('playbookBuilt', this.onPlaybookBuilt.bind(this))
      .on('sitePublished', this.onSitePublished.bind(this))
  }

  onPlaybookBuilt () {
    this.startTime = +new Date
  }

  onSitePublished () {
    const elapsed = (+new Date - this.startTime) / 1000
    const logger = this.context.getLogger('my-extension')
    logger.info(`elapsed time: ${elapsed}s`)
  }
}

module.exports = MyExtension
----

When adding each listener, it must be bound to the extension instance (i.e., `this`).
Otherwise, the listeners won't be able to access the properties on the extension instance.
The listener can still access the generator context using the `context` property, to which the constructor assigns the generator context.

As you have seen, using a class-based extension can keep your extension code more organized.
It also allows your extension to take advantages of other object-oriented patterns, such as inheritance, composition, and delegation.

// /docs/modules/extend/pages/asynchronous-listeners.adoc
[[asynchronous-listeners.adoc]]
= Asynchronous Listeners

Antora calls listeners synchronously in the order they are registered.
This is true even if a listener is marked asynchronous using the `async` keyword or the listener returns a Promise.
Antora will await the completion of the listener invocation before calling the next listener (and thus before continuing its own operation).
This behavior differs from the behavior of the built-in NodeEmitter in Node.js.

The benefit of marking a listener as async, or returning a Promise, is that the listener can perform asynchronous operations.
Of course, these operations will all be resolved before Antora proceeds, so they are made to behave in a synchronous fashion outside the boundaries of the function.

NOTE: A Promise ends when the program calls `await` on it.
Obviously, that requirement bubbles all the way up to the top-level function of the program.
Antora hides away this detail by allowing you to either define an extension listener as async or return a Promise.

Let's look at an example of fetching a file from a URL and publishing it to the site.

.fetch-and-publish-readme-extension.js
[,js]
----
include::example$fetch-and-publish-readme-extension.js[]
----

Notice that we have added the `async` keyword to the listener function.
This allows us to the use the `await` keyword inside the function.

As an exercise, you could try retrieving a file from each branch of each content source and adding it to the published site.
To give you a hint, you would need to access the `playbook` variable to get a list of content sources.

If you don't want Antora to wait for the completion of your asynchronous listener, you can either return an empty promise (e.g, `return Promise.resolve()`), or you can remove the `async` keyword from your listener.
However, if you do so, you'll need to add a listener that listens for an event that is emitted later in the generator, such as `contextClosed`, so you can resolve the promise before Antora completes.

Let's look at the same example as earlier, except it downloads the README.adoc in the background while the site is being generated.
To help manage the state of the pending promise, it has also been rewritten as a xref:class-based-extension.adoc[class-based extension].

.background-fetch-and-publish-readme-extension.js
[,js]
----
include::example$background-fetch-and-publish-readme-extension.js[]
----

Notice that only the `onBeforePublish` listener function is async so it can wait for the promise started by the `onPlaybookBuilt` listener function.
The extension also now accepts the URL of the README as a configuration key named `readme_url`.

// /docs/modules/extend/pages/replace-generator-functions.adoc
[[replace-generator-functions.adoc]]
= Replace Generator Functions

Antora's site generator is implemented as a sequence of steps.
Each step is performed by a function.
These functions are known as [.term]_generator functions_.
Generator functions may contain functions for key substeps a generator function may perform, such as `convertDocument`.

The generator retrieves these functions from the generator context.
These functions can also be retrieved and replaced programmatically by an Antora extension.
As such, these generator functions are designed to be replaceable, providing a more powerful way to extend Antora.

WARNING: Replacing functions in an extension does put the code at greater risk of breaking between major versions of Antora.

== Get the functions

Like with context variables, generator functions are available from the generator context.
The generator functions can be retrieved by calling the `getFunctions` method inside the listener of the `contextStarted` event, or at any point thereafter.
This method returns an object of key-value pairs, where the keys are the function names and the values are the function objects.

IMPORTANT: The built-in generator functions are not available until the `contextStarted` event is emitted.

Here's an example that shows how to retrieve the `aggregateContent` function in an extension, assuming `this` is bound to the generator content.

[,js]
----
this.once('contextStarted', () => {
  const { aggregateContent } = this.getFunctions()
})
----

One reason to retrieve a generator function is to use it as a utility.
For example, if you need your extension to load AsciiDoc as Antora does, you might retrieve the `loadAsciiDoc` function for this purpose.
Here's an example:

[,js]
----
this.once('contentClassified', (contentCatalog, siteAsciiDocConfig) => {
  const { loadAsciiDoc } = this.getFunctions()
  const page = contentCatalog.resolvePage('ROOT::index.adoc')
  const scopedAsciiDocConfig = contentCatalog.getComponentVersion(page.src.component, page.src.version).asciidoc
  const doc = loadAsciiDoc(page, contentCatalog, scopedAsciiDocConfig || siteAsciiDocConfig)
  const sections = doc.findBy({ context: 'section' }, (it) => it !== doc.getHeader())
  console.log(sections.map((it) => it.getTitle()))
})
----

Another reason to retrieve a generator function is to decorate (aka wrap) it.
In this case, you'll need to replace the original function with the decorated one.
Alternately, you can replace the original function with your own implementation.

== Replace a function

Replacing generator functions gives you the ability to override steps in Antora's site generator.

The generator functions can be replaced by passing functions to the `replaceFunctions` method.
This method accepts the same object signature that the `getFunctions` method returns, where the keys are the function names and the values are the function objects.

You only have to pass functions to `replaceFunctions` that you want to replace.
The generator will default to using the built-in functions for any function that's not replaced.

Here's an example that shows how to replace the `publishFiles` function in an extension:

[,js]
----
module.exports.register = function () {
  this.replaceFunctions({
    async publishFiles () {
      console.log('Not publishing today')
      return []
    }
  })
}
----

_When_ the functions are replaced matters.
If you replace a function directly in the `register` method (before the `contextStarted` event is emitted), it will stop Antora from requiring and registering the corresponding built-in function.
If you replace a function in the `contextStarted` listener, the function will replace the corresponding built-in function that has already been required and registered.

The `contextStarted` event gives you the opportunity to delegate to (i.e., wrap) a built-in function, as shown here:

[,js]
----
module.exports.register = function () {
  this.once('contextStarted', () => {
    const { publishFiles: publishFilesDelegate } = this.getFunctions()
    this.replaceFunctions({
      async publishFiles (playbook, catalogs) {
        console.log('It\'s publish time!')
        return publishFilesDelegate.call(this, playbook, catalogs)
      }
    })
  })
}
----

When replacing a function, you must adhere to the function's signature as defined in <<Function reference>>.
Like with the register function and event listener functions, the generator functions are automatically bound to the generator context.

== Function reference

The list of functions that can be replaced by an extension, shown along with their signatures, are as follows:

* aggregateContent(playbook): Promise<Object>
* buildNavigation(contentCatalog, siteAsciiDocConfig): NavigationCatalog
* classifyContent(playbook, contentAggregate, siteAsciiDocConfig): ContentCatalog
* convertDocument(file, contentCatalog, siteAsciiDocConfig): File
* convertDocuments(contentCatalog, siteAsciiDocConfig): void
* createPageComposer(playbook, contentCatalog, uiCatalog, env): Function
* extractAsciiDocMetadata(doc): Object
* loadAsciiDoc(file, contentCatalog, config): Document
* loadUi(uiCatalog): Promise<UiCatalog>
* mapSite(playbook, publishablePages): File[]
* produceRedirects(playbook, contentCatalog): File[]
* publishFiles(playbook, catalogs): Promise<Object[]>
* resolveAsciiDocConfig(playbook): Object

To learn more about these functions, consult the {url-repo}/tree/{page-origin-refname}/packages[Antora source code].

// /docs/modules/extend/pages/extension-tutorial.adoc
[[extension-tutorial.adoc]]
= Extension Tutorial

If you understand how Antora extensions work, and have a solid grasp of the concepts, this page offers an end-to-end tutorial that walks you through an in-depth example to give you a full view and help you get the most out of this feature of Antora.

In this tutorial, we'll create an extension that locates unlisted pages, which are pages not accessible from the navigation.
The extension will first retrieve the navigation tree for each component version.
It will then iterate through the pages in that component version and locate any pages that are not found in that navigation tree.
If it finds any unlisted pages, it will log a warning for each.
If configured to do so, it will also add those pages under a dedicated category in the navigation.

This example gives you an opportunity to use much of the functionality available to extensions.
We'll create the extension, register it in the playbook, configure it, and finally run Antora with it enabled.
//In the future, we may go through the steps of publishing the extension to a package repository and consuming it
Let's get started.

== Create the extension

To begin, you first need to create the extension.
Let's name the extension file [.path]_unlisted-pages-extension.js_ and place it in the [.path]_lib/_ folder adjacent to the playbook so it's neatly organized in the playbook repository.
//Q: should we name the folder ext instead?
//Later on, we'll publish the extension to a package repository

Populate the extension file with the source code shown in <<ex-ext>>.
The next section will analyze what this code is doing.

.lib/unlisted-pages-extension.js
[#ex-ext,js]
----
include::example$unlisted-pages-extension.js[tags=**]
----

Let's pause to break down what this extension does, step by step.

== How the extension works

The extension starts by exporting the register function, which Antora calls immediately after requiring the extension file.
The register function is bound to the generator context, which it can use to add listeners.
The function accepts the config object for the extension (via object destructuring) as the sole argument.
It goes on to pull several configuration keys out of the config object to customize its behavior.

[,js]
----
include::example$unlisted-pages-extension.js[tag=register,indent=0]
----

Next, the extension creates a named logger that it can use for reporting unlisted pages.
It does so by calling `getLogger` on the context to create a named logger.
This method, in turn, requires the `@antora/logger` module provided by Antora, then passes the name to its default function to create the child logger.

[,js]
----
include::example$unlisted-pages-extension.js[tag=logger,indent=0]
----

The extension then adds a listener for the `navigationBuilt` event.
Since the extension needs access to the navigation, this is the right opportunity in the generator to examine the navigation trees.
To access the navigation and the pages, the listener retrieves the `contentCatalog` object from the context variables using object destructuring.
The `navigationBuilt` event is emitted after the pages have been converted, which provides access to the navtitle for each page.

[,js]
----
include::example$unlisted-pages-extension.js[tag=on,indent=0]
----

When called, the listener for the `navigationBuilt` event retrieves the navigation tree for each component version from the content catalog, as well as some information about the component version for locating its pages.

[,js]
----
include::example$unlisted-pages-extension.js[tag=each-nav,indent=0]
----

To make it easier to find pages in the navigation, the extension provides a helper to create a lookup table for each entry in the navigation by URL, ignoring any duplicates.

[,js]
----
include::example$unlisted-pages-extension.js[tag=helper,indent=0]
----

The extension then uses this helper to create that lookup table for each navigation:

[,js]
----
include::example$unlisted-pages-extension.js[tag=create-lookup-table,indent=0]
----

Now the real work begins.
The extension returns to the content catalog to find all pages in the current component version, filtering that list to find only the publishable pages (i.e., pages which have an `out` property).
It then checks to see if the page is found in the navigation by comparing resource URLs.
If it can't find a match, it logs a warning using the logger and adds the page to the collector being returned.

[,js]
----
include::example$unlisted-pages-extension.js[tag=find-unlisted,indent=0]
----

Let's have a closer look at that warning message.

[,js]
----
include::example$unlisted-pages-extension.js[tag=warn,indent=0]
----

Notice that we're passing an object as the first argument and the message as the second.
The keys of the object passed as the first argument get merged into the structured log message.
Antora's logger provides a custom formatter for the `file` and `source` keys when outputting a pretty log message.
The `file` key should point to an object with a `path` key and, if applicable, an `abspath` key.
The simplest way to provide this content is to pass the `src` property of the virtual file, which has all the necessary information about where the file is located.
The `origin` key should point to the `src.origin` property on the virtual file, which provides information about the content source.
You can also pass in an optional line number using the `line` key.
The custom formatter will compile all this information into a formatted message to help the user locate the relevant file.

Finally, if the extension finds unlisted pages, it adds them to a new category in the navigation with the special heading if configured to do so.

[,js]
----
include::example$unlisted-pages-extension.js[tag=add-to-nav,indent=0]
----

The `addToNavigation` variable comes from the configuration key `add_to_navigation` on the extension entry.
Antora automatically converts configuration key names to camelCase to make them consistent with variable naming conventions in JavaScript.

.Remove unlisted pages
[#remove-unlisted]
****
Instead of adding unlisted pages to the navigation, you could instead remove them from the site.
This would be one way of limiting which pages get published.

[,js]
----
unlistedPages.forEach((page) => contentCatalog.removeFile(page))
----

If you go this route, you'll probably want to remove the warning for unlisted pages, or downgrade it to the info or debug severity level.
****

Now that the extension is written, and you understand what it does, it's time to register it.

== Register the extension

To register the extension, you add a require request entry for it in the `antora.extensions` key in the playbook.
In our case, the require request is the relative path from the playbook file to the extension file.

[,yaml]
----
antora:
  extensions:
  - ./lib/unlisted-pages-extension.js
----

The extension will be called the next time you run Antora.
However, since this extension is configurable, we'll want to use the more formal entry format to make room for those configuration keys.

== Configure the extension

To register an extension with configuration, you add a map entry for it in the `antora.extensions` key in the playbook.
In doing so, you'll define the require request in the `require` key, making way for the other configuration keys.

[,yaml]
----
antora:
  extensions:
  - require: ./lib/unlisted-pages-extension.js
    add_to_navigation: true
    unlisted_pages_heading: Orphans
----

If you want the extension to only be used when specified using the `--extension` CLI option, you'll need to set the `id` and `enabled` keys as well.

[,yaml]
----
antora:
  extensions:
  - id: unlisted-pages
    enabled: false
    require: ./lib/unlisted-pages-extension.js
    add_to_navigation: true
    unlisted_pages_heading: Orphans
----

Now the extension will only run if you pass `--extension=unlisted-pages` to Antora when you run it.

TIP: When an extension accepts configuration, it's always wise to register it in the playbook, even if you don't want it to be enabled by default.

== Use the extension

All that's left is to use the extension when you run Antora.
If the extension is enabled (as it is by default), all you need to do is run Antora and pass the playbook file, as you normally would:

 $ antora antora-playbook

If the extension is not enabled, you need to enable it when you run Antora using the `--extension` CLI option:

 $ antora --extension=unlisted-pages antora-playbook.yml

If you have unlisted pages in your playbook, you'll see a warning message similar to this one:

[.output]
....
[12:02:02.532] WARN (unlisted-pages-extension): detected unlisted page
    source: /path/to/worktree (refname: main <worktree>, start path: docs)
    file: modules/ROOT/pages/name-of-page.adoc
....

If the `add_to_navigation` key is true, you'll also find the page listed in the unlisted pages category at the bottom of the navigation tree.

To fix the problem of an unlisted page, find the appropriate nav file and add an entry for the unlisted page, then run Antora again to check your work.

Congratulations!
You've made your first Antora extension.

// /docs/modules/extend/pages/generator-events-reference.adoc
[[generator-events-reference.adoc]]
= Generator Lifecycle Events Reference
:navtitle: Generator Events Reference

Antora extensions listen for events emitted by the generator when Antora runs.
Each listener can access variables that are in scope at the time the event is emitted.
The following table lists the generator events in the order they're emitted and the context (in-scope) variables that correspond to each event.
If the variable is locked, meaning it cannot be replaced, it's italicized.

.Antora extension events and in-scope variables
[cols="1,2"]
|===
|Event name | In-scope variables

|register(){empty}footnote:register[The register function isn't an event, but rather the function Antora calls on an extension so it can register listeners.]
|playbook, config

|contextStarted{empty}footnote:functions[The built-in generator functions are not available until this event is emitted.]
|playbook

|playbookBuilt
|playbook

|beforeProcess
|_playbook_, siteAsciiDocConfig, siteCatalog

|contentAggregated{empty}footnote:event-sequence[The `uiLoaded` event may be emitted before, between, or after the `contentAggregated` and `componentsRegistered` events.]
|_playbook_, _siteAsciiDocConfig_, siteCatalog, contentAggregate

|componentsRegistered{empty}footnote:event-sequence[]
|_playbook_, _siteAsciiDocConfig_, siteCatalog, contentCatalogfootnote:[The contentCatalog only provides access to the components at this phase and is, as such, still being constructed.]

|uiLoaded{empty}footnote:event-sequence[]
|_playbook_, _siteAsciiDocConfig_, siteCatalog, uiCatalog

|contentClassified
|_playbook_, _siteAsciiDocConfig_, siteCatalog, uiCatalog, contentCatalog

|documentsConverted
|_playbook_, _siteAsciiDocConfig_, siteCatalog, _uiCatalog_, _contentCatalog_

|navigationBuilt
|_playbook_, _siteAsciiDocConfig_, siteCatalog, _uiCatalog_, _contentCatalog_, navigationCatalog

|pagesComposed
|_playbook_, _siteAsciiDocConfig_, siteCatalog, _uiCatalog_, _contentCatalog_

|redirectsProduced
|_playbook_, _siteAsciiDocConfig_, siteCatalog, _uiCatalog_, _contentCatalog_

|siteMapped{empty}footnote:[The `siteMapped` event is only emitted if the site URL is specified in the playbook.]
|_playbook_, _siteAsciiDocConfig_, siteCatalog, _uiCatalog_, _contentCatalog_

|beforePublish
|_playbook_, _siteAsciiDocConfig_, siteCatalog, _uiCatalog_, _contentCatalog_

|sitePublished
|_playbook_, _siteAsciiDocConfig_, _siteCatalog_, _uiCatalog_, _contentCatalog_, publications

|contextStopped
|(any variable still in scope at the time the context is stopped)

|contextClosed{empty}footnote:[Listeners of the `contextClosed` event are expected to catch their own errors so all listeners are notified.]
|(any variable still in scope at the time the context is closed)
|===

The playbook object (i.e., the parsed data from the playbook file) is available at the time the `register` function is called (which acts like the `register` event).
However, at this stage, the playbook is still just a raw data model.
The Antora extensions have yet to be registered.
When the `contextStarted` is emitted, all the initialization of the playbook, including registering Antora extensions and generator functions, is complete.

When modifying the content sources in an Antora extension, it's customary to use the `playbookBuilt` event.
After that, the playbook object cannot be modified or updated.

In addition to the built-in context variables listed in this table, your extension can also access context variables documented and promoted by other extensions.

// /docs/modules/extend/pages/generator-context-reference.adoc
[[generator-context-reference.adoc]]
= GeneratorContext API Reference
:url-event-emitter: https://nodejs.org/api/events.html#events_class_eventemitter

The GeneratorContext API is the main point of access into Antora's extension facility.
Antora creates an instance of the GeneratorContext, called the generator context, and binds it to the register function of an extension as well as any listeners it adds.
This object is shared across all extensions and event listeners.
The generator context provides a way to add those event listeners.
It also provides a handful of context-aware helpers that make writing extensions easier.

The GeneratorContext class extends the Node.js {url-event-emitter}[EventEmitter^] type.
All methods on the EventEmitter are inherited by and available on the generator context.
However, you should never call the `emit` object to emit one of Antora's own events.

In addition to the methods on EventEmitter, the following table describes the methods provided by the GeneratorContext API.

// Q: should we document all methods, including the ones contributed by EventEmitter?
.Additional methods provided by the GeneratorContext
[cols="1,1,2"]
|===
|Method name | Parameter(s) | Description

|getFunctions
|_none_
|Returns the object of generator functions.
A generator function is defined as any of the discrete steps in the generator, as well as key utility functions those steps use.
The built-in generator functions are not available until the `contextStarted` event is emitted.
This object is read only.

|getLogger
|String
|Creates an instance of the specified named logger.
If an argument is specified, and the value is not falsy, the method returns a child logger with the specified name.
If an argument is specified, and the value is empty, the method returns the root logger.
If an argument is specified, and the value is null, the method returns the root logger or undefined if the logger hasn't been configured.
If no argument is specified, the method returns a logger with the name `antora`.
The logger is always created, if needed, unless the argument value is null.

|getVariables
|_none_
|Returns the object of context variables.
This object is read only.

|lockVariable
|String
|Locks the specified context variable and returns its value.

|replaceFunctions
|Object
|Binds the specified functions to the generator context and uses them to replace existing functions on the generator context.
If this method is called before the `contextStarted` event, the corresponding built-in generator functions will not be required and registered.

|removeVariable
|String
|Removes the specified context variable if the variable is not locked and returns its value.
An error is thrown if the variable is locked.

|require
|String
|Requires the name of a module in the context of the Antora generator.
This method can be used to require Antora internals without having to declare the Antora component as a dependency.

|stop
|_none_
|Stops the operation of the generator (using an orderly shut down by emitting the `contextStopped` and `contextClosed` events) and exits using the specified exit code.
If an exit code is not specified, the process will use the exit code set on the process, or 0 if no exit code is set.

|updateVariables
|Object
|Adds or replaces the context variables with the specified variables.
|===

Since the GeneratorContext is an EventEmitter, you not only can use it to register listeners, but to get a list of registered listeners, unregister listeners, and reregister listeners in a different order.

// /docs/modules/extend/pages/extension-use-cases.adoc
[[extension-use-cases.adoc]]
= Extension Use Cases

This page provides a catalog of simple examples to showcase how you can enhance the capabilities of Antora through the use of extensions.
Each section introduces a different use case and presents the extension code you can build on as a starting point.

You can also reference official extension projects provided by the Antora project to study more complex examples.

== Set global AsciiDoc attributes

If you want to define global AsciiDoc attributes that dynamic values, you can do using an extension.
The playbook holds the AsciiDoc config object, which itself contains the global AsciiDoc attributes.
An extension can listen for the `playbookBuilt` event and add attributes to this map.

.set-global-asciidoc-attributes-extension.js
[,js]
----
include::example$set-global-asciidoc-attributes-extension.js[lines=3..]
----

The extension could read these values from a file or environment variables as well.

If you need to set AsciiDoc attributes that are scoped to a component version, then you'll need to listen for the `contentClassified` event instead.
From there, you can access the AsciiDoc attributes form the `asciidoc` property on a component version object.
You can look up a component version by name and version using the `getComponentVersion` method on the content catalog object.
Alternately, you can access component versions from the `versions` property on each component returned by the `getComponents` method on the content catalog object.

== Print AsciiDoc attributes

If you're troubleshooting your site, you can use an extension to generate a report of AsciiDoc attributes at the site level and those per component verison.
When making this report, you have a choice of whether you want to show the AsciiDoc attributes as they would be available to a page (aka compiled) or as defined (aka uncompiled)

You can use the following extension to print all the AsciiDoc attributes compiled for each component version.
The extension also prints all the attributes compiled from the playbook, though keep in mind these are integrated into the attributes for each component version.

.print-compiled-asciidoc-attributes-extension.js
[,js]
----
include::example$print-compiled-asciidoc-attributes-extension.js[lines=3..]
----

You can use the following extension to print all the AsciiDoc attributes as defined in the playbook and in the antora.yml file for each component version (by origin).

.print-defined-asciidoc-attributes-extension.js
[,js]
----
include::example$print-defined-asciidoc-attributes-extension.js[lines=3..]
----

You may find it useful to make use of these collections of AsciiDoc attributes when writing other extensions.

== Exclude private content sources

If some contributors or CI jobs don't have permission to the private content sources in the playbook, you can use an extension to filter them out instead of having to modify the playbook file.

This extension runs during the `playbookBuilt` event.
It retrieves the playbook, iterates over the content sources, and removes any content source that it detects as private and thus require authentication.
We'll rely on a convention to communicate to the extension which content source is private.
That convention is to use an SSH URL that starts with `git@`.
Antora automatically converts SSH URLs to HTTP URLs, so the use of this syntax merely serves as a hint to users and extensions that the URL is private and is going to request authentication.

.exclude-private-content-sources-extension.js
[,js]
----
include::example$exclude-private-content-sources-extension.js[]
----

This extension works because the playbook is mutable until the end of this event, at which point Antora freezes it.
The call to `this.updateVariables` to replace the `playbook` variable in the generator context is not required, but is used here to express intent and to future proof the extension.

== Unpublish flagged pages

If you don't want a page to ever be published, you can prefix the filename with an underscore (e.g., _hidden.adoc).
However, if you only want the page to be unpublished conditionally, then you need to reach for an extension.

When using this extension, any page that sets the `page-unpublish` page attribute will not be published (meaning it will be unpublished).
For example:

[,asciidoc]
----
= Secret Page
:page-unpublish:

This page will not be published.
----

You can set the `page-unpublish` page attribute based on the presence (or absence) of another AsciiDoc attribute, perhaps one set in the playbook or as a CLI option.
For example:

[,asciidoc]
----
= Secret Page
\ifndef::include-secret[:page-unpublish:]

This page will not be published.
----

This extension runs during the `documentsConverted` event.
This is the earliest event that provides access to the AsciiDoc metadata on the virtual file.
The extension iterates over all publishable pages in the content catalog and unpublishes any page that sets the `page-unpublish` attribute.
To unpublish the page, the extension removes the `out` property on the virtual file.
If the `out` property is absent, the page will not be published.

.page-unpublish-tag-extension.js
[,js]
----
include::example$page-unpublish-flag-extension.js[]
----

Keep in mind that there may be references to the unpublished page.
While they will be resolved by Antora, the target of the reference will not be available, which will result in a 404 response from the web server.

For more fine-grained control over when a page is unpublished, you could write an extension that replaces the `convertDocument` or `convertDocuments` functions.
Doing so would allow you to unpublish the page before references to it from other pages are resolved so that they appear as warnings.

== Report unlisted pages

After you create a new page, it's easy to forget to add it to the navigation so that the reader can access it.
We can use an extension to identify pages which are not in the navigation and report them using the logger.

This extension runs during the `navigationBuilt` event.
It iterates over each component version, retrieves a flattened list of its internal navigation entries, then checks to see if there are any pages that are not in that list, comparing pages by URL.
If it finds any such pages, it creates a report of them, optionally adding them to the navigation.

.unlisted-pages-extension.js
[,js]
----
include::example$unlisted-pages-extension.js[tags=**]
----

You can read more about this extension and how to configure it in the xref:extension-tutorial.adoc[].

== Unpublish unlisted pages

Instead of reporting unlisted pages, you could instead remove those pages from publishing.
This is one way you can use the navigation to drive which pages are published.

This extension runs during the `navigationBuilt` event.
It iterates over each component version, retrieves a flattened list of its internal navigation entries, then checks to see if there are any pages that are not in that list, comparing pages by URL.
If it finds any such pages, it unpublishes them.

.unpublish-unlisted-pages-extension.js
[,js]
----
include::example$unpublish-unlisted-pages-extension.js[]
----

By removing the `out` property from the page, it prevents the page from being published, but is still referenceable using an include directive.
Alternately, you could choose to remove the page entirely from the content catalog.

== List discovered component versions

When you're setting up your playbook, you may find that Antora is not discovering some of your component versions.
Using an extension, it's possible to list the component versions Antora discovers during content aggregation along with the content sources it took them from.

.discovered-component-versions-extension.js
[,js]
----
include::example$discovered-component-versions-extension.js[lines=3..]
----

If an entry is missing, then you know you may need to tune the content source definitions in your playbook.

For more information, you can print the whole bucket entry.

== Generate report of all pages

You can generate additional pages using an Antora extension.
This offers a way to generate report pages that summarize information about the site.

In this example, we'll generate a page that lists all the other pages in the same component verison.
This extension listens for the `documentsConverted` event, which is emitted once all the AsciiDoc-based pages have been converted to (embedded) HTML, but before the HTML layout has been applied.
The reason for using this event is twofold.
First, it provides access to the page title of each page.
Second, the page layout will be applied to the newly generated page.

.all-pages-report-extension.js
[,js]
----
include::example$all-pages-report-extension.js[lines=3..]
----

The key step of this extension is the call to `contentCatalog.addFile`.
This call adds a new file to the content catalog, in this case a page.
When generating the list of links, we use the `relativize` function from the AsciiDoc Loader to compute the relative URL from the start page of the component version and the target page, emulating the behavior of the xref macro in AsciiDoc.
The resulting report is written to the file [.path]_all-page.html_ at the root of the component version (adjacent to the start page).

== Audit includes

In order to audit include requests in an AsciiDoc document, you must intercept the built-in include processor that Antora provides.
Technically, this is not an Antora extension, but rather an Asciidoctor extension.
However, since it use facilities from Antora, it's acting like a specialized Antora extension.

IMPORTANT: When registering an Asciidoctor extension, make sure you're using the nested key `asciidoc.extensions` and not `antora.extensions`

What we'll do is intercept each include request and log an info message with information about the include and the stack leading up to the include.
To set up the include processor to intercept calls, it must be configured as the preferred processor by calling `this.prefer()`.
At the end of the process method, it must delegate back to the include processor provided by Antora.

WARNING: You must be careful when intercepting the include processor not to disrupt the built-in function of the include processor itself.
The include processor should not try to process the include itself as it won't be able to easily replicate the logic that Antora uses.
Rather, the include processor must delegate to Antora's include processor.

.audit-includes-asciidoctor-extension.js
[,js]
----
include::example$audit-includes-asciidoctor-extension.js[lines=3..]
----

In order to resolve the file being included, the processor must determine the file that contains the include directive from the cursor where the include directive is found or the file on which the extension is being run.
It then must use the content catalog to resolve the file from that context.

== Resolve attribute references in attachments

Files in the attachment family are passed directly through to the output site.
Antora does not resolve AsciiDoc attribute references in attachment files.
(Asciidoctor, on the other hand, will resolve AsciiDoc attribute references in the attachment's contents only if the attachment is included in an AsciiDoc page where the attribute substitution is enabled.)
You can use an Antora extension to have Antora resolve attribute references in the attachment file before that file is published.

This extension runs during the `contentClassified` event, which is when attachment files are first identified and classified.
It iterates over all attachments and resolves any references to attributes scoped to that attachment's component version.
If any changes were made to the contents of the file, it replaces the contents on the virtual file with the updated value.

.resolve-attributes-references-in-attachments-extension.js
[,js]
----
include::example$resolve-attribute-references-in-attachments-extension.js[]
----

This extension is only know to work with text-based attachments.
You may need to modify this extension for it to work with binary files.

== Convert word processor attachments to PDF

Much like AsciiDoc files (.adoc) are converted to HTML (.html) by Antora, you can do the same with attachments.
This extension runs during the `contentClassified` event, which is when attachment files are first identified and classified.
It iterates over all attachments in a word processor format (i.e., .docx, .odt, .fodt) and uses the *libreoffcie* command (LibreOffice in server mode) to convert each file to PDF.

.doc-to-pdf-extension.js
[,js]
----
include::example$doc-to-pdf-extension.js[lines=3..]
----

By converting the files and updating the metadata, it's possible to reference the source document using the xref macro.
That reference will automatically translate to a link to the PDF in the generated site.

== Export content to file

If you are integrating with a search or AI engine, you may want to extract the plain text of the pages to a file along with the page url, title, and navigation path.
You can use the following extension to do that as part of the site build.

.export-content-extension.js
[,js]
----
include::example$export-content-extension.js[lines=3..]
----

Note that this extension relies on the *node-html-parser* package.
You will need to include that in your site [.path]_package.json_ file in order to use this extension.
In the future, Antora may provide a built-in HTML parser for extensions to use.

// /docs/modules/extend/pages/supported-components.adoc
[[supported-components.adoc]]
= Available and Supported Antora Components
:page-aliases: pipeline:supported-components.adoc
:navtitle: Antora Components
:table-caption!:
// URLs
:url-antora-lcs: https://gitlab.com/antora/antora/blob/main/LICENSE
:y: &#x2705;

On this page, you'll find the list of Antora components that can be assembled into a custom site generator pipeline.
Antora has a modular architecture so that components can be easily removed and replaced.
Due to its API, you can also integrate Asciidoctor extensions.

[#core]
== Core components

Core components are assembled into a pipeline by the Site Generator Default component.
The Core components are versioned together.

At this time, only Core components with the same version are designed to work together.
For example, if you want to use the Content Classifier and Page Composer in a custom site generator, make sure each component has the same version.

If you use the CLI (`@antora/cli`) with the site generator (`@antora/site-generator`), then you just have to keep the versions of the CLI and the site generator in sync.
If you make a custom site generator, you are responsible for keeping each individual component you use in sync.

== Extended components

Extended components provide key functionality for special use cases.
An example of an Extended component is a file publisher provider for an Amazon S3 bucket.
Once ready for xref:ROOT:project/release-schedule.adoc[general availability], Extended components are released and versioned individually.

[#component-matrix]
== Supported Core and Extended components matrix

[cols="4,4,^1,^1,1"]
|===
|Name / Package |Description |Core |Extended |License

|*AsciiDoc Loader* +
@antora/asciidoc-loader
|Reusable library for handling AsciiDoc content in Antora.
It loads AsciiDoc content into an AsciiDoc Document object (AST).
|{y}
|
|{url-antora-lcs}[MPL-2.0^]

|*CLI* +
@antora/cli
|Command line interface (CLI) for Antora.
|{y}
|
|{url-antora-lcs}[MPL-2.0^]

|*Content Aggregator* +
@antora/content-aggregator
|Fetches and aggregates content distributed across multiple local and remote git repositories.
|{y}
|
|{url-antora-lcs}[MPL-2.0^]

|*Content Classifier* +
@antora/content-classifier
|Organizes aggregated content into a virtual file catalog.
|{y}
|
|{url-antora-lcs}[MPL-2.0^]

|*Document Converter* +
@antora/document-converter
|Converts AsciiDoc documents to embeddable HTML.
|{y}
|
|{url-antora-lcs}[MPL-2.0^]

|*Logger* +
@antora/logger
|Provides the infrastructure for logging, shaping, and reporting application messages.
|{y}
|
|{url-antora-lcs}[MPL-2.0^]

|*Navigation Builder* +
@antora/navigation-builder
|Builds a navigation catalog sourced from navigation files.
This navigation catalog can be used to add site navigation to pages.
|{y}
|
|{url-antora-lcs}[MPL-2.0^]

|*Page Composer* +
@antora/page-composer
|Wraps the embeddable HTML contents of each page file from the content catalog in an HTML page layout.
This step yields the standalone HTML pages in the generated site.
|{y}
|
|{url-antora-lcs}[MPL-2.0^]

|*Playbook Builder* +
@antora/playbook-builder
|The configuration component that builds a playbook object from user input.
|{y}
|
|{url-antora-lcs}[MPL-2.0^]

|*Redirect Producer* +
@antora/redirect-producer
|Produces redirects (HTTP redirections) to a given page from its registered aliases.
|{y}
|
|{url-antora-lcs}[MPL-2.0^]

|*Site Generator* +
@antora/site-generator
|The site generator for Antora.
Invoked by the `generate` command of Antora's CLI to produce and publish static documentation sites.
This package groups (i.e., has a dependency on) all the other non-extension packages except for the CLI.

_Renamed from @antora/site-generator-default._
|{y}
|
|{url-antora-lcs}[MPL-2.0^]

|*Site Mapper* +
@antora/site-mapper
|Generates the sitemap files for the site.
These files, which are intended to be read by crawlers, provide a list of all published pages by URL.
|{y}
|
|{url-antora-lcs}[MPL-2.0^]

|*File Publisher* +
@antora/file-publisher
|Publishes (i.e., writes) the publishable files in the virtual file catalogs to the destination(s) specified in the playbook.

_Renamed from @antora/site-publisher._
|{y}
|
|{url-antora-lcs}[MPL-2.0^]

|*UI Loader* +
@antora/ui-loader
|Downloads and caches the UI bundle, then extracts and loads the files from that bundle into a UI catalog.
The UI files are combined with the content files at the end of the Antora documentation pipeline to produce a complete site.
|{y}
|
|{url-antora-lcs}[MPL-2.0^]

|*Lunr Extension* +
@antora/lunr-extension
|An Antora extension that integrates with Lunr to add offline, full-text search powered by Lunr to your Antora documentation site.
|
|{y}
|{url-antora-lcs}[MPL-2.0^]
|===

// Custom components

// /docs/modules/ROOT/pages/project/get-help.adoc
[[project:get-help.adoc]]
= Get Help
// URLs
:url-issues: {url-repo}/issues
:url-twitter: https://twitter.com/antoraproject
:url-twitter-hash: https://twitter.com/hashtag/antora?src=hash
:url-contributing: https://gitlab.com/antora/antora/blob/main/contributing.adoc

Antora is designed to help you write and publish your documentation.
However, we can't fully realize this goal without your feedback!
We encourage you to report issues, ask questions, share ideas, or discuss other aspects of this project using the communication channels provided below.

== Chat

*The project chat is the preferred means of communication for all users of Antora.*
This policy helps keep the project sustainable.

If you want to ask for help, share feedback, or exchange ideas with project maintainers and fellow community members in real time, please join us in the project chat.

* {url-chat}[Chat^] (Zulip)

The chat is partitioned into channels by subject matter.
This partitioning helps to keep conversations organized and makes it possible to filter topics to follow.
When you first join, spend a few minutes to get familiar with where topics are being discussed.

IMPORTANT: Please do not send direct messages to the maintainers asking for help with Antora.
The project maintainers do not provide 1-on-1 support.
All support should be done in the public channels, most often the `#users` channel.
Direct messages should only be used for personal matters.

Before starting a new topic, use the filter or search feature to look for existing topics before starting a new one.
You may find the information you're seeking within the discussions that have already taken place.
If you find an ongoing (i.e., unresolved) discussion that matches the topic of your post, feel free to join in that discussion.

If you can't find an existing topic that answers your question, or it's already been marked as resolved, you can start a new topic.
We ask that you select an appropriate channel before you create a new topic.
If you aren't sure where to post, create a new topic in the `#users` channel and a moderator will reclassify it if necessary.
No action is needed on your part.

Once you've selected a channel, click "`New Topic`", enter a subject, write your post, then click "`Send`".
You can also select a channel after you click "`New Topic`".

The discussions in the project chat are archived and public.
There's no guarantee the logs will be saved indefinitely, though we do plan keep them as long as we're permitted to do so.

The project chat is not 1-on-1 support.
You're in a public space.
Users participate in the project chat voluntarily.
Please be respectful of their time and interests.

IMPORTANT: Do not `@` mention someone when writing a message unless a) the subject matter absolutely requires the attention of that person or b) that person has already replied to the topic and is interacting with you.
Using the `@` mention to draw attention to your question is not courteous to that person or fair to others participating.
You're free to post your message to the community at large (no `@` mention).
If someone has something to share in response, they will do so if and when they have time.
You can reference someone without notifying them using the `@_` prefix, which is considered acceptable conduct.

== Issues

The issue tracker is used to track changes to the software and for planning releases.
The issue tracker is not a support portal.
Instead, the issue tracker is reserved for reporting problems (verifiable bugs, regressions, and security vulnerabilities) and requesting new features.
If you aren't confident that a change to the software is required, please post to the <<Chat>> instead.

* {url-issues}[Issue tracker^] (GitLab)

Any significant change to the software or decision about the project must be logged in the issue tracker.

== Twitter

If you want to share your experience with Antora or help promote it, we encourage you to post about it on social media.
When you talk about Antora on Twitter, you can mention the official account for the project:

* {url-twitter}[@antoraproject^] -- The official Antora account on Twitter.

You can also use the {url-twitter-hash}[#antora^] hashtag to promote the project or discover other people talking about it.

== Code and content contributions

If you're interested in helping the maintainers improve the project, then check out the {url-contributing}[Antora contributing guidelines^].

// /docs/modules/ROOT/pages/security-bulletins.adoc
[[security-bulletins.adoc]]
= Security Bulletins

A prompt response to software defects and security vulnerabilities is a top priority for Antora. Even though threats are a fact of life, we take quality assurance seriously with nearly 100% test coverage. This page documents the items that slipped through and how to address them.

== inflight and glob deprecation notice

=== Summary

Asciidoctor.js depends on asciidoctor-opal-runtime, which depends on a deprecated version of the glob package.
The glob package, in turn, depends on the deprecated inflight package.
We're aware of this problem and are planning to eliminate glob from the dependency chain as soon as we're able to.

=== Affected versions

All versions of Antora.

=== Remediation plan

You can explicitly upgrade the glob dependency in your dependency chain, thus eliminating the warning emitted by npm, by adding the following override to your [.path]_package.json_ file:

[,json]
----
"overrides": {
  "asciidoctor-opal-runtime": {
    "glob": "~10.4"
  }
}
----

This remediation is used in the https://gitlab.com/antora/docs.antora.org/-/blob/main/netlify/package.json[build for this site].
Unfortunately, npm overrides can only be used by the consumer of a library, not the library itself.
Thus, this is not a remediation solution Antora itself can enact.

=== Assessment

Fortunately, Antora never uses the glob library that Asciidoctor.js depends on, so this deprecation is irrelevant.
However, we recognize that the notice is annoying and may trigger security protocols for users who see it.

=== References

* https://docs.npmjs.com/cli/v8/configuring-npm/package-json#overrides[package.json overrides]

// /docs/modules/ROOT/pages/project/release-schedule.adoc
[[project:release-schedule.adoc]]
= Antora Release Schedule
:navtitle: Release Schedule
:page-aliases: version-and-lifecycle-policies.adoc, project/roadmap.adoc
:table-caption!:

Each major release line of the Antora Core components is typically supported for one year after it enters general availability (GA).

[cols=6*]
|===
|Release Line |Latest Release |Status |GA |Maintenance |EOL

|Antora 3
|{release-version}
|Active
|2021/12/25
|TBD
|TBD

|Antora 2
|2.3.4
|EOL
|2018/12/25
|2022/01/25
|2022/02/25
|===

General Availability (GA):: A release line, such as Antora 2.x, enters general availability on the date the initial, final major version (e.g., Antora 2.0.0) of the software is released and available for download.

Active:: Release line is being actively improved and supported.

Maintenance:: Once a release line enters its maintenance period, only its most recent minor version will receive critical security patch releases.
A release line starts this phase 30 days after the next major release line goes GA.

End of Life (EOL):: The date after which the release line no longer receives support or releases.

== Version policy

Antora follows the semantic versioning rules.
Each Antora component release is versioned *major.minor.patch*.

Major::
Major releases occur when there are substantial changes in functionality or when new functionality breaks backwards compatibility.
Releases within the same major release line will maintain API compatibility.

Minor::
Minor releases add new features, improvements to existing features, and fixes that maintain backwards compatibility.

Patch::
Patch releases fix bugs and maintain backwards compatibility.
Only the latest minor release of a major release line will receive patches.
Patch releases happen as needed depending on the urgency of the fix.

Prerelease::
Major and minor releases may include prerelease versions (major.minor.patch-alpha.n | -beta.n | -rc.n).
Prerelease versions will be tagged as _next_ so that the npm client doesn't prefer a prerelease over a stable version.
Once a release candidate (rc) has been thoroughly tested, the stable release will be published.

[#roadmap]
== Roadmap

Refer to https://gitlab.com/antora/antora/-/milestones[Antora's milestones^] and https://gitlab.com/antora/antora/issues[issue tracker^] for a list of the currently scheduled development tasks.
The milestones are intended for informational purposes only.
The proposed features, their scope, and the release timeframes are estimates, not firm commitments.

// /docs/modules/ROOT/pages/project/copyright-and-license.adoc
[[project:copyright-and-license.adoc]]
= Antora Copyright and License
:navtitle: Copyright and License

== Copyright

Copyright (C) 2017-present OpenDevise Inc. and the individual contributors to Antora.

== License

Use of Antora is granted under the terms of the https://www.mozilla.org/en-US/MPL/2.0[Mozilla Public License Version 2.0 (MPL-2.0)].

== Trademarks

AsciiDoc(R) and AsciiDoc Language(TM) are trademarks of the Eclipse Foundation, Inc.

// /docs/modules/ROOT/pages/project/land-acknowledgement.adoc
[[project:land-acknowledgement.adoc]]
= Land Acknowledgement

== Our Statement

We would like to acknowledge that the Antora project is managed and primarily developed on land that occupies the traditional and unceded territories (Treaty of Fort Laramie: 1851 & 1868, Cession 426) of the Cheyenne, Očhéthi Šakówiŋ, and Ute Peoples, who have stewarded the land and its water for generations.

In offering this Land Acknowledgment, we affirm Indigenous sovereignty, history, and experiences.
May this acknowledgment express our commitment to listen to and honor the teachings of past and present Indigenous Peoples and to uphold their sacred relation to this land and water by helping to protect it.

== What is a Land Acknowledgment?

A Land Acknowledgment is a formal statement that gives thanks and gratitude to the Indigenous Peoples who worked and lived on the land in which we reside both presently and historically.
These statements honor Indigenous culture, their ancestral homelands, and the sacredness of land while recognizing the complex, ongoing history of colonialism and the privilege we have to live and work where we do.

You can learn more about the history of the Indigenous lands in the United States and Canada, and why acknowledging that history matters, at https://native-land.ca/resources/territory-acknowledgement/[Native Land Digital^].


// /docs/modules/install/partials/upgrade-checklist.adoc
[[install:upgrade-checklist.adoc]]
= Upgrade Checklist

[#checklist]
== Upgrade from Antora 2.3 to Antora {page-component-version} checklist

// tag::new[]
*Antora 2 is EOL*.
If you're currently using Antora 2, you may need to make the following changes to your documentation system before upgrading to Antora {page-component-version}.
If you're already using Antora 3.0, skip this section and go to xref:install:upgrade-antora.adoc#node[Upgrade Node.js].

Are you using an active LTS version of Node.js?::
We recommend upgrading to the {url-node-releases}[latest active long term support (LTS) release of Node].
Antora 3 officially supports Node.js 18 LTS, Node.js 20 LTS, and Node.js 22 LTS.
Antora 3 doesn't support Node.js versions that have reached end of life (EOL).
See xref:install:upgrade-antora.adoc#node[Upgrade Node.js] for instructions.

Have you updated your AsciiDoc syntax and Asciidoctor extensions to comply with the newest patch release of Asciidoctor.js 2.2?::
Antora 3 dropped support for Asciidoctor.js 1.5.9 (which provides Asciidoctor 1.5.8) and now depends on the latest patch version of Asciidoctor.js 2.2 (which provides Asciidoctor 2.0.x).
Asciidoctor 2 introduces a few substantive changes to existing features that may impact your documentation source content or UI.
See xref:ROOT:asciidoctor-upgrade-notes.adoc[] to learn about the affected features and the suggested actions you should take before upgrading to Antora 3.

Are you linking to attachment files?::
Using the AsciiDoc link macro (`+link:[]+`) and `+{attachmentsdir}+` attribute reference in the target value to reference an attachment has been deprecated in Antora 3.
Replace the link macro with the xref macro and use the attachment's resource ID to reference it.
See xref:page:attachments.adoc[] and xref:navigation:reference-resources.adoc[] to learn about the `attachment$` family coordinate and for usage examples.

Are any of your component versions unversioned?::
We've deprecated the use of the value `master`, when assigned to the `version` key, to identify an unversioned component.
In Antora 3, assign the tilde (`~`) to the `version` key in a component version's [.path]_antora.yml_ file to specify it as unversioned.
See xref:ROOT:component-with-no-version.adoc[] to learn more.

Make sure you're using file extensions when cross referencing pages or assigning `page-aliases` values.::
If the _.adoc_ file extension was missing from the resource ID in an xref macro or the value assigned to a `page-aliases` attribute, Antora 2 would automatically add _.adoc_ to the resource ID at runtime.
This fallback mechanism has been deprecated because the xref macro can now reference other non-AsciiDoc resources.
Review the resource IDs in your xrefs and `page-aliases` attributes to ensure the _.adoc_ extension is specified.

Are you depending on the default branches pattern in your playbook?::
The previous default branches pattern, `[master, v*]`, has been deprecated and replaced with `[HEAD, v{0..9}*]`.
It's unlikely this will cause a change when using remote repositories.
For local repositories, it may result in the worktree being used in cases it wasn't previously.

Do you use the antora-lunr add-on to integrate Lunr into your site?::
The antora-lunr add-on was designed for Antora 2 and is a community-maintained project.
In Antora 3, antora-lunr has been replaced by the https://gitlab.com/antora/antora-lunr-extension[Antora Lunr extension] (package: `@antora/lunr-extension`), which is an official Antora project.
This extension uses the new extension facility in Antora 3 to integrate Lunr into your site without having to resort to using a custom site generator.
We encourage you to migrate from antora-lunr to the Antora Lunr Extension when upgrading to Antora 3.

Do you use or maintain a custom site generator?::
In Antora 3, the site generator must declare the `@antora/logger` package as a dependency.
The CLI resolves the logger relative to the site generator.
If it cannot find it there, it will fall back to the logger provided by the CLI.
This may result in Antora configuring the wrong logger, which will result in the user to see a warning about the logger not being configured.
+
Also note that the recommended signature of the `generateSite` function has changed.
The function now accepts a single parameter, the playbook.
The old signature is still supported, but using it will result in the playbook being built a second time.
+
The site generator should also depend on the `@antora/file-publisher` package instead of `@antora/site-publisher`, though technically this isn't required.

Do you use a custom git credential manager?::
Isomorphic-git no longer includes the `cores` (plugin) API, so the call `git.cores.create('antora').set('credentialManager', customCredentialManager)` is going to fail.
Antora still honors the `cores` API, but the call to register the credential manager is now responsible for creating it (since it runs before Antora loads).
Refer to xref:playbook:private-repository-auth.adoc#custom[Configure a custom credential manager] for the latest instructions.

ifeval::["{route}" == "New"]
See xref:install:upgrade-antora.adoc[Upgrade Antora] for instructions when you're ready to upgrade to Antora 3.

== Antora 2.3 EOL

Antora 2.3 reached end of life (EOL) as of February 25, 2022.

endif::[]
// end::new[]


// /docs/modules/page/pages/examples.adoc
[[page:examples.adoc]]
= Examples
:page-aliases: examples-and-source-snippets.adoc

== Reusable, single source examples

Examples are useful for storing source code, queries, configuration parameters, terminal output, logs, data sets, and other non-AsciiDoc files, that you reuse in one or more pages throughout your site.
Changes you make to an example file will disseminate to all of the pages where you referenced the example the next time you build your site.

== Example filenames and file extensions

Example files are usually non-AsciiDoc files.
They're stored in an xref:ROOT:examples-directory.adoc[_examples_ directory].

// tag::filename[]
When saving a new example file, keep the following filename requirements and recommendations in mind:

* *Spaces aren't recommended* in example filenames.
While the AsciiDoc include directive does accept spaces in the target, some editing tools may not support it and is thus not recommended.
* *Uppercase letters and spaces aren't recommended* in example filenames.
Some file systems aren't case sensitive.
Therefore, file conflicts could occur when using git depending on the file system a writer is using.
* Save an example file with a valid file extension except when it's common industry practice for that specific file type, such as [.path]_Dockerfile_, to not have an extension.
Not using the correct file extension when saving an example file may limit your ability to apply some Antora extensions or upgrade to future capabilities.
// end::filename[]

Unlike publishable resources, an example file without a file extension isn't treated as a xref:ROOT:standard-directories.adoc#hidden-files[hidden file].
Antora will load an example that doesn't have a file extension into its content catalog and assign the example a resource ID for referencing.

Antora doesn't publish example files as individual site pages.
An xref:include-an-example.adoc[example must be referenced by an include directive] from a page, or resource that's eventually included in a page, for the example's content to be published.

== Example file usage

Typically, content from an example file is inserted into source, listing, and literal blocks.
Regardless of the component version an example file belongs to, it can be referenced by any page or partial in your site.
An example is referenced using its resource ID and the xref:include-an-example.adoc[AsciiDoc include directive].
You can even select regions or lines from an example, instead of all of the example's content, and insert only those regions or lines using the include directive's `tag`, `tags`, or `lines` attributes.

TIP: Examples shouldn't be confused with the AsciiDoc example block, though content from an example file can be inserted into an example block using an include directive.

//== Source materials used in other applications


// /docs/modules/page/pages/images.adoc
[[page:images.adoc]]
= Images
//:page-aliases: asciidoc:insert-image.adoc

Images are source files, such as photographs, diagrams, and screenshots, that are stored in an xref:ROOT:images-directory.adoc[_images_ family directory].
An image can be inserted into any page or partial, regardless of the module or component version it belongs to, using an AsciiDoc image macro.
AsciiDoc supports the PNG, JPG, SVG, and GIF (static and animated) image file formats.
It's also possible to create a link to an image using the xref macro.

== Block and inline image macros

There are two AsciiDoc image macro types, block and inline.
A xref:block-images.adoc[block image] is displayed as a discrete element on a page.

.Block image macro
----
This is a paragraph.

image::resource-id-of-target-image.ext[]
----

An xref:inline-images.adoc[inline image] is displayed in the flow of another element, such as a paragraph or sidebar block.

.Inline image macro
----
This sentence contains an inline image:resource-id-of-target-image.ext[] image.
----

== Link to a resource from an image macro

Using the `xref` element attribute, you can reference a page, attachment, element, or even another image from an image embedded in a page.

.xref element attribute assigned to an image macro
----
image::resource-id-of-target-image.ext[xref=resource-id.ext]
----

See xref:image-xref-and-link.adoc[] to learn more.

== AsciiDoc xref macro for images

An image can be cross referenced from a page using an xref:xref.adoc#xref-macro[AsciiDoc xref macro] and the images's resource ID (which must include the family).
The syntax follows that of an xref:attachments.adoc#make-link[attachment reference], except that the family must be `image` instead of `attachment`.
The result will be a link to an image rather than the rendered image.

TIP: If you want the image to be rendered in the page with a link to itself, use the xref:image-xref-and-link.adoc#link-self[self link] on the image macro instead.

<<ex-xref>> shows the structure of an xref macro with an images's fully qualified resource ID.

.Xref macro structure for referencing an image
[#ex-xref]
----
xref:version@component:module:image$file-coordinate-of-image.ext[optional link text]
----

At a minimum, an xref macro consists of the macro's prefix (`xref:`), the resource ID of the target image, and a set of square brackets (`[]`).
The [.term]*target image* is the image source file that's being referenced by the current page.
The target image is referenced by assigning its resource ID to an xref macro in the content of the current page.
The [.term]*current page* is the page source file containing the xref macro that references the target image.

How many of the target images's xref:resource-id-coordinates.adoc[resource ID coordinates] you need to specify depends on the component version and module of the target attachment in relation to the current page.

Here's a concrete example that shows how to link to an image in the same module:

[,asciidoc]
----
Click the image xref:image$my-image.png[] to see a screenshot of the form.
----

When linking to an image, the xref macro is structured and behaves much like when it's assigned the resource ID of a page, with three differences:

* The xref:resource-id.adoc[resource ID of an attachment] must specify the `image$` xref:resource-id-coordinates.adoc#id-family[family coordinate] when an image is assigned to an xref macro, otherwise Antora will assume the resource ID is that of a page at runtime.
* A fragment (element ID) can't be appended to the end of the image's resource ID.
* Images don't have default reference text.
If link text isn't specified in the xref macro, the target of the xref is displayed as the link text.


// /docs/modules/page/pages/index.adoc
[[page:index.adoc]]
= Pages

== Source page to site page

Antora automatically generates one HTML site page for each source file assigned to the pages family.
Another way to think about this: one AsciiDoc page file in equals one HTML page out.

[#standard-page]
== Standard source pages

Page source files are plain text files marked up with the xref:asciidoc:asciidoc.adoc[AsciiDoc syntax] and saved with the file extension `.adoc`.
They're stored in a xref:ROOT:pages-directory.adoc[_pages_ family directory].

A xref:standard-page.adoc[standard page has a title and body content].
You can use just a little AsciiDoc syntax to mark up your pages, or you can explore the breadth of AsciiDoc and Antora's capabilities such as scoped attributes, including tagged regions from resources, and UI macros.

== Linking pages

Antora automatically publishes all of the standard source pages to your site, but if you want to create page-to-page links in the content, you'll need to learn about xref:resource-id.adoc[Antora's resource IDs] and how to create xref:xref.adoc[cross references].
You'll also use cross references and resource IDs to build and organize your site's xref:navigation:index.adoc[component version page menus].
//If you don't want to include a page in a component menu, visitors will still be able to find it using search tools and through links to it on other pages, and in some scenarios, through dropdown menus such as the page version selector.


// /docs/modules/page/pages/partials.adoc
[[page:partials.adoc]]
= Partials
:page-aliases: partials-and-content-snippets.adoc, create-a-partial.adoc

== Reusable, single source content

Partials are good for storing snippets of content, such as common descriptions, project introductions, terminology, frequent admonitions, and reference tables, that you reuse in one or more pages throughout your site.
Changes you make to a partial will disseminate to all of the pages where you referenced the partial the next time you build your site.

== Partial filenames and file extensions

Partial files are stored in a xref:ROOT:partials-directory.adoc[_partials_ directory].
A partial file is usually marked up with AsciiDoc and saved with the  _.adoc_ file extension.
However, a partial isn't required to be an AsciiDoc file and, unlike publishable resources, a partial file without a file extension isn't treated as a xref:ROOT:standard-directories.adoc#hidden-files[hidden file].
Antora will load a partial that doesn't have a file extension into its content catalog and assign the partial a resource ID for referencing.

// tag::filename[]
When saving a new partial file, keep the following filename requirements and recommendations in mind:

* *Spaces aren't recommended* in partial filenames.
While the AsciiDoc include directive does accept spaces in the target, some editing tools may not support it and is thus not recommended.
* *Uppercase letters and spaces aren't recommended* in partial filenames.
Some file systems aren't case sensitive.
Therefore, file conflicts could occur when using git depending on the file system a writer is using.
* Save a partial file with the _.adoc_ extension when it's an AsciiDoc file, otherwise use the valid file extension for the file type.
You should only save a partial without a file extension when it's common industry practice for that specific file type to not have an extension.
Not using the correct file extension when saving a partial file may limit your ability to apply some Antora extensions or upgrade to future capabilities.
// end::filename[]

Antora doesn't publish partial files as individual site pages.
A xref:include-a-partial.adoc[partial must be referenced by an include directive] from a page, or resource that's eventually included in a page, for the partial's content to be published.

== Create a partial file

A partial is usually regular content marked up with AsciiDoc.
Unlike a page, a partial doesn't have any required structural elements, such as a title, though it can contain such elements.
In the next section, you'll see how to create a new partial file and mark it up with AsciiDoc.

=== Set up an AsciiDoc partial file

. Open a new file in your IDE or plain text editor.

. On the first line of the file, enter your content, such as paragraph text, a table, or an attribute entry.
In this example, let's create an admonition that's going to be used on several pages throughout a site.
+
----
[WARNING]
====
High, open places above the treeline are awe-inspiring--
but you need to be prepared for the altitude and
rapidly changing weather conditions.
====
----

. Once you finish creating your content, save the file with the extension `.adoc` in a [.path]_partials_ directory.
+
[listing]
----
📂 modules
  📂 ROOT
    📂 pages
      📄 a-source-file.adoc
    📂 partials
      📄 treeline-warning.adoc
----

You've created a partial!
Now, it's ready to be included in a page.
Regardless of the component version a partial belongs to, it can be referenced by any page or partial in your site using the partial's resource ID and xref:include-a-partial.adoc[AsciiDoc include directive].
You can even select regions or lines from a partial, instead of all of the partial's content, and insert only those regions or lines using the include directive's `tag`, `tags`, or `lines` attributes.

[#current-context]
== Current page context and structure

As you create the content in a partial, there are certain AsciiDoc elements that you may need to adjust according to the current page's context and structure.
A partial is converted after it's inserted into a page.
Therefore, the current page's component version, module, attributes, and other elements are applied to and may impact the included content.

=== Referencing pages and resources

Xrefs:: If the partial is included in pages that belong to other modules or docs components, you need to specify the resource ID of a target page or attachment that's assigned to an xref macro in the partial's content accordingly.
The number of resource ID coordinates required depends on the component version and module of the current page into which the partial is being inserted in relation to the target attachment or page being referenced by an xref macro in the partial's content.

Images, examples, and other partials:: A partial can reference other partials and examples using the include directive and images using the image macros.
Like when entering resource IDs in xrefs, the resource ID of the target resource may need additional coordinates specified depending on the component version and module of the current page that partial is being included into and the resource being referenced in the partial.

=== Section headings

A partial can contain section headings.
You may need to use the `leveloffset` attribute to adjust the partial's heading levels, depending on where you enter the referencing include directive in a current page.

=== Inline, block, and section IDs

Element IDs in a partial can't conflict with the element IDs of the page into which it's being inserted.

=== Attributes

xref:attributes.adoc[Attributes] can be set, assigned, and referenced in a partial.
When an attribute is referenced in a partial, either the partial, current page, or current page's component version descriptor must set and assign a value to the attribute.

If an attribute is set and assigned a value in a partial, the attribute will be available in the current page starting from the point where the partial is included.
In such cases, the partial's attribute will override an attribute with the same name that is set or unset in the current page's header or soft set or unset from the current page's component version descriptor.


// /docs/modules/page/pages/resource-id.adoc
[[page:resource-id.adoc]]
= Resources and Resource IDs

== What's a resource?

A [.term]*resource* is a source file that belongs to the pages, images, partials, examples, or attachments family.
Antora assigns each resource a unique identifier called an Antora resource ID.

[#publishable]
=== What's a publishable resource?

A [.term]*publishable resource* is a source file that belongs to the pages, attachments, or images family.
Antora automatically publishes page, attachment, and image files to your site, even if they aren't referenced in another resource.
This is in contrast to partial and example files.
The content of a partial or example is only published if it's referenced--either directly or by way of another partial or example that is eventually referenced--from a publishable resource.

[#whats-a-resource-id]
== What's a resource ID?

An [.term]*Antora resource ID*, or *resource ID* for short, is a unique and reliable set of identifying coordinates, organized in a standard sequence, that Antora automatically constructs from the properties assigned to each resource's source file.
You'll often use the resource ID of a resource to reference it from another resource.
A resource is referenced by assigning its resource ID to an AsciiDoc xref macro, include directive, image macro, or the few keys, attributes, or options that accept a resource ID as a value.
Antora then uses the assigned resource ID to look up the corresponding resource in its virtual file system.
xref:resource-id-coordinates.adoc[] describes the coordinates in a resource ID, where you find a resource's coordinates, and when you use each of the coordinates.

////
The most common reason for you to use a resource that you'll u of resource ID is to .
To reference a resource, enter its resource ID as the target value in an AsciiDoc xref macro, include directive, or image macro.
The image macro's xref option also accepts the resource ID of a publishable resource.
A few Antora keys and AsciiDoc attributes accept the resource ID of a page as a value.

When you reference a resource, the published result depends on the AsciiDoc syntax you use to reference the resource, the family of the resource, and, occasionally, the file format of the resource and a site visitor's browser settings.
For example, if you enter the resource ID for an image into an image macro, the image will be embedded in the page at the image macro's location.
However, if you enter the image's resource ID into an xref macro, a link to the image's published location will be displayed in the page.
How many resource ID coordinates you need to specify when referencing a resource depends on the component version and module of the xref:resource-id-coordinates.adoc#current[current page] in relation to the xref:resource-id-coordinates.adoc#target[target resource].
////

[#important]
== Why are resource IDs important?

*They're not coupled to a published URL* because they're a source-to-source reference.
Notice the page coordinate ends with [.path]_.adoc_, the file extension of an AsciiDoc source file.
Regardless of whether you're deploying your site locally, to a staging or production environment, or you change URL strategies, the resource ID always remains the same.
The xref locks on to the target page and produces a URL that points to it wherever it gets published.

*They're minimally coupled to the filesystem* by using an identifier based on the Antora's virtual component version classification system.

*They've eliminated the relative path (../../) problem* by specifying the resource as a family-relative directory path.
The path always starts from a family directory, even when the referencing resource is located inside a subdirectory of the family directory.
//If you move or rename a page within a module, you don't have to change any references to other pages.

*This human-friendly referencing system saves you from having to do computations in your head while writing*.
You just specify the coordinates of the page you want to reference.
There's no need to worry about the source file's physical location on disk or its published URL.
All you need to know are the names of your components, versions, modules, and pages so you can fill in this information.

////
This needs to go in a section about future development.

Of course, inbound references to the page you move do have to be updated.
To counter this, you could pin the page ID of the page you want to move, thus adding more stability.
That way, references to the page don't have to be updated even when it moves.
Though, a little help from the text editor to "`refactor`" references could make this abstraction unnecessary.

*We've made it possible to validate and update references* by using a well-defined pattern that's easy for a script to locate, parse, and rewrite.
////

[#duplicate-resources]
== Duplicate resources

Antora does not permit two resources (i.e., source files) to share the same resource ID.
This situation can occur under the following conditions:

. the [.path]_antora.yml_ file in more than one content source root declares the same name and version
. both content source roots have at least one file located at the same relative path (beginning from the start path)
. the conflicting files are both collected and classified by Antora

If this situation occurs, Antora will report the conflicting files by logging a fatal error and immediately stop building the site.

Which error you see depends on the order in which files are discovered.
If both component versions declare navigation files, you'll likely see a duplicate nav file error:

....
Duplicate nav file: modules/ROOT/nav.adoc in 1.0@name-of-component
    1: modules/ROOT/nav.adoc in https://git-host/repo-name.git (branch: v1.0.x)\n' +
    2: modules/ROOT/nav.adoc in https://git-host/repo-name.git (tag: v1.0.0)'
....

Otherwise, you'll see an error about a duplicate page or other resource:

....
Duplicate page: modules/ROOT/index.adoc in 1.0@name-of-component
    1: modules/ROOT/nav.adoc in https://git-host/repo-name.git (branch: v1.0.x)\n' +
    2: modules/ROOT/nav.adoc in https://git-host/repo-name.git (tag: v1.0.0)'
....

What this error is telling you is that two files are trying to claim the same resource ID.
This could indicate you have a redundant content source root configured in your playbook or that you've forgetten to update the version key in one of the [.path]_antora.yml_ files.
Study the git references that Antora cites to discover the cause.

If you're attempting to define a xref:ROOT:distributed-component-version.adoc[distributed component version], in which case the [.path]_antora.yml_ will declare the same name and version, then you need to remove the conflicting file from one of the two roots so there's no overlap.


// /docs/modules/page/partials/include-directive.adoc
[[page:include-directive.adoc]]
= Include directive

<<ex-base>> shows the structure of an include directive with the fully qualified resource ID of {article} {family}.

.Include directive assigned the fully qualified resource ID of {article} {family}
[#ex-base,subs=attributes+]
----
\include::version@component:module:{coordinate}file-coordinate-of-target-{family}{ext}[]
----

Let's break down the AsciiDoc include directive and resource ID coordinates you need to include {article} {family} (the target {family}) into a page (the current page).
// tag::target-current-def[]
[[target]]The [.term]*target {family}* is the source file of {article} {family} that's being referenced by the current page.
The target {family} is referenced by assigning its resource ID to an include directive in the content of the current page.
[[current]]The [.term]*current page* is the page source file containing the include directive that references the target {family}.
// end::target-current-def[]
The following steps assume the target {family} and current page belong to the same component version and module.

. In your IDE or plain text editor, open the page where you want to insert the {family}.
. Select the line in the current page where you want the {family}'s content to be inserted.
At the beginning of the line, enter the name of the directive followed by two colons, `include::`.
+
.current-page.adoc
[listing,subs=+quotes]
----
**include::**
----

. Enter the resource ID of the target {family}.
In this example, both the target {family} and current page belong to the same component version and module and the target {family} is stored at the root of the [.path]_{family}s_ directory.
Therefore, only the `{coordinate}` family coordinate and filename and extension of the target {family} needs to be assigned as the value of the include directive.
+
--
.current-page.adoc
[listing,subs="attributes+,+quotes"]
----
include::**{coordinate}target-{family}-filename{ext}**
----

NOTE: By default, the include directive assumes the family coordinate is `page$` when the coordinate isn't specified.
If you forget to use the `{coordinate}` coordinate, Antora will report an error because it won't be able to find the {family}.
--

. Directly after the resource ID of the target {family}, complete the directive with a set of square brackets (`+[]+`).
+
.current-page.adoc
[listing,subs="attributes+,+quotes"]
----
include::{coordinate}target-{family}-filename{ext}**[]**
----

. The brackets can contain an optional list of attributes, such as `lines`, `tag`, or `tags`.
The attributes are entered as key-value pairs separated by commas.
+
.current-page.adoc
[listing,subs="attributes+,+quotes"]
----
\include::{coordinate}target-{family}-filename{ext}[**optional attribute**]
----

That's it!
You've finished creating an include directive that will insert the target {family} into the current page.

The preceding instructions showed you how to insert {article} {family} into a page under the most common scenario--the target {family} and current page belong to the same component version and module and the target {family} is stored at the root of {article} [.path]_{family}s_ folder.
However, the structure of the target {family}'s file coordinate varies depending on whether the target {family} is stored at the root of the [.path]_{family}s_ family directory or in a subdirectory of the [.path]_{family}s_ directory.

.current-page.adoc
[listing#ex-file,subs="attributes+"]
----
include::{coordinate}target-{family}-filename{ext}[] <.>

include::{coordinate}path/to/target-{family}-filename{ext}[] <.>

include::{coordinate}./target-{family}-filename{ext}[] <.>
----
<.> File coordinate of the target {family} when it's stored at the root of the [.path]_{family}s_ directory.
<.> File coordinate of the target {family} when it's stored in a subdirectory of the [.path]_{family}s_ directory.
<.> File coordinate of the target {family} when the target {family} and current page are stored in a subdirectory with parallel family-relative directory paths.
_This is an advanced use case._

Also, the resource ID of the target {family} needs to specify additional coordinates when the target {family} and current page don't belong to the same module or component version.
The following sections provide examples showing the various resource ID scenarios.

Antora supports filtering the lines of an example or partial by either line numbers using the `lines` attribute or tags using the `tag` or `tags` attributes.
Filtering by line numbers takes precedence.
See the {url-asciidoc}/directives/include/[AsciiDoc include directive documentation] for full details about the `lines`, `tag`, and `tags` syntax.


// /docs/modules/playbook/partials/playbook-project-summary.adoc
[[playbook:playbook-project-summary.adoc]]
= Playbook Project Summary

A playbook is usually located in a playbook project.
A playbook project repository is responsible for generating a documentation site.
It's strictly a _configuration as code_ repository--it does not contain any content.
Instead, it contains a playbook file, and, in certain situations, supplemental UI files and extension code.


// /docs/modules/playbook/partials/playbook-vs-descriptor.adoc
[[playbook:playbook-vs-descriptor.adoc]]
= Playbook vs Descriptor

[NOTE]
.Playbook file versus component version descriptor file
====
Attributes are declared using the same structure and syntax in both the playbook file and the component version descriptor file.

The xref:playbook:index.adoc[playbook] is where you configure the site, content sources, and UI URLs.
A playbook file usually has the word _playbook_ in its filename, e.g., [.path]_antora-playbook.yml_ or [.path]_local-antora-playbook.yml_.

A xref:ROOT:component-version-descriptor.adoc[component version descriptor] is where you configure the name, version, metadata, attributes, and navigation list of a xref:ROOT:component-version.adoc[component version].
A component version descriptor's filename is always [.path]_antora.yml_.
// tag::note-for-extension-writers[]

_For extension writers._
If no AsciiDoc attributes are defined in the component descriptor, the `asciidoc` property on the component version object will reference the site-wide AsciiDoc config object (i.e., `siteAsciiDocConfig`).
If you plan to modify component version attributes, first check if the value of the `asciidoc` property matches (`===`) the site-wide object and make a deep copy of it if so.
// end::note-for-extension-writers[]
====


// /docs/modules/playbook/partials/relative-path-rules.adoc
[[playbook:relative-path-rules.adoc]]
= Relative Path Rules

A relative path is expanded to an absolute path using the following rules:

* If the first path segment is a tilde (`~`), the remaining path is resolved relative to the user's home directory.
* If the first path segment is a dot (`.`), the remaining path is resolved relative to the location of the playbook file.
* If the first path segment is a tilde directly followed by a plus sign (`~+`), or does not begin with an aforementioned prefix, the remaining path is resolved relative to the current working directory.


// /docs/modules/ROOT/pages/index.adoc
[[ROOT:index.adoc]]
= Antora Documentation

:keywords: Docs as Code, DocOps, content management system, docs writers, publish software documentation, CI and docs, CD and docs

[discrete.tagline]
=== The Static Site Generator for Tech Writers

This site hosts the technical documentation for Antora.
Antora makes it easy for tech writers to create documentation and publish it to the web.
As a tech writer, you focus on authoring content in xref:asciidoc:asciidoc.adoc[AsciiDoc], Antora's content markup language.
You organize those files into a standard project structure and store them in one or more content (git) repositories.
Antora picks up your content from there and transforms it into a website.
That's all there is to it!

////
== Generator pipeline

Antora's site generator pipeline is a complete end-to-end solution for publishing.
While it can be extended, no additional scripts are needed.

Antora's generator pipeline kicks off by aggregating files from a variety of sources.
Currently, these sources can be branches of one or more git repositories and a UI bundle.

//NOTE: By leveraging Antora's open architecture, you can incorporate just about any other type of content too.

Next, Antora organizes the files into catalogs.
It then uses Asciidoctor to convert all content files to embeddable HTML and resolve links between pages.

Once conversion is complete, Antora passes the embeddable HTML as part of a UI data model to Handlebars templates provided by the UI bundle to create the web pages.

Finally, it publishes the pages and supporting content and UI assets to one or more local or remote destinations, where they can be viewed as a website.

Antora's built-in orchestration makes it very CI-friendly.
All the CI job has to do is prepare the environment and launch a single command, and out comes your site!
////

== Manage docs as code

With Antora, you manage *docs as code*.
That means your documentation process benefits from the same practices used to produce successful software.

Some of these practices include:

* Storing content in a version control system.
* Separating content, configuration, and presentation.
* Leveraging automation for compilation, validation, verification, and publishing.
* Reusing shared materials (DRY).

Antora helps you incorporate these practices into your documentation workflow.
As a result, your documentation is much easier to manage, maintain, and enhance.

////
//== Content is sovereign
== Documentation as Code

While it's considered a best practice to split source code into discrete, well-defined modules, documentation for that code often gets lumped into one massive "`book`".
This situation has brought many documentation projects to a grinding halt.

By treating *docs as code*, the documentation process can benefit from the best practices that produce successful software.
Antora helps you incorporate these practices into your documentation workflow.

Antora favors a modular approach to managing documentation.
It consists of a playbook, content repositories, a UI bundle, and the site generator pipeline, all of which are discrete parts.
//The playbook controls how Antora generates and publishes your site, but it does not own any content itself.

The separation of these domains keeps the configuration separate from content.
The content repositories just contain content.
They can be enlisted, per branch, into the site generation process.

This strategy makes it possible for content branches to be reused, substituted, deactivated, or archived.
This is a sharp contrast to many other site generators that intermix all of these concerns, making the documentation difficult to manage, maintain, and enhance.
////

== Where to begin

If you're just beginning your journey with Antora, you'll probably want to know xref:features.adoc[how Antora can help you].
When you are familiar with the basic concepts, you can try out Antora using the xref:install-and-run-quickstart.adoc[Antora quickstart guide].

If you're ready to set up a new documentation project, or you want to migrate an existing project to Antora, start by xref:organize-content-files.adoc[organizing your documentation files] into the project structure Antora expects.
You'll then need to xref:playbook:index.adoc[create a playbook] to tell Antora where to find the documentation and UI to use for your site.

If you already have a documentation component set up, and you're ready to create your first site, check that you've met Antora's xref:install:supported-platforms.adoc[system requirements], then xref:install:install-antora.adoc[install Antora], and finally xref:run-antora.adoc[generate your site] using the `antora` command.

If you want to jump into writing, learn how to use the AsciiDoc syntax to xref:page:index.adoc[create documentation pages].
You may find the https://intellij-asciidoc-plugin.ahus1.de/docs[IntelliJ AsciiDoc Plugin] to be an author's best friend.
Not only does it assist with writing and previewing AsciiDoc content, it also provides state of the art tooling for creating and validating Antora configuration and resource references.

If you want to dive deeper into the details of the site generator pipeline, check out xref:how-antora-works.adoc[how Antora works].

We hope you find making documentation sites with Antora enjoyable and rewarding.
Happy writing!


// /docs/modules/ROOT/partials/assets-directory.adoc
[[ROOT:assets-directory.adoc]]
= Assets Directory

[#assets-dir]
.Assets
****
A module directory can also contain a directory named [.path]_assets_.
This is an alternate location, recognized by Antora, where the [.path]_attachments_ and [.path]_images_ family directories can be placed.

[listing]
----
📒 repository
  📄 antora.yml
  📂 modules
    📂 ROOT
      📂 assets
        📂 attachments
          📄 attachment-source-file.ext
        📂 images
          📄 image-source-file.ext
      📁 pages
      📄 nav.adoc
----

You don't need to set the path to these predefined directories in the header of your pages.
This is managed automatically by Antora.
****


// /docs/modules/ROOT/partials/dont-use-these-attributes.adoc
[[ROOT:dont-use-these-attributes.adoc]]
= Don't use these Attributes

CAUTION: Some built-in AsciiDoc attributes are not applicable in the Antora environment.
These attributes include `data-uri`, `allow-uri-read`, `docinfo`, `linkcss`, `noheader`, `nofooter`, `webfonts`, and `outfilesuffix`.
Setting these attributes either has no effect or may cause Antora to malfunction.
Other attributes, such as `imagesdir`, are automatically set by Antora and cannot be overridden.


// /docs/modules/ROOT/partials/optional-component-version-keys.adoc
[[ROOT:optional-component-version-keys.adoc]]
= Optional Componet Version Keys

[cols="1,5"]
|===
|Optional Key |Description

|xref:component-attributes.adoc[asciidoc.attributes]
|The `asciidoc` key accepts the `attributes` key and its nested list of key-value pairs.
The key-value pairs listed under `attributes` represent built-in and user-defined xref:page:define-and-modify-attributes.adoc[AsciiDoc attributes] (e.g., `idseparator: '-'`) and xref:page:page-attributes.adoc[page attributes].
Attributes in [.path]_antora.yml_ are applied to all of the xref:page:index.adoc[pages] and xref:page:resource-id.adoc[resources] (where applicable) that belong to a component version.

|xref:component-display-version.adoc[display_version]
|Version identifier used for presentation purposes only in the reference UI's component version selector and page version selector.
`display_version` accepts empty spaces, uppercase letters, and most characters (e.g., `3.0 Beta`, `RED WREN!`).

|xref:component-navigation.adoc[nav]
|Accepts a list of navigation files.
Navigation files (e.g., [.path]_nav.adoc_) that are registered under the `nav` key are used in the component version's page menu.

|xref:component-prerelease.adoc[prerelease]
|Designates a component version as a prerelease version and deactivates the default routing rules.
Key can append a prerelease identifier (e.g., `-alpha.2`) to `version` without affecting the version coordinate or version URL segment.

|xref:component-start-page.adoc[start_page]
|Specifies a page as the component version's home page.
By default, Antora uses [.path]_index.adoc_ in a component version's ROOT module.

|xref:component-title.adoc[title]
|Component name used for sorting and presentation purposes only in the reference UI's component version page menu, component version selector, and page breadcrumbs.
Accepts empty spaces, uppercase letters, and a broad range of characters (e.g., `API Manager`).
|===


// /docs/modules/ROOT/partials/pipeline-steps-list.adoc
[[ROOT:pipeline-steps-list.adoc]]
= Pipline Step List

When Antora runs, it performs the following steps:

. Clones the git-based content repositories using the provided git client isomorphic-git (or fetches them if they're already cloned and configured to do so).
. Resolves and downloads the UI bundle over HTTPS (unless it's already cached).
. Locates and reads all AsciiDoc files.
. Locates and reads all navigation files.
. Converts AsciiDoc files to embeddable HTML.
. Wraps the embeddable HTML in the page template and adds the navigation tree, which is also converted to HTML.
. Reads asset files (images, attachments, and UI resources).
. Writes all site files to [.path]_build/site_.

//The following sections describe a few of these steps in more detail.


// /docs/modules/ROOT/partials/required-component-version-keys.adoc
[[ROOT:required-component-version-keys.adoc]]
= Required Component Version Keys

[cols="1,5"]
|===
|Required Key |Description

|xref:component-name-key.adoc[name]
|Component name used with `version` to identify a component version.
Used as the component coordinate in resource IDs and in the component URL segment for a component version's published resources.

|xref:component-version-key.adoc[version]
|Version used with `name` to identify a component version.
Used as the version coordinate in resource IDs and as the version segment for a component version's published resource URLs, except when a xref:component-with-no-version.adoc[component version is defined as unversioned].

Specifying the `version` key in a component version descriptor file is optional if the value of the key is inherited from the xref:playbook:content-source-version.adoc[content source in the playbook].
You can specify the `version` key on the content source if you want the value to be automatically derived from the refname or based on a refname mapping.
|===


// /docs/modules/ROOT/partials/videos-directory.adoc
[[ROOT:videos-directory.adoc]]
= Videos Directory

// Don't use this partial because this feature isn't active.

[#videos-dir]
== Video files

Self-hosted video files are saved in [.path]_assets/videos_ in the same module where the page that references that video is located.
Videos are inserted into a page using the xref:asciidoc:embed-video.adoc[AsciiDoc video macro].


// /docs/modules/extend/examples/all-pages-report-extension.js
[[extend:examples:all-pages-report-extension.js]]
= Examples all-pages-report-extension.js

[source,js]
-----------
'use strict'

module.exports.register = function () {
  const relativize = this.require('@antora/asciidoc-loader/util/compute-relative-url-path')
  this.once('documentsConverted', ({ contentCatalog }) => {
    contentCatalog.getComponents().forEach(({ versions }) => {
      versions.forEach(({ name: component, version, url }) => {
        const pageList = ['<ul>']
        const pages = contentCatalog
          .findBy({ component, version, family: 'page' })
          .sort((a, b) => a.title.localeCompare(b.title))
        for (const page of pages) {
          pageList.push(`<li><a href="${relativize(url, page.pub.url)}">${page.title}</a></li>`)
        }
        pageList.push('</ul>')
        const pageListFile = contentCatalog.addFile({
          contents: Buffer.from(pageList.join('\n') + '\n'),
          src: { component, version, module: 'ROOT', family: 'page', relative: 'all-pages.html' },
        })
        pageListFile.asciidoc = { doctitle: 'All Pages' }
        // use the following assignment instead to use a separate layout (e.g., report.hbs)
        //pageListFile.asciidoc = { doctitle: 'All Pages', attributes: { 'page-layout': 'report' } }
      })
    })
  })
}
-----------


// /docs/modules/extend/examples/audit-includes-asciidoctor-extension.js
[[extend:examples:audit-includes-asciidoctor-extension.js]]
= Examples audit-includes-asciidoctor-extension.js

[source,js]
-----------
'use strict'

module.exports.register = (registry, context) => {
  registry.$groups().$store('audit-includes', toProc(createExtensionGroup(context)))
  return registry
}

function createExtensionGroup ({ contentCatalog, file }) {
  return function () {
    this.includeProcessor(function () {
      this.prefer()
      this.process((doc, reader, target, attrs) => {
        const cursor = reader.$cursor_at_prev_line()
        const from = cursor.file?.src || file.src
        this.logger ??= require('@antora/logger')('asciidoctor')
        const resource = contentCatalog.resolveResource(target, from)
        this.logger.info({ file: resource.src, stack: [{ file: from, line: cursor.lineno }] }, `include: ${target}`)
        const delegate = doc.getExtensions().getIncludeProcessors().find((it) => it.instance !== this)
        return delegate.process_method['$[]'](doc, reader, target, global.Opal.hash(attrs))
      })
    })
  }
}

function toProc (fn) {
  return Object.defineProperty(fn, '$$arity', { value: fn.length })
}
-----------


// /docs/modules/extend/examples/background-fetch-and-publish-readme-extension.js
[[extend:examples:background-fetch-and-publish-readme-extension.js]]
= Examples background-fetch-and-publish-readme-extension.js

[source,js]
-----------
const https = require('node:https')

class FetchAndPublishReadmeExtension {
  // alternate way to export register method
  //static register ({ config }) {
  //  return new FetchAndPublishReadmeExtension(this, config)
  //}

  constructor (context, config) {
    ;(this.context = context)
      .on('playbookBuilt', this.onPlaybookBuilt.bind(this))
      .on('beforePublish', this.onBeforePublish.bind(this))
    this.readmeUrl = config.readmeUrl || 'https://gitlab.com/antora/antora/-/raw/HEAD/README.adoc'
    this.contentsPromise = undefined
  }

  onPlaybookBuilt ({ siteCatalog }) {
    this.contentsPromise = new Promise((resolve, reject) => {
      const buffer = []
      https
        .get(this.readmeUrl, (response) => {
          response.on('data', (chunk) => buffer.push(chunk.toString()))
          response.on('end', () => resolve(buffer.join('').trimEnd()))
        })
        .on('error', reject)
    })
  }

  async onBeforePublish ({ siteCatalog }) {
    const contents = await this.contentsPromise
    siteCatalog.addFile({ contents: Buffer.from(contents), out: { path: 'README.adoc' } })
  }
}

FetchAndPublishReadmeExtension.register = function ({ config }) {
  return new FetchAndPublishReadmeExtension(this, config)
}
// or
//FetchAndPublishReadmeExtension.register = (context, { config }) => new FetchAndPublishReadmeExtension(context, config)

module.exports = FetchAndPublishReadmeExtension
-----------


// /docs/modules/extend/examples/better-time-generation-extension.js
[[extend:examples:better-time-generation-extension.js]]
= Examples better-time-generation-extension.js

[source,js]
-----------
module.exports.register = function () {
  this
    .prependListener('playbookBuilt', () => {
      console.time('generation time')
    })
    .on('sitePublished', () => {
      console.timeEnd('generation time')
    })
}
-----------


// /docs/modules/extend/examples/discovered-component-versions-extension.js
[[extend:examples:discovered-component-versions-extension.js]]
= Examples discovered-component-versions-extension.js

[source,js]
-----------
'use strict'

module.exports.register = function () {
  this.once('contentAggregated', ({ contentAggregate }) => {
    console.log('Discovered the following component versions')
    contentAggregate.forEach((bucket) => {
      const sources = bucket.origins.map(({ url, refname }) => ({ url, refname }))
      console.log({ name: bucket.name, version: bucket.version, files: bucket.files.length, sources })
    })
  })
}
-----------


// /docs/modules/extend/examples/doc-to-pdf-extension.js
[[extend:examples:doc-to-pdf-extension.js]]
= Examples doc-to-pdf-extension.js

[source,js]
-----------
'use strict'

const fsp = require('node:fs/promises')
const ospath = require('node:path')
const { posix: path } = ospath
const { execFile } = require('node:child_process')

module.exports.register = function () {
  this.once('contentClassified', async ({ playbook, contentCatalog }) => {
    const docExtnames = { '.docx': true, '.fodt': true, '.odt': true }
    const filesToConvert = contentCatalog
      .getFiles()
      .filter(({ src }) => src.family === 'attachment' && docExtnames[src.extname])
    if (!filesToConvert.length) return
    const buildDirBase = ospath.join(playbook.dir, 'build/doc-to-pdf')
    const convertArgs = ['--writer', '--convert-to', 'pdf']
    const convertOpts = { cwd: buildDirBase, windowsHide: true }
    try {
      await fsp.mkdir(buildDirBase, { recursive: true })
      await Promise.all(
        filesToConvert.map((file) => {
          const sourceRelpath = `${file.src.component}-${file.src.module}-${file.out.basename}`
          convertArgs.push(sourceRelpath)
          return fsp.writeFile(ospath.join(buildDirBase, sourceRelpath), file.contents)
        })
      )
      await new Promise((resolve, reject) => {
        execFile('libreoffice', convertArgs, convertOpts, (err, stderr, stdout) => {
          if (!err) return resolve()
          const splitIdx = stderr.indexOf('Usage: ')
          if (~splitIdx) stderr = stderr.slice(0, splitIdx).trimEnd()
          if (stderr) err.message += stderr
          reject(err)
        })
      })
      await Promise.all(
        filesToConvert.map((file) => {
          file.out.basename = file.out.basename.slice(0, -file.src.extname.length) + '.pdf'
          file.out.path = path.join(file.out.dirname, file.out.basename)
          file.pub.url = file.pub.url.slice(0, -file.src.extname.length) + '.pdf'
          const sourceRelpath = `${file.src.component}-${file.src.module}-${file.out.basename}`
          return fsp.readFile(ospath.join(buildDirBase, sourceRelpath)).then((contents) => (file.contents = contents))
        })
      )
    } finally {
      await fsp.rm(buildDirBase, { recursive: true, force: true })
    }
  })
}
-----------


// /docs/modules/extend/examples/exclude-private-content-sources-extension.js
[[extend:examples:exclude-private-content-sources-extension.js]]
= Examples exclude-private-content-sources-extension.js

[source,js]
-----------
module.exports.register = function () {
  this.on('playbookBuilt', function ({ playbook }) {
    playbook.content.sources = playbook.content.sources.filter(({ url }) => !url.startsWith('git@'))
    this.updateVariables({ playbook })
  })
}
-----------


// /docs/modules/extend/examples/export-content-extension.js
[[extend:examples:export-content-extension.js]]
= Examples export-content-extension.js

[source,js]
-----------
'use strict'

const { parse: parseHTML } = require('node-html-parser')

/**
 * An Antora extension that exports the content of publishable pages in plain text to a JSON
 * file along with the page URL and title.
 */
module.exports.register = function () {
  this.once('navigationBuilt', ({ playbook, contentCatalog, siteCatalog }) => {
    const siteUrl = playbook.site.url
    const component = 'dfcs'
    const version = ''
    const componentVersion = contentCatalog.getComponentVersion(component, version)
    const dfcsNavEntriesByUrl = getNavEntriesByUrl(componentVersion.navigation)
    const pages = contentCatalog
      .getPages((it) => it.src.component === component && it.src.version === version && it.pub)
      .map((page) => {
        const siteRelativeUrl = page.pub.url
        const articleDom = parseHTML(`<article>${page.contents}</article>`)
        // TODO might want to apply the sentence newline replacement per paragraph
        const text = articleDom.textContent.trim().replace(/\n(\s*\n)+/g, '\n\n').replace(/\.\n(?!\n)/g, '. ')
        const path = [componentVersion.title]
        path.push(...(dfcsNavEntriesByUrl[siteRelativeUrl]?.path?.map((it) => it.content) || []))
        return { url: siteUrl + siteRelativeUrl, title: page.title, text, path }
      })
    siteCatalog.addFile({
      contents: Buffer.from(JSON.stringify({ pages }, null, '  ')),
      out: { path: 'site-content.json' },
    })
  })
}

function getNavEntriesByUrl (items = [], accum = {}, path = []) {
  items.forEach((item) => {
    if (item.urlType === 'internal') accum[item.url.split('#')[0]] = { item, path: path.concat(item) }
    getNavEntriesByUrl(item.items, accum, item.content ? path.concat(item) : path)
  })
  return accum
}
-----------


// /docs/modules/extend/examples/fetch-and-publish-readme-extension.js
[[extend:examples:fetch-and-publish-readme-extension.js]]
= Examples fetch-and-publish-readme-extension.js

[source,js]
-----------
const https = require('node:https')

module.exports.register = function () {
  this.on('beforePublish', async ({ siteCatalog }) => {
    const contents = await new Promise((resolve, reject) => {
      const buffer = []
      https
        .get('https://gitlab.com/antora/antora/-/raw/HEAD/README.adoc', (response) => {
          response.on('data', (chunk) => buffer.push(chunk.toString()))
          response.on('end', () => resolve(buffer.join('').trimEnd()))
        })
        .on('error', reject)
    })
    siteCatalog.addFile({ contents: Buffer.from(contents), out: { path: 'README.adoc' } })
  })
}
-----------


// /docs/modules/extend/examples/humans-txt-extension.js
[[extend:examples:humans-txt-extension.js]]
= Examples humans-txt-extension.js

[source,js]
-----------
module.exports.register = function ({ config }) {
  this.on('beforePublish', ({ siteCatalog }) => {
    const teamInfo = '/* TEAM */\n' + config.names.map((name) => `Name: ${name}`).join('\n')
    const contents = Buffer.from(teamInfo + '\n')
    siteCatalog.addFile({ contents, out: { path: 'humans.txt' } })
  })
}
-----------


// /docs/modules/extend/examples/nojekyll-extension.js
[[extend:examples:nojekyll-extension.js]]
= Examples nojekyll-extension.js

[source,js]
-----------
module.exports.register = function () {
  this.on('beforePublish', ({ siteCatalog }) => {
    siteCatalog.addFile({ contents: Buffer.alloc(0), out: { path: '.nojekyll' } })
  })
}
-----------


// /docs/modules/extend/examples/page-unpublish-flag-extension.js
[[extend:examples:page-unpublish-flag-extension.js]]
= Examples page-unpublish-flag-extension.js

[source,js]
-----------
module.exports.register = function () {
  this.on('documentsConverted', ({ contentCatalog }) => {
    contentCatalog.getPages((page) => {
      if (page.out && page.asciidoc?.attributes['page-unpublish'] != null) delete page.out
    })
  })
}
-----------


// /docs/modules/extend/examples/print-compiled-asciidoc-attributes-extension.js
[[extend:examples:print-compiled-asciidoc-attributes-extension.js]]
= Examples print-compiled-asciidoc-attributes-extension.js

[source,js]
-----------
'use strict'

module.exports.register = function () {
  this.once('contentClassified', ({ siteAsciiDocConfig, contentCatalog }) => {
    console.log('site-wide attributes (compiled)')
    console.log(siteAsciiDocConfig.attributes)
    contentCatalog.getComponents().forEach((component) => {
      component.versions.forEach((componentVersion) => {
        console.log(`${componentVersion.version}@${componentVersion.name} attributes (compiled)`)
        if (componentVersion.asciidoc === siteAsciiDocConfig) {
          console.log('same as site-wide attributes')
        } else {
          console.log(componentVersion.asciidoc.attributes)
        }
      })
    })
  })
}
-----------


// /docs/modules/extend/examples/print-defined-asciidoc-attributes-extension.js
[[extend:examples:print-defined-asciidoc-attributes-extension.js]]
= Examples print-defined-asciidoc-attributes-extension.js

[source,js]
-----------
'use strict'

module.exports.register = function () {
  this.once('contentClassified', ({ playbook, contentCatalog }) => {
    console.log('site-wide attributes (as defined in playbook)')
    console.log(playbook.asciidoc.attributes)
    contentCatalog.getComponents().forEach((component) => {
      component.versions.forEach((componentVersion) => {
        getUniqueOrigins(contentCatalog, componentVersion).forEach((origin) => {
          console.log(`${componentVersion.version}@${componentVersion.name} attributes (as defined in antora.yml)`)
          console.log(origin.descriptor.asciidoc?.attributes || {})
        })
      })
    })
  })
}

function getUniqueOrigins (contentCatalog, componentVersion) {
  return contentCatalog
    .findBy({ component: componentVersion.name, version: componentVersion.version })
    .reduce((origins, file) => {
      const origin = file.src.origin
      if (origin && !origins.includes(origin)) origins.push(origin)
      return origins
    }, [])
}
-----------


// /docs/modules/extend/examples/resolve-attribute-references-in-attachments-extension.js
[[extend:examples:resolve-attribute-references-in-attachments-extension.js]]
= Examples resolve-attribute-references-in-attachments-extension.js

[source,js]
-----------
module.exports.register = function () {
  this.on('contentClassified', ({ contentCatalog }) => {
    const componentVersionTable = contentCatalog.getComponents().reduce((componentMap, component) => {
      componentMap[component.name] = component.versions.reduce((versionMap, componentVersion) => {
        versionMap[componentVersion.version] = componentVersion
        return versionMap
      }, {})
      return componentMap
    }, {})
    contentCatalog.findBy({ family: 'attachment' }).forEach((attachment) => {
      const componentVersion = componentVersionTable[attachment.src.component][attachment.src.version]
      let attributes = componentVersion.asciidoc?.attributes
      if (!attributes) return
      attributes = Object.entries(attributes).reduce((accum, [name, val]) => {
        accum[name] = val?.endsWith('@') ? val.slice(0, val.length - 1) : val
        return accum
      }, {})
      let modified
      const result = attachment.contents.toString().replace(/\{([\p{Alpha}\d_][\p{Alpha}\d_-]*)\}/gu, (match, name) => {
        if (!(name in attributes)) return match
        modified = true
        let value = attributes[name]
        if (value.endsWith('@')) value = value.slice(0, value.length - 1)
        return value
      })
      if (modified) attachment.contents = Buffer.from(result)
    })
  })
}
-----------


// /docs/modules/extend/examples/set-global-asciidoc-attributes-extension.js
[[extend:examples:set-global-asciidoc-attributes-extension.js]]
= Examples set-global-asciidoc-attributes-extension.js

[source,js]
-----------
'use strict'

module.exports.register = function () {
  this.on('beforeProcess', ({ siteAsciiDocConfig }) => {
    const buildDate = new Date().toISOString()
    siteAsciiDocConfig.attributes['build-date'] = buildDate
  })
}
-----------


// /docs/modules/extend/examples/time-generation-extension.js
[[extend:examples:time-generation-extension.js]]
= Examples time-generation-extension.js

[source,js]
-----------
module.exports.register = function () {
  this
    .on('playbookBuilt', () => {
      console.time('generation time')
    })
    .on('sitePublished', () => {
      console.timeEnd('generation time')
    })
}
-----------


// /docs/modules/extend/examples/unlisted-pages-extension.js
[[extend:examples:unlisted-pages-extension.js]]
= Examples unlisted-pages-extension.js

[source,js]
-----------
// tag::register[]
module.exports.register = function ({ config }) {
  // end::register[]
  // tag::register[]
  const { addToNavigation, unlistedPagesHeading = 'Unlisted Pages' } = config
  // end::register[]
  // tag::logger[]
  const logger = this.getLogger('unlisted-pages-extension')
  // end::logger[]
  // tag::on[]
  this
    .on('navigationBuilt', ({ contentCatalog }) => {
      // end::on[]
      // tag::each-nav[]
      contentCatalog.getComponents().forEach(({ versions }) => {
        versions.forEach(({ name: component, version, navigation: nav, url: defaultUrl }) => {
          // end::each-nav[]
          // tag::create-lookup-table[]
          const navEntriesByUrl = getNavEntriesByUrl(nav)
          // end::create-lookup-table[]
          // tag::find-unlisted[]
          const unlistedPages = contentCatalog
            .findBy({ component, version, family: 'page' })
            .filter((page) => page.out)
            .reduce((collector, page) => {
              if ((page.pub.url in navEntriesByUrl) || page.pub.url === defaultUrl) return collector
              // tag::warn[]
              logger.warn({ file: page.src, source: page.src.origin }, 'detected unlisted page')
              // end::warn[]
              return collector.concat(page)
            }, [])
          // end::find-unlisted[]
          // tag::add-to-nav[]
          if (unlistedPages.length && addToNavigation) {
            nav.push({
              content: unlistedPagesHeading,
              items: unlistedPages.map((page) => {
                const title = 'navtitle' in page.asciidoc
                  ? page.asciidoc.navtitle
                  : (page.src.module === 'ROOT' ? '' : page.src.module + ':') + page.src.relative
                return { content: title, url: page.pub.url, urlType: 'internal' }
              }),
              root: true,
            })
          }
          // end::add-to-nav[]
          // tag::each-nav[]
        })
      })
      // end::each-nav[]
      // tag::on[]
    })
    // end::on[]
    // tag::register[]
}
// end::register[]

// tag::helper[]
function getNavEntriesByUrl (items = [], accum = {}) {
  items.forEach((item) => {
    if (item.urlType === 'internal') accum[item.url.split('#')[0]] = item
    getNavEntriesByUrl(item.items, accum)
  })
  return accum
}
// end::helper[]
-----------


// /docs/modules/extend/examples/unpublish-unlisted-pages-extension.js
[[extend:examples:unpublish-unlisted-pages-extension.js]]
= Examples unpublish-unlisted-pages-extension.js

[source,js]
-----------
module.exports.register = function ({ config }) {
  this.on('navigationBuilt', ({ contentCatalog }) => {
    contentCatalog.getComponents().forEach(({ versions }) => {
      versions.forEach(({ name: component, version, navigation: nav, url: defaultUrl }) => {
        const navEntriesByUrl = getNavEntriesByUrl(nav)
        const unlistedPages = contentCatalog
          .findBy({ component, version, family: 'page' })
          .filter((page) => page.out)
          .reduce((collector, page) => {
            if (page.pub.url in navEntriesByUrl || page.pub.url === defaultUrl) return collector
            return collector.concat(page)
          }, [])
        if (unlistedPages.length) unlistedPages.forEach((page) => delete page.out)
      })
    })
  })
}

function getNavEntriesByUrl (items = [], accum = {}) {
  items.forEach((item) => {
    if (item.urlType === 'internal') accum[item.url.split('#')[0]] = item
    getNavEntriesByUrl(item.items, accum)
  })
  return accum
}
-----------


// /docs/modules/playbook/examples/linked-worktree-as-content-source.js
[[playbook:examples:linked-worktree-as-content-source.js]]
= Examples linked-worktree-as-content-source.js

[source,js]
-----------
'use strict'

/* Copyright (c) 2022 OpenDevise, Inc.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License Version 2.0. If a copy of this license was not distributed
 * with this file, you can obtain one at http://mozilla.org/MPL/2.0/.
 */
const fsp = require('node:fs/promises')
const ospath = require('node:path')

/**
 * Rewrites local content sources to support the use of linked worktrees.
 *
 * @author Dan Allen <dan@opendevise.com>
 */
module.exports.register = function () {
  this.once('playbookBuilt', async ({ playbook }) => {
    const expandPath = this.require('@antora/expand-path-helper')
    for (const contentSource of playbook.content.sources) {
      const { url, branches } = contentSource
      if (url.charAt() !== '.') continue
      const absdir = expandPath(url, { dot: playbook.dir })
      const dotgit = ospath.join(absdir, '.git')
      const dotgitIsFile = await fsp.stat(dotgit).then((stat) => stat.isFile(), () => false)
      if (!dotgitIsFile) continue
      const worktreeGitdir = await fsp.readFile(dotgit, 'utf8').then((contents) => contents.substr(8).trimEnd())
      const worktreeBranch = await fsp
        .readFile(ospath.join(worktreeGitdir, 'HEAD'), 'utf8')
        .then((contents) => contents.trimEnd().replace(/^ref: (?:refs\/heads\/)?/, ''))
      const reldir = ospath.relative(
        playbook.dir,
        await fsp.readFile(ospath.join(worktreeGitdir, 'commondir'), 'utf8').then((contents) => {
          const gitdir = ospath.join(worktreeGitdir, contents.trimEnd())
          return ospath.basename(gitdir) === '.git' ? ospath.dirname(gitdir) : gitdir
        })
      )
      contentSource.url = reldir ? `.${ospath.sep}${reldir}` : '.'
      if (!branches) continue
      contentSource.branches = (branches.constructor === Array ? branches : [branches]).map((pattern) =>
        pattern.replaceAll('HEAD', worktreeBranch)
      )
    }
  })
}
-----------


// /docs/modules/playbook/examples/system-git-credential-manager.js
[[playbook:examples:system-git-credential-manager.js]]
= Examples system-git-credential-manager.js

[source,js]
-----------
'use strict'

// tag::call-git-credential-fill[]
const { spawn } = require('node:child_process')

function callGitCredentialFill (url) {
  const { protocol, host } = new URL(url)
  return new Promise((resolve, reject) => {
    const output = []
    const process = spawn('git', ['credential', 'fill'])
    process.on('close', (code) => {
      if (code) return reject(code)
      const { username, password } = output.join('\n').split('\n').reduce((acc, line) => {
        if (line.startsWith('username') || line.startsWith('password')) {
          const [key, val] = line.split('=')
          acc[key] = val
        }
        return acc
      }, {})
      resolve(password ? { username, password } : username ? { token: username } : undefined)
    })
    process.stdout.on('data', (data) => output.push(data.toString().trim()))
    process.stdin.write(`protocol=${protocol.slice(0, -1)}\nhost=${host}\n\n`)
  })
}
// end::call-git-credential-fill[]

// tag::exports[]
module.exports = {
  configure () {
    this.urls = {}
  },
  async fill ({ url }) {
    this.urls[url] = 'requested'
    return callGitCredentialFill(url)
  },
  async approved ({ url }) {
    this.urls[url] = 'approved'
  },
  async rejected ({ url, auth }) {
    this.urls[url] = 'rejected'
    const data = { statusCode: 401, statusMessage: 'HTTP Basic: Access Denied' }
    const err = new Error(`HTTP Error: ${data.statusCode} ${data.statusMessage}`)
    err.name = err.code = 'HttpError'
    err.data = data
    if (auth) err.rejected = true
    throw err
  },
  status ({ url }) {
    return this.urls[url]
  },
}
// end::exports[]
-----------


// /docs/modules/ROOT/examples/github-actions-workflow.yml
[[ROOT:examples:github-actions-workflow.yml]]
= Examples github-actions-workflow.yml

[source,yml]
------------
name: Publish to GitHub Pages
on:
  push:
    branches: [main]
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:
concurrency:
  group: github-pages
  cancel-in-progress: false
# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write
jobs:
  build:
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    - name: Configure Pages
      uses: actions/configure-pages@v5
    - name: Install Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    - name: Install Antora
      run: npm i antora
    - name: Generate Site
      run: npx antora antora-playbook.yml
    - name: Upload Artifacts
      uses: actions/upload-pages-artifact@v3
      with:
        path: build/site
    - name: Deploy to GitHub Pages
      id: deployment
      uses: actions/deploy-pages@v4
------------


// /docs/modules/ROOT/examples/github-actions-workflow-with-lunr.yml
[[ROOT:examples:github-actions-workflow-with-lunr.yml]]
= Examples github-actions-workflow-with-lunr.yml

[source,yml]
------------
name: Publish to GitHub Pages with Lunr Search Extension
on:
  push:
    branches: [main]
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:
concurrency:
  group: github-pages
  cancel-in-progress: false
# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write
jobs:
  build:
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    - name: Configure Pages
      uses: actions/configure-pages@v5
    - name: Install Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    - name: Install Antora with the Antora Lunr Extension
      run: npm i antora @antora/lunr-extension
    - name: Generate Site
      run: npx antora antora-playbook.yml
    - name: Upload Artifacts
      uses: actions/upload-pages-artifact@v3
      with:
        path: build/site
    - name: Deploy to GitHub Pages
      id: deployment
      uses: actions/deploy-pages@v4
------------
