________________________________________________________________________
/1. - [Cover](invcpp5/ch00.htm)
====================================================
 Programming Microsoft Visual C++, Fifth Edition 

![Cover](c:/dl/books/windows/msvc5th/invcpp5/images/318570f.JPG)  
Copyright© 1998 by David J. Kruglinski
________________________________________________________________________
1.1. - [LOC Page](invcpp5/ch00a.htm)
----------------------------------------------------
 LOC Page 

PUBLISHED BY  
Microsoft Press  
A Division of Microsoft Corporation  
One Microsoft Way  
Redmond, Washington 98052-6399

Copyright (c) 1998 by David J. Kruglinski

All rights reserved. No part of the contents of this book may be reproduced or transmitted in any form or by any means without the written permission of the publisher.

Library of Congress Cataloging-in-Publication Data
  
Kruglinski, David.
  
        Programming Microsoft Visual C++ / David J. Kruglinski, Scot Wingo, George
  
    Shepherd. -- 5th ed.
  
            p.     cm.
  
        Rev. ed. of: Inside Visual C++.
  
        Includes index.
  
        ISBN 1-57231-857-0
  
        1. C++ (Computer program language)   2. Microsoft Visual C++.
  
    I. Wingo, Scot.    II. Shepherd, George, 1962-  .    III. Kruglinski,
  
    David.    Inside Visual C++.    IV. Title
  
    QA76.73.C153K78  1998
  
    005.13'3--dc21                                                                  98-27329
  
                                                                                                 CIP

Printed and bound in the United States of America.

1 2 3 4 5 6 7 8 9   WCWC   3 2 1 0 9 8

Distributed in Canada by Penguin Books Canada Limited.

A CIP catalogue record for this book is available from the British Library.

Microsoft Press books are available through booksellers and distributors worldwide. For further information about international editions, contact your local Microsoft Corporation office or contact Microsoft Press International directly at fax (425) 936-7329. Visit our Web site at [mspress.microsoft.com](http://mspress.microsoft.com).

Macintosh and TrueType fonts are registered trademarks of Apple Computer, Inc. Intel is a registered trademark of Intel Corporation. ActiveX, FoxPro, FrontPage, Microsoft, Microsoft Press, MS, MS-DOS, Outlook, PowerPoint, SourceSafe, Visual Basic, Visual C++, Visual J++, Win32, Win64, Windows, and Windows NT are either registered trademarks or trademarks of Microsoft Corporation in the United States and/or other countries. Other product and company names mentioned herein may be the trademarks of their respective owners.

**Acquisitions Editor:** Eric Stroo

**Project Editor:** Rebecca McKay

**Technical Editor:** Jean Ross
________________________________________________________________________
/2. - [Acknowledgments](invcpp5/ack.htm)
====================================================
 Acknowledgments 

Acknowledgments
===============

I first met David Kruglinski at a software development conference. I had just quit my job and started a new company, and I approached David at an author signing for an earlier edition of this book. Our new company was going to focus on Microsoft Foundation Class (MFC)/Microsoft Visual C++ class libraries. I hoped that David would listen to our ideas and maybe provide some feedback on our products and their usefulness to the Visual C++ development community—a community that he had both helped to build and understood like the back of his own hand.

Much to my surprise, David was very excited about the product ideas and asked if I could send him evaluation copies of our products. I did, and we started a long e-mail conversation about our products and ideas for improvements. David gave his time, expertise, and great opinions freely, without ever asking for any compensation—he genuinely wanted to help us make products for the Visual C++ developer that would make MFC/Visual C++ better.

I first heard about David's fatal paragliding accident via a posting on a newsgroup and initially thought it was some kind of cruel hoax. I called David's agent, who checked into the story, and much to my shock it was true. With David's passing, the Visual C++ community has lost one of its brightest and most giving stars. Talk to any Visual C++ developers about how they first learned Visual C++ and invariably they will say, "the Kruglinski book!" The Visual C++ community owes David greatly for what he gave us and taught us about Visual C++ over the years. It goes without saying that he should receive special acknowledgment for this book, and our thoughts go out to his family and friends for their loss.

It is a great honor to carry on the Kruglinski tradition with this fifth edition of _Inside Visual C++_ (now called _Programming Microsoft Visual C++, Fifth Edition_). We have done our best to stay true to David's vision of this book, following his format and style as closely as possible.

Thanks to my wife Kris and to my son, Sean, for putting up with all of the late nights and weekends of writing. Many thanks also go to my coauthor, George Shepherd, who always helps me get motivated for a late night of book writing with his upbeat, wacky, and great personality. Thanks to Claire Horne, our agent, for helping us get on board with the project.

Visual C++, and therefore this book, wouldn't exist if not for the many members of the Visual C++ team. Special thanks to Mike Blaszczak, Walter Sullivan, Dean McCrory, Rick Laplante, Marie Huwe, Christian Gross, and Jim Springfield for all of the help they have provided over the years.

Finally, but not least, thanks to the folks at Microsoft Press who worked on this project—especially Kathleen Atkins, Jim Fuchs, Becka McKay, John Pierce, Jean Ross, Eric Stroo, and the entire production team who worked extremely hard to get this large book out and into your hands with the highest quality possible.

—_Scot Wingo_  
  
  

Much work goes into writing books—even revisions of existing work. I'd like to acknowledge the following people for helping me get this work out the door: First I'd like to thank my wife Sandy for sticking with me while I worked to get the pages and chapters out. Sandy has been an invaluable source of encouragement throughout my software endeavors. Thanks to my son, Teddy, for being patient with me as I bowed out on various activities every once in a while. I wish to thank my mother Betsy for engendering in me a desire to write and my twin brother Patrick for being a great Java foil for me—and for arguing cogently with me about various hardware and software platform issues.

Thanks to Claire Horne of the Moore Literary Agency for helping to get this project rolling with Microsoft Press.

To Scot Wingo, thanks for taking on another writing project with me. And thanks to the folks at Stingray—you all are a great bunch to work with. Thanks to all the folks at DevelopMentor for providing a great training and learning environment. And thanks to Don Box for continuing to explain COM in a way that makes sense.

Getting a book out involves more than just authors. I wish to thank everyone at Microsoft Press who helped kick _Programming Microsoft Visual C++, Fifth Edition_ out the door, especially Eric Stroo for his kindness and patience, Kathleen Atkins and Becka McKay for sifting through our text and making it ever more readable, Jean Ross for balancing out the technical review to catch even the most minute error, and John Pierce for keeping everything on track.

Finally, thanks to David Kruglinski for starting this project. While I never had the opportunity to meet David, his writing had a measuable impact on me when first learning MFC. I hope Scot and I did justice to the work you began.

—_George Shepherd_
________________________________________________________________________
/3. - [Introduction](invcpp5/introa.htm)
====================================================
 Introduction 

Introduction
============

The 6.0 release of Visual C++ shows Microsoft's continued focus on Internet technologies and COM, which are key components of the new Windows Distributed interNet Application Architecture (DNA). In addition to supporting these platform initiatives, Visual C++ 6.0 also adds an amazing number of productivity-boosting features such as Edit And Continue, IntelliSense, AutoComplete, and code tips. These features take Visual C++ to a new level. We have tried to make sure that this book keeps you up to speed on the latest technologies being introduced into Visual C++.
________________________________________________________________________
3.1. - [MFC, ATL, and WFC -- Is MFC Dead?](invcpp5/introb.htm)
----------------------------------------------------
 MFC, ATL, and WFC—Is MFC Dead? 

MFC, ATL, and WFC—Is MFC Dead?
==============================

Ever since Microsoft released the Active Template Library (ATL) as part of Visual C++, Windows developers have speculated that the Microsoft Foundation Class Library (MFC) was no longer "en vogue" at Microsoft and that future efforts would focus on newer libraries such as ATL. Recently, Microsoft released another class library, Windows Foundation Classes (WFC), for Java Windows developers, which has unfortunately helped to fan the rumors that "MFC is dead."

The rumors of MFC's demise are definitely premature. Visual C++ 6.0 has added significant functionality to MFC and ATL in parallel, which indicates that both libraries will receive equal attention moving forward. Part of the problem is that the design goals of each library are sometimes not clearly stated and therefore are not clearly understood by the Visual C++ developer. MFC is designed to be a great class library for creating graphically rich, sophisticated Windows applications. ATL is designed to make it easy to create extremely lightweight COM objects and ActiveX controls. Each of these design goals has resulted in a different library to empower the developer.

Another common misconception is that MFC and ATL are mutually exclusive. This is definitely not the case! In fact, it is very easy to create ATL-based COM objects that use MFC. The only issue is that since many developers choose ATL for its lightweight nature, using MFC, which is feature-rich and "heavy," seems to contradict the reason for choosing ATL. While this might be the case for some developers, it doesn't make ATL and MFC mutually exclusive.

While ATL does not replace MFC, we do think it is an important part of Visual C++, so in this edition of _Programming Microsoft Visual C++_ we have added two chapters that cover the ATL class libraries.
________________________________________________________________________
3.2. - [C++ vs. Java](invcpp5/introc.htm)
----------------------------------------------------
 C++ vs. Java 

C++ vs. Java
============

In the last couple of years, there has been a great deal of interest in the Java programming language. Why should you choose C++ over Java? In the first place, a compiled program will always be faster than an interpreted program. Think about a high-performance spreadsheet program with cell formulas and macros. Now imagine the Java virtual machine interpreting the code that, in turn, interprets the formulas and macros. Not pretty, is it? With just-in-time compilation, it's necessary to compile the program every time you load it. Will that code be as good as the optimized output from a C++ compiler?

Execution speed is one factor; access to the operating system is another. For security reasons, Java applets can't perform such tasks as writing to disk and accessing serial ports. In order to be platform-independent, Java application programs are limited to the "lowest common denominator" of operating system features. A C++ program for Microsoft Windows is more flexible because it can call any Win32 function at any time.

Java will be an important language, but we believe it's just another language, not a revolution. If you need an Internet applet or a truly platform-independent application, choose Java. If you need efficiency and flexibility, choose C++.
________________________________________________________________________
3.3. - [Who Can Use This Book](invcpp5/introd.htm)
----------------------------------------------------
 Who Can Use This Book 

Who Can Use This Book
=====================

The product name "Visual C++" misleads some people. They think they've bought a pure visual programming system similar to Microsoft Visual Basic, and for the first few days the illusion persists. However, people soon learn that they must actually read and write C++ code. The Visual C++ wizards save time and improve accuracy, but programmers must understand the code that the wizards generate and, ultimately, the structure of the MFC library and the inner workings of the Windows operating system.

Visual C++, with its sophisticated application framework, is for professional programmers, and so is this book. We assume that you're proficient in the C language—you can write an _if_ statement without consulting the manual. And we assume that you've been exposed to the C++ language—you've at least taken a course or read a book, but maybe you haven't written much code. Compare learning C++ to learning the French language. You can study French in school, but you won't be able to speak fluently unless you go to France and start talking to people. Reading this book is like taking your trip to France!

We won't assume, however, that you already know Windows programming. We're sure that proficient C programmers can learn Windows the MFC way. It's more important to know C++ than it is to know the Win32 application programming interface (API). You should, however, know how to run Windows and Windows-based applications.

What if you're already experienced with the Win32 API or with the MFC library? There's something in this book for you too. First you'll get some help making the transition to Win32 programming. Then you'll learn about new features such as Data Access Objects (DAO), ActiveX control container support, and the controls introduced with Windows 95. If you haven't already figured out the Component Object Model (COM), this book presents some important theory that will get you started on understanding ActiveX Controls. You'll also learn about the ATL class library, the new Microsoft Internet Explorer 4.0 common controls, and OLE/DB database programming. Finally, you'll learn C++ programming for the Internet (including the hot new topic Dynamic HTML). We've even included coverage on how to make your Visual C++ programs work on the new Windows CE operating system.
________________________________________________________________________
3.4. - [What's Not Covered](invcpp5/introe.htm)
----------------------------------------------------
 What's Not Covered 

What's Not Covered
==================

It's not possible to cover every aspect of Windows-based programming in a single book. We exclude topics that depend on special-purpose hardware and software, such as MAPI, TAPI, and communications port access. We do cover using ActiveX controls in an application, but we'll defer the subject of writing ActiveX controls to Adam Denning and his _ActiveX Controls Inside Out_ (Microsoft Press, 1997). We get you started with 32-bit memory management, DLL theory, and multithreaded programming techniques, but you need to get the third edition of Jeffrey Richter's _Advanced Windows_ (Microsoft Press, 1997) if you're serious about these subjects. Another useful book is _MFC Internals_ by George Shepherd and Scot Wingo (Addison-Wesley, 1996).
________________________________________________________________________
3.5. - [How to Use This Book](invcpp5/introf.htm)
----------------------------------------------------
 How to Use This Book 

How to Use This Book
====================

When you're starting with Visual C++, you can use this book as a tutorial by going through it sequentially. Later you can use it as a reference by looking up topics in the table of contents or in the index. Because of the tight interrelationships among many application framework elements, it wasn't possible to cleanly isolate each concept in its own chapter, so the book really isn't an encyclopedia. When you use this book, you'll definitely want to keep the online help available for looking up classes and member functions.

If you're experienced with the Win16 version of Visual C++, scan Part I for an overview of new features. Then skip the first three chapters of Part II, but read Chapters 6 through 12, which cover elements specific to Win32.
________________________________________________________________________
3.6. - [The Organization of This Book](invcpp5/introg.htm)
----------------------------------------------------
 The Organization of This Book 

The Organization of This Book
=============================

As the table of contents shows, this book has six parts and an appendix section.

Part I: Windows, Visual C++, and Application Framework Fundamentals
-------------------------------------------------------------------

In this part, we try to strike a balance between abstract theory and practical application. After a quick review of Win32 and the Visual C++ components, you'll be introduced, in a gentle way, to the MFC application framework and the document-view architecture. You'll look at a simple "Hello, world!" program, built with the MFC library classes, that requires only 30 lines of code.

Part II: The MFC Library View Class
-----------------------------------

The MFC library documentation presents all the application framework elements in quick succession, with the assumption that you know the original Windows API. In Part II, you're confined to one major application framework component—the view, which is really a window. You'll learn here what experienced Windows programmers know already, but in the context of C++ and the MFC library classes. You'll use the Visual C++ tools that eliminate much of the coding drudgery that early Windows programmers had to endure.

Part II covers a lot of territory, including graphics programming with bitmaps, dialog data exchange, ActiveX control usage, 32-bit memory management, and multithreaded programming. The exercises will help you to write reasonably sophisticated Windows-based programs, but those programs won't take advantage of the advanced application framework features.

Part III: The Document-View Architecture
----------------------------------------

This part introduces the real core of application framework programming—the document-view architecture. You'll learn what a document is (something much more general than a word processing document), and you'll see how to connect the document to the view that you studied in Part II. You'll be amazed, once you have written a document class, at how the MFC library simplifies file I/O and printing.

Along the way, you'll learn about command message processing, toolbars and status bars, splitter frames, and context-sensitive help. You'll also be introduced to the Multiple Document Interface (MDI), the current standard for Windows-based applications.

Part III also contains a discussion of dynamic link libraries (DLLs) written with the MFC library. You'll learn the distinction between an extension DLL and a regular DLL. If you're used to Win16 DLLs, you'll notice some changes in the move to Win32.

Part IV: ActiveX: COM, Automation, and OLE
------------------------------------------

COM by itself deserves more than one book. Part IV will get you started in learning fundamental COM theory from the MFC point of view. You'll progress to Automation, which is the link between C++ and Visual Basic for Applications (VBA). You'll also become familiar with uniform data transfer and structured storage, and you'll learn the basics of compound documents and embedded objects.

Part V: Database Management
---------------------------

Windows-based programs often need access to information in large databases. Visual C++ now supports two separate database management options: Open Database Connectivity (ODBC) and Data Access Objects (DAO). Part V offers a chapter on each option. You'll learn about the extensive MFC and wizard support for both options, and you'll see the differences between and similarities of ODBC and DAO. We'll also cover a new data access technology, OLE/DB, which is supported by ATL OLE/DB consumer and providers.

Part VI: Programming for the Internet
-------------------------------------

This part starts with a technical Internet tutorial that covers the TCP/IP protocol plus the Winsock and WinInet APIs. You'll learn how to write C++ server and client programs for the Internet and the intranet, you'll learn how to write ISAPI DLLs that extend the Microsoft Internet Information Server, and you'll learn how to program for Dynamic HTML. We've also included coverage on Windows CE in this section.

Appendixes
----------

[Appendix A](chaaa.htm) contains a list of message map macros and their corresponding handler function prototypes. ClassWizard usually generates this code for you, but sometimes you must make manual entries.

[Appendix B](chaba.htm) offers a description of the MFC application framework's runtime class information and dynamic creation system. This is independent of the RTTI (runtime type information) feature that is now a part of ANSI C++.
________________________________________________________________________
3.7. - [Win32 vs. Win16](invcpp5/introh.htm)
----------------------------------------------------
 Win32 vs. Win16 

Win32 vs. Win16
===============

Lots of old computers out there are still running Windows 3.1. However, there's not much point in spending money writing new programs for obsolete technology. This edition of _Programming Microsoft Visual C++_ is about 32-bit programming for Microsoft Windows 95, Microsoft Windows 98, and Microsoft Windows NT using the Win32 API. If you really need to do 16-bit programming, find an old copy of the second edition of this book.
________________________________________________________________________
3.8. - [Windows 95 and Windows 98 vs. Windows NT](invcpp5/introi.htm)
----------------------------------------------------
 Windows 95 and Windows 98 vs. Windows NT 

Windows 95 and Windows 98 vs. Windows NT
========================================

Visual C++ version 6.0 requires either Windows 95, Windows 98, or Windows NT version 4.0 or later, all of which have the same user interface. We recommend that you use Windows NT as your development platform because of its stability—you can often go for months without rebooting your computer. If you use only the MFC programming interface, your compiled programs will run under Windows 95, Windows 98, and Windows NT, but a program can include Win32 calls that use specific Windows 98 or Windows NT features.
________________________________________________________________________
3.9. - [Going Further with Windows: The For Win32 Programmers Sidebars](invcpp5/introj.htm)
----------------------------------------------------
 Going Further with Windows: The "For Win32 Programmers" Sidebars 

Going Further with Windows:  
The "For Win32 Programmers" Sidebars
==================================================================

This book can't offer the kind of detail, tricks, and hidden features found in the newer, specialized books on Win32. Most of those books are written from the point of view of a C-language programmer: in order to use them, you'll have to understand the underlying Win32 API and its relationship to the MFC library. In addition, you'll need to know about the Windows message dispatch mechanism and the role of window classes.

This book's "For Win32 Programmers" sidebars, scattered throughout the text, help you make the connection to low-level programming for Windows. These specially formatted boxes help experienced C programmers relate new MFC library concepts to principles they're already familiar with. If you're unfamiliar with low-level programming, you should skip these notes the first time through, but you should read them on your second pass through the book. Even though you may never write a low-level Windows-based program with a _WinMain_ function, for example, you eventually need to know how the Windows operating system interacts with your program.
________________________________________________________________________
3.10. - [Using the Companion CD-ROM](invcpp5/introk.htm)
----------------------------------------------------
 Using the Companion CD-ROM 

Using the Companion CD-ROM
==========================

The companion CD-ROM bound inside the back cover of this book contains the source code files for all the sample programs. The executable program files are included, so you won't have to build the samples that you're interested in. To install the companion CD-ROM's files, insert the disc in your CD-ROM drive and run the Setup program. Follow the on-screen instructions.

> NOTE
> 
> The Setup program copies about 30 MB of files to your hard disk. If you prefer, you can manually install only the files for individual projects. Simply tree-copy the corresponding subdirectories from the CD-ROM to c:\vcpp32. Because each project is self-contained, no additional files from other projects are needed. (You'll need to remove the read-only attribute from these files if you copy them using Windows Explorer or File Manager.)

> NOTE
> 
> Many of the files on the companion CD-ROM have long filenames. If you use Windows 95 and your CD-ROM drive uses a real-mode driver, you'll see truncated names for these files and you might not see all of the files or directories. The Setup program will still work correctly, however, by copying files from a special \SETUP directory on the CD-ROM and renaming them with their proper long filenames. You can then browse the files on your hard disk. Alternatively, you can browse the files using the 8.3 aliases in the \SETUP directory on the CD-ROM.

With a conventional C-language program using the Windows API, the source code files tell the whole story. With the MFC library application framework, things are not so simple. AppWizard generates much of the C++ code, and the resources originate in the resource editors. The examples in the early chapters of this book include step-by-step instructions for using the tools to generate and customize the source code files. You'd be well advised to walk through those instructions for the first few examples; there's very little code to type. For the middle chapters, use the code from the companion CD-ROM but read through the steps in order to appreciate the role of the resource editors and the wizards. For the final chapters, not all the source code is listed. You'll need to examine the companion CD-ROM's files for those examples.

> **For Win32 Programmers: Unicode**
> 
> Until recently, Windows-based programs have used only the ANSI character set, which consists of 256 single-byte characters. Developers targeting the Asian software market are moving to the Unicode character set, which consists of 65,536 characters, each 2 bytes (wide). A third option, the double-byte character set (DBCS), includes both 1-byte characters and 2-byte characters, but DBCS is falling out of favor.
> 
> The MFC library and the runtime library both support Unicode applications. If you define the constant __UNICODE_ and follow the steps described in the online documentation, all your character variables and constant strings will be wide and the compiler will generate calls to the wide-character versions of the Win32 functions. This assumes that you use certain macros when you declare character pointers and arrays—for example, _TCHAR_ and __T_.
> 
> You'll hit a snag, though, if you try to run your MFC Unicode applications under Windows 95 or Windows 98, because they don't support Unicode internally. Even though Windows 95 and Windows 98 have wide-character versions of Win32 functions, those functions return a failure code. Windows NT, on the other hand, uses Unicode internally and has two versions of the Win32 functions that deal with characters. If you call a single-byte version, Windows NT makes the necessary conversions to and from wide characters.
> 
> None of the sample programs in this book are configured for Unicode. All the programs use single-byte types such as _char_ and single-byte string constants, and they do not define __UNICODE_. If you run the samples under Windows NT, the operating system will do the necessary single-to-wide conversions; if you run them under Windows 95 or Windows 98, the interface is pure single-byte.
> 
> One area in which you're forced to deal with wide characters is COM. All non-MFC COM functions (except DAO functions) that have string and character parameters require wide (_OLECHAR_) characters. If you write a non-Unicode program, you must do the conversions yourself with the help of the MFC _CString_ class and various MFC macros.
> 
> If you want to write Unicode applications, read the Unicode chapter in Jeffrey Richter's _Advanced Windows_. You should also read the Unicode material in the Visual C++ online documentation.
________________________________________________________________________
3.11. - [Technical Notes and Sample Programs](invcpp5/introl.htm)
----------------------------------------------------
 Technical Notes and Sample Programs 

Technical Notes and Sample Programs
===================================

The MSDN Library for Visual Studio 6.0 contains technical notes and sample programs that are referenced in this book. The technical notes, identified by number, are available from the Contents tab under the heading:

> MSDN Library Visual Studio 6.0
> 
>     Visual C++ Documentation Reference
> 
>          Microsoft Foundation Class Library and Templates
> 
>              Microsoft Foundation Class Library
> 
>                  MFC Technical Notes

The MSDN CD-ROM also contains a number of MFC sample programs also referenced in the book and identified by name. These sample programs are documented under the heading:

> MSDN Library Visual Studio 6.0
> 
>     Visual C++ Documentation
> 
>         Samples
> 
>             MFC Samples
________________________________________________________________________
3.12. - [Support](invcpp5/introm.htm)
----------------------------------------------------
 Support 

Support
=======

Every effort has been made to ensure the accuracy of this book and the contents of the companion disc. Microsoft Press provides corrections for books through the Web at: _[http://mspress.microsoft.com/mspress/support/](http://mspress.microsoft.com/mspress/support/)_

If you have comments, questions, or ideas regarding this book or the companion disc, please send them to Microsoft Press using postal mail or e-mail:

> Microsoft Press
> 
> Attn: Programming Microsoft Visual C++ Editor
> 
> One Microsoft Way
> 
> Redmond, WA 98052-6399
> 
> [MSPINPUT@MICROSOFT.COM](mailto:mspinput@microsoft.com)

Please note that product support is not offered through the above mail addresses. For support information regarding Microsoft Visual C++, you can call the technical support line at (425) 635-7007 weekdays between 6 a.m. and 6 p.m. Pacific time. Microsoft also provides information about Visual C++ at _[http://www.microsoft.com/visualc/](http://www.microsoft.com/visualc/)_ and about the Microsoft Developer Network at _[http://www.microsoft.com/MSDN/](http://www.microsoft.com/msdn/)_.
________________________________________________________________________
/4. - [Part I: Windows, Visual C++, and Application Framework Fundmentals]()
====================================================
________________________________________________________________________
4.1. - [Chapter 1 -- Microsoft Windows and Visual C++](invcpp5/ch01a.htm)
----------------------------------------------------
 Chapter 1 -- Microsoft Windows and Visual C++  Chapter 1

Microsoft Windows and Visual C++
================================

Enough has already been written about the acceptance of Microsoft Windows and the benefits of the graphical user interface (GUI). This chapter summarizes the Windows programming model (Win32 in particular) and shows you how the Microsoft Visual C++ components work together to help you write applications for Windows. Along the way, you might learn some new things about Windows.
________________________________________________________________________
4.1.1. - [The Windows Programming Model](invcpp5/ch01b.htm)
----------------------------------------------------
 The Windows Programming Model 

The Windows Programming Model
=============================

No matter which development tools you use, programming for Windows is different from old-style batch-oriented or transaction-oriented programming. To get started, you need to know some Windows fundamentals. As a frame of reference, we'll use the well-known MS-DOS programming model. Even if you don't currently program for plain MS-DOS, you're probably familiar with it.

Message Processing
------------------

When you write an MS-DOS-based application in C, the only absolute requirement is a function named _main_. The operating system calls _main_ when the user runs the program, and from that point on, you can use any programming structure you want. If your program needs to get user keystrokes or otherwise use operating system services, it calls an appropriate function, such as _getchar_, or perhaps uses a character-based windowing library.

When the Windows operating system launches a program, it calls the program's _WinMain_ function. Somewhere your application must have _WinMain_, which performs some specific tasks. Its most important task is creating the application's main window, which must have its own code to process messages that Windows sends it. An essential difference between a program written for MS-DOS and a program written for Windows is that an MS-DOS-based program calls the operating system to get user input, but a Windows-based program processes user input via messages from the operating system.

> NOTE
> 
> Many development environments for Windows, including Microsoft Visual C++ version 6.0 with the Microsoft Foundation Class (MFC) Library version 6.0, simplify programming by hiding the _WinMain_ function and structuring the message-handling process. When you use the MFC library, you need not write a _WinMain_ function but it is essential that you understand the link between the operating system and your programs.

Most messages in Windows are strictly defined and apply to all programs. For example, a WM_CREATE message is sent when a window is being created, a WM_LBUTTONDOWN message is sent when the user presses the left mouse button, a WM_CHAR message is sent when the user types a character, and a WM_CLOSE message is sent when the user closes a window. All messages have two 32-bit parameters that convey information such as cursor coordinates, key code, and so forth. Windows sends WM_COMMAND messages to the appropriate window in response to user menu choices, dialog button clicks, and so on. Command message parameters vary depending on the window's menu layout. You can define your own messages, which your program can send to any window on the desktop. These user-defined messages actually make C++ look a little like Smalltalk.

Don't worry yet about how these messages are connected to your code. That's the job of the application framework. Be aware, though, that the Windows message processing requirement imposes a lot of structure on your program. Don't try to force your Windows programs to look like your old MS-DOS programs. Study the examples in this book, and then be prepared to start fresh.

The Windows Graphics Device Interface
-------------------------------------

Many MS-DOS programs wrote directly to the video memory and the printer port. The disadvantage of this technique was the need to supply driver software for every video board and every printer model. Windows introduced a layer of abstraction called the Graphics Device Interface (GDI). Windows provides the video and printer drivers, so your program doesn't need to know the type of video board and printer attached to the system. Instead of addressing the hardware, your program calls GDI functions that reference a data structure called a device context. Windows maps the device context structure to a physical device and issues the appropriate input/output instructions. The GDI is almost as fast as direct video access, and it allows different applications written for Windows to share the display.

Resource-Based Programming
--------------------------

To do data-driven programming in MS-DOS, you must either code the data as initialization constants or provide separate data files for your program to read. When you program for Windows, you store data in a resource file using a number of established formats. The linker combines this binary resource file with the C++ compiler's output to generate an executable program. Resource files can include bitmaps, icons, menu definitions, dialog box layouts, and strings. They can even include custom resource formats that you define.

You use a text editor to edit a program, but you generally use wysiwyg (what you see is what you get) tools to edit resources. If you're laying out a dialog box, for example, you select elements (buttons, list boxes, and so forth) from an array of icons called a control palette, and you position and size the elements with the mouse. Microsoft Visual C++ 6.0 has graphics resource editors for all standard resource formats.

Memory Management
-----------------

With each new version of Windows, memory management gets easier. If you've heard horror stories about locking memory handles, thunks, and burgermasters, don't worry. That's all in the past. Today you simply allocate the memory you need, and Windows takes care of the details. [Chapter 10](ch10a.htm) describes current memory management techniques for Win32, including virtual memory and memory-mapped files.

Dynamic Link Libraries
----------------------

In the MS-DOS environment, all of a program's object modules are statically linked during the build process. Windows allows dynamic linking, which means that specially constructed libraries can be loaded and linked at runtime. Multiple applications can share dynamic link libraries (DLLs), which saves memory and disk space. Dynamic linking increases program modularity because you can compile and test DLLs separately.

Designers originally created DLLs for use with the C language, and C++ has added some complications. The MFC developers succeeded in combining all the application framework classes into a few ready-built DLLs. This means that you can statically or dynamically link the application framework classes into your application. In addition, you can create your own extension DLLs that build on the MFC DLLs. [Chapter 22](ch22a.htm) includes information about creating MFC extension DLLs and regular DLLs.

The Win32 Application Programming Interface
-------------------------------------------

Early Windows programmers wrote applications in C for the Win16 application programming interface (API). Today, if you want to write 32-bit applications, you must use the new Win32 API, either directly or indirectly. Most Win16 functions have Win32 equivalents, but many of the parameters are different—16-bit parameters are often replaced with 32-bit parameters, for example. The Win32 API offers many new functions, including functions for disk I/O, which was formerly handled by MS-DOS calls. With the 16-bit versions of Visual C++, MFC programmers were largely insulated from these API differences because they wrote to the MFC standard, which was designed to work with either Win16 or Win32 underneath.
________________________________________________________________________
4.1.2. - [The Visual C++ Components](invcpp5/ch01c.htm)
----------------------------------------------------
 The Visual C++ Components 

The Visual C++ Components
=========================

Microsoft Visual C++ is two complete Windows application development systems in one product. If you so choose, you can develop C-language Windows programs using only the Win32 API. C-language Win32 programming is described in Charles Petzold's book _Programming Windows 95_ (Microsoft Press, 1996). You can use many Visual C++ tools, including the resource editors, to make low-level Win32 programming easier.

Visual C++ also includes the ActiveX Template Library (ATL), which you can use to develop ActiveX controls for the Internet. ATL programming is neither Win32 C-language programming nor MFC programming, and it's complex enough to deserve its own book.

This book is not about C-language Win32 programming or ATL programming (although [Chapter 29](ch29a.htm) and [Chapter 30](ch30a.htm) provide an introduction to ATL). It's about C++ programming within the MFC library application framework that's part of Visual C++. You'll be using the C++ classes documented in the _Microsoft Visual C++ MFC Library Reference_ (Microsoft Press, 1997)_,_ and you'll also be using application framework-specific Visual C++ tools such as AppWizard and ClassWizard.

> NOTE
> 
> Use of the MFC library programming interface doesn't cut you off from the Win32 functions. In fact, you'll almost always need some direct Win32 calls in your MFC library programs.

A quick run-through of the Visual C++ components will help you get your bearings before you zero in on the application framework. Figure 1-1 shows an overview of the Visual C++ application build process.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f01og01x.gif)]

**Figure 1-1.** _The Visual C++ application build process._

Microsoft Visual C++ 6.0 and the Build Process
----------------------------------------------

Visual Studio 6.0 is a suite of developer tools that includes Visual C++ 6.0. The Visual C++ IDE is shared by several tools including Microsoft Visual J++. The IDE has come a long way from the original Visual Workbench, which was based on QuickC for Windows. Docking windows, configurable toolbars, plus a customizable editor that runs macros, are now part of Visual Studio. The online help system (now integrated with the MSDN Library viewer) works like a Web browser. Figure 1-2 shows Visual C++ 6.0 in action.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F01OG02x.gif)]

**Figure 1-2.** _Visual C++ 6.0 windows._

If you've used earlier versions of Visual C++ or another vendor's IDE, you already understand how Visual C++ 6.0 operates. But if you're new to IDEs, you'll need to know what a project is. A project is a collection of interrelated source files that are compiled and linked to make up an executable Windows-based program or a DLL. Source files for each project are generally stored in a separate subdirectory. A project depends on many files outside the project subdirectory too, such as include files and library files.

Experienced programmers are familiar with makefiles. A makefile stores compiler and linker options and expresses all the interrelationships among source files. (A source code file needs specific include files, an executable file requires certain object modules and libraries, and so forth.) A make program reads the makefile and then invokes the compiler, assembler, resource compiler, and linker to produce the final output, which is generally an executable file. The make program uses built-in inference rules that tell it, for example, to invoke the compiler to generate an OBJ file from a specified CPP file.

In a Visual C++ 6.0 project, there is no makefile (with an MAK extension) unless you tell the system to export one. A text-format project file (with a DSP extension) serves the same purpose. A separate text-format workspace file (with a DSW extension) has an entry for each project in the workspace. It's possible to have multiple projects in a workspace, but all the examples in this book have just one project per workspace. To work on an existing project, you tell Visual C++ to open the DSW file and then you can edit and build the project.

Visual C++ creates some intermediate files too. The following table lists the files that Visual C++ generates in the workspace.

**File Extension**

**Description**

APS

Supports ResourceView

BSC

Browser information file

CLW

Supports ClassWizard

DEP

Dependency file

DSP

Project file\*

DSW

Workspace file\*

MAK

External makefile

NCB

Supports ClassView

OPT

Holds workspace configuration

PLG

Builds log file

\* Do not delete or edit in a text editor.

The Resource Editors—Workspace ResourceView
-------------------------------------------

When you click on the ResourceView tab in the Visual C++ Workspace window, you can select a resource for editing. The main window hosts a resource editor appropriate for the resource type. The window can also host a wysiwyg editor for menus and a powerful graphical editor for dialog boxes, and it includes tools for editing icons, bitmaps, and strings. The dialog editor allows you to insert ActiveX controls in addition to standard Windows controls and the new Windows common controls (which have been further extended in Visual C++ 6.0). Chapter 3 shows pictures of the ResourceView page and one of the resource editors (the dialog editor).

Each project usually has one text-format resource script (RC) file that describes the project's menu, dialog, string, and accelerator resources. The RC file also has _#include_ statements to bring in resources from other subdirectories. These resources include project-specific items, such as bitmap (BMP) and icon (ICO) files, and resources common to all Visual C++ programs, such as error message strings. Editing the RC file outside the resource editors is not recommended. The resource editors can also process EXE and DLL files, so you can use the clipboard to "steal" resources, such as bitmaps and icons, from other Windows applications.

The C/C++ Compiler
------------------

The Visual C++ compiler can process both C source code and C++ source code. It determines the language by looking at the source code's filename extension. A C extension indicates C source code, and CPP or CXX indicates C++ source code. The compiler is compliant with all ANSI standards, including the latest recommendations of a working group on C++ libraries, and has additional Microsoft extensions. Templates, exceptions, and runtime type identification (RTTI) are fully supported in Visual C++ version 6.0. The C++ Standard Template Library (STL) is also included, although it is not integrated into the MFC library.

The Source Code Editor
----------------------

Visual C++ 6.0 includes a sophisticated source code editor that supports many features such as dynamic syntax coloring, auto-tabbing, keyboard bindings for a variety of popular editors (such as VI and EMACS), and pretty printing. In Visual C++ 6.0, an exciting new feature named AutoComplete has been added. If you have used any of the Microsoft Office products or Microsoft Visual Basic, you might already be familiar with this technology. Using the Visual C++ 6.0 AutoComplete feature, all you have to do is type the beginning of a programming statement and the editor will provide you with a list of possible completions to choose from. This feature is extremely handy when you are working with C++ objects and have forgotten an exact member function or data member name—they are all there in the list for you. You no longer have to memorize thousands of Win32 APIs or rely heavily on the online help system, thanks to this new feature.

The Resource Compiler
---------------------

The Visual C++ resource compiler reads an ASCII resource script (RC) file from the resource editors and writes a binary RES file for the linker.

The Linker
----------

The linker reads the OBJ and RES files produced by the C/C++ compiler and the resource compiler, and it accesses LIB files for MFC code, runtime library code, and Windows code. It then writes the project's EXE file. An incremental link option minimizes the execution time when only minor changes have been made to the source files. The MFC header files contain _#pragma_ statements (special compiler directives) that specify the required library files, so you don't have to tell the linker explicitly which libraries to read.

The Debugger
------------

If your program works the first time, you don't need the debugger. The rest of us might need one from time to time. The Visual C++ debugger has been steadily improving, but it doesn't actually fix the bugs yet. The debugger works closely with Visual C++ to ensure that breakpoints are saved on disk. Toolbar buttons insert and remove breakpoints and control single-step execution. Figure 1-3 illustrates the Visual C++ debugger in action. Note that the Variables and Watch windows can expand an object pointer to show all data members of the derived class and base classes. If you position the cursor on a simple variable, the debugger shows you its value in a little window. To debug a program, you must build the program with the compiler and linker options set to generate debugging information.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F01OG03x.gif)]

**Figure 1-3.** _The Visual C++ debugger window._

Visual C++ 6.0 adds a new twist to debugging with the Edit And Continue feature. Edit And Continue lets you debug an application, change the application, and then continue debugging with the new code. This feature dramatically reduces the amount of time you spend debugging because you no longer have to manually leave the debugger, recompile, and then debug again. To use this feature, simply edit any code while in the debugger and then hit the continue button. Visual C++ 6.0 automatically compiles the changes and restarts the debugger for you.

AppWizard
---------

AppWizard is a code generator that creates a working skeleton of a Windows application with features, class names, and source code filenames that you specify through dialog boxes. You'll use AppWizard extensively as you work through the examples in this book. Don't confuse AppWizard with older code generators that generate all the code for an application. AppWizard code is minimalist code; the functionality is inside the application framework base classes. AppWizard gets you started quickly with a new application.

Advanced developers can build custom AppWizards. Microsoft Corporation has exposed its macro-based system for generating projects. If you discover that your team needs to develop multiple projects with a telecommunications interface, you can build a special wizard that automates the process.

ClassWizard
-----------

ClassWizard is a program (implemented as a DLL) that's accessible from Visual C++'s View menu. ClassWizard takes the drudgery out of maintaining Visual C++ class code. Need a new class, a new virtual function, or a new message-handler function? ClassWizard writes the prototypes, the function bodies, and (if necessary) the code to link the Windows message to the function. ClassWizard can update class code that you write, so you avoid the maintenance problems common to ordinary code generators. Some ClassWizard features are available from Visual C++'s WizardBar toolbar, shown in Figure 1-2.

The Source Browser
------------------

If you write an application from scratch, you probably have a good mental picture of your source code files, classes, and member functions. If you take over someone else's application, you'll need some assistance. The Visual C++ Source Browser (the browser, for short) lets you examine (and edit) an application from the class or function viewpoint instead of from the file viewpoint. It's a little like the "inspector" tools available with object-oriented libraries such as Smalltalk. The browser has the following viewing modes:

*   **Definitions and References**—You select any function, variable, type, macro, or class and then see where it's defined and used in your project.
    
*   **Call Graph/Callers Graph**—For a selected function, you'll see a graphical representation of the functions it calls or the functions that call it.
    
*   **Derived Classes and Members/Base Classes and Members**—These are graphical class hierarchy diagrams. For a selected class, you see the derived classes or the base classes plus members. You can control the hierarchy expansion with the mouse.
    
*   **File Outline**—For a selected file, the classes, functions, and data members appear together with the places in which they're defined and used in your project.
    

A typical browser window is shown in [Chapter 3](ch03a.htm).

> NOTE
> 
> If you rearrange the lines in any source code file, Visual C++ regenerates the browser database when you rebuild the project. This increases the build time.

In addition to the browser, Visual C++ has a ClassView option that does not depend on the browser database. You get a tree view of all the classes in your project, showing member functions and data members. Double-click on an element, and you see the source code immediately. The ClassView does not show hierarchy information, whereas the browser does.

Online Help
-----------

In Visual C++ 6.0, the help system has been moved to a separate application named the MSDN Library Viewer. This help system is based on HTML. Each topic is covered in an individual HTML document; then all are combined into indexed files. The MSDN Library Viewer uses code from Microsoft Internet Explorer 4.0, so it works like the Web browser you already know. MSDN Library can access the help files from the Visual C++ CD-ROM (the default installation option) or from your hard disk, and it can access HTML files on the Internet.

Visual C++ 6.0 allows you to access help in four ways:

*   **By book**—When you choose Contents from Visual C++'s Help menu, the MSDN Library application switches to a contents view. Here Visual Studio, Visual C++, Win32 SDK documentation, and more is organized hierarchically by books and chapters.
    
*   **By topic**—When you choose Search from Visual C++'s Help menu, it automatically opens the MSDN Library Viewer. You can then select the Index tab, type a keyword, and see the topics and articles included for that keyword.
    
*   **By word**—When you choose Search from Visual C++'s Help menu, it invokes the MSDN Library with the Search tab active. With this tab active, you can type a combination of words to view articles that contain those words.
    
*   **F1 help**—This is the programmer's best friend. Just move the cursor inside a function, macro, or class name, and then press the F1 key and the help system goes to work. If the name is found in several places—in the MFC and Win32 help files, for example—you choose the help topic you want from a list window.
    

Whichever way you access online help, you can copy any help text to the clipboard for inclusion in your program.

Windows Diagnostic Tools
------------------------

Visual C++ 6.0 contains a number of useful diagnostic tools. SPY++ gives you a tree view of your system's processes, threads, and windows. It also lets you view messages and examine the windows of running applications. You'll find PVIEW (PVIEW95 for Windows 95) useful for killing errant processes that aren't visible from the Windows 95 task list. (The Windows NT Task Manager, which you can run by right-clicking the toolbar, is an alternative to PVIEW.) Visual C++ also includes a whole suite of ActiveX utilities, an ActiveX control test program (now with full source code in Visual C++ 6.0), the help workshop (with compiler), a library manager, binary file viewers and editors, a source code profiler, and other utilities.

Source Code Control
-------------------

During development of Visual C++ 5.0, Microsoft bought the rights to an established source code control product named SourceSafe. This product has since been included in the Enterprise Edition of Visual C++ and Visual Studio Enterprise, and it is integrated into Visual C++ so that you can coordinate large software projects. The master copy of the project's source code is stored in a central place on the network, and programmers can check out modules for updates. These checked-out modules are usually stored on the programmer's local hard disk. After a programmer checks in modified files, other team members can synchronize their local hard disk copies to the master copy. Other source code control systems can also be integrated into Visual C++.

The Gallery
-----------

The Visual C++ Components and Controls Gallery lets you share software components among different projects. The Gallery manages three types of modules:

*   **ActiveX controls**—When you install an ActiveX control (OCX—formerly OLE control), an entry is made in the Windows Registry. All registered ActiveX controls appear in the Gallery's window, so you can select them in any project.
    
*   **C++ source modules**—When you write a new class, you can add the code to the Gallery. The code can then be selected and copied into other projects. You can also add resources to the Gallery.
    
*   **Visual C++ components**—The Gallery can contain tools that let you add features to your project. Such a tool could insert new classes, functions, data members, and resources into an existing project. Some component modules are supplied by Microsoft (Idle time processing, Palette support, and Splash screen, for example) as part of Visual C++. Others will be supplied by third-party soft-ware firms.
    

> TIPS
> 
> If you decide to use one of the prepackaged Visual C++ components, try it out first in a dummy project to see if it's what you really want. Otherwise, it might be difficult to remove the generated code from your regular project.

All user-generated Gallery items can be imported from and exported to OGX files. These files are the distribution and sharing medium for Visual C++ components.

The Microsoft Foundation Class Library Version 6.0
--------------------------------------------------

The Microsoft Foundation Class Library version 6.0 (the MFC library, for short) is really the subject of this book. It defines the application framework that you'll be learning intimately. [Chapter 2](ch02a.htm) gets you started with actual code and introduces some important concepts.

The Microsoft Active Template Library
-------------------------------------

ATL is a tool, separate from MFC, for building ActiveX controls. You can build ActiveX controls with either MFC or ATL, but ATL controls are much smaller and quicker to load on the Internet. [Chapter 29](ch29a.htm) and [Chapter 30](ch30a.htm) provide a brief overview of ATL and creating ActiveX controls with ATL.
________________________________________________________________________
4.2. - [Chapter 2 -- The Microsoft Foundation Class Library Application Framework](invcpp5/ch02a.htm)
----------------------------------------------------
 Chapter 2 -- The Microsoft Foundation Class Library Application Framework  Chapter 2

The Microsoft Foundation Class Library Application Framework
============================================================

This chapter introduces the Microsoft Foundation Class Library version 6.0 (the MFC library) application framework by explaining its benefits. You'll see a stripped-down but fully operational MFC library program for Microsoft Windows that should help you understand what application framework programming is all about. Theory is kept to a minimum here, but the sections on message mapping and on documents and views contain important information that will help you with the examples in later chapters.
________________________________________________________________________
4.2.1. - [Why Use the Application Framework?](invcpp5/ch02b.htm)
----------------------------------------------------
 Why Use the Application Framework? 

Why Use the Application Framework?
==================================

If you're going to develop applications for Windows, you've got to choose a development environment. Assuming that you've already rejected non-C options such as Microsoft Visual Basic and Borland Delphi, here are some of your remaining options:

*   Program in C with the Win32 API
    
*   Write your own C++ Windows class library that uses Win32
    
*   Use the MFC application framework
    
*   Use another Windows-based application framework such as Borland's Object Windows Library (OWL)
    

If you're starting from scratch, any option involves a big learning curve. If you're already a Win16 or Win32 programmer, you'll still have a learning curve with the MFC library. Since its release, MFC has become the dominant Windows class library. But even if you're familiar with it, it's still a good idea to step through the features of this programming choice.

**The MFC library is the C++ Microsoft Windows API.** If you accept the premise that the C++ language is now the standard for serious application development, you'd have to say that it's natural for Windows to have a C++ programming interface. What better interface is there than the one produced by Microsoft, creator of Windows? That interface is the MFC library.

**Application framework applications use a standard structure.** Any programmer starting on a large project develops some kind of structure for the code. The problem is that each programmer's structure is different, and it's difficult for a new team member to learn the structure and conform to it. The MFC library application framework includes its own application structure—one that's been proven in many software environments and in many projects. If you write a program for Windows that uses the MFC library, you can safely retire to a Caribbean island, knowing that your minions can easily maintain and enhance your code back home.

Don't think that the MFC library's structure makes your programs inflexible. With the MFC library, your program can call Win32 functions at any time, so you can take maximum advantage of Windows.

**Application framework applications are small and fast.** Back in the 16-bit days, you could build a self-contained Windows EXE file that was less than 20 kilobytes (KB) in size. Today, Windows programs are larger. One reason is that 32-bit code is fatter. Even with the large memory model, a Win16 program used 16-bit addresses for stack variables and many globals. Win32 programs use 32-bit addresses for everything and often use 32-bit integers because they're more efficient than 16-bit integers. In addition, the new C++ exception-handling code consumes a lot of memory.

That old 20-KB program didn't have a docking toolbar, splitter windows, print preview capabilities, or control container support—features that users expect in modern programs. MFC programs are bigger because they do more and look better. Fortunately, it's now easy to build applications that dynamically link to the MFC code (and to C runtime code), so the size goes back down again—from 192 KB to about 20 KB! Of course, you'll need some big support DLLs in the background, but those are a fact of life these days.

As far as speed is concerned, you're working with machine code produced by an optimizing compiler. Execution is fast, but you might notice a startup delay while the support DLLs are loaded.

**The Visual C++ tools reduce coding drudgery.** The Visual C++ resource editors, AppWizard, and ClassWizard significantly reduce the time needed to write code that is specific to your application. For example, the resource editor creates a header file that contains assigned values for _#define_ constants. App-Wizard generates skeleton code for your entire application, and ClassWizard generates prototypes and function bodies for message handlers.

**The MFC library application framework is feature rich.** The MFC library version 1.0 classes, introduced with Microsoft C/C++ version 7.0, included the following features:

*   A C++ interface to the Windows API
    
*   General-purpose (non-Windows-specific) classes, including:
    
    *   Collection classes for lists, arrays, and maps
        
    *   A useful and efficient string class
        
    *   Time, time span, and date classes
        
    *   File access classes for operating system independence
        
    *   Support for systematic object storage and retrieval to and from disk
    
*   A "common root object" class hierarchy
    
*   Streamlined Multiple Document Interface (MDI) application support
    
*   Some support for OLE version 1.0
    

The MFC library version 2.0 classes (in Visual C++ version 1.0) picked up where the version 1.0 classes left off by supporting many user interface features that are found in current Windows-based applications, plus they introduced the application framework architecture. Here's a summary of the important new features:

*   Full support for File Open, Save, and Save As menu items and the most recently used file list
    
*   Print preview and printer support
    
*   Support for scrolling windows and splitter windows
    
*   Support for toolbars and status bars
    
*   Access to Visual Basic controls
    
*   Support for context-sensitive help
    
*   Support for automatic processing of data entered in a dialog box
    
*   An improved interface to OLE version 1.0
    
*   DLL support

The MFC library version 2.5 classes (in Visual C++ version 1.5) contributed the following:

*   Open Database Connectivity (ODBC) support that allows your application to access and update data stored in many popular databases such as Microsoft Access, FoxPro, and Microsoft SQL Server
    
*   An interface to OLE version 2.01, with support for in-place editing, linking, drag and drop, and OLE Automation

Visual C++ version 2.0 was the first 32-bit version of the product. It included support for Microsoft Windows NT version 3.5. It also contained MFC version 3.0, which had the following new features:

*   Tab dialog (property sheet) support (which was also added to Visual C++ version 1.51, included on the same CD-ROM)
    
*   Docking control bars that were implemented within MFC
    
*   Support for thin-frame windows
    
*   A separate Control Development Kit (CDK) for building 16-bit and 32-bit OLE controls, although no OLE control container support was provided

A subscription release, Visual C++ 2.1 with MFC 3.1, added the following:

*   Support for the new Microsoft Windows 95 (beta) common controls
    
*   A new ODBC Level 2 driver integrated with the Access Jet database engine
    
*   Winsock classes for TCP/IP data communication

Microsoft decided to skip Visual C++ version 3.0 and proceeded directly to 4.0 in order to synchronize the product version with the MFC version. MFC 4.0 contains these additional features:

*   New OLE-based Data Access Objects (DAO) classes for use with the Jet engine
    
*   Use of the Windows 95 docking control bars instead of the MFC control bars
    
*   Full support for the common controls in the released version of Windows 95, with new tree view and rich-edit view classes
    
*   New classes for thread synchronization
    
*   OLE control container support

Visual C++ 4.2 was an important subscription release that included MFC version 4.2. The following new features were included:

*   WinInet classes
    
*   ActiveX Documents server classes
    
*   ActiveX synchronous and asynchronous moniker classes
    
*   Enhanced MFC ActiveX Control classes, with features such as windowless activation, optimized drawing code, and so forth
    
*   Improved MFC ODBC support, including recordset bulk fetches and data transfer without binding

Visual C++ 5.0 included MFC version 4.21, which fixed some 4.2 bugs. Visual C++ 5.0 introduced some worthwhile features of its own as well:

*   A redesigned IDE, Developer Studio 97, which included an HTML-based online help system and integration with other languages, including Java
    
*   The Active Template Library (ATL) for efficient ActiveX control construction for the Internet
    
*   C++ language support for COM (Component Object Model) client programs with the new _#import_ statement for type libraries, as described in [Chapter 25](ch25a.htm)

The latest edition of Visual C++, 6.0, includes MFC 6.0. (Notice that the versions are now synchronized again.) Many of the features in MFC 6.0 enable the developer to support the new Microsoft Active Platform, including the following:

*   MFC classes that encapsulate the new Windows common controls introduced as part of Internet Explorer 4.0
    
*   Support for Dynamic HTML, which allows the MFC programmer to create applications that can dynamically manipulate and generate HTML pages
    
*   Active Document Containment, which allows MFC-based applications to contain Active Documents
    
*   OLE DB Consumers and Providers Template support and Active Data Objects (ADO) data binding, which help database developers who use MFC or ATL
    

The Learning Curve
------------------

All the listed benefits sound great, don't they? You're probably thinking, "You don't get something for nothing." Yes, that's true. To use the application framework effectively, you have to learn it thoroughly, and that takes time. If you have to learn C++, Windows, and the MFC library (without OLE) all at the same time, it will take at least six months before you're really productive. Interestingly, that's close to the learning time for the Win32 API alone.

How can that be if the MFC library offers so much more? For one thing, you can avoid many programming details that C-language Win32 programmers are forced to learn. From our own experience, we can say that an object-oriented application framework makes programming for Windows easier to learn—that is, once you understand object-oriented programming.

The MFC library won't bring real Windows programming down to the masses. Programmers of applications for Windows have usually commanded higher salaries than other programmers, and that situation will continue. The MFC library's learning curve, together with the application framework's power, should ensure that MFC library programmers will continue to be in strong demand.
________________________________________________________________________
4.2.2. - [What's an Application Framework?](invcpp5/ch02c.htm)
----------------------------------------------------
 What's an Application Framework? 

What's an Application Framework?
================================

One definition of application framework is "an integrated collection of object-oriented software components that offers all that's needed for a generic application." That isn't a very useful definition, is it? If you really want to know what an application framework is, you'll have to read the rest of this book. The application framework example that you'll familiarize yourself with later in this chapter is a good starting point.

An Application Framework vs. a Class Library
--------------------------------------------

One reason that C++ is a popular language is that it can be "extended" with class libraries. Some class libraries are delivered with C++ compilers, others are sold by third-party software firms, and still others are developed in-house. A class library is a set of related C++ classes that can be used in an application. A mathematics class library, for example, might perform common mathematics operations, and a communications class library might support the transfer of data over a serial link. Sometimes you construct objects of the supplied classes; sometimes you derive your own classes—it all depends on the design of the particular class library.

An application framework is a superset of a class library. An ordinary library is an isolated set of classes designed to be incorporated into any program, but an application framework defines the structure of the program itself. Microsoft didn't invent the application framework concept. It appeared first in the academic world, and the first commercial version was MacApp for the Apple Macintosh. Since MFC 2.0 was introduced, other companies, including Borland, have released similar products.

An Application Framework Example
--------------------------------

Enough generalizations. It's time to look at some code—not pseudocode but real code that actually compiles and runs with the MFC library. Guess what? It's the good old "Hello, world!" application, with a few additions. (If you've used version 1.0 of the MFC library, this code will be familiar except for the frame window base class.) It's about the minimum amount of code for a working MFC library application for Windows. (Contrast it with an equivalent pure Win32 application such as you would see in a Petzold book!) You don't have to understand every line now. Don't bother to type it in and test it, because EX23B on the CD-ROM is quite similar. Wait for the [next chapter](ch03a.htm), where you'll start using the "real" application framework.

> NOTE
> 
> By convention, MFC library class names begin with the letter _C_.

Following is the source code for the header and implementation files for our MYAPP application. The classes _CMyApp_ and _CMyFrame_ are each derived from MFC library base classes. First, here is the MyApp.h header file for the MYAPP application:

// application class
class CMyApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
};

// frame window class
class CMyFrame : public CFrameWnd
{
public:
    CMyFrame();
protected:
    // "afx_msg" indicates that the next two functions are part
    //  of the MFC library message dispatch system
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnPaint();
    DECLARE_MESSAGE_MAP()
};

And here is the MyApp.cpp implementation file for the MYAPP application:

#include <afxwin.h> // MFC library header file declares base classes
#include "myapp.h"
 
CMyApp theApp; // the one and only CMyApp object
 
BOOL CMyApp::InitInstance()
{
    m_pMainWnd = new CMyFrame();
    m_pMainWnd->ShowWindow(m_nCmdShow);
 
    m_pMainWnd->UpdateWindow();
    return TRUE;
}
 
BEGIN_MESSAGE_MAP(CMyFrame, CFrameWnd)
    ON_WM_LBUTTONDOWN()
    ON_WM_PAINT()
END_MESSAGE_MAP()

CMyFrame::CMyFrame()
{
    Create(NULL, "MYAPP Application");
}
 
void CMyFrame::OnLButtonDown(UINT nFlags, CPoint point)
{
    TRACE("Entering CMyFrame::OnLButtonDown - %lx, %d, %d\n",
          (long) nFlags, point.x, point.y);
}
 
void CMyFrame::OnPaint()
{
    CPaintDC dc(this);
    dc.TextOut(0, 0, "Hello, world!");
}

Here are some of the program elements:

**The _WinMain_ function—**Remember that Windows requires your application to have a _WinMain_ function. You don't see _WinMain_ here because it's hidden inside the application framework.

**The _CMyApp_ class—**An object of class _CMyApp_ represents an application. The program defines a single global _CMyApp_ object, _theApp_. The _CWinApp_ base class determines most of _theApp_'s behavior.

**Application startup—**When the user starts the application, Windows calls the application framework's built-in _WinMain_ function, and _WinMain_ looks for your globally constructed application object of a class derived from _CWinApp_. Don't forget that in a C++ program global objects are constructed before the main program is executed.

**The _CMyApp::InitInstance_ member function—**When the _WinMain_ function finds the application object, it calls the virtual _InitInstance_ member function, which makes the calls needed to construct and display the application's main frame window. You must override _InitInstance_ in your derived application class because the _CWinApp_ base class doesn't know what kind of main frame window you want.

**The _CWinApp::Run_ member function—**The _Run_ function is hidden in the base class, but it dispatches the application's messages to its windows, thus keeping the application running. _WinMain_ calls _Run_ after it calls _InitInstance_.

**The _CMyFrame_ class—**An object of class _CMyFrame_ represents the application's main frame window. When the constructor calls the _Create_ member function of the base class _CFrameWnd_, Windows creates the actual window structure and the application framework links it to the C++ object. The _ShowWindow_ and _UpdateWindow_ functions, also member functions of the base class, must be called in order to display the window.

**The _CMyFrame::OnLButtonDown_ function—**This function is a sneak preview of the MFC library's message-handling capability. We've elected to "map" the left mouse button down event to a _CMyFrame_ member function. You'll learn the details of the MFC library's message mapping in [Chapter 4](ch04a.htm). For the time being, accept that this function gets called when the user presses the left mouse button. The function invokes the MFC library _TRACE_ macro to display a message in the debugging window.

**The _CMyFrame::OnPaint_ function—**The application framework calls this important mapped member function of class _CMyFrame_ every time it's necessary to repaint the window: at the start of the program, when the user resizes the window, and when all or part of the window is newly exposed. The _CPaintDC_ statement relates to the Graphics Device Interface (GDI) and is explained in later chapters. The _TextOut_ function displays "Hello, world!"

**Application shutdown—**The user shuts down the application by closing the main frame window. This action initiates a sequence of events, which ends with the destruction of the _CMyFrame_ object, the exit from _Run_, the exit from _WinMain_, and the destruction of the _CMyApp_ object.

Look at the code example again. This time try to get the big picture. Most of the application's functionality is in the MFC library base classes _CWinApp_ and _CFrameWnd_. In writing MYAPP, we've followed a few simple structure rules and we've written key functions in our derived classes. C++ lets us "borrow" a lot of code without copying it. Think of it as a partnership between us and the application framework. The application framework provided the structure, and we provided the code that made the application unique.

Now you're beginning to see why the application framework is more than just a class library. Not only does the application framework define the application structure but it also encompasses more than C++ base classes. You've already seen the hidden _WinMain_ function at work. Other elements support message processing, diagnostics, DLLs, and so forth.
________________________________________________________________________
4.2.3. - [MFC Library Message Mapping](invcpp5/ch02d.htm)
----------------------------------------------------
 MFC Library Message Mapping 

MFC Library Message Mapping
===========================

Refer to the _OnLButtonDown_ member function in the previous example application. You might think that _OnLButtonDown_ would be an ideal candidate for a virtual function. A window base class would define virtual functions for mouse event messages and other standard messages, and derived window classes could override the functions as necessary. Some Windows class libraries do work this way.

The MFC library application framework doesn't use virtual functions for Windows messages. Instead, it uses macros to "map" specified messages to derived class member functions. Why the rejection of virtual functions? Suppose MFC used virtual functions for messages. The _CWnd_ class would declare virtual functions for more than 100 messages. C++ requires a virtual function dispatch table, called a vtable, for each derived class used in a program. Each vtable needs one 4-byte entry for each virtual function, regardless of whether the functions are actually overridden in the derived class. Thus, for each distinct type of window or control, the application would need a table consisting of over 400 bytes to support virtual message handlers.

What about message handlers for menu command messages and messages from button clicks? You couldn't define these as virtual functions in a window base class because each application might have a different set of menu commands and buttons. The MFC library message map system avoids large vtables, and it accommodates application-specific command messages in parallel with ordinary Windows messages. It also allows selected nonwindow classes, such as document classes and the application class, to handle command messages. MFC uses macros to connect (or map) Windows messages to C++ member functions. No extensions to the C++ language are necessary.

An MFC message handler requires a function prototype, a function body, and an entry (macro invocation) in the message map. ClassWizard helps you add message handlers to your classes. You select a Windows message ID from a list box, and the wizard generates the code with the correct function parameters and return values.
________________________________________________________________________
4.2.4. - [Documents and Views](invcpp5/ch02e.htm)
----------------------------------------------------
 Documents and Views 

Documents and Views
===================

The previous example used an application object and a frame window object. Most of your MFC library applications will be more complex. Typically, they'll contain application and frame classes plus two other classes that represent the "document" and the "view." This document-view architecture is the core of the application framework and is loosely based on the Model/View/Controller classes from the Smalltalk world.

In simple terms, the document-view architecture separates data from the user's view of the data. One obvious benefit is multiple views of the same data. Consider a document that consists of a month's worth of stock quotes stored on disk. Suppose a table view and a chart view of the data are both available. The user updates values through the table view window, and the chart view window changes because both windows display the same information (but in different views).

In an MFC library application, documents and views are represented by instances of C++ classes. Figure 2-1 shows three objects of class _CStockDoc_ corresponding to three companies: AT&T, IBM, and GM. All three documents have a table view attached, and one document also has a chart view. As you can see, there are four view objects—three objects of class _CStockTableView_ and one of class _CStockChartView_.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F02OG01x.gif)]

**Figure 2-1.** _The document-view relationship._

The document base class code interacts with the File Open and File Save menu items; the derived document class does the actual reading and writing of the document object's data. (The application framework does most of the work of displaying the File Open and File Save dialog boxes and opening, closing, reading, and writing files.) The view base class represents a window contained inside a frame window; the derived view class interacts with its associated document class and does the application's display and printer I/O. The derived view class and its base classes handle Windows messages. The MFC library orchestrates all interactions among documents, views, frame windows, and the application object, mostly through virtual functions.

Don't think that a document object must be associated with a disk file that is read entirely into memory. If a "document" were really a database, for example, you could override selected document class member functions and the File Open menu item would bring up a list of databases instead of a list of files.
________________________________________________________________________
/5. - [Part II: The MFC Library View Class]()
====================================================
________________________________________________________________________
5.1. - [Chapter 3 -- Getting Started with AppWizard -- ](invcpp5/ch03a.htm)
----------------------------------------------------
 Chapter 3 -- Getting Started with AppWizard -- "Hello, world!"  Chapter 3

Getting Started with AppWizard—"Hello, world!"
==============================================

[Chapter 2](ch02a.htm) sketched the MFC library version 6.0 document-view architecture. This hands-on chapter shows you how to build a functioning MFC library application, but it insulates you from the complexities of the class hierarchy and object interrelationships. You'll work with only one document-view program element, the "view class" that is closely associated with a window. For the time being, you can ignore elements such as the application class, the frame window, and the document. Of course, your application won't be able to save its data on disk, and it won't support multiple views, but Part III of this book provides plenty of opportunity to exploit those features.

Because resources are so important in Microsoft Windows-based applications, you'll use ResourceView to visually explore the resources of your new program. You'll also get some hints for setting up your Windows environment for maximum build speed and optimal debugging output.

> **Requirements:**
> 
> To compile and run the examples presented in this chapter and in the following chapters, you must have successfully installed the released version of Microsoft Windows 95 or Microsoft Windows NT version 4.0 or later, plus all the Microsoft Visual C++ version 6.0 components. Be sure that Visual C++'s executable, include, and library directories are set correctly. (You can change the directories by choosing Options from the Tools menu.) If you have any problems with the following steps, please refer to your Visual C++ documentation and Readme files for troubleshooting instructions.
________________________________________________________________________
5.1.1. - [What's a View?](invcpp5/ch03b.htm)
----------------------------------------------------
 What's a View? 

What's a View?
==============

From a user's standpoint, a view is an ordinary window that the user can size, move, and close in the same way as any other Windows-based application window. From the programmer's perspective, a view is a C++ object of a class derived from the MFC library _CView_ class. Like any C++ object, the view object's behavior is determined by the member functions (and data members) of the class—both the application-specific functions in the derived class and the standard functions inherited from the base classes.

With Visual C++, you can produce interesting applications for Windows by simply adding code to the derived view class that the AppWizard code generator produces. When your program runs, the MFC library application framework constructs an object of the derived view class and displays a window that is tightly linked to the C++ view object. As is customary in C++ programming, the view class code is divided into two source modules—the header file (H) and the implementation file (CPP).
________________________________________________________________________
5.1.2. - [Single Document Interface vs. Multiple Document Interface](invcpp5/ch03c.htm)
----------------------------------------------------
 Single Document Interface vs. Multiple Document Interface 

Single Document Interface vs. Multiple Document Interface
=========================================================

The MFC library supports two distinct application types: Single Document Interface (SDI) and Multiple Document Interface (MDI). An SDI application has, from the user's point of view, only one window. If the application depends on disk-file "documents," only one document can be loaded at a time. The original Windows Notepad is an example of an SDI application. An MDI application has multiple child windows, each of which corresponds to an individual document. Microsoft Word is a good example of an MDI application.

When you run AppWizard to create a new project, MDI is the default application type. For the early examples in this book, you'll be generating SDI applications because fewer classes and features are involved. Be sure you select the Single Document option (on the first AppWizard screen) for these examples. Starting with [Chapter 18](ch18a.htm), you'll be generating MDI applications. The MFC library application framework architecture ensures that most SDI examples can be upgraded easily to MDI applications.
________________________________________________________________________
5.1.3. - [The Do-Nothing Application -- EX03A](invcpp5/ch03d.htm)
----------------------------------------------------
 The "Do-Nothing" Application -- EX03A 

The "Do-Nothing" Application—EX03A
==================================

The AppWizard tool generates the code for a functioning MFC library application. This working application simply brings up an empty window with a menu attached. Later you'll add code that draws inside the window. Follow these steps to build the application:

2.  **Run AppWizard to generate SDI application source code.** Choose New from Visual C++'s File menu, and then click the Projects tab in the resulting New dialog box, as shown here.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G03OG01x.gif)]
    
    Make sure that MFC AppWizard (exe) is highlighted, and then type _C:\vcpp32\_ in the Location edit box. Type _ex03a_ as shown in the Project Name edit box, and then click the OK button. Now you will step through a sequence of AppWizard screens, the first of which is shown here.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G03OG02x.gif)]
    
    Be sure to select the Single Document option. Accept the defaults in the next four screens. The last screen should look like the following illustration.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G03OG03x.gif)]
    
    Notice that the class names and source-file names have been generated based on the project name EX03A. You could make changes to these names at this point if you wanted to. Click the Finish button. Just before AppWizard generates your code, it displays the New Project Information dialog box, shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G03OG04x.GIF)
    
    When you click the OK button, AppWizard begins to create your application's subdirectory (ex03a under \vcpp32) and a series of files in that subdirectory. When AppWizard is finished, look in the application's subdirectory. The following files are of interest (for now).
    
    **File**
    
    **Description**
    
    ex03a.dsp
    
    A project file that allows Visual C++ to build your application
    
    ex03a.dsw
    
    A workspace file that contains a single entry for ex03a.dsp
    
    ex03a.rc
    
    An ASCII resource script file
    
    ex03aView.cpp
    
    A view class implementation file that contains _CEx03aView_ class member functions
    
    ex03aView.h
    
    A view class header file that contains the _CEx03aView_ class declaration
    
    ex03a.opt
    
    A binary file that tells Visual C++ which files are open for this project and how the windows are arranged (This file is not created until you save the project.)
    
    ReadMe.txt
    
    A text file that explains the purpose of the generated files
    
    resource.h
    
    A header file that contains _#define_ constant definitions
    
    Open the ex03aView.cpp and ex03aView.h files and look at the source code. Together these files define the _CEx03aView_ class, which is central to the application. An object of class _CEx03aView_ corresponds to the application's view window, where all the "action" takes place.
    

3.  **Compile and link the generated code.** AppWizard, in addition to generating code, creates custom project and workspace files for your application. The project file, ex03a.dsp, specifies all the file dependencies together with the compile and link option flags. Because the new project becomes Visual C++'s current project, you can now build the application by choosing Build Ex03a.exe from the Build menu or by clicking the Build toolbar button, shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G03OG05.GIF)
    
    If the build is successful, an executable program named ex03a.exe is created in a new Debug subdirectory underneath \vcpp32\ex03a. The OBJ files and other intermediate files are also stored in Debug. Compare the file structure on disk with the structure in the Workspace window's FileView page shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G03OG06.GIF)
    
    The FileView page contains a logical view of your project. The header files show up under Header Files, even though they are in the same subdirectory as the CPP files. The resource files are stored in the \res subdirectory.
    
4.  **Test the resulting application.** Choose Execute Ex03a.exe from the Build menu. Experiment with the program. It doesn't do much, does it? (What do you expect for no coding?) Actually, as you might guess, the program has a lot of features—you simply haven't activated them yet. Close the program window when you've finished experimenting.
    
5.  **Browse the application.** Choose Source Browser from the Tools menu. If your project settings don't specify browser database creation, Visual C++ will offer to change the settings and recompile the program for you. (To change the settings yourself, choose Settings from the Project menu. On the C/C++ page, click Generate Browse Info, and on the Browse Info page, click Build Browse Info File.)
    
    When the Browse window appears, choose Base Classes And Members and then type _CEx03aView_. After you expand the hierarchy, you should see output similar to this.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G03OG07x.gif)]
    
    Compare the browser output to ClassView in the Workspace window.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G03OG08.GIF)
    
    ClassView doesn't show the class hierarchy, but it also doesn't involve the extra overhead of the browser. If ClassView is sufficient for you, don't bother building the browser database.
________________________________________________________________________
5.1.4. - [The CEx03aView View Class](invcpp5/ch03e.htm)
----------------------------------------------------
 The CEx03aView View Class 

The _CEx03aView_ View Class
===========================

AppWizard generated the _CEx03aView_ view class, and this class is specific to the EX03A application. (AppWizard generates classes based on the project name you entered in the first AppWizard dialog box.) _CEx03aView_ is at the bottom of a long inheritance chain of MFC library classes, as illustrated previously in the Browse window. The class picks up member functions and data members all along the chain. You can learn about these classes in the _Microsoft Foundation_ _Class Reference_ (online or printed version), but you must be sure to look at the descriptions for every base class because the descriptions of inherited member functions aren't generally repeated for derived classes.

The most important _CEx03aView_ base classes are _CWnd_ and _CView_. _CWnd_ provides _CEx03aView_'s "windowness," and _CView_ provides the hooks to the rest of the application framework, particularly to the document and to the frame window, as you'll see in Part III of this book.
________________________________________________________________________
5.1.5. - [Drawing Inside the View Window -- The Windows Graphics Device Interface](invcpp5/ch03f.htm)
----------------------------------------------------
 Drawing Inside the View Window -- The Windows Graphics Device Interface 

Drawing Inside the View Window—The Windows Graphics Device Interface
====================================================================

Now you're ready to write code to draw inside the view window. You'll be making a few changes directly to the EX03A source code.

The _OnDraw_ Member Function
----------------------------

Specifically, you'll be fleshing out _OnDraw_ in ex03aView.cpp. _OnDraw_ is a virtual member function of the _CView_ class that the application framework calls every time the view window needs to be repainted. A window needs to be repainted if the user resizes the window or reveals a previously hidden part of the window, or if the application changes the window's data. If the user resizes the window or reveals a hidden area, the application framework calls _OnDraw_, but if a function in your program changes the data, it must inform Windows of the change by calling the view's inherited _Invalidate_ (or _InvalidateRect_) member function. This call to _Invalidate_ triggers a later call to _OnDraw_.

Even though you can draw inside a window at any time, it's recommended that you let window changes accumulate and then process them all together in the _OnDraw_ function. That way your program can respond both to program-generated events and to Windows-generated events such as size changes.

The Windows Device Context
--------------------------

Recall from [Chapter 1](ch01b.htm#5) that Windows doesn't allow direct access to the display hardware but communicates through an abstraction called a "device context" that is associated with the window. In the MFC library, the device context is a C++ object of class _CDC_ that is passed (by pointer) as a parameter to _OnDraw_. After you have the device context pointer, you can call the many _CDC_ member functions that do the work of drawing.

Adding Draw Code to the EX03A Program
-------------------------------------

Now let's write the code to draw some text and a circle inside the view window. Be sure that the project EX03A is open in Visual C++. You can use the Workspace window's ClassView to locate the code for the function (double-click on _OnDraw_), or you can open the source code file ex03aView.cpp from FileView and locate the function yourself.

2.  **Edit the _OnDraw_ function in ex03aView.cpp.** Find the AppWizard-generated _OnDraw_ function in ex03aView.cpp:
    
    void CEx03aView::OnDraw(CDC\* pDC)
    {
        CEx03aDoc\* pDoc = GetDocument();
        ASSERT_VALID(pDoc);
    
        // TODO: add draw code for native data here
    }
    
    The following boldface code (which you type in) replaces the previous code:
    
    void CEx03aView::OnDraw(CDC\* pDC)
    {
        **pDC->TextOut(0, 0, "Hello, world!");  // prints in default font
                                              //  & size, top left corner
        pDC->SelectStockObject(GRAY_BRUSH);   // selects a brush for the
                                              //  circle interior
        pDC->Ellipse(CRect(0, 20, 100, 120)); // draws a gray circle 
                                              //  100 units in diameter**
    }
    
    You can safely remove the call to _GetDocument_ because we're not dealing with documents yet. The functions _TextOut_, _SelectStockObject_, and _Ellipse_ are all member functions of the application framework's device context class _CDC_. The _Ellipse_ function draws a circle if the bounding rectangle's length is equal to its width.
    
    The MFC library provides a handy utility class, _CRect_, for Windows rectangles. A temporary _CRect_ object serves as the bounding rectangle argument for the ellipse drawing function. You'll see more of the _CRect_ class in quite a few of the examples in this book.
    
3.  **Recompile and test EX03A.** Choose Build from the Project menu, and, if there are no compile errors, test the application again. Now you have a program that visibly does something!

> **For Win32 Programmers**
> 
> Rest assured that the standard Windows _WinMain_ and window procedure functions are hidden away inside the application framework. You'll see those functions later in this book, when the MFC library frame and application classes are examined. In the meantime, you're probably wondering what happened to the WM_PAINT message, aren't you? You would expect to do your window drawing in response to this Windows message, and you would expect to get your device context handle from a _PAINTSTRUCT_ structure returned by the Windows _BeginPaint_ function.
> 
> It so happens that the application framework has done all the dirty work for you and served up a device context (in object pointer form) in the virtual function _OnDraw_. As explained in [Chapter 2](ch02a.htm), true virtual functions in window classes are an MFC library rarity. MFC library message map functions dispatched by the application framework handle most Windows messages. MFC version 1.0 programmers always defined an _OnPaint_ message map function for their derived window classes. Beginning with version 2.5, however, _OnPaint_ was mapped in the _CView_ class, and that function made a polymorphic call to _OnDraw_. Why? Because _OnDraw_ needs to support the printer as well as the display. Both _OnPaint_ and _OnPrint_ call _OnDraw_, thus enabling the same drawing code to accommodate both the printer and the display.
________________________________________________________________________
5.1.6. - [A Preview of the Resource Editors](invcpp5/ch03g.htm)
----------------------------------------------------
 A Preview of the Resource Editors 

A Preview of the Resource Editors
=================================

Now that you have a complete application program, it's a good time for a quick look at the resource editors. Although the application's resource script, ex03a.rc, is an ASCII file, modifying it with a text editor is not a good idea. That's the resource editors' job.

The Contents of ex03a.rc
------------------------

The resource file determines much of the EX03A application's "look and feel." The file ex03a.rc contains (or points to) the Windows resources listed here.

**Resource**

**Description**

Accelerator

Definitions for keys that simulate menu and toolbar selections.

Dialog

Layout and contents of dialog boxes. EX03A has only the About dialog box.

Icon

Icons (16-by-16-pixel and 32-by-32-pixel versions), such as the application icon you see in Microsoft Windows Explorer and in the application's About dialog box. EX03A uses the MFC logo for its application icon.

Menu

The application's top-level menu and associated pop-up menus.

String table

Strings that are not part of the C++ source code.

Toolbar

The row of buttons immediately below the menu.

Version

Program description, version number, language, and so on.

In addition to the resources listed above, ex03a.rc contains the statements

#include  "afxres.h"
#include  "afxres.rc"

which bring in some MFC library resources common to all applications. These resources include strings, graphical buttons, and elements needed for printing and OLE.

> NOTE
> 
> If you're using the shared DLL version of the MFC library, the common resources are stored inside the MFC DLL.

The ex03a.rc file also contains the statement

#include  "resource.h"

This statement brings in the application's three _#define_ constants, which are _IDR___MAINFRAME_ (identifying the menu, icon, string list, and accelerator table), _IDR_EX03ATYPE_ (identifying the default document icon, which we won't use in this program), and _IDD___ABOUTBOX_ (identifying the About dialog box). This same resource.h file is included indirectly by the application's source code files. If you use a resource editor to add more constants (symbols), the definitions ultimately show up in resource.h. Be careful if you edit this file in text mode because your changes might be removed the next time you use a resource editor.

Running the Dialog Resource Editor
----------------------------------

2.  **Open the project's RC file.** Click the ResourceView button in the Workspace window. If you expand each item, you will see the following in the resource editor window.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G03OG09.GIF)
    
3.  **Examine the application's resources.** Now take some time to explore the individual resources. When you select a resource by double-clicking on it, another window opens with tools appropriate for the selected resource. If you open a dialog resource, the control palette should appear. If it doesn't, right-click inside any toolbar, and then check Controls.
    
4.  **Modify the IDD_ABOUTBOX dialog box.** Make some changes to the About Ex03a dialog box, shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G03OG10.GIF)
    
5.  You can change the size of the window by dragging the right and bottom borders, move the OK button, change the text, and so forth. Simply click on an element to select it, and then right-click to change its properties.
    
6.  **Rebuild the project with the modified resource file.** In Visual C++, choose Build Ex03a.exe from the Build menu. Notice that no actual C++ recompilation is necessary. Visual C++ saves the edited resource file, and then the Resource Compiler (rc.exe) processes ex03a.rc to produce a compiled version, ex03a.res, which is fed to the linker. The linker runs quickly because it can link the project incrementally.
7.  **Test the new version of the application.** Run the EX03A program again, and then choose About from the application's Help menu to confirm that your dialog box was changed as expected.
________________________________________________________________________
5.1.7. - [Win32 Debug Target vs. Win32 Release Target](invcpp5/ch03h.htm)
----------------------------------------------------
 Win32 Debug Target vs. Win32 Release Target 

Win32 Debug Target vs. Win32 Release Target
===========================================

If you open the drop-down list on the Build toolbar, you'll notice two items: Win32 Debug and Win32 Release. (The Build toolbar is not present by default, but you can choose Customize from the Tools menu to display it.) These items are targets that represent distinct sets of build options. When AppWizard generates a project, it creates two default targets with different settings. These settings are summarized in the following table.

**Option**

**Release Build**

**Debug Build**

**_Source code debugging_**

Disabled

Enabled for both compiler and linker

**_MFC diagnostic macros_**

Disabled (NDEBUG defined)

Enabled (_DEBUG defined)

**_Library linkage_**

MFC Release library

MFC Debug libraries

**_Compiler optimization_**

Speed optimization (not available in Learning Edition)

No optimization (faster compile)

You develop your application in Debug mode, and then you rebuild in Release mode prior to delivery. The Release build EXE will be smaller and faster, assuming that you have fixed all the bugs. You select the configuration from the build target window in the Build toolbar, as shown in [Figure 1-2](ch01c.htm#100) in Chapter 1. By default, the Debug output files and intermediate files are stored in the project's Debug subdirectory; the Release files are stored in the Release subdirectory. You can change these directories on the General tab in the Project Settings dialog box.

You can create your own custom configurations if you need to by choosing Configurations from Visual C++'s Build menu.
________________________________________________________________________
5.1.8. - [Enabling the Diagnostic Macros](invcpp5/ch03i.htm)
----------------------------------------------------
 Enabling the Diagnostic Macros 

Enabling the Diagnostic Macros
==============================

The application framework _TRACE_ macros are particularly useful for monitoring program activity. They require that tracing be enabled, which is the default setting. If you're not seeing _TRACE_ output from your program, first make sure that you are running the debug target from the debugger and then run the TRACER utility. If you check the Enable Tracing checkbox, TRACER will insert the statement

TraceEnabled = 1

in the [Diagnostics] section of a file named Afx.ini. (No, it's not stored in the Registry.) You can also use TRACER to enable other MFC diagnostic outputs, including message, OLE, database, and Internet information.
________________________________________________________________________
5.1.9. - [Understanding Precompiled Headers](invcpp5/ch03j.htm)
----------------------------------------------------
 Understanding Precompiled Headers 

Understanding Precompiled Headers
=================================

When AppWizard generates a project, it generates switch settings and files for precompiled headers. You must understand how the make system processes precompiled headers in order to manage your projects effectively.

> NOTE
> 
> Visual C++ has two precompiled header "systems:" automatic and manual. Automatic precompiled headers, activated with the /Yx compiler switch, store compiler output in a "database" file. Manual precompiled headers are activated by the /Yc and /Yu switch settings and are central to all AppWizard-generated projects.

Precompiled headers represent compiler "snapshots" taken at a particular line of source code. In MFC library programs, the snapshot is generally taken immediately after the following statement:

#include  "StdAfx.h"

The file StdAfx.h contains _#include_ statements for the MFC library header files. The file's contents depend on the options that you select when you run AppWizard, but the file always contains these statements:

#include <afxwin.h>
#include <afxext.h>

If you're using compound documents, StdAfx.h also contains the statement

#include <afxole.h>

and if you're using Automation or ActiveX Controls, it contains

#include <afxdisp.h>

If you're using Internet Explorer 4 Common Controls, StdAfx.h contains the statement

#include <afxdtctl.h>

Occasionally you will need other header files—for example, the header for template-based collection classes that is accessed by the statement

#include <afxtempl.h>

The source file StdAfx.cpp contains only the statement

#include  "StdAfx.h"

and is used to generate the precompiled header file in the project directory. The MFC library headers included by StdAfx.h never change, but they do take a long time to compile. The compiler switch /Yc, used only with StdAfx.cpp, causes creation of the precompiled header (PCH) file. The switch /Yu, used with all the other source code files, causes use of an existing PCH file. The switch /Fp specifies the PCH filename that would otherwise default to the project name (with the PCH extension) in the target's output files subdirectory. Figure 3-1 illustrates the whole process.

AppWizard sets the /Yc and /Yu switches for you, but you can make changes if you need to. It's possible to define compiler switch settings for individual source files. On the C/C++ tab in the Project Settings dialog box, if you select only StdAfx.cpp, you'll see the /Yc setting. This overrides the /Yu setting that is defined for the target.

Be aware that PCH files are big—5 MB is typical. If you're not careful, you'll fill up your hard disk. You can keep things under control by periodically cleaning out your projects' Debug directories, or you can use the /Fp compiler option to reroute PCH files to a common directory.

![](c:/dl/books/windows/msvc5th/invcpp5/images/F03OG01.GIF)

**Figure 3-1.** _The Visual C++ precompiled header process._
________________________________________________________________________
5.1.10. - [Two Ways to Run a Program](invcpp5/ch03k.htm)
----------------------------------------------------
 Two Ways to Run a Program 

Two Ways to Run a Program
=========================

Visual C++ lets you run your program directly (by pressing Ctrl-F5) or through the debugger (by pressing F5). Running your program directly is much faster because Visual C++ doesn't have to load the debugger first. If you know you don't want to see diagnostic messages or use breakpoints, start your program by pressing Ctrl-F5 or use the "exclamation point" button on the Build toolbar.
________________________________________________________________________
5.2. - [Chapter 4 -- Basic Event Handling, Mapping Modes, and a Scrolling View](invcpp5/ch04a.htm)
----------------------------------------------------
 Chapter 4 -- Basic Event Handling, Mapping Modes, and a Scrolling View  Chapter 4

Basic Event Handling, Mapping Modes, and a Scrolling View
=========================================================

In [Chapter 3](ch03a.htm), you saw how the Microsoft Foundation Class (MFC) Library application framework called the view class's virtual _OnDraw_ function. Take a look at the online help for the MFC library now. If you look at the documentation for the _CView_ class and its base class, _CWnd_, you'll see several hundred member functions. Functions whose names begin with _On—_such as _OnKeyDown_ and _OnLButtonUp—_are member functions that the application framework calls in response to various Windows "events" such as keystrokes and mouse clicks.

Most of these application framework-called functions, such as _OnKeyDown_, aren't virtual functions and thus require more programming steps. This chapter explains how to use the Visual C++ ClassWizard to set up the message map structure necessary for connecting the application framework to your functions' code. You'll see the practical application of message map functions.

The first two examples use an ordinary _CView_ class. In EX04A, you'll learn about the interaction between user-driven events and the _OnDraw_ function. In EX04B, you'll see the effects of different Windows mapping modes.

More often than not, you'll want a scrolling view. The last example, EX04C, uses _CScrollView_ in place of the _CView_ base class. This allows the MFC library application framework to insert scroll bars and connect them to the view.
________________________________________________________________________
5.2.1. - [Getting User Input--Message Map Functions](invcpp5/ch04b.htm)
----------------------------------------------------
 Getting User Input -- Message Map Functions 

Getting User Input—Message Map Functions
========================================

Your EX03A application from [Chapter 3](ch03a.htm) did not accept user input (other than the standard Microsoft Windows resizing and window close commands). The window contained menus and a toolbar, but these were not "connected" to the view code. The menus and the toolbar won't be discussed until Part III of this book because they depend on the frame class, but plenty of other Windows input sources will keep you busy until then. Before you can process any Windows event, even a mouse click, however, you must learn how to use the MFC message map system.

The Message Map
---------------

When the user presses the left mouse button in a view window, Windows sends a message—specifically WM_LBUTTONDOWN—to that window. If your program needs to take action in response to WM_LBUTTONDOWN, your view class must have a member function that looks like this:

void CMyView::OnLButtonDown(UINT nFlags, CPoint point)
{
    // event processing code here
}

Your class header file must also have the corresponding prototype:

afx_msg void OnLButtonDown(UINT nFlags, CPoint point);

The _afx___msg_ notation is a "no-op" that alerts you that this is a prototype for a message map function. Next, your code file needs a message map macro that connects your _OnLButtonDown_ function to the application framework:

BEGIN_MESSAGE_MAP(CMyView, CView)
    ON_WM_LBUTTONDOWN() // entry specifically for OnLButtonDown
    // other message map entries
END_MESSAGE_MAP()

Finally, your class header file needs the statement

DECLARE_MESSAGE_MAP()

How do you know which function goes with which Windows message? [Appendix A](chaaa.htm) (and the MFC library online documentation) includes a table that lists all standard Windows messages and corresponding member function prototypes. You can manually code the message-handling functions—indeed, that is still necessary for certain messages. Fortunately, Visual C++ provides a tool, ClassWizard, that automates the coding of most message map functions.

Saving the View's State—Class Data Members
------------------------------------------

If your program accepts user input, you'll want the user to have some visual feedback. The view's _OnDraw_ function draws an image based on the view's current "state," and user actions can alter that state. In a full-blown MFC application, the document object holds the state of the application, but you're not to that point yet. For now, you'll use two view class data members, _m_rectEllipse_ and _m_nColor._ The first is an object of class _CRect_, which holds the current bounding rectangle of an ellipse, and the second is an integer that holds the current ellipse color value.

> NOTE
> 
> By convention, MFC library nonstatic class data member names begin with _m__.

You'll make a message-mapped member function toggle the ellipse color (the view's state) between gray and white. (The toggle is activated by pressing the left mouse button.) The initial values of _m_rectEllipse_ and _m_nColor_ are set in the view's constructor, and the color is changed in the _OnLButtonDown_ member function.

> TIPS
> 
> Why not use a global variable for the view's state? Because if you did, you'd be in trouble if your application had multiple views. Besides, encapsulating data in objects is a big part of what object-oriented programming is all about.

### Initializing a View Class Data Member

The most efficient place to initialize a class data member is in the constructor, like this:

CMyView::CMyView() : m_rectEllipse(0, 0, 200, 200) {...}

You could initialize _m_nColor_ with the same syntax. Because we're using a built-in type (integer), the generated code is the same if you use an assignment statement in the constructor body.

Invalid Rectangle Theory
------------------------

The _OnLButtonDown_ function could toggle the value of _m___nColor_ all day, but if that's all it did, the _OnDraw_ function wouldn't get called (unless, for example, the user resized the view window). The _OnLButtonDown_ function must call the _InvalidateRect_ function (a member function that the view class inherits from _CWnd_). _InvalidateRect_ triggers a Windows WM_PAINT message, which is mapped in the _CView_ class to call to the virtual _OnDraw_ function. If necessary, _OnDraw_ can access the "invalid rectangle" parameter that was passed to _InvalidateRect_.

There are two ways to optimize painting in Windows. First of all, you must be aware that Windows updates only those pixels that are inside the invalid rectangle. Thus, the smaller you make the invalid rectangle (in the _OnLButtonDown_ handler, for instance), the quicker it can be repainted. Second, it's a waste of time to execute drawing instructions outside the invalid rectangle. Your _OnDraw_ function could call the _CDC_ member function _GetClipBox_ to determine the invalid rectangle, and then it could avoid drawing objects outside it. Remember that _OnDraw_ is being called not only in response to your _InvalidateRect_ call but also when the user resizes or exposes the window. Thus, _OnDraw_ is responsible for all drawing in a window, and it has to adapt to whatever invalid rectangle it gets.

> **For Win32 Programmers**
> 
> The MFC library makes it easy to attach your own state variables to a window through C++ class data members. In Win32 programming, the _WNDCLASS_ members _cbClsExtra_ and _cbWndExtra_ are available for this purpose, but the code for using this mechanism is so complex that developers tend to use global variables instead.

The Window's Client Area
------------------------

A window has a rectangular client area that excludes the border, caption bar, menu bar, and any docking toolbars. The _CWnd_ member function _GetClientRect_ supplies you with the client-area dimensions. Normally, you're not allowed to draw outside the client area, and most mouse messages are received only when the mouse cursor is in the client area.

_CRect_, _CPoint_, and _CSize_ Arithmetic
-----------------------------------------

The _CRect_, _CPoint_, and _CSize_ classes are derived from the Windows _RECT_, _POINT_, and _SIZE_ structures, and thus they inherit public integer data members as follows:

_CRect_

_left, top, right, bottom_

_CPoint_

_x, y_

_CSize_

_cx, cy_

If you look in the _Microsoft Foundation_ _Class Reference,_ you will see that these three classes have a number of overloaded operators. You can, among other things, do the following:

*   Add a _CSize_ object to a _CPoint_ object
    
*   Subtract a _CSize_ object from a _CPoint_ object
    
*   Subtract one _CPoint_ object from another, yielding a _CSize_ object
    
*   Add a _CPoint_ or _CSize_ object to a _CRect_ object
    
*   Subtract a _CPoint_ or _CSize_ object from a _CRect_ object
    

The _CRect_ class has member functions that relate to the _CSize_ and _CPoint_ classes. For example, the _TopLeft_ member function returns a _CPoint_ object, and the _Size_ member function returns a _CSize_ object. From this, you can begin to see that a _CSize_ object is the "difference between two _CPoint_ objects" and that you can "bias" a _CRect_ object by a _CPoint_ object.

Is a Point Inside a Rectangle?
------------------------------

The _CRect_ class has a member function _PtInRect_ that tests a point to see whether it falls inside a rectangle. The second _OnLButtonDown_ parameter (_point_) is an object of class _CPoint_ that represents the cursor location in the client area of the window. If you want to know whether that point is inside the _m_rectEllipse_ rectangle, you can use _PtInRect_ in this way:

if (m_rectEllipse.PtInRect(point)) {
    // point is inside rectangle
}

As you'll soon see, however, this simple logic applies only if you're working in device coordinates (which you are at this stage).

The _CRect LPCRECT_ Operator
----------------------------

If you read the _Microsoft Foundation_ _Class Reference_ carefully, you will notice that _CWnd::InvalidateRect_ takes an _LPCRECT_ parameter (a pointer to a _RECT_ structure), not a _CRect_ parameter. A _CRect_ parameter is allowed because the _CRect_ class defines an overloaded operator, _LPCRECT()_, that returns the address of a _CRect_ object, which is equivalent to the address of a _RECT_ object. Thus, the compiler converts _CRect_ arguments to _LPCRECT_ arguments when necessary. You call functions as though they had _CRect_ reference parameters. The view member function code

CRect rectClient;
GetClientRect(rectClient);

retrieves the client rectangle coordinates and stores them in _rectClient_.

Is a Point Inside an Ellipse?
-----------------------------

The EX04A code determines whether the mouse hit is inside the rectangle. If you want to make a better test, you can find out whether the hit is inside the ellipse. To do this, you must construct an object of class _CRgn_ that corresponds to the ellipse and then use the _PtInRegion_ function instead of _PtInRect_. Here's the code:

CRgn rgn;
rgn.CreateEllipticRgnIndirect(m_rectEllipse);
if (rgn.PtInRegion(point)) {
    // point is inside ellipse
}

Note that the _CreateEllipticRgnIndirect_ function is another function that takes an _LPCRECT_ parameter. It builds a special region structure within Windows that represents an elliptical region inside a window. That structure is then attached to the C++ _CRgn_ object in your program. (The same type of structure can also represent a polygon.)

The EX04A Example
-----------------

In the EX04A example, an ellipse (which happens to be a circle) changes color when the user presses the left mouse button while the mouse cursor is inside the rectangle that bounds the ellipse. You'll use the view class data members to hold the view's state, and you'll use the _InvalidateRect_ function to cause the view to be redrawn.

In the [Chapter 3](ch03a.htm) example, drawing in the window depended on only one function, _OnDraw_. The EX04A example requires three customized functions (including the constructor) and two data members. The complete _CEx04aView_ header and source code files are listed in Figure 4-1. (The steps for creating the program are shown after the program listings.) All changes to the original AppWizard and OnLButtonDown ClassWizard output are in boldface.

### EX04AVIEW.H

// ex04aView.h : interface of the CEx04aView class
//
///////////////////////////////////////////////////////////////////////

#if !defined(AFX_EX04AVIEW_H__B188BE41_6377_11D0_8FD4_00C04FC2A0C2
__INCLUDED_)
#define AFX_EX04AVIEW_H__B188BE41_6377_11D0_8FD4_00C04FC2A0C2
__INCLUDED_

#if _MFC_VER > 1000
#pragma once
#endif // _MFC_VER > 1000
class CEx04aView : public CView
{
protected: // create from serialization only
    CEx04aView();
    DECLARE_DYNCREATE(CEx04aView)

// Attributes
public:
    CEx04aDoc\* GetDocument();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEx04aView)
    public:
    virtual void OnDraw(CDC\* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    protected:
    virtual BOOL OnPreparePrinting(CPrintInfo\* pInfo);
    virtual void OnBeginPrinting(CDC\* pDC, CPrintInfo\* pInfo);
    virtual void OnEndPrinting(CDC\* pDC, CPrintInfo\* pInfo);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CEx04aView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CEx04aView)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
**private:
    int m_nColor;
    CRect m_rectEllipse;**
};
#ifndef _DEBUG  // debug version in ex04aView.cpp
inline CEx04aDoc\* CEx04aView::GetDocument()
   { return (CEx04aDoc\*)m_pDocument; }
#endif

///////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations
//  immediately before the previous line.

#endif // !defined(AFX_EX04AVIEW_H__B188BE41_6377_11D0_8FD4_00C04FC2A0C2__INCLUDED_)

### EX04AVIEW.CPP

// ex04aView.cpp : implementation of the CEx04aView class
//

#include "stdafx.h"
#include "ex04a.h"

#include "ex04aDoc.h"
#include "ex04aView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE
__;
#endif

///////////////////////////////////////////////////////////////////////
// CEx04aView

IMPLEMENT_DYNCREATE(CEx04aView, CView)

BEGIN_MESSAGE_MAP(CEx04aView, CView)
    //{{AFX_MSG_MAP(CEx04aView)
    ON_WM_LBUTTONDOWN()
    //}}AFX_MSG_MAP
    // Standard printing commands
    ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()
///////////////////////////////////////////////////////////////////////
// CEx04aView construction/destruction

CEx04aView::CEx04aView() **: m_rectEllipse(0, 0, 200, 200)**
{
    **m_nColor = GRAY_BRUSH;**
}

CEx04aView::~CEx04aView()
{
}

BOOL CEx04aView::PreCreateWindow(CREATESTRUCT& cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return CView::PreCreateWindow(cs);
}

///////////////////////////////////////////////////////////////////////
// CEx04aView drawing

void CEx04aView::OnDraw(CDC\* pDC)
{
    **pDC->SelectStockObject(m_nColor);
    pDC->Ellipse(m_rectEllipse);**
}

///////////////////////////////////////////////////////////////////////
// CEx04aView printing

BOOL CEx04aView::OnPreparePrinting(CPrintInfo\* pInfo)
{
    // default preparation
    return DoPreparePrinting(pInfo);
}

void CEx04aView::OnBeginPrinting(CDC\* /\*pDC\*/, CPrintInfo\* /\*pInfo\*/)
{
    // TODO: add extra initialization before printing
}

void CEx04aView::OnEndPrinting(CDC\* /\*pDC\*/, CPrintInfo\* /\*pInfo\*/)
{
    // TODO: add cleanup after printing
}

///////////////////////////////////////////////////////////////////////
// CEx04aView diagnostics

#ifdef _DEBUG
void CEx04aView::AssertValid() const
{
    CView::AssertValid();
}

void CEx04aView::Dump(CDumpContext& dc) const
{
    CView::Dump(dc);
}

CEx04aDoc\* CEx04aView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CEx04aDoc)));
    return (CEx04aDoc\*)m_pDocument;
}
#endif //_DEBUG

///////////////////////////////////////////////////////////////////////
// CEx04aView message handlers

void CEx04aView::OnLButtonDown(UINT nFlags, CPoint point) 
{
    **if (m_rectEllipse.PtInRect(point)) {
        if (m_nColor == GRAY_BRUSH) {
            m_nColor = WHITE_BRUSH;
        }
        else {
            m_nColor = GRAY_BRUSH;
        }
        InvalidateRect(m_rectEllipse);
    }**
}

**Figure 4-1.** _The_ CEx04aView _header and source code files._

Using ClassWizard with EX04A
----------------------------

Look at the following ex04aView.h source code:

//{{AFX_MSG(CEx04aView)
afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
//}}AFX_MSG

Now look at the following ex04aView.cpp source code:

//{{AFX_MSG_MAP(CEx04aView)
ON_WM_LBUTTONDOWN()
//}}AFX_MSG_MAP

AppWizard generated the funny-looking comment lines for the benefit of ClassWizard. ClassWizard adds message handler prototypes between the _AFX___MSG_ brackets and message map entries between the _AFX___MSG___MAP_ brackets. In addition, ClassWizard generates a skeleton _OnLButtonDown_ member function in ex04aView.cpp, complete with the correct parameter declarations and return type.

Notice how the AppWizard_ClassWizard combination is different from a conventional code generator. You run a conventional code generator only once and then edit the resulting code. You run AppWizard to generate the application only once, but you can run ClassWizard as many times as necessary, and you can edit the code at any time. You're safe as long as you don't alter what's inside the _AFX___MSG_ and _AFX___MSG___MAP_ brackets.

### Using AppWizard and ClassWizard Together

The following steps show how you use AppWizard and ClassWizard together to create this application:

2.  **Run AppWizard to create EX04A.** Use AppWizard to generate an SDI project named EX04A in the \vcpp32\ex04a subdirectory. The options and the default class names are shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G04OG01x.gif)
    
3.  **Add the _m___rectEllipse_ and _m_nColor_ data members to _CEx04aView_.** With the Workspace window set to ClassView, right-click the _CEx04aView_ class, select Add Member Variable, and then insert the following two data members:
    
    **private:
        CRect m_rectEllipse;
        int m_nColor;**
    
    If you prefer, you could type the above code inside the class declaration in the file ex04aView.h.
    
4.  **Use ClassWizard to add a _CEx04aView_ class message handler.** Choose ClassWizard from the View menu of Visual C++, or right-click inside a source code window and choose ClassWizard from the context menu. When the MFC ClassWizard dialog appears, be sure that the _CEx04aView_ class is selected, as shown in the illustration below. Now click on _CEx04aView_ at the top of the Object IDs list box, and then scroll down past the virtual functions in the Messages list box and double-click on WM_LBUTTONDOWN. The _OnLButtonDown_ function name should appear in the Member Functions list box, and the message name should be displayed in bold in the Messages list box. Here's the ClassWizard dialog box.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G04OG02x.gif)]
    
    > NOTE
    > 
    > Instead of using ClassWizard, you can map the function from the Visual C++ WizardBar (shown in [Figure 1-2](ch01c.htm#100) in Chapter 1).
    
5.  **Edit the _OnLButtonDown_ code in ex04aView.cpp.** Click the Edit Code button. ClassWizard opens an edit window for ex04aView.cpp in Visual C++ and positions the cursor on the newly generated _OnLButtonDown_ member function. The following boldface code (that you type in) replaces the previous code:
    
    void CEx04aView::OnLButtonDown(UINT nFlags, CPoint point)
    {
        **if (m_rectEllipse.PtInRect(point)) {
            if (m_nColor 
    == GRAY_BRUSH) {
                m_nColor = WHITE_BRUSH;
            }
            else {
                m_nColor = GRAY_BRUSH;
            }
            InvalidateRect(m_rectEllipse);
        }**
    }
    
6.  **Edit the constructor and the _OnDraw_ function in ex04aView.cpp.** The following boldface code (that you type in) replaces the previous code:
    
    CEx04aView::CEx04aView() **: m_rectEllipse(0, 0, 200, 200)**
    {
       ** m_nColor = GRAY_BRUSH;**
    }
    .
    .
    .
    void CEx04aView::OnDraw(CDC\* pDC)
    {
        **pDC->SelectStockObject(m_nColor);
        pDC->Ellipse(m_rectEllipse);**
    }
    
7.  **Build and run the EX04A program.** Choose Build Ex04a.exe from the Build menu, or, on the Build toolbar, click the button shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/g04og03.gif)
    
    Then choose Execute Ex04a.exe from the Build menu. The resulting program responds to presses of the left mouse button by changing the color of the circle in the view window. (Don't press the mouse's left button quickly in succession; Windows interprets this as a double click rather than two single clicks.)
    

> **For Win32 Programmers**
> 
> A conventional Windows-based application registers a series of window classes (not the same as C++ classes) and, in the process, assigns a unique function, known as a window procedure, to each class. Each time the application calls _CreateWindow_ to create a window, it specifies a window class as a parameter and thus links the newly created window to a window procedure function. This function, called each time Windows sends a message to the window, tests the message code that is passed as a parameter and then executes the appropriate code to handle the message.
> 
> The MFC application framework has a single window class and window procedure function for most window types. This window procedure function looks up the window handle (passed as a parameter) in the MFC handle map to get the corresponding C++ window object pointer. The window procedure function then uses the MFC runtime class system (see [Appendix B](chaba.htm)) to determine the C++ class of the window object. Next it locates the handler function in static tables created by the dispatch map functions, and finally it calls the handler function with the correct window object selected.
________________________________________________________________________
5.2.2. - [Mapping Modes](invcpp5/ch04c.htm)
----------------------------------------------------
 Mapping Modes 

Mapping Modes
=============

Up to now, your drawing units have been display pixels, also known as device coordinates. The EX04A drawing units are pixels because the device context has the default mapping mode, _MM_TEXT_, assigned to it. The statement

pDC->Rectangle(CRect(0, 0, 200, 200));

draws a square of 200-by-200 pixels, with its top-left corner at the top left of the window's client area. (Positive _y_ values increase as you move down the window.) This square would look smaller on a high-resolution display of 1024-by-768 pixels than it would look on a standard VGA display that is 640-by-480 pixels, and it would look tiny if printed on a laser printer with 600-dpi resolution. (Try EX04A's Print Preview feature to see for yourself.)

What if you want the square to be 4-by-4 centimeters (cm), regardless of the display device? Windows provides a number of other mapping modes, or coordinate systems, that can be associated with the device context. Coordinates in the current mapping mode are called logical coordinates. If you assign the _MM_HIMETRIC_ mapping mode, for example, a logical unit is 1/100 millimeter (mm) instead of 1 pixel. In the _MM_HIMETRIC_ mapping mode, the _y_ axis runs in the opposite direction to that in the _MM_TEXT_ mode: _y_ values decrease as you move down. Thus, a 4-by-4-cm square is drawn in logical coordinates this way:

pDC->Rectangle(CRect(0, 0, 4000, -4000));

Looks easy, doesn't it? Well, it isn't, because you can't work only in logical coordinates. Your program is always switching between device coordinates and logical coordinates, and you need to know when to convert between them. This section gives you a few rules that could make your programming life easier. First you need to know what mapping modes Windows gives you.

The _MM_TEXT_ Mapping Mode
---------------------------

At first glance, _MM_TEXT_ appears to be no mapping mode at all, but rather another name for device coordinates. Almost. In _MM_TEXT_, coordinates map to pixels, values of _x_ increase as you move right, and values of _y_ increase as you move down, but you're allowed to change the origin through calls to the _CDC_ functions _SetViewportOrg_ and _SetWindowOrg_. Here's some code that sets the window origin to (100, 100) in logical coordinate space and then draws a 200-by-200-pixel square offset by (100, 100). (An illustration of the output is shown in Figure 4-2.) The logical point (100, 100) maps to the device point (0, 0). A scrolling window uses this kind of transformation.

void CMyView::OnDraw(CDC\* pDC)
{
    pDC->SetMapMode(MM_TEXT);
    pDC->SetWindowOrg(CPoint(100, 100));
    pDC->Rectangle(CRect(100, 100, 300, 300));
}

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F04OG02x.gif)]

**Figure 4-2.** _A square drawn after the origin has been moved to (100, 100)._

The Fixed-Scale Mapping Modes
-----------------------------

One important group of Windows mapping modes provides fixed scaling. You have already seen that, in the _MM_HIMETRIC_ mapping mode, _x_ values increase as you move right and _y_ values decrease as you move down. All fixed mapping modes follow this convention, and you can't change it. The only difference among the fixed mapping modes is the actual scale factor, listed in the table shown here.

**Mapping Mode**

**Logical Unit**

MM_LOENGLISH

0.01 inch

MM_HIENGLISH

0.001 inch

MM_LOMETRIC

0.1 mm

MM_HIMETRIC

0.01 mm

MM_TWIPS

1/1440 inch

The last mapping mode, _MM_TWIPS_, is most often used with printers. One twip unit is 1/20 point. (A point is a type measurement unit. In Windows it equals exactly 1/72 inch.) If the mapping mode is _MM_TWIPS_ and you want, for example, 12-point type, set the character height to 12 × 20, or 240, twips.

The Variable-Scale Mapping Modes
--------------------------------

Windows provides two mapping modes, _MM_ISOTROPIC_ and _MM_ANISOTROPIC_, that allow you to change the scale factor as well as the origin. With these mapping modes, your drawing can change size as the user changes the size of the window. Also, if you invert the scale of one axis, you can "flip" an image about the other axis and you can define your own arbitrary fixed-scale factors.

With the _MM_ISOTROPIC_ mode, a 1:1 aspect ratio is always preserved. In other words, a circle is always a circle as the scale factor changes. With the _MM_ANISOTROPIC_ mode, the _x_ and _y_ scale factors can change independently. Circles can be squished into ellipses.

Here's an _OnDraw_ function that draws an ellipse that fits exactly in its window:

void CMyView::OnDraw(CDC\* pDC)
{
    CRect rectClient;

    GetClientRect(rectClient);
    pDC->SetMapMode(MM_ANISOTROPIC);
    pDC->SetWindowExt(1000, 1000);
    pDC->SetViewportExt(rectClient.right, -rectClient.bottom);
    pDC->SetViewportOrg(rectClient.right / 2, rectClient.bottom / 2);

    pDC->Ellipse(CRect(-500, -500, 500, 500));
}

What's going on here? The functions _SetWindowExt_ and _SetViewportExt_ work together to set the scale, based on the window's current client rectangle returned by the _GetClientRect_ function. The resulting window size is exactly 1000-by-1000 logical units. The _SetViewportOrg_ function sets the origin to the center of the window. Thus, a centered ellipse with a radius of 500 logical units fills the window exactly, as illustrated in Figure 4-3.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F04OG03x.gif)]

**Figure 4-3.** _A centered ellipse drawn in the_ MM_ANISOTROPIC _mapping mode._

Here are the formulas for converting logical units to device units:

> _x_ scale factor = _x_ viewport extent / _x_ window extent  
> _y_ scale factor = _y_ viewport extent / _y_ window extent  
> device _x_ = logical _x_ × _x_ scale factor + _x_ origin offset  
> device _y_ = logical _y_ × _y_ scale factor + _y_ origin offset  

Suppose the window is 448 pixels wide (_rectClient.right_). The right edge of the ellipse's client rectangle is 500 logical units from the origin. The _x_ scale factor is 448/1000, and the _x_ origin offset is 448/2 device units. If you use the formulas shown on the previous page, the right edge of the ellipse's client rectangle comes out to 448 device units, the right edge of the window. The _x_ scale factor is expressed as a ratio (viewport extent/window extent) because Windows device coordinates are integers, not floating-point values. The extent values are meaningless by themselves.

If you substitute _MM_ISOTROPIC_ for _MM_ANISOTROPIC_ in the preceding example, the "ellipse" is always a circle, as shown in Figure 4-4. It expands to fit the smallest dimension of the window rectangle.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F04OG04x.gif)]

**Figure 4-4.** _A centered ellipse drawn in the_ MM_ISOTROPIC _mapping mode._

Coordinate Conversion
---------------------

Once you set the mapping mode (plus the origin) of a device context, you can use logical coordinate parameters for most _CDC_ member functions. If you get the mouse cursor coordinates from a Windows mouse message (the _point_ parameter in _OnLButtonDown_), for example, you're dealing with device coordinates. Many other MFC functions, particularly the member functions of class _CRect_, work correctly only with device coordinates.

> NOTE
> 
> The _CRect_ arithmetic functions use the underlying Win32 _RECT_ arithmetic functions, which assume that _right_ is greater than _left_ and _bottom_ is greater than _top_. A rectangle (0, 0, 1000, -1000) in _MM_HIMETRIC_ coordinates, for example, has _bottom_ less than _top_ and cannot be processed by functions such as _CRect::PtInRect_ unless your program first calls _CRect::NormalizeRect_, which changes the rectangle's data members to (0, -1000, 1000, 0).

Furthermore, you're likely to need a third set of coordinates that we will call physical coordinates. Why do you need another set? Suppose you're using the _MM_LOENGLISH_ mapping mode in which a logical unit is 0.01 inch, but an inch on the screen represents a foot (12 inches) in the real world. Now suppose the user works in inches and decimal fractions. A measurement of 26.75 inches translates to 223 logical units, which must be ultimately translated to device coordinates. You will want to store the physical coordinates as either floating-point numbers or scaled long integers to avoid rounding-off errors.

For the physical-to-logical translation you're on your own, but the Windows GDI takes care of the logical-to-device translation for you. The _CDC_ functions _LPtoDP_ and _DPtoLP_ translate between the two systems, assuming the device context mapping mode and associated parameters have already been set. Your job is to decide when to use each system. Here are a few rules of thumb:

*   Assume that the _CDC_ member functions take logical coordinate parameters.
    
*   Assume that the _CWnd_ member functions take device coordinate parameters.
    
*   Do all hit-test operations in device coordinates. Define regions in device coordinates. Functions such as _CRect::PtInRect_ work best with device coordinates.
    
*   Store long-term values in logical or physical coordinates. If you store a point in device coordinates and the user scrolls through a window, that point is no longer valid.
    

Suppose you need to know whether the mouse cursor is inside a rectangle when the user presses the left mouse button. The code is shown here.

// m_rect is CRect data member of the derived view class with MM_LOENGLISH
//  logical coordinates

void CMyView::OnLButtonDown(UINT nFlags, CPoint point)
{
    CRect rect = m_rect; // rect is a temporary copy of m_rect.
    CClientDC dc(this);  // This is how we get a device context
                         //  for SetMapMode and LPtoDP
                         //  -- more in next chapter
    dc.SetMapMode(MM_LOENGLISH);
    dc.LPtoDP(rect);     // rect is now in device coordinates
    if (rect.PtInRect(point)) {
        TRACE("Mouse cursor is inside the rectangle.\n");
    }
}

Notice the use of the _TRACE_ macro (covered in [Chapter 3](ch03a.htm)).

> NOTE
> 
> As you'll soon see, it's better to set the mapping mode in the virtual _CView_ function _OnPrepareDC_ instead of in the _OnDraw_ function.

The EX04B Example—Converting to the _MM_HIMETRIC_ Mapping Mode
---------------------------------------------------------------

EX04B is EX04A converted to _MM_HIMETRIC_ coordinates. The EX04B project on the companion CD-ROM uses new class names and filenames, but the instructions here take you through modifying the EX04A code. Like EX04A, EX04B performs a hit-test so that the ellipse changes color only when you click inside the bounding rectangle.

2.  **Use ClassWizard to override the virtual _OnPrepareDC_ function.** ClassWizard can override virtual functions for selected MFC base classes, including _CView_. It generates the correct function prototype in the class's header file and a skeleton function in the CPP file. Select the class name _CEx04aView_ in the Object IDs list, and then double-click on the _OnPrepareDC_ function in the Messages list. Edit the function as shown here:
    
    void CEx04aView::OnPrepareDC(CDC\* pDC, CPrintInfo\* pInfo) 
    {
        **pDC->SetMapMode(MM_HIMETRIC);**
        CView::OnPrepareDC(pDC, pInfo);
    }
    
    The application framework calls the virtual _OnPrepareDC_ function just before it calls _OnDraw_.
    
3.  **Edit the view class constructor.** You must change the coordinate values for the ellipse rectangle. That rectangle is now 4-by-4 centimeters instead of 200-by-200 pixels. Note that the _y_ value must be negative; otherwise, the ellipse will be drawn on the "virtual screen" right above your monitor! Change the values as shown here:
    
    CEx04aView::CEx04aView() : m_rectEllipse(0, 0, **4000, -4000**)
    {
        m_nColor = GRAY_BRUSH;
    }
    
4.  **Edit the _OnLButtonDown_ function.** This function must now convert the ellipse rectangle to device coordinates in order to do the hit-test. Change the function as shown in the following code:
    
    void CEx04aView::OnLButtonDown(UINT nFlags, CPoint point) 
    {
        **CClientDC dc(this);
        OnPrepareDC(&dc);
        CRect rectDevice = m_rectEllipse;
        dc.LPtoDP(rectDevice);**
        if (**rectDevice**.PtInRect(point)) {
            if (m_nColor == GRAY_BRUSH) {
                m_nColor = WHITE_BRUSH;
            }
            else {
                m_nColor = GRAY_BRUSH;
            }
            InvalidateRect(**rectDevice**);
        }
    }
    
5.  **Build and run the EX04B program.** The output should look similar to the output from EX04A, except that the ellipse size will be different. If you try using Print Preview again, the ellipse should appear much larger than it did in EX04A.
________________________________________________________________________
5.2.3. - [A Scrolling View Window](invcpp5/ch04d.htm)
----------------------------------------------------
 A Scrolling View Window 

A Scrolling View Window
=======================

As the lack of scroll bars in EX04A and EX04B indicates, the MFC _CView_ class, the base class of _CEx04bView_, doesn't directly support scrolling. Another MFC library class, _CScrollView_, does support scrolling. _CScrollView_ is derived from _CView_. We'll create a new program, EX04C, that uses _CScrollView_ in place of _CView_. All the coordinate conversion code you added in EX04B sets you up for scrolling.

The _CScrollView_ class supports scrolling from the scroll bars but not from the keyboard. It's easy enough to add keyboard scrolling, so we'll do it.

A Window Is Larger than What You See
------------------------------------

If you use the mouse to shrink the size of an ordinary window, the contents of the window remain anchored at the top left of the window, and items at the bottom and/or on the right of the window disappear. When you expand the window, the items reappear. You can correctly conclude that a window is larger than the viewport that you see on the screen. The viewport doesn't have to be anchored at the top left of the window area, however. Through the use of the _CWnd_ functions _ScrollWindow_ and _SetWindowOrg_, the _CScrollView_ class allows you to move the viewport anywhere within the window, including areas above and to the left of the origin.

Scroll Bars
-----------

Microsoft Windows makes it easy to display scroll bars at the edges of a window, but Windows by itself doesn't make any attempt to connect those scroll bars to their window. That's where the _CScrollView_ class fits in. _CScrollView_ member functions process the WM_HSCROLL and WM_VSCROLL messages sent by the scroll bars to the view. Those functions move the viewport within the window and do all the necessary housekeeping.

Scrolling Alternatives
----------------------

The _CScrollView_ class supports a particular kind of scrolling that involves one big window and a small viewport. Each item is assigned a unique position in this big window. If, for example, you have 10,000 address lines to display, instead of having a window 10,000 lines long, you probably want a smaller window with scrolling logic that selects only as many lines as the screen can display. In that case, you should write your own scrolling view class derived from _CView_.

> NOTE
> 
> Microsoft Windows NT uses 32-bit numbers for logical coordinates, so your logical coordinate space is almost unlimited. Microsoft Windows 95, however, still has some 16-bit components, so it uses 16-bit numbers for logical coordinates, limiting values to the range -32,768 to 32,767. Scroll bars send messages with 16-bit values in both operating systems. With these facts in mind, you probably want to write code to the lowest common denominator, which is Windows 95.

The _OnInitialUpdate_ Function
------------------------------

You'll be seeing more of the _OnInitialUpdate_ function when you study the document-view architecture, starting in [Chapter 16](ch16a.htm). The virtual _OnInitial-Update_ function is important here because it is the first function called by the framework after your view window is fully created. The framework calls _OnInitialUpdate_ before it calls _OnDraw_ for the first time, so _OnInitialUpdate_ is the natural place for setting the logical size and mapping mode for a scrolling view. You set these parameters with a call to the _CScrollView::SetScrollSizes_ function.

Accepting Keyboard Input
------------------------

Keyboard input is really a two-step process. Windows sends WM_KEYDOWN and WM_KEYUP messages, with virtual key codes, to a window, but before they get to the window they are translated. If an ANSI character is typed (resulting in a WM_KEYDOWN message), the translation function checks the keyboard shift status and then sends a WM_CHAR message with the proper code, either uppercase or lowercase. Cursor keys and function keys don't have codes, so there's no translation to do. The window gets only the WM_KEYDOWN and WM_KEYUP messages.

You can use ClassWizard to map all these messages to your view. If you're expecting characters, map WM_CHAR; if you're expecting other keystrokes, map WM_KEYDOWN. The MFC library neatly supplies the character code or virtual key code as a handler function parameter.

The EX04C Example—Scrolling
---------------------------

The goal of EX04C is to make a logical window 20 centimeters wide by 30 centimeters high. The program draws the same ellipse that it drew in the EX04B project. You could edit the EX04B source files to convert the _CView_ base class to a _CScrollView_ base class, but it's easier to start over with AppWizard. AppWizard generates the _OnInitialUpdate_ override function for you. Here are the steps:

2.  **Run AppWizard to create EX04C.**Use AppWizard to generate a program named EX04C in the \vcpp32\ex04c subdirectory. In AppWizard Step 6, set the _CEx04cView_ base class to _CScrollView_, as shown here.
    

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G04OG04x.gif)]

3.  **Add the _m___rectEllipse_ and _m_nColor_ data members in ex04cView.h.** Insert the following code by right-clicking the _CEx04cView_ class in the Workspace window or by typing inside the _CEx04cView_ class declaration:
    
    **private:
        CRect m_rectEllipse;
        int m_nColor;**
    
    These are the same data members that were added in the EX04A and EX04B projects.
    
4.  **Modify the AppWizard-generated _OnInitialUpdate_ function.** Edit _OnInitialUpdate_ in ex04cView.cpp as shown here:
    
    void CEx04cView::OnInitialUpdate()
    {
        CScrollView::OnInitialUpdate();
        **CSize sizeTotal(20000, 30000); // 20 by 30 cm
        CSize sizePage(sizeTotal.cx / 2, sizeTotal.cy / 2);
        CSize sizeLine(sizeTotal.cx / 50, sizeTotal.cy / 50);**
       ** SetScrollSizes(MM_HIMETRIC, sizeTotal, sizePage, sizeLine);**
    }
    
5.  **Use ClassWizard to add a message handler for the WM_KEYDOWN message.** ClassWizard generates the member function _OnKeyDown_ along with the necessary message map entries and prototypes. Edit the code as follows:
    
    void CEx04cView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
    {
        **switch (nChar) {
        case VK_HOME:
            OnVScroll(SB_TOP, 0, NULL);
            OnHScroll(SB_LEFT, 0, NULL);
            break;
        case VK_END:
            OnVScroll(SB_BOTTOM, 0, NULL);
            OnHScroll(SB_RIGHT, 0, NULL);
            break;
        case VK_UP:
            OnVScroll(SB_LINEUP, 0, NULL);
            break;
        case VK_DOWN:
            OnVScroll(SB_LINEDOWN, 0, NULL);
            break;
        case VK_PRIOR:
            OnVScroll(SB_PAGEUP, 0, NULL);
            break;
        case VK_NEXT:
            OnVScroll(SB_PAGEDOWN, 0, NULL);
            break;
        case VK_LEFT:
            OnHScroll(SB_LINELEFT, 0, NULL);
            break;
        case VK_RIGHT:
            OnHScroll(SB_LINERIGHT, 0, NULL);
            break;
        default:
            break;**
       ** }**
    }
    
6.  **Edit the constructor and the _OnDraw_ function.** Change the AppWizard-generated constructor and the _OnDraw_ function in ex04cView.cpp as follows:
    
    CEx04cView::CEx04cView() **: m_rectEllipse(0, 0, 4000, -4000)**
    {
        **m_nColor = GRAY_BRUSH;**
    }
    .
    .
    .
    void CEx04cView::OnDraw(CDC\* pDC)
    {
        **pDC->SelectStockObject(
    m_nColor);
        pDC->Ellipse(m_rectEllipse);
    }**
    
    These functions are identical to those used in the EX04A and EX04B projects.
    
7.  **Map the WM_LBUTTONDOWN message and edit the handler.** Make the following changes to the ClassWizard-generated code:
    
    void CEx04cView::OnLButtonDown(UINT nFlags, CPoint point) 
    {
        **CClientDC dc(this);
        OnPrepareDC(&dc);
        CRect rectDevice = m_rectEllipse;
        dc.LPtoDP(rectDevice);
        if (rectDevice.PtInRect(point)) {
            if (m_nColor == GRAY_BRUSH) {
                m_nColor = WHITE_BRUSH;
            }
            else {
                m_nColor = GRAY_BRUSH;
            }
            InvalidateRect(rectDevice);
        }**
    }
    
    This function is identical to the _OnLButtonDown_ handler in the EX04B project. It calls _OnPrepareDC_ as before, but there is something different. The _CEx04bView_ class doesn't have an overridden _OnPrepareDC_ function, so the call goes to _CScrollView::OnPrepareDC_. That function sets the mapping mode based on the first parameter to _SetScrollSizes_, and it sets the window origin based on the current scroll position. Even if your scroll view used the _MM_TEXT_ mapping mode, you'd still need the coordinate conversion logic to adjust for the origin offset.
    
8.  **Build and run the EX04C program.** Check to be sure the mouse hit logic is working even if the circle is scrolled partially out of the window. Also check the keyboard logic. The output should look like this.

![](c:/dl/books/windows/msvc5th/invcpp5/images/G04OG05x.gif)
________________________________________________________________________
5.2.4. - [Other Windows Messages](invcpp5/ch04e.htm)
----------------------------------------------------
 Other Windows Messages 

Other Windows Messages
======================

The MFC library directly supports hundreds of Windows message-handling functions. In addition, you can define your own messages. You will see plenty of message-handling examples in later chapters, including handlers for menu items, child window controls, and so forth. In the meantime, five special Windows messages deserve special attention: WM_CREATE, WM_CLOSE, WM_QUERYENDSESSION, WM_DESTROY, and WM_NCDESTROY.

The WM_CREATE Message
----------------------

This is the first message that Windows sends to a view. It is sent when the window's _Create_ function is called by the framework, so the window creation is not finished and the window is not visible. Therefore, your _OnCreate_ handler cannot call Windows functions that depend on the window being completely alive. You can call such functions in an overridden _OnInitialUpdate_ function, but you must be aware that in an SDI application _OnInitialUpdate_ can be called more than once in a view's lifetime.

The WM_CLOSE Message
---------------------

Windows sends the WM_CLOSE message when the user closes a window from the system menu and when a parent window is closed. If you implement the _OnClose_ message map function in your derived view class, you can control the closing process. If, for example, you need to prompt the user to save changes to a file, you do it in _OnClose_. Only when you have determined that it is safe to close the window do you call the base class _OnClose_ function, which continues the close process. The view object and the corresponding window are both still active.

> TIPS
> 
> When you're using the full application framework, you probably won't use the WM_CLOSE message handler. You can override the _CDocument::SaveModified_ virtual function instead, as part of the application framework's highly structured program exit procedure.

The WM_QUERYENDSESSION Message
-------------------------------

Windows sends the WM_QUERYENDSESSION message to all running applications when the user exits Windows. The _OnQueryEndSession_ message map function handles it. If you write a handler for WM_CLOSE, write one for WM_QUERYENDSESSION too.

The WM_DESTROY Message
-----------------------

Windows sends this message after the WM_CLOSE message, and the _OnDestroy_ message map function handles it. When your program receives this message, it should assume that the view window is no longer visible on the screen but that it is still active and its child windows are still active. Use this message handler to do cleanup that depends on the existence of the underlying window. Be sure to call the base class _OnDestroy_ function. You cannot "abort" the window destruction process in your view's _OnDestroy_ function. _OnClose_ is the place to do that.

The WM_NCDESTROY Message
-------------------------

This is the last message that Windows sends when the window is being destroyed. All child windows have already been destroyed. You can do final processing in _OnNcDestroy_ that doesn't depend on a window being active. Be sure to call the base class _OnNcDestroy_ function.

> TIPS
> 
> Do not try to destroy a dynamically allocated window object in _OnNcDestroy_. That job is reserved for a special _CWnd_ virtual function, _PostNcDestroy_, that the base class _OnNcDestroy_ calls. MFC Technical Note #17 in the online documentation gives hints on when it's appropriate to destroy a window object.
________________________________________________________________________
5.3. - [Chapter 5 -- The Graphics Device Interface, Colors, and Fonts](invcpp5/ch05a.htm)
----------------------------------------------------
 Chapter 5 -- The Graphics Device Interface, Colors, and Fonts  Chapter 5

The Graphics Device Interface, Colors, and Fonts
================================================

You've already seen some elements of the Graphics Device Interface (GDI). Anytime your program draws to the display or the printer, it must use the GDI functions. The GDI provides functions for drawing points, lines, rectangles, polygons, ellipses, bitmaps, and text. You can draw circles and squares intuitively once you study the available functions, but text programming is more difficult.This chapter gives you the information you need to start using the GDI effectively in the Microsoft Visual C++ environment. You'll learn how to use fonts on both the display and the printer. You must wait until [Chapter 19](ch19a.htm), however, for details on how the framework controls the printer.
________________________________________________________________________
5.3.1. - [The Device Context Classes](invcpp5/ch05b.htm)
----------------------------------------------------
 The Device Context Classes 

The Device Context Classes
==========================

In [Chapter 3](ch03a.htm) and [Chapter 4](ch04a.htm), the view class's _OnDraw_ member function was passed a pointer to a device context object. _OnDraw_ selected a brush and then drew an ellipse. The Microsoft Windows device context is the key GDI element that represents a physical device. Each C++ device context object has an associated Windows device context, identified by a 32-bit handle of type HDC.

Microsoft Foundation Class (MFC) Library version 6.0 provides a number of device context classes. The base class _CDC_ has all the member functions (including some virtual functions) that you'll need for drawing. Except for the oddball _CMetaFileDC_ class, derived classes are distinct only in their constructors and destructors. If you (or the application framework) construct an object of a derived device context class, you can pass a _CDC_ pointer to a function such as _OnDraw_. For the display, the usual derived classes are _CClientDC_ and _CWindowDC_. For other devices, such as printers or memory buffers, you construct objects of the base class _CDC_.

The "virtualness" of the _CDC_ class is an important feature of the application framework. In [Chapter 19](ch19a.htm), you'll see how easy it is to write code that works with both the printer and the display. A statement in _OnDraw_ such as

pDC->TextOut(0, 0, "Hello");

sends text to the display, the printer, or the Print Preview window, depending on the class of the object referenced by the _CView::OnDraw_ function's _pDC_ parameter.

For display and printer device context objects, the application framework attaches the handle to the object. For other device contexts, such as the memory device context that you'll see in [Chapter 11](ch11a.htm), you must call a member function after construction in order to attach the handle.

The Display Context Classes _CClientDC_ and _CWindowDC_
-------------------------------------------------------

Recall that a window's client area excludes the border, the caption bar, and the menu bar. If you create a _CClientDC_ object, you have a device context that is mapped only to this client area—you can't draw outside it. The point (0, 0) usually refers to the upper-left corner of the client area. As you'll see later, an MFC _CView_ object corresponds to a child window that is contained inside a separate frame window, often along with a toolbar, a status bar, and scroll bars. The client area of the view, then, does not include these other windows. If the window contains a docked toolbar along the top, for example, (0, 0) refers to the point immediately under the left edge of the toolbar.

If you construct an object of class _CWindowDC_, the point (0, 0) is at the upper-left corner of the nonclient area of the window. With this whole-window device context, you can draw in the window's border, in the caption area, and so forth. Don't forget that the view window doesn't have a nonclient area, so _CWindowDC_ is more applicable to frame windows than it is to view windows.

Constructing and Destroying _CDC_ Objects
-----------------------------------------

After you construct a _CDC_ object, it is important to destroy it promptly when you're done with it. Microsoft Windows limits the number of available device contexts, and if you fail to release a Windows device context object, a small amount of memory is lost until your program exits. Most frequently, you'll construct a device context object inside a message handler function such as _OnLButtonDown_. The easiest way to ensure that the device context object is destroyed (and that the underlying Windows device context is released) is to construct the object on the stack in the following way:

void CMyView::OnLButtonDown(UINT nFlags, CPoint point)
{
    CRect rect;

    CClientDC dc(this);  // constructs dc on the stack
    dc.GetClipBox(rect); // retrieves the clipping rectangle
} // dc automatically released

Notice that the _CClientDC_ constructor takes a window pointer as a parameter. The destructor for the _CClientDC_ object is called when the function returns. You can also get a device context pointer by using the _CWnd::GetDC_ member function, as shown in the following code. You must be careful here to call the _ReleaseDC_ function to release the device context.

void CMyView::OnLButtonDown(UINT nFlags, CPoint point)
{
    CRect rect;

    CDC\* pDC = GetDC();    // a pointer to an internal dc
    pDC->GetClipBox(rect); // retrieves the clipping rectangle
    ReleaseDC(pDC);        // Don't forget this
}

> WARNING
> 
> You must not destroy the _CDC_ object passed by the pointer to _OnDraw_. The application framework handles the destruction for you.

The State of the Device Context
-------------------------------

You already know that a device context is required for drawing. When you use a _CDC_ object to draw an ellipse, for example, what you see on the screen (or on the printer's hard copy) depends on the current "state" of the device context. This state includes the following:

*   Attached GDI drawing objects such as pens, brushes, and fonts
    
*   The mapping mode that determines the scale of items when they are drawn (You've already experimented with the mapping mode in [Chapter 4](ch04a.htm).)
    
*   Various details such as text alignment parameters and polygon filling mode
    

You have already seen, for example, that choosing a gray brush prior to drawing an ellipse results in the ellipse having a gray interior. When you create a device context object, it has certain default characteristics, such as a black pen for shape boundaries. All other state characteristics are assigned through _CDC_ class member functions. GDI objects are selected into the device context by means of the overloaded _SelectObject_ functions. A device context can, for example, have one pen, one brush, or one font selected at any given time.

The _CPaintDC_ Class
--------------------

You'll need the _CPaintDC_ class only if you override your view's _OnPaint_ function. The default _OnPaint_ calls _OnDraw_ with a properly set up device context, but sometimes you'll need display-specific drawing code. The _CPaintDC_ class is special because its constructor and destructor do housekeeping unique to drawing to the display. Once you have a _CDC_ pointer, however, you can use it as you would any other device context pointer.

Here's a sample _OnPaint_ function that creates a _CPaintDC_ object:

void CMyView::OnPaint()
{
    CPaintDC dc(this);
    OnPrepareDC(&dc); // explained later
    dc.TextOut(0, 0, "for the display, not the printer");
    OnDraw(&dc);      // stuff that's common to display and printer
}

> **For Win32 Programmers**
> 
> The _CPaintDC_ constructor calls _BeginPaint_ for you, and the destructor calls _EndPaint_. If you construct your device context on the stack, the _EndPaint_ call is completely automatic.
________________________________________________________________________
5.3.2. - [GDI Objects](invcpp5/ch05c.htm)
----------------------------------------------------
 GDI Objects 

GDI Objects
===========

A Windows GDI object type is represented by an MFC library class. _CGdiObject_ is the abstract base class for the GDI object classes. A Windows GDI object is represented by a C++ object of a class derived from _CGdiObject_. Here's a list of the GDI derived classes:

*   **_CBitmap_**—A bitmap is an array of bits in which one or more bits correspond to each display pixel. You can use bitmaps to represent images, and you can use them to create brushes.
    
*   **_CBrush_**—A brush defines a bitmapped pattern of pixels that is used to fill areas with color.
    
*   **_CFont_**—A font is a complete collection of characters of a particular typeface and a particular size. Fonts are generally stored on disk as resources, and some are device-specific.
    
*   **_CPalette_**—A palette is a color mapping interface that allows an application to take full advantage of the color capability of an output device without interfering with other applications.
    
*   **_CPen_**—A pen is a tool for drawing lines and shape borders. You can specify a pen's color and thickness and whether it draws solid, dotted, or dashed lines.
    
*   **_CRgn_**—A region is an area whose shape is a polygon, an ellipse, or a combination of polygons and ellipses. You can use regions for filling, clipping, and mouse hit-testing.
    

Constructing and Destroying GDI Objects
---------------------------------------

You never construct an object of class _CGdiObject_; instead, you construct objects of the derived classes. Constructors for some GDI derived classes, such as _CPen_ and _CBrush_, allow you to specify enough information to create the object in one step. Others, such as _CFont_ and _CRgn_, require a second creation step. For these classes, you construct the C++ object with the default constructor and then you call a create function such as the _CreateFont_ or _CreatePolygonRgn_ function.

The _CGdiObject_ class has a virtual destructor. The derived class destructors delete the Windows GDI objects that are attached to the C++ objects. If you construct an object of a class derived from _CGdiObject_, you must delete it prior to exiting the program. To delete a GDI object, you must first separate it from the device context. You'll see an example of this in the next section.

> NOTE
> 
> Failure to delete a GDI object was a serious offense with Win16. GDI memory was not released until the user restarted Windows. With Win32, however, the GDI memory is owned by the process and is released when your program terminates. Still, an unreleased GDI bitmap object can waste a significant amount of memory.

Tracking GDI Objects
--------------------

OK, so you know that you have to delete your GDI objects and that they must first be disconnected from their device contexts. How do you disconnect them? A member of the _CDC::SelectObject_ family of functions does the work of selecting a GDI object into the device context, and in the process it returns a pointer to the previously selected object (which gets deselected in the process). Trouble is, you can't deselect the old object without selecting a new object. One easy way to track the objects is to "save" the original GDI object when you select your own GDI object and "restore" the original object when you're finished. Then you'll be ready to delete your own GDI object. Here's an example:

void CMyView::OnDraw(CDC\* pDC)
{
    CPen newPen(PS_DASHDOTDOT, 2, (COLORREF) 0);  // black pen,
                                                  //  2 pixels wide
    CPen\* pOldPen = pDC->SelectObject(&newPen);

    pDC->MoveTo(10, 10);
    pDC->Lineto(110, 10);
    pDC->SelectObject(pOldPen);                   // newPen is deselected
} // newPen automatically destroyed on exit

When a device context object is destroyed, all its GDI objects are deselected. Thus, if you know that a device context will be destroyed before its selected GDI objects are destroyed, you don't have to deselect the objects. If, for example, you declare a pen as a view class data member (and you initialize it when you initialize the view), you don't have to deselect the pen inside _OnDraw_ because the device context, controlled by the view base class's _OnPaint_ handler, will be destroyed first.

Stock GDI Objects
-----------------

Windows contains a number of stock GDI objects that you can use. Because these objects are part of Windows, you don't have to worry about deleting them. (Windows ignores requests to delete stock objects.) The MFC library function _CDC::SelectStockObject_ selects a stock object into the device context and returns a pointer to the previously selected object, which it deselects. Stock objects are handy when you want to deselect your own nonstock GDI object prior to its destruction. You can use a stock object as an alternative to the "old" object you used in the previous example, as shown here:

void CMyView::OnDraw(CDC\* pDC)
{
    CPen newPen(PS_DASHDOTDOT, 2, (COLORREF) 0);  // black pen,
                                                  //  2 pixels wide

    pDC->SelectObject(&newPen);
    pDC->MoveTo(10, 10);
    pDC->Lineto(110, 10);
    pDC->SelectStockObject(BLACK_PEN);            // newPen is deselected
} // newPen destroyed on exit

The Microsoft Foundation Class Reference lists, under _CDC::SelectStockObject_, the stock objects available for pens, brushes, fonts, and palettes.

The Lifetime of a GDI Selection
-------------------------------

For the display device context, you get a "fresh" device context at the beginning of each message handler function. No GDI selections (or mapping modes or other device context settings) persist after your function exits. You must, therefore, set up your device context from scratch each time. The _CView_ class virtual member function _OnPrepareDC_ is useful for setting the mapping mode, but you must manage your own GDI objects.

For other device contexts, such as those for printers and memory buffers, your assignments can last longer. For these long-life device contexts, things get a little more complicated. The complexity results from the temporary nature of GDI C++ object pointers returned by the _SelectObject_ function. (The temporary "object" will be destroyed by the application framework during the idle loop processing of the application, sometime after the handler function returns the call. See MFC Technical Note #3 in the online documentation.) You can't simply store the pointer in a class data member; instead, you must convert it to a Windows handle (the only permanent GDI identifier) with the _GetSafeHdc_ member function. Here's an example:

// m_pPrintFont points to a CFont object created in CMyView's constructor
// m_hOldFont is a CMyView data member of type HFONT, initialized to 0

void CMyView::SwitchToCourier(CDC\* pDC)
{
    m_pPrintFont->CreateFont(30, 10, 0, 0, 400, FALSE, FALSE,
                             0, ANSI_CHARSET, OUT_DEFAULT_PRECIS,
                             CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                             DEFAULT_PITCH | FF_MODERN, 
                             "Courier New"); // TrueType
    CFont\* pOldFont = pDC->SelectObject(m_pPrintFont);

    // m_hOldFont is the CGdiObject public data member that stores
    //  the handle
    m_hOldFont = (HFONT) pOldFont->GetSafeHandle();
}

void CMyView:SwitchToOriginalFont(CDC\* pDC)
{
    // FromHandle is a static member function that returns an
    //  object pointer
    if (m_hOldFont) {
        pDC->SelectObject(CFont::FromHandle(m_hOldFont));
    }
}

// m_pPrintFont is deleted in the CMyView destructor

> NOTE
> 
> Be careful when you delete an object whose pointer is returned by _SelectObject_. If you've allocated the object yourself, you can delete it. If the pointer is temporary, as it will be for the object initially selected into the device context, you won't be able to delete the C++ object.
________________________________________________________________________
5.3.3. - [Windows Color Mapping](invcpp5/ch05d.htm)
----------------------------------------------------
 Windows Color Mapping 

Windows Color Mapping
=====================

The Windows GDI provides a hardware-independent color interface. Your program supplies an "absolute" color code, and the GDI maps that code to a suitable color or color combination on your computer's video display. Most programmers of applications for Windows try to optimize their applications' color display for a few common video card categories.

Standard Video Graphics Array Video Cards
-----------------------------------------

A standard Video Graphics Array (VGA) video card uses 18-bit color registers and thus has a palette of 262,144 colors. Because of video memory constraints, however, the standard VGA board accommodates 4-bit color codes, which means it can display only 16 colors at a time. Because Windows needs fixed colors for captions, borders, scroll bars, and so forth, your programs can use only 16 "standard" pure colors. You cannot conveniently access the other colors that the board can display.

Each Windows color is represented by a combination of 8-bit "red," "green," and "blue" values. The 16 standard VGA "pure" (nondithered) colors are shown in the table below.

Color-oriented GDI functions accept 32-bit _COLORREF_ parameters that contain 8-bit color codes each for red, green, and blue. The Windows RGB macro converts 8-bit red, green, and blue values to a _COLORREF_ parameter. The following statement, when executed on a system with a standard VGA board, constructs a brush with a dithered color (one that consists of a pattern of pure-color pixels):

CBrush brush(RGB(128, 128, 192));

| **Red** | **Green** | **Blue** |  **Color**   |
|---------|-----------|----------|--------------|
|       0 |         0 |        0 | Black        |
|       0 |         0 |      255 | Blue         |
|       0 |       255 |        0 | Green        |
|       0 |       255 |      255 | Cyan         |
|     255 |         0 |        0 | Red          |
|     255 |         0 |      255 | Magenta      |
|     255 |       255 |        0 | Yellow       |
|     255 |       255 |      255 | White        |
|       0 |         0 |      128 | Dark blue    |
|       0 |       128 |        0 | Dark green   |
|       0 |       128 |      128 | Dark cyan    |
|     128 |         0 |        0 | Dark red     |
|     128 |         0 |      128 | Dark magenta |
|     128 |       128 |        0 | Dark yellow  |
|     128 |       128 |      128 | Dark gray    |
|     192 |       192 |      192 | Light gray   |

The following statement (in your view's _OnDraw_ function) sets the text background to red:

pDC->SetBkColor(RGB(255, 0, 0));

The _CDC_ functions _SetBkColor_ and _SetTextColor_ don't display dithered colors as the brush-oriented drawing functions do. If the dithered color pattern is too complex, the closest matching pure color is displayed.

256-Color Video Cards
---------------------

Most video cards can accommodate 8-bit color codes at all resolutions, which means they can display 256 colors simultaneously. This 256-color mode is now considered to be the "lowest common denominator" for color programming.

If Windows is configured for a 256-color display card, your programs are limited to 20 standard pure colors unless you activate the Windows color palette system as supported by the MFC library _CPalette_ class and the Windows API, in which case you can choose your 256 colors from a total of more than 16.7 million. Windows color palette programming is discussed in [Chapter 11](ch11a.htm). In this chapter, we'll assume that the Windows default color mapping is in effect.

With an SVGA 256-color display driver installed, you get the 16 VGA colors listed in the previous table plus 4 more, for a total of 20. The following table lists the 4 additional colors.

| **Red** | **Green** | **Blue** | **Color** |
|---------|-----------|----------|-----------|
| 192 |220 |192 |Money green
| 166 |202 |240 |Sky blue
| 255 |251 |240 |Cream
| 160 |160 |164 |Medium gray

The RGB macro works much the same as it does with the standard VGA. If you specify one of the 20 standard colors for a brush, you get a pure color; otherwise, you get a dithered color. If you use the _PALETTERGB_ macro instead, you don't get dithered colors; you get the closest matching standard pure color as defined by the current palette.

16-Bit-Color Video Cards
------------------------

Most modern video cards support a resolution of 1024-by-768 pixels, and 1 MB of video memory can support 8-bit color at this resolution. If a video card has 2 MB of memory, it can support 16-bit color, with 5 bits each for red, green, and blue. This means that it can display 32,768 colors simultaneously. That sounds like a lot, but there are only 32 shades each of pure red, green, and blue. Often, a picture will look better in 8-bit-color mode with an appropriate palette selected. A forest scene, for example, can use up to 236 shades of green. Palettes are not supported in 16-bit-color mode.

24-Bit-Color Video Cards
------------------------

High-end cards (which are becoming more widely used) support 24-bit color. This 24-bit capability enables the display of more than 16.7 million pure colors. If you're using a 24-bit card, you have direct access to all the colors. The RGB macro allows you to specify the exact colors you want. You'll need 2.5 MB of video memory, though, if you want 24-bit color at 1024-by-768-pixel resolution.
________________________________________________________________________
5.3.4. - [Fonts](invcpp5/ch05e.htm)
----------------------------------------------------
 Fonts 

Fonts
=====

Old-fashioned character-mode applications could display only the boring system font on the screen. Windows provides multiple device-independent fonts in variable sizes. The effective use of these Windows fonts can significantly energize an application with minimum programming effort. TrueType fonts, first introduced with Windows version 3.1, are even more effective and are easier to program than the previous device-dependent fonts. You'll see several example programs that use various fonts later in this chapter.

Fonts Are GDI Objects
---------------------

Fonts are an integral part of the Windows GDI. This means that fonts behave the same way other GDI objects do. They can be scaled and clipped, and they can be selected into a device context as a pen or a brush can be selected. All GDI rules about deselection and deletion apply to fonts.

Choosing a Font
---------------

Choosing a Windows font used to be like going to a fruit stand and asking for "a piece of reddish-yellow fruit, with a stone inside, that weighs about 4 ounces." You might have gotten a peach or a plum or even a nectarine, and you could be sure that it wouldn't have weighed exactly 4 ounces. Once you took possession of the fruit, you could weigh it and check the fruit type. Now, with TrueType, you can specify the fruit type, but you still can't specify the exact weight.

Today you can choose between two font types—device-independent TrueType fonts and device-dependent fonts such as the Windows display System font and the LaserJet LinePrinter font—or you can specify a font category and size and let Windows select the font for you. If you let Windows select the font, it will choose a TrueType font if possible. The MFC library provides a font selection dialog box tied to the currently selected printer, so there's little need for printer font guesswork. You let the user select the exact font and size for the printer, and then you approximate the display the best you can.

Printing with Fonts
-------------------

For text-intensive applications, you'll probably want to specify printer font sizes in points (1 point = 1/72 inch). Why? Most, if not all, built-in printer fonts are defined in terms of points. The LaserJet LinePrinter font, for example, comes in one size, 8.5 point. You can specify TrueType fonts in any point size. If you work in points, you need a mapping mode that easily accommodates points. That's what _MM_TWIPS_ is for. An 8.5-point font is 8.5 × 20, or 170, twips, and that's the character height you'll want to specify.

Displaying Fonts
----------------

If you're not worried about the display matching the printed output, you have a lot of flexibility. You can choose any of the scalable Windows TrueType fonts, or you can choose the fixed-size system fonts (stock objects). With the TrueType fonts, it doesn't much matter what mapping mode you use; simply choose a font height and go for it. No need to worry about points.

Matching printer fonts to make printed output match the screen presents some problems, but TrueType makes it easier than it used to be. Even if you're printing with TrueType fonts, however, you'll never quite get the display to match the printer output. Why? Characters are ultimately displayed in pixels (or dots), and the width of a string of characters is equal to the sum of the pixel widths of its characters, possibly adjusted for kerning. The pixel width of the characters depends on the font, the mapping mode, and the resolution of the output device. Only if both the printer and the display were set to _MM_TEXT_ mode (1 pixel or dot = 1 logical unit) would you get an exact correspondence. If you're using the _CDC::GetTextExtent_ function to calculate line breaks, the screen breakpoint will occasionally be different from the printer breakpoint.

> NOTE
> 
> In the MFC Print Preview mode, which we'll examine closely in [Chapter 19](ch19a.htm), line breaks occur exactly as they do on the printer, but the print quality in the preview window suffers in the process.

If you're matching a printer-specific font on the screen, TrueType again makes the job easier. Windows substitutes the closest matching TrueType font. For the 8.5-point LinePrinter font, Windows comes pretty close with its Courier New font.

Logical Inches and Physical Inches on the Display
-------------------------------------------------

The _CDC_ member function _GetDeviceCaps_ returns various display measurements that are important to your graphics programming. The six described below provide information about the display size. The values listed are for a typical display card configured for a resolution of 640-by-480 pixels with Microsoft Windows NT 4.0.

| **Index** | **Description** | **Value** |
|-----------|-----------------|-----------|
| _HORZSIZE_ | Physical width in millimeters | 320
| _VERTSIZE_ | Physical height in millimeters | 240
| _HORZRES_ | Width in pixels | 640
| _VERTRES_ | Height in raster lines | 480
| _LOGPIXELSX_ | Horizontal dots per logical inch | 96
| _LOGPIXELSY_ | Vertical dots per logical inch | 96

The indexes _HORZSIZE_ and _VERTSIZE_ represent the physical dimensions of your display. (These indexes might not be true since Windows doesn't know what size display you have connected to your video adapter.) You can also calculate a display size by multiplying _HORZRES_ and _VERTRES_ by _LOGPIXELSX_ and _LOGPIXELSY_, respectively. The size calculated this way is known as the logical size of the display. Using the values above and the fact that there are 25.4 millimeters per inch, we can quickly calculate the two display sizes for a 640-by-480 pixel display under Windows NT 4.0. The physical display size is 12.60-by-9.45 inches, and the logical size is 6.67-by-5.00 inches. So the physical size and the logical size need not be the same.

For Windows NT 4.0, it turns out that _HORZSIZE_ and _VERTSIZE_ are independent of the display resolution, and _LOGPIXELSX_ and _LOGPIXELSY_ are always 96. So the logical size changes for different display resolutions, but the physical size does not. For Windows 95, the logical size and the physical size are equal, so both change with the display resolution. (At a resolution of 640-by-480 pixels with Windows 95, _HORZSIZE_ is 169 and _VERTSIZE_ is 127.)

Whenever you use a fixed mapping mode such as _MM_HIMETRIC_ or _MM_TWIPS_, the display driver uses the physical display size to do the mapping.

So, for Windows NT, text is smaller on a small monitor; but that's not what you want. Instead, you want your font sizes to correspond to the logical display size, not the physical size.

You can invent a special mapping mode, called logical twips, for which one logical unit is equal to 1/1440 logical inch. This mapping mode is independent of the operating system and display resolution and is used by programs such as Microsoft Word. Here is the code that sets the mapping mode to logical twips:

pDC->SetMapMode(MM_ANISOTROPIC);
pDC->SetWindowExt(1440, 1440);
pDC->SetViewportExt(pDC->GetDeviceCaps(LOGPIXELSX),
                    -pDC->GetDeviceCaps(LOGPIXELSY));

> NOTE
> 
> From the Windows Control Panel, you can adjust both the display font size and the display resolution. If you change the display font size from the default 100 percent to 200 percent, _HORZSIZE_ becomes 160, _VERTSIZE_ becomes 120, and the dots-per-inch value becomes 192. In that case, the logical size is divided by 2, and all text drawn with the logical twips mapping mode is doubled in size.

Computing Character Height
--------------------------

Five font height measurement parameters are available through the _CDC_ function _GetTextMetrics_, but only three are significant. Figure 5-1 shows the important font measurements. The _tmHeight_ parameter represents the full height of the font, including descenders (for the characters g, j, p, q, and y) and any diacritics that appear over capital letters. The _tmExternalLeading_ parameter is the distance between the top of the diacritic and the bottom of the descender from the line above. The sum of _tmHeight_ and _tmExternalLeading_ is the total character height. The value of _tmExternalLeading_ can be 0.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F05OG01x.gif)]

**Figure 5-1.** _Font height measurements._

You would think that _tmHeight_ would represent the font size in points. Wrong! Another _GetTextMetrics_ parameter, _tmInternalLeading_, comes into play. The point size corresponds to the difference between _tmHeight_ and _tmInternalLeading_. With the _MM_TWIPS_ mapping mode in effect, a selected 12-point font might have a _tmHeight_ value of 295 logical units and a _tmInter-nalLeading_ value of 55. The font's net height of 240 corresponds to the point size of 12.
________________________________________________________________________
5.3.5. - [The EX05A Example](invcpp5/ch05f.htm)
----------------------------------------------------
 The EX05A Example 

The EX05A Example
=================

This example sets up a view window with the logical twips mapping mode. A text string is displayed in 10 point sizes with the Arial TrueType font. Here are the steps for building the application:

2.  **Run AppWizard to generate the EX05A project.** Start by choosing New from the File menu, and then select MFC AppWizard (exe) on the Project tab. Select Single Document and deselect Printing And Print Preview; accept all the other default settings. The options and the default class names are shown in the following illustration.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G05OG01x.gif)
    
    3.  **Use ClassWizard to override the _OnPrepareDC_ function in the _CEx05aView_ class.** Edit the code in ex05aView.cpp as follows:
        
        void CEx05aView::OnPrepareDC(CDC\* pDC, CPrintInfo\* pInfo)
        {
            **pDC->SetMapMode(MM_ANISOTROPIC);
            pDC->SetWindowExt(1440, 1440);
            pDC->SetViewportExt(pDC->GetDeviceCaps(LOGPIXELSX),
                                -pDC->GetDeviceCaps(LOGPIXELSY));**
        }
        
    4.  **Add a private _ShowFont_ helper function to the view class.** Add the prototype shown below in ex05aView.h:
        
        **private:
            void ShowFont(CDC\* pDC, int& nPos, int nPoints);**
        
        Then add the function itself in ex05aView.cpp:
        
        **void CEx05aView::ShowFont(CDC\* pDC, int& nPos, int nPoints)
        {
            TEXTMETRIC tm;
            CFont      fontText;
            CString    strText;
            CSize      sizeText;
        
            fontText.CreateFont(-nPoints \* 20, 0, 0, 0, 400, FALSE, FALSE, 0,
                                ANSI_CHARSET, OUT_DEFAULT_PRECIS,
                                CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                                DEFAULT_PITCH | FF_SWISS, "Arial");
            CFont\* pOldFont = (CFont\*) pDC->SelectObject(&fontText);
            pDC->GetTextMetrics(&tm);
            TRACE("points = %d, tmHeight = %d, tmInternalLeading = %d,"
                  " tmExternalLeading = %d\n", nPoints, tm.tmHeight,
                  tm.tmInternalLeading, tm.tmExternalLeading);
            strText.Format("This is %d-point Arial", nPoints);
            sizeText = pDC->GetTextExtent(strText);
            TRACE("string width = %d, string height = %d\n", sizeText.cx,
                  sizeText.cy);
            pDC->TextOut(0, nPos, strText);
            pDC->SelectObject(pOldFont);
            nPos -= tm.tmHeight + tm.tmExternalLeading;
        }**
        
    5.  **Edit the _OnDraw_ function in ex05aView.cpp.** AppWizard always generates a skeleton _OnDraw_ function for your view class. Find the function, and replace the code with the following:
        
        void CEx05aView::OnDraw(CDC\* pDC)
        {
            **int nPosition = 0;
        
            for (int i = 6; i <= 24; i += 2) {
                ShowFont(pDC, nPosition, i);
            }
            TRACE("LOGPIXELSX = %d, LOGPIXELSY = %d\n",
                  pDC->GetDeviceCaps(LOGPIXELSX),
                  pDC->GetDeviceCaps(LOGPIXELSY)); 
            TRACE("HORZSIZE = %d, VERTSIZE = %d\n",
                  pDC->GetDeviceCaps(HORZSIZE),
                  pDC->GetDeviceCaps(VERTSIZE)); 
            TRACE("HORZRES = %d, VERTRES = %d\n",
                  pDC->GetDeviceCaps(HORZRES),
                  pDC->GetDeviceCaps(VERTRES));**
        }
        
    6.  **Build and run the EX05A program.** You must run the program from the debugger if you want to see the output from the TRACE statements. You can choose Go from the Start Debug submenu of the Build menu in Visual C++, or click the following button on the Build toolbar.
        
        ![](c:/dl/books/windows/msvc5th/invcpp5/images/G05OG02.GIF)
        
        The resulting output (assuming the use of a standard VGA card) looks like the screen shown here.
        
        [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G05OG03x.gif)]
        
        Notice that the output string sizes don't quite correspond to the point sizes. This discrepancy results from the font engine's conversion of logical units to pixels. The program's trace output, partially shown below, shows the printout of font metrics. (The numbers depend on your display driver and your video driver.)
        
        points = 6, tmHeight = 150, tmInternalLeading = 30, tmExternalLeading = 4
        string width = 990, string height = 150
        points = 8, tmHeight = 210, tmInternalLeading = 45, tmExternalLeading = 5
        string width = 1380, string height = 210
        points = 10, tmHeight = 240, tmInternalLeading = 45, tmExternalLeading = 6
        string width = 1770, string height = 240
        points = 12, tmHeight = 270, tmInternalLeading = 30, tmExternalLeading = 8
        string width = 2130, string height = 270
        
    
    The EX05A Program Elements
    --------------------------
    
    Following is a discussion of the important elements in the EX05A example.
    
    ### Setting the Mapping Mode in the _OnPrepareDC_ Function
    
    The application framework calls _OnPrepareDC_ prior to calling _OnDraw_, so the _OnPrepareDC_ function is the logical place to prepare the device context. If you had other message handlers that needed the correct mapping mode, those functions would have contained calls to _OnPrepareDC_.
    
    ### The _ShowFont_ Private Member Function
    
    _ShowFont_ contains code that is executed 10 times in a loop. With C, you would have made this a global function, but with C++ it's better to make it a private class member function, sometimes known as a helper function.
    
    This function creates the font, selects it into the device context, prints a string to the window, and then deselects the font. If you choose to include debug information in the program, _ShowFont_ also displays useful font metrics information, including the actual width of the string.
    
    ### Calling _CFont::CreateFont_
    
    This call includes lots of parameters, but the important ones are the first two—the font height and width. A width value of 0 means that the aspect ratio of the selected font will be set to a value specified by the font designer. If you put a nonzero value here, as you'll see in the next example, you can change the font's aspect ratio.
    
    > TIPS
    > 
    > If you want your font to be a specific point size, the _CreateFont_ font height parameter (the first parameter) must be negative. If you're using the _MM_TWIPS_ mapping mode for a printer, for example, a height parameter of -240 ensures a true 12-point font, with _tmHeight_ - _tmInternalLeading_ = 240. A +240 height parameter gives you a smaller font, with _tmHeight_ = 240.
    
    The last _CreateFont_ parameter specifies the font name, in this case the Arial TrueType font. If you had used _NULL_ for this parameter, the _FF_SWISS_ specification (which indicates a proportional font without serifs) would have caused Windows to choose the best matching font, which, depending on the specified size, might have been the System font or the Arial TrueType font. The font name takes precedence. If you had specified _FF_ROMAN_ (which indicates a proportional font with serifs) with Arial, for example, you would have gotten Arial.
________________________________________________________________________
5.3.6. - [The EX05B Example](invcpp5/ch05g.htm)
----------------------------------------------------
 The EX05B Example 

The EX05B Example
=================

This program is similar to EX05A except that it shows multiple fonts. The mapping mode is _MM_ANISOTROPIC_, with the scale dependent on the window size. The characters change size along with the window. This program effectively shows off some TrueType fonts and contrasts them with the old-style fonts. Here are the steps for building the application:

2.  **Run AppWizard to generate the EX05B project.** The options and the default class names are shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G05OG04x.gif)
    
3.  **Use ClassWizard to override the _OnPrepareDC_ function in the _CEx05bView_ class.** Edit the code in ex05bView.cpp as shown below.
    
    void CEx05bView::OnPrepareDC(CDC\* pDC, CPrintInfo\* pInfo)
    {
        **CRect clientRect;
    
        GetClientRect(clientRect);
        pDC->SetMapMode(MM_ANISOTROPIC); // +y = down
        pDC->SetWindowExt(400, 450);
        pDC->SetViewportExt(clientRect.right, clientRect.bottom);
        pDC->SetViewportOrg(0, 0);**
    }
    
4.  **Add a private _TraceMetrics_ helper function to the view class.** Add the following prototype in ex05bView.h:
    
    **private:
        void TraceMetrics(CDC\* pDC);**
    
    Then add the function itself in ex05bView.cpp:
    
    **void CEx05bView::TraceMetrics(CDC\* pDC)
    {
        TEXTMETRIC tm;
        char       szFaceName[100];
    
        pDC->GetTextMetrics(&tm);
        pDC->GetTextFace(99, szFaceName);
        TRACE("font = %s, tmHeight = %d, tmInternalLeading = %d,"
              " tmExternalLeading = %d\n", szFaceName, tm.tmHeight,
              tm.tmInternalLeading, tm.tmExternalLeading);
    }**
    
5.  **Edit the _OnDraw_ function in ex05bView.cpp.** AppWizard always generates a skeleton _OnDraw_ function for your view class. Find the function, and edit the code as follows:
    
    void CEx05bView::OnDraw(CDC\* pDC)
    {
        **CFont fontTest1, fontTest2, fontTest3, fontTest4;
    
        fontTest1.CreateFont(50, 0, 0, 0, 400, FALSE, FALSE, 0,
                             ANSI_CHARSET, OUT_DEFAULT_PRECIS,
                             CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                             DEFAULT_PITCH | FF_SWISS, "Arial");
        CFont\* pOldFont = pDC->SelectObject(&fontTest1);
        TraceMetrics(pDC);
        pDC->TextOut(0, 0, "This is Arial, default width");
        
        fontTest2.CreateFont(50, 0, 0, 0, 400, FALSE, FALSE, 0,
                             ANSI_CHARSET, OUT_DEFAULT_PRECIS,
                             CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                             DEFAULT_PITCH | FF_MODERN, "Courier");
                             // not TrueType
        pDC->SelectObject(&fontTest2);
        TraceMetrics(pDC);
        pDC->TextOut(0, 100, "This is Courier, default width");
        
        fontTest3.CreateFont(50, 10, 0, 0, 400, FALSE, FALSE, 0,
                             ANSI_CHARSET, OUT_DEFAULT_PRECIS,
                             CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                             DEFAULT_PITCH | FF_ROMAN, NULL);
        pDC->SelectObject(&fontTest3);
        TraceMetrics(pDC);
        pDC->TextOut(0, 200, "This is generic Roman, variable width");
    
        fontTest4.CreateFont(50, 0, 0, 0, 400, FALSE, FALSE, 0,
                             ANSI_CHARSET, OUT_DEFAULT_PRECIS,
                             CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                             DEFAULT_PITCH | FF_MODERN, "LinePrinter");
        pDC->SelectObject(&fontTest4);
        TraceMetrics(pDC);
        pDC->TextOut(0, 300, "This is LinePrinter, default width");
        pDC->SelectObject(pOldFont);**
    }
    
6.  **Build and run the EX05B program.** Run the program from the debugger to see the TRACE output. The program's window is shown here.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G05OG05x.gif)]
    
    Resize the window to make it smaller, and watch the font sizes change. Compare this window with the previous one.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G05OG06x.gif)
    
    If you continue to downsize the window, notice how the Courier font stops shrinking after a certain size and how the Roman font width changes.
    

The EX05B Program Elements
--------------------------

Following is a discussion of the important elements in the EX05B example.

### The _OnDraw_ Member Function

The _OnDraw_ function displays character strings in four fonts, as follows:

*   **_fontTest1_**—The TrueType font Arial with default width selection.
    
*   **_fontTest2_**—The old-style font Courier with default width selection. Notice how jagged the font appears in larger sizes.
    
*   **_fontTest3_**—The generic Roman font for which Windows supplies the TrueType font Times New Roman with programmed width selection. The width is tied to the horizontal window scale, so the font stretches to fit the window.
    
*   **_fontTest4_**—The LinePrinter font is specified, but because this is not a Windows font for the display, the font engine falls back on the _FF_MODERN_ specification and chooses the TrueType Courier New font.
    

### The _TraceMetrics Helper_ Function

The _TraceMetrics_ helper function calls _CDC::GetTextMetrics_ and _CDC::GetTextFace_ to get the current font's parameters, which it prints in the Debug window.
________________________________________________________________________
5.3.7. - [The EX05C Example -- CScrollView Revisited](invcpp5/ch05h.htm)
----------------------------------------------------
 The EX05C Example -- CScrollView Revisited 

The EX05C Example—_CScrollView_ Revisited
=========================================

You saw the _CScrollView_ class in [Chapter 4](ch04a.htm) (in EX04C). The EX05C program allows the user to move an ellipse with a mouse by "capturing" the mouse, using a scrolling window with the _MM_LOENGLISH_ mapping mode. Keyboard scrolling is left out, but you can add it by borrowing the _OnKeyDown_ member function from EX04C.

Instead of a stock brush, we'll use a pattern brush for the ellipse—a real GDI object. There's one complication with pattern brushes: you must reset the origin as the window scrolls; otherwise, strips of the pattern don't line up and the effect is ugly.

As with the EX04C program, this example involves a view class derived from _CScrollView_. Here are the steps to create the application:

2.  **Run AppWizard to generate the EX05C project.** Be sure to set the view base class to _CScrollView_. The options and the default class names are shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G05OG07x.Gif)
    
3.  **Edit the _CEx05cView_ class header in the file ex05cView.h.**Add the following lines in the class _CEx05cView_ declaration:
    
    **private:
        const CSize m_sizeEllipse; //
     logical
        CPoint m_pointTopLeft; // logical, top left of ellipse rectangle
        CSize  m_sizeOffset; // device, from rect top left 
                           
      //  to capture point
        BOOL   m_bCaptured;**
    
4.  **Use ClassWizard to add three message handlers to the _CEx05cView_ class.** Add the message handlers as follows:
    
    **Message**
    
    **Member Function**
    
    WM_LBUTTONDOWN
    
    _OnLButtonDown_
    
    WM_LBUTTONUP
    
    _OnLButtonUp_
    
    WM_MOUSEMOVE
    
    _OnMouseMove_
    
5.  **Edit the _CEx05cView_ message handler functions.** ClassWizard generated the skeletons for the functions listed in the preceding step. Find the functions in ex05cView.cpp, and code them as follows.
    
    void CEx05cView::OnLButtonDown(UINT nFlags, CPoint point) 
    {
        **CRect rectEllipse(m_pointTopLeft, m_sizeEllipse); // still logical
        CRgn  circle;
    
        CClientDC dc(this);
        OnPrepareDC(&dc);
        dc.LPtoDP(rectEllipse); // Now it's in device coordinates
        circle.CreateEllipticRgnIndirect(rectEllipse);
        if (circle.PtInRegion(point)) {
            // Capturing the mouse ensures subsequent LButtonUp message
            SetCapture();
            m_bCaptured = TRUE;
            CPoint pointTopLeft(m_pointTopLeft);
            dc.LPtoDP(&pointTopLeft);
            m_sizeOffset = point - pointTopLeft; // device coordinates
            // New mouse cursor is active while mouse is captured
            ::SetCursor(::LoadCursor(NULL, IDC_CROSS));
        }**
    }
    
    void CEx05cView::OnLButtonUp(UINT nFlags, CPoint point) 
    {
        **if (m_bCaptured) {
            ::ReleaseCapture();
            m_bCaptured = FALSE;
        }**
    }
    
    void CEx05cView::OnMouseMove(UINT nFlags, CPoint point) 
    {
        **if (m_bCaptured) {
            CClientDC dc(this);
            OnPrepareDC(&dc);
            CRect rectOld(m_pointTopLeft, m_sizeEllipse);
            dc.LPtoDP(rectOld);
            InvalidateRect(rectOld, TRUE);
            m_pointTopLeft = point - m_sizeOffset;
            dc.DPtoLP(&m_pointTopLeft);
            CRect rectNew(m_pointTopLeft, m_sizeEllipse);
            dc.LPtoDP(rectNew);
            InvalidateRect(rectNew, TRUE);
        }**
    }
    
6.  **Edit the _CEx05cView_ constructor, the _OnDraw_ function, and the _OnInitialUpdate_ function.** AppWizard generated these skeleton functions. Find them in ex05cView.cpp, and code them as follows:
    
    CEx05cView::CEx05cView() **: m_sizeEllipse(100, -100),
                               m_pointTopLeft(0, 0),
                               m_sizeOffset(0, 0)**
    {
        **m_bCaptured = FALSE;**
    }
    
    void CEx05cView::OnDraw(CDC\* pDC)
    {
        **CBrush brushHatch(HS_DIAGCROSS, RGB(255, 0, 0));
        CPoint point(0, 0);                  // logical (0, 0)
    
        pDC->LPtoDP(&point);                 // In device coordinates,
        pDC->SetBrushOrg(point);             //  align the brush with
                                             //  the window origin
        pDC->SelectObject(&brushHatch);
        pDC->Ellipse(CRect(m_pointTopLeft, m_sizeEllipse));
        pDC->SelectStockObject(BLACK_BRUSH); // Deselect brushHatch
        pDC->Rectangle(CRect(100, -100, 200, -200)); // Test invalid rect**
    }
    
    void CEx05cView::OnInitialUpdate()
    {
        CScrollView::OnInitialUpdate();
    
        **CSize sizeTotal(800, 1050); // 8-by-10.5 inches
        CSize sizePage(sizeTotal.cx / 2, sizeTotal.cy / 2);
        CSize sizeLine(sizeTotal.cx / 50, sizeTotal.cy / 50);
        SetScrollSizes(MM_LOENGLISH, sizeTotal, sizePage, sizeLine);**
    }
    
7.  **Build and run the EX05C program.** The program allows an ellipse to be dragged with the mouse, and it allows the window to be scrolled through. The program's window should look like the one shown here. As you move the ellipse, observe the black rectangle. You should be able to see the effects of invalidating the rectangle.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G05OG08.GIF)
    

The EX05C Program Elements
--------------------------

Following is a discussion of the important elements in the EX05C example.

### The _m_sizeEllipse_ and _m_pointTopLeft_ Data Members

Rather than store the ellipse's bounding rectangle as a single _CRect_ object, the program separately stores its size (_m_sizeEllipse_) and the position of its top left corner (_m_pointTopLeft_). To move the ellipse, the program merely recalculates _m_pointTopLeft_, and any round-off errors in the calculation won't affect the size of the ellipse.

### The _m_sizeOffset_ Data Member

When _OnMouseMove_ moves the ellipse, the relative position of the mouse within the ellipse must be the same as it was when the user first pressed the left mouse button. The _m_sizeOffset_ object stores this original offset of the mouse from the top left corner of the ellipse rectangle.

### The _m_bCaptured_ Data Member

The _m_bCaptured_ Boolean variable is set to TRUE when mouse tracking is in progress.

### The _SetCapture_ and _ReleaseCapture_ Functions

_SetCapture_ is the _CWnd_ member function that "captures" the mouse, such that mouse movement messages are sent to this window even if the mouse cursor is outside the window. An unfortunate side effect of this function is that the ellipse can be moved outside the window and "lost." A desirable and necessary effect is that all subsequent mouse messages are sent to the window, including the WM_LBUTTONUP message, which would otherwise be lost. The Win32 _ReleaseCapture_ function turns off mouse capture.

### The _SetCursor_ and _LoadCursor_ Win32 Functions

The MFC library does not "wrap" some Win32 functions. By convention, we use the C++ scope resolution operator (::) when calling Win32 functions directly. In this case, there is no potential for conflict with a _CView_ member function, but you can deliberately choose to call a Win32 function in place of a class member function with the same name. In that case, the :: operator ensures that you call the globally scoped Win32 function.

When the first parameter is _NULL_, the _LoadCursor_ function creates a cursor resource from the specified predefined mouse cursor that Windows uses. The _SetCursor_ function activates the specified cursor resource. This cursor remains active as long as the mouse is captured.

### The _CScrollView::OnPrepareDC_ Member Function

The _CView_ class has a virtual _OnPrepareDC_ function that does nothing. The _CScrollView_ class implements the function for the purpose of setting the view's mapping mode and origin, based on the parameters that you passed to _SetScrollSizes_ in _OnCreate_. The application framework calls _OnPrepareDC_ for you prior to calling _OnDraw_, so you don't need to worry about it. You must call _OnPrepareDC_ yourself in any other message handler function that uses the view's device context, such as _OnLButtonDown_ and _OnMouseMove_.

### The _OnMouseMove_ Coordinate Transformation Code

As you can see, this function contains several translation statements. The logic can be summarized by the following steps:

1.  Construct the previous ellipse rectangle and convert it from logical to device coordinates.
    
2.  Invalidate the previous rectangle.
    
3.  Update the top left coordinate of the ellipse rectangle.
    
4.  Construct the new rectangle and convert it to device coordinates.
    
5.  Invalidate the new rectangle.
    

The function calls _InvalidateRect_ twice. Windows "saves up" the two invalid rectangles and computes a new invalid rectangle that is the union of the two, intersected with the client rectangle.

### The _OnDraw_ Function

The _SetBrushOrg_ call is necessary to ensure that all of the ellipse's interior pattern lines up when the user scrolls through the view. The brush is aligned with a reference point, which is at the top left of the logical window, converted to device coordinates. This is a notable exception to the rule that _CDC_ member functions require logical coordinates.

The _CScrollView SetScaleToFitSize_ Mode
----------------------------------------

The _CScrollView_ class has a stretch-to-fit mode that displays the entire scrollable area in the view window. The Windows _MM_ANISOTROPIC_ mapping mode comes into play, with one restriction: positive y values always increase in the down direction, as in _MM_TEXT_ mode.

To use the stretch-to-fit mode, make the following call in your view's function in place of the call to _SetScrollSizes_:

SetScaleToFitSize(sizeTotal);

You can make this call in response to a Shrink To Fit menu command. Thus, the display can toggle between scrolling mode and shrink-to-fit mode.

Using the Logical Twips Mapping Mode in a Scrolling View
--------------------------------------------------------

The MFC _CScrollView_ class allows you to specify only standard mapping modes. The EX19A example in [Chapter 19](ch19a.htm) shows a new class _CLogScrollView_ that accommodates the logical twips mode.
________________________________________________________________________
5.4. - [Chapter 6 -- The Modal Dialog and Windows Common Controls](invcpp5/ch06a.htm)
----------------------------------------------------
 Chapter 6 -- The Modal Dialog and Windows Common Controls  Chapter 6

The Modal Dialog and Windows Common Controls
============================================

Almost every Windows-based program uses a dialog window to interact with the user. The dialog might be a simple OK message box, or it might be a complex data entry form. Calling this powerful element a dialog "box" is an injustice. A dialog is truly a window that receives messages, that can be moved and closed, and that can even accept drawing instructions in its client area.

The two kinds of dialogs are modal and modeless. This chapter explores the most common type, the modal dialog. In the first of this chapter's two examples, you'll use all the familiar "old" controls, such as the edit control and the list box, inherited from Win16. In the second example, you'll use the Windows common controls, which Microsoft Windows 95 introduced. In [Chapter 7](ch07a.htm) we'll take a look at the modeless dialog and the special-purpose Windows common dialogs for opening files, selecting fonts, and so forth. In [Chapter 8](ch08a.htm) we'll examine ActiveX Controls. Then [Chapter 9](ch09a.htm) discusses the new Internet Explorer control classes, introduced in MFC 6.0
________________________________________________________________________
5.4.1. - [Modal vs. Modeless Dialogs](invcpp5/ch06b.htm)
----------------------------------------------------
 Modal vs. Modeless Dialogs 

Modal vs. Modeless Dialogs
==========================

The _CDialog_ base class supports both modal and modeless dialogs. With a modal dialog, such as the Open File dialog, the user cannot work elsewhere in the same application (more correctly, in the same user interface thread) until the dialog is closed. With a modeless dialog, the user can work in another window in the application while the dialog remains on the screen. Microsoft Word's Find and Replace dialog is a good example of a modeless dialog; you can edit your document while the dialog is open.

Your choice of a modal or a modeless dialog depends on the application. Modal dialogs are much easier to program, which might influence your decision.

> **FYI**
> 
> The 16-bit versions of Windows support a special kind of modal dialog called a system modal dialog, which prevents the user from switching to another application. Win32 also supports system modal dialogs but with weird results: the user can switch to another application, but the dialog remains as the top window. You probably don't want to use system modal dialogs in Win32 applications.
________________________________________________________________________
5.4.2. - [Resources and Controls](invcpp5/ch06c.htm)
----------------------------------------------------
 Resources and Controls 

Resources and Controls
======================

So now you know a dialog is a window. What makes the dialog different from the _CView_ windows you've seen already? For one thing, a dialog window is almost always tied to a Windows resource that identifies the dialog's elements and specifies their layout. Because you can use the dialog editor (one of the resource editors) to create and edit a dialog resource, you can quickly and efficiently produce dialogs in a visual manner.

A dialog contains a number of elements called controls. Dialog controls include edit controls (aka text boxes), buttons, list boxes, combo boxes, static text (aka labels), tree views, progress indicators, sliders, and so forth. Windows manages these controls using special grouping and tabbing logic, and that relieves you of a major programming burden. The dialog controls can be referenced either by a _CWnd_ pointer (because they are really windows) or by an index number (with an associated _#define_ constant) assigned in the resource. A control sends a message to its parent dialog in response to a user action such as typing text or clicking a button.

The Microsoft Foundation Class (MFC) Library and ClassWizard work together to enhance the dialog logic that Windows provides. ClassWizard generates a class derived from _CDialog_ and then lets you associate dialog class data members with dialog controls. You can specify editing parameters such as maximum text length and numeric high and low limits. ClassWizard generates statements that call the MFC data exchange and data validation functions to move information back and forth between the screen and the data members.
________________________________________________________________________
5.4.3. - [Programming a Modal Dialog](invcpp5/ch06d.htm)
----------------------------------------------------
 Programming a Modal Dialog 

Programming a Modal Dialog
==========================

Modal dialogs are the most frequently used dialogs. A user action (a menu choice, for example) brings up a dialog on the screen, the user enters data in the dialog, and then the user closes the dialog. Here's a summary of the steps to add a modal dialog to an existing project:

2.  Use the dialog editor to create a dialog resource that contains various controls. The dialog editor updates the project's resource script (RC) file to include your new dialog resource, and it updates the project's resource.h file with corresponding _#define_ constants.
    
3.  Use ClassWizard to create a dialog class that is derived from _CDialog_ and attached to the resource created in step 1. ClassWizard adds the associated code and header file to the Microsoft Visual C++ project.
    

> NOTE
> 
> When ClassWizard generates your derived dialog class, it generates a constructor that invokes a _CDialog_ modal constructor, which takes a resource ID as a parameter. Your generated dialog header file contains a class enumerator constant _IDD_ that is set to the dialog resource ID. In the CPP file, the constructor implementation looks like this:
> 
> CMyDialog::CMyDialog(CWnd\* pParent /\*=NULL\*/)
>     : CDialog(CMyDialog::IDD, pParent)
> {
>     // initialization code here
> }
> 
> The use of _enum_ _IDD_ decouples the CPP file from the resource IDs that are defined in the project's resource.h file.

3.  Use ClassWizard to add data members, exchange functions, and validation functions to the dialog class.
    
4.  Use ClassWizard to add message handlers for the dialog's buttons and other event-generating controls.
    
5.  Write the code for special control initialization (in _OnInitDialog_) and for the message handlers. Be sure the _CDialog_ virtual member function _OnOK_ is called when the user closes the dialog (unless the user cancels the dialog). (Note: _OnOK_ is called by default.)
    
6.  Write the code in your view class to activate the dialog. This code consists of a call to your dialog class's constructor followed by a call to the _DoModal_ dialog class member function. _DoModal_ returns only when the user exits the dialog window.
    

Now we'll proceed with a real example, one step at a time.
________________________________________________________________________
5.4.4. - [The Dialog That Ate Cincinnati -- The EX06A Example](invcpp5/ch06e.htm)
----------------------------------------------------
 The Dialog That Ate Cincinnati -- The EX06A Example 

The Dialog That Ate Cincinnati—The EX06A Example
================================================

Let's not mess around with wimpy little dialogs. We'll build a monster dialog that contains almost every kind of control. The job will be easy because Visual C++'s dialog editor is there to help us. The finished product is shown in Figure 6-1.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F06OG01x.gif)]

**Figure 6-1.** _The finished dialog in action._

As you can see, the dialog supports a human resources application. These kinds of business programs are fairly boring, so the challenge is to produce something that could not have been done with 80-column punched cards. The program is brightened a little by the use of scroll bar controls for "Loyalty" and "Reliability." Here is a classic example of direct action and visual representation of data! ActiveX controls could add more interest, but you'll have to wait until [Chapter 8](ch08a.htm) for details on ActiveX.

Building the Dialog Resource
----------------------------

Here are the steps for building the dialog resource:

2.  **Run AppWizard to generate a project called EX06A.** Choose New from Visual C++'s File menu, and then click the Projects tab and select MFC AppWizard (exe). Accept all the defaults but two: select Single Document and deselect Printing And Print Preview. The options and the default class names are shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG01x.gif)
    
    As usual, AppWizard sets the new project as the current project.
    
3.  **Create a new dialog resource with ID _IDD_DIALOG1_.** Choose Resource from Visual C++'s Insert menu. The Insert Resource dialog appears. Click on Dialog, and then click New. Visual C++ creates a new dialog resource, as shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG02.GIF)
    
    The dialog editor assigns the resource ID _IDD**_**DIALOG1_ to the new dialog. Notice that the dialog editor inserts OK and Cancel buttons for the new dialog.
    
4.  **Size the dialog and assign a caption.** Enlarge the dialog box to about 5-by-7 inches.
    
    When you right-click on the new dialog and choose Properties from the pop-up menu, the Dialog Properties dialog appears. Type in the caption for the new dialog as shown in the screen below. The state of the pushpin button in the upper-left corner determines whether the Dialog Properties dialog stays on top of other windows. (When the pushpin is "pushed," the dialog stays on top of other windows.) Click the Toggle Grid button (on the Dialog toolbar) to reveal the grid and to help align controls.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG03x.gif)]
    
5.  **Set the dialog style.** Click on the Styles tab at the top of the Dialog Properties dialog, and then set the style properties as shown in the following illustration.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG04.GIF)
    
6.  **Set additional dialog styles.** Click on the More Styles tab at the top of the Dialog Properties dialog, and then set the style properties as shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG05.GIF)
    
7.  **Add the dialog's controls.** Use the control palette to add each control. (If the control palette is not visible, right-click any toolbar and choose Controls from the list.) Drag controls from the control palette to the new dialog, and then position and size the controls, as shown in Figure 6-1. Here are the control palette's controls.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG06.GIF)
    
    > NOTE
    > 
    > The dialog editor displays the position and size of each control in the status bar. The position units are special "dialog units," or DLUs, not device units. A horizontal DLU is the average width of the dialog font divided by 4. A vertical DLU is the average height of the font divided by 8. The dialog font is normally 8-point MS Sans Serif.
    
    Here's a brief description of the dialog's controls:
    
    *   **The static text control for the Name field.** A static text control simply paints characters on the screen. No user interaction occurs at runtime. You can type the text after you position the bounding rectangle, and you can resize the rectangle as needed. This is the only static text control you'll see listed in text, but you should also create the other static text controls as shown earlier in Figure 6-1. Follow the same procedure for the other static text controls in the dialog. All static text controls have the same ID, but that doesn't matter because the program doesn't need to access any of them.
        
    *   **The Name edit control.** An edit control is the primary means of entering text in a dialog. Right-click the control, and then choose Properties. Change this control's ID from _IDC**_**EDIT1_ to _IDC**_**NAME_. Accept the defaults for the rest of the properties. Notice that the default sets Auto HScroll, which means that the text scrolls horizontally when the box is filled.
        
    *   **The SS Nbr (social security number) edit control.** As far as the dialog editor is concerned, the SS Nbr control is exactly the same as the Name edit control. Simply change its ID to _IDC**_**SSN_. Later you will use ClassWizard to make this a numeric field.
        
    *   **The Bio (biography) edit control.** This is a multiline edit control. Change its ID to _IDC**_**BIO_, and then set its properties as shown here.
        
        ![](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG07.GIF)
        
    *   **The Category group box.** This control serves only to group two radio buttons visually. Type in the caption _Category_. The default ID is sufficient.
        
    *   **The Hourly and Salary radio buttons.** Position these radio buttons inside the Category group box. Set the Hourly button's ID to _IDC**_**CAT_ and set the other properties as shown here.
        
        ![](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG08.GIF)
        
        ![](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG09.GIF)
        
        Be sure that both buttons have the Auto property (the default) on the Styles tab set and that only the Hourly button has the Group property set. When these properties are set correctly, Windows ensures that only one of the two buttons can be selected at a time. The Category group box has no effect on the buttons' operation.
        
    *   **The Insurance group box.** This control holds three check boxes. Type in the caption _Insurance_.
        
        > NOTE
        > 
        > Later, when you set the dialog's tab order, you'll ensure that the Insurance group box follows the last radio button of the Category group. Set the Insurance control's Group property now in order to "terminate" the previous group. If you fail to do this, it isn't a serious problem, but you'll get several warning messages when you run the program through the debugger.
        
    *   **The Life, Disability, and Medical check boxes.** Place these controls inside the Insurance group box. Accept the default properties, but change the IDs to _IDC**_**LIFE_, _IDC**_**DIS_, and _IDC**_**MED_. Unlike radio buttons, check boxes are independent; the user can set any combination.
        
    *   **The Skill combo box.** This is the first of three types of combo boxes. Change the ID to _IDC**_**SKILL_, and then click on the Styles tab and set the Type option to Simple. Click on the Data tab, and add three skills (terminating each line with Ctrl-Enter) in the Enter Listbox Items box.
        
        ![](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG10.GIF)
        
        This is a combo box of type Simple. The user can type anything in the top edit control, use the mouse to select an item from the attached list box, or use the Up or Down direction key to select an item from the attached list box.
        
    *   **The Educ (education) combo box.** Change the ID to _IDC**_**EDUC_; otherwise, accept the defaults. Add the three education levels in the Data page, as shown in Figure 6-1. In this Dropdown combo box, the user can type anything in the edit box, click on the arrow, and then select an item from the drop-down list box or use the Up or Down direction key to select an item from the attached list box.
        
        > **Aligning Controls**
        > 
        > To align two or more controls, select the controls by clicking on the first control and then Shift-clicking on the other controls you want to align. Next choose one of the alignment commands (Left, Horiz.Center, Right, Top, Vert.Center, or Bottom) from the Align submenu on the dialog editor's Layout menu.
        
        > NOTE
        > 
        > To set the size for the drop-down portion of a combo box, click on the box's arrow and drag down from the center of the bottom of the rectangle.
        
    *   **The Dept (department) list box.** Change the ID to _IDC**_**DEPT_; otherwise, accept all the defaults. In this list box, the user can select only a single item by using the mouse, by using the Up or Down direction key, or by typing the first character of a selection. Note that you can't enter the initial choices in the dialog editor. You'll see how to set these choices later.
        
    *   **The Lang (language) combo box.** Change the ID to _IDC**_**LANG_, and then click on the Styles tab and set the Type option to Drop List. Add three languages (English, French, and Spanish) in the Data page. With this Drop List combo box, the user can select only from the attached list box. To select, the user can click on the arrow and then select an entry from the drop-down list, or the user can type in the first letter of the selection and then refine the selection using the Up or Down direction key.
        
    *   **The Loyalty and Reliability scroll bars.** Do not confuse scroll bar controls with a window's built-in scroll bars as seen in scrolling views. A scroll bar control behaves in the same manner as do other controls and can be resized at design time. Position and size the horizontal scroll bar controls as shown previously in Figure 6-1, and then assign the IDs _IDC**_**LOYAL_ and _IDC**_**RELY_.
        
        > **Selecting a Group of Controls**
        > 
        > To quickly select a group of controls, position the mouse cursor above and to the left of the group. Hold down the left mouse button and drag to a point below and to the right of the group, as shown here.
        > 
        > [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG11x.gif)]
        
    *   **The OK, Cancel, and Special pushbuttons.** Be sure the button captions are _OK_, _Cancel_, and _Special_, and then assign the ID _IDC**_**SPECIAL_ to the Special button. Later you'll learn about special meanings that are associated with the default IDs _IDOK_ and _IDCANCEL_.
        
    *   **Any icon. (The MFC icon is shown as an example.)** You can use the Picture control to display any icon or bitmap in a dialog, as long as the icon or bitmap is defined in the resource script. We'll use the program's MFC icon, identified as _IDR**_**MAINFRAME_. Set the Type option to Icon, and set the Image option to _IDR**_**MAINFRAME_. Leave the ID as _IDC**_**STATIC_.
        

8.  **Check the dialog's tabbing order.** Choose Tab Order from the dialog editor's Layout menu. Use the mouse to set the tabbing order shown below. Click on each control in the order shown, and then press Enter.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG12x.gif)]
    
    > TIPS
    > 
    > If you mess up the tab sequence partway through, you can recover with a Ctrl-left mouse click on the last correctly sequenced control. Subsequent mouse clicks will start with the next sequence number.
    
    > NOTE
    > 
    > A static text control (such as Name or Skill) has an ampersand (&) embedded in the text for its caption. At runtime, the ampersand will appear as an underscore under the character that follows. (See Figure 6-1.) This enables the user to jump to selected controls by holding down the Alt key and pressing the key corresponding to the underlined character. (The related control must immediately follow the static text in the tabbing order.) Thus, Alt-N jumps to the Name edit control and Alt-K jumps to the Skill combo box. Needless to say, designated jump characters should be unique within the dialog. The Skill control uses Alt-K because the SS Nbr control uses Alt-S.
    
9.  **Save the resource file on disk.** For safety, choose Save from the File menu or click the Save button on the toolbar to save ex06a.rc. Keep the dialog editor running, and keep the newly built dialog on the screen.

ClassWizard and the Dialog Class
--------------------------------

You have now built a dialog resource, but you can't use it without a corresponding dialog class. (The section titled "[Understanding the EX06A Application](ch06e.htm#138)" explains the relationship between the dialog window and the underlying classes.) ClassWizard works in conjunction with the dialog editor to create that class as follows:

2.  **Choose ClassWizard from Visual C++'s View menu (or press Ctrl-W).** Be sure that you still have the newly built dialog, _IDD_DIALOG1_, selected in the dialog editor and that EX06A is the current Visual C++ project.
    
3.  **Add the _CEx06aDialog_ class.** ClassWizard detects the fact that you've just created a dialog resource without an associated C++ class. It politely asks whether you want to create a class, as shown below.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG13.GIF)
    
    Accept the default selection of Create A New Class, and click OK. Fill in the top field of the New Class dialog, as shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG14.GIF)
    
4.  **Add the _CEx06aDialog_ variables.** After ClassWizard creates the _CEx06aDialog_ class, the MFC ClassWizard dialog appears. Click on the Member Variables tab, and the Member Variables page appears, as shown here.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG15x.gif)]
    
    You need to associate data members with each of the dialog's controls. To do this, click on a control ID and then click the Add Variable button. The Add Member Variable dialog appears, as shown in the following illustration.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG16.GIF)
    
    Type in the member variable name, and choose the variable type according to the following table. Be sure to type in the member variable name exactly as shown; the case of each letter is important. When you're done, click OK to return to the MFC ClassWizard dialog. Repeat this process for each of the listed controls.
    
    **Control ID**
    
    **Data Member**
    
    **Type**
    
    _IDC_BIO_
    
    _m_strBio_
    
    _CString_
    
    _IDC_CAT_
    
    _m_nCat_
    
    _int_
    
    _IDC_DEPT_
    
    _m_strDept_
    
    _CString_
    
    _IDC_DIS_
    
    _m_bInsDis_
    
    _BOOL_
    
    _IDC_EDUC_
    
    _m_strEduc_
    
    _CString_
    
    _IDC_LANG_
    
    _m_nLang_
    
    _CString_
    
    _IDC_LIFE_
    
    _m_bInsLife_
    
    _BOOL_
    
    _IDC_LOYAL_
    
    _m_nLoyal_
    
    _int_
    
    _IDC_MED_
    
    _m_bInsMed_
    
    _BOOL_
    
    _IDC_NAME_
    
    _m_strName_
    
    _CString_
    
    _IDC_RELY_
    
    _m_nRely_
    
    _int_
    
    _IDC_SKILL_
    
    _m_strSkill_
    
    _CString_
    
    _IDC_SSN_
    
    _m_nSsn_
    
    _int_
    
    As you select controls in the MFC ClassWizard dialog, various edit boxes appear at the bottom of the dialog. If you select a _CString_ variable, you can set its maximum number of characters; if you select a numeric variable, you can set its high and low limits. Set the minimum value for _IDC**_**SSN_ to 0 and the maximum value to 999999999.
    
    Most relationships between control types and variable types are obvious. The way in which radio buttons correspond to variables is not so intuitive, however. The _CDialog_ class associates an integer variable with each radio button _group,_ with the first button corresponding to value 0, the second to 1, and so forth.
    
5.  **Add the message-handling function for the Special button.** _CEx06aDialog_ doesn't need many message-handling functions because the _CDialog_ base class, with the help of Windows, does most of the dialog management. When you specify the ID _IDOK_ for the OK button (ClassWizard's default), for example, the virtual _CDialog_ function _OnOK_ gets called when the user clicks the button. For other buttons, however, you need message handlers.
    
    Click on the Message Maps tab. The ClassWizard dialog should contain an entry for _IDC**_**SPECIAL_ in the Object IDs list box. Click on this entry, and double-click on the BN**_**CLICKED message that appears in the Messages list box. ClassWizard invents a member function name, _OnSpecial_, and opens the Add Member Function dialog, as shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG17.GIF)
    
    You could type in your own function name here, but this time accept the default and click OK. Click the Edit Code button in the MFC ClassWizard dialog. This opens the file ex06aDialog.cpp and moves to the _OnSpecial_ function. Insert a _TRACE_ statement in the _OnSpecial_ function by typing in the boldface code, shown below, which replaces the existing code:
    
    void CEx06aDialog::OnSpecial()
    {
        **TRACE("CEx06aDialog::OnSpecial\n");**
    }
    
6.  **Use ClassWizard to add an _OnInitDialog_ message-handling function.** As you'll see in a moment, ClassWizard generates code that initializes a dialog's controls. This DDX (Dialog Data Exchange) code won't initialize the list-box choices, however, so you must override the _CDialog::OnInit-Dialog_ function. Although _OnInitDialog_ is a virtual member function, ClassWizard generates the prototype and skeleton if you map the WM___INITDIALOG message in the derived dialog class. To do so, click on _CEx06aDialog_ in the Object IDs list box and then double-click on the WM___INITDIALOG message in the Messages list box. Click the Edit Code button in the MFC ClassWizard dialog to edit the _OnInitDialog_ function. Type in the boldface code, which replaces the existing code:
    
    BOOL CEx06aDialog::OnInitDialog()
    {
        **// Be careful to call CDialog::OnInitDialog
        //  only once in this function
        CListBox\* pLB = (CListBox\*) GetDlgItem(IDC_DEPT);
        pLB->InsertString(-1, "Documentation");
        pLB->InsertString(-1, "Accounting");
        pLB->InsertString(-1, "Human Relations");
        pLB->InsertString(-1, "Security");
    
        // Call after initialization
        return CDialog::OnInitDialog();**
    }
    
    You could also use the same initialization technique for the combo boxes, in place of the initialization in the resource.
    

Connecting the Dialog to the View
---------------------------------

Now we've got the resource and the code for a dialog, but it's not connected to the view. In most applications, you would probably use a menu choice to activate a dialog, but we haven't studied menus yet. Here we'll use the familiar mouse-click message WM**___**LBUTTONDOWN to start the dialog. The steps are as follows:

2.  **In ClassWizard, select the _CEx06aView_ class.** At this point, be sure that EX06A is Visual C++'s current project.
    
3.  **Use ClassWizard to add the _OnLButtonDown_ member function.** You've done this in the examples in earlier chapters. Simply select the _CEx06aView_ class name, click on the _CEx06aView_ object ID, and then double-click on WM___LBUTTONDOWN.
    
4.  **Write the code for _OnLButtonDown_ in file ex06aView.cpp.** Add the boldface code below. Most of the code consists of _TRACE_ statements to print the dialog data members after the user exits the dialog. The _CEx06aDialog_ constructor call and the _DoModal_ call are the critical statements, however:
    
    void CEx06aView::OnLButtonDown(UINT nFlags, CPoint point)
    {
        **CEx06aDialog dlg;
        dlg.m_strName  = "Shakespeare, Will";
        dlg.m_nSsn     = 307806636;
        dlg.m_nCat     = 1;  // 0 = hourly, 1 = salary
        dlg.m_strBio   = "This person is not a well-motivated tech writer";
        dlg.m_bInsLife = TRUE;
        dlg.m_bInsDis  = FALSE;
        dlg.m_bInsMed  = TRUE;
        dlg.m_strDept  = "Documentation";
        dlg.m_strSkill = "Writer";
        dlg.m_nLang    = 0;
        dlg.m_strEduc  = "College";
        dlg.m_nLoyal   = dlg.m_nRely = 50;
        int ret = dlg.DoModal();
        TRACE("DoModal return = %d\n", ret);
        TRACE("name = %s, ssn = %d, cat = %d\n",
              dlg.m_strName, dlg.m_nSsn, dlg.m_nCat);
        TRACE("dept = %s, skill = %s, lang = %d, educ = %s\n",
              dlg.m_strDept, dlg.m_strSkill, dlg.m_nLang, dlg.m_strEduc);
        TRACE("life = %d, dis = %d, med = %d, bio = %s\n",
              dlg.m_bInsLife, dlg.m_bInsDis, dlg.m_bInsMed, dlg.m_strBio);
        TRACE("loyalty = %d, reliability = %d\n",
              dlg.m_nLoyal, dlg.m_nRely);**
    }
    
5.  **Add code to the virtual _OnDraw_ function in file ex06aView.cpp.** To prompt the user to press the left mouse button, code the _CEx06aView::OnDraw_ function. (The skeleton was generated by AppWizard.) The following boldface code (which you type in) replaces the existing code:
    
    void CEx06aView::OnDraw(CDC\* pDC)
    {
        **pDC->TextOut(0, 0, "Press the left mouse button here.");**
    }
    
6.  **To ex06aView.cpp, add the dialog class include statement.** The _OnLButtonDown_ function above depends on the declaration of class _CEx06aDialog_. You must insert the include statement
    
    **#include "ex06aDialog.h"**
    
    at the top of the _CEx06aView_ class source code file (ex06aView.cpp), after the statement
    
    #include "ex06aView.h"
    
7.  **Build and test the application.** If you have done everything correctly, you should be able to build and run the EX06A application through Visual C++. Try entering data in each control, and then click the OK button and observe the _TRACE_ results in the Debug window. Notice that the scroll bar controls don't do much yet; we'll attend to them later. Notice what happens when you press Enter while typing in text data in a control: the dialog closes immediately.
    

Understanding the EX06A Application
-----------------------------------

When your program calls _DoModal_, control is returned to your program only when the user closes the dialog. If you understand that, you understand modal dialogs. When you start creating modeless dialogs, you'll begin to appreciate the programming simplicity of modal dialogs. A lot happens "out of sight" as a result of that _DoModal_ call, however. Here's a "what calls what" summary:

> CDialog::DoModal  
>     CEx06aDialog::OnInitDialog  
>         …additional initialization…  
>         CDialog::OnInitDialog  
>             CWnd::UpdateData(FALSE)  
>                 CEx06aDialog::DoDataExchange  
>     user enters data…  
>     user clicks the OK button  
>     CEx06aDialog::OnOK  
>         …additional validation…  
>         CDialog::OnOK  
>             CWnd::UpdateData(TRUE)  
>                 CEx06aDialog::DoDataExchange  
>             CDialog::EndDialog(IDOK)  

_OnInitDialog_ and _DoDataExchange_ are virtual functions overridden in the _CEx06aDialog_ class. Windows calls _OnInitDialog_ as part of the dialog initialization process, and that results in a call to _DoDataExchange_, a _CWnd_ virtual function that was overridden by ClassWizard. Here is a listing of that function:

void CEx06aDialog::DoDataExchange(CDataExchange\* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CEx06aDialog)
    DDX_Text(pDX, IDC_BIO, m_strBio);
    DDX_Radio(pDX, IDC_CAT, m_nCat);
    DDX_LBString(pDX, IDC_DEPT, m_strDept);
    DDX_Check(pDX, IDC_DIS, m_bInsDis);
    DDX_CBString(pDX, IDC_EDUC, m_strEduc);
    DDX_CBIndex(pDX, IDC_LANG, m_nLang);
    DDX_Check(pDX, IDC_LIFE, m_bInsLife);
    DDX_Scroll(pDX, IDC_LOYAL, m_nLoyal);
    DDX_Check(pDX, IDC_MED, m_bInsMed);
    DDX_Text(pDX, IDC_NAME, m_strName);
    DDX_Scroll(pDX, IDC_RELY, m_nRely);
    DDX_CBString(pDX, IDC_SKILL, m_strSkill);
    DDX_Text(pDX, IDC_SSN, m_nSsn);
    DDV_MinMaxInt(pDX, m_nSsn, 0, 999999999);
    //}}AFX_DATA_MAP 
}

The _DoDataExchange_ function and the _DDX**_**_ (exchange) and _DDV**_**_ (validation) functions are "bidirectional." If _UpdateData_ is called with a _FALSE_ parameter, the functions transfer data from the data members to the dialog controls. If the parameter is _TRUE_, the functions transfer data from the dialog controls to the data members. _DDX**_**Text_ is overloaded to accommodate a variety of data types.

The _EndDialog_ function is critical to the dialog exit procedure. _DoModal_ returns the parameter passed to _EndDialog_. _IDOK_ accepts the dialog's data, and _IDCANCEL_ cancels the dialog.

> TIPS
> 
> You can write your own "custom" DDX function and wire it into Visual C++. This feature is useful if you're using a unique data type throughout your application. See MFC Technical Note #26 in the online documentation.
________________________________________________________________________
5.4.5. - [Enhancing the Dialog Program](invcpp5/ch06f.htm)
----------------------------------------------------
 Enhancing the Dialog Program 

Enhancing the Dialog Program
============================

The EX06A program required little coding for a lot of functionality. Now we'll make a new version of this program that uses some hand-coding to add extra features. We'll eliminate EX06A's rude habit of dumping the user in response to a press of the Enter key, and we'll hook up the scroll bar controls.

Taking Control of the _OnOK_ Exit
---------------------------------

In the original EX06A program, the _CDialog::OnOK_ virtual function handled the OK button, which triggered data exchange and the exit from the dialog. Pressing the Enter key happens to have the same effect, and that might or might not be what you want. If the user presses Enter while in the Name edit control, for example, the dialog closes immediately.

What's going on here? When the user presses Enter, Windows looks to see which pushbutton has the input focus, as indicated on the screen by a dotted rectangle. If no button has the focus, Windows looks for the default pushbutton that the program or the resource specifies. (The default pushbutton has a thicker border.) If the dialog has no default button, the virtual _OnOK_ function is called, even if the dialog does not contain an OK button.

You can disable the Enter key by writing a do-nothing _CEx06aDialog::OnOK_ function and adding the exit code to a new function that responds to clicking the OK button. Here are the steps:

2.  **Use ClassWizard to "map" the IDOK button to the virtual _OnOK_ function.** In ClassWizard, choose _IDOK_ from the _CEx06aDialog_ Object IDs list, and then double-click on BN_CLICKED. This generates the prototype and skeleton for _OnOK_.
    
3.  **Use the dialog editor to change the OK button ID.** Select the OK button, change its ID from _IDOK_ to _IDC_OK_, and then uncheck its Default Button property. Leave the _OnOK_ function alone.
    
4.  **Use ClassWizard to create a member function called _OnClickedOk_.** This _CEx06aDialog_ class member function is keyed to the BN___CLICKED message from the newly renamed control _IDC_OK_.
    
5.  **Edit the body of the _OnClickedOk_ function in ex06aDialog.cpp.** This function calls the base class _OnOK_ function, as did the original _CEx06aDialog::OnOK_ function. Here is the code:
    
    void CEx06aDialog::OnClickedOk()
    {
        **TRACE("CEx06aDialog::OnClickedOk\n");
        CDialog::OnOK();** 
    }
    
6.  **Edit the original _OnOK_ function in ex06aDialog.cpp.** This function is a "leftover" handler for the old _IDOK_ button. Edit the code as shown here:
    
    void CEx06aDialog::OnOK()
    {
        **// dummy OnOK function -- do NOT call CDialog::OnOK()
        TRACE("CEx06aDialog::OnOK\n");** 
    }
    
7.  **Build and test the application.** Try pressing the Enter key now. Nothing should happen, but _TRACE_ output should appear in the Debug window. Clicking the OK button should exit the dialog as before, however.
    

> **For Win32 Programmers**
> 
> Dialog controls send WM**___** COMMAND notification messages to their parent dialogs. For a single button click, for example, the bottom 16 bits of _wParam_ contain the button ID, the top 16 bits of _wParam_ contain the BN_CLICKED notification code, and _lParam_ contains the button handle. Most window procedure functions process these notification messages with a nested switch statement. MFC "flattens out" the message processing logic by "promoting" control notification messages to the same level as other Windows messages.
> 
> For a Delete button (for example), ClassWizard generates notification message map entries similar to these:
> 
> ON_BN_CLICKED(IDC_DELETE, OnDeleteClicked)
> ON_BN_DOUBLECLICKED(IDC_DELETE, OnDeleteDblClicked)
> 
> Button events are special because they generate command messages if your dialog class doesn't have notification handlers like the ones above. As [Chapter 13](ch13a.htm) explains, the application framework "routes" these command messages to various objects in your application. You could also map the control notifications with a more generic _ON**_** COMMAND_ message-handling entry like this:
> 
> ON_COMMAND(IDC_DELETE, OnDelete)
> 
> In this case, the _OnDelete_ function is unable to distinguish between a single click and a double click, but that's no problem because few Windows-based programs utilize double clicks for buttons.

_OnCancel_ Processing
---------------------

Just as pressing the Enter key triggers a call to _OnOK_, pressing the Esc key triggers a call to _OnCancel_, which results in an exit from the dialog with a _DoModal_ return code of _IDCANCEL_. EX06A does no special processing for _IDCANCEL_; therefore, pressing the Esc key (or clicking the Close button) closes the dialog. You can circumvent this process by substituting a dummy _OnCancel_ function, following approximately the same procedure you used for the OK button.

Hooking Up the Scroll Bar Controls
----------------------------------

The dialog editor allows you to include scroll bar controls in your dialog, and ClassWizard lets you add integer data members. You must add code to make the Loyalty and Reliability scroll bars work.

Scroll bar controls have position and range values that can be read and written. If you set the range to (0, 100), for example, a corresponding data member with a value of 50 positions the scroll box at the center of the bar. (The function _CScrollBar::SetScrollPos_ also sets the scroll box position.) The scroll bars send the WM**___** HSCROLL and WM**___** VSCROLL messages to the dialog when the user drags the scroll box or clicks the arrows. The dialog's message handlers must decode these messages and position the scroll box accordingly.

Each control you've seen so far has had its own individual message handler function. Scroll bar controls are different because all horizontal scroll bars in a dialog are tied to a single WM_HSCROLL message handler and all vertical scroll bars are tied to a single WM_VSCROLL handler. Because this monster dialog contains two horizontal scroll bars, the single WM**___** HSCROLL message handler must figure out which scroll bar sent the scroll message.

Here are the steps for adding the scroll bar logic to EX06A:

2.  **Add the class _enum_ statements for the minimum and maximum scroll range.** In ex06aDialog.h, add the following lines at the top of the class declaration:
    
    **enum { nMin = 0 };
    enum { nMax = 100 };** 
    
3.  **Edit the _OnInitDialog_ function to initialize the scroll ranges.** In the _OnInitDialog_ function, we'll set the minimum and the maximum scroll values such that the _CEx06aDialog_ data members represent percentage values. A value of 100 means "Set the scroll box to the extreme right"; a value of 0 means "Set the scroll box to the extreme left."
    
    Add the following code to the _CEx06aDialog_ member function _OnInitDialog_ in the file ex06aDialog.cpp:
    
    **CScrollBar\* pSB = (CScrollBar\*) GetDlgItem(IDC_LOYAL);
    pSB->SetScrollRange(nMin, nMax);
    
    pSB = (CScrollBar\*) GetDlgItem(IDC_RELY);
    pSB->SetScrollRange(nMin, nMax);** 
    
4.  **Use ClassWizard to add a scroll bar message handler to _CEx06aDialog_.** Choose the WM___HSCROLL message, and then add the member function _OnHScroll_. Enter the following boldface code:
    
    void CEx06aDialog::OnHScroll(UINT nSBCode, UINT nPos,
                                 CScrollBar\* pScrollBar)
    {
        **int nTemp1, nTemp2;
    
        nTemp1 = pScrollBar->GetScrollPos();
        switch(nSBCode) {
        case SB_THUMBPOSITION:
            pScrollBar->SetScrollPos(nPos);
            break;
        case SB_LINELEFT: // left arrow button
            nTemp2 = (nMax - nMin) / 10;
            if ((nTemp1 - nTemp2) > nMin) {
                nTemp1 -= nTemp2;
            }
            else {
                nTemp1 = nMin;
            }
            pScrollBar->SetScrollPos(nTemp1);
            break;
        case SB_LINERIGHT: // right arrow button
            nTemp2 = (nMax - nMin) / 10;
            if ((nTemp1 + nTemp2) < nMax) {
                nTemp1 += nTemp2;
            }
            else {
                nTemp1 = nMax;
            }
            pScrollBar->SetScrollPos(nTemp1);
            break;
        }** 
    }
    

> NOTE
> 
> The scroll bar functions use 16-bit integers for both range and position.

5.  **Build and test the application.** Build and run EX06A again. Do the scroll bars work this time? The scroll boxes should "stick" after you drag them with the mouse, and they should move when you click the scroll bars' arrows. (Notice that we haven't added logic to cover the user's click on the scroll bar itself.)
________________________________________________________________________
5.4.6. - [Identifying Controls: CWnd Pointers and Control IDs](invcpp5/ch06g.htm)
----------------------------------------------------
 Identifying Controls: CWnd Pointers and Control IDs 

Identifying Controls: _CWnd_ Pointers and Control IDs
=====================================================

When you lay out a dialog resource in the dialog editor, you identify each control by an ID such as _IDC**_**SSN_. In your program code, however, you often need access to a control's underlying window object. The MFC library provides the _CWnd::GetDlgItem_ function for converting an ID to a _CWnd_ pointer. You've seen this already in the _OnInitDialog_ member function of class _CEx06aDialog_. The application framework "manufactured" this returned _CWnd_ pointer because there never was a constructor call for the control objects. This pointer is temporary and should not be stored for later use.

> TIPS
> 
> If you need to convert a _CWnd_ pointer to a control ID, use the MFC library _GetDlgCtrlID_ member function of class_CWnd._
________________________________________________________________________
5.4.7. - [Setting the Color for the Dialog Background and for Controls](invcpp5/ch06h.htm)
----------------------------------------------------
 Setting the Color for the Dialog Background and for Controls 

Setting the Color for the Dialog Background and for Controls
============================================================

You can change the background color of individual dialogs or specific controls in a dialog, but you have to do some extra work. The parent dialog is sent a WM_CTLCOLOR message for each control immediately before the control is displayed. A WM**___**CTLCOLOR message is also sent on behalf of the dialog itself. If you map this message in your derived dialog class, you can set the foreground and background text colors and select a brush for the control or dialog nontext area.

Following is a sample _OnCtlColor_ function that sets all edit control backgrounds to yellow and the dialog background to red. The _m**_**hYellowBrush_ and _m**_**hRedBrush_ variables are data members of type _HBRUSH_, initialized in the dialog's _OnInitDialog_ function. The _nCtlColor_ parameter indicates the type of control, and the _pWnd_ parameter identifies the specific control. If you wanted to set the color for an individual edit control, you would convert _pWnd_ to a child window ID and test it.

HBRUSH CMyDialog::OnCtlColor(CDC\* pDC, CWnd\* pWnd, UINT nCtlColor)
{
    if (nCtlColor == CTLCOLOR_EDIT) {
        pDC->SetBkColor(RGB(255, 255, 0));  // yellow
        return m_hYellowBrush;
    }
    if (nCtlColor == CTLCOLOR_DLG) {
        pDC->SetBkColor(RGB(255, 0, 0));    // red
        return m_hRedBrush;
    }
    return CDialog::OnCtlColor(pDC, pWnd, nCtlColor);
}

> NOTE
> 
> The dialog does not post the WM_CTLCOLOR message in the message queue; instead, it calls the Win32 _SendMessage_ function to send the message immediately. Thus the message handler can return a parameter, in this case a handle to a brush. This is not an MFC _CBrush_ object but rather a Win32 _HBRUSH_. You can create the brush by calling the Win32 functions _CreateSolidBrush_, _CreateHatchBrush_, and so forth.

> **For Win32 Programmers**
> 
> Actually, Win32 no longer has a WM_CTLCOLOR message. It was replaced by control-specific messages such as WM_CTLCOLORBTN, WM_CTLCOLORDLG, and so on. MFC and ClassWizard process these messages invisibly, so your programs look as though they're mapping the old 16-bit WM_CTLCOLOR messages. This trick makes debugging more complex, but it makes portable code easier to write. Another option would be to use the _ON_MESSAGE_ macro to map the real Win32 messages.
> 
> If your dialog class (or other MFC window class) doesn't map the WM_CTLCOLOR message, the framework reflects the message back to the control. When you study window subclassing in [Chapter 16](ch16a.htm), you'll learn how to write your own control window classes that can process these reflected messages.
________________________________________________________________________
5.4.8. - [Painting Inside the Dialog Window](invcpp5/ch06i.htm)
----------------------------------------------------
 Painting Inside the Dialog Window 

Painting Inside the Dialog Window
=================================

You can paint directly in the client area of the dialog window, but you'll avoid overwriting dialog elements if you paint only inside a control window. If you want to display text only, use the dialog editor to create a blank static control with a unique ID and then call the _CWnd::SetDlgItemText_ function in a dialog member function such as _OnInitDialog_ to place text in the control.

Displaying graphics is more complicated. You must use ClassWizard to add an _OnPaint_ member function to the dialog; this function must convert the static control's ID to a _CWnd_ pointer and get its device context. The trick is to draw inside the control window while preventing Windows from overwriting your work later. The _Invalidate/UpdateWindow_ sequence achieves this. Here is an _OnPaint_ function that paints a small black square in a static control:

void CMyDialog::OnPaint()
{
    CWnd\* pWnd = GetDlgItem(IDC_STATIC1);     // IDC_STATIC1 specified
                                              //  in the dialog editor
    CDC\* pControlDC = pWnd->GetDC();

    pWnd->Invalidate();
    pWnd->UpdateWindow();
    pControlDC->SelectStockObject(BLACK_BRUSH);
    pControlDC->Rectangle(0, 0, 10, 10);      // black square bullet
    pWnd->ReleaseDC(pControlDC);
}

As with all windows, the dialog's _OnPaint_ function is called only if some part of the dialog is invalidated. You can force the _OnPaint_ call from another dialog member function with the following statement:

Invalidate();
________________________________________________________________________
5.4.9. - [Adding Dialog Controls at Runtime](invcpp5/ch06j.htm)
----------------------------------------------------
 Adding Dialog Controls at Runtime 

Adding Dialog Controls at Runtime
=================================

You've seen how to use the resource editor to create dialog controls at build time. If you need to add a dialog control at runtime, here are the programming steps:

2.  Add an embedded control window data member to your dialog class. The MFC control window classes include _CButton_, _CEdit_, _CListBox_, and _CComboBox_. An embedded control C++ object is constructed and destroyed along with the dialog object.
    
3.  Choose Resource Symbols from Visual C++'s View menu. Add an ID constant for the new control.
    
4.  Use ClassWizard to map the WM_INITDIALOG message, thus overriding _CDialog::OnInitDialog_. This function should call the embedded control window's _Create_ member function. This call displays the new control in the dialog. Windows will destroy the control window when it destroys the dialog window.
    
5.  In your derived dialog class, manually add the necessary notification message handlers for your new control.
    

In [Chapter 13](ch13a.htm), you'll be adding a rich edit control to a view at runtime.
________________________________________________________________________
5.4.10. - [Using Other Control Features](invcpp5/ch06k.htm)
----------------------------------------------------
 Using Other Control Features 

Using Other Control Features
============================

You've seen how to customize the control class _CScrollBar_ by adding code in the dialog's _OnInitDialog_ member function. You can program other controls in a similar fashion. In the _Microsoft Visual C++ MFC Library Reference,_ or in the online help under "Microsoft Foundation Class Libary and Templates," look at the control classes, particularly _CListBox_ and _CComboBox_. Each has a number of features that ClassWizard does not directly support. Some combo boxes, for example, can support multiple selections. If you want to use these features, don't try to use ClassWizard to add data members. Instead, define your own data members and add your own exchange code in _OnInitDialog_ and _OnClickedOK_.

> **For Win32 Programmers**
> 
> If you've programmed controls in Win32, you'll know that parent windows communicate to controls via Windows messages. So what does a function such as _CListBox::InsertString_ do? (You've seen this function called in your _OnInitDialog_ function.) If you look at the MFC source code, you'll see that _InsertString_ sends an LB_INSERTSTRING message to the designated list-box control. Other control class member functions don't send messages because they apply to all window types. The _CScrollView::SetScrollRange_ function, for example, calls the Win32 _SetScrollRange_ function, specifying the correct _hWnd_ as a parameter.
________________________________________________________________________
5.4.11. - [Windows Common Controls](invcpp5/ch06l.htm)
----------------------------------------------------
 Windows Common Controls 

Windows Common Controls
=======================

The controls you used in EX06A are great learning controls because they're easy to program. Now you're ready for some more "interesting" controls. We'll take a look at some important new Windows controls, introduced for Microsoft Windows 95 and available in Microsoft Windows NT. These include the progress indicator, trackbar, spin button control, list control, and tree control.

The code for these controls is in the Windows COMCTL32.DLL file. This code includes the window procedure for each control, together with code that registers a window class for each control. The registration code is called when the DLL is loaded. When your program initializes a dialog, it uses the symbolic class name in the dialog resource to connect to the window procedure in the DLL. Thus your program owns the control's window, but the code is in the DLL. Except for ActiveX controls, most controls work this way.

Example EX06B uses the aforementioned controls. Figure 6-2 shows the dialog from that example. Refer to it when you read the control descriptions that follow.

Be aware that ClassWizard offers no member variable support for the common controls. You'll have to add code to your _OnInitDialog_ and _OnOK_ functions to initialize and read control data. ClassWizard will, however, allow you to map notification messages from common controls.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F06OG02x.gif)]

**Figure 6-2.** _The Windows Common Controls Dialog example._

The Progress Indicator Control
------------------------------

The progress indicator is the easiest common control to program and is represented by the MFC _CProgressCtrl_ class. It is generally used only for output. This control, together with the trackbar, can effectively replace the scroll bar controls you saw in the previous example. To initialize the progress indicator, call the _SetRange_ and _SetPos_ member functions in your _OnInitDialog_ function, and then call _SetPos_ anytime in your message handlers. The progress indicator shown in Figure 6-2 has a range of 0 to 100, which is the default range.

The Trackbar Control
--------------------

The trackbar control (class _CSliderCtrl_), sometimes called a slider, allows the user to set an "analog" value. (Trackbars would have been more effective than sliders for Loyalty and Reliability in the EX06A example.) If you specify a large range for this control—0 to 100 or more, for example—the trackbar's motion appears continuous. If you specify a small range, such as 0 to 5, the tracker moves in discrete increments. You can program tick marks to match the increments. In this discrete mode, you can use a trackbar to set such items as the display screen resolution, lens f-stop values, and so forth. The trackbar does not have a default range.

The trackbar is easier to program than the scroll bar because you don't have to map the WM_HSCROLL or WM_VSCROLL messages in the dialog class. As long as you set the range, the tracker moves when the user slides it or clicks in the body of the trackbar. You might choose to map the scroll messages anyway if you want to show the position value in another control. The _GetPos_ member function returns the current position value. The top trackbar in Figure 6-2 operates continuously in the range 0 to 100. The bottom trackbar has a range of 0 to 4, and those indexes are mapped to a series of double-precision values (4.0, 5.6, 8.0, 11.0, and 16.0).

The Spin Button Control
-----------------------

The spin button control (class _CSpinButtonCtrl_) is an itsy-bitsy scroll bar that's most often used in conjunction with an edit control. The edit control, located just ahead of the spin control in the dialog's tabbing order, is known as the spin control's buddy. The idea is that the user holds down the left mouse button on the spin control to raise or lower the value in the edit control. The spin speed accelerates as the user continues to hold down the mouse button.

If your program uses an integer in the buddy, you can avoid C++ programming almost entirely. Just use ClassWizard to attach an integer data member to the edit control, and set the spin control's range in the _OnInitDialog_ function. (You probably won't want the spin control's default range, which runs backward from a minimum of 100 to a maximum of 0.) Don't forget to select Auto Buddy and Set Buddy Integer in the spin control's Styles property page. You can call the _SetRange_ and _SetAccel_ member functions in your _OnInitDialog_ function to change the range and the acceleration profile.

If you want your edit control to display a noninteger, such as a time or a floating-point number, you must map the spin control's WM_VSCROLL (or WM_HSCROLL) messages and write handler code to convert the spin control's integer to the buddy's value.

The List Control
----------------

Use the list control (class _CListCtrl_) if you want a list that contains images as well as text. Figure 6-2 shows a list control with a "list" view style and small icons. The elements are arranged in a grid, and the control includes horizontal scrolling. When the user selects an item, the control sends a notification message, which you map in your dialog class. That message handler can determine which item the user selected. Items are identified by a zero-based integer index.

Both the list control and the tree control get their graphic images from a common control element called an image list (class _CImageList_). Your program must assemble the image list from icons or bitmaps and then pass an image list pointer to the list control. Your _OnInitDialog_ function is a good place to create and attach the image list and to assign text strings. The _InsertItem_ member function serves this purpose.

List control programming is straightforward if you stick with strings and icons. If you implement drag and drop or if you need custom owner-drawn graphics, you've got more work to do.

The Tree Control
----------------

You're already familiar with tree controls if you've used Microsoft Windows Explorer or Visual C++'s Workspace view. The MFC _CTreeCtrl_ class makes it easy to add this same functionality to your own programs. Figure 6-2 illustrates a tree control that shows a modern American combined family. The user can expand and collapse elements by clicking the + and - buttons or by double-clicking the elements. The icon next to each item is programmed to change when the user selects the item with a single click.

The list control and the tree control have some things in common: they can both use the same image list, and they share some of the same notification messages. Their methods of identifying items are different, however. The tree control uses an _HTREEITEM_ handle instead of an integer index. To insert an item, you call the _InsertItem_ member function, but first you must build up a _TV_INSERTSTRUCT_ structure that identifies (among other things) the string, the image list index, and the handle of the parent item (which is null for top-level items).

As with list controls, infinite customization possibilities are available for the tree control. For example, you can allow the user to edit items and to insert and delete items.

The WM_NOTIFY Message
----------------------

The original Windows controls sent their notifications in WM_COMMAND messages. The standard 32-bit _wParam_ and _lParam_ message parameters are not sufficient, however, for the information that a common control needs to send to its parent. Microsoft solved this "bandwidth" problem by defining a new message, WM_NOTIFY. With the WM_NOTIFY message, _wParam_ is the control ID and _lParam_ is a pointer to an _NMHDR_ structure, which is managed by the control. This C structure is defined by the following code:

typedef struct tagNMHDR {
    HWND hwndFrom; // handle to control sending the message
    UINT idFrom;   // ID of control sending the message
    UINT code;     // control-specific notification code
} NMHDR;

Many controls, however, send WM_NOTIFY messages with pointers to structures larger than _NMHDR_. Those structures contain the three members above plus appended control-specific members. Many tree control notifications, for example, pass a pointer to an _NM_TREEVIEW_ structure that contains _TV_ITEM_ structures, a drag point, and so forth. When ClassWizard maps a WM_NOTIFY message, it generates a pointer to the appropriate structure.
________________________________________________________________________
5.4.12. - [The EX06B Example](invcpp5/ch06m.htm)
----------------------------------------------------
 The EX06B Example 

The EX06B Example
=================

I won't try to contrive a business-oriented example that uses all the custom controls. I'll just slap the controls in a modal dialog and trust that you'll see what's going on. The steps are shown below. After step 3, the instructions are oriented to the individual controls rather than to the Visual C++ components you'll be using.

2.  **Run AppWizard to generate the EX06B project.** Choose New from Visual C++'s File menu, and then select Microsoft AppWizard (exe) from the Projects page. Accept all the defaults but two: select Single Document and deselect Printing And Print Preview. The options and the default class names are shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG18x.Gif)
    
3.  **Create a new dialog resource with ID _IDD_DIALOG1_.** Place the controls as shown back in Figure 6-2.
    
    You can select the controls from the control palette. The following table lists the control types and their IDs.
    
    Don't worry about the other properties now—you'll set those in the following steps. (Some controls might look different than they do in Figure 6-2 until you set their properties.) Set the tab order as shown next.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG19x.gif)]
    
    **Tab Sequence**
    
    **Control Type**
    
    **Child Window ID**
    
    1
    
    Static
    
    _IDC_STATIC_
    
    2
    
    Progress
    
    _IDC_PROGRESS1_
    
    3
    
    Static
    
    _IDC_STATIC_
    
    4
    
    Trackbar (Slider)
    
    _IDC_TRACKBAR1_
    
    5
    
    Static
    
    _IDC_STATIC_TRACK1_
    
    6
    
    Static
    
    _IDC_STATIC_
    
    7
    
    Trackbar (Slider)
    
    _IDC_TRACKBAR2_
    
    8
    
    Static
    
    _IDC_STATIC_TRACK2_
    
    9
    
    Static
    
    _IDC_STATIC_
    
    10
    
    Edit
    
    _IDC_BUDDY_SPIN1_
    
    11
    
    Spin
    
    _IDC_SPIN1_
    
    12
    
    Static
    
    _IDC_STATIC_
    
    13
    
    Static
    
    _IDC_STATIC_
    
    14
    
    List control
    
    _IDC_LISTVIEW1_
    
    15
    
    Static
    
    _IDC_STATIC_LISTVIEW1_
    
    16
    
    Static
    
    _IDC_STATIC_
    
    17
    
    Tree control
    
    _IDC_TREEVIEW1_
    
    18
    
    Static
    
    _IDC_STATIC_TREEVIEW1_
    
    19
    
    Pushbutton
    
    _IDOK_
    
    20
    
    Pushbutton
    
    _IDCANCEL_
    
4.  **Use ClassWizard to create a new class, _CEx06bDialog_, derived from _CDialog_.** ClassWizard will automatically prompt you to create this class because it knows that the _IDD_DIALOG1_ resource exists without an associated C++ class. Map the WM_INITDIALOG message, the WM_HSCROLL message, and the WM_VSCROLL message.
    
5.  **Program the progress control.** Because ClassWizard won't generate a data member for this control, you must do it yourself. Add a public integer data member named _m_nProgress_ in the _CEx06bDialog_ class header, and set it to 0 in the constructor. Also, add the following code in the _OnInitDialog_ member function:
    
    **CProgressCtrl\* pProg = 
        (CProgressCtrl\*) GetDlgItem(IDC_PROGRESS1);
    pProg->SetRange(0, 100);
    pProg->SetPos(m_nProgress);
    ** 
    
6.  **Program the "continuous" trackbar control.** Add a public integer data member named _m_nTrackbar1_ to the _CEx06bDialog_ header, and set it to 0 in the constructor. Next add the following code in the _OnInitDialog_ member function to set the trackbar's range, to initialize its position from the data member, and to set the neighboring static control to the tracker's current value.
    
    **CString strText1;
    CSliderCtrl\* pSlide1 = 
        (CSliderCtrl\*) GetDlgItem(IDC_TRACKBAR1);
    pSlide1->SetRange(0, 100);
    pSlide1->SetPos(m_nTrackbar1);
    strText1.Format("%d", pSlide1->GetPos());
    SetDlgItemText(IDC_STATIC_TRACK1, strText1);** 
    
    To keep the static control updated, you need to map the WM_HSCROLL message that the trackbar sends to the dialog. Here is the code for the handler:
    
    void CEx06bDialog::OnHScroll(UINT nSBCode, UINT nPos,
                                 CScrollBar\* pScrollBar)
    {
        **CSliderCtrl\* pSlide = (CSliderCtrl\*) pScrollBar;
        CString strText;
        strText.Format("%d", pSlide->GetPos());
        SetDlgItemText(IDC_STATIC_TRACK1, strText);** 
    }
    
    Finally, you need to update the trackbar's _m_nTrackbar1_ data member when the user clicks OK. Your natural instinct would be to put this code in the _OnOK_ button handler. You would have a problem, however, if a data exchange validation error occurred involving any other control in the dialog. Your handler would set _m_nTrackbar1_ even though the user might choose to cancel the dialog. To avoid this problem, add your code in the _DoDataExchange_ function as shown below. If you do your own validation and detect a problem, call the _CDataExchange::Fail_ function, which alerts the user with a message box.
    
    **if (pDX->m_bSaveAndValidate) {
        TRACE("updating trackbar data members\n");
        CSliderCtrl\* pSlide1 =
            (CSliderCtrl\*) GetDlgItem(IDC_TRACKBAR1);
        m_nTrackbar1 = pSlide1->GetPos();
    
    }
    ** 
    
7.  **Program the "discrete" trackbar control.** Add a public integer data member named _m_nTrackbar2_ to the _CEx06bDialog_ header, and set it to 0 in the constructor. This data member is a zero-based index into the _dValue_, the array of numbers (4.0, 5.6, 8.0, 11.0, and 16.0) that the trackbar can represent. Define _dValue_ as a private static double array member variable in ex06bDialog.h, and add to ex06bDialog.cpp the following line:
    
    **double CEx06bDialog::dValue[5] = {4.0, 5.6, 8.0, 11.0, 16.0};** 
    
    Next add code in the _OnInitDialog_ member function to set the trackbar's range and initial position.
    
    **CString strText2;
    CSliderCtrl\* pSlide2 = 
        (CSliderCtrl\*) GetDlgItem(IDC_TRACKBAR2);
    pSlide2->SetRange(0, 4);
    pSlide2->SetPos(m_nTrackbar2);
    strText2.Format("%3.1f", dValue[pSlide2->GetPos()]);
    SetDlgItemText(IDC_STATIC_TRACK2, strText2);** 
    
    If you had only one trackbar, the WM_HSCROLL handler in step 5 would work. But because you have two trackbars that send WM_HSCROLL messages, the handler must differentiate. Here is the new code:
    
    void CEx06bDialog::OnHScroll(UINT nSBCode, UINT nPos,
                                 CScrollBar\* pScrollBar)
    {
        CSliderCtrl\* pSlide = (CSliderCtrl\*) pScrollBar;
        CString strText;
    
        **// Two trackbars are sending
        //  HSCROLL messages (different processing)
        switch(pScrollBar->GetDlgCtrlID()) {
        case IDC_TRACKBAR1:** 
            strText.Format("%d", pSlide->GetPos());
            SetDlgItemText(IDC_STATIC_TRACK1, strText);
            **break;
        case IDC_TRACKBAR2:
            strText.Format("%3.1f", dValue[pSlide->GetPos()]);
            SetDlgItemText(IDC_STATIC_TRACK2, strText);
            break;
        }** 
    }
    
    This trackbar needs tick marks, so you must check the control's Tick Marks and Auto Ticks properties back in the dialog editor. With Auto Ticks set, the trackbar will place a tick at every increment. The same data exchange considerations applied to the previous trackbar apply to this trackbar. Add the following code in the dialog class _DoDataExchange_ member function inside the block for the _if_ statement you added in the previous step:
    
    **CSliderCtrl\* pSlide2 =
        (CSliderCtrl\*) GetDlgItem(IDC_TRACKBAR2);
    m_nTrackbar2 = pSlide2->GetPos();** 
    
    Use the dialog editor to set the Point property of both trackbars to Bottom/Right. Select Right for the Align Text property of both the _IDC_STATIC_TRACK1_ and _IDC_STATIC_TRACK2_ static controls.
    
8.  **Program the spin button control.** The spin control depends on its buddy edit control, located immediately before it in the tab order. Use ClassWizard to add a double-precision data member called _m_dSpin_ for the _IDC_BUDDY_SPIN1_ edit control. We're using a _double_ instead of an _int_ because the _int_ would require almost no programming, and that would be too easy. We want the edit control range to be 0.0 to 10.0, but the spin control itself needs an integer range. Add the following code to _OnInitDialog_ to set the spin control range to 0 to 100 and to set its initial value to _m_dSpin \* 10.0_:
    
    **CSpinButtonCtrl\* pSpin =
        (CSpinButtonCtrl\*) GetDlgItem(IDC_SPIN1);
    pSpin->SetRange(0, 100);
    pSpin->SetPos((int) (m_dSpin \* 10.0));** 
    
    To display the current value in the buddy edit control, you need to map the WM_VSCROLL message that the spin control sends to the dialog. Here's the code:
    
    void CEx06bDialog::OnVScroll(UINT nSBCode, UINT nPos, 
                                 CScrollBar\* pScrollBar) 
    {
        **if (nSBCode == SB_ENDSCROLL) {
            return; // Reject spurious messages
        }
        // Process scroll messages from IDC_SPIN1 only
        if (pScrollBar->GetDlgCtrlID() == IDC_SPIN1) {
            CString strValue;
            strValue.Format("%3.1f", (double) nPos / 10.0);
            ((CSpinButtonCtrl\*) pScrollBar)->GetBuddy()
                                           ->SetWindowText(strValue);
        }** 
    }
    
    There's no need for you to add code in _OnOK_ or in _DoDataExchange_ because the dialog data exchange code processes the contents of the edit control. In the dialog editor, select the spin control's Auto Buddy property and the buddy's Read-only property.
    
9.  **Set up an image list.** Both the list control and the tree control need an image list, and the image list needs icons.
    
    First use the graphics editor to add icons to the project's RC file. On the companion CD-ROM, these icons are circles with black outlines and different-colored interiors. Use fancier icons if you have them. You can import an icon by choosing Resource from the Insert menu and then clicking the Import button. For this example, the icon resource IDs are as follows.
    
    **Resource ID**
    
    **Icon File**
    
    _IDI_BLACK_
    
    Icon1
    
    _IDI_BLUE_
    
    Icon3
    
    _IDI_CYAN_
    
    Icon5
    
    _IDI_GREEN_
    
    Icon7
    
    _IDI_PURPLE_
    
    Icon6
    
    _IDI_RED_
    
    Icon2
    
    _IDI_WHITE_
    
    Icon0
    
    _IDI_YELLOW_
    
    Icon4
    
    Next add a private _CImageList_ data member called _m_imageList_ in the _CEx06bDialog_ class header, and then add the following code to _OnInitDialog_:
    
    **HICON hIcon[8];
    int n;
    m_imageList.Create(16, 16, 0, 8, 8); // 32, 32 for large icons
    hIcon[0] = AfxGetApp()->LoadIcon(IDI_WHITE);
    hIcon[1] = AfxGetApp()->LoadIcon(IDI_BLACK);
    hIcon[2] = AfxGetApp()->LoadIcon(IDI_RED);
    hIcon[3] = AfxGetApp()->LoadIcon(IDI_BLUE);
    hIcon[4] = AfxGetApp()->LoadIcon(IDI_YELLOW);
    hIcon[5] = AfxGetApp()->LoadIcon(IDI_CYAN);
    hIcon[6] = AfxGetApp()->LoadIcon(IDI_PURPLE);
    hIcon[7] = AfxGetApp()->LoadIcon(IDI_GREEN);
    for (n = 0; n < 8; n++) {
        m_imageList.Add(hIcon[n]);
    }
    ** 
    
    > **About Icons**
    > 
    > You probably know that a bitmap is an array of bits that represent pixels on the display. (You'll learn more about bitmaps in [Chapter 11](ch11a.htm).) In Windows, an icon is a "bundle" of bitmaps. First of all, an icon has different bitmaps for different sizes. Typically, small icons are 16-by-16 pixels and large icons are 32-by-32 pixels. Within each size are two separate bitmaps: one 4-bit-per-pixel bitmap for the color image and one monochrome (1-bit-per-pixel) bitmap for the "mask." If a mask bit is 0, the corresponding image pixel represents an opaque color. If the mask bit is 1, an image color of black (0) means that the pixel is transparent and an image color of white (0xF) means that the background color is inverted at the pixel location. Windows 95 and Windows NT seem to process inverted colors a little differently than Windows 3.x does—the inverted pixels show up transparent against the desktop, black against a Windows Explorer window background, and white against list and tree control backgrounds. Don't ask me why.
    > 
    > Small icons were new with Windows 95. They're used in the task bar, in Windows Explorer, and in your list and tree controls, if you want them there. If an icon doesn't have a 16-by-16-pixel bitmap, Windows manufactures a small icon out of the 32-by-32-pixel bitmap, but it won't be as neat as one you draw yourself.
    > 
    > The graphics editor lets you create and edit icons. Look at the color palette shown here.
    > 
    > ![](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG20.GIF)
    > 
    > The top square in the upper-left portion shows you the main color for brushes, shape interiors, and so on, and the square under it shows the border color for shape outlines. You select a main color by left-clicking on a color, and you select a border color by right-clicking on a color. Now look at the top center portion of the color palette. You click on the upper "monitor" to paint transparent pixels, which are drawn in dark cyan. You click on the lower monitor to paint inverted pixels, which are drawn in red.
    
10.  **Program the list control.** In the dialog editor, set the list control's style attributes as shown in the next illustration.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG21.GIF)
    
    Make sure the Border style on the More Styles page is set. Next add the following code to _OnInitDialog_:
    
    **static char\* color[] = {"white", "black", "red",
                            "blue", "yellow", "cyan",
                            "purple", "green"};
    CListCtrl\* pList = 
        (CListCtrl\*) GetDlgItem(IDC_LISTVIEW1);
    pList->SetImageList(&m_imageList, LVSIL_SMALL); 
    for (n = 0; n < 8; n++) {
        pList->InsertItem(n, color[n], n); 
    }
    pList->SetBkColor(RGB(0, 255, 255)); // UGLY!
    pList->SetTextBkColor(RGB(0, 255, 255));** 
    
    As the last two lines illustrate, you don't use the WM_CTLCOLOR message with common controls; you just call a function to set the background color. As you'll see when you run the program, however, the icons' inverse-color pixels look shabby.
    
    If you use ClassWizard to map the list control's LVN_ITEMCHANGED notification message, you'll be able to track the user's selection of items. The code in the following handler displays the selected item's text in a static control:
    
    void CEx06bDialog::OnItemchangedListview1(NMHDR\* pNMHDR,
                                              LRESULT\* pResult)
    {
        NM_LISTVIEW\* pNMListView = (NM_LISTVIEW\*)pNMHDR;
        **CListCtrl\* pList =
            (CListCtrl\*) GetDlgItem(IDC_LISTVIEW1);
        int nSelected = pNMListView->iItem;
        if (nSelected >= 0) {
            CString strItem = pList->GetItemText(nSelected, 0);
            SetDlgItemText(IDC_STATIC_LISTVIEW1, strItem);
        }** 
        \*pResult = 0;
    }
    
    The _NM_LISTVIEW_ structure has a data member called _iItem_ that contains the index of the selected item.
    
11.  **Program the tree control.** In the dialog editor, set the tree control's style attributes as shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G06OG22.GIF)
    
    Next, add the following lines to _OnInitDialog_:
    
    **CTreeCtrl\* pTree = (CTreeCtrl\*) GetDlgItem(IDC_TREEVIEW1);
    pTree->SetImageList(&m_imageList, TVSIL_NORMAL);
    // tree structure common values
    TV_INSERTSTRUCT tvinsert;
    tvinsert.hParent = NULL;
    tvinsert.hInsertAfter = TVI_LAST;
    tvinsert.item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE |
                         TVIF_TEXT;
    tvinsert.item.hItem = NULL; 
    tvinsert.item.state = 0;
    tvinsert.item.stateMask = 0;
    tvinsert.item.cchTextMax = 6;
    tvinsert.item.iSelectedImage = 1;
    tvinsert.item.cChildren = 0;
    tvinsert.item.lParam = 0;
    // top level
    tvinsert.item.pszText = "Homer";
    tvinsert.item.iImage = 2;
    HTREEITEM hDad = pTree->InsertItem(&tvinsert);
    tvinsert.item.pszText = "Marge";
    HTREEITEM hMom = pTree->InsertItem(&tvinsert);
    // second level     
    tvinsert.hParent = hDad;
    tvinsert.item.pszText = "Bart";
    tvinsert.item.iImage = 3;
    pTree->InsertItem(&tvinsert);
    tvinsert.item.pszText = "Lisa";
    pTree->InsertItem(&tvinsert);
    // second level
    tvinsert.hParent = hMom;
    tvinsert.item.pszText = "Bart";
    tvinsert.item.iImage = 4;
    pTree->InsertItem(&tvinsert);
    tvinsert.item.pszText = "Lisa";
    pTree->InsertItem(&tvinsert);
    tvinsert.item.pszText = "Dilbert";
    HTREEITEM hOther = pTree->InsertItem(&tvinsert);
    // third level
    tvinsert.hParent = hOther;
    tvinsert.item.pszText = "Dogbert";
    tvinsert.item.iImage = 7;
    pTree->InsertItem(&tvinsert);
    tvinsert.item.pszText = "Ratbert";
    pTree->InsertItem(&tvinsert);** 
    
    As you can see, this code sets TV_INSERTSTRUCT text and image indexes and calls _InsertItem_ to add nodes to the tree.
    
    Finally, use ClassWizard to map the TVN_SELCHANGED notification for the tree control. Here is the handler code to display the selected text in a static control:
    
    void CEx06bDialog::OnSelchangedTreeview1(NMHDR\* pNMHDR,
                                             LRESULT\* pResult)
    {
        NM_TREEVIEW\* pNMTreeView = (NM_TREEVIEW\*)pNMHDR;
        **CTreeCtrl\* pTree = (CTreeCtrl\*) GetDlgItem(IDC_TREEVIEW1);
        HTREEITEM hSelected = pNMTreeView->itemNew.hItem;
        if (hSelected != NULL) {
            char text[31];
            TV_ITEM item;
            item.mask = TVIF_HANDLE | TVIF_TEXT;
            item.hItem = hSelected;
            item.pszText = text;
            item.cchTextMax = 30;
            VERIFY(pTree->GetItem(&item));
            SetDlgItemText(IDC_STATIC_TREEVIEW1, text);
        }** 
        \*pResult = 0;
    }
    
    The _NM_TREEVIEW_ structure has a data member called _itemNew_ that contains information about the selected node; _itemNew.hItem_ is the handle of that node. The _GetItem_ function retrieves the node's data, storing the text using a pointer supplied in the _TV_ITEM_ structure. The _mask_ variable tells Windows that the _hItem_ handle is valid going in and that text output is desired.
    
12.  **Add code to the virtual _OnDraw_ function in file ex06bView.cpp.** The following boldface code replaces the previous code:
    
    void CEx06bView::OnDraw(CDC\* pDC)
    {
        **pDC->TextOut(0, 0, "Press the left mouse button here.");** 
    }
    
13.  **Use ClassWizard to add the _OnLButtonDown_ member function.** Edit the AppWizard-generated code as follows:
    
    void CEx06bView::OnLButtonDown(UINT nFlags, CPoint point)
    {
        **CEx06bDialog dlg;
    
        dlg.m_nTrackbar1 = 20;
        dlg.m_nTrackbar2 = 2; // index for 8.0
        dlg.m_nProgress = 70; // write-only
        dlg.m_dSpin = 3.2;
    
        dlg.DoModal();** 
    }
    
    Add a statement to include ex06bDialog.h in file ex06bView.cpp.
    
14.  **Compile and run the program.** Experiment with the controls to see how they work. We haven't added code to make the progress indicator functional; we'll cover that in [Chapter 12](ch12a.htm).

Other Windows Common Controls
-----------------------------

You've seen most of the common controls that appear on the dialog editor control palette. We've skipped the animation control because this book doesn't cover multimedia, and we've skipped the hot key control because it isn't very interesting. The tab control is interesting, but you seldom use it inside another dialog. [Chapter 13](ch13a.htm) shows you how to construct a tabbed dialog, sometimes known as a property sheet. In [Chapter 13](ch13a.htm), you'll also see an application that is built around the _CRichEditView_ class, which incorporates the Windows rich edit control.
________________________________________________________________________
5.5. - [Chapter 7 -- The Modeless Dialog and Windows Common Dialogs](invcpp5/ch07a.htm)
----------------------------------------------------
 Chapter 7 -- The Modeless Dialog and Windows Common Dialogs  Chapter 7

The Modeless Dialog and Windows Common Dialogs
==============================================

In [Chapter 6](ch06a.htm), you saw the ordinary modal dialog and most of the controls for Microsoft Windows. Now you'll move on to the modeless dialog and to the common dialogs for Microsoft Windows 95 and Microsoft Windows NT versions 4.0 and later. Modeless dialogs, as you'll remember, allow the user to work elsewhere in the application while the dialog is active. The common dialog classes are the C++ programming interface to the group of Windows utility dialogs that include File Open, Page Setup, Color, and so forth and that are supported by the dynamic link library COMDLG32.DLL.

In this chapter's first example, you'll build a simple modeless dialog that is controlled from a view. In the second example, you'll derive from the COMDLG32 _CFileDialog_ class a class that allows file deletion.
________________________________________________________________________
5.5.1. - [Modeless Dialogs](invcpp5/ch07b.htm)
----------------------------------------------------
 Modeless Dialogs 

Modeless Dialogs
================

In the Microsoft Foundation Class (MFC) Library version 6.0, modal and modeless dialogs share the same base class, _CDialog_, and they both use a dialog resource that you can build with the dialog editor. If you're using a modeless dialog with a view, you'll need to know some specialized programming techniques.

Creating Modeless Dialogs
-------------------------

For modal dialogs, you've already learned that you construct a dialog object using a _CDialog_ constructor that takes a resource template ID as a parameter, and then you display the modal dialog window by calling the _DoModal_ member function. The window ceases to exist as soon as _DoModal_ returns. Thus, you can construct a modal dialog object on the stack, knowing that the dialog window has been destroyed by the time the C++ dialog object goes out of scope.

Modeless dialogs are more complicated. You start by invoking the _CDialog_ default constructor to construct the dialog object, but then to create the dialog window you need to call the _CDialog::Create_ member function instead of _DoModal_. _Create_ takes the resource ID as a parameter and returns immediately with the dialog window still on the screen. You must worry about exactly when to construct the dialog object, when to create the dialog window, when to destroy the dialog, and when to process user-entered data.

Here's a summary of the differences between creating a modal dialog and a modeless dialog.

 

**Modal Dialog**

**Modeless Dialog**

**Constructor used**

Constructor with resource ID param

Default constructor (no params)

**Function used to create window**

_DoModal_

_Create_ with resource ID param

User-Defined Messages
---------------------

Suppose you want the modeless dialog window to be destroyed when the user clicks the dialog's OK button. This presents a problem. How does the view know that the user has clicked the OK button? The dialog could call a view class member function directly, but that would "marry" the dialog to a particular view class. A better solution is for the dialog to send the view a user-defined message as the result of a call to the OK button message-handling function. When the view gets the message, it can destroy the dialog window (but not the object). This sets the stage for the creation of a new dialog.

You have two options for sending Windows messages: the _CWnd::SendMessage_ function or the _PostMessage_ function. The former causes an immediate call to the message-handling function, and the latter posts a message in the Windows message queue. Because there's a slight delay with the _PostMessage_ option, it's reasonable to expect that the handler function has returned by the time the view gets the message.

Dialog Ownership
----------------

Now suppose you've accepted the dialog default pop-up style, which means that the dialog isn't confined to the view's client area. As far as Windows is concerned, the dialog's "owner" is the application's main frame window (introduced in [Chapter 13](ch13a.htm)), not the view. You need to know the dialog's view to send the view a message. Therefore, your dialog class must track its own view through a data member that the constructor sets. The _CDialog_ constructor's _pParent_ parameter doesn't have any effect here, so don't bother using it.

A Modeless Dialog Example—EX07A
-------------------------------

We could convert the [Chapter 6](ch06a.htm) monster dialog to a modeless dialog, but starting from scratch with a simpler dialog is easier. Example EX07A uses a dialog with one edit control, an OK button, and a Cancel button. As in the [Chapter 6](ch06a.htm) example, pressing the left mouse button while the mouse cursor is inside the view window brings up the dialog, but now we have the option of destroying it in response to another event—pressing the right mouse button when the mouse cursor is inside the view window. We'll allow only one open dialog at a time, so we must be sure that a second left button press doesn't bring up a duplicate dialog.

To summarize the upcoming steps, the EX07A view class has a single associated dialog object that is constructed on the heap when the view is constructed. The dialog window is created and destroyed in response to user actions, but the dialog object is not destroyed until the application terminates.

Here are the steps to create the EX07A example:

2.  **Run AppWizard to produce \vcpp32\ex07a\ex07a.** Accept all the defaults but two: select Single Document and deselect Printing And Print Preview. The options and the default class names are shown here.
    

![](c:/dl/books/windows/msvc5th/invcpp5/images/G07OG01x.gif)

3.  **Use the dialog editor to create a dialog resource.** Choose Resource from Visual C++'s Insert menu, and then select Dialog. The dialog editor assigns the ID _IDD_DIALOG1_ to the new dialog. Change the dialog caption to _Modeless Dialog_. Accept the default OK and Cancel buttons with IDs _IDOK_ and _IDCANCEL_, and then add a static text control and an edit control with the default ID _IDC_EDIT1_. Change the static text control's caption to _Edit 1_. Here is the completed dialog.
    

![](c:/dl/books/windows/msvc5th/invcpp5/images/G07OG02.GIF)

> NOTE
> 
> Be sure to select the dialog's Visible property.

4.  **Use ClassWizard to create the _CEx07aDialog_ class.** Choose ClassWizard from Microsoft Visual C++'s View menu. Fill in the New Class dialog as shown here, and then click the OK button.

![](c:/dl/books/windows/msvc5th/invcpp5/images/G07OG03.GIF)

Add the message-handling functions shown next. To add a message-handling function, click on an object ID, click on a message, and then click the Add Function button. The Add Member Function dialog box appears. Edit the function name if necessary, and click the OK button.

**Object ID**

**Message**

**Member Function**

_IDCANCEL_

BN_CLICKED

_OnCancel_

_IDOK_

BN_CLICKED

_OnOK_

5.  **Add a variable to the _CEx07aDialog_ class.** While in ClassWizard, click on the Member Variables tab, choose the _IDC_EDIT1_ control, and then click the Add Variable button to add the _CString_ variable _m_strEdit1_.
    
6.  **Edit ex07aDialog.h to add a view pointer and function prototypes.** Type in the following boldface code in the _CEx07aDialog_ class declaration:
    
    **private:
        CView\* m_pView;**
    
    Also, add the function prototypes as follows:
    
    **public:
        CEx07aDialog(CView\* pView);
        BOOL Create();**
    

> NOTE
> 
> Using the _CView_ class rather than the _CEx07aView_ class allows the dialog class to be used with any view class.

7.  **Edit ex07aDialog.h to define the WM_GOODBYE message ID.** Add the following line of code:
    
    **#define WM_GOODBYE     WM_USER + 5**
    
    The Windows constant WM_USER is the first message ID available for user-defined messages. The application framework uses a few of these messages, so we'll skip over the first five messages.
    

> NOTE
> 
> Visual C++ maintains a list of symbol definitions in your project's resource.h file, but the resource editor does not understand constants based on other constants. Don't manually add WM_GOODBYE to resource.h because Visual C++ might delete it.

8.  **Add the modeless constructor in the file ex07aDialog.cpp.** You could modify the existing _CEx07aDialog_ constructor, but if you add a separate one, the dialog class can serve for both modal and modeless dialogs. Add the lines shown below.
    
    **CEx07aDialog::CEx07aDialog(CView\* pView)  // modeless constructor
    {
        m_pView = pView;
    }**
    
    You should also add the following line to the AppWizard-generated modal constructor:
    
    **m_pView = NULL;**
    
    The C++ compiler is clever enough to distinguish between the modeless constructor _CEx07aDialog(CView\*)_ and the modal constructor _CEx07aDialog(CWnd\*)_. If the compiler sees an argument of class _CView_ or a derived _CView_ class, it generates a call to the modeless constructor. If it sees an argument of class _CWnd_ or another derived _CWnd_ class, it generates a call to the modal constructor.
    
9.  **Add the _Create_ function in ex07aDialog.cpp.** This derived dialog class _Create_ function calls the base class function with the dialog resource ID as a parameter. Add the following lines:
    
    **BOOL CEx07aDialog::Create()
    {
        return CDialog::Create(CEx07aDialog::IDD);
    }**
    

> NOTE
> 
> _Create_ is not a virtual function. You could have chosen a different name if you had wanted to.

10.  **Edit the _OnOK_ and _OnCancel_ functions in ex07aDialog.cpp.** These virtual functions generated by ClassWizard are called in response to dialog button clicks. Add the following boldface code:
    
    void CEx07aDialog::OnCancel()  **// not really a message handler**
    {
        **if (m_pView != NULL) {
            // modeless case -- do not call base class OnCancel
            m_pView->PostMessage(WM_GOODBYE, IDCANCEL);
        }
        else {
            CDialog::OnCancel(); // modal case
        }**
    }
    
    void CEx07aDialog::OnOK()      **// not really a message handler**
    {
        **if (m_pView != NULL) {
            // modeless case -- do not call base class OnOK
            UpdateData(TRUE);
            m_pView->PostMessage(WM_GOODBYE, IDOK);
        }
        else {
            CDialog::OnOK(); // modal case
        }**
    }
    
    If the dialog is being used as a modeless dialog, it sends the user-defined message WM___GOODBYE to the view. We'll worry about handling the message later.
    

> NOTE
> 
> For a modeless dialog, be sure you do not call the _CDialog::OnOK_ or _CDialog::OnCancel_ function. This means you must override these virtual functions in your derived class; otherwise, using the Esc key, the Enter key, or a button click would result in a call to the base class functions, which call the Windows _EndDialog_ function. _EndDialog_ is appropriate only for modal dialogs. In a modeless dialog, you must call _DestroyWindow_ instead, and if necessary, you must call _UpdateData_ to transfer data from the dialog controls to the class data members.

11.  **Edit the ex07aView.h header file.** You need a data member to hold the dialog pointer:
    
    **private:
        CEx07aDialog\* m_pDlg;**
    
    If you add the forward declaration
    
    **class CEx07aDialog;**
    
    at the beginning of ex07aView.h, you won't have to include ex07aDialog.h in every module that includes ex07aView.h.
    
12.  **Modify the _CEx07aView_ constructor and destructor in the file ex07aView.cpp.** The _CEx07aView_ class has a data member _m_pDlg_ that points to the view's _CEx07aDialog_ object. The view constructor constructs the dialog object on the heap, and the view destructor deletes it. Add the following boldface code:
    
    CEx07aView::CEx07aView()
    {
        **m_pDlg = new CEx07aDialog(this);**
    }
    
    CEx07aView::~CEx07aView()
    {
        **delete m_pDlg; // destroys window if not already destroyed**
    }
    
13.  **Add code to the virtual _OnDraw_ function in the ex07aView.cpp file.** The _CEx07aView OnDraw_ function (whose skeleton was generated by AppWizard) should be coded as follows in order to prompt the user to press the mouse button:
    
    void CEx07aView::OnDraw(CDC\* pDC)
    {
        **pDC->TextOut(0, 0, "Press the left mouse button here.");**
    }
    
14.  **Use ClassWizard to add _CEx07aView_ mouse message handlers.** Add handlers for the WM_LBUTTONDOWN and WM_RBUTTONDOWN messages. Now edit the code in file ex07aView.cpp as follows:
    
    void CEx07aView::OnLButtonDown(UINT nFlags, CPoint point)
    {
        **// creates the dialog if not created already
        if (m_pDlg->GetSafeHwnd() == 0) {
            m_pDlg->Create(); // displays the dialog window
        }**
    }
    
    void CEx07aView::OnRButtonDown(UINT nFlags, CPoint point)
    {
        **m_pDlg->DestroyWindow();
        // no problem if window was already destroyed**
    }
    
    For most window types except main frame windows, the _DestroyWindow_ function does not destroy the C++ object. We want this behavior because we'll take care of the dialog object's destruction in the view destructor.
    
15.  **Add the dialog header include statement to file ex07aView.cpp.** While you're in ex07aView.cpp, add the following dialog header include statement after the view header include statement:
    
    #include "ex07aView.h"
    **#include "ex07aDialog.h"**
    
16.  **Add your own message code for the WM_GOODBYE message.** Because ClassWizard does not support user-defined messages, you must write the code yourself. This task makes you appreciate the work ClassWizard does for the other messages.
    
    *   In ex07aView.cpp, add the following line after the _BEGIN_MESSAGE_MAP_ statement but outside the _AFX_MSG_MAP_ brackets:
        
        **ON_MESSAGE(WM_GOODBYE, OnGoodbye)**
        
    *   Also in ex07aView.cpp, add the message handler function itself:
        
        **LRESULT CEx07aView::OnGoodbye(WPARAM wParam, LPARAM lParam)
        {
            // message received in response to modeless dialog OK
            //  and Cancel buttons
            TRACE("CEx07aView::OnGoodbye %x, %lx\n", wParam, lParam);
            TRACE("Dialog edit1 contents = %s\n", 
                  (const char\*) m_pDlg->m_strEdit1);
            m_pDlg->DestroyWindow();
            return 0L;
        }**
        
    *   In ex07aView.h, add the following function prototype before the _DECLARE_MESSAGE_MAP()_ statement but outside the _AFX_ MSG_ brackets:
        
        **afx_msg LRESULT OnGoodbye(WPARAM wParam, LPARAM lParam);**
        
    
    With Win32, the _wParam_ and _lParam_ parameters are the usual means of passing message data. In a mouse button down message, for example, the mouse _x_ and _y_ coordinates are packed into the _lParam_ value. With the MFC library, message data is passed in more meaningful parameters. The mouse position is passed as a _CPoint_ object. User-defined messages must use _wParam_ and _lParam_, so you can use these two variables however you want. In this example, we've put the button ID in _wParam_.
    
17.  **Build and test the application.** Build and run EX07A. Press the left mouse button, and then press the right button. (Be sure the mouse cursor is outside the dialog window when you press the right mouse button.) Press the left mouse button again and enter some data, and then click the dialog's OK button. Does the view's _TRACE_ statement correctly list the edit control's contents?

> NOTE
> 
> If you use the EX07A view and dialog classes in an MDI application, each MDI child window can have one modeless dialog. When the user closes an MDI child window, the child's modeless dialog is destroyed because the view's destructor calls the dialog destructor, which, in turn, destroys the dialog window.
________________________________________________________________________
5.5.2. - [The CFormView Class -- A Modeless Dialog Alternative](invcpp5/ch07c.htm)
----------------------------------------------------
 The CFormView Class -- A Modeless Dialog Alternative 

The _CFormView_ Class—A Modeless Dialog Alternative
===================================================

If you need an application based on a single modeless dialog, the _CFormView_ class will save you a lot of work. You'll have to wait until [Chapter 16](ch16a.htm), however, because the _CFormView_ class is most useful when coupled with the _CDocument_ class, and we haven't progressed that far in our exploration of the application framework.
________________________________________________________________________
5.5.3. - [The Windows Common Dialogs](invcpp5/ch07d.htm)
----------------------------------------------------
 The Windows Common Dialogs 

The Windows Common Dialogs
==========================

Windows provides a group of standard user interface dialogs, and these are supported by the MFC library classes. You are probably familiar with all or most of these dialogs because so many Windows-based applications, including Visual C++, already use them. All the common dialog classes are derived from a common base class, _CCommonDialog_. A list of the COMDLG32 classes is shown in the following table.

**Class**

**Purpose**

_CColorDialog_

Allows the user to select or create a color

_CFileDialog_

Allows the user to open or save a file

_CFindReplaceDialog_

Allows the user to substitute one string for another

_CPageSetupDialog_

Allows the user to input page measurement parameters

_CFontDialog_

Allows the user to select a font from a list of available fonts

_CPrintDialog_

Allows the user to set up the printer and print a document

Here's one characteristic that all common dialogs share: they gather information from the user, but they don't do anything with it. The file dialog can help the user select a file to open, but it really just provides your program with the pathname—your program must make the call that opens the file. Similarly, a font dialog fills in a structure that describes a font, but it doesn't create the font.

Using the _CFileDialog_ Class Directly
--------------------------------------

Using the _CFileDialog_ class to open a file is easy. The following code opens a file that the user has selected through the dialog:

CFileDialog dlg(TRUE, "bmp", "\*.bmp");
if (dlg.DoModal() == IDOK) {
    CFile file;
    VERIFY(file.Open(dlg.GetPathName(), CFile::modeRead));
}

The first constructor parameter (_TRUE_) specifies that this object is a "File Open" dialog instead of a "File Save" dialog. The default file extension is _bmp_, and _\*.bmp_ appears first in the filename edit box. The _CFileDialog::GetPathName_ function returns a _CString_ object that contains the full pathname of the selected file.

Deriving from the Common Dialog Classes
---------------------------------------

Most of the time, you can use the common dialog classes directly. If you derive your own classes, you can add functionality without duplicating code. Each COMDLG32 dialog works a little differently, however. The next example is specific to the file dialog, but it should give you some ideas for customizing the other common dialogs.

> NOTE
> 
> In the early editions of this book, the EX07B example dynamically created controls inside the standard file dialog. That technique doesn't work in Win32, but the nested dialog method described here has the same effect.

Nested Dialogs
--------------

Win32 provides a way to "nest" one dialog inside another so that multiple dialogs appear as one seamless whole. You must first create a dialog resource template with a "hole" in it—typically a group box control—with the specific child window ID _stc32 (=0x045f)_. Your program sets some parameters that tell COMDLG32 to use your template. In addition, your program must hook into the COMDLG32 message loop so that it gets first crack at selected notifications. When you're done with all of this, you'll notice that you have created a dialog window that is a child of the COMDLG32 dialog window, even though your template wraps COMDLG32's template.

This sounds difficult, and it is unless you use MFC. With MFC, you build the dialog resource template as described above, derive a class from one of the common dialog base classes, add the class-specific connection code in _OnInitDialog_, and then happily use ClassWizard to map the messages that originate from your template's new controls.

> NOTE
> 
> Windows NT 3.51 uses an earlier version of the common dialogs DLL that does not support the new Windows namespace feature. The nested dialog technique illustrated in the EX07B example won't work with the Windows NT 3.51 version of the file dialog.

A _CFileDialog_ Example—EX07B
-----------------------------

In this example, you will derive a class _CEx07bDialog_ that adds a working Delete All Matching Files button to the standard file dialog. It also changes the dialog's title and changes the Open button's caption to Delete (to delete a single file). The example illustrates how you can use nested dialogs to add new controls to standard common dialogs. The new file dialog is activated as in the previous examples—by pressing the left mouse button when the mouse cursor is in the view window. Because you should be gaining skill with Visual C++, the following steps won't be as detailed as those for the earlier examples. Figure 7-1 shows what the dialog looks like.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f07og01x.gif)]

**Figure 7-1.** _The Delete File dialog in action._

Follow these steps to build the EX07B application:

2.  **Run AppWizard to produce \vcpp32\ex07b\ex07b.** Accept all the defaults but two: select Single Document and deselect Printing And Print Preview. The options and the default class names are shown in the next graphic.
    

![](c:/dl/books/windows/msvc5th/invcpp5/images/G07OG04x.GIF)

3.  **Use the dialog editor to create a dialog resource.** Make the dialog box about 3-by-5 inches, and use the ID _IDD_FILESPECIAL_. Set the dialog's Style property to Child, its Border property to None, and select its Clip Siblings and Visible properties. Create the template with a button with ID _IDC_DELETE_ and a group box with ID _stc32=0x045f_, as shown here.
    

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G07OG05x.gif)]

Check your work by choosing Resource Symbols from the Visual C++ View menu. You should see a symbol list like the one shown in the graphic below.

![](c:/dl/books/windows/msvc5th/invcpp5/images/G07OG06.GIF)

4.  **Use ClassWizard to create the _CSpecialFileDialog_ class.** Fill in the New Class dialog, as shown here, and then click the Change button.

![](c:/dl/books/windows/msvc5th/invcpp5/images/G07OG07.GIF)

Change the names to SpecFileDlg.h and SpecFileDlg.cpp. Unfortunately, we cannot use the Base Class drop-down list to change the base class to _CFileDialog_, as that would decouple our class from the _IDD_FILESPECIAL_ template. We have to change the base class by hand.

6.  **Edit the file SpecFileDlg.h.** Change the line
    
    class CSpecialFileDialog : public CDialog
    
    to
    
    class CSpecialFileDialog : public C**File**Dialog
    
    Add the following two public data members:
    
    **CString m_strFilename;
    BOOL m_bDeleteAll;**
    
    Finally, edit the constructor declaration:
    
    CSpecialFileDialog(**BOOL bOpenFileDialog, 
        LPCTSTR lpszDefExt = NULL,
        LPCTSTR lpszFileName = NULL,
        DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
        LPCTSTR lpszFilter = NULL,
        CWnd\* pParentWnd = NULL**
    );
    
7.  **Replace _CDialog_ with _CFileDialog_ in SpecFileDlg.h.** Choose Replace from Visual C++'s Edit menu, and replace this name globally.
    
8.  **Edit the _CSpecialFileDialog_ constructor in SpecFileDlg.cpp.** The derived class destructor must invoke the base class constructor and initialize the _m_bDeleteAll_ data member. In addition, it must set some members of the _CFileDialog_ base class data member _m_ofn_, which is an instance of the Win32 _OPENFILENAME_ structure. The _Flags_ and _lpTemplateName_ members control the coupling to your _IDD_FILESPECIAL_ template, and the _lpstrTitle_ member changes the main dialog box title. Edit the constructor as follows:
    
    CSpecialFileDialog::CSpecialFileDialog(**BOOL bOpenFileDialog,
            LPCTSTR lpszDefExt, LPCTSTR lpszFileName, DWORD dwFlags,
            LPCTSTR lpszFilter, CWnd\* pParentWnd)
        : CFileDialog(bOpenFileDialog, lpszDefExt, lpszFileName,
            dwFlags, lpszFilter, pParentWnd)**
    {
        //{{AFX_DATA_INIT(CSpecialFileDialog)
            // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
        **m_ofn.Flags |= OFN_ENABLETEMPLATE;
        m_ofn.lpTemplateName = MAKEINTRESOURCE(IDD_FILESPECIAL);
        m_ofn.lpstrTitle = "Delete File";
        m_bDeleteAll = FALSE;**
    }
    
9.  **Map the WM_INITDIALOG message in the _CSpecialDialog_ class.** The _OnInitDialog_ member function needs to change the common dialog's Open button caption to Delete. The child window ID is _IDOK_.
    
    **BOOL bRet = CFileDialog::OnInitDialog();
    if (bRet == TRUE) {
        GetParent()->GetDlgItem(IDOK)->SetWindowText("Delete");
    }
    return bRet;**
    
10.  **Map the new IDC_DELETE button (Delete All Matching Files) in the _CSpecialDialog_ class.** The _OnDelete_ member function sets the _m_bDeleteAll_ flag and then forces the main dialog to exit as if the Cancel button had been clicked. The client program (in this case, the view) gets the _IDCANCEL_ return from _DoModal_ and reads the flag to see whether it should delete all files. Here is the function:
    
     void CSpecialFileDialog::OnDelete() 
    {
        **m_bDeleteAll = TRUE;
        // 0x480 is the child window ID of the File Name edit control
        //  (as determined by SPYXX)
        GetParent()->GetDlgItem(0x480)->GetWindowText(m_strFilename);
        GetParent()->SendMessage(WM_COMMAND, IDCANCEL);**
    }
    
11.  **Add code to the virtual _OnDraw_ function in file ex07bView.cpp.** The _CEx07bView OnDraw_ function (whose skeleton was generated by AppWizard) should be coded as follows to prompt the user to press the mouse button:
    
    void CEx07bView::OnDraw(CDC\* pDC)
    {
        **pDC->TextOut(0, 0, "Press the left mouse button here.");**
    }
    
12.  **Add the OnLButtonDown message handler to the _CEx07bView_ class.** Use ClassWizard to create the message handler for WM_LBUTTON-DOWN, and then edit the code as follows:
    
    void CEx07bView::OnLButtonDown(UINT nFlags, CPoint point) 
    {
        **CSpecialFileDialog dlgFile(TRUE, NULL, "\*.obj");
        CString strMessage;
        int nModal = dlgFile.DoModal();
        if ((nModal == IDCANCEL) && (dlgFile.m_bDeleteAll)) {
            strMessage.Format(
                "Are you sure you want to delete all %s files?",
                dlgFile.m_strFilename);
            if (AfxMessageBox(strMessage, MB_YESNO) == IDYES) {
                HANDLE h;
                WIN32_FIND_DATA fData;
                while((h = ::FindFirstFile(dlgFile.m_strFilename, &fData))
                        != (HANDLE) 0xFFFFFFFF) { // no MFC equivalent
                    if (::DeleteFile(fData.cFileName) == FALSE) {
                        strMessage.Format("Unable to delete file %s\n",
                            fData.cFileName);
                        AfxMessageBox(strMessage);
                        break;
                    }
                }
            }
        }
        else if (nModal == IDOK) {
            CString strSingleFilename = dlgFile.GetPathName();
            strMessage.Format(
                "Are you sure you want to delete %s?", strSingleFilename);
            if (AfxMessageBox(strMessage, MB_YESNO) == IDYES) {
                CFile::Remove(strSingleFilename);
            }
        }**
    }
    
    Remember that common dialogs just gather data. Since the view is the client of the dialog, the view must call _DoModal_ for the file dialog object and then figure out what to do with the information returned. In this case, the view has the return value from _DoModal_ (either _IDOK_ or _IDCANCEL_) and the value of the public _m_bDeleteAll_ data member, and it can call various _CFileDialog_ member functions such as _GetPathName_. If _DoModal_ returns _IDCANCEL_ and the flag is _TRUE_, the function makes the Win32 file system calls necessary to delete all the matching files. If _DoModal_ returns _IDOK_, the function can use the MFC _CFile_ functions to delete an individual file.
    
    Using the global _AfxMessageBox_ function is a convenient way to pop up a simple dialog that displays some text and then queries the user for a Yes/No answer. The _Microsoft Foundation_ _Classes And Templates_ section in the online help describes all of the message box variations and options.
    
    Of course, you'll need to include the statement
    
    **#include "SpecFileDlg.h"**
    
    after the line
    
    #include "ex07bView.h"
    
13.  **Build and test the application.**Build and run EX07B. Pressing the left mouse button should bring up the Delete File dialog, and you should be able to use it to navigate through the disk directory and to delete files. Be careful not to delete your important source files!

Other Customization for _CFileDialog_
-------------------------------------

In the EX07B example, you added a pushbutton to the dialog. It's easy to add other controls too. Just put them in the resource template, and if they are standard Windows controls such as edit controls or list boxes, you can use ClassWizard to add data members and DDX/DDV code to your derived class. The client program can set the data members before calling _DoModal_, and it can retrieve the updated values after _DoModal_ returns.

> NOTE
> 
> Even if you don't use nested dialogs, two windows are still associated with a _CFileDialog_ object. Suppose you have overridden _OnInitDialog_ in a derived class and you want to assign an icon to the file dialog. You must call _CWnd::GetParent_ to get the top-level window, just as you did in the EX07B example. Here's the code:
> 
> HICON hIcon = AfxGetApp()->LoadIcon(ID_MYICON);
> GetParent()->SetIcon(hIcon, TRUE);        // Set big icon
> GetParent()->SetIcon(hIcon, FALSE);       // Set small icon
________________________________________________________________________
5.6. - [Chapter 8 -- Using ActiveX Controls](invcpp5/ch08a.htm)
----------------------------------------------------
 Chapter 8 -- Using ActiveX Controls  Chapter 8

Using ActiveX Controls
======================

Microsoft Visual Basic (VB) was introduced in 1991 and has proven to be a wildly popular and successful application development system for Microsoft Windows. Part of its success is attributable to its open-ended nature. The 16-bit versions of VB (versions 1 through 3) supported Visual Basic controls (VBXs), ready-to-run software components that VB developers could buy or write themselves. VBXs became the center of a whole industry, and pretty soon there were hundreds of them. At Microsoft, the Microsoft Foundation Class (MFC) team figured out a way for Microsoft Visual C++ programmers to use VBXs in their programs, too.

The VBX standard, which was highly dependent on the 16-bit segment architecture, did not make it to the 32-bit world. Now ActiveX Controls (formerly known as OLE controls, or OCXs) are the industrial-strength replacement for VBXs based on Microsoft COM technology. ActiveX controls can be used by application developers in both VB and Visual C++ 6.0. While VBXs were written mostly in plain C, ActiveX controls can be written in C++ with the help of the MFC library or with the help of the ActiveX Template Library (ATL).

This chapter is not about writing ActiveX controls; it's about using them in a Visual C++ application. The premise here is that you can learn to use ActiveX controls without knowing much about the Component Object Model (COM) on which they're based. After all, Microsoft doesn't require that VB programmers be COM experts. To effectively write ActiveX controls, however, you need to know a bit more, starting with the fundamentals of COM. Consider picking up a copy of Adam Denning's _ActiveX_ _Controls Inside Out_ (Microsoft Press, 1997) if you're serious about creating ActiveX controls. Of course, knowing more ActiveX Control theory won't hurt when you're using the controls in your programs. [Chapter 24](ch24a.htm), [Chapter 25](ch25a.htm), and [Chapter 30](ch30a.htm) of this book are a good place to start.
________________________________________________________________________
5.6.1. - [ActiveX Controls vs. Ordinary Windows Controls](invcpp5/ch08b.htm)
----------------------------------------------------
 ActiveX Controls vs. Ordinary Windows Controls 

ActiveX Controls vs. Ordinary Windows Controls
==============================================

An ActiveX control is a software module that plugs into your C++ program the same way a Windows control does. At least that's the way it seems at first. It's worthwhile here to analyze the similarities and differences between ActiveX controls and the controls you already know.

Ordinary Controls—A Frame of Reference
--------------------------------------

In [Chapter 6](ch06a.htm), you used ordinary Windows controls such as the edit control and the list box, and you saw the Windows common controls that work in much the same way. These controls are all child windows that you use most often in dialogs, and they are represented by MFC classes such as _CEdit_ and _CTreeCtrl_. The client program is always responsible for the creation of the control's child window.

Ordinary controls send notification command messages (standard Windows messages), such as BN_CLICKED, to the dialog. If you want to perform an action on the control, you call a C++ control class member function, which sends a Windows message to the control. The controls are all windows in their own right. All the MFC control classes are derived from _CWnd_, so if you want to get the text from an edit control, you call _CWnd::GetWindowText_. But even that function works by sending a message to the control.

Windows controls are an integral part of Windows, even though the Windows common controls are in a separate DLL. Another species of ordinary control, the so-called custom control, is a programmer-created control that acts as an ordinary control in that it sends WM_COMMAND notifications to its parent window and receives user-defined messages. You'll see one of these in [Chapter 22](ch22a.htm).

How ActiveX Controls Are Similar to Ordinary Controls
-----------------------------------------------------

You can consider an ActiveX control to be a child window, just as an ordinary control is. If you want to include an ActiveX control in a dialog, you use the dialog editor to place it there, and the identifier for the control turns up in the resource template. If you're creating an ActiveX control on the fly, you call a _Create_ member function for a class that represents the control, usually in the WM_CREATE handler for the parent window. When you want to manipulate an ActiveX control, you call a C++ member function, just as you do for a Windows control. The window that contains a control is called a container.

How ActiveX Controls Are Different from Ordinary Controls—Properties and Methods
--------------------------------------------------------------------------------

The most prominent ActiveX Controls features are properties and methods. Those C++ member functions that you call to manipulate a control instance all revolve around properties and methods. Properties have symbolic names that are matched to integer indexes. For each property, the control designer assigns a property name, such as BackColor or GridCellEffect, and a property type, such as string, integer, or double. There's even a picture type for bitmaps and icons. The client program can set an individual ActiveX control property by specifying the property's integer index and its value. The client can get a property by specifying the index and accepting the appropriate return value. In certain cases, ClassWizard lets you define data members in your client window class that are associated with the properties of the controls the client class contains. The generated Dialog Data Exchange (DDX) code exchanges data between the control properties and the client class data members.

ActiveX Controls methods are like functions. A method has a symbolic name, a set of parameters, and a return value. You call a method by calling a C++ member function of the class that represents the control. A control designer can define any needed methods, such as _PreviousYear_, _LowerControlRods_, and so forth.

An ActiveX control doesn't send WM_ notification messages to its container the way ordinary controls do; instead, it "fires events." An event has a symbolic name and can have an arbitrary sequence of parameters—it's really a container function that the control calls. Like ordinary control notification messages, events don't return a value to the ActiveX control. Examples of events are Click, KeyDown, and NewMonth. Events are mapped in your client class just as control notification messages are.

In the MFC world, ActiveX controls act just like child windows, but there's a significant layer of code between the container window and the control window. In fact, the control might not even have a window. When you call _Create_, the control's window isn't created directly; instead, the control code is loaded and given the command for "in-place activation." The ActiveX control then creates its own window, which MFC lets you access through a _CWnd_ pointer. It's not a good idea for the client to use the control's _hWnd_ directly, however.

A DLL is used to store one or more ActiveX controls, but the DLL often has an OCX filename extension instead of a DLL extension. Your container program loads the DLLs when it needs them, using sophisticated COM techniques that rely on the Windows Registry. For the time being, simply accept the fact that once you specify an ActiveX control at design time, it will be loaded for you at runtime. Obviously, when you ship a program that requires special ActiveX controls, you'll have to include the OCX files and an appropriate setup program.
________________________________________________________________________
5.6.2. - [Installing ActiveX Controls](invcpp5/ch08c.htm)
----------------------------------------------------
 Installing ActiveX Controls 

Installing ActiveX Controls
===========================

Let's assume you've found a nifty ActiveX control that you want to use in your project. Your first step is to copy the control's DLL to your hard disk. You could put it anywhere, but it's easier to track your ActiveX controls if you put them in one place, such as in the system directory (typically \Windows\System for Microsoft Windows 95 or \Winnt\System32 for Microsoft Windows NT). Copy associated files such as help (HLP) or license (LIC) files to the same directory.

Your next step is to register the control in the Windows Registry. Actually, the ActiveX control registers itself when a client program calls a special exported function. The Windows utility Regsvr32 is a client that accepts the control name on the command line. Regsvr32 is suitable for installation scripts, but another program, RegComp, in the project REGCOMP on the companion CD-ROM for this book, lets you find your control by browsing the disk. Some controls have licensing requirements, which might involve extra entries to the Registry. (See [Chapter 15](ch15a.htm), [Chapter 17](ch17a.htm), [Chapter 24](ch24a.htm), and [Chapter 25](ch25a.htm) for information about how the Windows Registry works.) Licensed controls usually come with setup programs that take care of those details.

After you register your ActiveX control, you must install it in each project that uses it. That doesn't mean that the OCX file gets copied. It means that ClassWizard generates a copy of a C++ class that's specific to the control, and it means that the control shows up in the dialog editor control palette for that project.

To install an ActiveX control in a project, choose Add To Project from the Project menu and then choose Components And Controls. Select Registered ActiveX Controls, as shown in the following illustration.

![](c:/dl/books/windows/msvc5th/invcpp5/images/G08OG01x.gif)

This gets you the list of all the ActiveX controls currently registered on your system. A typical list is shown here.

![](c:/dl/books/windows/msvc5th/invcpp5/images/G08OG02x.gif)
________________________________________________________________________
5.6.3. - [The Calendar Control](invcpp5/ch08d.htm)
----------------------------------------------------
 The Calendar Control 

The Calendar Control
====================

The MSCal.ocx control is a popular Microsoft ActiveX Calendar control that's probably already installed and registered on your computer. If it isn't there, don't worry. It's on the CD-ROM that comes with this book.

Figure 8-1 shows the Calendar control inside a modal dialog.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F08OG01x.gif)]

**Figure 8-1.** _The Calendar control in use._

The Calendar control comes with a help file that lists the control's properties, methods, and events shown here.

**Properties**

**Methods**

**Events**

BackColor

AboutBox

AfterUpdate

Day

NextDay

BeforeUpdate

DayFont

NextMonth

Click

DayFontColor

NextWeek

DblClick

DayLength

NextYear

KeyDown

FirstDay

PreviousDay

KeyPress

GridCellEffect

PreviousMonth

KeyUp

GridFont

PreviousWeek

NewMonth

GridFontColor

PreviousYear

NewYear

GridLinesColor

Refresh

 

Month

Today

 

MonthLength

 

 

ShowDateSelectors

 

 

ShowDays

 

 

ShowHorizontalGridlines

 

 

ShowTitle

 

 

ShowVerticalGridlines

 

 

TitleFont

 

 

TitleFontColor

 

 

Value

 

 

ValueIsNull

 

 

Year

 

 

You'll be using the BackColor, Day, Month, Year, and Value properties in the EX08A example later in this chapter. BackColor is an unsigned long, but it is used as an _OLE_COLOR_, which is almost the same as a _COLORREF_. Day, Month, and Year are short integers. Value's type is the special type _VARIANT_, which is described in [Chapter 25](ch25a.htm). It holds the entire date as a 64-bit value.

Each of the properties, methods, and events listed above has a corresponding integer identifier. Information about the names, types, parameter sequences, and integer IDs is stored inside the control and is accessible to ClassWizard at container design time.
________________________________________________________________________
5.6.4. - [ActiveX Control Container Programming](invcpp5/ch08e.htm)
----------------------------------------------------
 ActiveX Control Container Programming 

ActiveX Control Container Programming
=====================================

MFC and ClassWizard support ActiveX controls both in dialogs and as "child windows." To use ActiveX controls, you must understand how a control grants access to properties, and you must understand the interactions between your DDX code and those property values.

Property Access
---------------

The ActiveX control developer designates certain properties for access at design time. Those properties are specified in the property pages that the control displays in the dialog editor when you right-click on a control and choose Properties. The Calendar control's main property page looks like the one shown next.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G08OG03x.gif)]

When you click on the All tab, you will see a list of all the design- time-accessible properties, which might include a few properties not found on the Control tab. The Calendar control's All page looks like this.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G08OG04x.gif)]

All the control's properties, including the design-time properties, are accessible at runtime. Some properties, however, might be designated as read-only.

ClassWizard's C++ Wrapper Classes for ActiveX Controls
------------------------------------------------------

When you insert an ActiveX control into a project, ClassWizard generates a C++ wrapper class, derived from _CWnd_, that is tailored to your control's methods and properties. The class has member functions for all properties and methods, and it has constructors that you can use to dynamically create an instance of the control. (ClassWizard also generates wrapper classes for objects used by the control.) Following are a few typical member functions from the file Calendar.cpp that ClassWizard generates for the Calendar control:

unsigned long CCalendar::GetBackColor()
{
    unsigned long result;
    InvokeHelper(DISPID_BACKCOLOR, DISPATCH_PROPERTYGET,
                 VT_I4, (void\*)&result, NULL);
    return result;
}

void CCalendar::SetBackColor(unsigned long newValue)
{
    static BYTE parms[] =
        VTS_I4;
    InvokeHelper(DISPID_BACKCOLOR, DISPATCH_PROPERTYPUT,
                 VT_EMPTY, NULL, parms, newValue);
}

short CCalendar::GetDay()
{
    short result;
    InvokeHelper(0x11, DISPATCH_PROPERTYGET, VT_I2,
                 (void\*)&result, NULL);
    return result;
}

void CCalendar::SetDay(short nNewValue)
{
    static BYTE parms[] =
        VTS_I2;
    InvokeHelper(0x11, DISPATCH_PROPERTYPUT, VT_EMPTY,
                 NULL, parms, nNewValue);
}

COleFont CCalendar::GetDayFont()
{
    LPDISPATCH pDispatch;
    InvokeHelper(0x1, DISPATCH_PROPERTYGET, VT_DISPATCH,
                 (void\*)&pDispatch, NULL);
    return COleFont(pDispatch);
}

void CCalendar::SetDayFont(LPDISPATCH newValue)
{
    static BYTE parms[] =
        VTS_DISPATCH;
    InvokeHelper(0x1, DISPATCH_PROPERTYPUT, VT_EMPTY,
                 NULL, parms, newValue);
}

VARIANT CCalendar::GetValue()
{
    VARIANT result;
    InvokeHelper(0xc, DISPATCH_PROPERTYGET, VT_VARIANT,
                 (void\*)&result, NULL);
    return result;
}

void CCalendar::SetValue(const VARIANT& newValue)
{
    static BYTE parms[] =
        VTS_VARIANT;
    InvokeHelper(0xc, DISPATCH_PROPERTYPUT, VT_EMPTY,
                 NULL, parms, &newValue);
}

void CCalendar::NextDay()
{
    InvokeHelper(0x16, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CCalendar::NextMonth()
{
    InvokeHelper(0x17, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

You don't have to concern yourself too much with the code inside these functions, but you can match up the first parameter of each _InvokeHelper_ function with the dispatch ID for the corresponding property or method in the Calendar control property list. As you can see, properties always have separate _Set_ and _Get_ functions. To call a method, you simply call the corresponding function. For example, to call the NextDay method from a dialog class function, you write code such as this:

m_calendar.NextDay();

In this case, _m_calendar_ is an object of class _CCalendar_, the wrapper class for the Calendar control.

AppWizard Support for ActiveX Controls
--------------------------------------

When the AppWizard ActiveX Controls option is checked (the default), AppWizard inserts the following line in your application class _InitInstance_ member function:

AfxEnableControlContainer();

It also inserts the following line in the project's StdAfx.h file:

#include <afxdisp.h>

If you decide to add ActiveX controls to an existing project that doesn't include the two lines above, you can simply add the lines.

ClassWizard and the Container Dialog
------------------------------------

Once you've used the dialog editor to generate a dialog template, you already know that you can use ClassWizard to generate a C++ class for the dialog window. If your template contains one or more ActiveX controls, you can use ClassWizard to add data members and event handler functions.

### Dialog Class Data Members vs. Wrapper Class Usage

What kind of data members can you add to the dialog for an ActiveX control? If you want to set a control property before you call _DoModal_ for the dialog, you can add a dialog data member for that property. If you want to change properties inside the dialog member functions, you must take another approach: you add a data member that is an object of the wrapper class for the ActiveX control.

Now is a good time to review the MFC DDX logic. Look back at the Cincinnati dialog in [Chapter 6](ch06a.htm). The _CDialog::OnInitDialog_ function calls _CWnd::UpdateData(FALSE)_ to read the dialog class data members, and the _CDialog::OnOK_ function calls _UpdateData(TRUE)_ to write the members. Suppose you added a data member for each ActiveX control property and you needed to get the Value property value in a button handler. If you called _UpdateData(FALSE)_ in the button handler, it would read all the property values from all the dialog's controls—clearly a waste of time. It's more effective to avoid using a data member and to call the wrapper class _Get_ function instead. To call that function, you must first tell ClassWizard to add a wrapper class object data member.

Suppose you have a Calendar wrapper class _CCalendar_ and you have an _m_calendar_ data member in your dialog class. If you want to get the Value property, you do it like this:

COleVariant var = m_calendar.GetValue();

> NOTE
> 
> The _VARIANT_ type and _COleVariant_ class are described in [Chapter 25](ch25a.htm).

Now consider another case: you want to set the day to the 5th of the month before the control is displayed. To do this by hand, add a dialog class data member _m_sCalDay_ that corresponds to the control's short integer Day property. Then add the following line to the _DoDataExchange_ function:

DDX_OCShort(pDX, ID_CALENDAR1, 0x11, m_sCalDay);

The third parameter is the Day property's integer index (its DispID), which you can find in the _GetDay_ and _SetDay_ functions generated by ClassWizard for the control. Here's how you construct and display the dialog:

CMyDialog dlg;
dlg.m_sCalDay = 5;
dlg.DoModal();

The DDX code takes care of setting the property value from the data member before the control is displayed. No other programming is needed. As you would expect, the DDX code sets the data member from the property value when the user clicks the OK button.

> NOTE
> 
> Even when ClassWizard correctly detects a control's properties, it can't always generate data members for all of them. In particular, no DDX functions exist for _VARIANT_ properties like the Calendar's Value property. You'll have to use the wrapper class for these properties.

### Mapping ActiveX Control Events

ClassWizard lets you map ActiveX control events the same way you map Windows messages and command messages from controls. If a dialog class contains one or more ActiveX controls, ClassWizard adds and maintains an event sink map that connects mapped events to their handler functions. It works something like a message map. You can see the code in Figure 8-2.

> NOTE
> 
> ActiveX controls have the annoying habit of firing events before your program is ready for them. If your event handler uses windows or pointers to C++ objects, it should verify the validity of those entities prior to using them.

Locking ActiveX Controls in Memory
----------------------------------

Normally, an ActiveX control remains mapped in your process as long as its parent dialog is active. That means it must be reloaded each time the user opens a modal dialog. The reloads are usually quicker than the initial load because of disk caching, but you can lock the control into memory for better performance. To do so, add the following line in the overridden _OnInitDialog_ function after the base class call:

AfxOleLockControl(m_calendar.GetClsid());

The ActiveX control remains mapped until your program exits or until you call the _AfxOleUnlockControl_ function.
________________________________________________________________________
5.6.5. - [The EX08A Example -- An ActiveX Control Dialog Container](invcpp5/ch08f.htm)
----------------------------------------------------
 The EX08A Example -- An ActiveX Control Dialog Container 

The EX08A Example—An ActiveX Control Dialog Container
=====================================================

Now it's time to build an application that uses a Calendar control in a dialog. Here are the steps to create the EX08A example:

2.  **Verify that the Calendar control is registered.** If the control does not appear in the Visual C++ Gallery's Registered ActiveX Controls page, copy the files MSCal.ocx, MSCal.hlp, and MSCal.cnt to your system directory and register the control by running the REGCOMP program.
    
3.  **Run AppWizard to produce \vcpp32\ex08a\ex08a.** Accept all of the default settings but two: select Single Document and deselect Printing And Print Preview. In the AppWizard Step 3 dialog, make sure the ActiveX Controls option is selected, as shown below.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G08OG05x.gif)]
    
4.  **Install the Calendar control in the EX08A project.** Choose Add To Project from Visual C++'s Project menu, and then choose Components And Controls. Choose Registered ActiveX Controls, and then choose Calendar Control 8.0. ClassWizard generates two classes in the EX08A directory, as shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G08OG06.GIF)
    
5.  **Edit the Calendar control class to handle help messages.** Add Calendar.cpp to the following message map code:
    
    **BEGIN_MESSAGE_MAP(CCalendar, CWnd)
        ON_WM_HELPINFO()
    END_MESSAGE_MAP()**
    
    In the same file, add the _OnHelpInfo_ function:
    
    **BOOL CCalendar::OnHelpInfo(HELPINFO\* pHelpInfo) 
    {    
        // Edit the following string for your system
        ::WinHelp(GetSafeHwnd(), "c:\\winnt\\system32\\mscal.hlp",
                  HELP_FINDER, 0);
        return FALSE;
    }**
    
    In Calendar.h, add the function prototype and declare the message map:
    
    **protected:
        afx_msg BOOL OnHelpInfo(HELPINFO\* pHelpInfo);
        DECLARE_MESSAGE_MAP()**
    
    The _OnHelpInfo_ function is called if the user presses the F1 key when the Calendar control has the input focus. We have to add the message map code by hand because ClassWizard doesn't modify generated ActiveX classes.
    
    > NOTE
    > 
    > The _ON_WM_HELPINFO_ macro maps the WM_HELP message, which is new to Microsoft Windows 95 and Microsoft Windows NT 4.0. You can use _ON_WM_HELPINFO_ in any view or dialog class and then code the handler to activate any help system. [Chapter 21](ch21a.htm) describes the MFC context-sensitive help system, some of which predates the WM_HELP message.
    
6.  **Use the dialog editor to create a new dialog resource.** Choose Resource from Visual C++'s Insert menu, and then choose Dialog. The dialog editor assigns the ID _IDD_DIALOG1_ to the new dialog. Next change the ID to _IDD_ACTIVEXDIALOG_, change the dialog caption to _ActiveX Dialog_, and set the dialog's Context Help property (on the More Styles page). Accept the default OK and Cancel buttons with the IDs _IDOK_ and _IDCANCEL_, and then add the other controls as shown in Figure 8-1. Make the Select Date button the default button. Drag the Calendar control from the control palette. Then set an appropriate tab order. Assign control IDs as shown in the following table.
    
    **Control**
    
    **ID**
    
    Calendar control
    
    _IDC_CALENDAR1_
    
    Select Date button
    
    _IDC_SELECTDATE_
    
    Edit control
    
    _IDC_DAY_
    
    Edit control
    
    _IDC_MONTH_
    
    Edit control
    
    _IDC_YEAR_
    
    Next Week button
    
    _IDC_NEXTWEEK_
    
7.  **Use ClassWizard to create the _CActiveXDialog_ class.** If you run ClassWizard directly from the dialog editor window, it will know that you want to create a _CDialog_\-derived class based on the _IDD_ACTIVEXDIALOG_ template. Simply accept the default options, and name the class _CActiveXDialog_.
    
    Click on the ClassWizard Message Maps tab, and then add the message handler functions shown in the table below. To add a message handler function, click on an object ID, click on a message, and click the Add Function button. If the Add Member Function dialog box appears, type the function name and click the OK button.
    
    **Object ID**
    
    **Message**
    
    **Member Function**
    
    _CActiveXDialog_
    
    WM_INITDIALOG
    
    _OnInitDialog_ (virtual function)
    
    _IDC_CALENDAR1_
    
    NewMonth (event)
    
    _OnNewMonthCalendar1_
    
    _IDC_SELECTDATE_
    
    BN_CLICKED
    
    _OnSelectDate_
    
    _IDC_NEXTWEEK_
    
    BN_CLICKED
    
    _OnNextWeek_
    
    _IDOK_
    
    BN_CLICKED
    
    _OnOK_ (virtual function)
    
8.  **Use ClassWizard to add data members to the _CActiveXDialog_ class.** Click on the Member Variables tab, and then add the data members as shown in the illustration below.
    
    > NOTE
    > 
    > You might think that the ClassWizard ActiveX Events tab is for mapping ActiveX control events in a container. That's not true: it's for ActiveX control developers who are defining events for a control.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G08OG07x.gif)]
    
9.  **Edit the _CActiveXDialog_ class.** Add the _m_varValue_ and _m_BackColor_ data members, and then edit the code for the five handler functions _OnInitDialog_, _OnNewMonthCalendar1_, _OnSelectDate_, _OnNextWeek_, and _OnOK_. Figure 8-2 shows all the code for the dialog class, with new code in boldface.
    
    **ACTIVEXDIALOG.H**
    
    //{{AFX_INCLUDES()
    #include "calendar.h"
    //}}AFX_INCLUDES
    #if !defined(AFX_ACTIVEXDIALOG_H__1917789D_6F24_11D0_8FD9_00C04FC2A0C2__INCLUDED_)
    #define AFX_ACTIVEXDIALOG_H__1917789D_6F24_11D0_8FD9_00C04FC2A0C2__INCLUDED_
    
    #if _MSC_VER > 1000
    #pragma once
    #endif // _MSC_VER > 1000
    
    // ActiveXDialog.h : header file
    //
    
    //////////////////////////////////////////////////////////////////////
    // CActiveXDialog dialog
    class CActiveXDialog : public CDialog
    
    {
    // Construction
    public:
        CActiveXDialog(CWnd\* pParent = NULL);   // standard constructor
    
    // Dialog Data
        //{{AFX_DATA(CActiveXDialog)
        enum { IDD = IDD_ACTIVEXDIALOG };
        CCalendar    m_calendar;
        short    m_sDay;
        short    m_sMonth;
        short    m_sYear;
        //}}AFX_DATA
        **COleVariant m_varValue;
        unsigned long m_BackColor;**
    
    // Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CActiveXDialog)
        protected:
        virtual void DoDataExchange(CDataExchange\* pDX); // DDX/DDV
                                                         //  support
        //}}AFX_VIRTUAL
    
    // Implementation
    protected:
    
        // Generated message map functions
        //{{AFX_MSG(CActiveXDialog)
        virtual BOOL OnInitDialog();
        afx_msg void OnNewMonthCalendar1();
        afx_msg void OnSelectDate();
        afx_msg void OnNextWeek();
        virtual void OnOK();
        DECLARE_EVENTSINK_MAP()
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
    };
    
    //{{AFX_INSERT_LOCATION}}
    // Microsoft Visual C++ will insert additional
    //  declarations immediately before the previous line.
    
    #endif // !defined(AFX_ACTIVEXDIALOG_H__1917789D_6F24_11D0_8FD9_00C04FC2A0C2__INCLUDED_)
    
    **ACTIVEXDIALOG.CPP**
    
    // ActiveXDialog.cpp : implementation file
    //
    
    #include "stdafx.h"
    #include "ex08a.h"
    #include "ActiveXDialog.h"
    
    #ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
    static char THIS_FILE[] = __FILE__;
    #endif
    
    //////////////////////////////////////////////////////////////////////
    // CActiveXDialog dialog
    
    
    CActiveXDialog::CActiveXDialog(CWnd\* pParent /\*=NULL\*/)
        : CDialog(CActiveXDialog::IDD, pParent)
    {
        //{{AFX_DATA_INIT(CActiveXDialog)
        m_sDay = 0;
        m_sMonth = 0;
        m_sYear = 0;
        //}}AFX_DATA_INIT
        **m_BackColor = 0x8000000F;**
    }
    
    void CActiveXDialog::DoDataExchange(CDataExchange\* pDX)
    {
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CActiveXDialog)
        DDX_Control(pDX, IDC_CALENDAR1, m_calendar);
        DDX_Text(pDX, IDC_DAY, m_sDay);
        DDX_Text(pDX, IDC_MONTH, m_sMonth);
        DDX_Text(pDX, IDC_YEAR, m_sYear);
        //}}AFX_DATA_MAP
        **DDX_OCColor(pDX, IDC_CALENDAR1, DISPID_BACKCOLOR, m_BackColor);**
    }
    
    BEGIN_MESSAGE_MAP(CActiveXDialog, CDialog)
        //{{AFX_MSG_MAP(CActiveXDialog)
        ON_BN_CLICKED(IDC_SELECTDATE, OnSelectDate)
        ON_BN_CLICKED(IDC_NEXTWEEK, OnNextWeek)
        //}}AFX_MSG_MAP
    END_MESSAGE_MAP()
    
    //////////////////////////////////////////////////////////////////////
    // CActiveXDialog message handlers
    
    BEGIN_EVENTSINK_MAP(CActiveXDialog, CDialog)
        //{{AFX_EVENTSINK_MAP(CActiveXDialog)
        ON_EVENT(CActiveXDialog, IDC_CALENDAR1, 3 /\* NewMonth \*/, OnNewMonthCalendar1, VTS_NONE)
        //}}AFX_EVENTSINK_MAP
    END_EVENTSINK_MAP()
    
    BOOL CActiveXDialog::OnInitDialog() 
    {
        CDialog::OnInitDialog();
        **m_calendar.SetValue(m_varValue); // no DDX for VARIANTs**
        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
    
    }
    void CActiveXDialog::OnNewMonthCalendar1() 
    {
        **AfxMessageBox("EVENT:  CActiveXDialog::OnNewMonthCalendar1");**
    }
    
    void CActiveXDialog::OnSelectDate() 
    {
        **CDataExchange dx(this, TRUE);
        DDX_Text(&dx, IDC_DAY, m_sDay);
        DDX_Text(&dx, IDC_MONTH, m_sMonth);
        DDX_Text(&dx, IDC_YEAR, m_sYear);
        m_calendar.SetDay(m_sDay);
        m_calendar.SetMonth(m_sMonth);
        m_calendar.SetYear(m_sYear);**
    }
    
    void CActiveXDialog::OnNextWeek() 
    {
        **m_calendar.NextWeek();**    
    }
    
    void CActiveXDialog::OnOK() 
    {    
        CDialog::OnOK();
        **m_varValue = m_calendar.GetValue(); // no DDX for VARIANTs**
    }
    
    **Figure 8-2.** _Code for the_ CActiveXDialog _class._
    
    The _OnSelectDate_ function is called when the user clicks the Select Date button. The function gets the day, month, and year values from the three edit controls and transfers them to the control's properties. ClassWizard can't add DDX code for the BackColor property, so you must add it by hand. In addition, there's no DDX code for _VARIANT_ types, so you must add code to the _OnInitDialog_ and _OnOK_ functions to set and retrieve the date with the control's Value property.
    
10.  **Connect the dialog to the view.** Use ClassWizard to map the WM_LBUTTONDOWN message, and then edit the handler function as follows:
    
    void CEx08aView::OnLButtonDown(UINT nFlags, CPoint point) 
    {
        **CActiveXDialog dlg;
        dlg.m_BackColor = RGB(255, 251, 240); // light yellow
        COleDateTime today = COleDateTime::GetCurrentTime();
        dlg.m_varValue = COleDateTime(today.GetYear(), today.GetMonth(),
                                      today.GetDay(), 0, 0, 0);
        if (dlg.DoModal() == IDOK) {
            COleDateTime date(dlg.m_varValue);
            AfxMessageBox(date.Format("%B %d, %Y"));
        }**
    }
    
    The code sets the background color to light yellow and the date to today's date, displays the modal dialog, and reports the date returned by the Calendar control. You'll need to include ActiveXDialog.h in ex08aView.cpp.
    
11.  **Edit the virtual _OnDraw_ function in the file ex08aView.cpp.** To prompt the user to press the left mouse button, replace the code in the view class _OnDraw_ function with this single line:
    
    **pDC->TextOut(0, 0, "Press the left mouse button here.");**
    
12.  **Build and test the EX08A application.** Open the dialog, enter a date in the three edit controls, and then click the Select Date button. Click the Next Week button. Try moving the selected date directly to a new month, and observe the message box that is triggered by the NewMonth event. Watch for the final date in another message box when you click OK. Press the F1 key for help on the Calendar control.
    

> **For Win32 Programmers**
> 
> If you use a text editor to look inside the ex08a.rc file, you might be quite mystified. Here's the entry for the Calendar control in the ActiveX Dialog template:
> 
> CONTROL         "",IDC_CALENDAR1,
>                 "{8E27C92B-1264-101C-8A2F-040224009C02}",
>                 WS_TABSTOP,7,7,217,113
> 
> There's a 32-digit number sequence where the window class name should be. What's going on? Actually, the resource template isn't the one that Windows sees. The _CDialog::DoModal_ function "preprocesses" the resource template before passing it on to the dialog box procedure within Windows. It strips out all the ActiveX controls and creates the dialog window without them. Then it loads the controls (based on their 32-digit identification numbers, called CLSIDs) and activates them in place, causing them to create their own windows in the correct places. The initial values for the properties you set in the dialog editor are stored in binary form inside the project's custom DLGINIT resource.
> 
> When the modal dialog runs, the MFC code coordinates the messages sent to the dialog window both by the ordinary controls and by the ActiveX controls. This allows the user to tab between all the controls in the dialog, even though the ActiveX controls are not part of the actual dialog template.
> 
> When you call the member functions for the control object, you might think you're calling functions for a child window. The control window is quite far removed, but MFC steps in to make it seem as if you're communicating with a real child window. In ActiveX terminology, the container owns a site, which is not a window. You call functions for the site, and ActiveX and MFC make the connection to the underlying window in the ActiveX control.
> 
> The container window is an object of a class derived from _CWnd_. The control site is also an object of a class derived from _CWnd_—the ActiveX control wrapper class. That means that the _CWnd_ class has built-in support for both containers and sites.
> 
> What you're seeing here is MFC ActiveX control support grafted onto regular Windows. Maybe some future Windows version will have more direct support for ActiveX Controls. As a matter of fact, ActiveX versions of the Windows common controls already exist.
________________________________________________________________________
5.6.6. - [ActiveX Controls in HTML Files](invcpp5/ch08g.htm)
----------------------------------------------------
 ActiveX Controls in HTML Files 

ActiveX Controls in HTML Files
==============================

You've seen the ActiveX Calendar control in an MFC modal dialog. You can use the same control in a Web page. The following HTML code will work (assuming the person reading the page has the Calendar control installed and registered on his or her machine):

<OBJECT
    CLASSID="clsid:8E27C92B-1264-101C-8A2F-040224009C02"
    WIDTH=300 HEIGHT=200 BORDER=1 HSPACE=5 ID=calendar>
<PARAM NAME="Day" VALUE=7>
<PARAM NAME="Month" VALUE=11>
<PARAM NAME="Year" VALUE=1998>
</OBJECT>

The CLASSID attribute (the same number that was in the EX08A dialog resource) identifies the Calendar control in the Registry. A browser can download an ActiveX control.
________________________________________________________________________
5.6.7. - [Creating ActiveX Controls at Runtime](invcpp5/ch08h.htm)
----------------------------------------------------
 Creating ActiveX Controls at Runtime 

Creating ActiveX Controls at Runtime
====================================

You've seen how to use the dialog editor to insert ActiveX controls at design time. If you need to create an ActiveX control at runtime without a resource template entry, here are the programming steps:

2.  Insert the component into your project. ClassWizard will create the files for a wrapper class.
    
3.  Add an embedded ActiveX control wrapper class data member to your dialog class or other C++ window class. An embedded C++ object is then constructed and destroyed along with the window object.
    
4.  Choose Resource Symbols from Visual C++'s View menu. Add an ID constant for the new control.
    
5.  If the parent window is a dialog, use ClassWizard to map the dialog's WM_INITDIALOG message, thus overriding _CDialog-::OnInitDialog_. For other windows, use ClassWizard to map the WM_CREATE message. The new function should call the embedded control class's _Create_ member function. This call indirectly displays the new control in the dialog. The control will be properly destroyed when the parent window is destroyed.
    
6.  In the parent window class, manually add the necessary event message handlers and prototypes for your new control. Don't forget to add the event sink map macros.

> TIPS
> 
> ClassWizard doesn't help you with event sink maps when you add a dynamic ActiveX control to a project. Consider inserting the target control in a dialog in another temporary project. After you're finished mapping events, simply copy the event sink map code to the parent window class in your main project.
________________________________________________________________________
5.6.8. - [The EX08B Example -- The Web Browser ActiveX Control](invcpp5/ch08i.htm)
----------------------------------------------------
 The EX08B Example -- The Web Browser ActiveX Control 

The EX08B Example—The Web Browser ActiveX Control
=================================================

Microsoft Internet Explorer 4.x has become a leading Web browser. I was surprised to find out that most of its functionality is contained in one big ActiveX control, Shdocvw.dll. When you run Internet Explorer, you launch a small shell program that loads this Web Browser control in its main window.

> NOTE
> 
> You can find complete documentation for the Web Browser control's properties, methods, and events in the Internet SDK, downloadable from [http://www.microsoft.com](http://www.microsoft.com). This documentation is in HTML form, of course.

Because of this modular architecture, you can write your own custom browser program with very little effort. EX08B creates a two-window browser that displays a search engine page side-by-side with the target page, as shown here.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G08OG08x.gif)]

This view window contains two Web Browser controls that are sized to occupy the entire client area. When the user clicks an item in the search (right-hand) control, the program intercepts the command and routes it to the target (left-hand) control.

Here are the steps for building the example:

2.  **Make sure the Web Browser control is registered.** You undoubtedly have Microsoft Internet Explorer 4.x installed, since Visual C++ 6.0 requires it, so the Web Browser control should be registered. You can download Internet Explorer from [http://www.microsoft.com](http://www.microsoft.com) if necessary.
    
3.  **Run AppWizard to produce \vcpp32\ex08b\ex08b.** Accept all the default settings but two: except select Single Document and deselect Printing And Print Preview. Make sure the ActiveX Controls option is checked as in EX08A.
    
4.  **Install the Web Browser control in the EX08B project.** Choose Add To Project from Visual C++'s Project menu, and choose Components And Controls from the submenu. Select Registered ActiveX Controls, and then choose Microsoft Web Browser. Visual C++ will generate the wrapper class _CWebBrowser_ and add the files to your project.
    
5.  **Add two _CWebBrowser_ data members to the _CEx08bView_ class.** Click on the ClassView tab in the Workspace window, and then right-click the _CEx08bView_ class. Choose Add Member Variable, and fill in the dialog as shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G08OG09.GIF)
    
    Repeat for _m_target_. ClassWizard adds an _#include_ statement for the webbrowser.h file.
    
6.  **Add the child window ID constants for the two controls.** Select Resource Symbols from Visual C++'s View menu, and then add the symbols _ID_BROWSER_SEARCH_ and _ID_BROWSER_TARGET_.
    
7.  **Add a static character array data member for the AltaVista URL.** Add the following static data member to the class declaration in ex08bView.h:
    
    **private:
        static const char s_engineAltavista[];**
    
    Then add the following definition in ex08bView.cpp, outside any function:
    
    **const char CEx08bView::s_engineAltavista[] =
        "http://altavista.digital.com/";**
    
8.  **Use ClassWizard to map the view's WM_CREATE and WM_SIZE messages.** Edit the handler code in ex08bView.cpp as follows:
    
    int CEx08bView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
    {
        if (CView::OnCreate(lpCreateStruct) == -1)
            return -1;
        
        **DWORD dwStyle = WS_VISIBLE | WS_CHILD;    
        if (m_search.Create(NULL, dwStyle, CRect(0, 0, 100, 100),
                            this, ID_BROWSER_SEARCH) == 0) {
            AfxMessageBox("Unable to create search control!\n");
            return -1;
        }
        m_search.Navigate(s_engineAltavista, NULL, NULL, NULL, NULL);
    
        if (m_target.Create(NULL, dwStyle, CRect(0, 0, 100, 100),
                            this, ID_BROWSER_TARGET) == 0) {
            AfxMessageBox("Unable to create target control!\n");
            return -1;
        }
        m_target.GoHome(); // as defined in Internet Explorer 4 options**
    
        return 0;
    }
    
    void CEx08bView::OnSize(UINT nType, int cx, int cy) 
    {
        CView::OnSize(nType, cx, cy);
    
        **CRect rectClient;
        GetClientRect(rectClient);
        CRect rectBrowse(rectClient);
        rectBrowse.right = rectClient.right / 2;
        CRect rectSearch(rectClient);
        rectSearch.left = rectClient.right / 2;
    
        m_target.SetWidth(rectBrowse.right - rectBrowse.left);
        m_target.SetHeight(rectBrowse.bottom - rectBrowse.top);
        m_target.UpdateWindow();
    
        m_search.SetLeft(rectSearch.left);
        m_search.SetWidth(rectSearch.right - rectSearch.left);
        m_search.SetHeight(rectSearch.bottom - rectSearch.top);
        m_search.UpdateWindow();**
    }
    
    The _OnCreate_ function creates two browser windows inside the view window. The right-hand browser displays the top-level AltaVista page, and the left-hand browser displays the "home" page as defined through the Internet icon in the Control Panel. The _OnSize_ function, called whenever the view window changes size, ensures that the browser windows completely cover the view window. The _CWebBrowser_ member functions _SetWidth_ and _SetHeight_ set the browser's Width and Height properties.
    
9.  **Add the event sink macros in the _CEx08bView_ files.** ClassWizard can't map events from a dynamic ActiveX control, so you must do it manually. Add the following lines inside the class declaration in the file ex08bView.h:
    
    **protected:
        afx_msg void OnBeforeNavigateExplorer1(LPCTSTR URL, long Flags, LPCTSTR TargetFrameName, VARIANT FAR\* PostData, LPCTSTR Headers, BOOL FAR\* Cancel);
        afx_msg void OnTitleChangeExplorer2(LPCTSTR Text);
        DECLARE_EVENTSINK_MAP()**
    
    Then add the following code in ex08bView.cpp:
    
    **BEGIN_EVENTSINK_MAP(CEx08bView, CView)
        ON_EVENT(CEx08bView, ID_BROWSER_SEARCH, 100, OnBeforeNavigateExplorer1, VTS_BSTR VTS_I4 VTS_BSTR VTS_PVARIANT VTS_BSTR VTS_PBOOL)
        ON_EVENT(CEx08bView, ID_BROWSER_TARGET, 113,  OnTitleChangeExplorer2, VTS_BSTR)
    END_EVENTSINK_MAP()**
    
10.  **Add two event handler functions.** Add the following member functions in ex08bView.cpp:
    
    **void CEx08bView::OnBeforeNavigateExplorer1(LPCTSTR URL,
        long Flags, LPCTSTR TargetFrameName,
        VARIANT FAR\* PostData, LPCTSTR Headers, BOOL FAR\* Cancel)
    {
        TRACE("CEx08bView::OnBeforeNavigateExplorer1 -- URL = %s\n", URL);
    
        if (!strnicmp(URL, s_engineAltavista, strlen(s_engineAltavista))) {
            return;
        }
        m_target.Navigate(URL, NULL, NULL, PostData, NULL);
        \*Cancel = TRUE;
    }
    
    void CEx08bView::OnTitleChangeExplorer2(LPCTSTR Text)
    {
        // Careful!  Event could fire before we're ready.
        CWnd\* pWnd = AfxGetApp()->m_pMainWnd;
        if (pWnd != NULL) {
            if (::IsWindow(pWnd->m_hWnd)) {
                pWnd->SetWindowText(Text);
            }
        }
    }**
    
    The _OnBeforeNavigateExplorer1_ handler is called when the user clicks on a link in the search page. The function compares the clicked URL (in the _URL_ string parameter) with the search engine URL. If they match, the navigation proceeds in the search window; otherwise, the navigation is cancelled and the Navigate method is called for the target window. The _OnTitleChangeExplorer2_ handler updates the EX08B window title to match the title on the target page.
    
11.  **Build and test the EX08B application.** Search for something on the AltaVista page, and then watch the information appear in the target page.
________________________________________________________________________
5.6.9. - [The EX08C Example -- A Complete Dual-Window Web Browser](invcpp5/ch08j.htm)
----------------------------------------------------
 The EX08C Example -- A Complete Dual-Window Web Browser 

The EX08C Example—A Complete Dual-Window Web Browser
====================================================

I deliberately kept the EX08B example simple to clearly illustrate the use of the Web Browser control. However, I couldn't resist upgrading the program so that I could use it as my primary Internet browser. The result is EX08C, which uses MFC features described in later chapters of this book—in particular the features below.

*   A splitter window with moveable vertical bar browser windows
*   Use of the Registry to "remember" the search and target pages
*   Printing of both search and target pages
*   Support for multiple search engines
*   Toolbar buttons for navigation, printing, and search engine selection
*   Status bar display of activity and the selected URL

If EX08B runs, \vcpp32\Debug\ex08c should run also. I'm sure you'll have your own ideas for further customization. Once you've studied the rest of the book, you'll be able to take control of this project from the CD-ROM.
________________________________________________________________________
5.6.10. - [Picture Properties](invcpp5/ch08k.htm)
----------------------------------------------------
 Picture Properties 

Picture Properties
==================

Some ActiveX controls support picture properties, which can accommodate bitmaps, metafiles, and icons. If an ActiveX control has at least one picture property, ClassWizard generates a _CPicture_ class in your project during the control's installation. You don't need to use this _CPicture_ class, but you must use the MFC class _CPictureHolder_. To access the _CPictureHolder_ class declaration and code, you need the following line in StdAfx.h:

#include <afxctl.h>

Suppose you have an ActiveX control with a picture property named Picture. Here's how you set the Picture property to a bitmap in your program's resources:

CPictureHolder pict;
pict.CreateFromBitmap(IDB_MYBITMAP); // from project's resources
m_control.SetPicture(pict.GetPictureDispatch());

> NOTE
> 
> If you include the AfxCtl.h file, you can't statically link your program with the MFC library. If you need a stand-alone program that supports picture properties, you'll have to borrow code from the _CPictureHolder_ class, located in the \Program Files\Microsoft Visual Studio\VC98\mfc\src\ctlpict.cpp file.
________________________________________________________________________
5.6.11. - [Bindable Properties -- Change Notifications](invcpp5/ch08l.htm)
----------------------------------------------------
 Bindable Properties -- Change Notifications 

Bindable Properties—Change Notifications
========================================

If an ActiveX control has a property designated as bindable, the control will send an _OnChanged_ notification to its container when the value of the property changes inside the control. In addition, the control can send an _OnRequestEdit_ notification for a property whose value is about to change but has not yet changed. If the container returns _FALSE_ from its _OnRequestEdit_ handler, the control should not change the property value.

MFC fully supports property change notifications in ActiveX control containers, but as of Visual C++ version 6.0, no ClassWizard support was available. That means you must manually add entries to your container class's event sink map.

Suppose you have an ActiveX control with a bindable property named Note with a dispatch ID of _4_. You add an _ON_PROPNOTIFY_ macro to the _EVENTSINK_ macros in this way:

BEGIN_EVENTSINK_MAP(CAboutDlg, CDialog)
    //{{AFX_EVENTSINK_MAP(CAboutDlg)
    // ClassWizard places other event notification macros here
    //}}AFX_EVENTSINK_MAP
    ON_PROPNOTIFY(CAboutDlg, IDC_MYCTRL1, 4, OnNoteRequestEdit, OnNoteChanged)
END_EVENTSINK_MAP()

You must then code the _OnNoteRequestEdit_ and _OnNoteChanged_ functions with return types and parameter types exactly as shown here:

BOOL CMyDlg::OnNoteRequestEdit(BOOL\* pb)
{
    TRACE("CMyDlg::OnNoteRequestEdit\n");
    \*pb = TRUE; // TRUE means change request granted
    return TRUE;
}

BOOL CMyDlg::OnNoteChanged() 
{
    TRACE("CMyDlg::OnNoteChanged\n");
    return TRUE;
}

You'll also need corresponding prototypes in the class header, as shown here:

afx_msg BOOL OnNoteRequestEdit(BOOL\* pb);
afx_msg BOOL OnNoteChanged();
________________________________________________________________________
5.6.12. - [Other ActiveX Controls](invcpp5/ch08m.htm)
----------------------------------------------------
 Other ActiveX Controls 

Other ActiveX Controls
======================

You'll probably notice that your disk fills up with ActiveX controls, especially if you accept controls from Web sites. Most of these controls are difficult to use unless you have the documentation on hand, but you can have fun experimenting. Try the Marquee.ocx control that is distributed with Visual C++ 6.0. It works fine in both MFC programs and HTML files. The trick is to set the szURL property to the name of another HTML file that contains the text to display in the scrolling marquee window.

Many ActiveX controls were designed for use by Visual Basic programmers. The SysInfo.ocx control that comes with Visual C++, for example, lets you retrieve system parameters as property values. This isn't of much use to a C++ programmer, however, because you can make the equivalent Win32 calls anytime. Unlike the many objects provided by MFC, ActiveX controls are binary objects that are not extensible. For example, you cannot add a property or event to an ActiveX control. Nor can you use many C++ object-oriented techniques like polymorphism with ActiveX controls. Another downside of ActiveX controls is they are not compatible with many advanced MFC concepts such as the document/view architecture, which we will cover later.
________________________________________________________________________
5.7. - [Chapter 9 -- Internet Explorer 4 Common Controls](invcpp5/ch09a.htm)
----------------------------------------------------
 Chapter 9 -- Internet Explorer 4 Common Controls  Chapter 9

Internet Explorer 4 Common Controls
===================================

When Microsoft developers released Internet Explorer 4 (IE4), they included a new and improved version of the COMCTL32.DLL, which houses Microsoft Windows Common Controls. Since this update to the common controls was not part of an operating system release, Microsoft calls the update Internet Explorer 4 Common Controls. IE4 Common Controls updates all of the existing controls and adds a variety of advanced new controls. Microsoft Visual C++ 6.0 and Microsoft Foundation Class (MFC) 6.0 have added a great deal of support for these new controls. In this chapter, we'll look at the new controls and show examples of how to use each one. If you haven't worked with Windows controls or Windows Common Controls, be sure you read [Chapter 6](ch06a.htm) before proceeding with IE4 Common Controls.

> NOTE
> 
> While Microsoft Windows 95 and Microsoft Windows NT 4.0 do not include the new COMCTL32.DLL, future versions of Windows will. To be safe, you will need to redistribute the COMCTL32.DLL for these existing operating systems as part of your installation. Currently you must ship a "developer's edition" of Internet Explorer to be able to redistribute these controls. However, this might change once a version of Windows ships with the updated controls. Be sure you check _[www.microsoft.com/msdn](http://www.microsoft.com/msdn)_ for the latest news on this subject.
________________________________________________________________________
5.7.1. - [An Introduction to the New Internet Explorer 4 Common Controls](invcpp5/ch09b.htm)
----------------------------------------------------
 An Introduction to the New Internet Explorer 4 Common Controls 

An Introduction to the New Internet Explorer 4 Common Controls
==============================================================

Example EX09A uses each of the new IE4 common controls. Figure 9-1 shows the dialog from that example. Refer to it when you read the control descriptions that follow.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F09OG01x.gif)]

**Figure 9-1.** _The new Internet Explorer 4 Common Controls dialog._

The Date and Time Picker
------------------------

A common field on a dialog is a place for the user to enter a date and time. Before IE4 controls provided the date and time picker, developers had to either use a third-party control or subclass an MFC edit control to do significant data validation to ensure that the entered date was valid. Fortunately, the new date and time picker control is provided as an advanced control that prompts the user for a date or time while offering the developer a wide variety of styles and options. For example, dates can be displayed in short formats (8/14/68) or long formats (August 14, 1968). A time mode lets the user enter a time using a familiar hours/minutes/seconds AM/PM format.

The control also lets you decide if you want the user to select the date via in-place editing, a pull-down calendar, or a spin button. Several selection options are available including single and multiple select (for a range of dates) and the ability to turn on and off the "circling" in red ink of the current date. The control even has a mode that lets the user select "no date" via a check box. In Figure 9-1, the first four controls on the left illustrate the variety of configurations available with the date and time picker control.

The new MFC 6.0 class _CDateTimeCtrl_ provides the MFC interface to the IE4 date and time picker common control. This class provides a variety of notifications that enhance the programmability of the control. _CDateTimeCtrl_ provides member functions for dealing with either _CTime_ or _COleDateTime_ time structures.

You set the date and time in a _CDateTimeCtrl_ using the _SetTime_ member function. You can retrieve the date and time via the _GetTime_ function. You can create custom formats using the _SetFormat_ member function and change a variety of other configurations using the _CDateTimeCtrl_ interface.

> **_CTime_ vs. _COleDateTime_**
> 
> Most "longtime" MFC developers are accustomed to using the _CTime_ class. However, since _CTime_'s valid dates are limited to dates between January 1, 1970, and January 18, 2038, many developers are looking for an alternative. One popular alternative is _COleDateTime,_ which is provided for OLE automation support and handles dates from 1 January 100 through 31 December 9999. Both classes have various pros and cons. For example, _CTime_ handles all the issues of daylight savings time, while _COleDateTime_ does not.
> 
> With the Year 2000 crisis looming ahead, many developers choose _COleDateTime_ because of its much larger range. Any application that uses _CTime_ will need to be reworked in approximately 40 years, since the maximum value is the year 2038. To see this limitation in action, select a date outside the _CTime_ range in EX09A. The class you decide to use will depend on your particular needs and the potential longevity of your application.

The Month Calendar
------------------

The large display at the bottom left of Figure 9-1 is a Month Calendar. Like the date and time picker control, the month calendar control lets the user choose a date. However, the month calendar control can also be used to implement a small Personal Information Manager (PIM) in your applications. You can show as many months as room provides—from one month to a year's worth of months, if you want. EX09A uses the month calendar control to show only two months.

The month calendar control supports single or multiple selection and allows you to display a variety of different options such as numbered months and a circled "today's date." Notifications for the control let the developer specify which dates are in boldface. It is entirely up to the developer to decide what boldface dates might represent. For example, you could use the bold feature to indicate holidays, appointments, or unusable dates. The MFC 6.0 class _CMonthCalCtrl_ implements this control.

To initialize the _CMonthCalCtrl_ class, you can call the _SetToday()_ member function. _CMonthCalCtrl_ provides members that deal with both _CTime_ and _COleDateTime,_ including _SetToday()._

The Internet Protocol Address Control
-------------------------------------

If you write an application that uses any form of Internet or TCP/IP functionality, you might need to prompt the user for an Internet Protocol (IP) Address. The IE4 common controls include an IP address edit control as shown in the top right of Figure 9-1. In addition to letting the user enter a 4-byte IP address, this control performs an automatic validation of the entered IP address. _CIPAddressCtrl_ provides MFC support for the IP address control.

An IP address consists of four "fields" as shown in Figure 9-2. The fields are numbered from left to right.

![](c:/dl/books/windows/msvc5th/invcpp5/images/F09OG02.GIF)

**Figure 9-2.** _The fields of an IP address control._

To initialize an IP address control, you call the _SetAddress_ member function in your _OnInitDialog_ function. _SetAddress_ takes a DWORD, with each BYTE in the DWORD representing one of the fields. In your message handlers, you can call the _GetAddress_ member function to retrieve a DWORD or a series of BYTES to retrieve the various values of the four IP address fields.

The Extended Combo Box
----------------------

The "old-fashioned" combo box was developed in the early days of Windows. Its age and inflexible design have been the source of a great deal of developer confusion. With the IE4 controls, Microsoft has decided to release a much more flexible version of the combo box called the extended combo box.

The extended combo box gives the developer much easier access to and control over the edit-control portion of the combo box. In addition, the extended combo box lets you attach an image list to the items in the combo box. You can display graphics in the extended combo box easily, especially when compared with the old days of using owner-drawn combo boxes. Each item in the extended combo box can be associated with three images: a selected image, an unselected image, and an overlay image. These three images can be used to provide a variety of graphical displays in the combo box, as we'll see in the EX09A sample. The bottom two combo boxes in Figure 9-1 are both extended combo boxes. The MFC _CComboBoxEx_ class provides comprehensive extended combo box support.

Like the list control introduced in [Chapter 6](ch06a.htm), _CComboBoxEx_ can be attached to a _CImageList_ that will automatically display graphics next to the text in the extended combo box. If you are already familiar with _CComboBox_, _CComboBoxEx_ might cause some confusion: instead of containing strings, the extended combo box contains items of type _COMBOBOXEXITEM_, a structure that consists of the following fields:

*   **_UINT mask_**—A set of bit flags that specify which operations are to be performed using the structure. For example, set the _CBEIF_IMAGE_ flag if the image field is to be set or retrieved in an operation.
    
*   **_int iItem_**—The extended combo box item number. Like the older style of combo box, the extended combo box uses zero-based indexing.
    
*   **_LPSTR pszText_**—The text of the item.
    
*   **_int cchTextMax_**—The length of the buffer available in pszText.
    
*   **_int iImage_**—Zero-based index into an associated image list.
    
*   **_int iSelectedImage_**—Index of the image in the image list to be used to represent the "selected" state.
    
*   **_int iOverlay_**—Index of the image in the image list to be used to overlay the current image.
    
*   **_int iIndent_**—Number of 10-pixel indentation spaces.
    
*   **_LPARAM lParam_**—32-bit parameter for the item.
    

You will see first-hand how to use this structure in the EX09A example.
________________________________________________________________________
5.7.2. - [The EX09A Example](invcpp5/ch09c.htm)
----------------------------------------------------
 The EX09A Example 

The EX09A Example
=================

To illustrate how to take advantage of the new Internet Explorer 4 Common Controls, we'll build a dialog that demonstrates how to create and program each control type. The steps required to create the dialog are shown below.

2.  **Run AppWizard to generate the EX09A project.** Choose New from the Visual C++ File menu, and then select Microsoft AppWizard (exe) from the Projects page. Accept all the defaults but one: choose Single Document Interface (SDI). The options and the default class names are shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G09OG01x.gif)
    
3.  **Create a new dialog resource with ID _IDD_DIALOG1_.** Place the controls as shown in Figure 9-1.
    
    You can drag the controls from the control palette, shown in [Chapter 6](ch06a.htm). Remember that IE4 Common Controls are at the bottom of the palette. The following table lists the control types and their IDs.
    
    **Tab Sequence**
    
    **Control Type**
    
    **Child Window ID**
    
    1
    
    Group Box
    
    _IDC_STATIC_
    
    2
    
    Static
    
    _IDC_STATIC_
    
    3
    
    Date Time Picker
    
    _IDC_DATETIMEPICKER1_
    
    4
    
    Static
    
    _IDC_STATIC1_
    
    5
    
    Static
    
    _IDC_STATIC_
    
    6
    
    Date Time Picker
    
    _IDC_DATETIMEPICKER2_
    
    7
    
    Static
    
    _IDC_STATIC2_
    
    8
    
    Static
    
    _IDC_STATIC_
    
    9
    
    Date Time Picker
    
    _IDC_DATETIMEPICKER3_
    
    10
    
    Static
    
    _IDC_STATIC3_
    
    11
    
    Static
    
    _IDC_STATIC_
    
    12
    
    Date Time Picker
    
    _IDC_DATETIMEPICKER4_
    
    13
    
    Static
    
    _IDC_STATIC4_
    
    14
    
    Static
    
    _IDC_STATIC_
    
    15
    
    Month Calendar
    
    _IDC_MONTHCALENDAR_
    
    16
    
    Static
    
    _IDC_STATIC5_
    
    17
    
    Group Box
    
    _IDC_STATIC_
    
    18
    
    Static
    
    _IDC_STATIC_
    
    19
    
    IP Address
    
    _IDC_IPADDRESS1_
    
    20
    
    Static
    
    _IDC_STATIC6_
    
    21
    
    Group Box
    
    _IDC_STATIC_
    
    22
    
    Static
    
    _IDC_STATIC_
    
    23
    
    Extended Combo Box
    
    _IDC_COMBOBOXEX1_
    
    24
    
    Static
    
    _IDC_STATIC7_
    
    25
    
    Static
    
    _IDC_STATIC_
    
    26
    
    Extended Combo Box
    
    _IDC_COMBOBOXEX2_
    
    27
    
    Static
    
    _IDC_STATIC8_
    
    28
    
    Pushbutton
    
    _IDOK_
    
    29
    
    Pushbutton
    
    _IDCANCEL_
    
    The following figure shows each control and its appropriate tab order.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G09OG02x.gif)]
    
    Until we set some properties, your dialog will not look exactly like the one in Figure 9-1.
    
4.  **Use ClassWizard to create a new class, _CDialog1_, derived from _CDialog_.** ClassWizard will automatically prompt you to create this class because it knows that the _IDD_DIALOG1_ resource exists without an associated C++ class. Go ahead and create a message handler for the WM_INITDIALOG message.
    
5.  **Set the properties for the dialog's controls.** To demonstrate the full range of controls, we will need to set a variety of properties on each of the IE4 common controls in the example. Here is a brief overview of each property you will need to set:
    
    *   **The Short Date and Time Picker.** To set up the first date and time picker control to use the short format, select the properties for _IDC_DATETIMEPICKER1,_ as shown in the following figure.
        
        ![](c:/dl/books/windows/msvc5th/invcpp5/images/G09OG03.GIF)
        
    *   **The Long Date and Time Picker.** Now configure the second date and time picker control (_IDC_DATETIMEPICKER2_) to use the long format as shown below.
        
        ![](c:/dl/books/windows/msvc5th/invcpp5/images/G09OG04.GIF)
        
    *   **The Short and NULL Date and Time Picker.** This is the third date and time picker control, _IDC_DATETIMEPICKER3_. Configure this third date and time picker to use the short format and the styles shown here.
        
        ![](c:/dl/books/windows/msvc5th/invcpp5/images/G09OG05.GIF)
        
    *   **The Time Picker.** The fourth date and time picker control, _IDC_DATETIMEPICKER4_, is configured to let the user choose time. To configure this control, select Time from the Format combo box on the Styles tab as shown.
        
        ![](c:/dl/books/windows/msvc5th/invcpp5/images/G09OG06.GIF)
        
    *   **The Month View.** To configure the month view, you will need to set a variety of styles. First, from the Styles tab, choose Day States, as shown here.
        
        ![](c:/dl/books/windows/msvc5th/invcpp5/images/G09OG07.GIF)
        
        If we leave the default styles, the month view does not look like a control on the dialog. There are no borders drawn at all. To make the control fit in with the other controls on the dialog, select Client Edge and Static Edge from the Extended Styles tab, as shown below.
        
        ![](c:/dl/books/windows/msvc5th/invcpp5/images/G09OG08.GIF)
        
    *   **The IP Address.**This control (_IDC_IPADDRESS1_) does not require any special properties.
        
    *   **The First Extended Combo Box.**Make sure that you enter some items, as shown here, and also make sure the list is tall enough to display several items.
        
        ![](c:/dl/books/windows/msvc5th/invcpp5/images/G09OG09.GIF)
        
    *   **The Second Extended Combo Box.**Enter three items: Tweety, Mack, and Jaws. Later in the example, we will use these items to show one of the ways to draw graphics in an extended combo box.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G09OG10.GIF)
    
6.  **Add the _CDialog1_ variables.** Start ClassWizard and click on the Member Variables tab to view the Member Variables page. Enter the following member variables for each control listed.
    
    **Control ID**
    
    _**Data Member**_
    
    _**Type**_
    
    _IDC_DATETIMEPICKER1_
    
    _m_MonthCal1_
    
    _CDateTimeCtrl_
    
    _IDC_DATETIMEPICKER2_
    
    _m_MonthCal2_
    
    _CDateTimeCtrl_
    
    _IDC_DATETIMEPICKER3_
    
    _m_MonthCal3_
    
    _CDateTimeCtrl_
    
    _IDC_DATETIMEPICKER4_
    
    _m_MonthCal4_
    
    _CDateTimeCtrl_
    
    _vIDC_IPADDRESS1_
    
    _m_ptrIPCtrl_
    
    _CIPAddressCtrl_
    
    _IDC_MONTHCALENDAR1_
    
    _m_MonthCal5_
    
    _CMonthCalCtrl_
    
    _IDC_STATIC1_
    
    _m_strDate1_
    
    _CString_
    
    _IDC_STATIC2_
    
    _m_strDate2_
    
    _CString_
    
    _IDC_STATIC3_
    
    _m_strDate3_
    
    _CString_
    
    _IDC_STATIC4_
    
    _m_strDate4_
    
    _CString_
    
    _IDC_STATIC5_
    
    _m_strDate5_
    
    _CString_
    
    _IDC_STATIC6_
    
    _m_strIPValue_
    
    _CString_
    
    _IDC_STATIC7_
    
    _m_strComboEx1_
    
    _CString_
    
    _IDC_STATIC8_
    
    _m_strComboEx2_
    
    _CString_
    
7.  **Program the short date time picker.** In this example, we don't mind if the first date time picker starts with the current date, so we don't have any _OnInitDialog_ handling for this control. However, if we wanted to change the date, we would make a call to _SetTime_ for the control in _OnInitDialog_. At runtime, when the user selects a new date in the first date and time picker, the companion static control should be automatically updated. To achieve this, we need to use ClassWizard to add a handler for the DTN_DATETIMECHANGE message. Start ClassWizard (CTRL-W) and choose _IDC_DATETIMEPICKER1_ from the Object IDs list and DTN_DATETIMECHANGE from the Messages list. Accept the default message name and click OK. Repeat this step for each of the other three _IDC_DATETIMEPICKER_ IDs. Your ClassWizard should look like the illustration here.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G09OG11x.gif)]
    
    Next add the following code to the handler for Datetimepicker1 created by ClassWizard:
    
    void CDialog1::OnDatetimechangeDatetimepicker1(NMHDR\* pNMHDR,
        LRESULT\* pResult) 
    {
        **CTime ct;
        m_MonthCal1.GetTime(ct);
        m_strDate1.Format(_T("%02d/%02d/%2d"),
                          ct.GetMonth(),ct.GetDay(),ct.GetYear());
        UpdateData(FALSE);**
        \*pResult = 0;
    }
    
    This code uses the _m_MonthCal1_ data member that maps to the first date time picker to retrieve the time into the _CTime_ object variable _ct_. It then calls the _CString::Format_ member function to set the companion static string. Finally the call to _UpdateData(FALSE)_ triggers MFC's DDX and causes the static to be automatically updated to _m_strDate1_.
    
8.  **Program the long date time picker.** Now we need to provide a similar handler for the second date time picker.
    
    void CDialog1::OnDatetimechangeDatetimepicker2(NMHDR\* pNMHDR, 
        LRESULT\* pResult) 
    {
        **CTime ct;
        m_MonthCal2.GetTime(ct);
        m_strDate2.Format(_T("%02d/%02d/%2d"),
                          ct.GetMonth(),ct.GetDay(),ct.GetYear());
        UpdateData(FALSE);**
    
        \*pResult = 0;
    }
    
9.  **Program the third date time picker.** The third date time picker needs a similar handler, but since we set the Show None style in the dialog properties, it is possible for the user to specify a NULL date by checking the inline check box. Instead of blindly calling _GetTime_, we have to check the return value. If the return value of the _GetTime_ call is nonzero, the user has selected a NULL date. If the return value is zero, a valid date has been selected. As in the previous two handlers, when a _CTime_ object is returned, it is converted into a string and automatically displayed in the companion static control.
    
    void CDialog1::OnDatetimechangeDatetimepicker3(NMHDR\* pNMHDR, 
        LRESULT\* pResult) 
    {
        **//NOTE: this one can be null!
        CTime ct;
        int nRetVal = m_MonthCal3.GetTime(ct);
        if (nRetVal) //If not zero, it's** **null; and if it is,
                     // do the right thing.
        {
            m_strDate3 = "NO DATE SPECIFIED!!";
        }
        else
        {
            m_strDate3.Format(_T("%02d/%02d/%2d"),ct.GetMonth(),
                              ct.GetDay(),ct.GetYear());
        }
        UpdateData(FALSE);**
        \*pResult = 0;
    }
    
10.  **Program the time picker.** The time picker needs a similar handler, but this time the format displays hours/minutes/seconds instead of months/days/years:
    
    void CDialog1::OnDatetimechangeDatetimepicker4(NMHDR\* pNMHDR, 
        LRESULT\* pResult) 
    {
        **CTime ct;
        m_MonthCal4.GetTime(ct);
        m_strDate4.Format(_T("%02d:%02d:%2d"),
                          ct.GetHour(),ct.GetMinute(),ct.GetSecond());
        UpdateData(FALSE);**
        \*pResult = 0;
    }
    
11.  **Program the Month Selector.** You might think that the month selector handler is similar to the date time picker's handler, but they are actually somewhat different. First of all, the message you need to handle for detecting when the user has selected a new date is the MCN_SELCHANGE message. Select this message in the ClassWizard, as shown here.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G09OG12x.gif)]
    
    In addition to the different message handler, this control uses _GetCurSel_ as the date time picker instead of _GetTime_. The code below shows the MCN_SELCHANGE handler for the month calendar control.
    
    void CDialog1::OnSelchangeMonthcalendar1(NMHDR\* pNMHDR, 
        LRESULT\* pResult) 
    {
        **CTime ct;
        m_MonthCal5.GetCurSel(ct);
        m_strDate5.Format(_T("%02d/%02d/%2d"),
                          ct.GetMonth(),ct.GetDay(),ct.GetYear());
        UpdateData(FALSE);**
        \*pResult = 0;
    }
    
12.  **Program the IP control.** First we need to make sure the control is initialized. In this example, we initialize the control to 0 by giving it a 0 DWORD value. If you do not initialize the control, each segment will be blank. To initialize the control, add this call to the _CDialog1::OnInitDialog_ function:
    
    **m_ptrIPCtrl.SetAddress(0L);**
    
    Now we need to add a handler to update the companion static control whenever the IP address control changes. First we need to add a handler for the IPN_FIELDCHANGED notification message using ClassWizard, as shown here.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G09OG13x.gif)]
    
    Next we need to implement the handler as follows:
    
    void CDialog1::OnFieldchangedIpaddress1(NMHDR\* pNMHDR, 
        LRESULT\* pResult) 
    {
        **DWORD dwIPAddress;
        m_ptrIPCtrl.GetAddress(dwIPAddress);
        
        m_strIPValue.Format("%d.%d.%d.%d   %x.%x.%x.%x",
            HIBYTE(HIWORD(dwIPAddress)),
            LOBYTE(HIWORD(dwIPAddress)),
            HIBYTE(LOWORD(dwIPAddress)),
            LOBYTE(LOWORD(dwIPAddress)),
            HIBYTE(HIWORD(dwIPAddress)),
            LOBYTE(HIWORD(dwIPAddress)),
            HIBYTE(LOWORD(dwIPAddress)),
            LOBYTE(LOWORD(dwIPAddress)));
        UpdateData(FALSE);**
        \*pResult = 0;
    }
    
    The first call to _CIPAddressCtrl::GetAddress_ retrieves the current IP address into the local _dwIPAddress_ _DWORD_ variable. Next we make a fairly complex call to _CString::Format_ to deconstruct the _DWORD_ into the various fields. This call uses the _LOWORD_ macro to first get to the bottom word of the _DWORD_ and the _HIBYTE/LOBYTE_ macros to further deconstruct the fields in order from field 0 to field 3.
    
13.  **Add a handler for the first extended combo box.** No special initialization is required for the extended combo box, but we do need to handle the CBN_SELCHANGE message. The following code shows the extended combo box handler. Can you spot the ways that this differs from a "normal" combo box control?
    
    void CDialog1::OnSelchangeComboboxex1() 
    {
        **COMBOBOXEXITEM cbi;
        CString str ("dummy_string");
        CComboBoxEx \* pCombo = (CComboBoxEx \*)GetDlgItem(IDC_COMBOBOXEX1);
    
        int nSel = pCombo->GetCurSel();
        cbi.iItem = nSel;
        cbi.pszText = (LPTSTR)(LPCTSTR)str;
        cbi.mask = CBEIF_TEXT;
        cbi.cchTextMax = str.GetLength();
        pCombo->GetItem(&cbi);
        SetDlgItemText(IDC_STATIC7,str);
        return;**
    }
    
    The first thing you probably noticed is the use of the _COMBOBOXEXITEM_ structure for the extended combo box instead of the plain integers used for items in an older combo box. Once the handler retrieves the item, it extracts the string and calls _SetDlgItemText_ to update the companion static control.
    
14.  **Add Images to the Items in the second extended combo box.** The first extended combo box does not need any special programming. It is used to demonstrate how to implement a simple extended combo box very similar to the older, nonextended combo box. The second combo box requires a good bit of programming. First we created six bitmaps and eight icons that we need to add to the resources for the project, as shown in the following illustration.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G09OG14.GIF)
    
    Of course, you are free to grab these images from the companion CD instead of recreating them all by hand, or you can choose to use any bitmaps and icons.
    
    There are two ways to add our graphics to an extended combo box. The first method is to attach images to existing combo box items. (Remember that we used the dialog editor to add the Tweety, Mack, and Jaws items to the combo box.) The second method is to add new items and specify their corresponding images at the time of addition.
    
    Before we start adding graphics to the extended combo box, let's create a public _CImageList_ data member in the _CDialog1_ class named _m_imageList_. Be sure you add the data member to the header file (Dialog1.h) for the class.
    
    Now we can add some of the bitmap images to the image list and then "attach" the images to the three items already in the extended combo box. Add the following code to your _CDialog1_'s _OnInitDialog_ method to achieve this:
    
        **//Initialize the IDC_COMBOBOXEX2
        CComboBoxEx\* pCombo =
            (CComboBoxEx\*) GetDlgItem(IDC_COMBOBOXEX2);
        //First let's add images to the items there.
        //We have six images in bitmaps to match to our strings:
    
        //CImageList \* pImageList = new CImageList();
        m_imageList.Create(32,16,ILC_MASK,12,4);
    
        CBitmap bitmap;
    
        bitmap.LoadBitmap(IDB_BMBIRD);
        m_imageList.Add(&bitmap, (COLORREF)0xFFFFFF);
        bitmap.DeleteObject();
    
        bitmap.LoadBitmap(IDB_BMBIRDSELECTED);
        m_imageList.Add(&bitmap, (COLORREF)0xFFFFFF);
        bitmap.DeleteObject();
        
        bitmap.LoadBitmap(IDB_BMDOG);
        m_imageList.Add(&bitmap, (COLORREF)0xFFFFFF);
        bitmap.DeleteObject();
        
        bitmap.LoadBitmap(IDB_BMDOGSELECTED);
        m_imageList.Add(&bitmap, (COLORREF)0xFFFFFF);
        bitmap.DeleteObject();    
            
        bitmap.LoadBitmap(IDB_BMFISH);
        m_imageList.Add(&bitmap, (COLORREF)0xFFFFFF);
        bitmap.DeleteObject();
        
        bitmap.LoadBitmap(IDB_BMFISHSELECTED);
        m_imageList.Add(&bitmap, (COLORREF)0xFFFFFF);
        bitmap.DeleteObject();    
    
        //Set the imagelist
        pCombo->SetImageList(&m_imageList);
        //Now attach the images to the items in the list.
        COMBOBOXEXITEM    cbi;
        cbi.mask = CBEIF_IMAGE|CBEIF_SELECTEDIMAGE|CBEIF_INDENT;
        CString strTemp;
        int nBitmapCount = 0;
        for (int nCount = 0;nCount < 3;nCount++)
        {
            cbi.iItem = nCount;
            cbi.pszText = (LPTSTR)(LPCTSTR)strTemp;
            cbi.cchTextMax = 256;
            pCombo->GetItem(&cbi);
            cbi.iImage = nBitmapCount++;
            cbi.iSelectedImage = nBitmapCount++;
            cbi.iIndent = (nCount & 0x03);
            pCombo->SetItem(&cbi);
    
        }**
    
    First the extended combo box initialization code creates a pointer to the control using _GetDlgItem_. Next it calls _Create_ to create memory for the images to be added and to initialize the image list. The next series of calls loads each bitmap, adds them to the image list, and then deletes the resource allocated in the load.
    
    _CComboBoxEx::SetImageList_ is called to associate the _m_imageList_ with the extended combo box. Next a _COMBOBOXEXITEM_ structure is initialized with a mask, and then the _for_ loop iterates from 0 through 2, setting the selected and unselected images with each pass through the loop. The variable _nBitmapCount_ increments through the image list to ensure that the correct image ID is put into the _COMBOBOXEXITEM_ structure. The _for_ loop makes a call to _CComboBoxEx::GetItem_ to retrieve the _COMBOBOXEXITEM_ structure for each item in the extended combo box. Then the loop sets up the images for the list item and finally calls _CComboBoxEx::SetItem_ to put the modified _COMBOBOXEXITEM_ structure back into the extended combo box and complete the association of images with the existing items in the list.
    
15.  **Add Items to the Extended Combobox.** The other technique available for putting images into an extended combo box is to add them dynamically, as shown in the code added to _OnInitDialog_ below:
    
       ** HICON hIcon[8];
        int n;
    //Now let's insert some color icons
        hIcon[0] = AfxGetApp()->LoadIcon(IDI_WHITE);
        hIcon[1] = AfxGetApp()->LoadIcon(IDI_BLACK);
        hIcon[2] = AfxGetApp()->LoadIcon(IDI_RED);
        hIcon[3] = AfxGetApp()->LoadIcon(IDI_BLUE);
        hIcon[4] = AfxGetApp()->LoadIcon(IDI_YELLOW);
        hIcon[5] = AfxGetApp()->LoadIcon(IDI_CYAN);
        hIcon[6] = AfxGetApp()->LoadIcon(IDI_PURPLE);
        hIcon[7] = AfxGetApp()->LoadIcon(IDI_GREEN);
        for (n = 0; n < 8; n++) {
            m_imageList.Add(hIcon[n]);
        }
    
        static char\* color[] = {"white", "black", "red",
                                "blue", "yellow", "cyan",
                                "purple", "green"};
    
        cbi.mask = CBEIF_IMAGE|CBEIF_TEXT|CBEIF_OVERLAY|
                   CBEIF_SELECTEDIMAGE;
    
        for (n = 0; n < 8; n++) {**
          **  cbi.iItem = n;
            cbi.pszText = color[n];
            cbi.iImage = n+6; //6 is the offset into the image list from
            cbi.iSelectedImage = n+6; // the first six items we added...
            cbi.iOverlay = n+6;
            int nItem = pCombo->InsertItem(&cbi);
            ASSERT(nItem == n);
        }**
    
    The addition of the icons above is similar to the EX06B list control example in [Chapter 6](ch06a.htm). The _for_ loop fills out the _COMBOBOXEXITEM_ structure and then calls _CComboBoxEx::InsertItem_ with each item to add it to the list.
    
16.  **Add a handler for the second extended combo box.** The second extended combo box handler is essentially the same as the first:
    
    void CDialog1::OnSelchangeComboboxex2() 
    {
        **COMBOBOXEXITEM cbi;
        CString str ("dummy_string");
        CComboBoxEx \* pCombo = (CComboBoxEx \*)GetDlgItem(IDC_COMBOBOXEX2);
        int nSel = pCombo->GetCurSel();
        cbi.iItem = nSel;
        cbi.pszText = (LPTSTR)(LPCTSTR)str;
        cbi.mask = CBEIF_TEXT;
        cbi.cchTextMax = str.GetLength();
        pCombo->GetItem(&cbi);
        SetDlgItemText(IDC_STATIC8,str);
    
        return;**
    }
    
17.  **Connect the view and the dialog.** Add code to the virtual _OnDraw_ function in ex09aView.cpp. The following boldface code replaces the previous code:
    
    void CEx09aView::OnDraw(CDC\* pDC)
    {
        **pDC->TextOut(0, 0, "Press the left mouse button here.");**
    }
    
18.  **Use ClassWizard to add the _OnLButtonDown_ member function to the CEx09aView class.** Edit the AppWizard-generated code as follows:
    
    void CEx09aView::OnLButtonDown(UINT nFlags, CPoint point)
    {
        **CDialog1 dlg;
        dlg.DoModal();**
    }
    
    Add a statement to include Dialog1.h in file ex09aView.cpp.
    
19.  **Compile and run the program.** Now you can experiment with the various IE4 common controls to see how they work and how you can apply them in your own applications.
________________________________________________________________________
5.8. - [Chapter 10 -- Win32 Memory Management](invcpp5/ch10a.htm)
----------------------------------------------------
 Chapter 10 -- Win32 Memory Management  Chapter 10

Win32 Memory Management
=======================

Forget everything you ever knew about Win16 memory management. Some of the Win16 memory management functions, such as _GlobalAlloc_, were carried forward into Win32, but this was done to enable developers to port source code quickly. Underneath, the original functions work very differently, and many new ones have been added.

This chapter starts out with a dose of Win32 memory management theory, which includes coverage of the fundamental heap management functions. Then you'll see how the C++ _new_ and _delete_ operators connect with the underlying heap functions. Finally, you'll learn how to use the memory-mapped file functions, and you'll get some practical tips on managing dynamic memory. In no way is this chapter intended to be a definitive description of Win32 memory management. For that, you'll have to read Jeffrey Richter's _Advanced Windows_ (Microsoft Press, 1997). (Be sure you have the latest edition—a new version may be in the works that covers Microsoft Windows 98/NT 5.0.)

> NOTE
> 
> At the time this edition was written, both Windows 98 and Windows NT 5.0 were in beta and not released. Our examination of these betas indicates that the memory management has not changed significantly.
________________________________________________________________________
5.8.1. - [Processes and Memory Space](invcpp5/ch10b.htm)
----------------------------------------------------
 Processes and Memory Space 

Processes and Memory Space
==========================

Before you learn how Microsoft Windows manages memory, you must first understand what a process is. If you already know what a program is, you're on your way. A program is an EXE file that you can launch in various ways in Windows. Once a program is running, it's called a process. A process owns its memory, file handles, and other system resources. If you launch the same program twice in a row, you have two separate processes running simultaneously. Both the Microsoft Windows NT Task Manager (right-click the taskbar) and the Microsoft Windows 95 PVIEW95 program give you a detailed list of processes that are currently running, and they allow you to kill processes that are not responding. The SPYXX program shows the relationships among processes, tasks, and windows.

> NOTE
> 
> The Windows taskbar shows main windows, not processes. A single process (such as Windows Explorer) might have several main windows, each supported by its own thread, and some processes don't have windows at all. (See [Chapter 12](ch12a.htm) for a discussion of threads.)

The important thing to know about a process is that it has its own "private" 4-gigabyte (GB) virtual address space (which I'll describe in detail in the next section). For now, pretend that your computer has hundreds of gigabytes of RAM and that each process gets 4 GB. Your program can access any byte of this space with a single 32-bit linear address. Each process's memory space contains a variety of items, including the following:

*   Your program's EXE image
    
*   Any nonsystem DLLs that your program loads, including the MFC DLLs
    
*   Your program's global data (read-only as well as read/write)
    
*   Your program's stack
    
*   Dynamically allocated memory, including Windows and C runtime library (CRT) heaps
    
*   Memory-mapped files
    
*   Interprocess shared memory blocks
    
*   Memory local to specific executing threads
    
*   All sorts of special system memory blocks, including virtual memory tables
    
*   The Windows kernel and executive, plus DLLs that are part of Windows

The Windows 95 Process Address Space
------------------------------------

In Windows 95, only the bottom 2 GB (0 to 0x7FFFFFFF) of address space is truly private, and the bottom 4 MB of that is off-limits. The stack, heaps, and read/write global memory are mapped in the bottom 2 GB along with application EXE and DLL files.

The top 2 GB of space is the same for all processes and is shared by all processes. The Windows 95 kernel, executive, virtual device drivers (VxDs), and file system code, along with important tables such as page tables, are mapped to the top 1 GB (0xC0000000 to 0xFFFFFFFF) of address space. Windows DLLs and memory-mapped files are located in the range 0x80000000 to 0xBFFFFFFF. Figure 10-1 shows a memory map of two processes using the same program.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F10OG01x.gif)]

**Figure 10-1.** _A typical Windows 95 virtual memory map for two processes linked to the same EXE file._

How safe is all this? It's next to impossible for one process to overwrite another process's stack, global, or heap memory because this memory, located in the bottom 2 GB of virtual address space, is assigned only to that specific process. All EXE and DLL code is flagged as read-only, so there's no problem if the code is mapped in several processes.

However, because important Windows read/write data is mapped there, the top 1 GB of address space is vulnerable. An errant program could wipe out important system tables located in this region. In addition, one process could mess up another process's memory-mapped files in the range 0x80000000 through 0xBFFFFFFF because this region is shared by all processes.

The Windows NT Process Address Space
------------------------------------

A process in Windows NT can access only the bottom 2 GB of its address space, and the lowest and highest 64 KB of that is inaccessible. The EXE, the application's DLLs and Windows DLLs, and memory-mapped files all reside in this space between 0x00010000 and 0x7FFEFFFF. The Windows NT kernel, executive, and device drivers all reside in the upper 2 GB, where they are completely protected from any tampering by an errant program. Memory-mapped files are safer, too. One process cannot access another's memory-mapped file without knowing the file's name and explicitly mapping a view.
________________________________________________________________________
5.8.2. - [How Virtual Memory Works](invcpp5/ch10c.htm)
----------------------------------------------------
 How Virtual Memory Works 

How Virtual Memory Works
========================

You know that your computer doesn't really have hundreds of gigabytes of RAM. And it doesn't have hundreds of gigabytes of disk space either. Windows uses some smoke and mirrors here.

First of all, a process's 4-GB address space is going to be used sparsely. Various programs and data elements will be scattered throughout the 4-GB address space in 4-KB units starting on 4-KB boundaries. Each 4-KB unit, called a page, can hold either code or data. When a page is being used, it occupies physical memory, but you never see its physical memory address. The Intel microprocessor chip efficiently maps a 32-bit virtual address to both a physical page and an offset within the page, using two levels of 4-KB page tables, as shown in Figure 10-2. Note that individual pages can be flagged as either read-only or read/write. Also note that each process has its own set of page tables. The chip's CR3 register holds a pointer to the directory page, so when Windows switches from one process to another, it simply updates CR3.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F10OG02x.gif)]

**Figure 10-2.** _Win32 virtual memory management (Intel)._

So now our process is down from 4 GB to maybe 5 MB—a definite improvement. But if we're running several programs, along with Windows itself, we'll still run out of RAM. If you look at Figure 10-2 again, you'll notice that the page table entry has a "present" bit that indicates whether the 4-KB page is currently in RAM. If we try to access a page that's not in RAM, an interrupt fires and Windows analyzes the situation by checking its internal tables. If the memory reference was bogus, we'll get the dreaded "page fault" message and the program will exit. Otherwise, Windows reads the page from a disk file into RAM and updates the page table by loading the physical address and setting the present bit. This is the essence of Win32 virtual memory.

The Windows virtual memory manager figures out how to read and write 4-KB pages so that it optimizes performance. If one process hasn't used a page for a while and another process needs memory, the first page is swapped out or discarded and the RAM is used for the new process's page. Your program isn't normally aware that this is going on. The more disk I/O that happens, however, the worse your program's performance will be, so it stands to reason that more RAM is better.

I mentioned the word "disk," but I haven't talked about files yet. All processes share a big systemwide swap file that's used for all read/write data and some read-only data. (Windows NT supports multiple swap files.) Windows determines the swap file size based on available RAM and free disk space, but there are ways to fine-tune the swap file's size and specify its physical location on disk.

The swap file isn't the only file used by the virtual memory manager, however. It wouldn't make sense to write code pages back to the swap file, so instead of using the swap file, Windows maps EXE and DLL files directly to their files on disk. Because the code pages are marked read-only, there's never a need to write them back to disk.

If two processes use the same EXE file, that file is mapped into each process's address space. The code and constants never change during program execution, so the same physical memory can be mapped for each process. The two processes cannot share global data, however, and Windows 95 and Windows NT handle this situation differently. Windows 95 maps separate copies of the global data to each process. In Windows NT, both processes use the same copy of each page of global data until one process attempts to write to that page. At that point the page is copied; as a result, each process has its own private copy stored at the same virtual address.

> NOTE
> 
> A dynamic link library can be mapped directly to its DLL file only if the DLL can be loaded at its designated base address. If a DLL were statically linked to load at, say, 0x10000000 but that address range is already occupied by another DLL, Windows must "fix up" the addresses within the DLL code. Windows NT copies the altered pages to the swap file when the DLL is first loaded, but Windows 95 can do the fixup "on the fly" when the pages are brought into RAM. Needless to say, it's important to build your DLLs with nonoverlapping address ranges. If you're using the MFC DLLs, set the base address of your own DLLs outside the range 0x5F400000 through 0x5FFFFFFF. [Chapter 22](ch22a.htm) provides more details on writing DLLs.

Memory-mapped files, which I'll talk about later, are also mapped directly. These can be flagged as read/write and made available for sharing among processes.

> **For Win32 Programmers: Segment Registers in Win32**
> 
> If you've experimented with the debugger in Win32, you may have noticed the segment registers, particularly CS, DS, and SS. These 16-bit relics haven't gone away, but you can mostly ignore them. In 32-bit mode, the Intel microprocessor still uses segment registers, which are 16 bits long, to translate addresses prior to sending them through the virtual memory system. A table in RAM, called the descriptor table, has entries that contain the virtual memory base address and block size for code, data, and stack segments. In 32-bit mode, these segments can be up to 4 GB in size and can be flagged as read-only or read/write. For every memory reference, the chip uses the selector, the contents of a segment register, to look up the descriptor table entry for the purpose of translating the address.
> 
> Under Win32, each process has two segments—one for code and one for data and the stack. You can assume that both have a base value of 0 and a size of 4 GB, so they overlap. The net result is no translation at all, but Windows uses some tricks that exclude the bottom 16 KB from the data segment. If you try to access memory down there, you get a protection fault instead of a page fault, which is useful for debugging null pointers.
> 
> Some future operating system might someday use segments to get around that annoying 4-GB size limitation, but by then we'll have Win64 to worry about!
________________________________________________________________________
5.8.3. - [The VirtualAlloc Function -- Committed and Reserved Memory](invcpp5/ch10d.htm)
----------------------------------------------------
 The VirtualAlloc Function -- Committed and Reserved Memory 

The _VirtualAlloc_ Function—Committed and Reserved Memory
=========================================================

If your program needs dynamic memory, sooner or later the Win32 _VirtualAlloc_ function will be called. Chances are that your program will never call _VirtualAlloc_; instead you'll rely on the Windows heap or the CRT heap functions to call it directly. Knowing how _VirtualAlloc_ works, however, will help you better understand the functions that call it.

First you must know the meanings of reserved and committed memory. When memory is reserved, a contiguous virtual address range is set aside. If, for example, you know that your program is going to use a single 5-MB memory block (known as a region) but you don't need to use it all right away, you call _VirtualAlloc_ with a _MEM_RESERVE_ allocation type parameter and a 5-MB size parameter. Windows rounds the start address of the region to a 64-KB boundary and prevents your process from reserving other memory in the same range. You can specify a start address for your region, but more often you'll let Windows assign it for you. Nothing else happens. No RAM is allocated, and no swap file space is set aside.

When you get more serious about needing memory, you call _VirtualAlloc_ again to commit the reserved memory, using a _MEM_COMMIT_ allocation type parameter. Now the start and end addresses of the region are rounded to 4-KB boundaries, and corresponding swap file pages are set aside together with the required page table. The block is designated either read-only or read/write. Still no RAM is allocated, however; RAM allocation occurs only when you try to access the memory. If the memory was not previously reserved, no problem. If the memory was previously committed, still no problem. The rule is that memory must be committed before you can use it.

You call the _VirtualFree_ function to "decommit" committed memory, thereby returning the designated pages back to reserved status. _VirtualFree_ can also free a reserved region of memory, but you have to specify the base address you got from a previous _VirtualAlloc_ reservation call.
________________________________________________________________________
5.8.4. - [The Windows Heap and the GlobalAlloc Function Family](invcpp5/ch10e.htm)
----------------------------------------------------
 The Windows Heap and the GlobalAlloc Function Family 

The Windows Heap and the _GlobalAlloc_ Function Family
======================================================

A heap is a memory pool for a specific process. When your program needs a block of memory, it calls a heap allocation function, and it calls a companion function to free the memory. There's no assumption about 4-KB page boundaries; the heap manager uses space in existing pages or calls _VirtualAlloc_ to get more pages. First we'll look at Windows heaps. Next we'll consider heaps managed by the CRT library for functions like _malloc_ and _new_.

Windows provides each process with a default heap, and the process can create any number of additional Windows heaps. The _HeapAlloc_ function allocates memory in a Windows heap, and _HeapFree_ releases it.

You might never need to call _HeapAlloc_ yourself, but it will be called for you by the _GlobalAlloc_ function that's left over from Win16. In the ideal 32-bit world, you wouldn't have to use _GlobalAlloc_, but in this real world, we're stuck with a lot of code ported from Win16 that uses "memory handle" (_HGLOBAL_) parameters instead of 32-bit memory addresses.

_GlobalAlloc_ uses the default Windows heap. It does two different things, depending on its attribute parameter. If you specify _GMEM_FIXED_, _GlobalAlloc_ simply calls _HeapAlloc_ and returns the address cast as a 32-bit _HGLOBAL_ value. If you specify _GMEM_MOVEABLE_, the returned _HGLOBAL_ value is a pointer to a handle table entry in your process. That entry contains a pointer to the actual memory, which is allocated with _HeapAlloc_.

Why bother with "moveable" memory if it adds an extra level of indirection? You're looking at an artifact from Win16, in which, once upon a time, the operating system actually moved memory blocks around. In Win32, moveable blocks exist only to support the _GlobalReAlloc_ function, which allocates a new memory block, copies bytes from the old block to the new, frees the old block, and assigns the new block address to the existing handle table entry. If nobody called _GlobalReAlloc_, we could always use _HeapAlloc_ instead of _GlobalAlloc_.

Unfortunately, many library functions use _HGLOBAL_ return values and parameters instead of memory addresses. If such a function returns an _HGLOBAL_ value, you should assume that memory was allocated with the _GMEM_MOVEABLE_ attribute, and that means you must call the _GlobalLock_ function to get the memory address. (If the memory was fixed, the _GlobalLock_ call just returns the handle as an address.) Call _GlobalUnlock_ when you're finished accessing the memory. If you're required to supply an _HGLOBAL_ parameter, to be absolutely safe you should generate it with a _GlobalAlloc(GMEM_MOVEABLE, …)_ call in case the called function decides to call _GlobalReAlloc_ and expects the handle value to be unchanged.
________________________________________________________________________
5.8.5. - [The Small-Block Heap, the C++ new and delete Operators, and _heapmin](invcpp5/ch10f.htm)
----------------------------------------------------
 The Small-Block Heap, the C++ new and delete Operators, and _heapmin 

The Small-Block Heap, the C++ _new_ and _delete_ Operators, and __heapmin_
===========================================================================

You can use the Windows _HeapAlloc_ function in your programs, but you're more likely to use the _malloc_ and _free_ functions supplied by the CRT. If you write C++ code, you won't call these functions directly; instead, you'll use the _new_ and _delete_ operators, which map directly to _malloc_ and _free_. If you use _new_ to allocate a block larger than a certain threshold (480 bytes is the default), the CRT passes the call straight through to _HeapAlloc_ to allocate memory from a Windows heap created for the CRT. For blocks smaller than the threshold, the CRT manages a small-block heap, calling _VirtualAlloc_ and _VirtualFree_ as necessary. Here is the algorithm:

1.  Memory is reserved in 4-MB regions.
    
2.  Memory is committed in 64-KB blocks (16 pages).
    
3.  Memory is decommitted 64 KB at a time. As 128 KB becomes free, the last 64 KB is decommitted.
    
4.  A 4-MB region is released when every page in that region has been decommitted.
    

As you can see, this small-block heap takes care of its own cleanup. The CRT's Windows heap doesn't automatically decommit and unreserve pages, however. To clean up the larger blocks, you must call the CRT __heapmin_ function, which calls the windows _HeapCompact_ function. (Unfortunately, the Windows 95 version of _HeapCompact_ doesn't do anything—all the more reason to use Windows NT.) Once pages are decommitted, other programs can reuse the corresponding swap file space.

> NOTE
> 
> In previous versions of the CRT, the free list pointers were stored inside the heap pages. This strategy required the _malloc_ function to "touch" (read from the swap file) many pages to find free space, and this degraded performance. The current system, which stores the free list in a separate area of memory, is faster and minimizes the need for third-party heap management software.

If you want to change or access the block size threshold, use the CRT functions __set_sbh_threshold_ and __get_sbh_threshold_.

A special debug version of _malloc_, __malloc_dbg_, adds debugging information inside allocated memory blocks. The _new_ operator calls __malloc_dbg_ when you build an MFC project with __DEBUG_ defined. Your program can then detect memory blocks that you forgot to free or that you inadvertently overwrote.
________________________________________________________________________
5.8.6. - [Memory-Mapped Files](invcpp5/ch10g.htm)
----------------------------------------------------
 Memory-Mapped Files 

Memory-Mapped Files
===================

In case you think you don't have enough memory management options already, I'll toss you another one. Suppose your program needs to read a DIB (device-independent bitmap) file. Your instinct would be to allocate a buffer of the correct size, open the file, and then call a read function to copy the whole disk file into the buffer. The Windows memory-mapped file is a more elegant tool for handling this problem, however. You simply map an address range directly to the file. When the process accesses a memory page, Windows allocates RAM and reads the data from disk. Here's what the code looks like:

HANDLE hFile = ::CreateFile(strPathname, GENERIC_READ, 
    FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
ASSERT(hFile != NULL);
HANDLE hMap = ::CreateFileMapping(hFile, NULL, PAGE_READONLY,
    0, 0, NULL);
ASSERT(hMap != NULL);
LPVOID lpvFile = ::MapViewOfFile(hMap, FILE_MAP_READ,
    0, 0, 0); // Map whole file
DWORD dwFileSize = ::GetFileSize(hFile, NULL);  // useful info
// Use the file
::UnmapViewOfFile(lpvFile);
::CloseHandle(hMap);
::CloseHandle(hFile);

Here you're using virtual memory backed by the DIB file. Windows determines the file size, reserves a corresponding address range, and commits the file's storage as the physical storage for this range. In this case, _lpvFile_ is the start address. The _hMap_ variable contains the handle for the file mapping object, which can be shared among processes if desired.

The DIB in the example above is a small file that you could read entirely into a buffer. Imagine a larger file for which you would normally issue seek commands. A memory-mapped file works for such a file, too, because of the underlying virtual memory system. RAM is allocated and pages are read when you access them, and not before.

> NOTE
> 
> By default, the entire file is committed when you map it, although it's possible to map only part of a file.

If two processes share a file mapping object (such as _hMap_ in the sample code above), the file itself is, in effect, shared memory, but the virtual addresses returned by _MapViewOfFile_ might be different. Indeed, this is the preferred Win32 method of sharing memory. (Calling the _GlobalAlloc_ function with the _GMEM_SHARE_ flag doesn't create shared memory as it did in Win16.) If memory sharing is all you want to do and you don't need a permanent disk file, you can omit the call to _CreateFile_ and pass 0xFFFFFFFF as the _CreateFileMapping hFile_ parameter. Now the shared memory will be backed by pages in the swap file. Consult Richter for details on memory-mapped files. The EX35B and EX35C sample programs in [Chapter 35](ch35a.htm) illustrate sharing of memory-mapped files.

> NOTE
> 
> If you intend to access only a few random pages of a file mapping object that is backed by the swap file, you can use a technique that Jeffrey Richter describes in _Advanced Windows_ under the heading "Sparsely Committed Memory-Mapped Files." In this case, you call _CreateFileMapping_ with a special flag and then you commit specific address ranges later with the _VirtualAlloc_ function.

> NOTE
> 
> You might want to look carefully at the Windows message WM_COPYDATA. This message lets you transfer data between processes in shared memory without having to deal with the file mapping API. You must send this message rather than post it, which means the sending process has to wait while the receiving process copies and processes the data.

Unfortunately, there's no direct support for memory-mapped files or shared memory in MFC. The _CSharedFile_ class supports only clipboard memory transfers using _HGLOBAL_ handles, so the class isn't as useful as its name implies.
________________________________________________________________________
5.8.7. - [Accessing Resources](invcpp5/ch10h.htm)
----------------------------------------------------
 Accessing Resources 

Accessing Resources
===================

Resources are contained inside EXEs and DLLs and thus occupy virtual address space that doesn't change during the life of the process. This fact makes it easy to read a resource directly. If you need to access a bitmap, for example, you can get the DIB address with code like this:

LPVOID lpvResource = (LPVOID) ::LoadResource(NULL, 
    ::FindResource(NULL, MAKEINTRESOURCE(IDB_REDBLOCKS), 
    RT_BITMAP));

The _LoadResource_ function returns an _HGLOBAL_ value, but you can safely cast it to a pointer.
________________________________________________________________________
5.8.8. - [Some Tips for Managing Dynamic Memory](invcpp5/ch10i.htm)
----------------------------------------------------
 Some Tips for Managing Dynamic Memory 

Some Tips for Managing Dynamic Memory
=====================================

The more you use the heap, the more fragmented it gets and the more slowly your program runs. If your program is supposed to run for hours or days at a time, you have to be careful. It's better to allocate all the memory you need when your program starts and then free it when the program exits, but that's not always possible. The _CString_ class is a nuisance because it's constantly allocating and freeing little bits of memory. Fortunately, MFC developers have recently made some improvements.

Don't forget to call __heapmin_ every once in a while if your program allocates blocks larger than the small-block heap threshold. And be careful to remember where heap memory comes from. You'd have a big problem, for instance, if you called _HeapFree_ on a small-block pointer you got from _new_.

Be aware that your stack can be as big as it needs to be. Because you no longer have a 64-KB size limit, you can put large objects on the stack, thereby reducing the need for heap allocations.

As in Win16, your program doesn't run at full speed and then suddenly throw an exception when Windows runs out of swap space. Your program just slowly grinds to a halt, making your customer unhappy. And there's not much you can do except try to figure out which program is eating memory and why. Because the Windows 95 USER and GDI modules still have 16-bit components, there is some possibility of exhausting the 64-KB heaps that hold GDI objects and window structures. This possibility is pretty remote, however, and if it happens, it probably indicates a bug in your program.
________________________________________________________________________
5.8.9. - [Optimizing Storage for Constant Data](invcpp5/ch10j.htm)
----------------------------------------------------
 Optimizing Storage for Constant Data 

Optimizing Storage for Constant Data
====================================

Remember that the code in your program is backed not by the swap file but directly by its EXE and DLL files. If several instances of your program are running, the same EXE and DLL files will be mapped to each process's virtual address space. What about constant data? You would want that data to be part of the program rather than have it copied to another block of address space that's backed by the swap file.

You've got to work a little bit to ensure that constant data gets stored with the program. First consider string constants, which often permeate your programs. You would think that these would be read-only data, but guess again. Because you're allowed to write code like this:

char\* pch = "test";
\*pch = \`x';

"_test_" can't possibly be constant data, and it isn't.

If you want "_test_" to be a constant, you must declare it as an initialized _const_ static or global variable. Here's the global definition:

const char g_pch[] = "test";

Now _g_pch_ is stored with the code, but where, specifically? To answer that, you must understand the "data sections" that the Visual C++ linker generates. If you set the link options to generate a map file, you'll see a long list of the sections (memory blocks) in your program. Individual sections can be designated for code or data, and they can be read-only or read/write. The important sections and their characteristics are listed here.

**Name**

**Type**

**Access**

**Contents**

.text

Code

Read-only

Program code

.rdata

Data

Read-only

Constant initialized data

.data

Data

Read/write

Nonconstant initialized data

.bss

Data

Read/write

Nonconstant uninitialized data

The .rdata section is part of the EXE file, and that's where the linker puts the _g_pch_ variable. The more stuff you put in the .rdata section, the better. The use of the _const_ modifier does the trick.

You can put built-in types and even structures in the .rdata section, but you can't put C++ objects there if they have constructors. If you write a statement like the following one:

const CRect g_rect(0, 0, 100, 100);

the linker puts the object into the .bss section, and it will be backed separately to the swap file for each process. If you think about it, this makes sense because the compiler must invoke the constructor function after the program is loaded.

Now suppose you wanted to do the worst possible thing. You'd declare a _CString_ global variable (or static class data member) like this:

const CString g_str("this is the worst thing I can do");

Now you've got the _CString_ object (which is quite small) in the .bss section, and you've also got a character array in the .data section, neither of which can be backed by the EXE file. To make matters worse, when the program starts, the _CString_ class must allocate heap memory for a copy of the characters. You would be much better off using a _const_ character array instead of a _CString_ object.
________________________________________________________________________
5.9. - [Chapter 11 -- Bitmaps](invcpp5/ch11a.htm)
----------------------------------------------------
 Chapter 11 -- Bitmaps  Chapter 11

Bitmaps
=======

Without graphics images, Microsoft Windows-based applications would be pretty dull. Some applications depend on images for their usefulness, but any application can be spruced up with the addition of decorative clip art from a variety of sources. Windows bitmaps are arrays of bits mapped to display pixels. That might sound simple, but you have to learn a lot about bitmaps before you can use them to create professional applications for Windows.

This chapter starts with the "old" way of programming bitmaps—creating the device-dependent GDI bitmaps that work with a memory device context. You need to know these techniques because many programmers are still using them and you'll also need to use them on occasion.

Next you'll graduate to the modern way of programming bitmaps—creating device-independent bitmaps (DIBs). If you use DIBs, you'll have an easier time with colors and with the printer. In some cases you'll get better performance. The Win32 function _CreateDIBSection_ gives you the benefits of DIBs combined with all the features of GDI bitmaps.

Finally, you'll learn how to use the MFC _CBitmapButton_ class to put bitmaps on pushbuttons. (Using _CBitmapButton_ to put bitmaps on pushbuttons has nothing to do with DIBs, but it's a useful technique that would be difficult to master without an example.)
________________________________________________________________________
5.9.1. - [GDI Bitmaps and Device-Independent Bitmaps](invcpp5/ch11b.htm)
----------------------------------------------------
 GDI Bitmaps and Device-Independent Bitmaps 

GDI Bitmaps and Device-Independent Bitmaps
==========================================

There are two kinds of Windows bitmaps: GDI bitmaps and DIBs. GDI bitmap objects are represented by the Microsoft Foundation Class (MFC) Library version 6.0 _CBitmap_ class. The GDI bitmap object has an associated Windows data structure, maintained inside the Windows GDI module, that is device-dependent. Your program can get a copy of the bitmap data, but the bit arrangement depends on the display hardware. GDI bitmaps can be freely transferred among programs on a single computer, but because of their device dependency, transferring bitmaps by disk or modem doesn't make sense.

> NOTE
> 
> In Win32, you're allowed to put a GDI bitmap handle on the clipboard for transfer to another process, but behind the scenes Windows converts the device-dependent bitmap to a DIB and copies the DIB to shared memory. That's a good reason to consider using DIBs from the start.

DIBs offer many programming advantages over GDI bitmaps. Because a DIB carries its own color information, color palette management is easier. DIBs also make it easy to control gray shades when printing. Any computer running Windows can process DIBs, which are usually stored in BMP disk files or as a resource in your program's EXE or DLL file. The wallpaper background on your monitor is read from a BMP file when you start Windows. The primary storage format for Microsoft Paint is the BMP file, and Visual C++ uses BMP files for toolbar buttons and other images. Other graphic interchange formats are available, such as TIFF, GIF, and JPEG, but only the DIB format is directly supported by the Win32 API.

Color Bitmaps and Monochrome Bitmaps
------------------------------------

Now might be a good time to reread the "[Windows Color Mapping](ch05d.htm#97)" section in Chapter 5. As you'll see in this chapter, Windows deals with color bitmaps a little differently from the way it deals with brush colors.

Many color bitmaps are 16-color. A standard VGA board has four contiguous color planes, with 1 corresponding bit from each plane combining to represent a pixel. The 4-bit color values are set when the bitmap is created. With a standard VGA board, bitmap colors are limited to the standard 16 colors. Windows does not use dithered colors in bitmaps.

A monochrome bitmap has only one plane. Each pixel is represented by a single bit that is either off (0) or on (1). The _CDC::SetTextColor_ function sets the "off" display color, and _SetBkColor_ sets the "on" color. You can specify these pure colors individually with the Windows _RGB_ macro.
________________________________________________________________________
5.9.2. - [Using GDI Bitmaps](invcpp5/ch11c.htm)
----------------------------------------------------
 Using GDI Bitmaps 

Using GDI Bitmaps
=================

A GDI bitmap is simply another GDI object, such as a pen or a font. You must somehow create a bitmap, and then you must select it into a device context. When you're finished with the object, you must deselect it and delete it. You know the drill.

There's a catch, though, because the "bitmap" of the display or printer device is effectively the display surface or the printed page itself. Therefore, you can't select a bitmap into a display device context or a printer device context. You have to create a special memory device context for your bitmaps, using the _CDC::CreateCompatibleDC_ function. You must then use the _CDC_ member function _StretchBlt_ or _BitBlt_ to copy the bits from the memory device context to the "real" device context. These "bit-blitting" functions are generally called in your view class's _OnDraw_ function. Of course, you mustn't forget to clean up the memory device context when you're finished.

Loading a GDI Bitmap from a Resource
------------------------------------

The easiest way to use a bitmap is to load it from a resource. If you look in ResourceView in the Workspace window, you'll find a list of the project's bitmap resources. If you select a bitmap and examine its properties, you'll see a filename.

Here's an example entry in an RC (resource script) file, when viewed by a text editor:

IDB_REDBLOCKS             BITMAP  DISCARDABLE     "res\\Red Blocks.bmp"

_IDB_REDBLOCKS_ is the resource ID, and the file is Red Blocks.bmp in the project's \res subdirectory. (This is one of the Microsoft Windows 95 wallpaper bitmaps, normally located in the \WINDOWS directory.) The resource compiler reads the DIB from disk and stores it in the project's RES file. The linker copies the DIB into the program's EXE file. You know that the Red Blocks bitmap must be in device-independent format because the EXE can be run with any display board that Windows supports.

The _CDC::LoadBitmap_ function converts a resource-based DIB to a GDI bitmap. Below is the simplest possible self-contained _OnDraw_ function that displays the Red Blocks bitmap:

CMyView::OnDraw(CDC\* pDC)
{
    CBitmap bitmap; // Sequence is important
    CDC dcMemory;
    bitmap.LoadBitmap(IDB_REDBLOCKS);
    dcMemory.CreateCompatibleDC(pDC);
    dcMemory.SelectObject(&bitmap);
    pDC->BitBlt(100, 100, 54, 96, &dcMemory, 0, 0, SRCCOPY);
    // CDC destructor deletes dcMemory; bitmap is deselected
    // CBitmap destructor deletes bitmap
}

The _BitBlt_ function copies the Red Blocks pixels from the memory device context to the display (or printer) device context. The bitmap is 54 bits wide by 96 bits high, and on a VGA display it occupies a rectangle of 54-by-96 logical units, offset 100 units down and to the right of the upper-left corner of the window's client area.

> NOTE
> 
> The code above works fine for the display. As you'll see in [Chapter 19](ch19a.htm), the application framework calls the _OnDraw_ function for printing, in which case _pDC_ points to a printer device context. The bitmap here, unfortunately, is configured specifically for the display and thus cannot be selected into the printer-compatible memory device context. If you want to print a bitmap, you should look at the _CDib_ class described later in this chapter.

The Effect of the Display Mapping Mode
--------------------------------------

If the display mapping mode in the Red Blocks example is _MM_TEXT_, each bitmap pixel maps to a display pixel and the bitmap fits perfectly. If the mapping mode is _MM_LOENGLISH_, the bitmap size is 0.54-by-0.96 inch, or 52-by-92 pixels for Windows 95, and the GDI must do some bit crunching to make the bitmap fit. Consequently, the bitmap might not look as good with the _MM_LOENGLISH_ mapping mode. Calling _CDC::SetStretchBltMode_ with a parameter value of _COLORONCOLOR_ will make shrunken bitmaps look nicer.

Stretching the Bits
-------------------

What if we want Red Blocks to occupy a rectangle of exactly 54-by-96 pixels, even though the mapping mode is not _MM_TEXT_? The _StretchBlt_ function is the solution. If we replace the _BitBlt_ call with the following three statements, Red Blocks is displayed cleanly, whatever the mapping mode:

CSize size(54, 96);
pDC->DPtoLP(&size);
pDC->StretchBlt(0, 0, size.cx, -size.cy,
                &dcMemory, 0, 0, 54, 96, SRCCOPY);

With either _BitBlt_ or _StretchBlt_, the display update is slow if the GDI has to actually stretch or compress bits. If, as in the case above, the GDI determines that no conversion is necessary, the update is fast.

The EX11A Example
-----------------

The EX11A example displays a resource-based bitmap in a scrolling view with mapping mode set to _MM_LOENGLISH_. The program uses the _StretchBlt_ logic described above, except that the memory device context and the bitmap are created in the view's _OnInitialUpdate_ member function and last for the life of the program. Also, the program reads the bitmap size through a call to the _CGdiObject_ member function _GetObject_, so it's not using hard-coded values as in the preceding examples.

Here are the steps for building the example:

2.  **Run AppWizard to produce \vcpp32\ex11a\ex11a.** Accept all the default settings but two: select Single Document, and select the _CScrollView_ view base class, as shown in [Chapter 4](ch04a.htm), for _CEx11aView._ The options and the default class names are shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G11OG01x.gif)
    
3.  **Import the Gold Weave bitmap.** Choose Resource from Visual C++'s Insert menu. Import the bitmap Gold Weave.bmp from the \WINDOWS directory. (If your version of Windows doesn't have this bitmap, load it from this book's companion CD-ROM.) Visual C++ will copy this bitmap file into your project's \res subdirectory. Assign the ID _IDB_GOLDWEAVE_, and save the changes.
    
4.  **Add the following private data members to the class _CEx11aView._** Edit the file ex11aView.h or use ClassView. The bitmap and the memory device context last for the life of the view. The _CSize_ objects are the source (bitmap) dimensions and the destination (display) dimensions.
    
    **CDC\*     m_pdcMemory;
    CBitmap\* m_pBitmap;
    CSize    m_sizeSource, m_sizeDest;**
    
5.  **Edit the following member functions in the class _CEx11aView._** Edit the file ex11aView.cpp. The constructor and destructor do C++ housekeeping for the embedded objects. You want to keep the constructor as simple as possible because failing constructors cause problems. The _OnInitialUpdate_ function sets up the memory device context and the bitmap, and it computes output dimensions that map each bit to a pixel. The _OnDraw_ function calls _StretchBlt_ twice—once by using the special computed dimensions and once by mapping each bit to a 0.01-by-0.01-inch square. Add the following boldface code:
    
    CEx11aView::CEx11aView()
    {
        **m_pdcMemory = new CDC;
        m_pBitmap = new CBitmap;**
    }
    
    CEx11aView::~CEx11aView()
    {
        **// cleans up the memory device context and the bitmap
        delete m_pdcMemory; // deselects bitmap
        delete m_pBitmap;**
    }
    void CEx11aView::OnDraw(CDC\* pDC)
    {
        **pDC->SetStretchBltMode(COLORONCOLOR);
        pDC->StretchBlt(20, -20, m_sizeDest.cx, -m_sizeDest.cy,
            m_pdcMemory, 0, 0,
            m_sizeSource.cx, m_sizeSource.cy, SRCCOPY);
    
        pDC->StretchBlt(350, -20, m_sizeSource.cx, -m_sizeSource.cy,
            m_pdcMemory, 0, 0,
            m_sizeSource.cx, m_sizeSource.cy, SRCCOPY);**
    }
    
    void CEx11aView::OnInitialUpdate()
    {
        CScrollView::OnInitialUpdate();
        **CSize sizeTotal(800, 1050); // 8-by-10.5 inches
        CSize sizeLine = CSize(sizeTotal.cx / 100, sizeTotal.cy / 100);
        SetScrollSizes(MM_LOENGLISH, sizeTotal, sizeTotal, sizeLine);
    
        BITMAP bm; // Windows BITMAP data structure; see Win32 help
        if (m_pdcMemory->GetSafeHdc() == NULL) {
            CClientDC dc(this);
            OnPrepareDC(&dc); // necessary
            m_pBitmap->LoadBitmap(IDB_GOLDWEAVE);
            m_pdcMemory->CreateCompatibleDC(&dc);
            m_pdcMemory->SelectObject(m_pBitmap);
            m_pBitmap->GetObject(sizeof(bm), &bm);
            m_sizeSource.cx = bm.bmWidth;
            m_sizeSource.cy = bm.bmHeight;
            m_sizeDest = m_sizeSource;
            dc.DPtoLP(&m_sizeDest);
        }**
    }
    
6.  **Build and test the EX11A application.** Your screen should look like this.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g11og02x.gif)]
    
7.  **Try the Print Preview and Print features.** The bitmap prints to scale because the application framework applies the _MM_LOENGLISH_ mapping mode to the printer device context just as it does to the display device context. The output looks great in Print Preview mode, but (depending on your print drivers) the printed output will probably be either blank or microscopic! We'll fix that soon.
________________________________________________________________________
5.9.3. - [Using Bitmaps to Improve the Screen Display](invcpp5/ch11d.htm)
----------------------------------------------------
 Using Bitmaps to Improve the Screen Display 

Using Bitmaps to Improve the Screen Display
===========================================

You've seen an example program that displays a bitmap that originated outside the program. Now you'll see an example program that generates its own bitmap to support smooth motion on the screen. The principle is simple: you draw on a memory device context with a bitmap selected, and then you zap the bitmap onto the screen.

The EX11B Example
-----------------

In the EX05C example in [Chapter 5](ch05a.htm), the user dragged a circle with the mouse. As the circle moved, the display flickered because the circle was erased and redrawn on every mouse-move message. EX11B uses a GDI bitmap to correct this problem. The EX05C custom code for mouse message processing carries over almost intact; most of the new code is in the _OnPaint_ and _OnInitialUpdate_ functions.

In summary, the EX11B _OnInitialUpdate_ function creates a memory device context and a bitmap that are compatible with the display. The _OnPaint_ function prepares the memory device context for drawing, passes _OnDraw_ a handle to the memory device context, and copies the resulting bitmap from the memory device context to the display.

Here are the steps to build EX11B from scratch:

2.  **Run AppWizard to produce \vcpp32\ex11b\ex11b.** Accept all the default settings but two: select Single Document and select _CScrollView_ view as the base class for _CEx11bView_. The options and the default class names are shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/g11og03x.gif)
    
3.  **Use ClassWizard to add _CEx11bView_ message handlers.** Add message handlers for the following messages:
    
    *   WM_LBUTTONDOWN
        
    *   WM_LBUTTONUP
        
    *   WM_MOUSEMOVE
        
    *   WM_PAINT
    
4.  **Edit the ex11bView.h header file.** Add the private data members shown here to the _CEx11bView_ class:
    
    **private:
        const CSize m_sizeEllipse;
        CPoint   m_pointTopLeft;
        BOOL     m_bCaptured;
        CSize    m_sizeOffset;
        CDC\*     m_pdcMemory;
        CBitmap\* m_pBitmap;**
    
5.  **Code the _CEx11bView_ constructor and destructor in ex11bView.cpp.** You need a memory device context object and a bitmap GDI object. These are constructed in the view's constructor and destroyed in the view's destructor. Add the following boldface code:
    
    CEx11bView::CEx11bView() : **m_sizeEllipse(100, -100),
                               m_pointTopLeft(10, -10),
                               m_sizeOffset(0, 0)**
    {
        **m_bCaptured = FALSE;
        m_pdcMemory = new CDC;
        m_pBitmap   = new CBitmap;**
    }
    
    CEx11bView::~CEx11bView()
    {
        **delete m_pBitmap; // already deselected
        delete m_pdcMemory;**
    }
    
6.  **Add code for the _OnInitialUpdate_ function in ex11bView.cpp.** The C++ memory device context and bitmap objects are already constructed. This function creates the corresponding Windows objects. Both the device context and the bitmap are compatible with the display context _dc_, but you must explicitly set the memory device context's mapping mode to match the display context. You could create the bitmap in the _OnPaint_ function, but the program runs faster if you create it once here. Add the boldface code shown here:
    
    void CEx11bView::OnInitialUpdate()
    {
        CScrollView::OnInitialUpdate();
        **CSize sizeTotal(800, 1050); // 8-by-10.5 inches
        CSize sizePage(sizeTotal.cx / 2, sizeTotal.cy / 2);
        CSize sizeLine(sizeTotal.cx / 50, sizeTotal.cy / 50);
        SetScrollSizes(MM_LOENGLISH, sizeTotal, sizePage, sizeLine);
        // creates the memory device context and the bitmap
        if (m_pdcMemory->GetSafeHdc() == NULL) {
            CClientDC dc(this);
            OnPrepareDC(&dc);
            CRect rectMax(0, 0, sizeTotal.cx, -sizeTotal.cy);
            dc.LPtoDP(rectMax);
            m_pdcMemory->CreateCompatibleDC(&dc);
            // makes bitmap same size as display window
            m_pBitmap->CreateCompatibleBitmap(&dc, rectMax.right,
                                              rectMax.bottom);
            m_pdcMemory->SetMapMode(MM_LOENGLISH);
        }**
    }
    
7.  **Add code for the _OnPaint_ function in ex11bView.cpp.** Normally it isn't necessary to map the WM_PAINT message in your derived view class. The _CView_ version of _OnPaint_ contains the following code:
    
    CPaintDC dc(this);
    OnPrepareDC(&dc);
    OnDraw(&dc);
    
    In this example, you will be using the _OnPaint_ function to reduce screen flicker through the use of a memory device context. _OnDraw_ is passed this memory device context for the display, and it is passed the printer device context for printing. Thus, _OnDraw_ can perform tasks common to the display and to the printer. You don't need to use the bitmap with the printer because the printer has no speed constraint.
    
    The _OnPaint_ function must perform, in order, the following three steps to prepare the memory device context for drawing:
    
    *   Select the bitmap into the memory device context.
        
    *   Transfer the invalid rectangle (as calculated by _OnMouseMove_) from the display context to the memory device context. There is no _SetClipRect_ function, but the _CDC::IntersectClipRect_ function, when called after the _CDC::SelectClipRgn_ function (with a _NULL_ parameter), has the same effect. If you don't set the clipping rectangle to the minimum size, the program runs more slowly.
        
    *   Initialize the bitmap to the current window background color. The _CDC::PatBlt_ function fills the specified rectangle with a pattern. In this case, the pattern is the brush pattern for the current window background. That brush must first be constructed and selected into the memory device context.
    
    After the memory device context is prepared, _OnPaint_ can call _OnDraw_ with a memory device context parameter. Then the _CDC::BitBlt_ function copies the updated rectangle from the memory device context to the display device context. Add the following boldface code:
    
    void CEx11bView::OnPaint()
    {
        CPaintDC dc(this); // device context for painting
        **OnPrepareDC(&dc);
        CRect rectUpdate;
        dc.GetClipBox(&rectUpdate);
        CBitmap\* pOldBitmap = m_pdcMemory->SelectObject(m_pBitmap);
        m_pdcMemory->SelectClipRgn(NULL);
        m_pdcMemory->IntersectClipRect(&rectUpdate);
        CBrush backgroundBrush((COLORREF) ::GetSysColor(COLOR_WINDOW));
        CBrush\* pOldBrush = m_pdcMemory->SelectObject(&backgroundBrush);
        m_pdcMemory->PatBlt(rectUpdate.left, rectUpdate.top,
                            rectUpdate.Width(), rectUpdate.Height(),
                            PATCOPY); 
        OnDraw(m_pdcMemory);
        dc.BitBlt(rectUpdate.left, rectUpdate.top,
                  rectUpdate.Width(), rectUpdate.Height(),
                  m_pdcMemory, rectUpdate.left, rectUpdate.top,
                  SRCCOPY);
        m_pdcMemory->SelectObject(pOldBitmap);
        m_pdcMemory->SelectObject(pOldBrush);**
    }
    
8.  **Code the _OnDraw_ function in ex11bView.cpp.** Copy the code from ex05cView.cpp. In EX11B, _OnDraw_ is passed a pointer to a memory device context by the _OnPaint_ function. For printing, _OnDraw_ is passed a pointer to the printer device context.
    
9.  **Copy the mouse message-handling code from ex05cView.cpp.** Copy the functions shown below from ex05cView.cpp to ex11bView.cpp. Be sure to change the functions' class names from _CEx05cView_ to _CEx11bView._
    
    *   _OnLButtonDown_
        
    *   _OnLButtonUp_
        
    *   _OnMouseMove_
    
10.  **Change two lines in the _OnMouseMove_ function in ex11bView.cpp.** Change the following two lines:
    
    InvalidateRect(rectOld, TRUE);
    InvalidateRect(rectNew, TRUE);
    
    to
    
    InvalidateRect(rectOld, **FALSE**);
    InvalidateRect(rectNew, **FALSE**);
    
    If the second _CWnd::InvalidateRect_ parameter is _TRUE_ (the default), Windows erases the background before repainting the invalid rectangle. That's what you needed in EX05C, but the background erasure is what causes the flicker. Because the entire invalid rectangle is being copied from the bitmap, you no longer need to erase the background. The _FALSE_ parameter prevents this erasure.
    
11.  **Build and run the application.** Here is the EX11B program output.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G11OG04x.gif)]
    
    Is the circle's movement smoother now? The problem is that the bitmap is only 8-by-10.5 inches, and if the scrolling window is big enough, the circle goes off the edge. One solution to this problem is to make the bitmap as big as the largest display.
    

Windows Animation
-----------------

EX11B is a crude attempt at Windows animation. What if you wanted to move an angelfish instead of a circle? Win32 doesn't have an _Angelfish_ function (yet), so you'd have to keep your angelfish in its own bitmap and use the _StretchBlt_ mask ROP codes to merge the angelfish with the background. You'd probably keep the background in its own bitmap, too. These techniques are outside the scope of this book. If you are interested in learning more about Windows Animation, run out and get Nigel Thompson's _Animation Techniques in Win32_ (Microsoft Press, 1995). After you read it, you can get rich writing video games for Windows!
________________________________________________________________________
5.9.4. - [DIBs and the CDib Class](invcpp5/ch11e.htm)
----------------------------------------------------
 DIBs and the CDib Class 

DIBs and the _CDib_ Class
=========================

There's an MFC class for GDI bitmaps (_CBitmap_), but there's no MFC class for DIBs. Don't worry—I'm giving you one here. It's a complete rewrite of the _CDib_ class from the early editions of this book (prior to the fourth edition), and it takes advantage of Win32 features such as memory-mapped files, improved memory management, and DIB sections. It also includes palette support. Before you examine the _CDib_ class, however, you need a little background on DIBs.

A Few Words About Palette Programming
-------------------------------------

Windows palette programming is quite complex, but you've got to deal with it if you expect your users to run their displays in the 8-bpp (bits per pixel) mode—and many users will if they have video cards with 1 MB or less of memory.

Suppose you're displaying a single DIB in a window. First you must create a logical palette, a GDI object that contains the colors in the DIB. Then you must "realize" this logical palette into the hardware system palette, a table of the 256 colors the video card can display at that instant. If your program is the foreground program, the realization process tries to copy all your colors into the system palette, but it doesn't touch the 20 standard Windows colors. For the most part, your DIB looks just like you want it to look.

But what if another program is the foreground program, and what if that program has a forest scene DIB with 236 shades of green? Your program still realizes its palette, but something different happens this time. Now the system palette won't change, but Windows sets up a new mapping between your logical palette and the system palette. If your DIB contains a neon pink color, for example, Windows maps it to the standard red color. If your program forgot to realize its palette, your neon pink stuff would turn green when the other program went active.

The forest scene example is extreme because we assumed that the other program grabbed 236 colors. If instead the other program realized a logical palette with only 200 colors, Windows would let your program load 36 of its own colors, including, one hopes, neon pink.

So when is a program supposed to realize its palette? The Windows message WM_PALETTECHANGED is sent to your program's main window whenever a program, including yours, realizes its palette. Another message, WM_QUERYNEWPALETTE, is sent whenever one of the windows in your program gets the input focus. Your program should realize its palette in response to both these messages (unless your program generated the message). These palette messages are not sent to your view window, however. You must map them in your application's main frame window and then notify the view. [Chapter 13](ch13a.htm) discusses the relationship between the frame window and the view, and [Chapter 26](ch26a.htm) contains a complete palette-aware MDI application (EX26A).

You call the Win32 _RealizePalette_ function to perform the realization, but first you must call _SelectPalette_ to select your DIB's logical palette into the device context. _SelectPalette_ has a flag parameter that you normally set to _FALSE_ in your WM_PALETTECHANGED and WM_QUERYNEWPALETTE handlers. This flag ensures that your palette is realized as a foreground palette if your application is indeed running in the foreground. If you use a _TRUE_ flag parameter here, you can force Windows to realize the palette as though the application were in the background.

You must also call _SelectPalette_ for each DIB that you display in your _OnDraw_ function. This time you call it with a _TRUE_ flag parameter. Things do get complicated if you're displaying several DIBs, each with its own palette. Basically, you've got to choose a palette for one of the DIBs and realize it (by selecting it with the _FALSE_ parameter) in the palette message handlers. The chosen DIB will end up looking better than the other DIBs. There are ways of merging palettes, but it might be easier to go out and buy more video memory.

DIBs, Pixels, and Color Tables
------------------------------

A DIB contains a two-dimensional array of elements called pixels. In many cases, each DIB pixel will be mapped to a display pixel, but the DIB pixel might be mapped to some logical area on the display, depending on the mapping mode and the display function stretch parameters.

A pixel consists of 1, 4, 8, 16, 24, or 32 contiguous bits, depending on the color resolution of the DIB. For 16-bpp, 24-bpp, and 32-bpp DIBs, each pixel represents an RGB color. A pixel in a 16-bpp DIB typically contains 5 bits each for red, green, and blue values; a pixel in a 24-bpp DIB has 8 bits for each color value. The 16-bpp and 24-bpp DIBs are optimized for video cards that can display 65,536 or 16.7 million simultaneous colors.

A 1-bpp DIB is a monochrome DIB, but these DIBs don't have to be black and white—they can contain any two colors chosen from the color table that is built into each DIB. A monochrome bitmap has two 32-bit color table entries, each containing 8 bits for red, green, and blue values plus another 8 bits for flags. Zero (0) pixels use the first entry, and one (1) pixel uses the second. Whether you have a 65,536-color video card or a 16.7-million-color card, Windows can display the two colors directly. (Windows truncates 8-bits-per-color values to 5 bits for 65,536-color displays.) If your video card is running in 256-color palettized mode, your program can adjust the system palette to load the two specified colors.

Eight-bpp DIBs are quite common. Like a monochrome DIB, an 8-bpp DIB has a color table, but the color table has 256 (or fewer) 32-bit entries. Each pixel is an index into this color table. If you have a palettized video card, your program can create a logical palette from the 256 entries. If another program (running in the foreground) has control of the system palette, Windows does its best to match your logical palette colors to the system palette.

What if you're trying to display a 24-bpp DIB with a 256-color palettized video card? If the DIB author was nice, he or she included a color table containing the most important colors in the DIB. Your program can build a logical palette from that table, and the DIB will look fine. If the DIB has no color table, use the palette returned by the Win32 _CreateHalftonePalette_ function; it's better than the 20 standard colors you'd get with no palette at all. Another option is to analyze the DIB to identify the most important colors, but you can buy a utility to do that.

The Structure of a DIB Within a BMP File
----------------------------------------

You know that the DIB is the standard Windows bitmap format and that a BMP file contains a DIB. So let's look inside a BMP file to see what's there. Figure 11-1 shows a layout for a BMP file.

![](c:/dl/books/windows/msvc5th/invcpp5/images/F11OG01.JPG)

**Figure 11-1.** _The layout for a BMP file._

The _BITMAPFILEHEADER_ structure contains the offset to the image bits, which you can use to compute the combined size of the _BITMAPINFOHEADER_ structure and the color table that follows. The _BITMAPFILEHEADER_ structure contains a file size member, but you can't depend on it because you don't know whether the size is measured in bytes, words, or double words.

The _BITMAPINFOHEADER_ structure contains the bitmap dimensions, the bits per pixel, compression information for both 4-bpp and 8-bpp bitmaps, and the number of color table entries. If the DIB is compressed, this header contains the size of the pixel array; otherwise, you can compute the size from the dimensions and the bits per pixel. Immediately following the header is the color table (if the DIB has a color table). The DIB image comes after that. The DIB image consists of pixels arranged by column within rows, starting with the bottom row. Each row is padded to a 4-byte boundary.

The only place you'll find a _BITMAPFILEHEADER_ structure, however, is in a BMP file. If you get a DIB from the clipboard, for example, there will not be a file header. You can always count on the color table to follow the _BITMAPINFOHEADER_ structure, but you can't count on the image to follow the color table. If you're using the _CreateDIBSection_ function, for example, you must allocate the bitmap info header and color table and then let Windows allocate the image somewhere else.

> NOTE
> 
> This chapter and all the associated code are specific to Windows DIBs. There's also a well-documented variation of the DIB format for OS/2. If you need to process these OS/2 DIBs, you'll have to modify the _CDib_ class.

DIB Access Functions
--------------------

Windows supplies some important DIB access functions. None of these functions is wrapped by MFC, so you'll need to refer to the online Win32 documentation for details. Here's a summary:

*   **_SetDIBitsToDevice_**—This function displays a DIB directly on the display or printer. No scaling occurs; one bitmap bit corresponds to one display pixel or one printer dot. This scaling restriction limits the function's usefulness. The function doesn't work like _BitBlt_ because _BitBlt_ uses logical coordinates.
    
*   **_StretchDIBits_**—This function displays a DIB directly on the display or printer in a manner similar to that of _StretchBlt_.
    
*   **_GetDIBits_**—This function constructs a DIB from a GDI bitmap, using memory that you allocate. You have some control over the format of the DIB because you can specify the number of color bits per pixel and the compression. If you are using compression, you have to call _GetDIBits_ twice—once to calculate the memory needed and again to generate the DIB data.
    
*   **_CreateDIBitmap_**—This function creates a GDI bitmap from a DIB. As for all these DIB functions, you must supply a device context pointer as a parameter. A display device context will do; you don't need a memory device context.
    
*   **_CreateDIBSection_**—This Win32 function creates a special kind of DIB known as a DIB section. It then returns a GDI bitmap handle. This function gives you the best features of DIBs and GDI bitmaps. You have direct access to the DIB's memory, and with the bitmap handle and a memory device context, you can call GDI functions to draw into the DIB.

The _CDib_ Class
----------------

If DIBs look intimidating, don't worry. The _CDib_ class makes DIB programming easy. The best way to get to know the _CDib_ class is to look at the public member functions and data members. Figure 11-2 shows the _CDib_ header file. Consult the ex11c folder on the companion CD-ROM to see the implementation code.

**CDIB.H**

#ifndef _INSIDE_VISUAL_CPP_CDIB
#define _INSIDE_VISUAL_CPP_CDIB

class CDib : public CObject
{
    enum Alloc {noAlloc, crtAlloc,
                heapAlloc}; // applies to BITMAPINFOHEADER
    DECLARE_SERIAL(CDib)
public:
    LPVOID  m_lpvColorTable;
    HBITMAP m_hBitmap;
    LPBYTE  m_lpImage;  // starting address of DIB bits
    LPBITMAPINFOHEADER m_lpBMIH; // buffer containing the
                                 //  BITMAPINFOHEADER
private:
    HGLOBAL m_hGlobal; // for external windows we need to free;
                       //  could be allocated by this class or
                       //  allocated externally
    Alloc m_nBmihAlloc;
    Alloc m_nImageAlloc;
    DWORD m_dwSizeImage; // of bits—not BITMAPINFOHEADER
                         // or BITMAPFILEHEADER
    int m_nColorTableEntries;

    HANDLE m_hFile;
    HANDLE m_hMap;
    LPVOID m_lpvFile;
    HPALETTE m_hPalette;
public:
    CDib();
    CDib(CSize size, int nBitCount);  // builds BITMAPINFOHEADER
    ~CDib();
    int GetSizeImage() {return m_dwSizeImage;}
    int GetSizeHeader()
        {return sizeof(BITMAPINFOHEADER) +
                sizeof(RGBQUAD) \* m_nColorTableEntries;}
    CSize GetDimensions();
    BOOL AttachMapFile(const char\* strPathname, BOOL bShare = FALSE);
    BOOL CopyToMapFile(const char\* strPathname);
    BOOL AttachMemory(LPVOID lpvMem, BOOL bMustDelete = FALSE,
        HGLOBAL hGlobal = NULL);
    BOOL Draw(CDC\* pDC, CPoint origin,
        CSize size); // until we implement CreateDibSection
    HBITMAP CreateSection(CDC\* pDC = NULL);
    UINT UsePalette(CDC\* pDC, BOOL bBackground = FALSE);
    BOOL MakePalette();
    BOOL SetSystemPalette(CDC\* pDC);
    BOOL Compress(CDC\* pDC,
        BOOL bCompress = TRUE); // FALSE means decompress
    HBITMAP CreateBitmap(CDC\* pDC);
    BOOL Read(CFile\* pFile);
    BOOL ReadSection(CFile\* pFile, CDC\* pDC = NULL);
    BOOL Write(CFile\* pFile);
    void Serialize(CArchive& ar);
    void Empty();
private:
    void DetachMapFile();
    void ComputePaletteSize(int nBitCount);
    void ComputeMetrics();
};
#endif // _INSIDE_VISUAL_CPP_CDIB

**Figure 11-2.** _The_ CDib _class declaration._

Here's a rundown of the _CDib_ member functions, starting with the constructors and the destructor:

*   **Default constructor**—You'll use the default constructor in preparation for loading a DIB from a file or for attaching to a DIB in memory. The default constructor creates an empty DIB object.
    
*   **DIB section constructor**—If you need a DIB section that is created by the _CreateDIBSection_ function, use this constructor. Its parameters determine DIB size and number of colors. The constructor allocates info header memory but not image memory. You can also use this constructor if you need to allocate your own image memory.

**Parameter**

**Description**

_size_

_CSize_ object that contains the width and height of the DIB

_nBitCount_

Bits per pixel; should be 1, 4, 8, 16, 24, or 32

*   **Destructor**—The _CDib_ destructor frees all allocated DIB memory.
    
*   **_AttachMapFile_**—This function opens a memory-mapped file in read mode and attaches it to the _CDib_ object. The return is immediate because the file isn't actually read into memory until it is used. When you access the DIB, however, a delay might occur as the file is paged in. The _AttachMapFile_ function releases existing allocated memory and closes any previously attached memory-mapped file.
    

**Parameter**

**Description**

_strPathname_

Pathname of the file to be mapped

_bShare_

Flag that is _TRUE_ if the file is to be opened in share mode; the default value is _FALSE_

Return value

_TRUE_ if successful

*   **_AttachMemory_**—This function associates an existing _CDib_ object with a DIB in memory. This memory could be in the program's resources, or it could be clipboard or OLE data object memory. Memory might have been allocated from the CRT heap with the _new_ operator, or it might have been allocated from the Windows heap with _GlobalAlloc_.

**Parameter**

**Description**

_lpvMem_

Address of the memory to be attached

_bMustDelete_

Flag that is _TRUE_ if the _CDib_ class is responsible for deleting this memory; the default value is _FALSE_

_hGlobal_

If memory was obtained with a call to the Win32 _GlobalAlloc_ function, the _CDib_ object needs to keep the handle in order to free it later, assuming that _bMustDelete_ was set to _TRUE_

Return value

_TRUE_ if successful

*   **_Compress_**—This function regenerates the DIB as a compressed or an uncompressed DIB. Internally, it converts the existing DIB to a GDI bitmap and then makes a new compressed or an uncompressed DIB. Compression is supported only for 4-bpp and 8-bpp DIBs. You can't compress a DIB section.

**Parameter**

**Description**

_pDC_

Pointer to the display device context

_bCompress_

_TRUE_ (default) to compress the DIB; _FALSE_ to uncompress it

Return value

_TRUE_ if successful

*   **_CopyToMapFile_**—This function creates a new memory-mapped file and copies the existing _CDib_ data to the file's memory, releasing any previously allocated memory and closing any existing memory-mapped file. The data isn't actually written to disk until the new file is closed, but that happens when the _CDib_ object is reused or destroyed.

**Parameter**

**Description**

_strPathname_

Pathname of the file to be mapped

Return value

_TRUE_ if successful

*   **_CreateBitmap_**—This function creates a GDI bitmap from an existing DIB and is called by the _Compress_ function. Don't confuse this function with _CreateSection_, which generates a DIB and stores the handle.

**Parameter**

**Description**

_pDC_

Pointer to the display or printer device context

Return value

Handle to a GDI bitmap—_NULL_ if unsuccessful. This handle is not stored as a public

data member.

*   **_CreateSection_**—This function creates a DIB section by calling the Win32 _CreateDIBSection_ function. The image memory will be uninitialized.

**Parameter**

**Description**

_pDC_

Pointer to the display or printer device context

Return value

Handle to a GDI bitmap—_NULL_ if unsuccessful. This handle is also stored as a public data member.

*   **_Draw_**—This function outputs the _CDib_ object to the display (or to the printer) with a call to the Win32 _StretchDIBits_ function. The bitmap will be stretched as necessary to fit the specified rectangle.

**Parameter**

**Description**

_pDC_

Pointer to the display or printer device context that will receive the DIB image

_origin_

_CPoint_ object that holds the logical coordinates at which the DIB will be displayed

_size_

_CSize_ object that represents the display rectangle's width and height in logical units

Return value

_TRUE_ if successful

*   **_Empty_**—This function empties the DIB, freeing allocated memory and closing the map file if necessary.
*   **_GetDimensions_**—This function returns the width and height of a DIB in pixels.

**Parameter**

**Description**

Return value

_CSize_ object

*   **_GetSizeHeader_**—This function returns the number of bytes in the info header and color table combined.

**Parameter**

**Description**

Return value

32-bit integer

*   **_GetSizeImage_**—This function returns the number of bytes in the DIB image (excluding the info header and the color table).

**Parameter**

**Description**

Return value

32-bit integer

*   **_MakePalette_**—If the color table exists, this function reads it and creates a Windows palette. The _HPALETTE_ handle is stored in a data member.

**Parameter**

**Description**

Return value

_TRUE_ if successful

*   **_Read_**—This function reads a DIB from a file into the _CDib_ object. The file must have been successfully opened. If the file is a BMP file, reading starts from the beginning of the file. If the file is a document, reading starts from the current file pointer.

**Parameter**

**Description**

_pFile_

Pointer to a _CFile_ object; the corresponding disk file contains the DIB

Return value

_TRUE_ if successful

*   **_ReadSection_**—This function reads the info header from a BMP file, calls _CreateDIBSection_ to allocate image memory, and then reads the image bits from the file into that memory. Use this function if you want to read a DIB from disk and then edit it by calling GDI functions. You can write the DIB back to disk with _Write_ or _CopyToMapFile_.

**Parameter**

**Description**

_pFile_

Pointer to a _CFile_ object; the corresponding disk file contains the DIB

_pDC_

Pointer to the display or printer device context

Return value

_TRUE_ if successful

*   **_Serialize_**—Serialization is covered in [Chapter 17](ch17a.htm). The _CDib::Serialize_ function, which overrides the MFC _CObject::Serialize_ function, calls the _Read_ and _Write_ member functions. See the _Microsoft Foundation Classes and Templates_ section of the online help for a description of the parameters.
*   **_SetSystemPalette_**—If you have a 16-bpp, 24-bpp, or 32-bpp DIB that doesn't have a color table, you can call this function to create for your _CDib_ object a logical palette that matches the palette returned by the _CreateHalftonePalette_ function. If your program is running on a 256-color palettized display and you don't call _SetSystemPalette_, you'll have no palette at all, and only the 20 standard Windows colors will appear in your DIB.

**Parameter**

**Description**

_pDC_

Pointer to the display context

Return value

_TRUE_ if successful

*   **_UsePalette_**—This function selects the _CDib_ object's logical palette into the device context and then realizes the palette. The _Draw_ member function calls _UsePalette_ prior to painting the DIB.

**Parameter**

**Description**

_pDC_

Pointer to the display device context for realization

_bBackground_

If this flag is _FALSE_ (the default value) and the application is running in the foreground, Windows realizes the palette as the foreground palette (copies as many colors as possible into the system palette). If this flag is _TRUE_, Windows realizes the palette as a background palette (maps the logical palette to the system palette as best it can).

Return value

Number of entries in the logical palette mapped to the

system palette. If the function fails, the return value is _GDI_ERROR_.

*   **_Write_**—This function writes a DIB from the _CDib_ object to a file. The file must have been successfully opened or created.

**Parameter**

**Description**

_pFile_

Pointer to a _CFile_ object; the DIB will be

written to the corresponding disk file.

Return value

_TRUE_ if successful

For your convenience, four public data members give you access to the DIB memory and to the DIB section handle. These members should give you a clue about the structure of a _CDib_ object. A _CDib_ is just a bunch of pointers to heap memory. That memory might be owned by the DIB or by someone else. Additional private data members determine whether the _CDib_ class frees the memory.

DIB Display Performance
-----------------------

Optimized DIB processing is now a major feature of Windows. Modern video cards have frame buffers that conform to the standard DIB image format. If you have one of these cards, your programs can take advantage of the new Windows DIB engine, which speeds up the process of drawing directly from DIBs. If you're still running in VGA mode, however, you're out of luck; your programs will still work, but not as fast.

If you're running Windows in 256-color mode, your 8-bpp bitmaps will be drawn very quickly, either with _StretchBlt_ or with _StretchDIBits_. If, however, you are displaying 16-bpp or 24-bpp bitmaps, those drawing functions will be too slow. Your bitmaps will appear more quickly in this situation if you create a separate 8-bbp GDI bitmap and then call _StretchBlt_. Of course, you must be careful to realize the correct palette prior to creating the bitmap and prior to drawing it.

Here's some code that you might insert just after loading your _CDib_ object from a BMP file:

// m_hBitmap is a data member of type HBITMAP
// m_dcMem is a memory device context object of class CDC
m_pDib->UsePalette(&dc);
m_hBitmap = m_pDib->CreateBitmap(&dc); // could be slow
::SelectObject(m_dcMem.GetSafeHdc(), m_hBitmap);

Here is the code that you use in place of _CDib::Draw_ in your view's _OnDraw_ member function:

m_pDib->UsePalette(pDC); // could be in palette msg handler

CSize sizeDib = m_pDib->GetDimensions();

pDC->StretchBlt(0, 0, sizeDib.cx, sizeDib.cy, &m_dcMem,
                0, 0, sizeToDraw.cx, sizeToDraw.cy, SRCCOPY);

Don't forget to call _DeleteObject_ for _m_hBitmap_ when you're done with it.

The EX11C Example
-----------------

Now you'll put the _CDib_ class to work in an application. The EX11C program displays two DIBs, one from a resource and the other loaded from a BMP file that you select at runtime. The program manages the system palette and displays the DIBs correctly on the printer. Compare the EX11C code with the GDI bitmap code in EX11A. Notice that you're not dealing with a memory device context and all the GDI selection rules!

Following are the steps to build EX11C. It's a good idea to type in the view class code, but you'll want to use the cdib.h and cdib.cpp files from the companion CD-ROM.

2.  **Run AppWizard to produce \vcpp32\ex11c\ex11c.** Accept all the defaults but two: select Single Document and select the _CScrollView_ view base class for _CEx11cView_. The options and the default class names are shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G11OG05x.gif)
    

3.  **Import the Red Blocks bitmap.** Choose Resource from Visual C++'s Insert menu. Import Red Blocks.bmp from the \WINDOWS directory. (If your version of Windows doesn't include this bitmap, load it from the companion CD-ROM.) Visual C++ will copy this bitmap file into your project's \res subdirectory. Assign _IDB_REDBLOCKS_ as the ID, and save the changes.
    
4.  **Integrate the _CDib_ class with this project.** If you've created this project from scratch, copy the cdib.h and cdib.cpp files from \vcpp32\ex11c on the companion CD-ROM. Simply copying the files to disk isn't enough; you must also add the _CDib_ files to the project. Choose Add To Project from Visual C++'s Project menu, and then choose Files. Select cdib.h and cdib.cpp, and click the OK button. If you now switch to ClassView in the Workspace window, you will see the class _CDib_ and all of its member variables and functions.
    
5.  **Add two private _CDib_ data members to the class _CEx11cView._** In the ClassView window, right-click the _CEx11cView_ class. Choose Add Member Variable from the resulting pop-up menu, and then add the _m_dibResource_ member as shown in the following illustration.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G11OG06.GIF)
    
    Add _m_dibFile_ in the same way. The result should be two data members at the bottom of the header file:
    
    CDib m_dibFile;
    CDib m_dibResource;
    
    ClassView also adds this statement at the top of the ex11cView.h file:
    
    #include "cdib.h"   // Added by ClassView
    
6.  **Edit the _OnInitialUpdate_ member function in ex11cView.cpp.** This function sets the mapping mode to _MM_HIMETRIC_ and loads the _m_dibResource_ object directly from the _IDB_REDBLOCKS_ resource. Note that we're not calling _LoadBitmap_ to load a GDI bitmap as we did in EX11A. The _CDib::AttachMemory_ function connects the object to the resource in your EXE file. Add the following boldface code:
    
    void CEx11cView::OnInitialUpdate()
    {
        CScrollView::OnInitialUpdate();
        **CSize sizeTotal(30000, 40000); // 30-by-40 cm
        CSize sizeLine = CSize(sizeTotal.cx / 100, sizeTotal.cy / 100);
        SetScrollSizes(MM_HIMETRIC, sizeTotal, sizeTotal, sizeLine);
    
        LPVOID lpvResource = (LPVOID) ::LoadResource(NULL,
            ::FindResource(NULL, MAKEINTRESOURCE(IDB_REDBLOCKS),
            RT_BITMAP));
        m_dibResource.AttachMemory(lpvResource); // no need for
                                                 //  ::LockResource
        CClientDC dc(this);
        TRACE("bits per pixel = %d\n", dc.GetDeviceCaps(BITSPIXEL));**
    }
    
7.  **Edit the _OnDraw_ member function in the file ex11cView.cpp.** This code calls _CDib::Draw_ for each of the DIBs. The _UsePalette_ calls should really be made by message handlers for the WM_QUERYNEWPALETTE and WM_PALETTECHANGED messages. These messages are hard to deal with because they don't go to the view directly, so we'll take a shortcut. Add the following boldface code:
    
    void CEx11cView::OnDraw(CDC\* pDC)
    {
        **BeginWaitCursor();
        m_dibResource.UsePalette(pDC); // should be in palette
        m_dibFile.UsePalette(pDC);     //  message handlers, not here
        pDC->TextOut(0, 0, 
            "Press the left mouse button here to load a file.");
        CSize sizeResourceDib = m_dibResource.GetDimensions();
        sizeResourceDib.cx \*= 30;
        sizeResourceDib.cy \*= -30;
        m_dibResource.Draw(pDC, CPoint(0, -800), sizeResourceDib);
        CSize sizeFileDib = m_dibFile.GetDimensions();
        sizeFileDib.cx \*= 30;
        sizeFileDib.cy \*= -30;
        m_dibFile.Draw(pDC, CPoint(1800, -800), sizeFileDib);
        EndWaitCursor();**
    }
    
8.  **Map the WM_LBUTTONDOWN message in the _CEx11cView_ class.** Edit the file ex11cView.cpp. _OnLButtonDown_ contains code to read a DIB in two different ways. If you leave the MEMORY_MAPPED_FILES definition intact, the _AttachMapFile_ code is activated to read a memory-mapped file. If you comment out the first line, the _Read_ call is activated. The _SetSystemPalette_ call is there for DIBs that don't have a color table. Add the following boldface code:
    
    **#define MEMORY_MAPPED_FILES**
    void CEx11cView::OnLButtonDown(UINT nFlags, CPoint point)
    {
        **CFileDialog dlg(TRUE, "bmp", "\*.bmp");
        if (dlg.DoModal() != IDOK) {
            return;
        }
    #ifdef MEMORY_MAPPED_FILES
        if (m_dibFile.AttachMapFile(dlg.GetPathName(),
                TRUE) == TRUE) { // share
            Invalidate();
        }
     #else
        CFile file;
        file.Open(dlg.GetPathName(), CFile::modeRead);
        if (m_dibFile.Read(&file) == TRUE) {
            Invalidate();
        }
    #endif // MEMORY_MAPPED_FILES
        CClientDC dc(this);
        m_dibFile.SetSystemPalette(&dc);**
    }
    
9.  **Build and run the application.** The bitmaps directory on the companion CD-ROM contains several interesting bitmaps. The Chicago.bmp file is an 8-bpp DIB with 256-color table entries; the forest.bmp and clouds.bmp files are also 8-bpp, but they have smaller color tables. The balloons.bmp is a 24-bpp DIB with no color table. Try some other BMP files if you have them. Note that Red Blocks is a 16-color DIB that uses standard colors, which are always included in the system palette.
________________________________________________________________________
5.9.5. - [Going Further with DIBs](invcpp5/ch11f.htm)
----------------------------------------------------
 Going Further with DIBs 

Going Further with DIBs
=======================

Each new version of Windows offers more DIB programming choices. Both Windows 95 and Microsoft Windows NT 4.0 provide the _LoadImage_ and _DrawDibDraw_ functions, which are useful alternatives to the DIB functions already described. Experiment with these functions to see if they work well in your applications.

The _LoadImage_ Function
------------------------

The _LoadImage_ function can read a bitmap directly from a disk file, returning a DIB section handle. It can even process OS/2 format DIBs. Suppose you wanted to add an _ImageLoad_ member function to _CDib_ that would work like _ReadSection_. This is the code you would add to cdib.cpp:

BOOL CDib::ImageLoad(const char\* lpszPathName, CDC\* pDC)
{
    Empty();
    m_hBitmap = (HBITMAP) ::LoadImage(NULL, lpszPathName, 
        IMAGE_BITMAP, 0, 0, 
        LR_LOADFROMFILE | LR_CREATEDIBSECTION | LR_DEFAULTSIZE);
    DIBSECTION ds;
    VERIFY(::GetObject(m_hBitmap, sizeof(ds), &ds) == sizeof(ds));
    // Allocate memory for BITMAPINFOHEADER
    //  and biggest possible color table
    m_lpBMIH = (LPBITMAPINFOHEADER) new 
        char[sizeof(BITMAPINFOHEADER) + 256 \* sizeof(RGBQUAD)];
    memcpy(m_lpBMIH, &ds.dsBmih, sizeof(BITMAPINFOHEADER));
    TRACE("CDib::LoadImage, biClrUsed = %d, biClrImportant = %d\n",
        m_lpBMIH->biClrUsed, m_lpBMIH->biClrImportant);
    ComputeMetrics(); // sets m_lpvColorTable
    m_nBmihAlloc = crtAlloc;
    m_lpImage = (LPBYTE) ds.dsBm.bmBits;
    m_nImageAlloc = noAlloc;
    // Retrieve the DIB section's color table
    //  and make a palette from it
    CDC memdc;
    memdc.CreateCompatibleDC(pDC);
    ::SelectObject(memdc.GetSafeHdc(), m_hBitmap);
    UINT nColors = ::GetDIBColorTable(memdc.GetSafeHdc(), 0, 256, 
        (RGBQUAD\*) m_lpvColorTable);
    if (nColors != 0) {
        ComputePaletteSize(m_lpBMIH->biBitCount);
        MakePalette();
    }
    // memdc deleted and bitmap deselected
    return TRUE;
}

Note that this function extracts and copies the _BITMAPINFOHEADER_ structure and sets the values of the _CDib_ pointer data members. You must do some work to extract the palette from the DIB section, but the Win32 _GetDIBColorTable_ function gets you started. It's interesting that _GetDIBColorTable_ can't tell you how many palette entries a particular DIB uses. If the DIB uses only 60 entries, for example, _GetDIBColorTable_ generates a 256-entry color table with the last 196 entries set to 0.

The _DrawDibDraw_ Function
--------------------------

Windows includes the Video for Windows (VFW) component, which is supported by Visual C++. The VFW _DrawDibDraw_ function is an alternative to _StretchDIBits_. One advantage of _DrawDibDraw_ is its ability to use dithered colors. Another is its increased speed in drawing a DIB with a bpp value that does not match the current video mode. The main disadvantage is the need to link the VFW code into your process at runtime.

Shown below is a _DrawDib_ member function for the _CDib_ class that calls _DrawDibDraw_:

BOOL CDib::DrawDib(CDC\* pDC, CPoint origin, CSize size)
{
    if (m_lpBMIH == NULL) return FALSE;
    if (m_hPalette != NULL) {
        ::SelectPalette(pDC->GetSafeHdc(), m_hPalette, TRUE);
    }
    HDRAWDIB hdd = ::DrawDibOpen();
    CRect rect(origin, size);
    pDC->LPtoDP(rect); // Convert DIB's rectangle
                       //  to MM_TEXT coordinates
    rect -= pDC->GetViewportOrg();
    int nMapModeOld = pDC->SetMapMode(MM_TEXT);
    ::DrawDibDraw(hdd, pDC->GetSafeHdc(), rect.left, rect.top,
        rect.Width(), rect.Height(), m_lpBMIH, m_lpImage, 0, 0,
        m_lpBMIH->biWidth, m_lpBMIH->biHeight, 0);
    pDC->SetMapMode(nMapModeOld);
    VERIFY(::DrawDibClose(hdd));
    return TRUE;
}

Note that _DrawDibDraw_ needs _MM_TEXT_ coordinates and the _MM_TEXT_ mapping mode. Thus, logical coordinates must be converted not to device coordinates but to pixels with the origin at the top left of the scrolling window.

To use _DrawDibDraw_, your program needs an _#include<vfw.h>_ statement, and you must add vfw32.lib to the list of linker input files. _DrawDibDraw_ might assume the bitmap it draws is in read/write memory, a fact to keep in mind if you map the memory to the BMP file.
________________________________________________________________________
5.9.6. - [Putting Bitmaps on Pushbuttons](invcpp5/ch11g.htm)
----------------------------------------------------
 Putting Bitmaps on Pushbuttons 

Putting Bitmaps on Pushbuttons
==============================

The MFC library makes it easy to display a bitmap (instead of text) on a pushbutton. If you were to program this from scratch, you would set the Owner Draw property for your button and then write a message handler in your dialog class that would paint a bitmap on the button control's window. If you use the MFC _CBitmapButton_ class instead, you end up doing a lot less work, but you have to follow a kind of "cookbook" procedure. Don't worry too much about how it all works (but be glad that you don't have to write much code!).

> NOTE
> 
> There's also another way to put bitmaps on buttons. See [Chapter 36](ch36a.htm), for a description of the _CButton::SetBitmap_ function, which associates a single bitmap with a button.

To make a long story short, you lay out your dialog resource as usual with unique text captions for the buttons you designate for bitmaps. Next you add some bitmap resources to your project, and you identify those resources by name rather than by numeric ID. Finally you add some _CBitmapButton_ data members to your dialog class, and you call the _AutoLoad_ member function for each one, which matches a bitmap name to a button caption. If the button caption is "Copy", you add two bitmaps: "COPYU" for the up state and "COPYD" for the down state. By the way, you must still set the button's Owner Draw property. (This will all make more sense when you write a program).

> NOTE
> 
> If you look at the MFC source code for the _CBitmapButton_ class, you'll see that the bitmap is an ordinary GDI bitmap painted with a _BitBlt_ call. Thus, you can't expect any palette support. That's not often a problem because bitmaps for buttons are usually 16-color bitmaps that depend on standard VGA colors.

The EX11D Example
-----------------

Here are the steps for building EX11D:

2.  **Run AppWizard to produce \vcpp32\ex11d\ex11d.** Accept all the defaults but three: select Single Document, deselect Printing And Print Preview, and select Context-Sensitive Help. The options and the default class names are shown in the illustration below.
    
    The Context-Sensitive Help option was selected for one reason only: it causes AppWizard to copy some bitmap files into your project's \hlp subdirectory. These bitmaps are supposed to be bound into your project's help file, but we won't study help files until [Chapter 21](ch21a.htm).
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G11OG07x.gif)
    
3.  **Modify the project's _IDD_ABOUTBOX_ dialog resource.** It's too much hassle to create a new dialog resource for a few buttons, so we'll use the About dialog that AppWizard generates for every project. Add three pushbuttons with captions, as shown below, accepting the default IDs _IDC_BUTTON1_, _IDC_BUTTON2_, and _IDC_BUTTON3_. The size of the buttons isn't important because the framework adjusts the button size at runtime to match the bitmap size.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G11OG08.GIF)
    
    Select the Owner Draw property for all three buttons.
    
4.  **Import three bitmaps from the project's \hlp subdirectory.** Choose Resource from Visual C++'s Insert menu, and then click the Import button. Start with EditCopy.bmp, as shown below.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/g11og09.gif)
    
    Assign the name "COPYU" as shown.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G11OG10.GIF)
    
    Be sure to use quotes around the name in order to identify the resource by name rather than by ID. This is now the bitmap for the button's up state. Close the bitmap window and, from the ResourceView window, use the clipboard (or drag and drop) to make a copy of the bitmap. Rename the copy "COPYD" (down state), and then edit this bitmap. Choose Invert Colors from the Image menu. There are other ways of making a variation of the up image, but inversion is the quickest.
    
    Repeat the steps listed above for the EditCut and EditPast bitmaps. When you're finished, you should have the following bitmap resources in your project.
    
    **Resource Name**
    
    **Original File**
    
    **Invert Colors**
    
    "COPYU"
    
    EditCopy.bmp
    
    no
    
    "COPYD"
    
    EditCopy.bmp
    
    yes
    
    "CUTU"
    
    EditCut.bmp
    
    no
    
    "CUTD"
    
    EditCut.bmp
    
    yes
    
    "PASTEU"
    
    EditPast.bmp
    
    no
    
    "PASTED"
    
    EditPast.bmp
    
    yes
    
5.  **Edit the code for the _CAboutDlg_ class.** Both the declaration and the implementation for this class are contained in the ex11d.cpp file. First add the three private data members shown here in the class declaration:
    
    **CBitmapButton m_editCopy;
    CBitmapButton m_editCut;
    CBitmapButton m_editPaste;**
    
    Then you use ClassWizard to map the WM_INITDIALOG message in the dialog class. (Be sure that the _CAboutDlg_ class is selected.) The message handler (actually a virtual function) is coded as follows:
    
    BOOL CAboutDlg::OnInitDialog()
    {
        CDialog::OnInitDialog();
        **VERIFY(m_editCopy.AutoLoad(IDC_BUTTON1, this));
        VERIFY(m_editCut.AutoLoad(IDC_BUTTON2, this));
        VERIFY(m_editPaste.AutoLoad(IDC_BUTTON3, this));**
        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
    }
    
    The _AutoLoad_ function connects each button with the two matching resources. The _VERIFY_ macro is an MFC diagnostic aid that displays a message box if you didn't code the bitmap names correctly.
    
6.  **Edit the _OnDraw_ function in ex11dView.cpp.** Replace the AppWizard-generated code with the following line:
    
    **pDC->TextOut(0, 0, "Choose About from the Help menu.");**
    
7.  **Build and test the application.** When the program starts, choose About from the Help menu and observe the button behavior. The image below shows the CUT button in the down state.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G11OG11.GIF)
    
    Note that bitmap buttons send BN_CLICKED notification messages just as ordinary buttons do. ClassWizard can, of course, map those messages in your dialog class.
    

Going Further with Bitmap Buttons
---------------------------------

You've seen bitmaps for the buttons' up and down states. The _CBitmapButton_ class also supports bitmaps for the focused and disabled states. For the Copy button, the focused bitmap name would be "COPYF", and the disabled bitmap name would be "COPYX". If you want to test the disabled option, make a "COPYX" bitmap, possibly with a red line through it, and then add the following line to your program:

m_editCopy.EnableWindow(FALSE);
________________________________________________________________________
5.10. - [Chapter 12 -- Windows Message Processing and Multi-threaded Programming](invcpp5/ch12a.htm)
----------------------------------------------------
 Chapter 12 -- Windows Message Processing and Multi-threaded Programming  Chapter 12

Windows Message Processing and Multithreaded Programming
========================================================

With its multitasking and multithreading API, Win32 revolutionized programming for Microsoft Windows. If you've seen magazine articles and advanced programming books on these subjects, you might have been intimidated by the complexity of using multiple threads. You could stick with single-threaded programming for a long time and still write useful Win32 applications. If you learn the fundamentals of threads, however, you'll be able to write more efficient and capable programs. You'll also be on your way to a better understanding of the Win32 programming model.
________________________________________________________________________
5.10.1. - [Windows Message Processing](invcpp5/ch12b.htm)
----------------------------------------------------
 Windows Message Processing 

Windows Message Processing
==========================

To understand threads, you must first understand how 32-bit Windows processes messages. The best starting point is a single-threaded program that shows the importance of the message translation and dispatch process. You'll improve that program by adding a second thread, which you'll control with a global variable and a simple message. Then you'll experiment with events and critical sections. For heavy-duty multithreading elements such as mutexes and semaphores, however, you'll need to refer to another book, such as Jeffrey Richter's _Advanced Windows,_ 3d Ed. (Microsoft Press, 1997).

How a Single-Threaded Program Processes Messages
------------------------------------------------

All the programs so far in this book have been single-threaded, which means that your code has only one path of execution. With ClassWizard's help, you've written handler functions for various Windows messages and you've written _OnDraw_ code that is called in response to the WM_PAINT message. It might seem as though Windows magically calls your handler when the message floats in, but it doesn't work that way. Deep inside the MFC code (which is linked to your program) are instructions that look something like this:

MSG message;
while (::GetMessage(&message, NULL, 0, 0)) {
    ::TranslateMessage(&message);
    ::DispatchMessage(&message);
}

Windows determines which messages belong to your program, and the _GetMessage_ function returns when a message needs to be processed. If no messages are posted, your program is suspended and other programs can run. When a message eventually arrives, your program "wakes up." The _TranslateMessage_ function translates WM_KEYDOWN messages into WM_CHAR messages containing ASCII characters, and the _DispatchMessage_ function passes control (via the window class) to the MFC message pump, which calls your function via the message map. When your handler is finished, it returns to the MFC code, which eventually causes _DispatchMessage_ to return.

Yielding Control
----------------

What would happen if one of your handler functions was a pig and chewed up 10 seconds of CPU time? Back in the 16-bit days, that would have hung up the whole computer for the duration. Only cursor tracking and a few other interrupt-based tasks would have run. With Win32, multitasking got a whole lot better. Other applications can run because of preemptive multitasking—Windows simply interrupts your pig function when it needs to. However, even in Win32, your program would be locked out for 10 seconds. It couldn't process any messages because _DispatchMessage_ doesn't return until the pig returns.

There is a way around this problem, however, which works with both Win16 and Win32. You simply train your pig function to be polite and yield control once in a while by inserting the following instructions inside the pig's main loop:

MSG message;
if (::PeekMessage(&message, NULL, 0, 0, PM_REMOVE)) {
    ::TranslateMessage(&message);
    ::DispatchMessage(&message);
}

The _PeekMessage_ function works like _GetMessage_, except that it returns immediately even if no message has arrived for your program. In that case, the pig keeps on chewing. If there is a message, however, the pig pauses, the handler is called, and the pig starts up again after the handler exits.

Timers
------

A Windows timer is a useful programming element that sometimes makes multithreaded programming unnecessary. If you need to read a communication buffer, for example, you can set up a timer to retrieve the accumulated characters every 100 milliseconds. You can also use a timer to control animation because the timer is independent of CPU clock speed.

Timers are easy to use. You simply call the _CWnd_ member function _SetTimer_ with an interval parameter, and then you provide, with the help of ClassWizard, a message handler function for the resulting WM_TIMER messages. Once you start the timer with a specified interval in milliseconds, WM_TIMER messages will be sent continuously to your window until you call _CWnd::KillTimer_ or until the timer's window is destroyed. If you want to, you can use multiple timers, each identified by an integer. Because Windows isn't a real-time operating system, the interval between timer events becomes imprecise if you specify an interval much less than 100 milliseconds.

Like any other Windows messages, timer messages can be blocked by other handler functions in your program. Fortunately, timer messages don't stack up. Windows won't put a timer message in the queue if a message for that timer is already present.

The EX12A Program
-----------------

We're going to write a single-threaded program that contains a CPU-intensive computation loop. We want to let the program process messages after the user starts the computation; otherwise, the user couldn't cancel the job. Also, we'd like to display the percent-complete status by using a progress indicator control, as shown in Figure 12-1. The EX12A program allows message processing by yielding control in the compute loop. A timer handler updates the progress control based on compute parameters. The WM_TIMER messages could not be processed if the compute process didn't yield control.

![](c:/dl/books/windows/msvc5th/invcpp5/images/F12OG01.GIF)

**Figure 12-1.** _The Compute dialog box._

Here are the steps for building the EX12A application:

2.  **Run AppWizard to generate \vcpp32\ex12a\ex12a.** Accept all the default settings but two: select Single Document and deselect Printing And Print Preview. The options and the default class names are shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G12OG01x.gif)
    
3.  **Use the dialog editor to create the dialog resource _IDD_COMPUTE._** Use the resource shown here as a guide.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G12OG02.GIF)
    
    Keep the default control ID for the Cancel button, but use _IDC_START_ for the Start button. For the progress indicator, accept the default ID _IDC_PROGRESS1_.
    
4.  **Use ClassWizard to create the _CComputeDlg_ class.** ClassWizard connects the new class to the _IDD_COMPUTE_ resource you just created.
    
    After the class is generated, add a WM_TIMER message handler function. Also add BN_CLICKED message handlers for _IDC_START_ and _IDCANCEL_. Accept the default names _OnStart_ and _OnCancel_.
    
5.  **Add three data members to the _CComputeDlg_ class.** Edit the file ComputeDlg.h. Add the following private data members:
    
    **int m_nTimer;
    int m_nCount;
    enum { nMaxCount = 10000 };**
    
    The _m_nCount_ data member of class _CComputeDlg_ is incremented during the compute process. It serves as a percent complete measurement when divided by the "constant" _nMaxCount_.
    
6.  **Add initialization code to the _CComputeDlg_ constructor in the ComputeDlg.cpp file.** Add the following line to the constructor to ensure that the Cancel button will work if the compute process has not been started:
    
    **m_nCount = 0;**
    
    Be sure to add the line outside the _//{{AFX_DATA_INIT_ comments generated by ClassWizard.
    
7.  **Code the _OnStart_ function in ComputeDlg.cpp.** This code is executed when the user clicks the Start button. Add the following boldface code:
    
    void CComputeDlg::OnStart() 
    {
        **MSG message;
    
        m_nTimer = SetTimer(1, 100, NULL); // 1/10 second
        ASSERT(m_nTimer != 0);
        GetDlgItem(IDC_START)->EnableWindow(FALSE);
        volatile int nTemp;
        for (m_nCount = 0; m_nCount < nMaxCount; m_nCount++) {
            for (nTemp = 0; nTemp < 10000; nTemp++) {
                // uses up CPU cycles
            }
            if (::PeekMessage(&message, NULL, 0, 0, PM_REMOVE)) {
                ::TranslateMessage(&message);
                ::DispatchMessage(&message);
            }
        }
        CDialog::OnOK();**
    }
    
    The main _for_ loop is controlled by the value of _m_nCount_. At the end of each pass through the outer loop, _PeekMessage_ allows other messages, including WM_TIMER, to be processed. The _EnableWindow(FALSE)_ call disables the Start button during the computation. If we didn't take this precaution, the _OnStart_ function could be reentered.
    
8.  **Code the _OnTimer_ function in ComputeDlg.cpp.** When the timer fires, the progress indicator's position is set according to the value of _m_nCount_. Add the following boldface code:
    
    void CComputeDlg::OnTimer(UINT nIDEvent)
    {
        **CProgressCtrl\* pBar = (CProgressCtrl\*) GetDlgItem(IDC_PROGRESS1);
        pBar->SetPos(m_nCount \* 100 / nMaxCount);**
    }
    
9.  **Update the _OnCancel_ function in ComputeDlg.cpp.** When the user clicks the Cancel button during computation, we don't destroy the dialog; instead, we set _m_nCount_ to its maximum value, which causes _OnStart_ to exit the dialog. If the computation hasn't started, it's okay to exit directly. Add the following boldface code:
    
    void CControlDlg::OnCancel()
    {
        **TRACE("entering CComputeDlg::OnCancel\n");
        if (m_nCount == 0) {      // prior to Start button
            CDialog::OnCancel();
        }
        else {                    // computation in progress
            m_nCount = nMaxCount; // Force exit from OnStart
        }**
    }
    
10.  **Edit the _CEx12aView_ class in ex12aView.cpp.** First edit the virtual _OnDraw_ function to display a message, as shown here:
    
    void CEx12aView::OnDraw(CDC\* pDC)
    {
        **pDC->TextOut(0, 0, "Press the left mouse button here.");**
    }
    
    Then use ClassWizard to add the _OnLButtonDown_ function to handle WM_LBUTTONDOWN messages, and add the following boldface code:
    
    void CEx12aView::OnLButtonDown(UINT nFlags, CPoint point)
    {
        **CComputeDlg dlg;
        dlg.DoModal();**
    }
    
    This code displays the modal dialog whenever the user presses the left mouse button while the mouse cursor is in the view window.
    
    While you're in ex12aView.cpp, add the following _#include_ statement:
    
    **#include "ComputeDlg.h"**
    
11.  **Build and run the application.** Press the left mouse button while the mouse cursor is inside the view window to display the dialog. Click the Start button, and then click Cancel. The progress indicator should show the status of the computation.
________________________________________________________________________
5.10.2. - [On-Idle Processing](invcpp5/ch12c.htm)
----------------------------------------------------
 On-Idle Processing 

On-Idle Processing
==================

Before multithreaded programming came along, Windows developers used on-idle processing for "background" tasks such as pagination. On-idle processing is no longer as important, but it's still useful. The application framework calls a virtual member function _OnIdle_ of class _CWinApp_, and you can override this function to do background processing. _OnIdle_ is called from the framework's message processing loop, which is actually a little more complicated than the simple _GetMessage/TranslateMessage/DispatchMessage_ sequence you've seen. Generally, once the _OnIdle_ function completes its work, it is not called again until the next time the application's message queue has been emptied. If you override this function, your code will be called, but it won't be called continuously unless there is a constant stream of messages. The base class _OnIdle_ updates the toolbar buttons and status indicators, and it cleans up various temporary object pointers. It makes sense for you to override _OnIdle_ to update the user interface. The fact that your code won't be executed when no messages are coming is not important because the user interface shouldn't be changing.

> NOTE
> 
> If you do override _CWinApp::OnIdle_, don't forget to call the base class _OnIdle_. Otherwise, your toolbar buttons won't be updated and temporary objects won't be deleted.

_OnIdle_ isn't called at all if the user is working in a modal dialog or is using a menu. If you need to use background processing for modal dialogs and menus, you'll have to add a message handler function for the WM_ENTERIDLE message, but you must add it to the frame class rather than to the view class. That's because pop-up dialogs are always "owned" by the application's main frame window, not by the view window. [Chapter 15](ch15a.htm) explores the relationship between the frame window and the view window.
________________________________________________________________________
5.10.3. - [Multithreaded Programming](invcpp5/ch12d.htm)
----------------------------------------------------
 Multithreaded Programming 

Multithreaded Programming
=========================

As you'll recall from [Chapter 10](ch10a.htm), a process is a running program that owns its own memory, file handles, and other system resources. An individual process can contain separate execution paths, called threads. Don't look for separate code for separate threads, however, because a single function can be called from many threads. For the most part, all of a process's code and data space is available to all of the threads in the process. Two threads, for example, can access the same global variables. Threads are managed by the operating system, and each thread has its own stack.

Windows offers two kinds of threads, worker threads and user interface threads. The Microsoft Foundation Class (MFC) Library supports both. A user interface thread has windows, and therefore it has its own message loop. A worker thread doesn't have windows, so it doesn't need to process messages. Worker threads are easier to program and are generally more useful. The remaining examples in this chapter illustrate worker threads. At the end of the chapter, however, an application for a user interface thread is described.

Don't forget that even a single-threaded application has one thread—the main thread. In the MFC hierarchy, _CWinApp_ is derived from _CWinThread_. Back in [Chapter 2](ch02a.htm), I told you that _InitInstance_ and _m_pMainWnd_ are members of _CWinApp_. Well, I lied. The members are declared in _CWinThread_, but of course they're inherited by _CWinApp_. The important thing to remember here is that an application is a thread.

Writing the Worker Thread Function and Starting the Thread
----------------------------------------------------------

If you haven't guessed already, using a worker thread for a long computation is more efficient than using a message handler that contains a _PeekMessage_ call. Before you start a worker thread, however, you must write a global function for your thread's main program. This global function should return a _UINT_, and it should take a single 32-bit value (declared _LPVOID_) as a parameter. You can use the parameter to pass anything at all to your thread when you start it. The thread does its computation, and when the global function returns, the thread terminates. The thread would also be terminated if the process terminated, but it's preferable to ensure that the worker thread terminates first, which will guarantee that you'll have no memory leaks.

To start the thread (with function name _ComputeThreadProc_), your program makes the following call:

CWinThread\* pThread =
    AfxBeginThread(ComputeThreadProc, GetSafeHwnd(),
                   THREAD_PRIORITY_NORMAL);

The compute thread code looks like this:

UINT ComputeThreadProc(LPVOID pParam)
{
    // Do thread processing
    return 0;
}

The _AfxBeginThread_ function returns immediately; the return value is a pointer to the newly created thread object. You can use that pointer to suspend and resume the thread (_CWinThread::SuspendThread_ and _ResumeThread_), but the thread object has no member function to terminate the thread. The second parameter is the 32-bit value that gets passed to the global function, and the third parameter is the thread's priority code. Once the worker thread starts, both threads run independently. Windows divides the time between the two threads (and among the threads that belong to other processes) according to their priority. If the main thread is waiting for a message, the compute thread can still run.

How the Main Thread Talks to a Worker Thread
--------------------------------------------

The main thread (your application program) can communicate with the subsidiary worker thread in many different ways. One option that will not work, however, is a Windows message; the worker thread doesn't have a message loop. The simplest means of communication is a global variable because all the threads in the process have access to all the globals. Suppose the worker thread increments and tests a global integer as it computes and then exits when the value reaches 100. The main thread could force the worker thread to terminate by setting the global variable to 100 or higher.

The code below looks as though it should work, and when you test it, it probably will:

UINT ComputeThreadProc(LPVOID pParam)
{
    g_nCount = 0;
    while (g_nCount++ < 100) {
        // Do some computation here
    }
    return 0;
}

There's a problem, however, that you could detect only by looking at the generated assembly code. The value of _g_nCount_ gets loaded into a register, the register is incremented, and then the register value is stored back in _g_nCount_. Suppose _g_nCount_ is 40 and Windows interrupts the worker thread just after the worker thread loads 40 into the register. Now the main thread gets control and sets _g_nCount_ to 100. When the worker thread resumes, it increments the register value and stores 41 back into _g_nCount_, obliterating the previous value of 100. The thread loop doesn't terminate!

If you turn on the compiler's optimization switch, you'll have an additional problem. The compiler uses a register for _g_nCount_, and the register stays loaded for the duration of the loop. If the main thread changes the value of _g_nCount_ in memory, it will have no effect on the worker thread's compute loop. (You can ensure that the counter isn't stored in a register, however, by declaring _g_nCount_ as _volatile_.)

But suppose you rewrite the thread procedure as shown here:

UINT ComputeThreadProc(LPVOID pParam)
{
    g_nCount = 0;
    while (g_nCount < 100) {
        // Do some computation here
        ::InterlockedIncrement((long\*) &g_nCount);
    }
    return 0;
}

The _InterlockedIncrement_ function blocks other threads from accessing the variable while it is being incremented. The main thread can safely stop the worker thread.

Now you've seen some of the pitfalls of using global variables for communication. Using global variables is sometimes appropriate, as the next example illustrates, but there are alternative methods that are more flexible, as you'll see later in this chapter.

How the Worker Thread Talks to the Main Thread
----------------------------------------------

It makes sense for the worker thread to check a global variable in a loop, but what if the main thread did that? Remember the pig function? You definitely don't want your main thread to enter a loop because that would waste CPU cycles and stop your program's message processing. A Windows message is the preferred way for a worker thread to communicate with the main thread because the main thread always has a message loop. This implies, however, that the main thread has a window (visible or invisible) and that the worker thread has a handle to that window.

How does the worker thread get the handle? That's what the 32-bit thread function parameter is for. You pass the handle in the _AfxBeginThread_ call. Why not pass the C++ window pointer instead? Doing so would be dangerous because you can't depend on the continued existence of the object and you're not allowed to share objects of MFC classes among threads. (This rule does not apply to objects derived directly from _CObject_ or to simple classes such as _CRect_ and _CString_.)

Do you send the message or post it? Better to post it, because sending it could cause reentry of the main thread's MFC message pump code, and that would create problems in modal dialogs. What kind of message do you post? Any user-defined message will do.

The EX12B Program
-----------------

The EX12B program looks exactly like the EX12A program when you run it. When you look at the code, however, you'll see some differences. The computation is done in a worker thread instead of in the main thread. The count value is stored in a global variable _g_nCount_, which is set to the maximum value in the dialog window's Cancel button handler. When the thread exits, it posts a message to the dialog, which causes _DoModal_ to exit.

The document, view, frame, and application classes are the same except for their names, and the dialog resource is the same. The modal dialog class is still named _CComputeDlg_, but the code inside is quite different. The constructor, timer handler, and data exchange functions are pretty much the same. The following code fragment shows the global variable definition and the global thread function as given in the \ex12b\ComputeDlg.cpp file on the companion CD-ROM. Note that the function exits (and the thread terminates) when _g_nCount_ is greater than a constant maximum value. Before it exits, however, the function posts a user-defined message to the dialog window.

**int g_nCount = 0; 

UINT ComputeThreadProc(LPVOID pParam)
{
    volatile int nTemp; // volatile else compiler optimizes too much

    for (g_nCount = 0; g_nCount < CComputeDlg::nMaxCount;
                       ::InterlockedIncrement((long\*) &g_nCount)) {
        for (nTemp = 0; nTemp < 10000; nTemp++) {
            // uses up CPU cycles
        }
    }
    // WM_THREADFINISHED is user-defined message
    ::PostMessage((HWND) pParam, WM_THREADFINISHED, 0, 0);
    g_nCount = 0;
    return 0; // ends the thread
}**

The _OnStart_ handler below is mapped to the dialog's Start button. Its job is to start the timer and the worker thread. You can change the worker thread's priority by changing the third parameter of _AfxBeginThread_—for example, the computation runs a little more slowly if you set the priority to _THREAD_PRIORITY_LOWEST_.

void CComputeDlg::OnStart()
{
    **m_nTimer = SetTimer(1, 100, NULL); // 1/10 second
    ASSERT(m_nTimer != 0);
    GetDlgItem(IDC_START)->EnableWindow(FALSE);
    AfxBeginThread(ComputeThreadProc, GetSafeHwnd(),
                   THREAD_PRIORITY_NORMAL);**
}

The _OnCancel_ handler below is mapped to the dialog's Cancel button. It sets the _g_nCount_ variable to the maximum value, causing the thread to terminate.

void CComputeDlg::OnCancel()
{
    **if (g_nCount == 0) { // prior to Start button
        CDialog::OnCancel();
    }
    else { // computation in progress
        g_nCount = nMaxCount; // Force thread to exit
    }**
}

The _OnThreadFinished_ handler below is mapped to the dialog's WM_THREADFINISHED user-defined message. It causes the dialog's _DoModal_ function to exit.

**LRESULT CComputeDlg::OnThreadFinished(WPARAM wParam, LPARAM lParam)
{
    CDialog::OnOK();
    return 0;
}**

Using Events for Thread Synchronization
---------------------------------------

The global variable is a crude but effective means of interthread communication. Now let's try something more sophisticated. We want to think in terms of thread synchronization instead of simple communication. Our threads must carefully synchronize their interactions with one another.

An event is one type of kernel object (processes and threads are also kernel objects) that Windows provides for thread synchronization. An event is identified by a unique 32-bit handle within a process. It can be identified by name, or its handle can be duplicated for sharing among processes. An event can be either in the signaled (or true) state or in the unsignaled (or false) state. Events come in two types: manual reset and autoreset. We'll be looking at autoreset events here because they're ideal for the synchronization of two processes.

Let's go back to our worker thread example. We want the main (user interface) thread to "signal" the worker thread to make it start or stop, so we'll need a "start" event and a "kill" event. MFC provides a handy _CEvent_ class that's derived from _CSyncObject_. By default, the constructor creates a Win32 autoreset event object in the unsignaled state. If you declare your events as global objects, any thread can easily access them. When the main thread wants to start or terminate the worker thread, it sets the appropriate event to the signaled state by calling _CEvent::SetEvent_.

Now the worker thread must monitor the two events and respond when one of them is signaled. MFC provides the _CSingleLock_ class for this purpose, but it's easier to use the Win32 _WaitForSingleObject_ function. This function suspends the thread until the specified object becomes signaled. When the thread is suspended, it's not using any CPU cycles—which is good. The first _WaitForSingleObject_ parameter is the event handle. You can use a _CEvent_ object for this parameter; the object inherits from _CSyncObject_ an operator _HANDLE_ that returns the event handle it has stored as a public data member. The second parameter is the time-out interval. If you set this parameter to _INFINITE_, the function waits forever until the event becomes signaled. If you set the time-out to 0, _WaitForSingleObject_ returns immediately, with a return value of _WAIT_OBJECT_0_ if the event was signaled.

The EX12C Program
-----------------

The EX12C program uses two events to synchronize the worker thread with the main thread. Most of the EX12C code is the same as EX12B, but the _CComputeDlg_ class is quite different. The StdAfx.h file contains the following line for the _CEvent_ class:

**#include <afxmt.h>**

There are two global event objects, as shown below. Note that the constructors create the Windows events prior to the execution of the main program.

**CEvent g_eventStart; // creates autoreset events
CEvent g_eventKill;**

It's best to look at the worker thread global function first. The function increments _g_nCount_ just as it did in EX12B. The worker thread is started by the _OnInitDialog_ function instead of by the Start button handler. The first _WaitForSingleObject_ call waits for the start event, which is signaled by the Start button handler. The _INFINITE_ parameter means that the thread waits as long as necessary. The second _WaitForSingleObject_ call is different—it has a 0 time-out value. It's located in the main compute loop and simply makes a quick test to see whether the kill event was signaled by the Cancel button handler. If the event was signaled, the thread terminates.

**UINT ComputeThreadProc(LPVOID pParam)
{
    volatile int nTemp;

    ::WaitForSingleObject(g_eventStart, INFINITE);
    TRACE("starting computation\n");
    for (g_nCount = 0; g_nCount < CComputeDlg::nMaxCount;
                       g_nCount++) {
        for (nTemp = 0; nTemp < 10000; nTemp++) {
            // Simulate computation
        }
        if (::WaitForSingleObject(g_eventKill, 0) == WAIT_OBJECT_0) {
            break;
        }
    }
    // Tell owner window we're finished
    ::PostMessage((HWND) pParam, WM_THREADFINISHED, 0, 0);
    g_nCount = 0;
    return 0; // ends the thread
}**

Here is the _OnInitDialog_ function that's called when the dialog is initialized. Note that it starts the worker thread, which doesn't do anything until the start event is signaled.

BOOL CComputeDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    **AfxBeginThread(ComputeThreadProc, GetSafeHwnd());**
    return TRUE;  // Return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

The following Start button handler sets the start event to the signaled state, thereby starting the worker thread's compute loop:

void CComputeDlg::OnStart()
{
    **m_nTimer = SetTimer(1, 100, NULL); // 1/10 second
    ASSERT(m_nTimer != 0);
    GetDlgItem(IDC_START)->EnableWindow(FALSE);
    g_eventStart.SetEvent();**
}

The following Cancel button handler sets the kill event to the signaled state, causing the worker thread's compute loop to terminate:

void CComputeDlg::OnCancel()
{
    **if (g_nCount == 0) { // prior to Start button
        // Must start it before we can kill it
        g_eventStart.SetEvent();
    }
    g_eventKill.SetEvent();**
}

Note the awkward use of the start event when the user cancels without starting the compute process. It might be neater to define a new cancel event and then replace the first _WaitForSingleObject_ call with a _WaitForMultipleObjects_ call in the _ComputeThreadProc_ function. If _WaitForMultipleObjects_ detected a cancel event, it could cause an immediate thread termination.

Thread Blocking
---------------

The first _WaitForSingleObject_ call in the _ComputeThreadProc_ function above is an example of thread blocking. The thread simply stops executing until an event becomes signaled. A thread could be blocked in many other ways. You could call the Win32 _Sleep_ function, for example, to put your thread to "sleep" for 500 milliseconds. Many functions block threads, particularly those functions that access hardware devices or Internet hosts. Back in the Win16 days, those functions took over the CPU until they were finished. In Win32, they allow other processes and threads to run.

You should avoid putting blocking calls in your main user interface thread. Remember that if your main thread is blocked, it can't process its messages, and that makes the program appear sluggish. If you have a task that requires heavy file I/O, put the code in a worker thread and synchronize it with your main thread.

Be careful of calls in your worker thread that could block indefinitely. Check the online documentation to determine whether you have the option of setting a time-out value for a particular I/O operation. If a call does block forever, the thread will be terminated when the main process exits, but then you'll have some memory leaks. You could call the Win32 _TerminateThread_ function from your main thread, but you'd still have the memory-leak problem.

Critical Sections
-----------------

Remember the problems with access to the _g_nCount_ global variable? If you want to share global data among threads and you need more flexibility than simple instructions like _InterlockedIncrement_ can provide, critical sections might be the synchronization tools for you. Events are good for signaling, but critical sections (sections of code that require exclusive access to shared data) are good for controlling access to data.

MFC provides the _CCriticalSection_ class that wraps the Windows critical section handle. The constructor calls the Win32 _InitializeCriticalSection_ function, the _Lock_ and _Unlock_ member functions call _EnterCriticalSection_ and _LeaveCriticalSection_, and the destructor calls _DeleteCriticalSection_. Here's how you use the class to protect global data:

CCriticalSection g_cs;    // global variables accessible from all threads
int g_nCount;
void func()
{
    g_cs.Lock();
    g_nCount++;
    g_cs.Unlock();
}

Suppose your program tracks time values as hours, minutes, and seconds, each stored in a separate integer, and suppose two threads are sharing time values. Thread A is changing a time value but is interrupted by thread B after it has updated hours but before it has updated minutes and seconds. Thread B will have an invalid time value.

If you write a C++ class for your time format, it's easy to control data access by making the data members private and providing public member functions. The _CHMS_ class, shown in Figure 12-2, does exactly that. Notice that the class has a data member of type _CCriticalSection_. Thus, a critical section object is associated with each _CHMS_ object.

Notice that the other member functions call the _Lock_ and _Unlock_ member functions. If thread A is executing in the middle of _SetTime_, thread B will be blocked by the _Lock_ call in _GetTotalSecs_ until thread A calls _Unlock_. The _IncrementSecs_ function calls _SetTime_, resulting in nested locks on the critical section. That's okay because Windows keeps track of the nesting level.

The _CHMS_ class works well if you use it to construct global objects. If you share pointers to objects on the heap, you have another set of problems. Each thread must determine whether another thread has deleted the object, and that means you must synchronize access to the pointers.

**HMS.H**

#include "StdAfx.h"

class CHMS
{
private:
    int m_nHr, m_nMn, m_nSc;
    CCriticalSection m_cs;
public:
    CHMS() : m_nHr(0), m_nMn(0), m_nSc(0) {}

    ~CHMS() {}

    void SetTime(int nSecs)
    {
        m_cs.Lock();
        m_nSc = nSecs % 60;
        m_nMn = (nSecs / 60) % 60;
        m_nHr = nSecs / 3600;
        m_cs.Unlock();
    }
    
    int GetTotalSecs()
    {
        int nTotalSecs;
        m_cs.Lock();
        nTotalSecs = m_nHr \* 3600 + m_nMn \* 60 + m_nSc;
        m_cs.Unlock();
        return nTotalSecs;
    }
    
    void IncrementSecs()
    {
        m_cs.Lock();
        SetTime(GetTotalSecs() + 1);
        m_cs.Unlock();
    }
};

**Figure 12-2.** _The_ CHMS _class listing._

No sample program is provided that uses the _CHMS_ class, but the file hms.h is included in the \vcpp32\ex12c subdirectory on the companion CD-ROM. If you write a multithreaded program, you can share global objects of the class. You don't need any other calls to the thread-related functions.

Mutexes and Semaphores
----------------------

As I mentioned, I'm leaving these synchronization objects to Jeffrey Richter's _Advanced Windows_. You might need a mutex or a semaphore if you're controlling access to data across different processes because a critical section is accessible only within a single process. Mutexes and semaphores (along with events) are shareable by name.

User Interface Threads
----------------------

The MFC library provides good support for UI threads. You derive a class from _CWinThread_, and you use an overloaded version of _AfxBeginThread_ to start the thread. Your derived _CWinThread_ class has its own _InitInstance_ function, and most important, it has its own message loop. You can construct windows and map messages as required.

Why might you want a user interface thread? If you want multiple top-level windows, you can create and manage them from your main thread. Suppose you allow the user to run multiple instances of your application, but you want all instances to share memory. You can configure a single process to run multiple UI threads such that users think they are running separate processes. That's exactly what Windows Explorer does. Check it out with SPY++.

Starting the second and subsequent threads is a little tricky because the user actually launches a new process for each copy of Windows Explorer. When the second process starts, it signals the first process to start a new thread, and then it exits. The second process can locate the first process either by calling the Win32 _FindWindow_ function or by declaring a shared data section. Shared data sections are explained in detail in Jeffrey Richter's book.
________________________________________________________________________
/6. - [Part III: The Document-View Architecture]()
====================================================
________________________________________________________________________
6.1. - [Chapter 13 -- Menus, Keyboard Accelerators, the Rich Edit Control, and Property Sheets](invcpp5/ch13a.htm)
----------------------------------------------------
 Chapter 13 -- Menus, Keyboard Accelerators, the Rich Edit Control, and Property Sheets  Chapter 13

Menus, Keyboard Accelerators, the Rich Edit Control, and Property Sheets
========================================================================

In all the book's examples to this point, mouse clicks have triggered most program activity. Even though menu selections might have been more appropriate, you've used mouse clicks because mouse-click messages are handled simply and directly within the Microsoft Foundation Class (MFC) Library version 6.0 view window. If you want program activity to be triggered when the user chooses a command from a menu, you must first become familiar with the other application framework elements.

This chapter concentrates on menus and the command routing architecture. Along the way, we introduce frames and documents, explaining the relationships between these new application framework elements and the already familiar view element. You'll use the menu editor to lay out a menu visually, and you'll use ClassWizard to link document and view member functions to menu items. You'll learn how to use special update command user interface (UI) member functions to check and disable menu items, and you'll see how to use keyboard accelerators as menu shortcut keys.

Because you're probably tired of circles and dialogs, next you'll examine two new MFC building blocks. The rich edit common control can add powerful text editing features to your application. Property sheets are ideal for setting edit options.
________________________________________________________________________
6.1.1. - [The Main Frame Window and Document Classes](invcpp5/ch13b.htm)
----------------------------------------------------
 The Main Frame Window and Document Classes 

The Main Frame Window and Document Classes
==========================================

Up to now, you've been using a view window as if it were the application's only window. In an SDI application, the view window sits inside another window—the application's main frame window. The main frame window has the title bar and the menu bar. Various child windows, including the toolbar window, the view window, and the status bar window, occupy the main frame window's client area, as shown in Figure 13-1. The application framework controls the interaction between the frame and the view by routing messages from the frame to the view.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F13OG01x.gif)]

**Figure 13-1.** _The child windows within an SDI main frame window._

Look again at any project files generated by AppWizard. The MainFrm.h and MainFrm.cpp files contain the code for the application's main frame window class, derived from the class _CFrameWnd_. Other files, with names such as ex13aDoc.h and ex13aDoc.cpp, contain code for the application's document class, which is derived from _CDocument_. In this chapter you'll begin working with the MFC document class. You'll start by learning that each view object has exactly one document object attached and that the view's inherited _GetDocument_ member function returns a pointer to that object. In [Chapter 15](ch15a.htm) you'll examine frame windows, and in [Chapter 16](ch16a.htm) you'll learn much more about document-view interactions.
________________________________________________________________________
6.1.2. - [Windows Menus](invcpp5/ch13c.htm)
----------------------------------------------------
 Windows Menus 

Windows Menus
=============

A Microsoft Windows menu is a familiar application element that consists of a top-level horizontal list of items with associated pop-up menus that appear when the user selects a top-level item. Most of the time, you define for a frame window a default menu resource that loads when the window is created. You can also define a menu resource independent of a frame window. In that case, your program must call the functions necessary to load and activate the menu.

A menu resource completely defines the initial appearance of a menu. Menu items can be grayed or have check marks, and bars can separate groups of menu items. Multiple levels of pop-up menus are possible. If a first-level menu item is associated with a subsidiary pop-up menu, the menu item carries a right-pointing arrow symbol, as shown next to the Start Debug menu item in Figure 13-2.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F13OG02x.gif)]

**Figure 13-2.** _Multilevel pop-up menus (from Microsoft Visual C++)._

Visual C++ includes an easy-to-use menu-resource editing tool. This tool lets you edit menus in a wysiwyg environment. Each menu item has a properties dialog that defines all the characteristics of that item. The resulting resource definition is stored in the application's resource script (RC) file. Each menu item is associated with an ID, such as _ID_FILE_OPEN_, that is defined in the resource.h file.

The MFC library extends the functionality of the standard menus for Windows. Each menu item can have a prompt string that appears in the frame's status bar when the item is highlighted. These prompts are really Windows string resource elements linked to the menu item by a common ID. From the point of view of the menu editor and your program, the prompts appear to be part of the menu item definition.
________________________________________________________________________
6.1.3. - [Keyboard Accelerators](invcpp5/ch13d.htm)
----------------------------------------------------
 Keyboard Accelerators 

Keyboard Accelerators
=====================

You've probably noticed that most menu items contain an underlined letter. In Visual C++ (and most other applications), pressing Alt-F followed by S activates the File Save menu item. This shortcut system is the standard Windows method of using the keyboard to choose commands from menus. If you look at an application's menu resource script (or the menu editor's properties dialog), you will see an ampersand (&) preceding the character that is underlined in each of the application's menu items.

Windows offers an alternative way of linking keystrokes to menu items. The keyboard accelerator resource consists of a table of key combinations with associated command IDs. The Edit Copy menu item (with command ID _ID_EDIT_COPY_), for example, might be linked to the Ctrl-C key combination through a keyboard accelerator entry. A keyboard accelerator entry does not have to be associated with a menu item. If no Edit Copy menu item were present, the Ctrl-C key combination would nevertheless activate the _ID_EDIT_COPY_ command.

> NOTE
> 
> If a keyboard accelerator is associated with a menu item or toolbar button, the accelerator key is disabled when the menu item or button is disabled.
________________________________________________________________________
6.1.4. - [Command Processing](invcpp5/ch13e.htm)
----------------------------------------------------
 Command Processing 

Command Processing
==================

As you saw in [Chapter 2](ch02a.htm), the application framework provides a sophisticated routing system for command messages. These messages originate from menu selections, keyboard accelerators, and toolbar and dialog button clicks. Command messages can also be sent by calls to the _CWnd::SendMessage_ or _PostMessage_ function. Each message is identified by a _#define_ constant that is often assigned by a resource editor. The application framework has its own set of internal command message IDs, such as _ID_FILE_PRINT_ and _ID_FILE_OPEN_. Your project's resource.h file contains IDs that are unique to your application.

Most command messages originate in the application's frame window, and without the application framework in the picture, that's where you would put the message handlers. With command routing, however, you can handle a message almost anywhere. When the application framework sees a frame window command message, it starts looking for message handlers in one of the sequences listed here.

**SDI Application**

**MDI Application**

View

View

Document

Document

SDI main frame window

MDI child frame window

Application

MDI main frame window  
Application

Most applications have a particular command handler in only one class, but suppose your one-view application has an identical handler in both the view class and the document class. Because the view is higher in the command route, only the view's command handler function will be called.

What is needed to install a command handler function? The installation requirements are similar to those of the window message handlers you've already seen. You need the function itself, a corresponding message map entry, and the function prototype. Suppose you have a menu item named Zoom (with _IDM_ZOOM_ as the associated ID) that you want your view class to handle. First you add the following code to your view implementation file:

BEGIN_MESSAGE_MAP(CMyView, CView)
    ON_COMMAND(IDM_ZOOM, OnZoom)
END_MESSAGE_MAP()

void CMyView::OnZoom()
{
    // command message processing code
}

Now add the following function prototype to the _CMyView_ class header file (before the _DECLARE_MESSAGE_MAP_ macro):

afx_msg void OnZoom();

Of course, ClassWizard automates the process of inserting command message handlers the same way it facilitates the insertion of window message handlers. You'll learn how this works in the next example, EX13A.

Command Message Handling in Derived Classes
-------------------------------------------

The command routing system is one dimension of command message handling. The class hierarchy is a second dimension. If you look at the source code for the MFC library classes, you'll see lots of _ON_COMMAND_ message map entries. When you derive a class from one of these base classes—for example, _CView_—the derived class inherits all the _CView_ message map functions, including the command message functions. To override one of the base class message map functions, you must add both a function and a message map entry to your derived class.

Update Command User Interface Handlers
--------------------------------------

You often need to change the appearance of a menu item to match the internal state of your application. If your application's Edit menu includes a Clear All item, for example, you might want to disable that item if there's nothing to clear. You've undoubtedly seen such grayed menu items in Windows-based applications, and you've probably also seen check marks next to menu items.

With Win32 programming, it's difficult to keep menu items synchronized with the application's state. Every piece of code that changes the internal state must contain statements to update the menu. The MFC library takes a different approach by calling a special update command user interface (UI) handler function whenever a pop-up menu is first displayed. The handler function's argument is a _CCmdUI_ object, which contains a pointer to the corresponding menu item. The handler function can then use this pointer to modify the menu item's appearance. Update command UI handlers apply only to items on pop-up menus, not to top-level menu items that are permanently displayed. You can't use an update command UI handler to disable a File menu item, for example.

The update command UI coding requirements are similar to those for commands. You need the function itself, a special message map entry, and of course the prototype. The associated ID—in this case, _IDM_ZOOM_—is the same constant used for the command. Here is an example of the necessary additions to the view class code file:

BEGIN_MESSAGE_MAP(CMyView, CView)
    ON_UPDATE_COMMAND_UI(IDM_ZOOM, OnUpdateZoom)
END_MESSAGE_MAP()

void CMyView::OnUpdateZoom(CCmdUI\* pCmdUI)
{
    pCmdUI->SetCheck(m_bZoomed); // m_bZoomed is a class data member
}

Here is the function prototype that you must add to the class header (before the _DECLARE_MESSAGE_MAP_ macro):

afx_msg void OnUpdateZoom(CCmdUI\* pCmdUI);

Needless to say, ClassWizard automates the process of inserting update command UI handlers.

Commands That Originate in Dialogs
----------------------------------

Suppose you have a pop-up dialog with buttons, and you want a particular button to send a command message. Command IDs must be in the range 0x8000 to 0xDFFF, the same ID range that the resource editor uses for your menu items. If you assign an ID in this range to a dialog button, the button will generate a routable command. The application framework first routes this command to the main frame window because the frame window owns all pop-up dialogs. The command routing then proceeds normally; if your view has a handler for the button's command, that's where it will be handled. To ensure that the ID is in the range 0x8000 to 0xDFFF, you must use Visual C++'s symbol editor to enter the ID prior to assigning the ID to a button.
________________________________________________________________________
6.1.5. - [The Application Framework's Built-In Menu Items](invcpp5/ch13f.htm)
----------------------------------------------------
 The Application Framework's Built-In Menu Items 

The Application Framework's Built-In Menu Items
===============================================

You don't have to start each frame menu from scratch—the MFC library defines some useful menu items for you, along with all the command handler functions, as shown in Figure 13-3.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F13OG03x.gif)]

**Figure 13-3.** _The standard SDI frame menus._

The menu items and command message handlers that you get depend on the options you choose in AppWizard. If you deselect Printing and Print Preview, for example, the Print and Print Preview menu items don't appear. Because printing is optional, the message map entries are not defined in the _CView_ class but are generated in your derived view class. That's why entries such as the following are defined in the _CMyView_ class instead of in the _CView_ class:

ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)

Enabling/Disabling Menu Items
-----------------------------

The application framework can disable a menu item if it does not find a command message handler in the current command route. This feature saves you the trouble of having to write _ON_UPDATE_COMMAND_UI_ handlers. You can disable the feature if you set the _CFrameWnd_ data member _m_bAutoMenuEnable_ to _FALSE_.

Suppose you have two views for one document, but only the first view class has a message handler for the _IDM_ZOOM_ command. The Zoom item on the frame menu will be enabled only when the first view is active. Or consider the application framework-supplied Edit Cut, Copy, and Paste menu items. These will be disabled if you have not provided message handlers in your derived view or document class.
________________________________________________________________________
6.1.6. - [MFC Text Editing Options](invcpp5/ch13g.htm)
----------------------------------------------------
 MFC Text Editing Options 

MFC Text Editing Options
========================

Windows itself supplies two text editing tools: edit control and Windows rich edit common control. Both can be used as controls within dialogs, but both can also be made to look like view windows. The MFC library supports this versatility with the _CEditView_ and _CRichEditView_ classes.

The _CEditView_ Class
---------------------

This class is based on the Windows edit control, so it inherits all the edit control's limitations. Text size is limited to 64 KB, and you can't mix fonts. AppWizard gives you the option of making _CEditView_ the base class of your view class. When the framework gives you an edit view object, it has all the functionality of both _CView_ and _CEdit_. There's no multiple inheritance here, just some magic that involves window subclassing. The _CEditView_ class implements and maps the clipboard cut, copy, and paste functions, so they appear active on the Edit menu.

The _CRichEditView_ Class
-------------------------

This class uses the rich edit control, so it supports mixed formats and large quantities of text. The _CRichEditView_ class is designed to be used with the _CRichEditDoc_ and _CRichEditCntrItem_ classes to implement a complete ActiveX container application.

The _CRichEditCtrl_ Class
-------------------------

This class wraps the rich edit control, and you can use it to make a fairly decent text editor. That's exactly what we'll do in the EX13A example. We'll use an ordinary view class derived from _CView_, and we'll cover the view's client area with a big rich edit control that resizes itself when the view size changes. The _CRichEditCtrl_ class has dozens of useful member functions, and it picks up other functions from its _CWnd_ base class. The functions we'll use in this chapter are as follows.

**Function**

**Description**

_Create_

Creates the rich edit control window (called from the parent's WM_CREATE handler)

_SetWindowPos_

Sets the size and position of the edit window (sizes the control to cover the view's client area)

_GetWindowText_

Retrieves plain text from the control (other functions available to retrieve the text with rich text formatting codes)

_SetWindowText_

Stores plain text in the control

_GetModify_

Gets a flag that is _TRUE_ if the text has been modified (text modified if the user types in the control or if the program calls _SetModify(TRUE)_)

_SetModify_

Sets the modify flag to _TRUE_ or _FALSE_

_GetSel_

Gets a flag that indicates whether the user has selected text

_SetDefaultCharFormat_

Sets the control's default format characteristics

_SetSelectionCharFormat_

Sets the format characteristics of the selected text

> NOTE
> 
> If you use the dialog editor to add a rich edit control to a dialog resource, your application class _InitInstance_ member function must call the function _AfxInitRichEdit_.
________________________________________________________________________
6.1.7. - [The EX13A Example](invcpp5/ch13h.htm)
----------------------------------------------------
 The EX13A Example 

The EX13A Example
=================

This example illustrates the routing of menu and keyboard accelerator commands to both documents and views. The application's view class is derived from _CView_ and contains a rich edit control. View-directed menu commands, originating from a new pop-up menu named Transfer, move data between the view object and the document object, and a Clear Document menu item erases the document's contents. On the Transfer menu, the Store Data In Document item is grayed when the view hasn't been modified since the last time the data was transferred. The Clear Document item, located on the Edit menu, is grayed when the document is empty. Figure 13-4 shows the first version of the EX13A program in use.

![](c:/dl/books/windows/msvc5th/invcpp5/images/F13OG04x.gif)

**Figure 13-4.** _The EX13A program in use._

If we exploited the document-view architecture fully, we would tell the rich edit control to keep its text inside the document, but that's rather difficult to do. Instead, we'll define a document _CString_ data member named _m_strText_, the contents of which the user can transfer to and from the control. The initial value of _m_strText_ is a Hello message; choosing Clear Document from the Edit menu sets it to empty. By running this example, you'll start to understand the separation of the document and the view.

The first part of the EX13A example exercises Visual C++'s wysiwyg menu editor and keyboard accelerator editor together with ClassWizard. You'll need to do very little C++ coding. Simply follow these steps:

2.  **Run AppWizard to generate \vcpp32\ex13a\ex13a.** Accept all the default settings but two: select Single Document and deselect Printing and Print Preview.
    
3.  **Use the resource editor to edit the application's main menu.** Click on the ResourceView tab in the Workspace window. Edit the _IDR_MAINFRAME_ menu resource to add a separator and a Clear Document item to the Edit menu, as shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G13OG01.GIF)
    
    > TIPS
    > 
    > The resource editor's menu resource editor is intuitive, but you might need some help the first time you insert an item in the middle of a menu. A blank item is present at the bottom of each menu. Using the mouse, drag the blank item to the insertion position to define a new item. A new blank item will appear at the bottom when you're finished.
    
    Now add a Transfer menu, and then define the underlying items.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G13OG02.GIF)
    
    Use the following command IDs for your new menu items.
    
    **Menu**
    
    **Caption**
    
    **Command ID**
    
    Edit
    
    Clear &Document
    
    _ID_EDIT_CLEAR_ALL_
    
    Transfer
    
    &Get Data From Document\tF2
    
    _ID_TRANSFER_GETDATA_
    
    Transfer
    
    &Store Data In Document\tF3
    
    _ID_TRANSFER_STOREDATA_
    
    The MFC library has defined the first item, _ID_EDIT_CLEAR_ALL_. (Note: \t is a tab character—but type \_t_; don't press the Tab key.)
    
    When you add the menu items, type appropriate prompt strings in the Menu Item Properties dialog. These prompts will appear in the application's status bar window when the menu item is highlighted.
    
4.  **Use the resource editor to add keyboard accelerators.** Open the _IDR_MAINFRAME_ accelerator table, and then use the insert key to add the following items.
    
    **Accelerator ID**
    
    **Key**
    
    _ID_TRANSFER_GETDATA_
    
    VK_F2
    
    _ID_TRANSFER_STOREDATA_
    
    VK_F3
    
    Be sure to turn off the Ctrl, Alt, and Shift modifiers. The Accelerator edit screen and Accel Properties dialog are shown in the illustration below.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G13OG03x.gif)]
    
5.  **Use ClassWizard to add the view class command and update command UI message handlers.** Select the _CEx13aView_ class, and then add the following member functions.
    
    **Object ID**
    
    **Message**
    
    **Member Function**
    
    _ID_TRANSFER_GETDATA_
    
    COMMAND
    
    _OnTransferGetData_
    
    _ID_TRANSFER_STOREDATA_
    
    COMMAND
    
    _OnTransferStoreData_
    
    _ID_TRANSFER_STOREDATA_
    
    UPDATE_COMMAND_UI
    
    _OnUpdateTransferStoreData_
    
6.  **Use ClassWizard to add the document class command and update command UI message handlers.** Select the _CEx13aDoc_ class, and then add the following member functions.
    
    **Object ID**
    
    **Message**
    
    **Member Function**
    
    _ID_EDIT_CLEAR_ALL_
    
    COMMAND
    
    _OnEditClearDocument_
    
    _ID_EDIT_CLEAR_ALL_
    
    UPDATE_COMMAND_UI
    
    _OnUpdateEditClearDocument_
    
7.  **Add a _CString_ data member to the _CEx13aDoc_ class.** Edit the file ex13aDoc.h or use ClassView.
    
    **public:
        CString m_strText**;
    
8.  **Edit the document class member functions in ex13aDoc.cpp.** The _OnNewDocument_ function was generated by ClassWizard. As you'll see in [Chapter 16](ch16a.htm), the framework calls this function after it first constructs the document and when the user chooses New from the File menu. Your version sets some text in the string data member. Add the following boldface code:
    
    BOOL CEx13aDoc::OnNewDocument()
    {
        if (!CDocument::OnNewDocument())
            return FALSE;
        **m_strText = "Hello (from CEx13aDoc::OnNewDocument)";**
        return TRUE;
    }
    
    The Edit Clear Document message handler sets _m_strText_ to empty, and the update command UI handler grays the menu item if the string is already empty. Remember that the framework calls _OnUpdateEditClearDocument_ when the Edit menu pops up. Add the following boldface code:
    
    void CEx13aDoc::OnEditClearDocument()
    {
        **m_strText.Empty();**
    }
    
    void CEx13aDoc::OnUpdateEditClearDocument(CCmdUI\* pCmdUI)
    {
        **pCmdUI->Enable(!m_strText.IsEmpty());**
    }
    
9.  **Add a _CRichEditCtrl_ data member to the _CEx13aView_ class.** Edit the file ex13aView.h or use ClassView.
    
    **public:
        CRichEditCtrl m_rich;**
    
10.  **Use ClassWizard to map the WM_CREATE and WM_SIZE messages in the _CEx13aView_ class.** The _OnCreate_ function creates the rich edit control. The control's size is 0 here because the view window doesn't have a size yet. The code for the two handlers is shown below.
    
    int CEx13aView::OnCreate(LPCREATESTRUCT lpCreateStruct)
    {
        **CRect rect(0, 0, 0, 0);**
        if (CView::OnCreate(lpCreateStruct) == -1)
            return -1;
        **m_rich.Create(ES_AUTOVSCROLL | ES_MULTILINE | ES_WANTRETURN |
                      WS_CHILD | WS_VISIBLE | WS_VSCROLL, rect, this, 1);**
        return 0;
    }
    
    Windows sends the WM_SIZE message to the view as soon as the view's initial size is determined and again each time the user changes the frame size. This handler simply adjusts the rich edit control's size to fill the view client area. Add the following boldface code:
    
    void CEx13aView::OnSize(UINT nType, int cx, int cy)
    {
        **CRect rect;**
        CView::OnSize(nType, cx, cy);
        **GetClientRect(rect);
        m_rich.SetWindowPos(&wndTop, 0, 0, rect.right - rect.left,
                            rect.bottom - rect.top, SWP_SHOWWINDOW);**
    }
    
11.  **Edit the menu command handler functions in ex13aView.cpp.** ClassWizard generated these skeleton functions when you mapped the menu commands in step 4. The _OnTransferGetData_ function gets the text from the document data member and puts it in the rich edit control. The function then clears the control's modified flag. There is no update command UI handler. Add the following boldface code:
    
    void CEx13aView::OnTransferGetData()
    {
        **CEx13aDoc\* pDoc = GetDocument();
        m_rich.SetWindowText(pDoc->m_strText);
        m_rich.SetModify(FALSE);**
    }
    
    The _OnTransferStoreData_ function copies the text from the view's rich edit control to the document string and resets the control's modified flag. The corresponding update command UI handler grays the menu item if the control has not been changed since it was last copied to or from the document. Add the following boldface code:
    
    void CEx13aView::OnTransferStoreData()
    {
        **CEx13aDoc\* pDoc = GetDocument();
        m_rich.GetWindowText(pDoc->m_strText);
        m_rich.SetModify(FALSE);**
    }
    
    void CEx13aView::OnUpdateTransferStoreData(CCmdUI\* pCmdUI)
    {
        **pCmdUI->Enable(m_rich.GetModify());**
    }
    
12.  **Build and test the EX13A application.** When the application starts, the Clear Document item on the Edit menu should be enabled. Choose Get Data From Document from the Transfer menu. Some text should appear. Edit the text, and then choose Store Data In Document. That menu item should now appear gray. Try choosing the Clear Document command, and then choose Get Data From Document again.
________________________________________________________________________
6.1.8. - [Property Sheets](invcpp5/ch13i.htm)
----------------------------------------------------
 Property Sheets 

Property Sheets
===============

You've already seen property sheets in Visual C++ and in many other modern Windows-based programs. A property sheet is a nice UI element that allows you to cram lots of categorized information into a small dialog. The user selects pages by clicking on their tabs. Windows offers a tab control that you can insert in a dialog, but it's more likely that you'll want to put dialogs inside the tab control. The MFC library supports this, and the result is called a property sheet. The individual dialogs are called property pages.

Building a Property Sheet
-------------------------

Follow these general steps to build a property sheet using the Visual C++ tools:

1.  Use the resource editor to create a series of dialog templates that are all approximately the same size. The captions are the strings that you want to display on the tabs.
    
2.  Use ClassWizard to generate a class for each template. Select _CPropertyPage_ as the base class. Add data members for the controls.
    
3.  Use ClassWizard to generate a single class derived from _CPropertySheet_.
    
4.  To the sheet class, add one data member for each page class.
    
5.  In the sheet class constructor, call the _AddPage_ member function for each page, specifying the address of the embedded page object.
    
6.  In your application, construct an object of the derived _CPropertySheet_ class, and then call _DoModal_. You must specify a caption in the constructor call, but you can change the caption later by calling _CPropertySheet::SetTitle_.
    
7.  Take care of programming for the Apply button.
    

Property Sheet Data Exchange
----------------------------

The framework puts three buttons on a property sheet. (See, for example, Figure 13-5.) Be aware that the framework calls the Dialog Data Exchange (DDX) code for a property page each time the user switches to and from that page. As you would expect, the framework calls the DDX code for a page when the user clicks OK, thus updating that page's data members. From these statements, you can conclude that all data members for all pages are updated when the user clicks OK to exit the sheet. All this with no C++ programming on your part!

> NOTE
> 
> With a normal modal dialog, if the user clicks the Cancel button, the changes are discarded and the dialog class data members remain unchanged. With a property sheet, however, the data members are updated if the user changes one page and then moves to another, even if the user exits by clicking the Cancel button.

What does the Apply button do? Nothing at all if you don't write some code. It won't even be enabled. To enable it for a given page, you must set the page's modified flag by calling _SetModified(TRUE)_ when you detect that the user has made changes on the page.

If you've enabled the Apply button, you can write a handler function for it in your page class by overriding the virtual _CPropertyPage::OnApply_ function. Don't try to understand property page message processing in the context of normal modal dialogs; it's quite different. The framework gets a WM_NOTIFY message for all button clicks. It calls the DDX code for the page if the OK or Apply button was clicked. It then calls the virtual _OnApply_ functions for all the pages, and it resets the modified flag, which disables the Apply button. Don't forget that the DDX code has already been called to update the data members in all pages, so you need to override _OnApply_ in only one page class.

What you put in your _OnApply_ function is your business, but one option is to send a user-defined message to the object that created the property sheet. The message handler can get the property page data members and process them. Meanwhile, the property sheet stays on the screen.
________________________________________________________________________
6.1.9. - [The EX13A Example Revisited](invcpp5/ch13j.htm)
----------------------------------------------------
 The EX13A Example Revisited 

The EX13A Example Revisited
===========================

Now we'll add a property sheet to EX13A that allows the user to change the rich edit control's font characteristics. Of course, we could have used the standard MFC _CFontDialog_ function, but then you wouldn't have learned how to create property sheets. Figure 13-5 shows the property sheet that you'll build as you continue with EX13A.

![](c:/dl/books/windows/msvc5th/invcpp5/images/F13OG05.GIF)

**Figure 13-5.** _The property sheet from EX13A._

If you haven't built EX13A, follow the instructions that begin under the EX13A Example to build it. If you already have EX13A working with the Transfer menu commands, just continue on with these steps:

2.  **Use the resource editor to edit the application's main menu.** Click on the ResourceView tab in the Workspace window. Edit the _IDR_MAINFRAME_ menu resource to add a Format menu that looks like this.  
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G13OG04.GIF)
    
    Use the following command IDs for the new Format menu items.
    
    **Caption**
    
    **Command ID**
    
    &Default
    
    _ID_FORMAT_DEFAULT_
    
    &Selection
    
    _ID_FORMAT_SELECTION_
    
    Add appropriate prompt strings for the two menu items.
    

3.  **Use ClassWizard to add the view class command and update command UI message handlers.** Select the _CEx13aView_ class, and then add the following member functions.
    
    **Object ID**
    
    **Message**
    
    **Member Function**
    
    _ID_FORMAT_DEFAULT_
    
    COMMAND
    
    _OnFormatDefault_
    
    _ID_FORMAT_SELECTION_
    
    COMMAND
    
    _OnFormatSelection_
    
    _ID_FORMAT_SELECTION_
    
    UPDATE_COMMAND_UI
    
    _OnUpdateFormatSelection_
    

4.  **Use the resource editor to add four property page dialog templates.** The templates are shown here with their associated IDs.  
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G13OG05x.gif)]
    
    Use the IDs in the table below for the controls in the dialogs. Set the Auto Buddy and the Set Buddy Integer properties for the spin button control, and set the Group property for the _IDC_FONT_ and _IDC_COLOR_ radio buttons. Set the minimum value of _IDC_FONTSIZE_ to _8_ and its maximum value to _24_.
    
    Use ClassWizard to create the classes _CPage1_, _CPage2_, _CPage3_, and _CPage4_. In each case, select _CPropertyPage_ as the base class. Click the Change button in ClassWizard's New Class dialog to generate the code for all these classes in the files Property.h and Property.cpp. Then add the data members shown here.
    
    **Dialog**
    
    **Control**
    
    **ID**
    
    **Type**
    
    **Data Member**
    
    _IDD_PAGE1_
    
    First radio button
    
    _IDC_FONT_
    
    _int_
    
    _m_nFont_
    
    _IDD_PAGE2_
    
    Bold check box
    
    _IDC_BOLD_
    
    _BOOL_
    
    _m_bBold_
    
    _IDD_PAGE2_
    
    Italic check box
    
    _IDC_ITALIC_
    
    _BOOL_
    
    _m_bItalic_
    
    _IDD_PAGE2_
    
    Underline check box
    
    _IDC_UNDERLINE_
    
    _BOOL_
    
    _m_bUnderline_
    
    _IDD_PAGE3_
    
    First radio button
    
    _IDC_COLOR_
    
    _int_
    
    _m_nColor_
    
    _IDD_PAGE4_
    
    Edit control
    
    _IDC_FONTSIZE_
    
    _int_
    
    _m_nFontSize_
    
    _IDD_PAGE4_
    
    Spin button control
    
    _IDC_SPIN1_
    
     
    
     
    
    Finally, use ClassWizard to add an _OnInitDialog_ message handler function for _CPage4_.
    

5.  **Use ClassWizard to create a class derived from _CPropertySheet_.** Choose the name _CFontSheet_. Generate the code in the files Property.h and Property.cpp, the same files you used for the property page classes. Figure 13-6 shows these files with the added code in boldface.
    
    **PROPERTY.H**
    
    #if !defined(AFX_PROPERTY_H__CD702F99_7495_11D0_8FDC_00C04FC2A0C2__INCLUDED_)
    #define AFX_PROPERTY_H_ _CD702F99_7495_11D0_8FDC_00C04FC2A0C2__INCLUDED_
    
    #if _MSC_VER > 1000
    #pragma once
    #endif // _MSC_VER > 1000
    // Property.h : header file
    //
    
    **#define WM_USERAPPLY WM_USER + 5
    extern CView\* g_pView;**
    
    ////////////////////////////////////////////////////////////////////
    // CPage1 dialog
    
    class CPage1 : public CPropertyPage
    {
        DECLARE_DYNCREATE(CPage1)
    
    // Construction
    public:
        CPage1();
        ~CPage1();
    
    // Dialog Data
        //{{AFX_DATA(CPage1)
        enum { IDD = IDD_PAGE1 };
        int     m_nFont;
        //}}AFX_DATA
    
    
    // Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CPage1)
        protected:
        virtual void DoDataExchange(CDataExchange\* pDX); // DDX/DDV
                                                          // support
        //}}AFX_VIRTUAL
        **virtual BOOL OnApply();
        virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);**
    
    // Implementation
    protected:
        // Generated message map functions
        //{{AFX_MSG(CPage1)
            // NOTE: the ClassWizard will add member functions here
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
    
    };
    
    ////////////////////////////////////////////////////////////////////
    // CPage2 dialog
    
    class CPage2 : public CPropertyPage
    {
        DECLARE_DYNCREATE(CPage2)
    
    // Construction
    public:
        CPage2();
        ~CPage2();
    
    // Dialog Data
        //{{AFX_DATA(CPage2)
        enum { IDD = IDD_PAGE2 };
        BOOL    m_bBold;
        BOOL    m_bItalic;
        BOOL    m_bUnderline;
        //}}AFX_DATA
    
    
    // Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CPage2)
        protected:
        virtual void DoDataExchange(CDataExchange\* pDX); // DDX/DDV
                                                          // support
        //}}AFX_VIRTUAL
        **virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);**
    
    // Implementation
    protected:
        // Generated message map functions
        //{{AFX_MSG(CPage2)
            // NOTE: the ClassWizard will add member functions here
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
    
    };
    
    ////////////////////////////////////////////////////////////////////
    // CPage3 dialog
    
    class CPage3 : public CPropertyPage
    {
        DECLARE_DYNCREATE(CPage3)
    
    // Construction
    public:
        CPage3();
        ~CPage3();
    
    // Dialog Data
        //{{AFX_DATA(CPage3)
        enum { IDD = IDD_PAGE3 };
        int     m_nColor;
        //}}AFX_DATA
    
    
    // Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CPage3)
        protected:
        virtual void DoDataExchange(CDataExchange\* pDX); // DDX/DDV
                                                          // support
        //}}AFX_VIRTUAL
        **virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);**
    
    // Implementation
    protected:
        // Generated message map functions
        //{{AFX_MSG(CPage3)
            // NOTE: the ClassWizard will add member functions here
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
    
    };
    
    ////////////////////////////////////////////////////////////////////
    // CPage4 dialog
    
    class CPage4 : public CPropertyPage
    {
        DECLARE_DYNCREATE(CPage4)
    
    // Construction
    public:
        CPage4();
        ~CPage4();
    
    // Dialog Data
        //{{AFX_DATA(CPage4)
        enum { IDD = IDD_PAGE4 };
        int     m_nFontSize;
        //}}AFX_DATA
    
    // Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CPage4)
        protected:
        virtual void DoDataExchange(CDataExchange\* pDX); // DDX/DDV
                                                         // support
        //}}AFX_VIRTUAL
        **virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);**
    
    // Implementation
    protected:
        // Generated message map functions
        //{{AFX_MSG(CPage4)
        virtual BOOL OnInitDialog();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
    
    };
    
    ////////////////////////////////////////////////////////////////////
    // CFontSheet
    
    class CFontSheet : public CPropertySheet
    {
        DECLARE_DYNAMIC(CFontSheet)
    
    **public:
        CPage1 m_page1;
        CPage2 m_page2;
        CPage3 m_page3;
        CPage4 m_page4;**
    
    // Construction
    public:
        CFontSheet(UINT nIDCaption, CWnd\* pParentWnd = NULL,
                   UINT iSelectPage = 0);
        CFontSheet(LPCTSTR pszCaption, CWnd\* pParentWnd = NULL,
                   UINT iSelectPage = 0);
    
    // Attributes
    public:
    
    // Operations
    public:
    // Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CFontSheet)
        //}}AFX_VIRTUAL
    
    // Implementation
    public:
        virtual ~CFontSheet();
    
        // Generated message map functions
    protected:
        //{{AFX_MSG(CFontSheet)
            // NOTE - the ClassWizard will add and remove member functions here.
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
    };
    
    ////////////////////////////////////////////////////////////////////
    //{{AFX_INSERT_LOCATION}}
    // Microsoft Visual C++ will insert additional declarations
    //  immediately before the previous line.
    
    #endif // !defined(AFX_PROPERTY_H_ _CD702F99_7495_11D0_8FDC_00C04FC2A0C2__INCLUDED_)
    
    **PROPERTY.CPP**
    
    // Property.cpp : implementation file
    //
    
    #include "stdafx.h"
    #include "ex13a.h"
    #include "Property.h"
    
    #ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
    static char THIS_FILE[] = __FILE__;
    #endif
    
    **CView\* g_pView;**
    
    ////////////////////////////////////////////////////////////////////
    // CPage1 property page
    
    IMPLEMENT_DYNCREATE(CPage1, CPropertyPage)
    
    CPage1::CPage1() : CPropertyPage(CPage1::IDD)
    {
        //{{AFX_DATA_INIT(CPage1)
        m_nFont = -1;
        //}}AFX_DATA_INIT
    }
    
    CPage1::~CPage1()
    {
    }
    
    **BOOL CPage1::OnApply()
    {
        TRACE("CPage1::OnApply\n");
        g_pView->SendMessage(WM_USERAPPLY);
        return TRUE;
    }
    
    BOOL CPage1::OnCommand(WPARAM wParam, LPARAM lParam)
    {
        SetModified(TRUE);
        return CPropertyPage::OnCommand(wParam, lParam);
    }**
    
    void CPage1::DoDataExchange(CDataExchange\* pDX)
    {
        **TRACE("Entering CPage1::DoDataExchange -- %d\n",
              pDX->m_bSaveAndValidate);**
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CPage1)
        DDX_Radio(pDX, IDC_FONT, m_nFont);
        //}}AFX_DATA_MAP
    }
    
    
    BEGIN_MESSAGE_MAP(CPage1, CPropertyPage)
        //{{AFX_MSG_MAP(CPage1)
            // NOTE: the ClassWizard will add message map macros here
        //}}AFX_MSG_MAP
    END_MESSAGE_MAP()
    
    ////////////////////////////////////////////////////////////////////
    // CPage1 message handlers
    
    ////////////////////////////////////////////////////////////////////
    // CPage2 property page
    
    IMPLEMENT_DYNCREATE(CPage2, CPropertyPage)
    
    CPage2::CPage2() : CPropertyPage(CPage2::IDD)
    {
        //{{AFX_DATA_INIT(CPage2)
        m_bBold = FALSE;
        m_bItalic = FALSE;
        m_bUnderline = FALSE;
        //}}AFX_DATA_INIT
    }
    
    CPage2::~CPage2()
    {
    }
    
    **BOOL CPage2::OnCommand(WPARAM wParam, LPARAM lParam)
    {
        SetModified(TRUE);
        return CPropertyPage::OnCommand(wParam, lParam);
    }**
    
    void CPage2::DoDataExchange(CDataExchange\* pDX)
    {
        **TRACE("Entering CPage2::DoDataExchange -- %d\n",
              pDX->m_bSaveAndValidate);**
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CPage2)
        DDX_Check(pDX, IDC_BOLD, m_bBold);
        DDX_Check(pDX, IDC_ITALIC, m_bItalic);
        DDX_Check(pDX, IDC_UNDERLINE, m_bUnderline);
        //}}AFX_DATA_MAP
    }
    
    
    BEGIN_MESSAGE_MAP(CPage2, CPropertyPage)
        //{{AFX_MSG_MAP(CPage2)
            // NOTE: the ClassWizard will add message map macros here
        //}}AFX_MSG_MAP
    END_MESSAGE_MAP()
    
    ////////////////////////////////////////////////////////////////////
    // CPage2 message handlers
    
    ////////////////////////////////////////////////////////////////////
    // CPage3 property page
    
    IMPLEMENT_DYNCREATE(CPage3, CPropertyPage)
    
    CPage3::CPage3() : CPropertyPage(CPage3::IDD)
    {
        //{{AFX_DATA_INIT(CPage3)
        m_nColor = -1;
        //}}AFX_DATA_INIT
    }
    
    CPage3::~CPage3()
    {
    }
    
    **BOOL CPage3::OnCommand(WPARAM wParam, LPARAM lParam)
    {
        SetModified(TRUE);
        return CPropertyPage::OnCommand(wParam, lParam);
    }**
    
    void CPage3::DoDataExchange(CDataExchange\* pDX)
    {
        **TRACE("Entering CPage3::DoDataExchange -- %d\n",
              pDX->m_bSaveAndValidate);**
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CPage3)
        DDX_Radio(pDX, IDC_COLOR, m_nColor);
        //}}AFX_DATA_MAP
    }
    
    
    BEGIN_MESSAGE_MAP(CPage3, CPropertyPage)
        //{{AFX_MSG_MAP(CPage3)
            // NOTE: the ClassWizard will add message map macros here
        //}}AFX_MSG_MAP
    END_MESSAGE_MAP()
    
    ////////////////////////////////////////////////////////////////////
    // CPage3 message handlers
    
    ////////////////////////////////////////////////////////////////////
    // CPage4 property page
    
    IMPLEMENT_DYNCREATE(CPage4, CPropertyPage)
    
    CPage4::CPage4() : CPropertyPage(CPage4::IDD)
    {
        //{{AFX_DATA_INIT(CPage4)
        m_nFontSize = 0;
        //}}AFX_DATA_INIT
    }
    
    CPage4::~CPage4()
    {
    }
    
    **BOOL CPage4::OnCommand(WPARAM wParam, LPARAM lParam)
    {
        SetModified(TRUE);
        return CPropertyPage::OnCommand(wParam, lParam);
    }**
    
    void CPage4::DoDataExchange(CDataExchange\* pDX)
    {
        **TRACE("Entering CPage4::DoDataExchange -- %d\n",
              pDX->m_bSaveAndValidate);**
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CPage4)
        DDX_Text(pDX, IDC_FONTSIZE, m_nFontSize);
        DDV_MinMaxInt(pDX, m_nFontSize, 8, 24);
        //}}AFX_DATA_MAP
    }
    
    
    BEGIN_MESSAGE_MAP(CPage4, CPropertyPage)
        //{{AFX_MSG_MAP(CPage4)
        //}}AFX_MSG_MAP
    END_MESSAGE_MAP()
    
    ////////////////////////////////////////////////////////////////////
    // CPage4 message handlers
    
    BOOL CPage4::OnInitDialog() 
    {
        CPropertyPage::OnInitDialog();
        **((CSpinButtonCtrl\*) GetDlgItem(IDC_SPIN1))->SetRange(8, 24);**
        return TRUE;  // return TRUE unless you set the focus to a control
                      //  EXCEPTION: OCX Property Pages should return FALSE
    }
    
    ////////////////////////////////////////////////////////////////////
    // CFontSheet
    
    IMPLEMENT_DYNAMIC(CFontSheet, CPropertySheet)
    
    CFontSheet::CFontSheet(UINT nIDCaption, CWnd\* pParentWnd,
                           UINT iSelectPage)
        :CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
    {
    }
    
    CFontSheet::CFontSheet(LPCTSTR pszCaption, CWnd\* pParentWnd,
                           UINT iSelectPage)
        :CPropertySheet(pszCaption, pParentWnd, iSelectPage)
    {
        **AddPage(&m_page1);
        AddPage(&m_page2);
        AddPage(&m_page3);
        AddPage(&m_page4);**
    }
    
    CFontSheet::~CFontSheet()
    {
    }
    
    
    BEGIN_MESSAGE_MAP(CFontSheet, CPropertySheet)
        //{{AFX_MSG_MAP(CFontSheet)
            // NOTE - the ClassWizard will add and remove mapping macros here.
        //}}AFX_MSG_MAP
    END_MESSAGE_MAP()
    
    ////////////////////////////////////////////////////////////////////
    // CFontSheet message handlers
    
    **Figure 13-6.** _The EX13A Header and implementation file listings for the property page and property sheet classes._
    
6.  **Add two data members and two prototypes to the _CEx13aView_ class.** If you use ClassView for the data members, the _#include_ for Property.h will be added automatically.
    
    **private:
        CFontSheet m_sh;
        BOOL m_bDefault; // TRUE default format, FALSE selection**
    
    Now add the prototype for the private function _Format_:
    
    **void Format(CHARFORMAT &cf);**
    
    Insert the prototype for the protected function _OnUserApply_ before the _DECLARE_MESSAGE_MAP_ macro.
    
    **afx_msg LRESULT OnUserApply(WPARAM wParam, LPARAM lParam);**
    
7.  **Edit and add code in the file ex13aView.cpp.** Map the user-defined WM_USERAPPLY message, as shown here:
    
    **ON_MESSAGE(WM_USERAPPLY, OnUserApply)**
    
    Add the following lines to the _OnCreate_ function, just before the _return 0_ statement:
    
    **CHARFORMAT cf;
    Format(cf);
    m_rich.SetDefaultCharFormat(cf);**
    
    Edit the view constructor to set default values for the property sheet data members, as follows:
    
    CEx13aView::CEx13aView() **: m_sh("")**
    {
        **m_sh.m_page1.m_nFont = 0;
        m_sh.m_page2.m_bBold = FALSE;
        m_sh.m_page2.m_bItalic = FALSE;
        m_sh.m_page2.m_bUnderline = FALSE;
        m_sh.m_page3.m_nColor = 0;
        m_sh.m_page4.m_nFontSize = 12;
        g_pView = this;
        m_bDefault = TRUE;**
    }
    
    Edit the format command handlers, as shown here:
    
    void CEx13aView::OnFormatDefault()
    {
        **m_sh.SetTitle("Default Format");
        m_bDefault = TRUE;
        m_sh.DoModal();**
    }
    
    void CEx13aView::OnFormatSelection()
    {
        **m_sh.SetTitle("Selection Format");
        m_bDefault = FALSE;
        m_sh.DoModal();**
    }
    
    void CEx13aView::OnUpdateFormatSelection(CCmdUI\* pCmdUI)
    {
        **long nStart, nEnd;
        m_rich.GetSel(nStart, nEnd);
        pCmdUI->Enable(nStart != nEnd);**
    }
    
    Add the following handler for the user-defined WM_USERAPPLY message:
    
    **LRESULT CEx13aView::OnUserApply(WPARAM wParam, LPARAM lParam)
    {
        TRACE("CEx13aView::OnUserApply -- wParam = %x\n", wParam);
        CHARFORMAT cf;
        Format(cf);
        if (m_bDefault) {
            m_rich.SetDefaultCharFormat(cf);
        }
        else {
            m_rich.SetSelectionCharFormat(cf);
        }
        return 0;
    }**
    
    Add the _Format_ helper function, as shown below, to set a _CHARFORMAT_ structure based on the values of the property sheet data members.
    
    **void CEx13aView::Format(CHARFORMAT& cf)
    {
        cf.cbSize = sizeof(CHARFORMAT);
        cf.dwMask = CFM_BOLD | CFM_COLOR | CFM_FACE |
                    CFM_ITALIC | CFM_SIZE | CFM_UNDERLINE;
        cf.dwEffects = (m_sh.m_page2.m_bBold ? CFE_BOLD : 0) |
                       (m_sh.m_page2.m_bItalic ? CFE_ITALIC : 0) |
                       (m_sh.m_page2.m_bUnderline ? CFE_UNDERLINE : 0);
        cf.yHeight = m_sh.m_page4.m_nFontSize \* 20;
        switch(m_sh.m_page3.m_nColor) {
        case -1:
        case 0:
            cf.crTextColor = RGB(0, 0, 0);
            break;
        case 1:
            cf.crTextColor = RGB(255, 0, 0);
            break;
        case 2:
            cf.crTextColor = RGB(0, 255, 0);
            break;
        }
        switch(m_sh.m_page1.m_nFont) {
        case -1:
        case 0:
            strcpy(cf.szFaceName, "Times New Roman");
            break;
        case 1:
            strcpy(cf.szFaceName, "Arial");
            break;
        case 2:
            strcpy(cf.szFaceName, "Courier New");
            break;
        }
        cf.bCharSet = 0;
        cf.bPitchAndFamily = 0;
    }**
    
8.  **Build and test the enhanced EX13A application.** Type some text, and then choose Default from the Format menu. Observe the _TRACE_ messages in the Debug window as you click on property sheet tabs and click the Apply button. Try highlighting some text and then formatting the selection.
    
    Apply Button Processing
    -----------------------
    
    You might be curious about the way the property sheet classes process the Apply button. In all the page classes, the overridden _OnCommand_ functions enable the Apply button whenever a control sends a message to the page. This works fine for pages 1 through 3 in EX13A, but for page 4, _OnCommand_ is called during the initial conversation between the spin button control and its buddy.
    
    The _OnApply_ virtual override in the _CPage1_ class sends a user-defined message to the view. The function finds the view in an expedient way—by using a global variable set by the view class. A better approach would be to pass the view pointer to the sheet constructor and then to the page constructor.
    
    The view class calls the property sheet's _DoModal_ function for both default formatting and selection formatting. It sets the _m_bDefault_ flag to indicate the mode. We don't need to check the return from _DoModal_ because the user-defined message is sent for both the OK button and the Apply button. If the user clicks Cancel, no message is sent.
________________________________________________________________________
6.1.10. - [The CMenu Class](invcpp5/ch13k.htm)
----------------------------------------------------
 The CMenu Class 

The _CMenu_ Class
=================

Up to this point, the application framework and the menu editor have shielded you from the menu class, _CMenu_. A _CMenu_ object can represent each Windows menu, including the top-level menu items and associated pop-up menus. Most of the time, the menu's resource is directly attached to a frame window when the window's _Create_ or _LoadFrame_ function is called, and a _CMenu_ object is never explicitly constructed. The _CWnd_ member function _GetMenu_ returns a temporary _CMenu_ pointer. Once you have this pointer, you can freely access and update the menu object.

Suppose you want to switch menus after the application starts. _IDR_MAINFRAME_ always identifies the initial menu in the resource script. If you want a second menu, you use the menu editor to create a menu resource with your own ID. Then, in your program, you construct a _CMenu_ object, use the _CMenu::LoadMenu_ function to load the menu from the resource, and call the _CWnd::SetMenu_ function to attach the new menu to the frame window. Then you call the _Detach_ member function to separate the object's _HMENU_ handle so that the menu is not destroyed when the _CMenu_ object goes out of scope.

You can use a resource to define a menu, and then your program can modify the menu items at runtime. If necessary, however, you can build the whole menu at runtime, without benefit of a resource. In either case, you can use _CMenu_ member functions such as _ModifyMenu_, _InsertMenu_, and _DeleteMenu_. Each of these functions operates on an individual menu item identified by ID or by a relative position index.

A menu object is actually composed of a nested structure of submenus. You can use the _GetSubMenu_ member function to get a _CMenu_ pointer to a pop-up menu contained in the main _CMenu_ object. The _CMenu::GetMenuString_ function returns the menu item string corresponding to either a zero-based index or a command ID. If you use the command ID option, the menu is searched, together with any submenus.
________________________________________________________________________
6.1.11. - [Creating Floating Pop-Up Menus](invcpp5/ch13l.htm)
----------------------------------------------------
 Creating Floating Pop-Up Menus 

Creating Floating Pop-Up Menus
==============================

Floating pop-up menus are one of the latest trends in user interface design. The user presses the right mouse button and a floating menu offers choices that relate to the current selection. It's easy to create these menus using the resource editor and the MFC library _CMenu::TrackPopupMenu_ function. Just follow these steps:

1.  Use the menu editor to insert a new, empty menu in your project's resource file.
    
2.  Type some characters in the left top-level item, and then add your menu items in the resulting pop-up menu.
    
3.  Use ClassWizard to add a WM_CONTEXTMENU message handler in your view class or in some other window class that receives mouse-click messages. Code the handler as shown below.
    
    void CMyView::OnContextMenu(CWnd \*pWnd, CPoint point)
    {
        CMenu menu;
        menu.LoadMenu(IDR_MYFLOATINGMENU);
        menu.GetSubMenu(0)
            ->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON,
            point.x, point.y, this);
    }
    
    You can use ClassWizard to map the floating menu's command IDs the same way you would map the frame menu's command IDs.
________________________________________________________________________
6.1.12. - [Extended Command Processing](invcpp5/ch13m.htm)
----------------------------------------------------
 Extended Command Processing 

Extended Command Processing
===========================

In addition to the _ON_COMMAND_ message map macro, the MFC library provides an extended variation, _ON_COMMAND_EX_. The extended command message map macro provides two features not supplied by the regular command message—a command ID function parameter and the ability to reject a command at runtime, sending it to the next object in the command route. If the extended command handler returns _TRUE_, the command goes no further; if it returns _FALSE_, the application framework looks for another command handler.

The command ID parameter is useful when you want one function to handle several related command messages. You might invent some of your own uses for the rejection feature.

ClassWizard can't help you with extended command handlers, so you'll have to do the coding yourself, outside the _AFX_MSG_MAP_ brackets. Assume that _IDM_ZOOM_1_ and _IDM_ZOOM_2_ are related command IDs defined in resource.h. Here's the class code you'll need to process both messages with one function, _OnZoom_:

BEGIN_MESSAGE_MAP(CMyView, CView)
    ON_COMMAND_EX(IDM_ZOOM_1, OnZoom)
    ON_COMMAND_EX(IDM_ZOOM_2, OnZoom)
END_MESSAGE_MAP()

BOOL CMyView::OnZoom(UINT nID)
{
    if (nID == IDM_ZOOM_1) {
        // code specific to first zoom command
    }
    else {
        // code specific to second zoom command
    }
    // code common to both commands
    return TRUE; // Command goes no further
}

Here's the function prototype:

afx_msg BOOL OnZoom(UINT nID);

Other MFC message map macros are helpful for processing ranges of commands, as you might see in dynamic menu applications. These macros include

> _ON_COMMAND_RANGE_
> 
> _ON_COMMAND_EX_RANGE_
> 
> _ON_UPDATE_COMMAND_UI_RANGE_

If the values of _IDM_ZOOM_1_ and _IDM_ZOOM_2_ were consecutive, you could rewrite the _CMyView_ message map as follows:

BEGIN_MESSAGE_MAP(CMyView, CView)
    ON_COMMAND_EX_RANGE(IDM_ZOOM_1, IDM_ZOOM_2, OnZoom)
END_MESSAGE_MAP()

Now _OnZoom_ is called for both menu choices, and the handler can determine the choice from the integer parameter.
________________________________________________________________________
6.2. - [Chapter 14 -- Toolbars and Status Bars](invcpp5/ch14a.htm)
----------------------------------------------------
 Chapter 14 -- Toolbars and Status Bars  Chapter 14

Toolbars and Status Bars
========================

All the Microsoft Visual C++ examples up to this point have included toolbars and status bars. AppWizard generated the code that initialized these application framework elements as long as you accepted the AppWizard default options Docking Toolbar and Initial Status Bar. The default toolbar provides graphics equivalents for many of the standard application framework menu selections, and the default status bar displays menu prompts together with the keyboard state indicators CAP, NUM, and SCRL.

This chapter shows you how to customize the toolbar and the status bar for your application. You'll be able to add your own toolbar graphical buttons and control their appearance. You'll also learn how to disable the status bar's normal display of menu prompts and keyboard indicators. This allows your application to take over the status bar for its own use.
________________________________________________________________________
6.2.1. - [Control Bars and the Application Framework](invcpp5/ch14b.htm)
----------------------------------------------------
 Control Bars and the Application Framework 

Control Bars and the Application Framework
==========================================

The toolbar is an object of class _CToolBar_, and the status bar is an object of class _CStatusBar_. Both these classes are derived from class _CControlBar_, which is itself derived from _CWnd_. The _CControlBar_ class supports control bar windows that are positioned inside frame windows. These control bar windows resize and reposition themselves as the parent frame moves and changes size. The application framework takes care of the construction, window creation, and destruction of the control bar objects. AppWizard generates control bar code for its derived frame class located in the files MainFrm.cpp and MainFrm.h.

In a typical SDI application, a _CToolBar_ object occupies the top portion of the _CMainFrame_ client area and a _CStatusBar_ object occupies the bottom portion. The view occupies the remaining (middle) part of the frame.

Beginning with Microsoft Foundation Class (MFC) Library version 4.0, the toolbar has been built around the toolbar common control that first became available with Microsoft Windows 95. Thus the toolbar is fully dockable. The programming interface is much the same as it was in earlier versions of the MFC library, however. The button images are easy to work with because a special resource type is supported by the resource editor. The old global _buttons_ array is gone.

Assuming that AppWizard has generated the control bar code for your application, the user can enable and disable the toolbar and the status bar individually by choosing commands from the application's View menu. When a control bar is disabled, it disappears and the view size is recalculated. Apart from the common behavior just described, toolbar and status bar objects operate independently of each other and have rather different characteristics.

In Visual C++ 6.0, a new MFC toolbar was introduced called the rebar. The rebar is based on the controls that come as part of Microsoft Internet Explorer 4.0 and provides a Microsoft Internet Explorer-style "sliding" toolbar. We will cover this later in this chapter.
________________________________________________________________________
6.2.2. - [The Toolbar](invcpp5/ch14c.htm)
----------------------------------------------------
 The Toolbar 

The Toolbar
===========

A toolbar consists of a number of horizontally (or vertically) arranged graphical buttons that might be clustered in groups. The programming interface determines the grouping. The graphical images for the buttons are stored in a single bitmap that is attached to the application's resource file. When a button is clicked, it sends a command message, as do menus and keyboard accelerators. An update command UI message handler is used to update the button's state, which in turn is used by the application framework to modify the button's graphical image.

The Toolbar Bitmap
------------------

Each button on a toolbar appears to have its own bitmap, but actually a single bitmap serves the entire toolbar. The toolbar bitmap has a tile, 15 pixels high and 16 pixels wide, for each button. The application framework supplies the button borders, and it modifies those borders, together with the button's bitmap tile color, to reflect the current button state. Figure 14-1 shows the relationship between the toolbar bitmap and the corresponding toolbar.

![](c:/dl/books/windows/msvc5th/invcpp5/images/F14OG01.GIF)

**Figure 14-1.** _A toolbar bitmap and an actual toolbar._

The toolbar bitmap is stored in the file Toolbar.bmp in the application's \res subdirectory. The bitmap is identified in the resource script (RC) file as _IDR_MAINFRAME_. You don't edit the toolbar bitmap directly; instead you use Visual C++'s special toolbar-editing facility.

Button States
-------------

Each button can assume the following states.

**State**

**Meaning**

0

Normal, unpressed state.

_TBSTATE_CHECKED_

Checked (down) state.

_TBSTATE_ENABLED_

Available for use. Button is grayed and unavailable if this state is not set.

_TBSTATE_HIDDEN_

Not visible.

_TBSTATE_INDETERMINATE_

Grayed.

_TBSTATE_PRESSED_

Currently selected (pressed) with the mouse.

_TBSTATE_WRAP_

Line break follows the button.

A button can behave in either of two ways: it can be a pushbutton, which is down only when currently selected by the mouse, or it can be a check box button, which can be toggled up and down with mouse clicks. All buttons in the standard application framework toolbar are pushbuttons.

The Toolbar and Command Messages
--------------------------------

When the user clicks a toolbar button with the mouse, a command message is generated. This message is routed like the menu command messages you saw in [Chapter 13](ch13a.htm). Most of the time, a toolbar button matches a menu option. In the standard application framework toolbar, for example, the Disk button is equivalent to the File Save menu option because both generate the _ID_FILE_SAVE_ command. The object receiving the command message doesn't need to know whether the message was produced by a click on the toolbar or by a selection from the menu.

A toolbar button doesn't have to mirror a menu item. If you don't provide the equivalent menu item, however, you are advised to define a keyboard accelerator for the button so that the user can activate the command with the keyboard or with a keyboard macro product for Microsoft Windows. You can use ClassWizard to define command and update command UI message handlers for toolbar buttons, whether or not they have corresponding menu items.

A toolbar has an associated bitmap resource and, in the RC file, a companion TOOLBAR resource that defines the menu commands associated with the buttons. Both the bitmap and the TOOLBAR resource have the same ID, typically _IDR_MAINFRAME_. The text of the AppWizard-generated TOOLBAR resource is shown below:

IDR_MAINFRAME TOOLBAR DISCARDABLE  16, 15
BEGIN
    BUTTON      ID_FILE_NEW
    BUTTON      ID_FILE_OPEN
    BUTTON      ID_FILE_SAVE
        SEPARATOR
    BUTTON      ID_EDIT_CUT
    BUTTON      ID_EDIT_COPY
    BUTTON      ID_EDIT_PASTE
        SEPARATOR
    BUTTON      ID_FILE_PRINT
    BUTTON      ID_APP_ABOUT
END

The _SEPARATOR_ constants serve to group the buttons by inserting corresponding spaces on the toolbar. If the number of toolbar bitmap panes exceeds the number of resource elements (excluding separators), the extra buttons are not displayed.

When you edit the toolbar with the resource editor, you're editing both the bitmap resource and the TOOLBAR resource. You select a button image, and then you double-click on the left panel to edit the properties, including the button's ID.

Toolbar Update Command UI Message Handlers
------------------------------------------

Remember from [Chapter 13](ch13a.htm) that update command UI message handlers are used to disable or add check marks to menu items. These same message handlers apply to toolbar buttons. If your update command UI message handler calls the _CCmdUI::Enable_ member function with a _FALSE_ parameter, the corresponding button is set to the disabled (grayed) state and no longer responds to mouse clicks.

On a menu item, the _CCmdUI::SetCheck_ member function displays a check mark. For the toolbar, the _SetCheck_ function implements check box buttons. If the update command UI message handler calls _SetCheck_ with a parameter value of 1, the button is toggled to the down (checked) state; if the parameter is 0, the button is toggled up (unchecked).

> NOTE
> 
> If the _SetCheck_ parameter value is 2, the button is set to the indeterminate state. This state looks like the disabled state, but the button is still active and its color is a bit brighter.

The update command UI message handlers for a pop-up menu are called only when the menu is painted. The toolbar is displayed all the time, so when are its update command UI message handlers called? They're called during the application's idle processing, so the buttons can be updated continuously. If the same handler covers a menu item and a toolbar button, it is called both during idle processing and when the pop-up menu is displayed.
________________________________________________________________________
6.2.3. - [ToolTips](invcpp5/ch14d.htm)
----------------------------------------------------
 ToolTips 

ToolTips
========

You've seen ToolTips in various Windows applications, including Visual C++. When the user positions the mouse on a toolbar button for a certain interval, text is displayed in a little ToolTip box next to the button. In [Chapter 13](ch13a.htm), you learned that menu items can have associated prompt strings, which are string resource elements with matching IDs. To create a ToolTip, you simply add the tip text to the end of the menu prompt, preceded by a newline (\n) character. The resource editor lets you edit the prompt string while you are editing the toolbar images. Just double-click in the left panel.
________________________________________________________________________
6.2.4. - [Locating the Main Frame Window](invcpp5/ch14e.htm)
----------------------------------------------------
 Locating the Main Frame Window 

Locating the Main Frame Window
==============================

The toolbar and status bar objects you'll be working with are attached to the application's main frame window, not to the view window. How does your view find its main frame window? In an SDI application, you can use the _CWnd::GetParentFrame_ function. Unfortunately, this function won't work in an MDI application because the view's parent frame is the MDI child frame, not the MDI frame window.

If you want your view class to work in both SDI and MDI applications, you must find the main frame window through the application object. The _AfxGetApp_ global function returns a pointer to the application object. You can use that pointer to get the _CWinApp_ data member _m_pMainWnd_. In an MDI application, AppWizard generates code that sets _m_pMainWnd_, but in an SDI application, the framework sets _m_pMainWnd_ during the view creation process. Once _m_pMainWnd_ is set, you can use it in a view class to get the frame's toolbar with statements such as this:

CMainFrame\* pFrame = (CMainFrame\*) AfxGetApp()->m_pMainWnd;
CToolBar\* pToolBar = &pFrame->m_wndToolBar;

> NOTE
> 
> You'll need to cast _m_pMainWnd_ from _CFrameWnd\*_ to _CMainFrame\*_ because _m_wndToolBar_ is a member of that derived class. You'll also have to make _m_wndToolBar_ public or make your class a friend of _CMainFrame_.

You can use similar logic to locate menu objects, status bar objects, and dialog objects.

> NOTE
> 
> In an SDI application, the value of _m_pMainWnd_ is not set when the view's _OnCreate_ message handler is called. If you need to access the main frame window in your _OnCreate_ function, you must use the _GetParentFrame_ function.
________________________________________________________________________
6.2.5. - [The EX14A Toolbar Example](invcpp5/ch14f.htm)
----------------------------------------------------
 The EX14A Toolbar Example 

The EX14A Toolbar Example
=========================

In this example, you will replace the standard application framework Edit Cut, Copy, and Paste toolbar buttons with three special-purpose buttons that control drawing in the view window. You will also construct a Draw menu with three corresponding menu items, as follows.

**Menu Item**

**Function**

Circle

Draws a circle in the view window

Square

Draws a square in the view window

Pattern

Toggles a diagonal line fill pattern for new squares and circles

The menu and toolbar options force the user to alternate between drawing circles and squares. After the user draws a circle, the Circle menu item and toolbar button are disabled; after the user draws a square, the Square menu item and toolbar button are disabled.

On the application's Draw menu, the Pattern menu item gets a check mark when pattern fill is active. On the toolbar, the corresponding button is a check box button that is down when pattern fill is active and up when it is not active.

Figure 14-2 shows the application in action. The user has just drawn a square with pattern fill. Notice the states of the three drawing buttons.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F14OG02x.gif)]

**Figure 14-2.** _The EX14A program in action._

The EX14A example introduces the resource editor for toolbars. You'll need to do very little C++ coding. Simply follow these steps:

2.  **Run AppWizard to generate \vcpp32\ex14a\ex14a.** Accept all default settings but two: select Single Document and deselect Printing and Print Preview. The options and the default class names are shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G14OG01x.GIF)
    

3.  **Use the resource editor to edit the application's main menu.** In ResourceView, double-click on _IDR_MAINFRAME_ under Menu. Edit the _IDR_MAINFRAME_ menu resource to create a menu that looks like this (which means you'll need to change the Edit menu).
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G14OG02.GIF)
    
    Use the following command IDs for your new menu items.
    
    **Menu**
    
    **Caption**
    
    **Command ID**
    
    Draw
    
    Circle
    
    _ID_DRAW_CIRCLE_
    
    Draw
    
    Square
    
    _ID_DRAW_SQUARE_
    
    Draw
    
    Pattern
    
    _ID_DRAW_PATTERN_
    
    When you're in the Menu Item Properties dialog, add some appropriate prompt strings and ToolTips (following a newline character). The string for _ID_DRAW_CIRCLE_ might be "Draw a circle\nCircle."
    

4.  **Use the resource editor to update the application's toolbar.** Edit the _IDR_MAINFRAME_ toolbar resource to create a bitmap that looks like this.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G14OG03.GIF)
    
    You'll be erasing the Edit Cut, Copy, and Paste tiles (fourth, fifth, and sixth from the left) and replacing them with new tiles. The toolbar editor is fairly intuitive. You simply move the buttons around with the mouse. The Delete key erases a button's pixels. If you want to eliminate a button entirely, just drag it off the toolbar. Use the rectangle and ellipse tools from the graphics toolbar. Experiment with different line widths. Save the resource file when you're done—just in case.
    
    Assign the IDs _ID_DRAW_CIRCLE_, _ID_DRAW_SQUARE_, and _ID_DRAW_PATTERN_ to the three new buttons.
    

5.  **Use ClassWizard to add _CEx14aView_ view class message handlers.** Add message handlers for the following command and update command UI messages, and accept the default function names shown in the following table.
    
    **Object ID**
    
    **Message**
    
    **Member Function**
    
    _ID_DRAW_CIRCLE_
    
    COMMAND
    
    _OnDrawCircle_
    
    _ID_DRAW_CIRCLE_
    
    UPDATE_COMMAND_UI
    
    _OnUpdateDrawCircle_
    
    _ID_DRAW_PATTERN_
    
    COMMAND
    
    _OnDrawPattern_
    
    _ID_DRAW_PATTERN_
    
    UPDATE_COMMAND_UI
    
    _OnUpdateDrawPattern_
    
    _ID_DRAW_SQUARE_
    
    COMMAND
    
    _OnDrawSquare_
    
    _ID_DRAW_SQUARE_
    
    UPDATE_COMMAND_UI
    
    _OnUpdateDrawSquare_
    

6.  **Add three data members to the _CEx14aView_ class.** Edit the file ex14aView.h, or use ClassView.
    
    **private:
        CRect m_rect;
        BOOL  m_bCircle;
        BOOL  m_bPattern;**
    
7.  **Edit the ex14aView.cpp file.** The _CEx14aView_ constructor simply initializes the class data members. Add the following boldface code:
    
    CEx14aView::CEx14aView() **: m_rect(0, 0, 100, 100)**
    {
        **m_bCircle = TRUE;
        m_bPattern = FALSE;**
    }
    
    The _OnDraw_ function draws an ellipse or a rectangle, depending on the value of the _m_bCircle_ flag. The brush is plain white or a diagonal pattern, depending on the value of _m_bPattern_.
    
    void CEx14aView::OnDraw(CDC\* pDC)
    {
        **CBrush brush(HS_BDIAGONAL, 0L); // brush with diagonal pattern
    
        if (m_bPattern) {
            pDC->SelectObject(&brush);
        }
        else {
            pDC->SelectStockObject(WHITE_BRUSH);
        }
        if (m_bCircle) {
            pDC->Ellipse(m_rect);
        }
        else {
            pDC->Rectangle(m_rect);
        }
        pDC->SelectStockObject(WHITE_BRUSH); // Deselects brush
                                             //  if selected**
    }
    
    The _OnDrawCircle_ function handles the _ID_DRAW_CIRCLE_ command message, and the _OnDrawSquare_ function handles the _ID_DRAW_SQUARE_ command message. These two functions move the drawing rectangle down and to the right, and then they invalidate the rectangle, causing the _OnDraw_ function to redraw it. The effect of this invalidation strategy is a diagonal cascading of alternating squares and circles. Also, the display is not buffered, so when the window is hidden or minimized, previously drawn items are not redisplayed.
    
    void CEx14aView::OnDrawCircle()
    {
        **m_bCircle = TRUE;
        m_rect += CPoint(25, 25);
        InvalidateRect(m_rect);**
    }
    
    void CEx14aView::OnDrawSquare()
    {
        **m_bCircle = FALSE;
        m_rect += CPoint(25, 25);
        InvalidateRect(m_rect);**
    }
    
    The following two update command UI functions alternately enable and disable the Circle and Square buttons and corresponding menu items. Only one item can be enabled at a time.
    
    void CEx14aView::OnUpdateDrawCircle(CCmdUI\* pCmdUI)
    {
        **pCmdUI->Enable(!m_bCircle);**
    }
    
    void CEx14aView::OnUpdateDrawSquare(CCmdUI\* pCmdUI)
    {
        **pCmdUI->Enable(m_bCircle);**
    }
    
    The _OnDrawPattern_ function toggles the state of the _m_bPattern_ flag.
    
    void CEx14aView::OnDrawPattern()
    {
        **m_bPattern ^= 1;**
    }
    
    The _OnUpdateDrawPattern_ function updates the Pattern button and menu item according to the state of the _m_bPattern_ flag. The toolbar button appears to move in and out, and the menu item check mark appears and disappears.
    
    void CEx14aView::OnUpdateDrawPattern(CCmdUI\* pCmdUI)
    {
        **pCmdUI->SetCheck(m_bPattern);**
    }
    
8.  **Build and test the EX14A application.** Notice the behavior of the toolbar buttons. Try the corresponding menu items, and notice that they too are enabled, disabled, and checked as the application's state changes. Observe the ToolTip when you stop the mouse pointer on one of the new toolbar buttons.
________________________________________________________________________
6.2.6. - [The Status Bar](invcpp5/ch14g.htm)
----------------------------------------------------
 The Status Bar 

The Status Bar
==============

The status bar window neither accepts user input nor generates command messages. Its job is simply to display text in panes under program control. The status bar supports two types of text panes—message line panes and status indicator panes. To use the status bar for application-specific data, you must first disable the standard status bar that displays the menu prompt and key-board status.

The Status Bar Definition
-------------------------

The static _indicators_ array that AppWizard generates in the MainFrm.cpp file defines the panes for the application's status bar. The constant _ID_SEPARATOR_ identifies a message line pane; the other constants are string resource IDs that identify indicator panes. Figure 14-3 shows the _indicators_ array and its relationship to the standard framework status bar.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F14OG03x.gif)]

**Figure 14-3.** _The status bar and the_ indicators _array._

The _CStatusBar::SetIndicators_ member function, called in the application's derived frame class, configures the status bar according to the contents of the _indicators_ array.

The Message Line
----------------

A message line pane displays a string that the program supplies dynamically. To set the value of the message line, you must first get access to the status bar object and then you must call the _CStatusBar::SetPaneText_ member function with a zero-based index parameter. Pane 0 is the leftmost pane, 1 is the next pane to the right, and so forth.

The following code fragment is part of a view class member function. Note that you must navigate up to the application object and then back down to the main frame window.

CMainFrame\* pFrame = (CMainFrame\*) AfxGetApp()->m_pMainWnd;
CStatusBar\* pStatus = &pFrame->m_wndStatusBar;
pStatus->SetPaneText(0, "message line for first pane");

Normally, the length of a message line pane is exactly one-fourth the width of the display. If, however, the message line is the first (index 0) pane, it is a stretchy pane without a beveled border. Its minimum length is one-fourth the display width, and it expands if room is available in the status bar.

The Status Indicator
--------------------

A status indicator pane is linked to a single resource-supplied string that is displayed or hidden by logic in an associated update command UI message handler function. An indicator is identified by a string resource ID, and that same ID is used to route update command UI messages. The Caps Lock indicator is handled in the frame class by a message map entry and a handler function equivalent to those shown below. The _Enable_ function turns on the indicator if the Caps Lock mode is set.

ON_UPDATE_COMMAND_UI(ID_INDICATOR_CAPS, OnUpdateKeyCapsLock)

void CMainFrame::OnUpdateKeyCapsLock(CCmdUI\* pCmdUI)
{
    pCmdUI->Enable(::GetKeyState(VK_CAPITAL) & 1);
}

The status bar update command UI functions are called during idle processing so that the status bar is updated whenever your application receives messages.

The length of a status indicator pane is the exact length of the corresponding resource string.

Taking Control of the Status Bar
--------------------------------

In the standard application framework implementation, the status bar has the child window ID _AFX_IDW_STATUS_BAR_. The application framework looks for this ID when it wants to display a menu prompt. The update command UI handlers for the keyboard state indicators, embedded in the frame window base class, are linked to the following string IDs: _ID_INDICATOR_CAPS_, _ID_INDICATOR_NUM_, and _ID_INDICATOR_SCRL_. To take control of the status bar, you must use a different child window ID and you must use different indicator ID constants.

> NOTE
> 
> The only reason to change the status bar's child window ID is to prevent the framework from writing menu prompts in pane 0. If you like the menu prompts, you can disregard the following instructions.

The status bar window ID is assigned in the _CStatusBar::Create_ function called by the derived frame class _OnCreate_ member function. That function is contained in the MainFrm.cpp file that AppWizard generates. The window ID is the third _Create_ parameter, and it defaults to _AFX_IDW_STATUS_BAR_.

To assign your own ID, you must replace this call

m_wndStatusBar.Create(this);

with this call

m_wndStatusBar.Create(this, WS_CHILD | WS_VISIBLE | CBRS_BOTTOM, 
                      ID_MY_STATUS_BAR);

You must also, of course, define the _ID_MY_STATUS_BAR_ constant in the resource.h file (using Visual C++'s resource symbol editor).

We forgot one thing. The standard application framework's View menu allows the user to turn the status bar on and off. That logic is pegged to the _AFX_IDW_STATUS_BAR_ window ID, so you'll have to change the menu logic, too. In your derived frame class, you must write message map entries and handlers for the _ID_VIEW_STATUS_BAR_ command and update command UI messages. _ID_VIEW_STATUS_BAR_ is the ID of the Status Bar menu item. The derived class handlers override the standard handlers in the _CFrameWnd_ base class. See the EX14B example for code details.
________________________________________________________________________
6.2.7. - [The EX14B Status Bar Example](invcpp5/ch14h.htm)
----------------------------------------------------
 The EX14B Status Bar Example 

The EX14B Status Bar Example
============================

The EX14B example replaces the standard application framework status bar with a new status bar that has the following text panes.

**Pane Index**

**String ID**

**Type**

**Description**

0

_ID_SEPARATOR_ (0)

Message line

_x_ cursor coordinate

1

_ID_SEPARATOR_ (0)

Message line

_y_ cursor coordinate

2

_ID_INDICATOR_LEFT_

Status indicator

Left mouse button status

3

_ID_INDICATOR_RIGHT_

Status indicator

Right mouse button status

The resulting status bar is shown in Figure 14-4. Notice that the leftmost pane stretches past its normal 1/20-screen length as the displayed frame window expands.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F14OG04x.gif)]

**Figure 14-4.** _The status bar of the EX14B example._

Follow these steps to produce the EX14B example:

2.  **Run AppWizard to generate \vcpp32\ex14b\ex14b.** Accept all default settings but two: select Single Document and deselect Printing and Print Preview. The options and the default class names are shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G14OG04x.gif)
    
3.  **Use the string editor to edit the application's string table resource.** The application has a single string table resource with artificial "segment" divisions left over from the 16-bit era. Double-click on the String Table icon in the String Table folder on the ResourceView page to bring up the string editor. Then double-click on the empty entry at the end of the list. A dialog allows you to assign the ID and the string value as shown below.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G14OG05x.gif)]
    
    Add two strings as follows.
    
    **String ID**
    
    **String Caption**
    
    _ID_INDICATOR_LEFT_
    
    LEFT
    
    _ID_INDICATOR_RIGHT_
    
    RIGHT
    
4.  **Use Visual C++ to edit the application's symbols.** Choose Resource Symbols from the View menu. Add the new status bar identifier, _ID_MY_STATUS_BAR_, and accept the default value.
    
5.  **Use ClassWizard to add View menu command handlers in the class _CMainFrame._** Add the following command message handlers.
    
    **Object ID**
    
    **Message**
    
    **Member Function**
    
    _ID_VIEW_STATUS_BAR_
    
    COMMAND
    
    _OnViewStatusBar_
    
    _ID_VIEW_STATUS_BAR_
    
    UPDATE_COMMAND_UI
    
    _OnUpdateViewStatusBar_
    
6.  **Add the following function prototypes to MainFrm.h.** You must add these _CMainFrame_ message handler prototypes manually because ClassWizard doesn't recognize the associated command message IDs.
    
    **afx_msg void OnUpdateLeft(CCmdUI\* pCmdUI);
    afx_msg void OnUpdateRight(CCmdUI\* pCmdUI);**
    
    Add the message handler statements inside the _AFX_MSG_ brackets so that ClassWizard will let you access and edit the code later. While MainFrm.h is open, make _m_wndStatusBar_ public rather than protected.
    
7.  **Edit the MainFrm.cpp file.** Replace the original _indicators_ array with the following boldface code:
    
    static UINT indicators[] =
    {
        ID_SEPARATOR,  **// first message line pane
        ID_SEPARATOR,  // second message line pane
        ID_INDICATOR_LEFT,
        ID_INDICATOR_RIGHT,**
    };
    
    Next edit the _OnCreate_ member function. Replace the following statement
    
    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0("Failed to create status bar\n");
        return -1;      // fail to create
    }
    
    with the statement shown here:
    
    if (!m_wndStatusBar.Create(this**,
            WS_CHILD | WS_VISIBLE | CBRS_BOTTOM, ID_MY_STATUS_BAR**) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0("Failed to create status bar\n");
        return -1;      // fail to create
    }
    
    The modified call to _Create_ uses our own status bar ID, _ID_MY_STATUS_BAR_, instead of _AFX_IDW_STATUS_BAR_ (the application framework's status bar object).
    
    Now add the following message map entries for the class _CMainFrame_. ClassWizard can't add these for you because it doesn't recognize the string table IDs as object IDs.
    
    **ON_UPDATE_COMMAND_UI(ID_INDICATOR_LEFT, OnUpdateLeft)
    ON_UPDATE_COMMAND_UI(ID_INDICATOR_RIGHT, OnUpdateRight)**
    
    Next add the following _CMainFrame_ member functions that update the two status indicators:
    
    **void CMainFrame::OnUpdateLeft(CCmdUI\* pCmdUI)
    {
        pCmdUI->Enable(::GetKeyState(VK_LBUTTON) < 0);
    }
    
    void CMainFrame::OnUpdateRight(CCmdUI\* pCmdUI)
    {
        pCmdUI->Enable(::GetKeyState(VK_RBUTTON) < 0);
    }**
    
    Note that the left and right mouse buttons have virtual key codes like keys on the keyboard have. You don't have to depend on mouse-click messages to determine the button status.
    
    Finally, edit the following View menu functions that ClassWizard originally generated in MainFrm.cpp:
    
    void CMainFrame::OnViewStatusBar()
    {
        **m_wndStatusBar.ShowWindow((m_wndStatusBar.GetStyle() &
                                   WS_VISIBLE) == 0);
        RecalcLayout();**
    }
    void CMainFrame::OnUpdateViewStatusBar(CCmdUI\* pCmdUI)
    {
        **pCmdUI-
    >SetCheck((m_wndStatusBar.GetStyle() & WS_VISIBLE) != 0);**
    }
    
    These functions ensure that the View menu Status Bar command is properly linked to the new status bar.
    
8.  **Edit the _OnDraw_ function in Ex14bView.cpp.** The _OnDraw_ function displays a message in the view window. Add the following boldface code:
    
    void CEx14bView::OnDraw(CDC\* pDC)
    {
        **pDC->TextOut(0, 0,
            "Watch the status bar while you move and click the mouse.");**
    }
    
9.  **Add a WM_MOUSEMOVE handler in the _CEx14bView_ class.** Use ClassWizard to map the message to _OnMouseMove_, and then edit the function as shown below. This function gets a pointer to the status bar object and then calls the _SetPaneText_ function to update the first and second message line panes.
    
    void CEx14bView::OnMouseMove(UINT nFlags, CPoint point)
    {
        **CString str;
        CMainFrame\* pFrame = (CMainFrame\*) AfxGetApp()->m_pMainWnd;
        CStatusBar\* pStatus = &pFrame->m_wndStatusBar;
        if (pStatus) {
            str.Format("x = %d", point.x);
            pStatus->SetPaneText(0, str);
            str.Format("y = %d", point.y);
            pStatus->SetPaneText(1, str);
        }**
    }
    
    Finally, add the statement
    
    **#include "MainFrm.h"**
    
    near the top of the file ex14bView.cpp.
    
10.  **Build and test the EX14B application.** Move the mouse, and observe that the left two status bar panes accurately reflect the mouse cursor's position. Try the left and right mouse buttons. Can you toggle the status bar on and off from the View menu?

> NOTE
> 
> If you want the first (index 0) status bar pane to have a beveled border like the other panes and you want the status bar to grow and resize to fit their contents, include the following two lines in the _CMainFrame::OnCreate_ function, following the call to the status bar _Create_ function.
> 
> m_wndStatusBar.SetPaneInfo(0, 0, 0, 50);
> m_wndStatusBar.SetPaneInfo(1, 0, SBPS_STRETCH, 50);
> 
> These statements change the width of the first two panes (from their default of one-fourth the display size) and make the second pane (index 1) the stretchy one.
________________________________________________________________________
6.2.8. - [The Internet Explorer Rebar Toolbar](invcpp5/ch14i.htm)
----------------------------------------------------
 The Internet Explorer Rebar Toolbar 

The Internet Explorer Rebar Toolbar
===================================

As we learned in [Chapter 9](ch09a.htm), Visual C++ 6.0 contains many features that are part of Internet Explorer 4.0: the Internet Explorer Common Controls. One of the new controls in the IE Common Controls is a new kind of toolbar called a rebar.

You're probably already familiar with the rebar if you have ever used Internet Explorer 4.0. The rebar differs from the default MFC toolbar in that it provides grippers and allows the user to "slide" its horizontal and vertical positions, whereas the MFC toolbar's position is changed via drag-and-drop docking. Rebars also allow the developer to provide many more internal control types—such as drop-down menus—than are available in _CToolBar_.

Anatomy of a Rebar
------------------

Figure 14-5 shows the various terminology used on a rebar. Each internal toolbar in a rebar is called a band. The raised edge where the user slides the band is called a gripper. Each band can also have a label.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F14OG05x.gif)]

**Figure 14-5.** _Rebar terminology._

MFC provides two classes that facilitate working with rebars:

*   **_CReBar_**—A high-level abstraction class that provides members for adding _CToolBar_ and _CDialogBar_ classes to rebars as bands. _CReBar_ also handles communication (such as message notifications) between the underlying control and the MFC framework.
*   **_CReBarCtrl_**—A low-level wrapper class that wraps the IE ReBar control. This class provides numerous members for creating and manipulating rebars but does not provide the niceties that are found in _CReBar_.

Most MFC applications use _CReBar_ and call the member function _GetReBarCtrl_, which returns a _CReBarCtrl_ pointer to gain access to the lower-level control if needed.
________________________________________________________________________
6.2.9. - [The EX14C Rebar Example](invcpp5/ch14j.htm)
----------------------------------------------------
 The EX14C Rebar Example 

The EX14C Rebar Example
=======================

Let's get familiar with the rebar by jumping into an example. This example creates an SDI application that has a rebar with two bands: a familiar toolbar band and a dialog bar band. Figure 14-6 shows the example in action.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F14OG06x.gif)]

**Figure 14-6.** _EX14C rebar example._

Here are the steps required to create the EX14C example:

2.  **Run AppWizard to generate \vcpp32\ex14c\ex14c.** Select Single Document. In Step 4, be sure you select Internet Explorer ReBars under the How Do You Want Your Toolbars To Look option. Figure 14-7 below shows the correct settings. Accept all other default settings.
    
3.  **Compile and run the application.** When you run the application, you will see that AppWizard has automatically created a rebar with two bands. One band contains a conventional toolbar and the other contains the text "TODO: layout dialog bar" in the band. Figure 14-8 below shows the initial rebar control.
    
    At this point, you can open the MainFrm.h header file and see the code below, which declares the _CReBar_ data member _m_ndReBar_.
    
    protected:  // control bar embedded members
        CStatusBar  m_wndStatusBar;
        CToolBar    m_wndToolBar;
        CReBar      m_wndReBar;
        CDialogBar  m_wndDlgBar;
    

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F14OG07x.gif)]

**Figure 14-7.** _AppWizard Step 4 settings for the rebar control._

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F14OG08x.gif)]

**Figure 14-8.** _Initial windows for EX14C example with the default rebar controls._

In the MainFrm.cpp file, you can see the code that adds the toolbar and the dialog bar to the _CReBar_ object:

    if (!m_wndReBar.Create(this) ||
        !m_wndReBar.AddBar(&m_wndToolBar) ||
        !m_wndReBar.AddBar(&m_wndDlgBar))
    {
        TRACE0("Failed to create rebar\n");
        return -1;      // fail to create
    }

7.  **Lay out the Dialog Bar.** Open the Visual C++ resource editor. Under the Dialog heading you'll find a dialog resource for the dialog bar with the ID _IDR_MAINFRAME_. Open _IDR_MAINFRAME_ and you'll see the dialog bar with the text "TODO: layout dialog bar". Let's follow AppWizard's friendly suggestion and put some real controls into the dialog bar. First delete the static control with the "TODO" text in it. Next place a combo box in the dialog bar and enter some default data items: _one_, _two_, _buckle_, _my_, _shoe!_ Now place a button on the dialog bar and change the button's text to _Increment_. Next place a progress bar with the default properties on the dialog bar. Finally place another button with the text _Decrement_ on the dialog bar. When you are done laying out the dialog bar, it should look similar to Figure 14-9.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F14OG09x.gif)]

**Figure 14-9.** _Edited_ IDR_MAINFRAME _dialog bar._

5.  **Associate the dialog bar with the _CMainFrame_ class.** Before we can program the handlers for the Increment and Decrement buttons, we need to attach the dialog bar to a class using ClassWizard. While in the resource editor, bring up ClassWizard by double-clicking on the Increment button. You will now see this dialog.

![](c:/dl/books/windows/msvc5th/invcpp5/images/G14OG06.GIF)

Choose Select An Existing Class. We choose this option because we want our dialog resource to be a band in the toolbar, not a separate dialog class. Click OK and you will see these choices.

![](c:/dl/books/windows/msvc5th/invcpp5/images/G14OG07.GIF)

Choose _CMainFrame_ from the list and click Select.

ClassWizard will prompt you with one last dialog.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G14OG08x.gif)]

Click Yes and then exit ClassWizard. You have successfully associated the IDR_MAINFRAME dialog bar with the _CMainFrame_ class.

7.  **Program the dialog bar.** To program the dialog bar, bring up the IDR_MAINFRAME dialog resource in the resource editor again and double-click on the Increment button. ClassWizard will automatically create an _ONBUTTON1_ handler for you—accept the default name for this function. Enter the following boldface code in the _OnButton1_ function:
    
    void CMainFrame::OnButton1() 
    {
        **CProgressCtrl \* pProgress =   
            (CProgressCtrl\*)m_wndDlgBar.GetDlgItem(IDC_PROGRESS1);
        pProgress->StepIt();**
    }
    
    The _OnButton1_ handler first gets a pointer to the progress control and then calls _StepIt_ to increment the progress control.
    
    Now we need to add similar code to the decrement handler. Double-click on the Decrement button in the resource editor and ClassWizard will automatically create an _OnButton2_ handler. Add the following boldface code to the _OnButton2_ member function:
    
    void CMainFrame::OnButton2() 
    {
        **CProgressCtrl \* pProgress =
                 (CProgressCtrl\*)m_wndDlgBar.GetDlgItem(IDC_PROGRESS1);
    
        int nCurrentPos = pProgress->GetPos();
    
        pProgress->SetPos(nCurrentPos-10);**
    
    }
    
8.  **Compile and test.** Now you can compile and run EX14C to see your custom rebar in action. The Increment button increases the progress bar and the Decrement button decreases it.
    

In this chapter, we learned how to use MFC's toolbar, status bar, and the new rebar control. In the next chapter, we'll look at how to extend MFC to implement a frame window that remembers its position.
________________________________________________________________________
6.3. - [Chapter 15 -- A Reusable Frame Window Base Class](invcpp5/ch15a.htm)
----------------------------------------------------
 Chapter 15 -- A Reusable Frame Window Base Class   Chapter 15

A Reusable Frame Window Base Class
==================================

C++ promises programmers the ability to produce "software Lego blocks" that can be taken "off the shelf" and fitted easily into an application. The Microsoft Foundation Class (MFC) Library version 6.0 classes are a good example of this kind of reusable software. This chapter shows you how to build your own reusable base class by taking advantage of what the MFC library already provides.

In the process of building the reusable class, you'll learn a few more things about Microsoft Windows and the MFC library. In particular, you'll see how the application framework allows access to the Windows Registry, you'll learn more about the mechanics of the _CFrameWnd_ class, and you'll get more exposure to static class variables and the _CString_ class.
________________________________________________________________________
6.3.1. - [Why Reusable Base Classes Are Difficult to Write](invcpp5/ch15b.htm)
----------------------------------------------------
 Why Reusable Base Classes Are Difficult to Write 

Why Reusable Base Classes Are Difficult to Write
================================================

In a normal application, you write code for software components that solve particular problems. It's usually a simple matter of meeting the project specification. With reusable base classes, however, you must anticipate future programming needs, both your own and those of others. You have to write a class that is general and complete yet efficient and easy to use.

This chapter's example showed me the difficulty in building reusable software. I started out intending to write a frame class that would "remember" its window size and position. When I got into the job, I discovered that existing Windows-based programs remember whether they have been minimized to the taskbar or whether they have been maximized to full screen. Then there was the oddball case of a window that was both minimized and maximized. After that, I had to worry about the toolbar and the status bar, plus the class had to work in a dynamic link library (DLL). In short, it was surprisingly difficult to write a frame class that would do everything that a programmer might expect.

In a production programming environment, reusable base classes might fall out of the normal software development cycle. A class written for one project might be extracted and further generalized for another project. There's always the temptation, though, to cut and paste existing classes without asking, "What can I factor out into a base class?" If you're in the software business for the long term, it's beneficial to start building your library of truly reusable components.
________________________________________________________________________
6.3.2. - [The CPersistentFrame Class](invcpp5/ch15c.htm)
----------------------------------------------------
 The CPersistentFrame Class 

The _CPersistentFrame_ Class
============================

In this chapter, you'll be using a class named _CPersistentFrame_ that is derived from the _CFrameWnd_ class. This _CPersistentFrame_ class supports a persistent SDI (Single Document Interface) frame window that remembers the following characteristics.

*   Window size
    
*   Window position
    
*   Maximized status
    
*   Minimized status
    
*   Toolbar and status bar enablement and position

When you terminate an application that's built with the _CPersistentFrame_ class, the above information is saved on disk in the Windows Registry. When the application starts again, it reads the Registry and restores the frame to its state at the previous exit.

You can use the persistent view class in any SDI application, including the examples in this book. All you have to do is substitute _CPersistentFrame_ for _CFrameWnd_ in your application's derived frame class files.
________________________________________________________________________
6.3.3. - [The CFrameWnd Class and the ActivateFrame Member Function](invcpp5/ch15d.htm)
----------------------------------------------------
 The CFrameWnd Class and the ActivateFrame Member Function 

The _CFrameWnd_ Class and the _ActivateFrame_ Member Function
=============================================================

Why choose _CFrameWnd_ as the base class for a persistent window? Why not have a persistent view class instead? In an MFC SDI application, the main frame window is always the parent of the view window. This frame window is created first, and then the control bars and the view are created as child windows. The application framework ensures that the child windows shrink and expand appropriately as the user changes the size of the frame window. It wouldn't make sense to change the view size after the frame was created.

The key to controlling the frame's size is the _CFrameWnd::ActivateFrame_ member function. The application framework calls this virtual function (declared in _CFrameWnd_) during the SDI main frame window creation process (and in response to the File New and File Open commands). The framework's job is to call the _CWnd::ShowWindow_ function with the parameter _nCmdShow_. _ShowWindow_ makes the frame window visible along with its menu, view window, and control bars. The _nCmdShow_ parameter determines whether the window is maximized or minimized or both.

If you override _ActivateFrame_ in your derived frame class, you can change the value of _nCmdShow_ before passing it to the _CFrameWnd::ActivateFrame_ function. You can also call the _CWnd::SetWindowPlacement_ function, which sets the size and position of the frame window, and you can set the visible status of the control bars. Because all changes are made before the frame window becomes visible, no annoying flash occurs on the screen.

You must be careful not to reset the frame window's position and size after every File New or File Open command. A first-time flag data member ensures that your _CPersistentFrame::ActivateFrame_ function operates only when the application starts.
________________________________________________________________________
6.3.4. - [The PreCreateWindow Member Function](invcpp5/ch15e.htm)
----------------------------------------------------
 The PreCreateWindow Member Function 

The _PreCreateWindow_ Member Function
=====================================

_PreCreateWindow_, declared at the _CWnd_ level, is another virtual function that you can override to change the characteristics of your window before it is displayed. The framework calls this function before it calls _ActivateFrame_. AppWizard always generates an overridden _PreCreateWindow_ function in your project's view and frame window classes.

This function has a _CREATESTRUCT_ structure as a parameter, and two of the data members in this structure are _style_ and _dwExStyle_. You can change these data members before passing the structure on to the base class _PreCreateWindow_ function. The _style_ flag determines whether the window has a border, scroll bars, a minimize box, and so on. The _dwExStyle_ flag controls other characteristics, such as always-on-top status. See the online documentation for Window Styles and Extended Window Styles for details.

The _CREATESTRUCT_ member _lpszClass_ is also useful to change the window's background brush, cursor, or icon. It makes no sense to change the brush or cursor in a frame window because the view window covers the client area. If you want an ugly red view window with a special cursor, for example, you can override your view's _PreCreateWindow_ function like this:

BOOL CMyView::PreCreateWindow(CREATESTRUCT& cs)
{
    if (!CView::PreCreateWindow(cs)) {
        return FALSE;
    }
    cs.lpszClass =
        AfxRegisterWndClass(CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW,
                            AfxGetApp()->LoadCursor(IDC_MYCURSOR),
                            ::CreateSolidBrush(RGB(255, 0, 0)));
    if (cs.lpszClass != NULL) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

If you override the _PreCreateWindow_ function in your persistent frame class, windows of all derived classes will share the characteristics you programmed in the base class. Of course, derived classes can have their own overridden _PreCreateWindow_ functions, but then you'll have to be careful about the interaction between the base class and derived class functions.
________________________________________________________________________
6.3.5. - [The Windows Registry](invcpp5/ch15f.htm)
----------------------------------------------------
 The Windows Registry 

The Windows Registry
====================

If you've used Win16-based applications, you've probably seen INI files. You can still use INI files in Win32-based applications, but Microsoft recommends that you use the Windows Registry instead. The Registry is a set of system files, managed by Windows, in which Windows and individual applications can store and access permanent information. The Registry is organized as a kind of hierarchical database in which string and integer data is accessed by a multipart key.

For example, a text processing application, TEXTPROC, might need to store the most recent font and point size in the Registry. Suppose that the program name forms the root of the key (a simplification) and that the application maintains two hierarchy levels below the name. The structure looks something like this.

> TEXTPROC
> 
>     Text formatting
> 
>        Font = Times Roman
> 
>        Points = 10

> **Unicode**
> 
> European languages use characters that can be encoded in 8 bits—even characters with diacritics. Most Asian languages require 16 bits for their characters. Many programs use the double-byte character set (DBCS) standard: some characters use 8 bits and others 16 bits, depending on the value of the first 8 bits. DBCS is being replaced by Unicode, in which all characters are 16-bit "wide" characters. No specific Unicode character ranges are set aside for individual languages: if a character is used in both the Chinese and the Japanese languages, for example, that character appears only once in the Unicode character set.
> 
> When you look at MFC source code and the code that AppWizard generates, you'll see the types _TCHAR_, _LPTSTR_, and _LPCTSTR_ and you'll see literal strings like __T("string")_. You are looking at Unicode macros. If you build your project without defining __UNICODE_, the compiler generates code for ordinary 8-bit ANSI characters (_CHAR_) and pointers to 8-bit character arrays (_LPSTR_, _LPCSTR_). If you do define __UNICODE_, the compiler generates code for 16-bit Unicode characters (_WCHAR_), pointers (_LPWSTR_, _LPCWSTR_), and literals (_L"wide string")_.
> 
> The __UNICODE_ preprocessor symbol also determines which Windows functions your program calls. Many Win32 functions have two versions. When your program calls _CreateWindowEx_, for example, the compiler generates code to call either _CreateWindowExA_ (with ANSI parameters) or _CreateWindowExW_ (with Unicode parameters). In Microsoft Windows NT, which uses Unicode internally, _CreateWindowExW_ passes all parameters straight through, but _CreateWindowExA_ converts ANSI string and character parameters to Unicode. In Microsoft Windows 95, which uses ANSI internally, _CreateWindowExW_ is a stub that returns an error and _CreateWindowExA_ passes the parameters straight through.
> 
> If you want to create a Unicode application, you should target it for Windows NT and use the macros throughout. You can write Unicode applications for Windows 95, but you'll do extra work to call the "A" versions of the Win32 functions. As shown in [Chapter 24](ch24a.htm), [Chapter 25](ch25a.htm), [Chapter 26](ch26a.htm), [Chapter 27](ch27a.htm), [Chapter 28](ch28a.htm), [Chapter 29](ch29a.htm), and [Chapter 30](ch30a.htm), COM calls (except DAO) always use wide characters. Although Win32 functions are available for converting between ANSI and Unicode, if you're using the _CString_ class you can rely on a wide character constructor and the _AllocSysString_ member function to do the conversions.
> 
> For simplicity, this book's example programs use ANSI only. The code AppWizard generated uses Unicode macros, but the code I wrote uses 8-bit literal strings and the _char_, _char\*_, and _const char\*_ types.

The MFC library provides four _CWinApp_ member functions, holdovers from the days of INI files, for accessing the Registry. Starting with Visual C++ version 5.0, AppWizard generates a call to _CWinApp::SetRegistryKey_ in your application's _InitInstance_ function as shown here.

SetRegistryKey(_T("Local AppWizard-Generated Applications"));

If you remove this call, your application will not use the Registry but will create and use an INI file in the Windows directory. The _SetRegistryKey_ function's string parameter establishes the top of the hierarchy, and the following Registry functions define the bottom two levels: called heading name and entry name.

*   _GetProfileInt_
    
*   _WriteProfileInt_
    
*   _GetProfileString_
    
*   _WriteProfileString_

These functions treat Registry data as either _CString_ objects or unsigned integers. If you need floating-point values as entries, you must use the string functions and do the conversion yourself. All the functions take a heading name and an entry name as parameters. In the example shown above, the heading name is Text Formatting and the entry names are Font and Points.

To use the Registry access functions, you need a pointer to the application object. The global function _AfxGetApp_ does the job. With the previous sample Registry, the Font and Points entries were set with the following code:

AfxGetApp()->WriteProfileString("Text formatting", "Font",
                                "Times Roman");
AfxGetApp()->WriteProfileInt("Text formatting", "Points", 10);

You'll see a real Registry example in EX15A, and you'll learn to use the Windows Regedit program to examine and edit the Registry.

> NOTE
> 
> The application framework stores a list of most recently used files in the Registry under the heading Recent File List.
________________________________________________________________________
6.3.6. - [Using the CString Class](invcpp5/ch15g.htm)
----------------------------------------------------
 Using the CString Class 

Using the _CString_ Class
=========================

The MFC _CString_ class is a significant de facto extension to the C++ language. As the _Microsoft Foundation_ _Classes and Templates_ section of the online help points out, the _CString_ class has many useful operators and member functions, but perhaps its most important feature is its dynamic memory allocation. You never have to worry about the size of a _CString_ object. The statements here represent typical uses of _CString_ objects.

CString strFirstName("Elvis");
CString strLastName("Presley");
CString strTruth = strFirstName + " " + strLastName; // concatenation
strTruth += " is alive";
ASSERT(strTruth == "Elvis Presley is alive");
ASSERT(strTruth.Left(5) == strFirstName);
ASSERT(strTruth[2] == \`v'); // subscript operator

In a perfect world, C++ programs would use all _CString_ objects and never use ordinary zero-terminated character arrays. Unfortunately, many runtime library functions still use character arrays, so programs must always mix and match their string representations. Fortunately, the _CString_ class provides a _const char\*()_ operator that converts a _CString_ object to a character pointer. Many of the MFC library functions have _const char\*_ parameters. Take the global _AfxMessageBox_ function, for example. Here is one of the function's prototypes:

int AFXAPI AfxMessageBox(LPCTSTR lpszText, UINT nType = MB_OK,
                         UINT nIDHelp = 0);

(Note: _LPCTSTR_ is not a pointer to a _CString_ object but rather is a Unicode-enabled replacement for _const char\*_.)

You can call _AfxMessageBox_ this way:

char szMessageText[] = "Unknown error";
AfxMessageBox(szMessageText);

or you can call it this way:

CString strMessageText("Unknown ;error");
AfxMessageBox(strMessageText);

Now suppose you want to generate a formatted string. _CString::Format_ does the job, as shown here:

int nError = 23;
CString strMessageText;
strMessageText.Format("Error number %d", nError);
AfxMessageBox(strMessageText);

> NOTE
> 
> Suppose you want direct write access to the characters in a _CString_ object. If you write code like this:
> 
> CString strTest("test");
> strncpy(strTest, "T", 1);
> 
> you'll get a compile error because the first parameter of _strncpy_ is declared _char\*_, not _const char\*_. The _CString::GetBuffer_ function "locks down" the buffer with a specified size and returns a _char\*_. You must call the _ReleaseBuffer_ member function later to make the string dynamic again. The correct way to capitalize the _T_ is shown here.
> 
> CString strTest("test");
> strncpy(strTest.GetBuffer(5), "T", 1);
> strTest.ReleaseBuffer();
> ASSERT(strTest == "Test");

The _const char\*_ operator takes care of converting a _CString_ object to a constant character pointer; but what about conversion in the other direction? It so happens that the _CString_ class has a constructor that converts a constant character pointer to a _CString_ object, and it has a set of overloaded operators for these pointers. That's why statements such as the following work.

strTruth += " is alive";

The special constructor works with functions that take a _CString_ reference parameter, such as _CDC::TextOut_. In the following statement, a temporary _CString_ object is created on the calling program's stack and then the object's address is passed to _TextOut_:

pDC->TextOut(0, 0, "Hello, world!");

It's more efficient to use the other overloaded version of _CDC::TextOut_ if you're willing to count the characters:

pDC->TextOut(0, 0, "Hello, world!", 13);

If you're writing a function that takes a string parameter, you've got some design choices. Here are some programming rules.

*   If the function doesn't change the contents of the string and you're willing to use C runtime functions such as _strcpy_, use a _const char\*_ parameter.
    
*   If the function doesn't change the contents of the string but you want to use _CString_ member functions inside the function, use a _const CString&_ parameter.
    
*   If the function changes the contents of the string, use a _CString&_ parameter.
________________________________________________________________________
6.3.7. - [The Position of a Maximized Window](invcpp5/ch15h.htm)
----------------------------------------------------
 The Position of a Maximized Window 

The Position of a Maximized Window
==================================

As a Windows user, you know that you can maximize a window from the system menu or by clicking a button at the top right corner of the window. You can return a maximized window to its original size in a similar fashion. It's obvious that a maximized window remembers its original size and position.

The _CWnd_ function _GetWindowRect_ retrieves the screen coordinates of a window. If a window is maximized, _GetWindowRect_ returns the coordinates of the screen rather than the window's unmaximized coordinates. If a persistent frame class is to work for maximized windows, it has to know the window's unmaximized coordinates. _CWnd::GetWindowPlacement_ retrieves the unmaxi-mized coordinates together with some flags that indicate whether the window is currently minimized or maximized or both.

The companion _SetWindowPlacement_ function lets you set the maximized and minimized status and the size and position of the window. To calculate the position of the top left corner of a maximized window, you need to account for the window's border size, obtainable from the Win32 _GetSystemMetrics_ function. See Figure 15-1 for the _CPersistentFrame::ActivateFrame_ code for an example of how _SetWindowPlacement_ is used.
________________________________________________________________________
6.3.8. - [Control Bar Status and the Registry](invcpp5/ch15i.htm)
----------------------------------------------------
 Control Bar Status and the Registry 

Control Bar Status and the Registry
===================================

The MFC library provides two _CFrameWnd_ member functions, _SaveBarState_ and _LoadBarState_, for saving and loading control bar status to and from the Registry. These functions process the size and position of the status bar and docked toolbars. They don't process the position of floating toolbars, however.
________________________________________________________________________
6.3.9. - [Static Data Members](invcpp5/ch15j.htm)
----------------------------------------------------
 Static Data Members 

Static Data Members
===================

The _CPersistentFrame_ class stores its Registry key names in _static_ _const char_ array data members. What were the other storage choices? String resource entries won't work because the strings need to be defined with the class itself. (String resources make sense if _CPersistentFrame_ is made into a DLL, however.) Global variables are generally not recommended because they defeat encapsulation. Static _CString_ objects don't make sense because the characters must be copied to the heap when the program starts.

An obvious choice would have been regular data members. But static data members are better because, as constants, they are segregated into the program's read-only data section and can be mapped to multiple instances of the same program. If the _CPersistentFrame_ class is part of a DLL, all processes that are using the DLL can map the character arrays. Static data members are really global variables, but they are scoped to their class so there's no chance of name collisions.
________________________________________________________________________
6.3.10. - [The Default Window Rectangle](invcpp5/ch15k.htm)
----------------------------------------------------
 The Default Window Rectangle 

The Default Window Rectangle
============================

You're used to defining rectangles with device or logical coordinates. A _CRect_ object constructed with the statement

CRect rect(CW_USEDEFAULT, CW_USEDEFAULT, 0, 0);

has a special meaning. When Windows creates a new window with this special rectangle, it positions the window in a cascade pattern with the top left corner below and to the right of the window most recently created. The right and bottom edges of the window are always within the display's boundaries.

The _CFrameWnd_ class's static _rectDefault_ data member is constructed using _CW_USEDEFAULT_ this way, so it contains the special rectangle. The _CPersistentFrame_ class declares its own _rectDefault_ default window rectangle with a fixed size and position as a static data member, thus hiding the base class member.
________________________________________________________________________
6.3.11. - [The EX15A Example](invcpp5/ch15l.htm)
----------------------------------------------------
 The EX15A Example 

The EX15A Example
=================

The EX15A program illustrates the use of a persistent frame window class, _CPersistentFrame_. Figure 15-1 shows the contents of the files Persist.h and Persist.cpp, which are included in the EX15A project on the companion CD-ROM. In this example, you'll insert the new frame class into an AppWizard-generated SDI application. EX15A is a "do-nothing" application, but you can insert the persistent frame class into any of your own SDI "do-something" applications.

**PERSIST.H**

// Persist.h

#ifndef _INSIDE_VISUAL_CPP_PERSISTENT_FRAME
#define _INSIDE_VISUAL_CPP_PERSISTENT_FRAME

class CPersistentFrame : public CFrameWnd
{ // remembers where it was on the desktop
    DECLARE_DYNAMIC(CPersistentFrame)
private:
    static const CRect s_rectDefault;
    static const char s_profileHeading[];
    static const char s_profileRect[];
    static const char s_profileIcon[];
    static const char s_profileMax[];
    static const char s_profileTool[];
    static const char s_profileStatus[];
    BOOL m_bFirstTime;
protected: // Create from serialization only
    CPersistentFrame();
    ~CPersistentFrame();
//{{AFX_VIRTUAL(CPersistentFrame)
    public:
    virtual void ActivateFrame(int nCmdShow = -1);
    protected:
    //}}AFX_VIRTUAL

    //{{AFX_MSG(CPersistentFrame)
    afx_msg void OnDestroy();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

#endif // _INSIDE_VISUAL_CPP_PERSISTENT_FRAME

**PERSIST.CPP**

// Persist.cpp Persistent frame class for SDI apps

#include "stdafx.h"
#include "persist.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
///////////////////////////////////////////////////////////////
// CPersistentFrame

const CRect CPersistentFrame::s_rectDefault(10,  10,
                                            500, 400);  // static
const char CPersistentFrame::s_profileHeading[] = "Window size";
const char CPersistentFrame::s_profileRect[] = "Rect";
const char CPersistentFrame::s_profileIcon[] = "icon";
const char CPersistentFrame::s_profileMax[] = "max";
const char CPersistentFrame::s_profileTool[] = "tool";
const char CPersistentFrame::s_profileStatus[] = "status";
IMPLEMENT_DYNAMIC(CPersistentFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CPersistentFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CPersistentFrame)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////
CPersistentFrame::CPersistentFrame(){
    m_bFirstTime = TRUE;
}

///////////////////////////////////////////////////////////////
CPersistentFrame::~CPersistentFrame()
{
}

///////////////////////////////////////////////////////////////
void CPersistentFrame::OnDestroy()
{
    CString strText;
    BOOL bIconic, bMaximized;

    WINDOWPLACEMENT wndpl;
    wndpl.length = sizeof(WINDOWPLACEMENT);
    // gets current window position and
    //  iconized/maximized status
    BOOL bRet = GetWindowPlacement(&wndpl);
    if (wndpl.showCmd == SW_SHOWNORMAL) {
        bIconic = FALSE;
        bMaximized = FALSE;
    }
    else if (wndpl.showCmd == SW_SHOWMAXIMIZED) {
        bIconic = FALSE;
        bMaximized = TRUE;
    } 
    else if (wndpl.showCmd == SW_SHOWMINIMIZED) {
        bIconic = TRUE;
        if (wndpl.flags) {
            bMaximized = TRUE;
        }
        else {
            bMaximized = FALSE;
        }
    }
    strText.Format("%04d %04d %04d %04d",
                   wndpl.rcNormalPosition.left,
                   wndpl.rcNormalPosition.top,
                   wndpl.rcNormalPosition.right,
                   wndpl.rcNormalPosition.bottom);
    AfxGetApp()->WriteProfileString(s_profileHeading,
                                    s_profileRect, strText);
    AfxGetApp()->WriteProfileInt(s_profileHeading,
                                 s_profileIcon, bIconic);
    AfxGetApp()->WriteProfileInt(s_profileHeading,
                                 s_profileMax, bMaximized);
    SaveBarState(AfxGetApp()->m_pszProfileName);
    CFrameWnd::OnDestroy();
}

///////////////////////////////////////////////////////////////
void CPersistentFrame::ActivateFrame(int nCmdShow)
{
    CString strText;
    BOOL bIconic, bMaximized;
    UINT flags;
    WINDOWPLACEMENT wndpl;
    CRect rect;

    if (m_bFirstTime) {
        m_bFirstTime = FALSE;
        strText = AfxGetApp()->GetProfileString(s_profileHeading,
                                                s_profileRect);
        if (!strText.IsEmpty()) {
            rect.left = atoi((const char\*) strText);
            rect.top = atoi((const char\*) strText + 5);
            rect.right = atoi((const char\*) strText + 10);
            rect.bottom = atoi((const char\*) strText + 15);
        }
        else {
            rect = s_rectDefault;
        }
       bIconic = AfxGetApp()->GetProfileInt(s_profileHeading,
                                             s_profileIcon, 0);
        bMaximized = AfxGetApp()->GetProfileInt(s_profileHeading,
                                                s_profileMax, 0);
        if (bIconic) {
            nCmdShow = SW_SHOWMINNOACTIVE;
            if (bMaximized) {
                flags = WPF_RESTORETOMAXIMIZED;
            }
            else {
                flags = WPF_SETMINPOSITION;
            }
        }
        else {
            if (bMaximized) {
                nCmdShow = SW_SHOWMAXIMIZED;
                flags = WPF_RESTORETOMAXIMIZED;
            }
            else {
                nCmdShow = SW_NORMAL;
                flags = WPF_SETMINPOSITION;
            }
        }
        wndpl.length = sizeof(WINDOWPLACEMENT);
        wndpl.showCmd = nCmdShow;
        wndpl.flags = flags;
        wndpl.ptMinPosition = CPoint(0, 0);
        wndpl.ptMaxPosition =
            CPoint(-::GetSystemMetrics(SM_CXBORDER),
                   -::GetSystemMetrics(SM_CYBORDER));
        wndpl.rcNormalPosition = rect;
        LoadBarState(AfxGetApp()->m_pszProfileName);
        // sets window's position and minimized/maximized status
        BOOL bRet = SetWindowPlacement(&wndpl);
    }
    CFrameWnd::ActivateFrame(nCmdShow);
}

**Figure 15-1.** _The_ CPersistentView _class listing._

Here are the steps for building the EX15A example program.

2.  **Run AppWizard to generate \vcpp32\ex15a\ex15a.** Accept all default settings but two: select Single Document and deselect Printing and Print Preview. The options and the default class names are shown in the following illustration.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G15og01x.GIF)
    

3.  **Modify MainFrm.h.** You must change the base class of _CMainFrame_. To do this, simply change the line
    
    class CMainFrame : public CFrameWnd
    
    to
    
    class CMainFrame : public **CPersistentFrame**
    
    Also, add the line
    
    **#include "persist.h"**
    
4.  **Modify MainFrm.cpp.** Globally replace all occurrences of _CFrameWnd_ with _CPersistentFrame_.
5.  **Modify ex15a.cpp.** Replace the line
    
    SetRegistryKey(_T("Local AppWizard-Generated Applications"));
    
    with the line
    
    SetRegistryKey(**"Programming Visual C++"**);
    
6.  **Add the Persist.cpp file to the project.** You can type in the Persist.h and Persist.cpp files from Figure 15-1, or you can copy the files from the companion CD-ROM. Having the files in the \vcpp32\ex15a directory is not sufficient. You must add the names of the files to the project's project (DSP) file. Choose Add To Project from Visual C++'s Project menu, and choose Files from the submenu. Select Persist.h and Persist.cpp from the list.
7.  **Rebuild the ClassWizard file to include the new _CPersistentFrame_ class.** Use Windows Explorer to delete the ClassWizard file ex15a.clw. Back in Visual C++, choose ClassWizard from the View menu. Follow Visual C++'s instructions if it asks you to close any files. Click Yes when asked if you would like to rebuild the CLW file. The Select Source Files dialog box will appear. Make sure all of the header and source files are listed in the Files In Project box, as shown in the following illustration.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G15og02x.GIF)
    
    Then click OK to regenerate the CLW file. Notice that _CPersistentFrame_ is now integrated into ClassWizard. You'll now be able to map messages and override virtual functions in the _CPersistentFrame_ class.
    

8.  **Build and test the EX15A application.** Size and move the application's frame window, and then close the application. When you restart the application, does its window open at the same location at which it was closed? Experiment with maximizing and minimizing, and then change the status and position of the control bars. Does the persistent frame remember its settings?
9.  **Save the _CPersistentFrame_ class as a Gallery component for future use.** In the ClassView window, right-click on _CPersistentFrame_ and select Add To Gallery. Bring up the Components And Controls Gallery by choosing Add To Project from the Project menu and then choosing Components And Controls. Notice that Visual C++ created the file Persistent Frame.ogx in a folder named \ex15a. Change this folder's name to Persistent Frame. Now you can add the _CPersistentFrame_ class to any project by simply adding Persistent Frame.ogx. We will add _CPersistentFrame_ to EX22A this way.
10.  **Examine the Windows Registry.** Run the Windows regedit.exe program. Navigate to the HKEY_CURRENT_USER\Software\Programming Visual C++\ex15a key. You should see data values similar to those shown in the following illustration.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G15og03x.gif)]
    
    Notice the relationship between the Registry key and the _SetRegistryKey_ function parameter, "_Programming Visual C++."_ If you supply an empty string as the _SetRegistryKey_ parameter, the program name (ex15a, in this case) is positioned directly below the Software key.
________________________________________________________________________
6.3.12. - [Persistent Frames in MDI Applications](invcpp5/ch15m.htm)
----------------------------------------------------
 Persistent Frames in MDI Applications 

Persistent Frames in MDI Applications
=====================================

You won't get to Multiple Document Interface (MDI) applications until [Chapter 18](ch18a.htm), but if you're using this book as a reference, you might want to apply the persistent frame technique to MDI applications.

The _CPersistentFrame_ class, as presented in this chapter, won't work in an MDI application because the MDI main frame window's _ShowWindow_ function is called, not by a virtual _ActivateFrame_ function, but directly by the application class's _InitInstance_ member function. If you need to control the characteristics of an MDI main frame window, add the necessary code to _InitInstance_.

The _ActivateFrame_ function is called, however, for _CMDIChildWnd_ objects. This means your MDI application could remember the sizes and positions of its child windows. You could store the information in the Registry, but you would have to accommodate multiple windows. You would have to modify the _CPersistentFrame_ class for this purpose.
________________________________________________________________________
6.4. - [Chapter 16 -- Separating the Document from Its View](invcpp5/ch16a.htm)
----------------------------------------------------
 Chapter 16 -- Separating the Document from Its View   Chapter 16

Separating the Document from Its View
=====================================

Now you're finally going to see the interaction between documents and views. [Chapter 13](ch13a.htm) gave you a preview of this interaction when it showed the routing of command messages to both view objects and document objects. In this chapter, you'll see how the document maintains the application's data and how the view presents the data to the user. You'll also learn how the document and view objects talk to each other while the application executes.

The two examples in this chapter both use the _CFormView_ class as the base class for their views. The first example is as simple as possible, with the document holding only one simple object of class _CStudent_, which represents a single student record. The view shows the student's name and grade and allows editing. With the _CStudent_ class, you'll get some practice writing classes to represent real-world entities. You'll also get to use the Microsoft Foundation Class (MFC) Library version 6.0 diagnostic dump functions.

The second example goes further by introducing pointer collection classes—the _CObList_ and _CTypedPtrList_ classes in particular. Now the document holds a collection of student records, and the view allows the sequencing, insertion, and deletion of individual records.
________________________________________________________________________
6.4.1. - [Document-View Interaction Functions](invcpp5/ch16b.htm)
----------------------------------------------------
 Document-View Interaction Functions 

Document-View Interaction Functions
===================================

You already know that the document object holds the data and that the view object displays the data and allows editing. An SDI application has a document class derived from _CDocument_, and it has one or more view classes, each ultimately derived from _CView_. A complex handshaking process takes place among the document, the view, and the rest of the application framework. To understand this process, you need to know about five important member functions in the document and view classes. Two are nonvirtual base class functions that you call in your derived classes; three are virtual functions that you often override in your derived classes. Let's look at these functions one at a time.

The _CView::GetDocument_ Function
---------------------------------

A view object has one and only one associated document object. The _GetDocument_ function allows an application to navigate from a view to its document. Suppose a view object gets a message that the user has entered new data into an edit control. The view must tell the document object to update its internal data accordingly. The _GetDocument_ function provides the document pointer that can be used to access document class member functions or public data embers.

> NOTE
> 
> The _CDocument::GetNextView_ function navigates from the document to the view, but because a document can have more than one view, it's necessary to call this member function once for each view, inside a loop. You'll seldom call _GetNextView_ because the application framework provides a better method of iterating through a document's views.

When AppWizard generates a derived _CView_ class, it creates a special type-safe version of the _GetDocument_ function that returns not a _CDocument_ pointer but a pointer to an object of your derived class. This function is an inline function, and it looks something like this:

CMyDoc\* GetDocument()
{
    return (CMyDoc\*) 
m_pDocument;
}

When the compiler sees a call to _GetDocument_ in your view class code, it uses the derived class version instead of the _CDocument_ version, so you do not have to cast the returned pointer to your derived document class. Because the _CView::GetDocument_ function is not a virtual function, a statement such as

pView->GetDocument(); // pView is declared CView\*

calls the base class _GetDocument_ function and thus returns a pointer to a _CDocument_ object.

The _CDocument::UpdateAllViews_ Function
----------------------------------------

If the document data changes for any reason, all views must be notified so that they can update their representations of that data. If _UpdateAllViews_ is called from a member function of a derived document class, its first parameter, _pSender_, is _NULL_. If _UpdateAllViews_ is called from a member function of a derived view class, set the _pSender_ parameter to the current view, like this:

GetDocument()->UpdateAllViews(this);

The non-null parameter prevents the application framework from notifying the current view. The assumption here is that the current view has already updated itself.

The function has optional hint parameters that can be used to give view-specific and application-dependent information about which parts of the view to update. This is an advanced use of the function.

How exactly is a view notified when _UpdateAllViews_ gets called? Take a look at the next function, _OnUpdate_.

The _CView::OnUpdate_ Function
------------------------------

This virtual function is called by the application framework in response to your application's call to the _CDocument::UpdateAllViews_ function. You can, of course, call it directly within your derived _CView_ class. Typically, your derived view class's _OnUpdate_ function accesses the document, gets the document's data, and then updates the view's data members or controls to reflect the changes. Alternatively, _OnUpdate_ can invalidate a portion of the view, causing the view's _OnDraw_ function to use document data to draw in the window. The _OnUpdate_ function might look something like this:

void CMyView::OnUpdate(CView\* pSender, LPARAM lHint, CObject\* pHint)
{
    CMyDocument\* pMyDoc = GetDocument();
    CString lastName = pMyDoc->GetLastName();
    m_pNameStatic->SetWindowText(lastName); // m_pNameStatic is
                                            //  a CMyView data member
}

The hint information is passed through directly from the call to _UpdateAllViews_. The default _OnUpdate_ implementation invalidates the entire window rectangle. In your overridden version, you can choose to define a smaller invalid rectangle as specified by the hint information.

If the _CDocument_ function _UpdateAllViews_ is called with the _pSender_ parameter pointing to a specific view object, _OnUpdate_ is called for all the document's views except the specified view.

The _CView::OnInitialUpdate_ Function
-------------------------------------

This virtual _CView_ function is called when the application starts, when the user chooses New from the File menu, and when the user chooses Open from the File menu. The _CView_ base class version of _OnInitialUpdate_ does nothing but call _OnUpdate_. If you override _OnInitialUpdate_ in your derived view class, be sure that the view class calls the base class's _OnInitialUpdate_ function or the derived class's _OnUpdate_ function.

You can use your derived class's _OnInitialUpdate_ function to initialize your view object. When the application starts, the application framework calls _OnInitialUpdate_ immediately after _OnCreate_ (if you've mapped _OnCreate_ in your view class). _OnCreate_ is called once, but _OnInitialUpdate_ can be called many times.

The _CDocument::OnNewDocument_ Function
---------------------------------------

The framework calls this virtual function after a document object is first constructed and when the user chooses New from the File menu in an SDI application. This is a good place to set the initial values of your document's data members. AppWizard generates an overridden _OnNewDocument_ function in your derived document class. Be sure to retain the call to the base class function.
________________________________________________________________________
6.4.2. - [The Simplest Document-View Application](invcpp5/ch16c.htm)
----------------------------------------------------
 The Simplest Document-View Application 

The Simplest Document-View Application
======================================

Suppose you don't need multiple views of your document but you plan to take advantage of the application framework's file support. In this case, you can forget about the _UpdateAllViews_ and _OnUpdate_ functions. Simply follow these steps when you develop the application:

2.  In your derived document class header file (generated by AppWizard), declare your document's data members. These data members are the primary data storage for your application. You can make these data members public, or you can declare the derived view class a friend of the document class.
    
3.  In your derived view class, override the _OnInitialUpdate_ virtual member function. The application framework calls this function after the document data has been initialized or read from disk. ([Chapter 17](ch17a.htm) discusses disk file I/O.) _OnInitialUpdate_ should update the view to reflect the current document data.
    
4.  In your derived view class, let your window message handlers, command message handlers and your _OnDraw_ function read and update the document data members directly, using _GetDocument_ to access the document object.

The sequence of events for this simplified document-view environment is as follows.

Application starts

_CMyDocument_ object constructed

_CMyView_ object constructed

View window created

_CMyView::OnCreate_ called (if mapped)

_CMyDocument::OnNewDocument_ called

_CMyView::OnInitialUpdate_ called  

> View object initialized
> 
> View window invalidated
> 
> _CMyView::OnDraw_ called

User edits data

_CMyView_ functions update _CMyDocument_ data members

User exits application

_CMyView_ object destroyed

_CMyDocument_ object destroyed
________________________________________________________________________
6.4.3. - [The CFormView Class](invcpp5/ch16d.htm)
----------------------------------------------------
 The CFormView Class 

The _CFormView_ Class
=====================

The _CFormView_ class is a useful view class that has many of the characteristics of a modeless dialog window. Like a class derived from _CDialog_, a derived _CFormView_ class is associated with a dialog resource that defines the frame characteristics and enumerates the controls. The _CFormView_ class supports the same dialog data exchange and validation (DDX and DDV) functions that you saw in the _CDialog_ examples in [Chapter 6](ch06a.htm).

> WARNING
> 
> If AppWizard generates a Form View dialog, the properties are set correctly, but if you use the dialog editor to make a dialog for a form view, you must specify the following items in the Dialog Properties dialog:
> 
> > Style = Child
> > 
> > Border = None
> > 
> > Visible = unchecked

A _CFormView_ object receives notification messages directly from its controls, and it receives command messages from the application framework. This application framework command-processing ability clearly separates _CFormView_ from _CDialog_, and it makes controlling the view from the frame's main menu or toolbar easy.

The _CFormView_ class is derived from _CView_ (actually, from _CScrollView_) and not from _CDialog_. You can't, therefore, assume that _CDialog_ member functions are supported. _CFormView_ does not have virtual _OnInitDialog_, _OnOK_, and _OnCancel_ functions. _CFormView_ member functions do not call _UpdateData_ and the DDX functions. You have to call _UpdateData_ yourself at the appropriate times, usually in response to control notification messages or command messages.

Even though the _CFormView_ class is not derived from the _CDialog_ class, it is built around the Microsoft Windows dialog. For this reason, you can use many of the _CDialog_ class member functions such as _GotoDlgCtrl_ and _NextDlgCtrl_. All you have to do is cast your _CFormView_ pointer to a _CDialog_ pointer. The following statement, extracted from a member function of a class derived from _CFormView_, sets the focus to a specified control. _GetDlgItem_ is a _CWnd_ function and is thus inherited by the derived _CFormView_ class.

((CDialog\*) this)->GotoDlgCtrl(GetDlgItem(IDC_NAME));

AppWizard gives you the option of using _CFormView_ as the base class for your view. When you select _CFormView_, AppWizard generates an empty dialog with the correct style properties set. The next step is to use ClassWizard to add control notification message handlers, command message handlers, and update command UI handlers. (The example steps starting after Figure 16-2 show you what to do.) You can also define data members and validation criteria.
________________________________________________________________________
6.4.4. - [The CObject Class](invcpp5/ch16e.htm)
----------------------------------------------------
 The CObject Class 

The _CObject_ Class
===================

If you study the MFC library hierarchy, you'll notice that the _CObject_ class is at the top. Most other classes are derived from the _CObject_ root class. When a class is derived from _CObject_, it inherits a number of important characteristics. The many benefits of _CObject_ derivation will become clear as you read the chapters that follow.

In this chapter, you'll see how _CObject_ derivation allows objects to participate in the diagnostic dumping scheme and allows objects to be elements in the collection classes.
________________________________________________________________________
6.4.5. - [Diagnostic Dumping](invcpp5/ch16f.htm)
----------------------------------------------------
 Diagnostic Dumping 

Diagnostic Dumping
==================

The MFC library gives you some useful tools for diagnostic dumping. You enable these tools when you select the Debug target. When you select the Win32 Release target, diagnostic dumping is disabled and the diagnostic code is not linked to your program. All diagnostic output goes to the Debug view in the debugger's Output window.

> TIPS
> 
> To clear diagnostic output from the debugger's Output window, position the cursor in the Output window and click the right mouse button. Then choose Clear from the pop-up menu.

The _TRACE_ Macro
-----------------

You've seen the _TRACE_ macro used throughout the preceding examples in this book. _TRACE_ statements are active whenever the constant __DEBUG_ is defined (when you select the Debug target and when the _afxTraceEnabled_ variable is set to _TRUE_). _TRACE_ statements work like C language _printf_ statements, but they're completely disabled in the release version of the program. Here's a typical _TRACE_ statement:

int nCount = 9;
CString strDesc("total");
TRACE("Count = %d, Description = %s\n", nCount, strDesc);

> NOTE
> 
> The _TRACE_ macro takes a variable number of parameters and is thus easy to use. If you look at the MFC source code, you won't see _TRACE_ macros but rather _TRACE0_, _TRACE1_, _TRACE2_, and _TRACE3_ macros. These macros take 0, 1, 2, and 3 parameters, respectively, and are leftovers from the 16-bit environment, where it was necessary to conserve space in the data segment.

The _afxDump_ Object
--------------------

An alternative to the _TRACE_ statement is more compatible with the C++ language. The MFC _afxDump_ object accepts program variables with a syntax similar to that of _cout_, the C++ output stream object. You don't need complex formatting strings; instead, overloaded operators control the output format. The _afxDump_ output goes to the same destination as the _TRACE_ output, but the _afxDump_ object is defined only in the Debug version of the MFC library. Here is a typical stream-oriented diagnostic statement that produces the same output as the _TRACE_ statement above:

int nCount = 9;
CString strDesc("total");
#ifdef _DEBUG
    afxDump << "Count = " << nCount 
            << ", Description = " << strDesc << "\n";
#endif // _DEBUG

Although both _afxDump_ and _cout_ use the same insertion operator (<<), they don't share any code. The _cout_ object is part of the Microsoft Visual C++ iostream library, and _afxDump_ is part of the MFC library. Don't assume that any of the _cout_ formatting capability is available through _afxDump_.

Classes that aren't derived from _CObject_, such as _CString_, _CTime_, and _CRect_, contain their own overloaded insertion operators for _CDumpContext_ objects. The _CDumpContext_ class, of which _afxDump_ is an instance, includes the overloaded insertion operators for the native C++ data types (_int_, _double_, _char\*_, and so on). The _CDumpContext_ class also contains insertion operators for _CObject_ references and pointers, and that's where things get interesting.

The Dump Context and the _CObject_ Class
----------------------------------------

If the _CDumpContext_ insertion operator accepts _CObject_ pointers and references, it must also accept pointers and references to derived classes. Consider a trivial class, _CAction_, that is derived from _CObject_, as shown here:

class CAction : public CObject
{
public:
    int m_nTime;
};

What happens when the following statement executes?

#ifdef _DEBUG
    afxDump << action; // action is an object of class CAction
#endif // _DEBUG

The virtual _CObject::Dump_ function gets called. If you haven't overridden _Dump_ for _CAction_, you don't get much except for the address of the object. If you have overridden _Dump_, however, you can get the internal state of your object. Here's a _CAction::Dump_ function:

#ifdef _DEBUG
void CAction::Dump(CDumpContext& dc) const
{
    CObject::Dump(dc); // Always call base class function
    dc << "time = " << 
m_nTime << "\n";
}
#endif // _DEBUG

The base class (_CObject_) _Dump_ function prints a line such as this:

a CObject at $4115D4

If you have called the _DECLARE_DYNAMIC_ macro in your _CAction_ class definition and the _IMPLEMENT_DYNAMIC_ macro in your _CAction_ declaration, you will see the name of the class in your dump

a CAction at $4115D4

even if your dump statement looks like this:

#ifdef _DEBUG
    afxDump << (CObject&) action;
#endif // _DEBUG

The two macros work together to include the MFC library runtime class code in your derived _CObject_ class. With this code in place, your program can determine an object's class name at runtime (for the dump, for example) and it can obtain class hierarchy information.

> NOTE
> 
> The (_DECLARE_SERIAL_, _IMPLEMENT_SERIAL_) and (_DECLARE_DYNCREATE_, _IMPLEMENT_DYNCREATE_) macro pairs provide the same runtime class features as those provided by the (_DECLARE_DYNAMIC_, _IMPLEMENT_DYNAMIC_) macro pair.

Automatic Dump of Undeleted Objects
-----------------------------------

With the Debug target selected, the application framework dumps all objects that are undeleted when your program exits. This dump is a useful diagnostic aid, but if you want it to be really useful, you must be sure to delete all your objects, even the ones that would normally disappear after the exit. This object cleanup is good programming discipline.

> NOTE
> 
> The code that adds debug information to allocated memory blocks is now in the Debug version of the CRT (C runtime) library rather than in the MFC library. If you choose to dynamically link MFC, the MSVCRTD DLL is loaded along with the necessary MFC DLLs. When you add the line
> 
> #define new DEBUG_NEW
> 
> at the top of a CPP file, the CRT library lists the filename and line number at which the allocations were made. AppWizard puts this line at the top of all the CPP files it generates.

> **Window Subclassing for Enhanced Data-Entry Control**
> 
> What if you want an edit control (in a dialog or a form view) that accepts only numeric characters? That's easy. You just set the Number style in the control's property sheet. If, however, you want to exclude numeric characters or change the case of alphabetic characters, you must do some programming.
> 
> The MFC library provides a convenient way to change the behavior of any standard control, including the edit control. Actually, there are several ways. You can derive your own classes from _CEdit_, _CListBox_, and so forth (with their own message handler functions) and then create control objects at runtime. Or you can register a special window class, as a Win32 programmer would do, and integrate it into the project's resource file with a text editor. Neither of these methods, however, allows you to use the dialog editor to position controls in the dialog resource.
> 
> The easy way to modify a control's behavior is to use the MFC library's window subclassing feature. You use the dialog editor to position a normal control in a dialog resource, and then you write a new C++ class that contains message handlers for the events that you want to handle yourself. Here are the steps for subclassing an edit control:
> 
> 1.  With the dialog editor, position an edit control in your dialog resource. Assume that it has the child window ID _IDC_EDIT1._
>     
> 2.  Write a new class—for example, _CNonNumericEdit_—derived from _CEdit_. Map the WM_CHAR message and write a handler like this:
>     
>     void CNonNumericEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
>     {
>         if (!isdigit(nChar)) {
>             CEdit::OnChar(nChar, nRepCnt, nFlags);
>         }
>     }
>     
> 3.  In your derived dialog or form view class header, declare a data member of class _CNonNumericEdit_ in this way:
>     
>     private:
>         CNonNumericEdit m_nonNumericEdit;
>     
> 4.  If you're working with a dialog class, add the following line to your _OnInitDialog_ override function:
>     
>     m_nonNumericEdit.SubclassDlgItem(IDC_EDIT1, this);
>     
> 5.  If you're working with a form view class, add the following code to your _OnInitialUpdate_ override function:
>     
>     if (m_nonNumericEdit.m_hWnd == NULL) {
>         m_nonNumericEdit.SubclassDlgItem(IDC_EDIT1, this);
>     }
>     
> 
> The _CWnd::SubclassDlgItem_ member function ensures that all messages are routed through the application framework's message dispatch system before being sent to the control's built-in window procedure. This technique is called dynamic subclassing and is explained in more detail in Technical Note #14 in the online documentation.
> 
> The code in the preceding steps only accepts or rejects a character. If you want to change the value of a character, your handler must call _CWnd::DefWindowProc_, which bypasses some MFC logic that stores parameter values in thread object data members. Here's a sample handler that converts lowercase characters to uppercase:
> 
> void CUpperEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
> {
>     if (islower(nChar)) {
>         nChar = toupper(nChar);
>     }
>     DefWindowProc(WM_CHAR, (WPARAM) nChar,
>                   (LPARAM) (nRepCnt | (nFlags << 16)));
> }
> 
> You can also use window subclassing to handle reflected messages, which were mentioned in [Chapter 6](ch06a.htm). If an MFC window class doesn't map a message from one of its child controls, the framework reflects the message back to the control. Technical Note #62 in the online documentation explains the details.
> 
> If you need an edit control with a yellow background, for example, you can derive a class _CYellowEdit_ from _CEdit_ and use ClassWizard to map the =WM_CTLCOLOR message in _CYellowEdit_. (ClassWizard lists the message name with an equal sign in front to indicate that it is reflected.) The handler code, shown below, is substantially the same as the nonreflected WM_CTLCOLOR handler. (Member variable _m_hYellowBrush_ is defined in the control class's constructor.)
> 
> HBRUSH CYellowEdit::CtlColor(CDC\* pDC, UINT nCtlColor)
> {
>     pDC->SetBkColor(RGB(255, 255, 0)); // yellow
>     return m_hYellowBrush;
> }
________________________________________________________________________
6.4.6. - [The EX16A Example](invcpp5/ch16g.htm)
----------------------------------------------------
 The EX16A Example 

The EX16A Example
=================

The first of this chapter's two examples shows a very simple document-view interaction. The _CEx16aDoc_ document class, derived from _CDocument_, allows for a single embedded _CStudent_ object. The _CStudent_ class represents a student record composed of a _CString_ name and an integer grade. The _CEx16aView_ view class is derived from _CFormView_. It is a visual representation of a student record that has edit controls for the name and grade. The default Enter pushbutton updates the document with data from the edit controls. Figure 16-1 shows the EX16A program window.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F16og01x.gif)]

**Figure 16-1.** _The EX16A program in action._

Figure 16-2 shows the code for the _CStudent_ class. Most of the class's features serve EX16A, but a few items carry forward to EX16B and the programs discussed in [Chapter 17](ch17a.htm). For now, take note of the two data members, the default constructor, the operators, and the _Dump_ function declaration. The _DECLARE_DYNAMIC_ and _IMPLEMENT_DYNAMIC_ macros ensure that the class name is available for the diagnostic dump.

**STUDENT.H**

// student.h

#ifndef _INSIDE_VISUAL_CPP_STUDENT
#define _INSIDE_VISUAL_CPP_STUDENT
class CStudent : public CObject
{
    DECLARE_DYNAMIC(CStudent)
public:
    CString m_strName;
    int m_nGrade;
    
    CStudent()
    {
        m_nGrade = 0;
    }
    
    CStudent(const char\* szName, int nGrade) : m_strName(szName)
    {
        m_nGrade = nGrade;
    }

    CStudent(const CStudent& s) : m_strName(s.m_strName)
    {
        // copy constructor
        m_nGrade = s.m_nGrade;
    }

    const CStudent& operator =(const CStudent& s)
    {
        m_strName = s.m_strName;
        m_nGrade = s.m_nGrade;
        return \*this;
    }

    BOOL operator ==(const CStudent& s) const
    {
        if ((m_strName == s.m_strName) && (m_nGrade == s.m_nGrade)) {
            return TRUE;
        }
        else {
            return FALSE;
        }
    }

    BOOL operator !=(const CStudent& s) const
    {
        // Let's make use of the operator we just defined!
        return !(\*this == s);
    }
#ifdef _DEBUG
    void Dump(CDumpContext& dc) const;
#endif // _DEBUG
};

#endif // _INSIDE_VISUAL_CPP_STUDENT

**Figure 16-2.** _The_ CPersistentView _class listing._

**STUDENT.CPP**

#include "stdafx.h"
#include "student.h"

IMPLEMENT_DYNAMIC(CStudent, CObject)

#ifdef _DEBUG
void CStudent::Dump(CDumpContext& dc) const
{
    CObject::Dump(dc);
    dc << "m_strName = " << m_strName << "\nm_nGrade = " <<m_nGrade;
}
#endif // _DEBUG

Follow these steps to build the EX16A example:

2.  **Run AppWizard to generate \vcpp32\ex16a\ex16a.** In the Step 6 page, change the view's base class to _CFormView_, as shown here.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G16og01x.gif)]
    
    The options and the default class names are shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G16og02x.GIF)
    
3.  **Use the menu editor to replace the Edit menu options.** Delete the current Edit menu items and replace them with a Clear All option, as shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G16og03.gif)
    
    Use the default constant _ID_EDIT_CLEAR_ALL_, which is assigned by the application framework. A menu prompt automatically appears.
    
4.  **Use the dialog editor to modify the _IDD_EX16A_FORM_ dialog.** Open the AppWizard-generated dialog _IDD_EX16A_FORM_, and add controls as shown below.
    
    Be sure that the Styles properties are set exactly as shown in the Dialog Properties dialog (Style = Child; Border = None) and that Visible is unchecked.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G16og04x.GIF)
    
    Use the following IDs for the controls.
    
    **Control**
    
    **ID**
    
    Name edit control
    
    _IDC_NAME_
    
    Grade edit control
    
    _IDC_GRADE_
    
    Enter pushbutton
    
    _IDC_ENTER_
    
5.  **Use ClassWizard to add message handlers for _CEx16aView_.** Select the _CEx16aView_ class, and then add handlers for the following messages. Accept the default function names.
    
    **Object ID**
    
    **Message**
    
    **Member Function**
    
    _IDC_ENTER_
    
    BN_CLICKED
    
    _OnEnter_
    
    _ID_EDIT_CLEAR_ALL_
    
    COMMAND
    
    _OnEditClearAll_
    
    _ID_EDIT_CLEAR_ALL_
    
    UPDATE_COMMAND_UI
    
    _OnUpdateEditClearAll_
    
6.  **Use ClassWizard to add variables for _CEx16aView_.** Click on the Member Variables tab in the MFC ClassWizard dialog, and then add the following variables.
    
    **Control ID**
    
    **Member Variable**
    
    **Category**
    
    **Variable Type**
    
    _IDC_GRADE_
    
    _m_nGrade_
    
    Value
    
    _int_
    
    _IDC_NAME_
    
    _m_strName_
    
    Value
    
    _CString_
    
    For _m_nGrade_, enter a minimum value of 0 and a maximum value of 100. Notice that ClassWizard generates the code necessary to validate data entered by the user.
    
7.  **Add a prototype for the helper function _UpdateControlsFromDoc_.**In the ClassView window, right-click on _CEx16aView_ and choose Add Member Function. Fill out the dialog box to add the following function:
    
    **private:
        void UpdateControlsFromDoc();**
    
8.  **Edit the file Ex16aView.cpp.** AppWizard generated the skeleton _OnInitialUpdate_ function, and ClassView generated the skeleton _UpdateControlsFromDoc_ function. _UpdateControlsFromDoc_ is a private helper member function that transfers data from the document to the _CEx16aView_ data members and then to the dialog edit controls. Edit the code as shown here:
    
    void CEx16aView::OnInitialUpdate()
    {   **// called on startup
        UpdateControlsFromDoc();**
    }
    void CEx16aView::UpdateControlsFromDoc()
    {   **// called from OnInitialUpdate and OnEditClearAll
        CEx16aDoc\* pDoc = GetDocument();
        m_nGrade = pDoc->m_student.m_nGrade;
        m_strName = pDoc->m_student.m_strName;  
        UpdateData(FALSE); // calls DDX**
    }
    
    The _OnEnter_ function replaces the _OnOK_ function you'd expect to see in a dialog class. The function transfers data from the edit controls to the view's data members and then to the document. Add the boldface code shown here:
    
    void CEx16aView::OnEnter()
    {
        **CEx16aDoc\* pDoc = GetDocument();
        UpdateData(TRUE);
        pDoc->m_student.m_nGrade = m_nGrade;
        pDoc->m_student.m_strName = m_strName;**
    }
    
    In a complex multiview application, the Edit Clear All command would be routed directly to the document. In this simple example, it's routed to the view. The update command UI handler disables the menu item if the document's student object is already blank. Add the following boldface code:
    
    void CEx16aView::OnEditClearAll()
    {
        GetDocument()->m_student = CStudent(); // "blank" student object
        UpdateControlsFromDoc();
    }
    void CEx16aView::OnUpdateEditClearAll(CCmdUI\* pCmdUI)
    {
        pCmdUI->Enable(GetDocument()->m_student != CStudent()); // blank?
    }
    
9.  **Edit the EX16A project to add the files for _CStudent_.** Choose Add To Project from the Project menu, choose Files from the submenu, and select the Student.h header and the Student.cpp source code files. Visual C++ will add the files' names to the project's DSP file so that they will be compiled when you build the project.
    
10.  **Add a _CStudent_ data member to the _CEx16aDoc_ class.** Use ClassView to add the following data member, and the _#include_ will be added automatically.
    
    **public:
        CStudent m_student;**
    
    The _CStudent_ constructor is called when the document object is constructed, and the _CStudent_ destructor is called when the document object is destroyed.
    
11.  **Edit the Ex16aDoc.cpp file.** Use the _CEx16aDoc_ constructor to initialize the student object, as shown here:
    
    CEx16aDoc::CEx16aDoc() : m_student("default value", 0)
    {
        TRACE("Document object constructed\n");
    }
    
    We can't tell whether the EX16A program works properly unless we dump the document when the program exits. We'll use the destructor to call the document's _Dump_ function, which calls the _CStudent::Dump_ function shown here:
    
    CEx16aDoc::~CEx16aDoc()
    {
    #ifdef _DEBUG
        Dump(afxDump);
    #endif // _DEBUG
    }
    
    void CEx16aDoc::Dump(CDumpContext& dc) const
    {
        CDocument::Dump(dc);
        dc << "\n" << m_student << "\n";
    }
    
12.  **Build and test the EX16A application.** Type a name and a grade, and then click Enter. Now exit the application. Does the Debug window show messages similar to those shown here?
    
    a CEx16aDoc at $411580
    m_strTitle = Untitled
    m_strPathName = 
    m_bModified = 0
    m_pDocTemplate = $4113A0
    
    a CStudent at $4115D4 
    m_strName = Sullivan, Walter
    m_nGrade = 78
    

> NOTE
> 
> To see these messages, you must compile the application with the Win32 Debug target selected and you must run the program from the debugger.
________________________________________________________________________
6.4.7. - [A More Advanced Document-View Interaction](invcpp5/ch16h.htm)
----------------------------------------------------
 A More Advanced Document-View Interaction 

A More Advanced Document-View Interaction
=========================================

If you're laying the groundwork for a multiview application, the document-view interaction must be more complex than the simple interaction in example EX16A. The fundamental problem is this: the user edits in view #1, so view #2 (and any other views) must be updated to reflect the changes. Now you need the _UpdateAllViews_ and _OnUpdate_ functions because the document is going to act as the clearinghouse for all view updates. The development steps are shown here:

1.  In your derived document class header file (generated by AppWizard), declare your document's data members. If you want to, you can make these data members private and you can define member functions to access them or declare the view class as a friend of the document class.
    
2.  In your derived view class, use ClassWizard to override the _OnUpdate_ virtual member function. The application framework calls this function whenever the document data has changed for any reason. _OnUpdate_ should update the view with the current document data.
    
3.  Evaluate all your command messages. Determine whether each one is document-specific or view-specific. (A good example of a document-specific command is the Clear All command on the Edit menu.) Now map the commands to the appropriate classes.
    
4.  In your derived view class, allow the appropriate command message handlers to update the document data. Be sure these message handlers call the _CDocument::UpdateAllViews_ function before they exit. Use the type-safe version of the _CView::GetDocument_ member function to access the view's document.
    
5.  In your derived document class, allow the appropriate command message handlers to update the document data. Be sure that these message handlers call the _CDocument::UpdateAllViews_ function before they exit.

The sequence of events for the complex document-view interaction is shown here.

> Application starts               _CMyDocument_ object constructed  
>                                         _CMyView_ object constructed  
>                                         Other view objects constructed  
>                                         View windows created  
>                                         _CMyView::OnCreate_ called (if mapped)  
>                                         _CDocument::OnNewDocument_ called  
>                                         _CView::OnInitialUpdate_ called  
>                                               Calls _CMyView::OnUpdate_  
>                                               Initializes the view  
> User executes                   _CMyView_ functions update _CMyDocument_  
> view command                  data members  
>                                               Call _CDocument::UpdateAllViews_  
>                                               Other views' _OnUpdate_ functions called  
> User executes                   _CMyDocument_ functions update data  
> document command          members  
>                                               Call _CDocument::UpdateAllViews_  
>                                               _CMyView::OnUpdate_ called  
>                                               Other views' _OnUpdate_ functions called  
> User exits application        View objects destroyed  
>                                               _CMyDocument_ object destroyed
________________________________________________________________________
6.4.8. - [The CDocument::DeleteContents Function](invcpp5/ch16i.htm)
----------------------------------------------------
 The CDocument::DeleteContents Function 

The _CDocument::DeleteContents_ Function
========================================

At some point, you'll need a function to delete the contents of your document. You could write your own private member function, but it happens that the application framework declares a virtual _DeleteContents_ function for the _CDocument_ class. The application framework calls your overridden _DeleteContents_ function when the document is closed and as you'll see in the next chapter, at other times as well.
________________________________________________________________________
6.4.9. - [The CObList Collection Class](invcpp5/ch16j.htm)
----------------------------------------------------
 The CObList Collection Class 

The _CObList_ Collection Class
==============================

Once you get to know the collection classes, you'll wonder how you ever got along without them. The _CObList_ class is a useful representative of the collection class family. If you're familiar with this class, it's easy to learn the other list classes, the array classes, and the map classes.

You might think that collections are something new, but the C programming language has always supported one kind of collection—the array. C arrays must be fixed in size, and they do not support insertion of elements. Many C programmers have written function libraries for other collections, including linked lists, dynamic arrays, and indexed dictionaries. For implementing collections, the C++ class is an obvious and better alternative than a C function library. A list object, for example, neatly encapsulates the list's internal data structures.

The _CObList_ class supports ordered lists of pointers to objects of classes derived from _CObject_. Another MFC collection class, _CPtrList_, stores _void_ pointers instead of _CObject_ pointers. Why not use _CPtrList_ instead? The _CObList_ class offers advantages for diagnostic dumping, which you'll see in this chapter, and for serialization, which you'll see in the next chapter. One important feature of _CObList_ is that it can contain mixed pointers. In other words, a _CObList_ collection can hold pointers to both _CStudent_ objects and _CTeacher_ objects, assuming that both _CStudent_ and _CTeacher_ were derived from _CObject_.

Using the _CObList_ Class for a First-In, First-Out List
--------------------------------------------------------

One of the easiest ways to use a _CObList_ object is to add new elements to the tail, or bottom, of the list and to remove elements from the head, or top, of the list. The first element added to the list will always be the first element removed from the head of the list. Suppose you're working with element objects of class _CAction_, which is your own custom class derived from _CObject_. A command-line program that puts five elements into a list and then retrieves them in the same sequence is shown here:

#include <afx.h>
#include <afxcoll.h>

class CAction : public CObject
{
private:
    int m_nTime;
public:
    CAction(int nTime) { m_nTime = nTime; } // Constructor stores
                                            //  integer time value
    void PrintTime() { TRACE("time = %d\n", m_nTime); }
};

int main()
{
    CAction\* pAction;
    CObList actionList; // action list constructed on stack
    int i;

    // inserts action objects in sequence {0, 1, 2, 3, 4}
    for (i = 0; i < 5; i++) {
        pAction = new CAction(i);
        actionList.AddTail(pAction); // no cast necessary for pAction
    }

    // retrieves and removes action objects in sequence {0, 1, 2, 3, 4}
    while (!actionList.IsEmpty()) {
        pAction =                               // cast required for
            (CAction\*) actionList.RemoveHead(); //  return value
        pAction->PrintTime();
        delete pAction;
    }

    return 0;
}

Here's what's going on in the program. First a _CObList_ object, _actionList_, is constructed. Then the _CObList::AddTail_ member function inserts pointers to newly constructed _CAction_ objects. No casting is necessary for _pAction_ because _AddTail_ takes a _CObject_ pointer parameter and _pAction_ is a pointer to a derived class.

Next the _CAction_ object pointers are removed from the list of the objects deleted. A cast is necessary for the returned value of _RemoveHead_ because _RemoveHead_ returns a _CObject_ pointer that is higher in the class hierarchy than _CAction_.

When you remove an object pointer from a collection, the object is not automatically deleted. The _delete_ statement is necessary for deleting the _CAction_ objects.

_CObList_ Iteration—The _POSITION_ Variable
-------------------------------------------

Suppose you want to iterate through the elements in a list. The _CObList_ class provides a _GetNext_ member function that returns a pointer to the "next" list element, but using it is a little tricky. _GetNext_ takes a parameter of type _POSITION_, which is a 32-bit variable. The _POSITION_ variable is an internal representation of the retrieved element's position in the list. Because the _POSITION_ parameter is declared as a reference (&), the function can change its value.

_GetNext_ does the following:

1.  It returns a pointer to the "current" object in the list, identified by the incoming value of the _POSITION_ parameter.
    
2.  It increments the value of the _POSITION_ parameter to the next list element.

Here's what a _GetNext_ loop looks like, assuming you're using the list generated in the previous example:

CAction\* pAction;
POSITION pos = actionList.GetHeadPosition();
while (pos != NULL) {
    pAction = (CAction\*) actionList.GetNext(pos);
    pAction->PrintTime();
}

Now suppose you have an interactive Windows-based application that uses toolbar buttons to sequence forward and backward through the list one element at a time. You can't use _GetNext_ to retrieve the entry because _GetNext_ always increments the _POSITION_ variable and you don't know in advance whether the user is going to want the next element or the previous element. Here's a sample view class command message handler function that gets the next list entry. In the _CMyView_ class, _m_actionList_ is an embedded _CObList_ object and the _m_position_ data member is a _POSITION_ variable that holds the current list position.

CMyView::OnCommandNext()
{
    POSITION pos;
    CAction\*  pAction;

    if ((pos = m_position) != NULL) {
        m_actionList.GetNext(pos);
        if (pos != NULL) { // pos is NULL at end of list
            pAction = (CAction\*) m_actionList.GetAt(pos);
            pAction->PrintTime();
            m_position = pos;
        }
        else {
            AfxMessageBox("End of list reached");
        }
    }
}

_GetNext_ is now called first to increment the list position, and the _CObList::GetAt_ member function is called to retrieve the entry. The _m_position_ variable is updated only when we're sure we're not at the tail of the list.

The _CTypedPtrList_ Template Collection Class
---------------------------------------------

The _CObList_ class works fine if you want a collection to contain mixed pointers. If, on the other hand, you want a type-safe collection that contains only one type of object pointer, you should look at the MFC library template pointer collection classes. _CTypedPtrList_ is a good example. Templates are a relatively new C++ language element, introduced by Microsoft Visual C++ version 2.0. _CTypedPtrList_ is a template class that you can use to create a list of any pointers to objects of any specified class. To make a long story short, you use the template to create a custom derived list class, using either _CPtrList_ or _CObList_ as a base class.

To declare an object for _CAction_ pointers, you write the following line of code:

CTypedPtrList<CObList, CAction\*> m_actionList;

The first parameter is the base class for the collection, and the second parameter is the type for parameters and return values. Only _CPtrList_ and _CObList_ are permitted for the base class because those are the only two MFC library pointer list classes. If you are storing objects of classes derived from _CObject_, you should use _CObList_ as your base class; otherwise, use _CPtrList_.

By using the template as shown above, the compiler ensures that all list member functions return a _CAction_ pointer. Thus, you can write the following code:

pAction = m_actionList.GetAt(pos); // no cast required

If you want to clean up the notation a little, use a _typedef_ statement to generate what looks like a class, as shown here:

typedef CTypedPtrList<CObList, CAction\*> CActionList;

Now you can declare _m_actionList_ as follows:

CActionList m_actionList;

The Dump Context and Collection Classes
---------------------------------------

The _Dump_ function for _CObList_ and the other collection classes has a useful property. If you call _Dump_ for a collection object, you can get a display of each object in the collection. If the element objects use the _DECLARE_DYNAMIC_ and _IMPLEMENT_DYNAMIC_ macros, the dump will show the class name for each object.

The default behavior of the collection _Dump_ functions is to display only class names and addresses of element objects. If you want the collection _Dump_ functions to call the _Dump_ function for each element object, you must, somewhere at the start of your program, make the following call:

#ifdef _DEBUG
    afxDump.SetDepth(1);
#endif

Now the statement

#ifdef _DEBUG
    afxDump << actionList;
#endif

produces output such as this:

a CObList at $411832
with 4 elements
    a CAction at $412CD6
time = 0
    a CAction at $412632
time = 1
    a CAction at $41268E
time = 2
    a CAction at $4126EA
time = 3

If the collection contains mixed pointers, the virtual _Dump_ function is called for the object's class and the appropriate class name is printed.
________________________________________________________________________
6.4.10. - [The EX16B Example](invcpp5/ch16k.htm)
----------------------------------------------------
 The EX16B Example 

The EX16B Example
=================

This second SDI example improves on EX16A in the following ways:

*   Instead of a single embedded _CStudent_ object, the document now contains a list of _CStudent_ objects. (Now you see the reason for using the _CStudent_ class instead of making _m_strName_ and _m_nGrade_ data members of the document.)
    
*   Toolbar buttons allow the user to sequence through the list.
    
*   The application is structured to allow the addition of extra views. The Edit Clear All command is now routed to the document object, so the document's _UpdateAllViews_ function and the view's _OnUpdate_ function are brought into play.
    
*   The student-specific view code is isolated so that the _CEx16bView_ class can later be transformed into a base class that contains only general-purpose code. Derived classes can override selected functions to accommodate lists of application-specific objects.

The EX16B window, shown in Figure 16-3, looks a little different from the EX16A window shown in Figure 16-1. The toolbar buttons are enabled only when appropriate. The Next (arrow-down graphic) button, for example, is disabled when we're positioned at the bottom of the list.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f16og03x.gif)]

**Figure 16-3.** _The EX16B program in action._

The toolbar buttons function as follows.

**Button**

**Function**

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G16OG05x.gif)]

Retrieves the first student record

![](c:/dl/books/windows/msvc5th/invcpp5/images/G16OG06.GIF)

Retrieves the last student record

![](c:/dl/books/windows/msvc5th/invcpp5/images/G16OG07.GIF)

Retrieves the previous student record

![](c:/dl/books/windows/msvc5th/invcpp5/images/G16OG08.GIF)

Retrieves the next student record

![](c:/dl/books/windows/msvc5th/invcpp5/images/G16OG09.GIF)

Deletes the current student record

![](c:/dl/books/windows/msvc5th/invcpp5/images/G16OG10.GIF)

Inserts a new student record

The Clear button in the view window clears the contents of the Name and Grade edit controls. The Clear All command on the Edit menu deletes all the student records in the list and clears the view's edit controls.

This example deviates from the step-by-step format in the previous examples. Because there's now more code, we'll simply list selected code and the resource requirements. In the listing figures, boldface code indicates additional code or other changes that you enter in the output from AppWizard and ClassWizard. The frequent use of _TRACE_ statements lets you follow the program's execution in the debugging window.

Resource Requirements
---------------------

The file ex16b.rc defines the application's resources as follows.

### Toolbar

The toolbar (visible in Figure 16-3) was created by erasing the Edit Cut, Copy, and Paste tiles (fourth, fifth, and sixth from the left) and replacing them with six new patterns. The Flip Vertical command (on the Image menu) was used to duplicate some of the tiles. The ex16b.rc file defines the linkage between the command IDs and the toolbar buttons.

### Student Menu

Having menu options that correspond to the new toolbar buttons isn't absolutely necessary. (ClassWizard allows you to map toolbar button commands just as easily as menu commands.) However, most applications for Microsoft Windows have menu options for all commands, so users generally expect them.

### Edit Menu

On the Edit menu, the clipboard menu items are replaced by the Clear All menu item. See step 2 for an illustration of the Edit menu.

### The _IDD_STUDENT_ Dialog Template

The _IDD_STUDENT_ dialog template, shown here, is similar to the EX16A dialog shown in Figure 16-1 except that the Enter pushbutton has been replaced by the Clear pushbutton.

![](c:/dl/books/windows/msvc5th/invcpp5/images/G16OG11.GIF)

The following IDs identify the controls.

**Control**

**ID**

Name edit control

_IDC_NAME_

Grade edit control

_IDC_GRADE_

Clear pushbutton

_IDC_CLEAR_

The controls' styles are the same as for the EX16A program.

Code Requirements
-----------------

Here's a list of the files and classes in the EX16B example.

**Header File**

**Source Code File**

**Classes**

**Description**

ex16b.h

ex16b.cpp

_CEx16bApp_

Application class (from AppWizard)

 

 

_CAboutDlg_

About dialog

MainFrm.h

MainFrm.cpp

_CMainFrame_

SDI main frame

StuDoc.h

StuDoc.cpp

_CStudentDoc_

Student document

StuView.h

StuView.cpp

_CStudentView_

Student form view (derived from _CFormView_)

Student.h

Student.cpp

_CStudent_

Student record (similar to EX16A)

StdAfx.h

StdAfx.cpp

Includes the standard precompiled headers

 

### _CEx16bApp_

The files ex16b.cpp and ex16b.h are standard AppWizard output.

### _CMainFrame_

The code for the _CMainFrame_ class in MainFrm.cpp is standard AppWizard output.

### _CStudent_

This is the code from EX16A, except for the following line added at the end of Student.h:

**typedef CTypedPtrList<CObList, CStudent\*> CStudentList;**

> NOTE
> 
> Use of the MFC template collection classes requires the following statement in StdAfx.h:
> 
> **#include <afxtempl.h>**

### _CStudentDoc_

AppWizard originally generated the _CStudentDoc_ class. Figure 16-4 shows the code used in the EX16B example.

**STUDOC.H**

// StuDoc.h : interface of the CStudentDoc class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STUDOC_H__4D011047_7E1C_11D0_8FE0_00C04FC2A0C2__INCLUDED_)
#define AFX_STUDOC_H__4D011047_7E1C_11D0_8FE0_00C04FC2A0C2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

**#include "student.h"**

class CStudentDoc : public CDocument
{
protected: // create from serialization only
    CStudentDoc();
    DECLARE_DYNCREATE(CStudentDoc)

// Attributes
public:
    **CStudentList\* GetList() {
        return &m_studentList;
    }**

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CStudentDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void Serialize(CArchive& ar);
    virtual void DeleteContents();
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CStudentDoc();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CStudentDoc)
    afx_msg void OnEditClearAll();
    afx_msg void OnUpdateEditClearAll(CCmdUI\* pCmdUI);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
**private:
    CStudentList m_studentList;**
};

//////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations
//  immediately before the previous line.

#endif // !defined(AFX_STUDOC_H__4D011047_7E1C_11D0_8FE0_00C04FC2A0C2__INCLUDED_)

**STUDOC.CPP**

// StuDoc.cpp : implementation of the CStudentDoc class
//

#include "stdafx.h"
#include "ex16b.h"

#include "StuDoc.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// CStudentDoc

IMPLEMENT_DYNCREATE(CStudentDoc, CDocument)

BEGIN_MESSAGE_MAP(CStudentDoc, CDocument)
    //{{AFX_MSG_MAP(CStudentDoc)
    ON_COMMAND(ID_EDIT_CLEAR_ALL, OnEditClearAll)
    ON_UPDATE_COMMAND_UI(ID_EDIT_CLEAR_ALL, OnUpdateEditClearAll)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////////////////////////////////////////////////
// CStudentDoc construction/destruction

CStudentDoc::CStudentDoc()
{
    **TRACE("Entering CStudentDoc constructor\n");
#ifdef _DEBUG
    afxDump.SetDepth(1); // Ensure dump of list elements
#endif // _DEBUG**
}

CStudentDoc::~CStudentDoc()
{
}

BOOL CStudentDoc::OnNewDocument()
{
    **TRACE("Entering CStudentDoc::OnNewDocument\n");**
    if (!CDocument::OnNewDocument())
        return FALSE;

    // TODO: add reinitialization code here
    // (SDI documents will reuse this document)

    return TRUE;
}
//////////////////////////////////////////////////////////////////////
// CStudentDoc serialization

void CStudentDoc::Serialize(CArchive& ar)
{
    if (ar.IsStoring())
    {
        // TODO: add storing code here
    }
    else
    {
        // TODO: add loading code here
    }
}

//////////////////////////////////////////////////////////////////////
// CStudentDoc diagnostics

#ifdef _DEBUG
void CStudentDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CStudentDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
    **dc << "\n" << m_studentList << "\n";**
}
#endif //_DEBUG

//////////////////////////////////////////////////////////////////////
// CStudentDoc commands

void CStudentDoc::DeleteContents() 
{
**#ifdef _DEBUG
    Dump(afxDump);
#endif
    while (m_studentList.GetHeadPosition()) {
        delete m_studentList.RemoveHead();
    }**
}
void CStudentDoc::OnEditClearAll() 
{
    **DeleteContents();
    UpdateAllViews(NULL);**
}

void CStudentDoc::OnUpdateEditClearAll(CCmdUI\* pCmdUI) 
{
    **pCmdUI->Enable(!m_studentList.IsEmpty());**
}

**Figure 16-4.** _The_ CStudentDoc _class listing._

### ClassWizard and _CStudentDoc_

The Edit Clear All command is handled in the document class. The following message handlers were added through ClassWizard.

**Object ID**

**Message**

**Member Function**

_ID_EDIT_CLEAR_ALL_

COMMAND

_OnEditClearAll_

_ID_EDIT_CLEAR_ALL_

ON_UPDATE_COMMAND_UI

_OnUpdateEditClearAll_

### Data Members

The document class provides for an embedded _CStudentList_ object, the _m_studentList_ data member, which holds pointers to _CStudent_ objects. The list object is constructed when the _CStudentDoc_ object is constructed, and it is destroyed at program exit. _CStudentList_ is a _typedef_ for a _CTypedPtrList_ for _CStudent_ pointers.

### Constructor

The document constructor sets the depth of the dump context so that a dump of the list causes dumps of the individual list elements.

### _GetList_

The inline _GetList_ function helps isolate the view from the document. The document class must be specific to the type of object in the list—in this case, objects of the class _CStudent_. A generic list view base class, however, can use a member function to get a pointer to the list without knowing the name of the list object.

### _DeleteContents_

The _DeleteContents_ function is a virtual override function that is called by other document functions and by the application framework. Its job is to remove all student object pointers from the document's list and to delete those student objects. An important point to remember here is that SDI document objects are reused after they are closed. _DeleteContents_ also dumps the student list.

### _Dump_

AppWizard generates the _Dump_ function skeleton between the lines _#ifdef _DEBUG_ and _#endif_. Because the _afxDump_ depth was set to 1 in the document constructor, all the _CStudent_ objects contained in the list are dumped.

### _CStudentView_

Figure 16-5 shows the code for the _CStudentView_ class. This code will be carried over into the next two chapters.

**STUVIEW.H**

// StuView.h : interface of the CStudentView class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STUVIEW_H__4D011049_7E1C_11D0_8FE0_00C04FC2A0C2__INCLUDED_)
#define AFX_STUVIEW_H__4D011049_7E1C_11D0_8FE0_00C04FC2A0C2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CStudentView : public CFormView
{
**protected:
    POSITION      m_position; // current position in document list
    CStudentList\* m_pList;    // copied from document**

protected: // create from serialization only
    CStudentView();
    DECLARE_DYNCREATE(CStudentView)

public:
    //{{AFX_DATA(CStudentView)
    enum { IDD = IDD_STUDENT };
    int     m_nGrade;
    CString m_strName;
    //}}AFX_DATA

// Attributes
public:
    CStudentDoc\* GetDocument();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CStudentView)
    public:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    protected:
    virtual void DoDataExchange(CDataExchange\* pDX); // DDX/DDV support
    virtual void OnInitialUpdate(); // called first time after construct
    virtual void OnUpdate(CView\* pSender, LPARAM lHint, CObject\* pHint);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CStudentView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:
    **virtual void ClearEntry();
    virtual void InsertEntry(POSITION position);
    virtual void GetEntry(POSITION position);**

// Generated message map functions
protected:
    //{{AFX_MSG(CStudentView)
    afx_msg void OnClear();
    afx_msg void OnStudentHome();
    afx_msg void OnStudentEnd();
    afx_msg void OnStudentPrev();
    afx_msg void OnStudentNext();
    afx_msg void OnStudentIns();
    afx_msg void OnStudentDel();
    afx_msg void OnUpdateStudentHome(CCmdUI\* pCmdUI);
    afx_msg void OnUpdateStudentEnd(CCmdUI\* pCmdUI);
    afx_msg void OnUpdateStudentDel(CCmdUI\* pCmdUI);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in StuView.cpp
inline CStudentDoc\* CStudentView::GetDocument()
   { return (CStudentDoc\*)m_pDocument; }
#endif

//////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations
//  immediately before the previous line.

#endif // !defined(AFX_STUVIEW_H__4D011049_7E1C_11D0_8FE0_00C04FC2A0C2__INCLUDED_)

**STUVIEW.CPP**

// StuView.cpp : implementation of the CStudentView class
//

#include "stdafx.h"
#include "ex16b.h"

#include "StuDoc.h"
#include "StuView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__ ;
#endif

//////////////////////////////////////////////////////////////////////
// CStudentView

IMPLEMENT_DYNCREATE(CStudentView, CFormView)
BEGIN_MESSAGE_MAP(CStudentView, CFormView)
    //{{AFX_MSG_MAP(CStudentView)
    ON_BN_CLICKED(IDC_CLEAR, OnClear)
    ON_COMMAND(ID_STUDENT_HOME, OnStudentHome)
    ON_COMMAND(ID_STUDENT_END, OnStudentEnd)
    ON_COMMAND(ID_STUDENT_PREV, OnStudentPrev)
    ON_COMMAND(ID_STUDENT_NEXT, OnStudentNext)
    ON_COMMAND(ID_STUDENT_INS, OnStudentIns)
    ON_COMMAND(ID_STUDENT_DEL, OnStudentDel)
    ON_UPDATE_COMMAND_UI(ID_STUDENT_HOME, OnUpdateStudentHome)
    ON_UPDATE_COMMAND_UI(ID_STUDENT_END, OnUpdateStudentEnd)
    ON_UPDATE_COMMAND_UI(ID_STUDENT_PREV, OnUpdateStudentHome)
    ON_UPDATE_COMMAND_UI(ID_STUDENT_NEXT, OnUpdateStudentEnd)
    ON_UPDATE_COMMAND_UI(ID_STUDENT_DEL, OnUpdateStudentDel)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////////////////////////////////////////////////
// CStudentView construction/destruction

CStudentView::CStudentView()
    : CFormView(CStudentView::IDD)
{
    **TRACE("Entering CStudentView constructor\n");**
    //{{AFX_DATA_INIT(CStudentView)
    m_nGrade = 0;
    m_strName = _T("");
    //}}AFX_DATA_INIT
    **m_position = NULL;**
}

CStudentView::~CStudentView()
{
}

void CStudentView::DoDataExchange(CDataExchange\* pDX)
{
    CFormView::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CStudentView)
    DDX_Text(pDX, IDC_GRADE, m_nGrade);
    DDV_MinMaxInt(pDX, m_nGrade, 0, 100);
    DDX_Text(pDX, IDC_NAME, m_strName);
    DDV_MaxChars(pDX, m_strName, 20);
    //}}AFX_DATA_MAP
}
BOOL CStudentView::PreCreateWindow(CREATESTRUCT& cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs
    return CFormView::PreCreateWindow(cs);
}

void CStudentView::OnInitialUpdate() 
{
    **TRACE("Entering CStudentView::OnInitialUpdate\n");
    m_pList = GetDocument()->GetList();**
    CFormView::OnInitialUpdate();
}

//////////////////////////////////////////////////////////////////////
// CStudentView diagnostics

#ifdef _DEBUG
void CStudentView::AssertValid() const
{
    CFormView::AssertValid();
}

void CStudentView::Dump(CDumpContext& dc) const
{
    CFormView::Dump(dc);
}

CStudentDoc\* CStudentView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CStudentDoc)));
    return (CStudentDoc\*)m_pDocument;
}
#endif //_DEBUG

//////////////////////////////////////////////////////////////////////
// CStudentView message handlers

void CStudentView::OnClear() 
{
    **TRACE("Entering CStudentView::OnClear\n");
    ClearEntry();**
}

void CStudentView::OnUpdate(CView\* pSender, LPARAM lHint,
                            CObject\* pHint) 
{
    **// called by OnInitialUpdate and by UpdateAllViews
    TRACE("Entering CStudentView::OnUpdate\n");
    m_position = m_pList->GetHeadPosition();
    GetEntry(m_position); // initial data for view**
}

void CStudentView::OnStudentHome() 
{
    **TRACE("Entering CStudentView::OnStudentHome\n");
    // need to deal with list empty condition
    if (!m_pList->IsEmpty()) {
        m_position = m_pList->GetHeadPosition();
        GetEntry(m_position);
    }**
}

void CStudentView::OnStudentEnd() 
{
    **TRACE("Entering CStudentView::OnStudentEnd\n");
    if (!m_pList->IsEmpty()) {
        m_position = m_pList->GetTailPosition();
        GetEntry(m_position);
    }**
}

void CStudentView::OnStudentPrev() 
{
    **POSITION pos;
    TRACE("Entering CStudentView::OnStudentPrev\n");
    if ((pos = m_position) != NULL) {
        m_pList->GetPrev(pos);
        if (pos) {
            GetEntry(pos);
      m_position = pos;
        }
    }**
}

void CStudentView::OnStudentNext() 
{
    **POSITION pos;
    TRACE("Entering CStudentView::OnStudentNext\n");
    if ((pos = m_position) != NULL) {
        m_pList->GetNext(pos);
        if (pos) {
            GetEntry(pos);
            m_position = pos;
        }
    }**
}
void CStudentView::OnStudentIns() 
{
    **TRACE("Entering CStudentView::OnStudentIns\n");
    InsertEntry(m_position);
    GetDocument()->SetModifiedFlag();
    GetDocument()->UpdateAllViews(this);**
}

void CStudentView::OnStudentDel() 
{
    **// deletes current entry and positions to next one or head
    POSITION pos;
    TRACE("Entering CStudentView::OnStudentDel\n");
    if ((pos = m_position) != NULL) {
        m_pList->GetNext(pos);
        if (pos == NULL) {
            pos = m_pList->GetHeadPosition();
            TRACE("GetHeadPos = %ld\n", pos);
            if (pos == m_position) {
                pos = NULL;
            }
        }
        GetEntry(pos);
        CStudent\* ps = m_pList->GetAt(m_position);
        m_pList->RemoveAt(m_position);
        delete ps;
        m_position = pos;
        GetDocument()->SetModifiedFlag();
        GetDocument()->UpdateAllViews(this);
    }**
}

void CStudentView::OnUpdateStudentHome(CCmdUI\* pCmdUI) 
{
    **// called during idle processing and when Student menu drops down
    POSITION pos;

    // enables button if list not empty and not at home already
    pos = m_pList->GetHeadPosition();
    pCmdUI->Enable((m_position != NULL) && (pos != m_position));**
}

void CStudentView::OnUpdateStudentEnd(CCmdUI\* pCmdUI) 
{
    **// called during idle processing and when Student menu drops down
    POSITION pos;

    // enables button if list not empty and not at end already
    pos = m_pList->GetTailPosition();
    pCmdUI->Enable((m_position != NULL) && (pos != m_position));**
}

void CStudentView::OnUpdateStudentDel(CCmdUI\* pCmdUI) 
{
    **// called during idle processing and when Student menu drops down
    pCmdUI->Enable(m_position != NULL);**
}

**void CStudentView::GetEntry(POSITION position)
{
    if (position) {
        CStudent\* pStudent = m_pList->GetAt(position);
        m_strName = pStudent->m_strName;
        m_nGrade = pStudent->m_nGrade;
    }
    else {
        ClearEntry();
    }
    UpdateData(FALSE);
}

void CStudentView::InsertEntry(POSITION position)
{
    if (UpdateData(TRUE)) {
        // UpdateData returns FALSE if it detects a user error
        CStudent\* pStudent = new CStudent;
        pStudent->m_strName = m_strName;
        pStudent->m_nGrade = m_nGrade;
        m_position = m_pList->InsertAfter(m_position, pStudent);
    }
}

void CStudentView::ClearEntry()
{
    m_strName = "";
    m_nGrade = 0;
    UpdateData(FALSE);
    ((CDialog\*) this)->GotoDlgCtrl(GetDlgItem(IDC_NAME));
}**

**Figure 16-5.** _The_ CStudentView _class listing._

### ClassWizard and _CStudentView_

ClassWizard was used to map the _CStudentView_ Clear pushbutton notification message as follows.

**Object ID**

**Message**

**Member Function**

_IDC_CLEAR_

BN_CLICKED

_OnClear_

Because _CStudentView_ is derived from _CFormView_, ClassWizard supports the definition of dialog data members. The variables shown here were added with the Add Variables button.

**Control ID**

**Member Variable**

**Category**

**Variable Type**

_IDC_GRADE_

_m_nGrade_

Value

_int_

_IDC_NAME_

_m_strName_

Value

_CString_

The minimum value of the _m_nGrade_ data member was set to 0, and its maximum value was set to 100. The maximum length of the _m_strName_ data member was set to 20 characters.

ClassWizard maps toolbar button commands to their handlers. Here are the commands and the handler functions to which they were mapped.

**Object ID**

**Message**

**Member Function**

_ID_STUDENT_HOME_

COMMAND

_OnStudentHome_

_ID_STUDENT_END_

COMMAND

_OnStudentEnd_

_ID_STUDENT_PREV_

COMMAND

_OnStudentPrev_

_ID_STUDENT_NEXT_

COMMAND

_OnStudentNext_

_ID_STUDENT_INS_

COMMAND

_OnStudentIns_

_ID_STUDENT_DEL_

COMMAND

_OnStudentDel_

Each command handler has built-in error checking.

The following update command UI message handlers are called during idle processing to update the state of the toolbar buttons and, when the Student menu is painted, to update the menu items.

**Object ID**

**Message**

**Member Function**

_ID_STUDENT_HOME_

UPDATE_COMMAND_UI

_OnUpdateStudentHome_

_ID_STUDENT_END_

UPDATE_COMMAND_UI

_OnUpdateStudentEnd_

_ID_STUDENT_PREV_

UPDATE_COMMAND_UI

_OnUpdateStudentHome_

_ID_STUDENT_NEXT_

UPDATE_COMMAND_UI

_OnUpdateStudentEnd_

_ID_STUDENT_DEL_

UPDATE_COMMAND_UI

_OnUpdateCommandDel_

For example, this button,

![](c:/dl/books/windows/msvc5th/invcpp5/images/G16OG12.GIF)

which retrieves the first student record, is disabled when the list is empty and when the _m_position_ variable is already set to the head of the list. The Previous button is disabled under the same circumstances, so it uses the same update command UI handler. The End and the Next buttons share a handler for similar reasons. Because a delay sometimes occurs in calling the update command UI functions, the command message handlers must look for error conditions.

### Data Members

The _m_position_ data member is a kind of cursor for the document's collection. It contains the position of the _CStudent_ object that is currently displayed. The _m_pList_ variable provides a quick way to get at the student list in the document.

### _OnInitialUpdate_

The virtual _OnInitialUpdate_ function is called when you start the application. It sets the view's _m_pList_ data member for subsequent access to the document's list object.

### _OnUpdate_

The virtual _OnUpdate_ function is called both by the _OnInitialUpdate_ function and by the _CDocument::UpdateAllViews_ function. It resets the list position to the head of the list, and it displays the head entry. In this example, the _UpdateAllViews_ function is called only in response to the Edit Clear All command. In a multiview application, you might need a different strategy for setting the _CStudentView m_position_ variable in response to document updates from another view.

Protected Virtual Functions
---------------------------

The following three functions are protected virtual functions that deal specifically with _CStudent_ objects:

> _GetEntry_
> 
> _InsertEntry_
> 
> _ClearEntry_

You can transfer these functions to a derived class if you want to isolate the general-purpose list-handling features in a base class.

Testing the EX16B Application
-----------------------------

Fill in the student name and grade fields, and then click this button

![](c:/dl/books/windows/msvc5th/invcpp5/images/G16OG13.GIF)

to insert the entry into the list. Repeat this action several times, using the Clear pushbutton to erase the data from the previous entry. When you exit the application, the debug output should look similar to this:

a CStudentDoc at $4116D0
m_strTitle = Untitled
m_strPathName = 
m_bModified = 1
m_pDocTemplate = $4113F1

a CObList at $411624
with 4 elements
    a CStudent at $412770
m_strName = Fisher, Lon
m_nGrade = 67
    a CStudent at $412E80
m_strName = Meyers, Lisa
m_nGrade = 80
    a CStudent at $412880
m_strName = Seghers, John
m_nGrade = 92
    a CStudent at $4128F0
m_strName = Anderson, Bob
m_nGrade = 87
________________________________________________________________________
6.4.11. - [Two Exercises for the Reader](invcpp5/ch16l.htm)
----------------------------------------------------
 Two Exercises for the Reader 

Two Exercises for the Reader
============================

You might have noticed the absence of a Modify button on the toolbar. Without such a button, you can't modify an existing student record. Can you add the necessary toolbar button and message handlers? The most difficult task might be designing a graphic for the button's tile.

Recall that the _CStudentView_ class is just about ready to be a general-purpose base class. Try separating the _CStudent_\-specific virtual functions into a derived class. After that, make another derived class that uses a new element class other than _CStudent_.
________________________________________________________________________
6.5. - [Chapter 17 -- Reading and Writing Documents -- SDI Applications](invcpp5/ch17a.htm)
----------------------------------------------------
 Chapter 17 -- Reading and Writing Documents -- SDI Applications  Chapter 17

Reading and Writing Documents—SDI Applications
==============================================

As you've probably noticed, every AppWizard-generated program has a File menu that contains the familiar New, Open, Save, and Save As commands. In this chapter, you'll learn how to make your application respond to read and write documents.

Here we'll stick with the Single Document Interface (SDI) application because it's familiar territory. [Chapter 18](ch18a.htm) introduces the Multiple Document Interface (MDI) application, which is more flexible in its handling of documents and files. In both chapters, you'll get a heavy but necessary dose of application-framework theory; you'll learn a lot about the various helper classes that have been concealed up to this point. The going will be rough, but believe me, you must know the details to get the most out of the application framework.

This chapter's example, EX17A, is an SDI application based on the EX16B example from the previous chapter. It uses the student list document with a _CFormView_\-derived view class. Now the student list can be written to and read from disk through a process called serialization. [Chapter 18](ch18a.htm) shows you how to use the same view and document classes to make an MDI application.
________________________________________________________________________
6.5.1. - [Serialization -- What Is It?](invcpp5/ch17b.htm)
----------------------------------------------------
 Serialization -- What Is It? 

Serialization—What Is It?
=========================

The term "serialization" might be new to you, but it's already seen some use in the world of object-oriented programming. The idea is that objects can be persistent, which means they can be saved on disk when a program exits and then can be restored when the program is restarted. This process of saving and restoring objects is called serialization. In the Microsoft Foundation Class (MFC) library, designated classes have a member function named _Serialize_. When the application framework calls _Serialize_ for a particular object—for example, an object of class _CStudent_—the data for the student is either saved on disk or read from disk.

In the MFC library, serialization is not a substitute for a database management system. All the objects associated with a document are sequentially read from or written to a single disk file. It's not possible to access individual objects at random disk file addresses. If you need database capability in your application, consider using the Microsoft Open Database Connectivity (ODBC) software or Data Access Objects (DAO). [Chapter 31](ch31a.htm) and [Chapter 32](ch32a.htm) show you how to use ODBC and DAO with the MFC application framework.

> NOTE
> 
> There's a storage option that fits between sequential files and a database: structured storage, described in [Chapter 27](ch27a.htm). The MFC framework already uses structured storage for container programs that support embedded objects.

Disk Files and Archives
-----------------------

How do you know whether _Serialize_ should read or write data? How is _Serialize_ connected to a disk file? With the MFC library, objects of class _CFile_ represent disk files. A _CFile_ object encapsulates the binary file handle that you get through the Win32 function _CreateFile_. This is not the buffered _FILE_ pointer that you'd get with a call to the C runtime _fopen_ function; rather, it's a handle to a binary file. The application framework uses this file handle for Win32 _ReadFile_, _WriteFile_, and _SetFilePointer_ calls.

If your application does no direct disk I/O but instead relies on the serialization process, you can avoid direct use of _CFile_ objects. Between the _Serialize_ function and the _CFile_ object is an archive object (of class _CArchive_), as shown in Figure 17-1.

The _CArchive_ object buffers data for the _CFile_ object, and it maintains an internal flag that indicates whether the archive is storing (writing to disk) or loading (reading from disk). Only one active archive is associated with a file at any one time. The application framework takes care of constructing the _CFile_ and _CArchive_ objects, opening the disk file for the _CFile_ object and associating the archive object with the file. All you have to do (in your _Serialize_ function) is load data from or store data in the archive object. The application framework calls the document's _Serialize_ function during the File Open and File Save processes.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F17FG01x.gif)]

**Figure 17-1.** _The serialization process._

Making a Class Serializable
---------------------------

A serializable class must be derived directly or indirectly from _CObject_. In addition (with some exceptions), the class declaration must contain the _DECLARE_SERIAL_ macro call, and the class implementation file must con- tain the _IMPLEMENT_SERIAL_ macro call. (See the _Microsoft Foundation_ _Class Reference_ for a description of these macros.) This chapter's _CStudent_ class example is modified from the class in [Chapter 16](ch16a.htm) to include these macros.

Writing a _Serialize_ Function
------------------------------

In [Chapter 16](ch16a.htm), you saw a _CStudent_ class, derived from _CObject_, with these data members:

public:
    CString m_strName;
    int     m_nGrade;

Now your job is to write a _Serialize_ member function for _CStudent_. Because _Serialize_ is a virtual member function of class _CObject_, you must be sure that the return value and parameter types match the _CObject_ declaration. The _Serialize_ function for the _CStudent_ class is below.

**void CStudent::Serialize(CArchive& ar)
{
    TRACE("Entering CStudent::Serialize\n");
    if (ar.IsStoring()) {
        ar << m_strName << m_nGrade;
    }
    else {
        ar >> m_strName >> m_nGrade;
    }
}**

Most serialization functions call the _Serialize_ functions of their base classes. If _CStudent_ were derived from _CPerson_, for example, the first line of the _Serialize_ function would be

CPerson::Serialize(ar);

The _Serialize_ function for _CObject_ (and for _CDocument_, which doesn't override it) doesn't do anything useful, so there's no need to call it.

Notice that _ar_ is a _CArchive_ reference parameter that identifies the application's archive object. The _CArchive::IsStoring_ member function tells us whether the archive is currently being used for storing or loading. The _CArchive_ class has overloaded insertion operators (<<) and extraction operators (>>) for many of the C++ built-in types, as shown in the following table.

**Type**

**Description**

_BYTE_

8 bits, unsigned

_WORD_

16 bits, unsigned

_LONG_

32 bits, signed

_DWORD_

32 bits, unsigned

_float_

32 bits

_double_

64 bits, IEEE standard

_int_

32 bits, signed

_short_

16 bits, signed

_char_

8 bits, unsigned

_unsigned_

32 bits, unsigned

The insertion operators are overloaded for values; the extraction operators are overloaded for references. Sometimes you must use a cast to satisfy the compiler. Suppose you have a data member _m_nType_ that is an enumerated type. Here's the code you would use:

ar << (int) m_nType;
ar >> (int&) m_nType;

MFC classes that are not derived from _CObject_, such as _CString_ and _CRect_, have their own overloaded insertion and extraction operators for _CArchive_.

Loading from an Archive—Embedded Objects vs. Pointers
-----------------------------------------------------

Now suppose your _CStudent_ object has other objects embedded in it, and these objects are not instances of standard classes such as _CString_, _CSize_, and _CRect_. Let's add a new data member to the _CStudent_ class:

public:
    CTranscript m_transcript;

Assume that _CTranscript_ is a custom class, derived from _CObject_, with its own _Serialize_ member function. There's no overloaded << or >> operator for _CObject_, so the _CStudent::Serialize_ function now becomes

void CStudent::Serialize(CArchive& ar)
{
    if (ar.IsStoring()) {
        ar << m_strName << m_nGrade;
    }
    else {
        ar >> m_strName >> m_nGrade;
    }
    m_transcript.Serialize(ar);
}

Before the _CStudent::Serialize_ function can be called to load a student record from the archive, a _CStudent_ object must exist somewhere. The embedded _CTranscript_ object _m_transcript_ is constructed along with the _CStudent_ object before the call to the _CTranscript::Serialize_ function. When the virtual _CTranscript::Serialize_ function does get called, it can load the archived transcript data into the embedded _m_transcript_ object. If you're looking for a rule, here it is: always make a direct call to _Serialize_ for embedded objects of classes derived from _CObject_.

Suppose that, instead of an embedded object, your _CStudent_ object contained a _CTranscript_ pointer data member such as this:

public:
    CTranscript\* m_pTranscript;

You could use the _Serialize_ function, as shown below, but as you can see, you must construct a new _CTranscript_ object yourself.

void CStudent::Serialize(CArchive& ar)
{
    if (ar.IsStoring())
        ar << m_strName << m_nGrade;
    else {
        m_pTranscript = new CTranscript;
        ar >> m_strName >> m_nGrade;
    }
    m_pTranscript->Serialize(ar);
}

Because the _CArchive_ insertion and extraction operators are indeed overloaded for _CObject_ pointers, you could write _Serialize_ this way instead:

void CStudent::Serialize(CArchive& ar)
{
    if (ar.IsStoring())
        ar << m_strName << m_nGrade << m_pTranscript;
    else
        ar >> m_strName >> m_nGrade >> m_pTranscript;
}

But how is the _CTranscript_ object constructed when the data is loaded from the archive? That's where the _DECLARE_SERIAL_ and _IMPLEMENT_SERIAL_ macros in the _CTranscript_ class come in.

When the _CTranscript_ object is written to the archive, the macros ensure that the class name is written along with the data. When the archive is read, the class name is read in and an object of the correct class is dynamically constructed, under the control of code generated by the macros. Once the _CTranscript_ object has been constructed, the overridden _Serialize_ function for _CTranscript_ can be called to do the work of reading the student data from the disk file. Finally the _CTranscript_ pointer is stored in the _m_pTranscript_ data member. To avoid a memory leak, you must be sure that _m_pTranscript_ does not already contain a pointer to a _CTranscript_ object. If the _CStudent_ object was just constructed and thus was not previously loaded from the archive, the transcript pointer will be null.

The insertion and extraction operators do not work with embedded objects of classes derived from _CObject_, as shown here:

ar >> m_strName >>  m_nGrade >> &m_transcript; // Don't try this

Serializing Collections
-----------------------

Because all collection classes are derived from the _CObject_ class and the collection class declarations contain the _DECLARE_SERIAL_ macro call, you can conveniently serialize collections with a call to the collection class's _Serialize_ member function. If you call _Serialize_ for a _CObList_ collection of _CStudent_ objects, for example, the _Serialize_ function for each _CStudent_ object will be called in turn. You should, however, remember the following specifics about loading collections from an archive:

*   If a collection contains pointers to objects of mixed classes (all derived from _CObject_), the individual class names are stored in the archive so that the objects can be properly constructed with the appropriate class constructor.
    
*   If a container object, such as a document, contains an embedded collection, loaded data is appended to the existing collection. You might need to empty the collection before loading from the archive. This is usually done in the document's virtual _DeleteContents_ function, which is called by the application framework.
    
*   When a collection of _CObject_ pointers is loaded from an archive, the following processing steps take place for each object in the collection:
    
    1.  The object's class is identified.
        
    2.  Heap storage is allocated for the object.
        
    3.  The object's data is loaded into the newly allocated storage.
        
    4.  A pointer to the new object is stored in the collection.

The EX17A example shows serialization of an embedded collection of _CStudent_ records.

The _Serialize_ Function and the Application Framework
------------------------------------------------------

OK, so you know how to write _Serialize_ functions, and you know that these function calls can be nested. But do you know when the first _Serialize_ function gets called to start the serialization process? With the application framework, everything is keyed to the document (the object of a class derived from _CDocument_). When you choose Save or Open from the File menu, the application framework creates a _CArchive_ object (and an underlying _CFile_ object) and then calls your document class's _Serialize_ function, passing a reference to the _CArchive_ object. Your derived document class _Serialize_ function then serializes each of its nontemporary data members.

> NOTE
> 
> If you take a close look at any AppWizard-generated document class, you'll notice that the class includes the _DECLARE_DYNCREATE_ and _IMPLEMENT_DYNCREATE_ macros rather than the _DECLARE_SERIAL_ and _IMPLEMENT_SERIAL_ macros. The _SERIAL_ macros are unneeded because document objects are never used in conjunction with the _CArchive_ extraction operator or included in collections; the application framework calls the document's _Serialize_ member function directly. You should include the _DECLARE_SERIAL_ and _IMPLEMENT_SERIAL_ macros in all other serializable classes.
________________________________________________________________________
6.5.2. - [The SDI Application](invcpp5/ch17c.htm)
----------------------------------------------------
 The SDI Application 

The SDI Application
===================

You've seen many SDI applications that have one document class and one view class. We'll stick to a single view class in this chapter, but we'll explore the interrelationships among the application object, the main frame window, the document, the view, the document template object, and the associated string and menu resources.

The Windows Application Object
------------------------------

For each of your applications, AppWizard has been quietly generating a class derived from _CWinApp_. It has also been generating a statement such as this:

CMyApp theApp;

What you're seeing here is the mechanism that starts an MFC application. The class _CMyApp_ is derived from the class _CWinApp_, and _theApp_ is a globally declared instance of the class. This global object is called the Windows application object.

Here's a summary of the startup steps in a Microsoft Windows MFC library application:

1.  Windows loads your program into memory.
    
2.  The global object _theApp_ is constructed. (All globally declared objects are constructed immediately when the program is loaded.)
    
3.  Windows calls the global function _WinMain_, which is part of the MFC library. (_WinMain_ is equivalent to the non-Windows _main_ function—each is a main program entry point.)
    
4.  _WinMain_ searches for the one and only instance of a class derived from _CWinApp_.
    
5.  _WinMain_ calls the _InitInstance_ member function for _theApp_, which is overridden in your derived application class.
    
6.  Your overridden _InitInstance_ function starts the process of loading a document and displaying the main frame and view windows.
    
7.  _WinMain_ calls the _Run_ member function for _theApp_, which starts the processes of dispatching window messages and command messages.

You can override another important _CWinApp_ member function. The _ExitInstance_ function is called when the application terminates, after all its windows are closed.

> NOTE
> 
> Windows allows multiple instances of programs to run. The _InitInstance_ function is called each time a program instance starts up. In Win32, each instance runs as an independent process. It's only incidental that the same code is mapped to the virtual memory address space of each process. If you want to locate other running instances of your program, you must either call the Win32 _FindWindow_ function or set up a shared data section or memory-mapped file for communication.

The Document Template Class
---------------------------

If you look at the _InitInstance_ function that AppWizard generates for your derived application class, you'll see that the following statements are featured:

CSingleDocTemplate\* pDocTemplate;
pDocTemplate = new CSingleDocTemplate(
    IDR_MAINFRAME,
    RUNTIME_CLASS(CStudentDoc),
    RUNTIME_CLASS(CMainFrame),       // main SDI frame window
    RUNTIME_CLASS(CStudentView));
AddDocTemplate(pDocTemplate);

Unless you start doing fancy things with splitter windows and multiple views, this is the only time you'll actually see a document template object. In this case, it's an object of class _CSingleDocTemplate_, which is derived from _CDocTemplate_. The _CSingleDocTemplate_ class applies only to SDI applications because SDI applications are limited to one document object. _AddDocTemplate_ is a member function of class _CWinApp_.

The _AddDocTemplate_ call, together with the document template constructor call, establishes the relationships among classes—the application class, the document class, the view window class, and the main frame window class. The application object exists, of course, before template construction, but the document, view, and frame objects are not constructed at this time. The application framework later dynamically constructs these objects when they are needed.

This dynamic construction is a sophisticated use of the C++ language. The _DECLARE_DYNCREATE_ and _IMPLEMENT_DYNCREATE_ macros in a class declaration and implementation enable the MFC library to construct objects of the specified class dynamically. If this dynamic construction capability weren't present, more relationships among your application's classes would have to be hard-coded. Your derived application class, for example, would need code for constructing document, view, and frame objects of your specific derived classes. This would compromise the object-oriented nature of your program.

With the template system, all that's required in your application class is use of the _RUNTIME_CLASS_ macro. Notice that the target class's declaration must be included for this macro to work.

Figure 17-2 illustrates the relationships among the various classes, and Figure 17-3 illustrates the object relationships. An SDI application can have only one template (and associated class groups), and when the SDI program is running, there can be only one document object and only one main frame window object.

![](c:/dl/books/windows/msvc5th/invcpp5/images/F17FG02.GIF)

**Figure 17-2.** _Class relationships._

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F17FG03x.gif)]

**Figure 17-3.** _Object relationships._

> NOTE
> 
> The MFC library dynamic construction capability was designed before the runtime type identification (RTTI) feature was added to the C++ language. The original MFC implementation goes beyond RTTI, and the MFC library continues to use it for dynamic object construction. See [Appendix B](chaba.htm) for a description of MFC library dynamic construction.

The Document Template Resource
------------------------------

The first _AddDocTemplate_ parameter is _IDR_MAINFRAME_, the identifier for a string table resource. Here is the corresponding string that AppWizard generates for EX17A in the application's RC file:

IDR_MAINFRAME
    "ex17a\n"                // application window caption
    "\n"                     // root for default document name
                             //  ("Untitled" used if none provided)
    "Ex17a\n"                // document type name
    "Ex17a Files (\*.17a)\n"  // document type description and filter
    ".17a\n"                 // extension for documents of this type
    "Ex17a.Document\n"       // Registry file type ID
    "Ex17a Document"         // Registry file type description

> NOTE
> 
> The resource compiler won't accept the string concatenations as shown above. If you examine the ex17a.rc file, you'll see the substrings combined in one long string.

_IDR_MAINFRAME_ specifies one string that is separated into substrings by newline characters (\n). The substrings show up in various places when the application executes. The string _17A_ is the default document file extension specified to AppWizard.

The _IDR_MAINFRAME_ ID, in addition to specifying the application's strings, identifies the application's icon, toolbar resources, and menu. AppWizard generates these resources, and you can maintain them with the resource editors.

So now you've seen how the _AddDocTemplate_ call ties all the application elements together. Be aware, though, that no windows have been created yet and therefore nothing appears on the screen.

Multiple Views of an SDI Document
---------------------------------

Providing multiple views of an SDI document is a little more complicated. You could provide a menu item that allows the user to choose a view, or you could allow multiple views in a splitter window. [Chapter 20](ch20a.htm) shows you how to implement both techniques.

Creating an Empty Document—The _CWinApp::OnFileNew_ Function
------------------------------------------------------------

After your application class's _InitInstance_ function calls the _AddDocTemplate_ member function, it calls _OnFileNew_ (indirectly through _CWinApp::ProcessShellCommand_), another important _CWinApp_ member function. _OnFileNew_ sorts through the web of interconnected class names and does the following:

1.  Constructs the document object but does not attempt to read data from disk.
    
2.  Constructs the main frame object (of class _CMainFrame_); also creates the main frame window but does not show it. The main frame window includes the _IDR_MAINFRAME_ menu, the toolbar, and the status bar.
    
3.  Constructs the view object; also creates the view window but doesn't show it.
    
4.  Establishes connections among the document, main frame, and view objects. Do not confuse these object connections with the class connections established by the call to _AddDocTemplate_.
    
5.  Calls the virtual _CDocument::OnNewDocument_ member function for the document object, which calls the virtual _DeleteContents_ function.
    
6.  Calls the virtual _CView::OnInitialUpdate_ member function for the view object.
    
7.  Calls the virtual _CFrameWnd::ActivateFrame_ for the frame object to show the main frame window together with the menus, view window, and control bars.

> NOTE
> 
> Some of the functions listed above are not called directly by _OnFileNew_ but are called indirectly through the application framework.

In an SDI application, the document, main frame, and view objects are created only once, and they last for the life of the program. The _CWinApp::OnFileNew_ function is called by _InitInstance_. It's also called in response to the user choosing the File New menu item. In this case, _OnFileNew_ must behave a little differently. It can't construct the document, frame, and view objects because they're already constructed. Instead, it reuses the existing document object and performs steps 5, 6, and 7 above. Notice that _OnFileNew_ always calls _DeleteContents_ (indirectly) to empty the document.

The Document Class's _OnNewDocument_ Function
---------------------------------------------

You've seen the view class _OnInitialUpdate_ member function and the document class _OnNewDocument_ member function in [Chapter 16](ch16a.htm). If an SDI application didn't reuse the same document object, you wouldn't need _OnNewDocument_ because you could perform all document initialization in your document class constructor. Now you must override _OnNewDocument_ to initialize your document object each time the user chooses File New or File Open. AppWizard helps you by providing a skeleton function in the derived document class it generates.

> NOTE
> 
> It's a good idea to minimize the work you do in constructor functions. The fewer things you do, the less chance there is for the constructor to fail—and constructor failures are messy. Functions such as _CDocument::OnNewDocument_ and _CView::OnInitialUpdate_ are excellent places to do initial housekeeping. If anything fails at creation time, you can pop up a message box, and in the case of _OnNewDocument_, you can return _FALSE_. Be advised that both functions can be called more than once for the same object. If you need certain instructions executed only once, declare a "first time" flag data member and then test/set it appropriately.

Connecting File Open to Your Serialization Code—The _OnFileOpen_ Function
-------------------------------------------------------------------------

When AppWizard generates an application, it maps the File Open menu item to the _CWinApp::OnFileOpen_ member function. When called, this function invokes a sequence of functions to accomplish these steps:

1.  Prompts the user to select a file.
    
2.  Calls the virtual function _CDocument::OnOpenDocument_ for the already existing document object. This function opens the file, calls _CDocument::DeleteContents_, and constructs a _CArchive_ object set for loading. It then calls the document's _Serialize_ function, which loads data from the archive.
    
3.  Calls the view's _OnInitialUpdate_ function.

The Most Recently Used (MRU) file list is a handy alternative to the File Open menu item. The application framework tracks the four most recently used files and displays their names on the File menu. These filenames are stored in the Windows Registry between program executions.

> NOTE
> 
> You can change the number of recent files tracked by supplying a parameter to the _LoadStdProfileSetting_ function in the application class _InitInstance_ function.

The Document Class's _DeleteContents_ Function
----------------------------------------------

When you load an existing SDI document object from a disk file, you must somehow erase the existing contents of the document object. The best way to do this is to override the _CDocument::DeleteContents_ virtual function in your derived document class. The overridden function, as you've seen in [Chapter 16](ch16a.htm) , does whatever is necessary to clean up your document class's data members. In response to both the File New and File Open menu items, the _CDocument_ functions _OnNewDocument_ and _OnOpenDocument_ both call the _DeleteContents_ function, which means _DeleteContents_ is called immediately after the document object is first constructed. It's called again when you close a document.

If you want your document classes to work in SDI applications, plan on emptying the document's contents in the _DeleteContents_ member function rather than in the destructor. Use the destructor only to clean up items that last for the life of the object.

Connecting File Save and File Save As to Your Serialization Code
----------------------------------------------------------------

When AppWizard generates an application, it maps the File Save menu item to the _OnFileSave_ member function of the _CDocument_ class. _OnFileSave_ calls the _CDocument_ function _OnSaveDocument_, which in turn calls your document's _Serialize_ function with an archive object set for storing. The File Save As menu item is handled in a similar manner: it is mapped to the _CDocument_ function _OnFileSaveAs_, which calls _OnSaveDocument_. Here the application framework does all the file management necessary to save a document on disk.

> NOTE
> 
> Yes, it is true that the File New and File Open menu options are mapped to application class member functions, but File Save and File Save As are mapped to document class member functions. File New is mapped to _OnFileNew._ The SDI version of _InitInstance_ also calls _OnFileNew_ (indirectly). No document object exists when the application framework calls _InitInstance_, so _OnFileNew_ can't possibly be a member function of _CDocument._ When a document is saved, however, a document object certainly exists.

The Document's "Dirty" Flag
---------------------------

Many document-oriented applications for Windows track the user's modifications of a document. If the user tries to close a document or exit the program, a message box asks whether the user wants to save the document. The MFC application framework directly supports this behavior with the _CDocument_ data member _m_bModified_. This Boolean variable is _TRUE_ if the document has been modified (has become "dirty"); otherwise, it is _FALSE_.

The protected _m_bModified_ flag is accessed through the _CDocument_ member functions _SetModifiedFlag_ and _IsModified_. The framework sets the document object's flag to _FALSE_ when the document is created or read from disk and when it is saved on disk. You, the programmer, must use the _SetModifiedFlag_ function to set the flag to _TRUE_ when the document data changes. The virtual function _CDocument::SaveModified_, which the framework calls when the user closes the document, displays a message box if the _m_bModified_ flag is set to _TRUE_. You can override this function if you need to do something else.

In the EX17A example, you'll see how a one-line update command UI function can use _IsModified_ to control the state of the disk button and the corresponding menu item. When the user modifies the file, the disk button is enabled; when the user saves the file, the button changes to gray.

> NOTE
> 
> In one respect, MFC SDI applications behave a little differently from other Windows SDI applications such as Notepad. Here's a typical sequence of events:
> 
> 1.  The user creates a document and saves it on disk under the name (for example) test.dat.
>     
> 2.  The user modifies the document.
>     
> 3.  The user chooses File Open and then specifies test.dat.
> 
> When the user chooses File Open, Notepad asks whether the user wants to save the changes made to the document (in Step 2 above). If the user answers no, the program rereads the document from disk. An MFC application, on the other hand, assumes that the changes are permanent and does not reread the file.
________________________________________________________________________
6.5.3. - [The EX17A Example -- SDI with Serialization](invcpp5/ch17d.htm)
----------------------------------------------------
 The EX17A Example -- SDI with Serialization 

The EX17A Example—SDI with Serialization
========================================

The EX17A example is similar to example EX16B. The student dialog and the toolbar are the same, and the view class is the same. Serialization has been added, together with an update command UI function for File Save. The header and implementation files for the view and document classes will be reused in example EX18A in the [next chapter](ch18a.htm).

All the new code (code that is different from EX16B) is listed, with additions and changes to the AppWizard-generated code and the ClassWizard code in boldface. A list of the files and classes in the EX17A example is shown in the following table.

**Header File**

**Source Code File**

**Class**

**Description**

ex17a.h

ex17a.cpp

_CEx17aApp_

Application class (from AppWizard)

 

 

_CAboutDlg_

About dialog

MainFrm.h

MainFrm.cpp

_CMainFrame_

SDI main frame

StuDoc.h

StuDoc.cpp

_CStudentDoc_

Student document

StuView.h

StuView.cpp

_CStudentView_

Student form view (from EX16B)

Student.h

Student.cpp

_CStudent_

Student record

StdAfx.h

StdAfx.cpp

 

Precompiled headers (with afxtempl.h included)

_CStudent_
----------

The EX17A Student.h file is almost the same as the file in the EX16A project. (See Figure 16-2.) The header contains the macro

**DECLARE_SERIAL(CStudent)**

instead of

DECLARE_DYNAMIC(CStudent)

and the implementation file contains the macro

**IMPLEMENT_SERIAL(CStudent, CObject, 0)**

instead of

IMPLEMENT_DYNAMIC(CStudent, Cobject)

The virtual _Serialize_ function has also been added.

_CEx17aApp_
-----------

The application class files, shown in Figure 17-4, contain only code generated by AppWizard. The application was generated with a default file extension and with the Microsoft Windows Explorer launch and drag-and-drop capabilities. These features are described later in this chapter.

To generate additional code, you must do the following when you first run AppWizard: in the AppWizard Step 4 page, click the Advanced button. When the Advanced Options dialog appears, you must enter the filename extension in the upper-left control, as shown here.

![](c:/dl/books/windows/msvc5th/invcpp5/images/G17OG01.GIF)

This ensures that the document template resource string contains the correct default extension and that the correct Explorer-related code is inserted into your application class _InitInstance_ member function. You can change some of the other resource substrings if you want.

> NOTE
> 
> The generated calls to _Enable3dControls_ and _Enable3dControlsStatic_ in _CEx17aApp::InitInstance_ are not necessary with Microsoft Windows 95, Microsoft Windows 98, or Microsoft Windows NT 4.0. These two functions support an older DLL that is shipped with Microsoft Windows 3.51.

**EX17A.H**

// ex17a.h : main header file for the EX17A application
//

#if !defined(AFX_EX17A_H__1A036EA3_821A_11D0_8FE2_00C04FC2A0C2__INCLUDED_)
#define AFX_EX17A_H__1A036EA3_821A_11D0_8FE2_00C04FC2A0C2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#ifndef __AFXWIN_H__
    #error include \`stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

///////////////////////////////////////////////////////////////////////
// CEx17aApp:
// See ex17a.cpp for the implementation of this class
//

class CEx17aApp : public CWinApp
{
public:
    CEx17aApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEx17aApp)
    public:
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL

// Implementation

    //{{AFX_MSG(CEx17aApp)
    afx_msg void OnAppAbout();
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////
//

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations
//  immediately before the previous line.

#endif // !defined(AFX_EX17A_H__1A036EA3_821A_11D0_8FE2_00C04FC2A0C2__INCLUDED_)

**EX17A.CPP**

// ex17a.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "ex17a.h"

#include "MainFrm.h"
#include "StuDoc.h"
#include "StuView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////
// CEx17aApp

BEGIN_MESSAGE_MAP(CEx17aApp, CWinApp)
    //{{AFX_MSG_MAP(CEx17aApp)

    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////
// CEx17aApp construction

CEx17aApp::CEx17aApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

///////////////////////////////////////////////////////////////////////
// The one and only CEx17aApp object

CEx17aApp theApp;
///////////////////////////////////////////////////////////////////////
// CEx17aApp initialization

BOOL CEx17aApp::InitInstance()
{
    AfxEnableControlContainer();

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

#ifdef _AFXDLL
    Enable3dControls();       // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic(); // Call this when linking to MFC statically
#endif

    // Change the registry key under which our settings are stored.
    // You should modify this string to be something appropriate
    // such as the name of your company or organization.
    SetRegistryKey(_T("Local AppWizard-Generated Applications"));

    LoadStdProfileSettings();  // Load standard INI file options 
                               //  (including MRU)

    // Register the application's document templates.
    //  Document templates serve as the connection between
    //  documents, frame windows and views.

    CSingleDocTemplate\* pDocTemplate;
    pDocTemplate = new CSingleDocTemplate(
        IDR_MAINFRAME,
        RUNTIME_CLASS(CStudentDoc),
        RUNTIME_CLASS(CMainFrame),       // main SDI frame window
        RUNTIME_CLASS(CStudentView));
    AddDocTemplate(pDocTemplate);

    // Enable DDE Execute open
    EnableShellOpen();
    RegisterShellFileTypes(TRUE);
    // Parse command line for standard shell commands, DDE, file open
    CCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);

    // Dispatch commands specified on the command line
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;

    // The one and only window has been initialized,
    //  so show and update it.
    m_pMainWnd->ShowWindow(SW_SHOW);
    m_pMainWnd->UpdateWindow();

    // Enable drag/drop open
    m_pMainWnd->DragAcceptFiles();

    return TRUE;
}

///////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)

    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange\* pDX); // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange\* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CEx17aApp::OnAppAbout()
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}

///////////////////////////////////////////////////////////////////////
// CEx17aApp commands

**Figure 17-4.** _The_ CEx17aApp _class listing._

_CMainFrame_
------------

The main frame window class code, shown in Figure 17-5, is almost unchanged from the code that AppWizard generated. The overridden _ActivateFrame_ function and the _WM_DROPFILES_ handler exist solely for trace purposes.

**MAINFRM.H**

// MainFrm.h : interface of the CMainFrame class
//
///////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__1A036EA7_821A_11D0_8FE2_00C04FC2A0C2__INCLUDED_)
#define AFX_MAINFRM_H__1A036EA7_821A_11D0_8FE2_00C04FC2A0C2__INCLUDED_
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
    CMainFrame();
    DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    public:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual void ActivateFrame(int nCmdShow = -1);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
    CStatusBar  m_wndStatusBar;
    CToolBar    m_wndToolBar;

// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDropFiles(HDROP hDropInfo);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
///////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
//  immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__1A036EA7_821A_11D0_8FE2_00C04FC2A0C2__INCLUDED_)

**MAINFRM.CPP**

// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "ex17a.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_CREATE()
    ON_WM_DROPFILES()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
    ID_SEPARATOR,           // status line indicator
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
    ID_INDICATOR_SCRL,
};
///////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
    // TODO: add member initialization code here

}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;
    
    if (!m_wndToolBar.Create(this) ||
        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    {
        TRACE0("Failed to create toolbar\n");
        return -1;      // fail to create
    }

    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0("Failed to create status bar\n");
        return -1;      // fail to create
    }

    // TODO: Remove this if you don't want tool tips
    //  or a resizeable toolbar
    m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
        CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

    // TODO: Delete these three lines if you don't want the toolbar to
    //  be dockable
    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
    EnableDocking(CBRS_ALIGN_ANY);
  
DockControlBar(&m_wndToolBar);
    return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return CFrameWnd::PreCreateWindow(cs);
}

///////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

///////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
void CMainFrame::ActivateFrame(int nCmdShow) 
{
    **TRACE("Entering CMainFrame::ActivateFrame\n");**
    CFrameWnd::ActivateFrame(nCmdShow);
}

void CMainFrame::OnDropFiles(HDROP hDropInfo) 
{
    **TRACE("Entering CMainFrame::OnDropFiles\n");**
    CFrameWnd::OnDropFiles(hDropInfo);
}

**Figure 17-5.** _The_ CMainFrame _class listing._

_CStudentDoc_
-------------

The _CStudentDoc_ class is the same as the _CStudentDoc_ class from the [previous chapter](ch16a.htm) (shown in Figure 16-4) except for four functions: _Serialize_, _DeleteContents_, _OnOpenDocument_, and _OnUpdateFileSave_.

### _Serialize_

One line has been added to the AppWizard-generated function to serialize the document's student list, as shown here:

///////////////////////////////////////////////////////////////////////
// CStudentDoc serialization

void CStudentDoc::Serialize(CArchive& ar)
{
    **TRACE("Entering CStudentDoc::Serialize\n");**
    if (ar.IsStoring())
    {
        // TODO: add storing code here
    }
    else
    {
        // TODO: add loading code here
    }
    **m_studentList.Serialize(ar);**
}

### _DeleteContents_

The _Dump_ statement is replaced by a simple _TRACE_ statement. Here is the modified code:

void CStudentDoc::DeleteContents() 
{
    TRACE("Entering CStudentDoc::DeleteContents\n");
    while (m_studentList.GetHeadPosition()) {
        delete m_studentList.RemoveHead();
    }
}

### _OnOpenDocument_

This virtual function is overridden only for the purpose of displaying a _TRACE_ message, as shown below.

BOOL CStudentDoc::OnOpenDocument(LPCTSTR lpszPathName)
{
    **TRACE("Entering CStudentDoc::OnOpenDocument\n");**
     if (!CDocument::OnOpenDocument(lpszPathName))
        return FALSE;
     
    // TODO: Add your specialized creation code here
     
    return TRUE;
}

### _OnUpdateFileSave_

This message map function grays the File Save toolbar button when the document is in the unmodified state. The view controls this state by calling the document's _SetModifiedFlag_ function, as shown here:

void CStudentDoc::OnUpdateFileSave(CCmdUI\* pCmdUI)
{
    **// Disable disk toolbar button if file is not modified
    pCmdUI->Enable(IsModified());**
}

_CStudentView_
--------------

The code for the _CStudentView_ class comes from the [previous chapter](ch16a.htm). Figure 16-5 shows the code.

Testing the EX17A Application
-----------------------------

Build the program and start it from the debugger, and then test it by typing some data and saving it on disk with the filename Test.17a. (You don't need to type the _.17a_.)

Exit the program, and then restart it and open the file you saved. Did the data you typed come back? Take a look at the Debug window and observe the sequence of function calls. Is the following sequence produced when you start the application and open the file?

Entering CStudentDoc constructor
Entering CStudentView constructor
Entering CStudentDoc::OnNewDocument
Entering CStudentDoc::DeleteContents
Entering CStudentView::OnInitialUpdate
Entering CStudentView::OnUpdate
Entering CMainFrame::ActivateFrame
Entering CStudentDoc::OnOpenDocument
Entering CStudentDoc::DeleteContents
Entering CStudentDoc::Serialize
Entering CStudent::Serialize
Entering CStudent::Serialize
Entering CStudent::Serialize
Entering CStudentView::OnInitialUpdate
Entering CStudentView::OnUpdate
Entering CMainFrame::ActivateFrame
________________________________________________________________________
6.5.4. - [Explorer Launch and Drag and Drop](invcpp5/ch17e.htm)
----------------------------------------------------
 Explorer Launch and Drag and Drop 

Explorer Launch and Drag and Drop
=================================

In the past, PC users were accustomed to starting up a program and then selecting a disk file (sometimes called a document) that contained data the program understood. Many MS-DOS-based programs worked this way. The old Windows Program Manager improved things by allowing the user to double-click on a program icon instead of typing a program name. Meanwhile, Apple Macintosh users were double-clicking on a document icon; the Macintosh operating system figured out which program to run.

While Windows Explorer still lets users double-click on a program, it also lets users double-click on a document icon to run the document's program. But how does Explorer know which program to run? Explorer uses the Windows Registry to make the connection between document and program. The link starts with the filename extension that you typed into AppWizard, but as you'll see, there's more to it than that. Once the association is made, users can launch your program by double-clicking on its document icon or by dragging the icon from Explorer to a running instance of your program. In addition, users can drag the icon to a printer, and your program will print it.

Program Registration
--------------------

In [Chapter 15](ch15a.htm), you saw how MFC applications store data in the Windows Registry by calling _SetRegistryKey_ from the _InitInstance_ function. Independent of this _SetRegistryKey_ call, your program can write file association information in a different part of the Registry on startup. To activate this feature, you must type in the filename extension when you create the application with AppWizard. (Use the Advanced button in AppWizard Step 4.) After you do that, AppWizard adds the extension as a substring in your template string and adds the following line in your _InitInstance_ function:

RegisterShellFileTypes(TRUE);

Now your program adds two items to the Registry. Under the HKEY_CLASSES_ROOT top-level key, it adds a subkey and a data string as shown here (for the EX17A example):

.17A = Ex17a.Document

The data item is the file type ID that AppWizard has chosen for you. Ex17a.Document, in turn, is the key for finding the program itself. The Registry entries for Ex17a.Document, also beneath HKEY_CLASSES_ROOT, are shown here.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G17OG02x.gif)]

Notice that the Registry contains the full pathname of the EX17A program. Now Explorer can use the Registry to navigate from the extension to the file type ID to the actual program itself. After the extension is registered, Explorer finds the document's icon and displays it next to the filename, as shown here.

![](c:/dl/books/windows/msvc5th/invcpp5/images/G17OG03.GIF)

Double-Clicking on a Document
-----------------------------

When the user double-clicks on a document icon, Explorer executes the associated SDI program, passing in the selected filename on the command line. You might notice that AppWizard generates a call to _EnableShellOpen_ in the application class _InitInstance_ function. This supports execution via DDE message, the technique used by the File Manager in Windows NT 3.51. Explorer can launch your SDI application without this call.

Enabling Drag and Drop
----------------------

If you want your already-running program to open files dragged from Explorer, you must call the _CWnd_ function _DragAcceptFiles_ for the application's main frame window. The application object's public data member _m_pMainWnd_ points to the _CFrameWnd_ (or _CMDIFrameWnd_) object. When the user drops a file anywhere inside the frame window, the window receives a WM_DROPFILES message, which triggers a call to _FrameWnd::OnDropFiles_. The following line in _InitInstance_, generated by AppWizard, enables drag and drop:

m_pMainWnd->DragAcceptFiles();

Program Startup Parameters
--------------------------

When you choose Run from the Start menu, or when you double-click the program directly in Explorer, there is no command-line parameter. The _InitInstance_ function processes the command line with calls to _ParseCommandLine_ and _ProcessShellCommand_. If the command line contains something that looks like a filename, the program immediately loads that file. Thus, you create a Windows shortcut that can run your program with a specific document file.

Experimenting with Explorer Launch and Drag and Drop
----------------------------------------------------

Once you have built EX17A, you can try running it from Explorer. You must execute the program directly, however, in order to write the initial entries in the Registry. Be sure that you've saved at least one 17A file to disk, and then exit EX17A. Start Explorer, and then open the \vcpp32\ex17a directory. Double-click on one of the 17A files in the panel on the right. Your program should start with the selected file loaded. Now, with both EX17A and Explorer open on the desktop, try dragging another file from Explorer to the EX17A window. The program should open the new file just as if you had chosen File Open from the EX17A menu.

You might also want to look at the EX17A entries in the Registry. Run the Regedit program (possibly named Regedt32 in Windows NT), and expand the HKEY_CLASSES_ROOT key. Look under ".17A" and "Ex17a.Document." Also expand the HKEY_CURRENT_USER (or HKEY_USERS\.DEFAULT) key, and look under "Software." You should see a Recent File List under the subkey ex17a. The EX17A program calls _SetRegistryKey_ with the string _"Local AppWizard-Generated Applications"_, so the program name goes beneath the ex17a subkey.
________________________________________________________________________
6.6. - [Chapter 18 -- Reading and Writing Documents -- MDI Applications](invcpp5/ch18a.htm)
----------------------------------------------------
 Chapter 18 -- Reading and Writing Documents -- MDI Applications  Chapter 18

Reading and Writing Documents—MDI Applications
==============================================

This chapter introduces the Microsoft Foundation Class (MFC) Library version 6.0 Multiple Document Interface (MDI) application and demonstrates how it reads and writes its document files. The MDI application appears to be the preferred MFC library program style. It's the AppWizard default, and most of the sample programs that come with Microsoft Visual C++ are MDI applications.

In this chapter, you'll learn the similarities and differences between Single Document Interface (SDI) and MDI applications, and you'll learn how to convert an SDI application to an MDI application. Be sure you thoroughly understand the SDI application described in [Chapter 17](ch17a.htm) before you attack the MDI application in this chapter.
________________________________________________________________________
6.6.1. - [The MDI Application](invcpp5/ch18b.htm)
----------------------------------------------------
 The MDI Application 

The MDI Application
===================

Before you look at the MFC library code for MDI applications, you should be familiar with the operation of Microsoft Windows MDI programs. Take a close look at Visual C++ now. It's an MDI application whose "multiple documents" are program source code files. Visual C++ is not the most typical MDI application, however, because it collects its documents into projects. It's better to examine Microsoft Word or, better yet, a real MFC library MDI application—the kind that AppWizard generates.

A Typical MDI Application, MFC Style
------------------------------------

This chapter's example, EX18A, is an MDI version of EX17A. Run the EX17A example to see an illustration of the SDI version after the user has selected a file. Now look at the MDI equivalent, as shown in Figure 18-1.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f18og01x.gif)]

**Figure 18-1.** _The EX18A application with two files open and the Window menu shown._

The user has two separate document files open, each in a separate MDI child window, but only one child window is active—the lower window, which lies on top of the other child window. The application has only one menu and one toolbar, and all commands are routed to the active child window. The main window's title bar reflects the name of the active child window's document file.

The child window's minimize box allows the user to reduce the child window to an icon in the main window. The application's Window menu (shown in Figure 18-1) lets the user control the presentation through the following items.

**Menu Item**

**Action**

New Window

Opens as an additional child window for the selected document

Cascade

Arranges the existing windows in an overlapped pattern

Tile

Arranges the existing windows in a nonoverlapped, tiled pattern

Arrange Icons

Arranges minimized windows in the frame window

(document names)

Selects the corresponding child window and brings it to the top

If the user closes both child windows (and opens the File menu), the application looks like Figure 18-2.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f18og02x.gif)]

**Figure 18-2.** _EX18A with no child windows._

The File menu is different, most toolbar buttons are disabled, and the window caption does not show a filename. The only choices the user has are to start a new document or to open an existing document from disk.

Figure 18-3 shows the application when it first starts up and a new document is created. The single child window has been maximized.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f18og03x.gif)]

**Figure 18-3.** _EX18A with initial child window._

The single, empty child window has the default document name Ex18a1. This name is based on the Doc Type Name (Ex18a) that you selected in the Advanced Options dialog after clicking the Advanced button in Step 4 of AppWizard. The first new file is Ex18a1, the second is Ex18a2, and so forth. The user normally chooses a different name when saving the document.

An MFC library MDI application, like many commercial MDI applications, starts up with a new, empty document. (Visual C++ is an exception.) If you want your application to start up with a blank frame, you can modify the argument to the _ProcessShellCommand_ call in the application class file, as shown in example EX18A.

> **For Win32 Programmers**
> 
> Starting with version 3.0, Windows directly supports MDI applications. The MFC library builds on this Windows support to create an MDI environment that parallels the SDI environment. In a Win32 MDI application, a main application frame window contains the menu and a single client window. The client window manages various child windows that correspond to documents. The MDI client window has its own preregistered window class (not to be confused with a C++ class) with a procedure that handles special messages such as WM_MDICASCADE and WM_MDITILE. An MDI child window procedure is similar to the window procedure for an SDI main window.
> 
> In the MFC library, the _CMDIFrameWnd_ class encapsulates the functions of both the main frame window and the MDI client window. This class has message handlers for all the Windows MDI messages and thus can manage its child windows, which are represented by objects of class _CMDIChildWnd_.

The MDI Application Object
--------------------------

You're probably wondering how an MDI application works and what code makes it different from an SDI application. Actually, the startup sequences are pretty much the same. An application object of a class derived from class _CWinApp_ has an overridden _InitInstance_ member function. This _InitInstance_ function is somewhat different from the SDI _InitInstance_ function, starting with the call to _AddDocTemplate_.

The MDI Document Template Class
-------------------------------

The MDI template construction call in _InitInstance_ looks like this:

CMultiDocTemplate\* pDocTemplate;
pDocTemplate = new CMultiDocTemplate(
    IDR_EX18ATYPE,
    RUNTIME_CLASS(CStudentDoc),
    RUNTIME_CLASS(CChildFrame), // custom MDI child frame
    RUNTIME_CLASS(CStudentView));
AddDocTemplate(pDocTemplate);

Unlike the SDI application you saw in [Chapter 17](ch17a.htm), an MDI application can use multiple document types and allows the simultaneous existence of more than one document object. This is the essence of the MDI application.

The single _AddDocTemplate_ call shown above permits the MDI application to support multiple child windows, each connected to a document object and a view object. It's also possible to have several child windows (and corresponding view objects) connected to the same document object. In this chapter, we'll start with only one view class and one document class. You'll see multiple view classes and multiple document classes in [Chapter 20](ch20a.htm).

> NOTE
> 
> When your application is running, the document template object maintains a list of active document objects that were created from the template. The _CMultiDocTemplate_ member functions _GetFirstDocPosition_ and _GetNextDoc_ allow you to iterate through the list. Use _CDocument::GetDocTemplate_ to navigate from a document to its template.

The MDI Frame Window and the MDI Child Window
---------------------------------------------

The SDI examples had only one frame window class and only one frame window object. For SDI applications, AppWizard generated a class named _CMainFrame_, which was derived from the class _CFrameWnd_. An MDI application has two frame window classes and many frame objects, as shown in the table below. The MDI frame-view window relationship is shown in Figure 18-4.

**Base Class**

**AppWizard-Generated Class**

**Number of Objects**

**Menu and Control Bars**

**Contains a View**

**Object Constructed**

_CMDIFrameWnd_

_CMainFrame_

1 only

Yes

No

In application class's _InitInstance_ function

_CMDIChildWnd_

_CChildFrame_

1 per child window

No

Yes

By application framework when a new child window is opened

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f18if04x.gif)]

**Figure 18-4.** _The MDI frame-view window relationship._

In an SDI application, the _CMainFrame_ object frames the application and contains the view object. In an MDI application, the two roles are separated. Now the _CMainFrame_ object is explicitly constructed in _InitInstance_, and the _CChildFrame_ object contains the view. AppWizard generates the following code:

CMainFrame\* pMainFrame = new CMainFrame;
if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
    return FALSE;
m_pMainWnd = pMainFrame;

_(code calls_ ProcessShellCommand _to create child frame)_

pMainFrame->ShowWindow(m_nCmdShow);
pMainFrame->UpdateWindow();

The application framework can create the _CChildFrame_ objects dynamically because the _CChildFrame_ runtime class pointer is passed to the _CMultiDocTemplate_ constructor.

> NOTE
> 
> The MDI _InitInstance_ function sets the _CWinApp_ data member _m_pMainWnd_ to point to the application's main frame window. This means you can access _m_pMainWnd_ through the global _AfxGetApp_ function anytime you need to get your application's main frame window.

The Main Frame and Document Template Resources
----------------------------------------------

An MDI application (EX18A, as described later in this chapter) has two separate string and menu resources, identified by the _IDR_MAINFRAME_ and _IDR_EX18ATYPE_ constants. The first resource set goes with the empty main frame window; the second set goes with the occupied main frame window. Here are the two string resources with substrings broken out:

IDR_MAINFRAME
    "ex18a"                     // application window caption

IDR_EX18ATYPE
    "\n"                        // (not used)
    "Ex18a\n"                   // root for default document name
    "Ex18a\n"                   // document type name
    "Ex18a Files (\*.18a)\n"     // document type description and filter
    ".18a\n"                    // extension for documents of this type
    "Ex18a.Document\n"          // Registry file type ID
    "Ex18a Document"            // Registry file type description

> NOTE
> 
> The resource compiler won't accept the string concatenations as shown above. If you examine the ex18a.rc file, you'll see the substrings combined in one long string.

The application window caption comes from the _IDR_MAINFRAME_ string. When a document is open, the document filename is appended. The last two substrings in the _IDR_EX18ATYPE_ string support embedded launch and drag and drop.

Creating an Empty Document—The _CWinApp::OnFileNew_ Function
------------------------------------------------------------

The MDI _InitInstance_ function calls _OnFileNew_ (through _ProcessShellCommand_), as did the SDI _InitInstance_ function. This time, however, the main frame window has already been created. _OnFileNew_, through a call to the _CMultiDocTemplate_ function _OpenDocumentFile_, now does the following:

2.  Constructs a document object but does not attempt to read data from disk.
    
3.  Constructs a child frame window object (of class _CChildFrame_). Also creates the child frame window but does not show it. In the main frame window, the _IDR_EX18ATYPE_ menu replaces the _IDR_MAINFRAME_ menu. _IDR_EX18ATYPE_ also identifies an icon resource that is used when the child window is minimized within the frame.
    
4.  Constructs a view object. Also creates the view window but does not show it.
    
5.  Establishes connections among the document, the main frame, and view objects. Do not confuse these object connections with the class associations established by the call to _AddDocTemplate_.
    
6.  Calls the virtual _OnNewDocument_ member function for the document object.
    
7.  Calls the virtual _OnInitialUpdate_ member function for the view object.
    
8.  Calls the virtual _ActivateFrame_ member function for the child frame object to show the frame window and the view window.

The _OnFileNew_ function is also called in response to the File New menu command. In an MDI application, _OnFileNew_ performs exactly the same steps as it does when called from _InitInstance_.

> NOTE
> 
> Some functions listed above are not called directly by _OpenDocumentFile_ but are called indirectly through the application framework.

Creating an Additional View for an Existing Document
----------------------------------------------------

If you choose the New Window command from the Window menu, the application framework opens a new child window that is linked to the currently selected document. The associated _CMDIFrameWnd_ function, _OnWindowNew_, does the following:

2.  Constructs a child frame object (of class _CChildFrame_). Also creates the child frame window but does not show it.
    
3.  Constructs a view object. Also creates the view window but does not show it.
    
4.  Establishes connections between the new view object and the existing document and main frame objects.
    
5.  Calls the virtual _OnInitialUpdate_ member function for the view object.
    
6.  Calls the virtual _ActivateFrame_ member function for the child frame object to show the frame window and the view window.

Loading and Storing Documents
-----------------------------

In MDI applications, documents are loaded and stored the same way as in SDI applications but with two important differences: a new document object is constructed each time a document file is loaded from disk, and the document object is destroyed when the child window is closed. Don't worry about clearing a document's contents before loading—but override the _CDocument::DeleteContents_ function anyway to make the class portable to the SDI environment.

Multiple Document Templates
---------------------------

An MDI application can support multiple document templates through multiple calls to the _AddDocTemplate_ function. Each template can specify a different combination of document, view, and MDI child frame classes. When the user chooses New from the File menu of an application with multiple templates, the application framework displays a list box that allows the user to select a template by name as specified in the string resource (document type substring). Multiple _AddDocTemplate_ calls are not supported in SDI applications because the document, view, and frame objects are constructed once for the life of the application.

> NOTE
> 
> When your application is running, the application object keeps a list of active document template objects. The _CWinApp_ member functions _GetFirstDocTemplatePosition_ and _GetNextDocTemplate_ allow you to iterate through the list of templates. These functions, together with the _CDocTemplate_ member functions _GetFirstDocPosition_ and _GetNextDoc_, allow you to access all of the application's document objects.

If you don't want the template list box, you can edit the File menu to add a New menu item for each document type. Code the command message handlers as shown below, using the document type substring from each template.

void CMyApp::OnFileNewStudent()
{
    OpenNewDocument("Studnt");
}
void CMyApp::OnFileNewTeacher()
{
    OpenNewDocument("Teachr");
}

Then add the _OpenNewDocument_ helper function as follows:

BOOL CMyApp::OpenNewDocument(const CString& strTarget)
{
    CString strDocName;
    CDocTemplate\* pSelectedTemplate;
    POSITION pos = GetFirstDocTemplatePosition();
    while (pos != NULL) {
        pSelectedTemplate = (CDocTemplate\*) GetNextDocTemplate(pos);
        ASSERT(pSelectedTemplate != NULL);
        ASSERT(pSelectedTemplate->IsKindOf(
            RUNTIME_CLASS(CDocTemplate)));
        pSelectedTemplate->GetDocString(strDocName,
            CDocTemplate::docName);
        if (strDocName == strTarget) { // from template's
                                       //  string resource
            pSelectedTemplate->OpenDocumentFile(NULL);
            return TRUE;
        }
    }
    return FALSE;
}

Explorer Launch and Drag and Drop
---------------------------------

When you double-click on a document icon for an MDI application in Windows Explorer, the application launches only if it was not running already; otherwise, a new child window opens in the running application for the document you selected. The _EnableShellOpen_ call in the application class _InitInstance_ function is necessary for this to work. Drag and drop works much the same way in an MDI application as it does in an SDI application. If you drag a file from Windows Explorer to your MDI main frame window, the program opens a new child frame (with associated document and view) just as if you'd chosen the File Open command. As with SDI applications, you must use the AppWizard Step 4 Advanced button to specify the filename extension.
________________________________________________________________________
6.6.2. - [The EX18A Example](invcpp5/ch18c.htm)
----------------------------------------------------
 The EX18A Example 

The EX18A Example
=================

This example is the MDI version of the EX17A example from the [previous chapter](ch17a.htm). It uses the same document and view class code and the same resources (except the program name). The application code and main frame class code are different, however. All the new code is listed here, including the code that AppWizard generates. A list of the files and classes in the EX18A example are shown in the table below.

**Header File**

**Source Code File**

**Class**

**Description**

ex18a.h

ex18a.cpp

_CEx18aApp_

Application class (from AppWizard)

 

 

_CAboutDlg_

About dialog

MainFrm.h

MainFrm.cpp

_CMainFrame_

MDI main frame

ChildFrm.h

ChildFrm.cpp

_CChildFrame_

MDI child frame

StuDoc.h

StuDoc.cpp

_CStudentDoc_

Student document (from EX17A)

StuView.h

StuView.cpp

_CStudentView_

Student form view (from EX16B)

Student.h

Student.cpp

_CStudent_

Student record (from EX17A)

StdAfx.h

StdAfx.h

 

Precompiled headers (with afxtempl.h included)

_CEx18aApp_
-----------

In the _CEx18aApp_ source code listing, the _OpenDocumentFile_ member function is overridden only for the purpose of inserting a _TRACE_ statement. Also, a few lines have been added before the _ProcessShellCommand_ call in _InitInstance_. They check the argument to _ProcessShellCommand_ and change it if necessary to prevent the creation of any empty document window on startup. Figure 18-5 shows the source code.

**EX18A.H**

// ex18a.h : main header file for the EX18A application
//

#if !defined(AFX_EX18A_H__7B5FE267_85E9_11D0_8FE3_00C04FC2A0C2__INCLUDED_)
#define AFX_EX18A_H__7B5FE267_85E9_11D0_8FE3_00C04FC2A0C2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
    #error include \`stdafx.h' before including this file for PCH
#endif
#include "resource.h"       // main symbols

//////////////////////////////////////////////////////////////////////
// CEx18aApp:
// See ex18a.cpp for the implementation of this class
//

class CEx18aApp : public CWinApp
{
public:
    CEx18aApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEx18aApp)
    public:
    virtual BOOL InitInstance();
    virtual CDocument\* OpenDocumentFile(LPCTSTR lpszFileName);
    //}}AFX_VIRTUAL

// Implementation

    //{{AFX_MSG(CEx18aApp)
    afx_msg void OnAppAbout();
        // NOTE - the ClassWizard will add and remove member functions here.        
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

//////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations
//  immediately before the previous line.

#endif // !defined(AFX_EX18A_H__7B5FE267_85E9_11D0_8FE3_00C04FC2A0C2__INCLUDED_)

**EX18A.CPP**

// ex18a.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "ex18a.h"

#include "MainFrm.h"
#include "ChildFrm.h"
#include "StuDoc.h"
#include "StuView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// CEx18aApp

BEGIN_MESSAGE_MAP(CEx18aApp, CWinApp)
    //{{AFX_MSG_MAP(CEx18aApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

//////////////////////////////////////////////////////////////////////
// CEx18aApp construction

CEx18aApp::CEx18aApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}
    
//////////////////////////////////////////////////////////////////////
// The one and only CEx18aApp object

CEx18aApp theApp;

//////////////////////////////////////////////////////////////////////
// CEx18aApp initialization

BOOL CEx18aApp::InitInstance()
{
    AfxEnableControlContainer();

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

#ifdef _AFXDLL
    Enable3dControls();    // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();       // Call this when linking to MFC
                                    //  statically
#endif

    // Change the registry key under which our settings are stored.
    // TODO: You should modify this string to be something appropriate
    // such as the name of your company or organization.
    SetRegistryKey(_T("Local AppWizard-Generated Applications"));
    LoadStdProfileSettings();  // Load standard INI file options
                               //  (including MRU)
    // Register the application's document templates.  Document
    //  templates serve as the connection between documents, frame
    //  windows and views.

    CMultiDocTemplate\* pDocTemplate;
    pDocTemplate = new CMultiDocTemplate(
        IDR_EX18ATYPE,
        RUNTIME_CLASS(CStudentDoc),
        RUNTIME_CLASS(CChildFrame), // custom MDI child frame
        RUNTIME_CLASS(CStudentView));
    AddDocTemplate(pDocTemplate);

    // create main MDI Frame window
    CMainFrame\* pMainFrame = new CMainFrame;
    if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
        return FALSE;
    m_pMainWnd = pMainFrame;

    // Enable drag/drop open
    m_pMainWnd->DragAcceptFiles();

    // Enable DDE Execute open
    EnableShellOpen();
    RegisterShellFileTypes(TRUE);

    // Parse command line for standard shell commands, DDE, file open
    CCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);

    **// no empty document window on startup
    if (cmdInfo.m_nShellCommand == CCommandLineInfo::FileNew) {
        cmdInfo.m_nShellCommand = CCommandLineInfo::FileNothing;
    }**

    // Dispatch commands specified on the command line
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;

    // The main window has been initialized, so show and update it.
    pMainFrame->ShowWindow(m_nCmdShow);
    pMainFrame->UpdateWindow();

    return TRUE;
}
//////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange\* pDX); // DDX/DDV
                                                     // support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange\* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CEx18aApp::OnAppAbout()
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}
//////////////////////////////////////////////////////////////////////
// CEx18aApp message handlers

CDocument\* CEx18aApp::OpenDocumentFile(LPCTSTR lpszFileName) 
{
    **TRACE("CEx18aApp::OpenDocumentFile\n");**
    return CWinApp::OpenDocumentFile(lpszFileName);
}

**Figure 18-5.** _The_ CEx18aApp _source code listing._

_CMainFrame_
------------

This main frame class, listed in Figure 18-6, is almost identical to the SDI version, except that it's derived from _CMDIFrameWnd_ instead of _CFrameWnd_.

**MAINFRM.H**

// MainFrm.h : interface of the CMainFrame class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__7B5FE26B_85E9_11D0_8FE3_00C04FC2A0C2__INCLUDED_)
#define AFX_MAINFRM_H__7B5FE26B_85E9_11D0_8FE3_00C04FC2A0C2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CMainFrame : public CMDIFrameWnd
{
    DECLARE_DYNAMIC(CMainFrame)
public:
    CMainFrame();

// Attributes
public:
// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
    CStatusBar  m_wndStatusBar;
    CToolBar    m_wndToolBar;

// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations
//  immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__7B5FE26B_85E9_11D0_8FE3_00C04FC2A0C2__INCLUDED_)

**MAINFRM.CPP**

// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "ex18a.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)
BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    ON_WM_CREATE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
    ID_SEPARATOR,           // status line indicator
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
    ID_INDICATOR_SCRL,
};

//////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
    // TODO: add member initialization code here
}
CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD 
        | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS 
        | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    {
        TRACE0("Failed to create toolbar\n");
        return -1;      // fail to create
    }
    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0("Failed to create status bar\n");
        return -1;      // fail to create
    }

    // TODO: Delete these three lines if you don't want the toolbar to
    //  be dockable
    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
    EnableDocking(CBRS_ALIGN_ANY);
    DockControlBar(&m_wndToolBar);

    return 0;
}
BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    if ( !CMDIFrameWnd::PreCreateWindow(cs) )
        return FALSE;
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return TRUE;
}
//////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

//////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

**Figure 18-6.** _The_ CMainFrame _class listing._

_CChildFrame_
-------------

This child frame class, listed in Figure 18-7, lets you conveniently control the child frame window's characteristics by adding code in the _PreCreateWindow_ function. You can also map messages and override other virtual functions.

**CHILDFRM.H**

// ChildFrm.h : interface of the CChildFrame class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDFRM_H__7B5FE26D_85E9_11D0_8FE3_00C04FC2A0C2__INCLUDED_)
#define AFX_CHILDFRM_H__7B5FE26D_85E9_11D0_8FE3_00C04FC2A0C2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CChildFrame : public CMDIChildWnd
{
    DECLARE_DYNCREATE(CChildFrame)
public:
    CChildFrame();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CChildFrame)
    public:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual void ActivateFrame(int nCmdShow = -1);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CChildFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
    //{{AFX_MSG(CChildFrame)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations
//  immediately before the previous line.

#endif // !defined(AFX_CHILDFRM_H__7B5FE26D_85E9_11D0_8FE3_00C04FC2A0C2__INCLUDED_)

**CHILDFRM.CPP**

// ChildFrm.cpp : implementation of the CChildFrame class
//

#include "stdafx.h"
#include "ex18a.h"

#include "ChildFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
    //{{AFX_MSG_MAP(CChildFrame)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
    // TODO: add member initialization code here

}

CChildFrame::~CChildFrame()
{
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    if ( !CMDIChildWnd::PreCreateWindow(cs) )
        return FALSE;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
    CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
    CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

//////////////////////////////////////////////////////////////////////
// CChildFrame message handlers

void CChildFrame::ActivateFrame(int nCmdShow)
{
    **TRACE("Entering CChildFrame::ActivateFrame\n");**
    CMDIChildWnd::ActivateFrame(nCmdShow);
}

**Figure 18-7.** _The_ CChildFrame _class listing._

Testing the EX18A Application
-----------------------------

Do the build, run the program from Visual C++, and then make several documents. Try saving the documents on disk, closing them, and reloading them. Also, choose New Window from the Window menu. Notice that you now have two views (and child frames) attached to the same document. Now exit the program and start Windows Explorer. The files you created should show up with document icons. Double-click on a document icon and see whether the EX18A program starts up. Now, with both Windows Explorer and EX18A on the desktop, drag a document from Windows Explorer to EX18A. Was the file opened?
________________________________________________________________________
6.7. - [Chapter 19 -- Printing and Print Preview](invcpp5/ch19a.htm)
----------------------------------------------------
 Chapter 19 -- Printing and Print Preview  Chapter 19

Printing and Print Preview
==========================

If you're depending on the Win32 API alone, printing is one of the tougher programming jobs you'll have. If you don't believe me, just skim through the 60-page chapter "Using the Printer" in Charles Petzold's _Programming Windows 95_ (Microsoft Press, 1996). Other books about Microsoft Windows ignore the subject completely. The Microsoft Foundation Class (MFC) Library version 6.0 application framework goes a long way toward making printing easy. As a bonus, it adds a print preview capability that behaves like the print preview functions in commercial Windows-based programs such as Microsoft Word and Microsoft Excel.

In this chapter, you'll learn how to use the MFC library Print and Print Preview features. In the process, you'll get a feeling for what's involved in Windows printing and how it's different from printing in MS-DOS. First you'll do some wysiwyg printing, in which the printer output matches the screen display. This option requires careful use of mapping modes. Later you'll print a paginated data processing-style report that doesn't reflect the screen display at all. In that example, you will use a template array to structure your document so that the program can print any specified range of pages on demand.
________________________________________________________________________
6.7.1. - [Windows Printing](invcpp5/ch19b.htm)
----------------------------------------------------
 Windows Printing 

Windows Printing
================

In the old days, programmers had to worry about configuring their applications for dozens of printers. Now Windows makes life easy because it provides all of the printer drivers you'll ever need. It also supplies a consistent user interface for printing.

Standard Printer Dialogs
------------------------

When the user chooses Print from the File menu of a Windows-based application, the standard Print dialog appears, as shown in Figure 19-1.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f19og01x.gif)]

**Figure 19-1.** _The standard Print dialog._

If the user chooses Print Setup from the File menu, the standard Print Setup dialog appears, as shown in Figure 19-2.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F19OG02x.gif)]

**Figure 19-2.** _The standard Print Setup dialog._

During the printing process, the application displays a standard printer status dialog, as shown in Figure 19-3.

![](c:/dl/books/windows/msvc5th/invcpp5/images/F19OG03.GIF)

**Figure 19-3.** _The standard printer status dialog._

Interactive Print Page Selection
--------------------------------

If you've worked in the data processing field, you might be used to batch-mode printing. A program reads a record and then formats and prints selected information as a line in a report. Let's say, for example, that every time 50 lines have been printed the program ejects the paper and prints a new page heading. The programmer assumes that the whole report will be printed at one time and makes no allowance for interactively printing selected pages.

As Figure 19-1 shows, page numbers are important in Windows-based printing. A program must respond to a user's page selection by calculating which information to print and then printing the selected pages. If you're aware of this page selection requirement, you can design your application's data structures accordingly.

Remember the student list from [Chapter 17](ch17a.htm)? What if the list included 1000 students' names and the user wanted to print page 5 of a student report? If you assumed that each student record required one print line and that a page held 50 lines, page 5 would include records 201 through 250. With an MFC list collection class, you're stuck iterating through the first 200 list elements before you can start printing. Maybe the list isn't the ideal data structure. How about an array collection instead? With the _CObArray_ class (or with one of the template array classes), you can directly access the 201st student record.

Not every application has elements that map to a fixed number of print lines. Suppose the student record contained a multi-line text biography field. Because you wouldn't know how many biography lines each record included, you'd have to search through the whole file to determine the page breaks. If your program could remember those page breaks as it calculated them, its efficiency would increase.

Display Pages vs. Printed Pages
-------------------------------

In many cases, you'll want a printed page to correspond to a display page. As you learned in [Chapter 5](ch05a.htm), you cannot guarantee that objects will be printed exactly as they are displayed on screen. With TrueType fonts, however, your printed page will be pretty close. If you're working with full-size paper and you want the corresponding display to be readable, you'll certainly want a display window that is larger than the screen. Thus, a scrolling view such as the one that the _CScrollView_ class provides is ideal for your printable views.

Sometimes, however, you might not care about display pages. Perhaps your view holds its data in a list box, or maybe you don't need to display the data at all. In these cases, your program can contain stand-alone print logic that simply extracts data from the document and sends it to the printer. Of course, the program must properly respond to a user's page-range request. If you query the printer to determine the paper size and orientation (portrait or landscape), you can adjust the pagination accordingly.
________________________________________________________________________
6.7.2. - [Print Preview](invcpp5/ch19c.htm)
----------------------------------------------------
 Print Preview 

Print Preview
=============

The MFC library Print Preview feature shows you on screen the exact page and line breaks you'll get when you print your document on a selected printer. The fonts might look a little funny, especially in the smaller sizes, but that's not a problem. Look now at the print preview window that appears in "[The EX19A Example—A Wysiwyg Print Program](ch19e.htm)".

Print Preview is an MFC library feature, not a Windows feature. Don't underestimate how much effort went into programming Print Preview. The Print Preview program examines each character individually, determining its position based on the printer's device context. After selecting an approximating font, the program displays the character in the print preview window at the proper location.
________________________________________________________________________
6.7.3. - [Programming for the Printer](invcpp5/ch19d.htm)
----------------------------------------------------
 Programming for the Printer 

Programming for the Printer
===========================

The application framework does most of the work for printing and print preview. To use the printer effectively, you must understand the sequence of function calls and know which functions to override.

The Printer Device Context and the _CView::OnDraw_ Function
-----------------------------------------------------------

When your program prints on the printer, it uses a device context object of class _CDC_. Don't worry about where the object comes from; the application framework constructs it and passes it as a parameter to your view's _OnDraw_ function. If your application uses the printer to duplicate the display, the _OnDraw_ function can do double duty. If you're displaying, the _OnPaint_ function calls _OnDraw_ and the device context is the display context. If you're printing, _OnDraw_ is called by another _CView_ virtual function, _OnPrint_, with a printer device context as a parameter. The _OnPrint_ function is called once to print an entire page.

In print preview mode, the _OnDraw_ parameter is actually a pointer to a _CPreviewDC_ object. Your _OnPrint_ and _OnDraw_ functions work the same regardless of whether you're printing or previewing.

The _CView::OnPrint_ Function
-----------------------------

You've seen that the base class _OnPrint_ function calls _OnDraw_ and that _OnDraw_ can use both a display device context and a printer device context. The mapping mode should be set before _OnPrint_ is called. You can override _OnPrint_ to print items that you don't need on the display, such as a title page, headers, and footers. The _OnPrint_ parameters are as follows:

*   A pointer to the device context
    
*   A pointer to a print information object (_CPrintInfo_) that includes page dimensions, the current page number, and the maximum page number
    

In your overridden _OnPrint_ function, you can elect not to call _OnDraw_ at all to support print logic that is totally independent of the display logic. The application framework calls the _OnPrint_ function once for each page to be printed, with the current page number in the _CPrintInfo_ structure. You'll soon find out how the application framework determines the page number.

Preparing the Device Context—The _CView::OnPrepareDC_ Function
--------------------------------------------------------------

If you need a display mapping mode other than _MM_TEXT_ (and you often do), that mode is usually set in the view's _OnPrepareDC_ function. You override this function yourself if your view class is derived directly from _CView_, but it's already overridden if your view is derived from _CScrollView_. The _OnPrepareDC_ function is called in _OnPaint_ immediately before the call to _OnDraw_. If you're printing, the same _OnPrepareDC_ function is called, this time immediately before the application framework calls _OnPrint_. Thus, the mapping mode is set before both the painting of the view and the printing of a page.

The second parameter of the _OnPrepareDC_ function is a pointer to a _CPrintInfo_ structure. This pointer is valid only if _OnPrepareDC_ is being called prior to printing. You can test for this condition by calling the _CDC_ member function _IsPrinting_. The _IsPrinting_ function is particularly handy if you're using _OnPrepareDC_ to set different mapping modes for the display and the printer.

If you do not know in advance how many pages your print job requires, your overridden _OnPrepareDC_ function can detect the end of the document and reset the _m_bContinuePrinting_ flag in the _CPrintInfo_ structure. When this flag is _FALSE_, the _OnPrint_ function won't be called again and control will pass to the end of the print loop.

The Start and End of a Print Job
--------------------------------

When a print job starts, the application framework calls two _CView_ functions, _OnPreparePrinting_ and _OnBeginPrinting_. (AppWizard generates the _OnPreparePrinting_, _OnBeginPrinting_, and _OnEndPrinting_ functions for you if you select the Printing And Print Preview option.) The first function, _OnPreparePrinting_, is called before the display of the Print dialog. If you know the first and last page numbers, call _CPrintInfo::SetMinPage_ and _CPrintInfo::SetMaxPage_ in _OnPreparePrinting_. The page numbers you pass to these functions will appear in the Print dialog for the user to override.

The second function, _OnBeginPrinting_, is called after the Print dialog exits. Override this function to create Graphics Device Interface (GDI) objects, such as fonts, that you need for the entire print job. A program runs faster if you create a font once instead of re-creating it for each page.

The _CView_ function _OnEndPrinting_ is called at the end of the print job, after the last page has been printed. Override this function to get rid of GDI objects created in _OnBeginPrinting_.

The following table summarizes the important overridable _CView_ print loop functions.

**Function**

**Common Override Behavior**

_OnPreparePrinting_

Sets first and last page numbers

_OnBeginPrinting_

Creates GDI objects

_OnPrepareDC_ (for each page)

Sets mapping mode and optionally detects end of print job

_OnPrint_

Does print-specific output and then calls _OnDraw_ (for each page)

_OnEndPrinting_

Deletes GDI objects
________________________________________________________________________
6.7.4. - [The EX19A Example -- A Wysiwyg Print Program](invcpp5/ch19e.htm)
----------------------------------------------------
 The EX19A Example -- A Wysiwyg Print Program 

The EX19A Example—A Wysiwyg Print Program
=========================================

This example displays and prints a single page of text stored in a document. The printed image should match the displayed image. The _MM_TWIPS_ mapping mode is used for both printer and display. First we'll use a fixed drawing rectangle; later we'll base the drawing rectangle on the printable area rectangle supplied by the printer driver.

Here are the steps for building the example:

2.  **Run AppWizard to generate \vcpp32\ex19a\ex19a.** Accept the default options, and then rename the document and view classes and files as shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G19OG01x.GIF)
    
    Note that this is an MDI application.
    
3.  **Add a _CStringArray_ data member to the _CPoemDoc_ class.**Edit the PoemDoc.h header file or use ClassView.
    
    **public:
        CStringArray m_stringArray;**
    
    The document data is stored in a string array. The MFC library _CStringArray_ class holds an array of _CString_ objects, accessible by a zero-based subscript. You need not set a maximum dimension in the declaration because the array is dynamic.
    
4.  **Add a _CRect_ data member to the _CStringView_ class.** Edit the StringView.h header file or use ClassView:
    
    **private:
        CRect m_rectPrint;**
    
5.  **Edit three _CPoemDoc_ member functions in the file PoemDoc.cpp.** AppWizard generated skeleton _OnNewDocument_ and _Serialize_ functions, but we'll have to use ClassWizard to override the _DeleteContents_ function. We'll initialize the poem document in the overridden _OnNewDocument_ function. _DeleteContents_ is called in _CDocument::OnNewDocument_, so by calling the base class function first we're sure the poem won't be deleted. (The text, by the way, is an excerpt from the twentieth poem in Lawrence Ferlinghetti's book _A Coney Island of the Mind_.) Type 10 lines of your choice. You can substitute another poem or maybe your favorite Win32 function description. Add the following boldface code:
    
    BOOL CPoemDoc::OnNewDocument()
    {
        if (!CDocument::OnNewDocument())
            return FALSE;
    
        **m_stringArray.SetSize(10);
        m_stringArray[0] = "The pennycandystore beyond the El";
        m_stringArray[1] = "is where I first";
        m_stringArray[2] = "                  fell in love";
        m_stringArray[3] = "                      with unreality";
        m_stringArray[4] = "Jellybeans glowed in the semi-gloom";
        m_stringArray[5] = "of that september afternoon";
        m_stringArray[6] = "A cat upon the counter moved among";
        m_stringArray[7] = "                     the licorice sticks";
        m_stringArray[8] = "                  and tootsie rolls";
        m_stringArray[9] = "           and Oh Boy Gum";
    
       ** return TRUE;
    }
    
    > NOTE
    > 
    > The _CStringArray_ class supports dynamic arrays, but here we're using the _m_stringArray_ object as though it were a static array of 10 elements.
    
    The application framework calls the document's virtual _DeleteContents_ function when it closes the document; this action deletes the strings in the array. A _CStringArray_ contains actual objects, and a _CObArray_ contains pointers to objects. This distinction is important when it's time to delete the array elements. Here the _RemoveAll_ function actually deletes the string objects:
    
    void CPoemDoc::DeleteContents()
    {
       ** // called before OnNewDocument and when document is closed
        m_stringArray.RemoveAll();**
    }
    
    Serialization isn't important in this example, but the following function illustrates how easy it is to serialize strings. The application framework calls the _DeleteContents_ function before loading from the archive, so you don't have to worry about emptying the array. Add the following boldface code:
    
    void CPoemDoc::Serialize(CArchive& ar)
    {
       ** m_stringArray.Serialize(ar);**
    }
    
6.  **Edit the _OnInitialUpdate_ function in StringView.cpp.** You must override the function for all classes derived from _CScrollView_. This function's job is to set the logical window size and the mapping mode. Add the following boldface code:
    
    void CStringView::OnInitialUpdate()
    {
        CScrollView::OnInitialUpdate();
       ** CSize sizeTotal(m_rectPrint.Width(), -m_rectPrint.Height());
        CSize sizePage(sizeTotal.cx / 2,
                       sizeTotal.cy / 2);   // page scroll
        CSize sizeLine(sizeTotal.cx / 100,
                       sizeTotal.cy / 100); // line scroll
        SetScrollSizes(MM_TWIPS, sizeTotal, sizePage, sizeLine);**
    }
    
7.  **Edit the _OnDraw_ function in StringView.cpp.** The _OnDraw_ function of class _CStringView_ draws on both the display and the printer. In addition to displaying the poem text lines in 10-point roman font, it draws a border around the printable area and a crude ruler along the top and left margins. _OnDraw_ assumes the _MM_TWIPS_ mapping mode, in which 1 inch = 1440 units. Add the boldface code shown below.
    
    void CStringView::OnDraw(CDC\* pDC)
    {
        **int        i, j, nHeight;
        CString    str;
        CFont      font;
        TEXTMETRIC tm;**
    
        CPoemDoc\* pDoc = GetDocument();
        **// Draw a border — slightly smaller to avoid truncation
        pDC->Rectangle(m_rectPrint + CRect(0, 0, -20, 20));
        // Draw horizontal and vertical rulers
        j = m_rectPrint.Width() / 1440;
        for (i = 0; i <= j; i++) {
            str.Format("%02d", i);
            pDC->TextOut(i \* 1440, 0, str);
        }
        j = -(m_rectPrint.Height() / 1440);
        for (i = 0; i <= j; i++) {
            str.Format("%02d", i);
            pDC->TextOut(0, -i \* 1440, str);
        }**
        **// Print the poem 0.5 inch down and over;
        //  use 10-point roman font
        font.CreateFont(-200, 0, 0, 0, 400, FALSE, FALSE, 0, ANSI_CHARSET,
                        OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                        DEFAULT_QUALITY, DEFAULT_PITCH | FF_ROMAN,
                        "Times New Roman");
        CFont\* pOldFont = (CFont\*) pDC->SelectObject(&font);
        pDC->GetTextMetrics(&tm);
        nHeight = tm.tmHeight + tm.tmExternalLeading;
        TRACE("font height = %d, internal leading = %d\n",
              nHeight, tm.tmInternalLeading);
        j = pDoc->m_stringArray.GetSize();
        for (i = 0; i < j; i++) {
            pDC->TextOut(720, -i \* nHeight - 720, pDoc->m_stringArray[i]);
        }**
       ** pDC->SelectObject(pOldFont);
        TRACE("LOGPIXELSX = %d, LOGPIXELSY = %d\n",
              pDC->GetDeviceCaps(LOGPIXELSX),
              pDC->GetDeviceCaps(LOGPIXELSY));
        TRACE("HORZSIZE = %d, VERTSIZE = %d\n",
              pDC->GetDeviceCaps(HORZSIZE),
              pDC->GetDeviceCaps(VERTSIZE));**
    }
    
8.  **Edit the _OnPreparePrinting_ function in StringView.cpp.** This function sets the maximum number of pages in the print job. This example has only one page. It's absolutely necessary to call the base class _DoPreparePrinting_ function in your overridden _OnPreparePrinting_ function. Add the following boldface code:
    
    BOOL CStringView::OnPreparePrinting(CPrintInfo\* pInfo)
    {
       **pInfo->SetMaxPage(1);**
        return DoPreparePrinting(pInfo);
    }
    
9.  **Edit the constructor in StringView.cpp.** The initial value of the print rectangle should be 8-by-15 inches, expressed in twips (1 inch = 1440 twips). Add the following boldface code:
    
    CStringView::CStringView() **: m_rectPrint(0, 0, 11520, -15120)**
    {
    }
    
10.  **Build and test the application.** If you run the EX19A application under Microsoft Windows NT with the lowest screen resolution, your MDI child window will look like the one shown below. (The text will be larger under higher resolutions and under Windows 95 and Windows 98.)
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g19og02x.gif)]
    
    The window text is too small, isn't it? Go ahead and choose Print Preview from the File menu, and then click twice with the magnifying glass to enlarge the image. The print preview output is illustrated here.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g19og03x.gif)]
    
    Remember "logical twips" from [Chapter 5](ch05a.htm)? We're going to use logical twips now to enlarge type on the display while keeping the printed text the same size. This requires some extra work because the _CScrollView_ class wasn't designed for nonstandard mapping modes. You will be changing the view's base class from _CScrollView_ to _CLogScrollView_, which is a class that I created by copying and modifying the MFC code in ViewScrl.cpp. The files LogScrollView.h and LogScrollView.cpp are in the \vcpp32\ex19a directory on the companion CD-ROM.
    
11.  **Insert the _CScrollView_ class into the project.** Copy the files LogScrollView.h and LogScrollView.cpp from the companion CD-ROM if you have not done so already. Choose Add To Project from the Project menu, and then choose Files from the submenu. Select the two new files and click OK to insert them into the project.
    
12.  **Edit the StringView.h header file.** Add the following line at the top of the file:
    
    **#include "LogScrollView.h"**
    
    Then change the line
    
    class CStringView : public CScrollView
    
    to
    
    class CStringView : public C**Log**ScrollView
    
13.  **Edit the StringView.cpp file.** Globally replace all occurrences of _CScrollView_ with _CLogScrollView_. Then edit the _OnInitialUpdate_ function. Here is the edited code, which is much shorter:
    
    void CStringView::OnInitialUpdate()
    {
        CLogScrollView::OnInitialUpdate();
        CSize sizeTotal(m_rectPrint.Width(), -m_rectPrint.Height());
       ** SetLogScrollSizes(sizeTotal);**
    }
    
14.  **Build and test the application again.** Now the screen should look like this.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g19og04x.gif)]

Reading the Printer Rectangle
-----------------------------

The EX19A program prints in a fixed-size rectangle that's appropriate for a laser printer set to portrait mode with 8.5-by-11-inch (letter-size) paper. But what if you load European-size paper or you switch to landscape mode? The program should be able to adjust accordingly.

It's relatively easy to read the printer rectangle. Remember the _CPrintInfo_ pointer that's passed to _OnPrint_? That structure has a data member _m_rectDraw_ that contains the rectangle in logical coordinates. Your overridden _OnPrint_ function simply stuffs the rectangle in a view data member, and _OnDraw_ uses it. There's only one problem: you can't get the rectangle until you start printing, so the constructor still needs to set a default value for _OnDraw_ to use before printing begins.

If you want the EX19A program to read the printer rectangle and adjust the size of the scroll view, use ClassWizard to override _OnPrint_ and then code the function as follows:

void CStringView::OnPrint(CDC\* pDC, CPrintInfo\* pInfo)
{
    **m_rectPrint = pInfo->
m_rectDraw;
    SetLogScrollSizes(CSize(m_rectPrint.Width(), 
                      -
m_rectPrint.Height()));**
    CLogScrollView::OnPrint(pDC, pInfo);
}
________________________________________________________________________
6.7.5. - [Template Collection Classes Revisited -- The CArray Class](invcpp5/ch19f.htm)
----------------------------------------------------
 Template Collection Classes Revisited -- The CArray Class 

Template Collection Classes Revisited—The _CArray_ Class
========================================================

In EX16B in [Chapter 16](ch16a.htm), you saw the MFC library _CTypedPtrList_ template collection class, which was used to store a list of pointers to _CStudent_ objects. Another collection class, _CArray_, is appropriate for the next example, EX19B. This class is different from _CTypedPtrList_ in two ways. First, it's an array, with elements accessible by index, just like _CStringArray_ in EX19A. Second, the array holds actual objects, not pointers to objects. In EX19B, the elements are _CRect_ objects. The elements' class does not have to be derived from _CObject_, and indeed, _CRect_ is not.

As in EX16B, a _typedef_ makes the template collection easier to use. We use the statement

typedef CArray<CRect, CRect&> CRectArray;

to define an array class that holds _CRect_ objects and whose functions take _CRect_ reference parameters. (It's cheaper to pass a 32-bit pointer than to copy a 128bit object.) To use the template array, you declare an instance of _CRectArray_ and then you call _CArray_ member functions such as _SetSize_. You can also use the _CArray_ subscript operator to get and set elements.

The template classes _CArray_, _CList_, and _CMap_ are easy to use if the element class is sufficiently simple. The _CRect_ class fits that description because it contains no pointer data members. Each template class uses a global function, _SerializeElements_, to serialize all the elements in the collection. The default _SerializeElements_ function does a bitwise copy of each element to and from the archive.

If your element class contains pointers or is otherwise complex, you'll need to write your own _SerializeElements_ function. If you wrote this function for the rectangle array (not required), your code would look like this:

void AFXAPI SerializeElements(CArchive& ar, CRect\* pNewRects,
    int nCount)
{
    for (int i = 0; i < nCount; i++, pNewRects++) {
        if (ar.IsStoring()) {
            ar << \*pNewRects;
        }
        else {
            ar >> \*pNewRects;
        }
    }
}

When the compiler sees this function, it uses the function to replace the _SerializeElements_ function inside the template. This only works, however, if the compiler sees the _SerializeElements_ prototype before it sees the template class declaration.

> NOTE
> 
> The template classes depend on two other global functions, _ConstructElements_ and _DestructElements_. Starting with Visual C++ version 4.0, these functions call the element class constructor and destructor for each object. Therefore, there's no real need to replace them.
________________________________________________________________________
6.7.6. - [The EX19B Example -- A Multipage Print Program](invcpp5/ch19g.htm)
----------------------------------------------------
 The EX19B Example -- A Multipage Print Program 

The EX19B Example—A Multipage Print Program
===========================================

In this example, the document contains an array of 50 _CRect_ objects that define circles. The circles are randomly positioned in a 6-by-6-inch area and have random diameters of as much as 0.5 inch. The circles, when drawn on the display, look like two-dimensional simulations of soap bubbles. Instead of drawing the circles on the printer, the application prints the corresponding _CRect_ coordinates in numeric form, 12 to a page, with headers and footers.

2.  **Run AppWizard to generate \vcpp32\ex19b\ex19b.** Select Single Document, and accept the defaults for all the other settings. The options and the default class names are shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/g19og05x.gif)
    
3.  **Edit the StdAfx.h header file.** You'll need to bring in the declarations for the MFC template collection classes. Add the following statement:
    
    **#include <afxtempl.h>**
    
4.  **Edit the ex19bDoc.h header file.** In the EX19A example, the document data consists of strings stored in a _CStringArray_ collection. Because we're using a template collection for ellipse rectangles, we'll need a _typedef_ statement outside the class declaration, as shown here:
    
    **typedef CArray<CRect, CRect&> CRectArray;**
    
    Next add the following public data members to the ex19bDoc.h header file:
    
    **public:
        enum { nLinesPerPage = 12 };
        enum { nMaxEllipses = 50 };
        CRectArray m_ellipseArray;**
    
    The two enumerations are object-oriented replacements for _#define_s.
    
5.  **Edit the ex19bDoc.cpp implementation file.** The overridden _OnNew Document_ function initializes the ellipse array with some random values, and the _Serialize_ function reads and writes the whole array. AppWizard generated the skeletons for both functions. You don't need a _DeleteContents_ function because the _CArray_ subscript operator writes a new _CRect_ object on top of any existing one. Add the following boldface code:
    
    BOOL CEx19bDoc::OnNewDocument()
    {
        if (!CDocument::OnNewDocument())
            return FALSE;
    
        **int n1, n2, n3;
        // Make 50 random circles
        srand((unsigned) time(NULL));
        m_ellipseArray.SetSize(nMaxEllipses);
    
        for (int i = 0; i < nMaxEllipses; i++) {
            n1 = rand() \* 600 / RAND_MAX;
            n2 = rand() \* 600 / RAND_MAX;
            n3 = rand() \* 50  / RAND_MAX;
            m_ellipseArray[i] = CRect(n1, -n2, n1 + n3, -(n2 + n3));
        }**
    
        return TRUE;
    }
    
    void CEx19bDoc::Serialize(CArchive& ar)
    {
        **m_ellipseArray.Serialize(ar);**
    }
    
6.  **Edit the ex19bView.h header file.** Use ClassView to add the member variable and two function prototypes listed below. ClassView will also generate skeletons for the functions in ex19bView.cpp.
    
    **public:
        int m_nPage;
    private:
        void PrintPageHeader(CDC \*pDC);
        void PrintPageFooter(CDC \*pDC);**
    
    The _m_nPage_ data member holds the document's current page number for printing. The private functions are for the header and footer subroutines.
    
7.  **Edit the _OnDraw_ function in ex19bView.cpp.** The overridden _OnDraw_ function simply draws the bubbles in the view window. Add the boldface code shown here:
    
    void CEx19bView::OnDraw(CDC\* pDC)
    {
        **int i, j;**
    
        CEx19bDoc\* pDoc = GetDocument();
        **j = pDoc->m_ellipseArray.GetUpperBound();
        for (i = 0; i < j; i++) {
            pDC->Ellipse(pDoc->m_ellipseArray[i]);
        }**
    }
    
8.  **Insert the _OnPrepareDC_ function in ex19bView.cpp.** The view class is not a scrolling view, so the mapping mode must be set in this function. Use ClassWizard to override the _OnPrepareDC_ function, and then add the following boldface code:
    
    void CEx19bView::OnPrepareDC(CDC\* pDC, CPrintInfo\* pInfo)
    {
      **  pDC->SetMapMode(MM_LOENGLISH);**
    }
    
9.  **Insert the _OnPrint_ function in ex19bView.cpp.** The _CView_ default _OnPrint_ function calls _OnDraw_. In this example, we want the printed output to be entirely different from the displayed output, so the _OnPrint_ function must take care of the print output without calling _OnDraw_. _OnPrint_ first sets the mapping mode to _MM_TWIPS_, and then it creates a fixed-pitch font. After printing the numeric contents of 12 _m_ellipseArray_ elements, _OnPrint_ deselects the font. You could have created the font once in _OnBeginPrinting_, but you wouldn't have noticed the increased efficiency. Use ClassWizard to override the _OnPrint_ function, and then add the following boldface code:
    
    void CEx19bView::OnPrint(CDC\* pDC, CPrintInfo\* pInfo)
    {
        **int        i, nStart, nEnd, nHeight;
        CString    str;
        CPoint     point(720, -1440);
        CFont      font;
        TEXTMETRIC tm;**
    
        **pDC->SetMapMode(MM_TWIPS);
        CEx19bDoc\* pDoc = GetDocument();
        m_nPage = pInfo->m_nCurPage; // for PrintPageFooter's benefit
        nStart = (m_nPage - 1) \* CEx19bDoc::nLinesPerPage;
        nEnd = nStart + CEx19bDoc::nLinesPerPage;
         // 14-point fixed-pitch font
        font.CreateFont(-280, 0, 0, 0, 400, FALSE, FALSE,
                        0, ANSI_CHARSET, OUT_DEFAULT_PRECIS,
                        CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                        DEFAULT_PITCH | FF_MODERN, "Courier New");
                        // Courier New is a TrueType font**
        **CFont\* pOldFont = (CFont\*) (pDC->SelectObject(&font));
        PrintPageHeader(pDC);
        pDC->GetTextMetrics(&tm);
        nHeight = tm.tmHeight + tm.tmExternalLeading;
        for (i = nStart; i < nEnd; i++) {
            if (i > pDoc->m_ellipseArray.GetUpperBound()) {
                break;
            }
            str.Format("%6d %6d %6d %6d %6d", i + 1,
                       pDoc->m_ellipseArray[i].left,
                       pDoc->m_ellipseArray[i].top,
                       pDoc->m_ellipseArray[i].right,
                       pDoc->m_ellipseArray[i].bottom);
            point.y -= nHeight;
            pDC->TextOut(point.x, point.y, str);
        }
        PrintPageFooter(pDC);**
       ** pDC->SelectObject(pOldFont);**
    }
    
10.  **Edit the _OnPreparePrinting_ function in ex19bView.cpp.** The _OnPreparePrinting_ function (whose skeleton is generated by AppWizard) computes the number of pages in the document and then communicates that value to the application framework through the _SetMaxPage_ function. Add the following boldface code:
    
    BOOL CEx19bView::OnPreparePrinting(CPrintInfo\* pInfo)
    {
        **CEx19bDoc\* pDoc = GetDocument();
        pInfo->SetMaxPage(pDoc->m_ellipseArray.GetUpperBound() /
                          CEx19bDoc::nLinesPerPage + 1);**
        return DoPreparePrinting(pInfo);
    }
    
11.  **Insert the page header and footer functions in ex19bView.cpp.** These private functions, called from _OnPrint_, print the page headers and the page footers. The page footer includes the page number, stored by _OnPrint_ in the view class data member _m_nPage_. The _CDC::GetTextExtent_ function provides the width of the page number so that it can be right-justified. Add the boldface code shown here:
    
    void CEx19bView::PrintPageHeader(CDC\* pDC)
    {
        **CString str;
    
        CPoint point(0, 0);
        pDC->TextOut(point.x, point.y, "Bubble Report");
        point += CSize(720, -720);
        str.Format("%6.6s %6.6s %6.6s %6.6s %6.6s",
                   "Index", "Left", "Top", "Right", "Bottom");
        pDC->TextOut(point.x, point.y, str);**
    }
    
    void CEx19bView::PrintPageFooter(CDC\* pDC)
    {
        **CString str;
    
        CPoint point(0, -14400); // Move 10 inches down
        CEx19bDoc\* pDoc = GetDocument();
        str.Format("Document %s", (LPCSTR) pDoc->GetTitle());
        pDC->TextOut(point.x, point.y, str);
        str.Format("Page %d", m_nPage);
        CSize size = pDC->GetTextExtent(str);
        point.x += 11520 - size.cx;
        pDC->TextOut(point.x, point.y, str); // right-justified**
    }
    
12.  **Build and test the application.** For one set of random numbers, the bubble view window looks like this.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g19og06x.gif)]
    
    Each time you choose New from the File menu, you should see a different picture. In Print Preview, the first page of the output should look like this.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g19og07x.gif)]
    
    With the Print dialog, you can specify any range of pages to print.
________________________________________________________________________
6.8. - [Chapter 20 -- Splitter Windows and Multiple Views](invcpp5/ch20a.htm)
----------------------------------------------------
 Chapter 20 -- Splitter Windows and Multiple Views  Chapter 20

Splitter Windows and Multiple Views
===================================

Except for the EX18A example, each program you've seen so far in this book has had only one view attached to a document. If you've used a Microsoft Windows-based word processor, you know that it's convenient to have two windows open simultaneously on various parts of a document. Both windows might contain normal views, or one window might contain a page layout view and another might contain an outline view.

With the application framework, you can use a splitter window or multiple MDI child windows to display multiple views. You'll learn about both presentation options here, and you'll see that it's easy to make multiple view objects of the same view class (the normal view) in both cases. It's slightly more difficult, however, to use two or more view classes in the same application (say, the outline view and the page layout view).

This chapter emphasizes the selection and presentation of multiple views. The examples depend on a document with data initialized in the _OnNewDocument_ function. Look back now to [Chapter 16](ch16a.htm) for a review of document-view communication.
________________________________________________________________________
6.8.1. - [The Splitter Window](invcpp5/ch20b.htm)
----------------------------------------------------
 The Splitter Window 

The Splitter Window
===================

A splitter window appears as a special type of frame window that holds several views in panes. The application can split the window on creation, or the user can split the window by choosing a menu command or by dragging a splitter box on the window's scroll bar. After the window has been split, the user can move the splitter bars with the mouse to adjust the relative sizes of the panes. Splitter windows can be used in both SDI and MDI applications. You can see examples of splitter windows in this chapter.

An object of class _CSplitterWnd_ represents the splitter window. As far as Windows is concerned, a _CSplitterWnd_ object is an actual window that fully occupies the frame window (_CFrameWnd_ or _CMDIChildWnd_) client area. The view windows occupy the splitter window pane areas. The splitter window does not take part in the command dispatch mechanism. The active view window (in a splitter pane) is connected directly to its frame window.
________________________________________________________________________
6.8.2. - [View Options](invcpp5/ch20c.htm)
----------------------------------------------------
 View Options 

View Options
============

When you combine multiview presentation methods with application models, you get a number of permutations. Here are some of them:

*   **SDI application with splitter window, single view class** This chapter's first example, EX20A, covers this case. Each splitter window pane can be scrolled to a different part of the document. The programmer determines the maximum number of horizontal and vertical panes; the user makes the split at runtime.
    
*   **SDI application with splitter window, multiple view classes** The EX20B example illustrates this case. The programmer determines the number of panes and the sequence of views; the user can change the pane size at runtime.
    
*   **SDI application with no splitter windows, multiple view classes** The EX20C example illustrates this case. The user switches view classes by making a selection from a menu.
    
*   **MDI application with no splitter windows, single view class** This is the standard MDI application you've seen already in [Chapter 18](ch18a.htm). The New Window menu item lets the user open a new child window for a document that's open already.
    
*   **MDI application with no splitter windows, multiple view classes** A small change to the standard MDI application allows the use of multiple views. As example EX20D shows, all that's necessary is to add a menu item and a handler function for each additional view class available.
    
*   **MDI application with splitter child windows** This case is covered thoroughly in the online documentation. The SCRIBBLE example illustrates the splitting of an MDI child window.
________________________________________________________________________
6.8.3. - [Dynamic and Static Splitter Windows](invcpp5/ch20d.htm)
----------------------------------------------------
 Dynamic and Static Splitter Windows 

Dynamic and Static Splitter Windows
===================================

A dynamic splitter window allows the user to split the window at any time by choosing a menu item or by dragging a splitter box located on the scroll bar. The panes in a dynamic splitter window generally use the same view class. The top left pane is initialized to a particular view when the splitter window is created. In a dynamic splitter window, scroll bars are shared among the views. In a window with a single horizontal split, for example, the bottom scroll bar controls both views. A dynamic splitter application starts with a single view object. When the user splits the frame, other view objects are constructed. When the user unsplits the frame, view objects are destroyed.

The panes of a static splitter window are defined when the window is first created and they cannot be changed. The user can move the bars but cannot unsplit or resplit the window. Static splitter windows can accommodate multiple view classes, with the configuration set at creation time. In a static splitter window, each pane has separate scroll bars. In a static splitter window application, all view objects are constructed when the frame is constructed and they are all destroyed when the frame is destroyed.
________________________________________________________________________
6.8.4. - [The EX20A Example -- A Single View Class SDI Dynamic Splitter](invcpp5/ch20e.htm)
----------------------------------------------------
 The EX20A Example -- A Single View Class SDI Dynamic Splitter 

The EX20A Example— A Single View Class SDI Dynamic Splitter
===========================================================

In this example, the user can dynamically split the view into four panes with four separate view objects, all managed by a single view class. We'll use the document and the view code from EX19A. AppWizard lets you add a dynamic splitter window to a new application. Create an SDI project. Click the Advanced button in the AppWizard Step 4 dialog. Click on the Window Styles tab, and select Use Split Window as shown here.

![](c:/dl/books/windows/msvc5th/invcpp5/images/g20og01.gif)

When you check the Use Split Window check box, AppWizard adds code to your _CMainFrame_ class. Of course, you could add the same code to the _CMainFrame_ class of an existing application to add splitter capability.

Resources for Splitting
-----------------------

When AppWizard generates an application with a splitter frame, it includes a Split option in the project's View menu. The _ID_WINDOW_SPLIT_ command ID is mapped in the _CView_ class within the MFC library.

_CMainFrame_
------------

The application's main frame window class needs a splitter window data member and a prototype for an overridden _OnCreateClient_ function. Here are the additions that AppWizard makes to the MainFrm.h file:

protected:
    CSplitterWnd m_wndSplitter;
public:
    virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext\* pContext);

The application framework calls the _CFrameWnd::OnCreateClient_ virtual member function when the frame object is created. The base class version creates a single view window as specified by the document template. The AppWizard-generated _OnCreateClient_ override shown here (in MainFrm.cpp) creates a splitter window instead, and the splitter window creates the first view:

BOOL CMainFrame::OnCreateClient( LPCREATESTRUCT /\*lpcs\*/,
    CCreateContext\* pContext)
{
    return m_wndSplitter.Create( this,
        2, 2,           // TODO: adjust the number of rows, columns
        CSize(10, 10),  // TODO: adjust the minimum pane size
        pContext);
}

The _CSplitterWnd Create_ member function creates a dynamic splitter window, and the _CSplitterWnd_ object knows the view class because its name is embedded in the _CCreateContext_ structure that's passed as a parameter to _Create_.

The second and third _Create_ parameters (2, 2) specify that the window can be split into a maximum of two rows and two columns. If you changed the parameters to (2, 1), you would allow only a single horizontal split. The parameters (1, 2) allow only a single vertical split. The _CSize_ parameter specifies the minimum pane size.

Testing the EX20A Application
-----------------------------

When the application starts, you can split the window by choosing Split from the View menu or by dragging the splitter boxes at the left and top of the scroll bars. Figure 20-1 shows a typical single view window with a four-way split. Multiple views share the scroll bars.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F20OG01x.gif)]

**Figure 20-1.** _A single view window with a four-way split._
________________________________________________________________________
6.8.5. - [The EX20B Example -- A Double View Class SDI Static Splitter](invcpp5/ch20f.htm)
----------------------------------------------------
 The EX20B Example -- A Double View Class SDI Static Splitter 

The EX20B Example—A Double View Class SDI Static Splitter
=========================================================

In EX20B, we'll extend EX20A by defining a second view class and allowing a static splitter window to show the two views. (The H and CPP files are cloned from the original view class.) This time the splitter window works a little differently. Instead of starting off as a single pane, the splitter is initialized with two panes. The user can move the bar between the panes by dragging it with the mouse or by choosing the Window Split menu item.

The easiest way to generate a static splitter application is to let AppWizard generate a dynamic splitter application and then edit the generated _CMainFrame::OnCreateClient_ function.

_CHexView_
----------

The _CHexView_ class was written to allow programmers to appreciate poetry. It is essentially the same code used for _CStringView_ except for the _OnDraw_ member function:

void C**Hex**View::OnDraw(CDC\* pDC)
{
    **// hex dump of document strings**
    int        i, j, **k, l, n,** nHeight;
    CString    **outputLine,** str;
    CFont      font;
    TEXTMETRIC tm;

    CPoemDoc\* pDoc = GetDocument();
    **font.CreateFont(-160, 80, 0, 0, 400, FALSE, FALSE, 0,
        ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
        DEFAULT_QUALITY, DEFAULT_PITCH | FF_SWISS, "Arial");**
    CFont\* pOldFont = pDC->SelectObject(&font);
    pDC->GetTextMetrics(&tm);
    nHeight = tm.tmHeight + tm.tmExternalLeading;

    j = pDoc->m_stringArray.GetSize();
    for (i = 0; i < j; i++) {
        **outputLine.Format("%02x   ", i);
        l = pDoc->m_stringArray[i].GetLength();
        for (k = 0; k < l; k++) {
            n = pDoc->m_stringArray[i][k] & 0x00ff;
            str.Format("%02x ", n);
            outputLine += str;
        }**
        pDC->TextOut(720, -i \* nHeight - 720, **outputLine**);
    }
    pDC->SelectObject(pOldFont);
}

This function displays a hexadecimal dump of all strings in the document's _m_stringArray_ collection. Notice the use of the subscript operator to access individual characters in a _CString_ object.

_CMainFrame_
------------

As in EX20A, the EX20B application's main frame window class needs a splitter window data member and a prototype for an overridden _OnCreateClient_ function. You can let AppWizard generate the code by specifying Use Split Window, as in EX20A. You won't have to modify the MainFrm.h file.

The implementation file, MainFrm.cpp, needs both view class headers (and the prerequisite document header), as shown here:

**#include "PoemDoc.h"
#include "StringView.h"
#include "HexView.h"**

AppWizard generates dynamic splitter code in the _OnCreateClient_ function, so you'll have to do some editing if you want a static splitter. Instead of calling _CSplitterWnd::Create_, you'll call the _CSplitterWnd::CreateStatic_ function, which is tailored for multiple view classes. The following calls to _CSplitterWnd::CreateView_ attach the two view classes. As the second and third _CreateStatic_ parameters (2, 1) dictate, this splitter window contains only two panes. The horizontal split is initially 100 device units from the top of the window. The top pane is the string view; the bottom pane is the hex dump view. The user can change the splitter bar position but the view configuration cannot be changed.

BOOL CMainFrame::OnCreateClient( LPCREATESTRUCT /\*lpcs\*/,
    CCreateContext\* pContext)
{
    **VERIFY(m_wndSplitter.CreateStatic(this, 2, 1));
    VERIFY(m_wndSplitter.CreateView(0, 0, RUNTIME_CLASS(CStringView),
                                    CSize(100, 100), pContext));
    VERIFY(m_wndSplitter.CreateView(1, 0, RUNTIME_CLASS(CHexView),
                                    CSize(100, 100), pContext));
    return TRUE;**
}

Testing the EX20B Application
-----------------------------

When you start the EX20B application, the window should look like the one shown below. Notice the separate horizontal scroll bars for the two views.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G20OG02x.gif)]
________________________________________________________________________
6.8.6. - [The EX20C Example -- Switching View Classes Without a Splitter](invcpp5/ch20g.htm)
----------------------------------------------------
 The EX20C Example -- Switching View Classes Without a Splitter 

The EX20C Example—Switching View Classes Without a Splitter
===========================================================

Sometimes you just want to switch view classes under program control and you don't want to be bothered with a splitter window. The EX20C example is an SDI application that switches between _CStringView_ and _CHexView_ in response to selections on the View menu. Starting with what AppWizard generates, all you need to do is add two new menu commands and then add some code to the _CMainFrame_ class. You also need to change the _CStringView_ and _CHexView_ constructors from protected to public.

Resource Requirements
---------------------

The following two items have been added to the View menu in the _IDR_MAINFRAME_ menu resource.

**Caption**

**Command ID**

**_CMainFrame_ Function**

St&ring View

_ID_VIEW_STRINGVIEW_

_OnViewStringView_

&Hex View

_ID_VIEW_HEXVIEW_

_OnViewHexView_

ClassWizard was used to add the command-handling functions (and corresponding update command UI handlers) to the _CMainFrame_ class.

_CMainFrame_
------------

The _CMainFrame_ class gets a new private helper function, _SwitchToView_, which is called from the two menu command handlers. The _enum_ parameter tells the function which view to switch to. Here are the two added items in the MainFrm.h header file:

**private:
    enum eView { STRING = 1, HEX = 2 };
    void SwitchToView(eView nView);**

The _SwitchToView_ function (in MainFrm.cpp) makes some low-level MFC calls to locate the requested view and to activate it. Don't worry about how it works. Just adapt it to your own applications when you want the view- switching feature. Add the following code:

**void CMainFrame::SwitchToView(eView nView)
{
    CView\* pOldActiveView = GetActiveView();
    CView\* pNewActiveView = (CView\*) GetDlgItem(nView);
    if (pNewActiveView == NULL) {
        switch (nView) {
        case STRING:
            pNewActiveView = (CView\*) new CStringView;
            break;
        case HEX:
            pNewActiveView = (CView\*) new CHexView;
            break;
        }
        CCreateContext context;
        context.m_pCurrentDoc = pOldActiveView->GetDocument();
        pNewActiveView->Create(NULL, NULL, WS_BORDER,
            CFrameWnd::rectDefault, this, nView, &context);
        pNewActiveView->OnInitialUpdate();
    }
    SetActiveView(pNewActiveView);
    pNewActiveView->ShowWindow(SW_SHOW);
    pOldActiveView->ShowWindow(SW_HIDE);
    pOldActiveView->SetDlgCtrlID(
        pOldActiveView->GetRuntimeClass() == 
        RUNTIME_CLASS(CStringView) ? STRING : HEX);
    pNewActiveView->SetDlgCtrlID(AFX_IDW_PANE_FIRST);
    RecalcLayout();
}**

Finally, here are the menu command handlers and update command UI handlers that ClassWizard initially generated (along with message map entries and prototypes). The update command UI handlers test the current view's class.

void CMainFrame::OnViewStringView()
{
    **SwitchToView(STRING);**
}

void CMainFrame::OnUpdateViewStringView(CCmdUI\* pCmdUI)
{
    **pCmdUI->Enable(
        !GetActiveView()->IsKindOf(RUNTIME_CLASS(CStringView)));**
}

void CMainFrame::OnViewHexView()
{
    **SwitchToView(HEX);**
}

void CMainFrame::OnUpdateViewHexView(CCmdUI\* pCmdUI)
{
    **pCmdUI->Enable(
        !GetActiveView()->IsKindOf(RUNTIME_CLASS(CHexView)));**
}

Testing the EX20C Application
-----------------------------

The EX20C application initially displays the _CStringView_ view of the document. You can toggle between the _CStringView_ and _CHexView_ views by choosing the appropriate command from the View menu. Both views of the document are shown side by side in Figure 20-2.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F20OG02x.gif)]

**Figure 20-2.** _The_ CStringView _view and the_ CHexView _view of the document._
________________________________________________________________________
6.8.7. - [The EX20D Example -- A Multiple View Class MDI Application](invcpp5/ch20h.htm)
----------------------------------------------------
 The EX20D Example -- A Multiple View Class MDI Application 

The EX20D Example—A Multiple View Class MDI Application
=======================================================

The final example, EX20D, uses the previous document and view classes to create a multiple view class MDI application without a splitter window. The logic is different from the logic in the other multiple view class applications. This time the action takes place in the application class in addition to the main frame class. As you study EX20D, you'll gain more insight into the use of _CDocTemplate_ objects.

This example was generated with the AppWizard Context-Sensitive Help option. In [Chapter 21](ch21a.htm), you'll activate the context-sensitive help capability.

If you're starting from scratch, use AppWizard to generate an ordinary MDI application with one of the view classes. Then add the second view class to the project and modify the application class files and main frame class files as described in the following sections.

Resource Requirements
---------------------

The two items below have been added to the Window menu in the _IDR_EX20DTYPE_ menu resource.

**Caption**

**Command ID**

**_CMainFrame_ Function**

New &String Window (replaces New Window item)

_ID_WINDOW_NEW_STRING_

_CMDIFrameWnd::OnWindowNew_

New &Hex Window

_ID_WINDOW_NEW_HEX_

_OnWindowNewHex_

ClassWizard was used to add the command-handling function _OnWindowNewHex_ to the _CMainFrame_ class.

_CEx20dApp_
-----------

In the application class header file, ex20d.h, the following data member and function prototype have been added:

**public:
    CMultiDocTemplate\* m_pTemplateHex;**

The implementation file, ex20d.cpp, contains the _#include_ statements shown here:

#include "PoemDoc.h"
#include "StringView.h"
**#include "HexView.h"**

The _CEx20dApp InitInstance_ member function has the code shown below inserted immediately after the _AddDocTemplate_ function call.

**m_pTemplateHex = new CMultiDocTemplate(
    IDR_EX20DTYPE,
    RUNTIME_CLASS(CPoemDoc),
    RUNTIME_CLASS(CChildFrame),
    RUNTIME_CLASS(CHexView));**

The _AddDocTemplate_ call generated by AppWizard established the primary document/frame/view combination for the application that is effective when the program starts. The template object above is a secondary template that can be activated in response to the New Hex Window menu item.

Now all you need is an _ExitInstance_ member function that cleans up the secondary template:

int CEx20dApp::ExitInstance()
{
    **delete m_pTemplateHex;**
    return CWinApp::ExitInstance(); **// saves profile settings**
}

_CMainFrame_
------------

The main frame class implementation file, MainFrm.cpp, has the _CHexView_ class header (and the prerequisite document header) included:

**#include "PoemDoc.h"
#include "HexView.h"**

The base frame window class, _CMDIFrameWnd_, has an _OnWindowNew_ function that is normally connected to the standard New Window menu item on the Window menu. The New String Window menu item is mapped to this function in EX20D. The New Hex Window menu item is mapped to the command handler function below to create new hex child windows. The function is a clone of _OnWindowNew_, adapted for the hex view-specific template defined in _InitInstance_.

void CMainFrame::OnWindowNewHex() 
{
    **CMDIChildWnd\* pActiveChild = MDIGetActive();
    CDocument\* pDocument;
    if (pActiveChild == NULL ||
            (pDocument = pActiveChild->GetActiveDocument()) == NULL) {
        TRACE("Warning:  No active document for WindowNew command\n");
        AfxMessageBox(AFX_IDP_COMMAND_FAILURE);
        return; // Command failed
    }

    // Otherwise, we have a new frame!
    CDocTemplate\* pTemplate =
        ((CEx20dApp\*) AfxGetApp())->m_pTemplateHex;
    ASSERT_VALID(pTemplate);
    CFrameWnd\* pFrame =
        pTemplate->CreateNewFrame(pDocument, pActiveChild);
    if (pFrame == NULL) {
        TRACE("Warning:  failed to create new frame\n");
        AfxMessageBox(AFX_IDP_COMMAND_FAILURE);
        return; // Command failed
    }

    pTemplate->InitialUpdateFrame(pFrame, pDocument);**
}

> NOTE
> 
> The function cloning above is a useful MFC programming technique. You must first find a base class function that does almost what you want, and then copy it from the \VC98\mfc\src subdirectory into your derived class, changing it as required. The only danger of cloning is that subsequent versions of the MFC library might implement the original function differently.

Testing the EX20D Application
-----------------------------

When you start the EX20D application, a text view child window appears. Choose New Hex Window from the Window menu. The application should look like this.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G20OG03x.gif)]
________________________________________________________________________
6.9. - [Chapter 21 -- Context-Sensitive Help](invcpp5/ch21a.htm)
----------------------------------------------------
 Chapter 21 -- Context-Sensitive Help  Chapter 21

Context-Sensitive Help
======================

Help technology is in a transition phase at the moment. The Hypertext Markup Language (HTML) format seems to be replacing rich text format (RTF). You can see this in the new Visual C++ online documentation via the MSDN viewer, which uses a new HTML-based help system called HTML Help. Microsoft is developing tools for compiling and indexing HTML files that are not shipped with Visual C++ 6.0. In the meantime, Microsoft Foundation Class (MFC) Library version 6.0 application framework programs are set up to use the WinHelp help engine included with Microsoft Windows. That means you'll be writing RTF files and your programs will be using compiled HLP files.

This chapter first shows you how to construct and process a simple stand-alone help file that has a table of contents and lets the user jump between topics. Next you'll see how your MFC library program activates WinHelp with help context IDs derived from window and command IDs keyed to an AppWizard-generated help file. Finally you'll learn how to use the MFC library help message routing system to customize the help capability.
________________________________________________________________________
6.9.1. - [The Windows WinHelp Program](invcpp5/ch21b.htm)
----------------------------------------------------
 The Windows WinHelp Program 

**The Windows WinHelp Program**
===============================

If you've used commercial Windows-based applications, you've probably marveled at their sophisticated help screens: graphics, hyperlinks, and popups abound. At some software firms, including Microsoft, help authoring has been elevated to a profession in its own right. This section won't turn you into a help expert, but you can get started by learning to prepare a simple no-frills help file.

**Rich Text Format**
--------------------

The original Windows SDK documentation showed you how to format help files with the ASCII file format called rich text format. We'll be using rich text format too, but we'll be working in wysiwyg mode, thereby avoiding the direct use of awkward escape sequences. You'll write with the same fonts, sizes, and styles that your user sees on the help screens. You'll definitely need a word processor that handles RTF. I've used Microsoft Word for this book, but many other word processors accommodate the RTF format.

> NOTE
> 
> Several commercial Windows help tools are available, including RoboHELP from Blue Sky Software and ForeHelp from the Forefront Corporation. RoboHELP is a set of templates and macros for Microsoft Word, and ForeHelp is a stand-alone package that simulates WinHelp, giving you immediate feedback as you write the help system.

**Writing a Simple Help File**
------------------------------

We're going to write a simple help file with a table of contents and three topics. This help file is designed to be run directly from WinHelp and started from Windows. No C++ programming is involved. Here are the steps:

2.  **Create a \vcpp32\ex21a subdirectory.**
    
3.  **Write the main help text file.** Use Microsoft Word (or another RTF-compatible word processor) to type text as shown here.
    
     [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g21og01x.gif)]
     Be sure to apply the double-underline and hidden text formatting correctly and to insert the page break at the correct place.
    
    > NOTE
    > 
    > To see hidden text, you must turn on your word processor's hidden text viewing mode. In Word, choose Options from the Tools menu, click on the View tab, and select All in the Nonprinting Characters section.
    
4.  **Insert footnotes for the Table Of Contents screen.** The Table Of Contents screen is the first topic screen in this help system. Using the specified custom footnote marks, insert the following footnotes at the beginning of the topic title.
    
    **Footnote Mark**
    
    **Text**
    
    **Description**
    
    #
    
    HID_CONTENTS
    
    Help context ID
    
    $
    
    SIMPLE Help Contents
    
    Topic title
    
    When you're finished with this step, the document should look like this.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g21og02x.gif)]
    
5.  **Insert footnotes for the Help Topic 1 screen.** The Help Topic 1 screen is the second topic screen in the help system. Using the specified custom footnote marks, insert the footnotes shown here.
    
    **Footnote Mark**
    
    **Text**
    
    **Description**
    
    #
    
    HID_TOPIC1
    
    Help context ID
    
    $
    
    SIMPLE Help Topic 1
    
    Topic title
    
    K
    
    SIMPLE Topics
    
    Keyword text
    
6.  **Clone the Help Topic 1 screen.** Copy the entire Help Topic 1 section of the document—including the page break—to the clipboard, and then paste two copies of the text into the document. The footnotes are copied along with the text. In the first copy, change all occurrences of _1_ to _2_. In the second copy, change all occurrences of _1_ to _3_. Don't forget to change the footnotes. With Word, seeing which footnote goes with which topic can be a little difficult—be careful. When you're finished with this step, the document text (including footnotes) should look like this.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g21og03x.gif)]
    
7.  **Save the document.** Save the document as \vcpp32\ex21a\Simple.rtf. Specify Rich Text Format as the file type.
    
8.  **Write a help project file.** Using Visual C++ or another text editor, create the file \vcpp32\ex21a\Simple.hpj, as follows:
    
    **[OPTIONS]
    CONTENTS=HID_CONTENTS
    TITLE=SIMPLE Application Help
    COMPRESS=true
    WARNING=2
    
    [FILES]
    Simple.rtf**
    
    This file specifies the context ID of the Table Of Contents screen and the name of the RTF file that contains the help text. Be sure to save the file in text (ASCII) format.
    
9.  **Build the help file.** From Windows, run the Microsoft Help Workshop (HCRTF) utility (located by default in Program Files\Microsoft Visual Studio\Common\Tools). Open the file \vcpp32\ex21a\Simple.hpj, and then click the Save And Compile button.
    
    This step runs the Windows Help Compiler with the project file Simple.hpj. The output is the help file Simple.hlp in the same directory.
    
    > NOTE
    > 
    > If you use Word 97 to create or edit RTF files, make sure you use version 4.02 (or later) of the HCRTF utility. Earlier versions of the HCRTF cannot process the rich text flags generated by Word 97.
    
10.  **Run WinHelp with the new help file.** From Windows Explorer, double-click the file \vcpp32\ex21a\Simple.hlp. The Table Of Contents screen should look like this.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/g21og04.gif)
    
    Now move the mouse cursor to Topic 1. Notice that the cursor changes from an arrow to a pointing hand. When you press the left mouse button, the Help Topic 1 screen should appear, as shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/g21og05.gif)
    
    The _HID_TOPIC1_ text in the Table Of Contents screen links to the corresponding context ID (the # footnote) in the topic page. This link is known as a jump.
    
    The link to Help Topic 2 is coded as a pop-up jump. When you click on Topic 2, here's what you see.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/g21og06.gif)
    
11.  **Click the WinHelp Contents pushbutton.** Clicking this button should take you to the Table Of Contents screen, as shown at the beginning of step 9. WinHelp knows the ID of the Table Of Contents window because you specified it in the HPJ file.
    
12.  **Click the WinHelp Index pushbutton.** When you click the Index button, WinHelp opens its Index dialog, which displays the help file's list of keywords. In Simple.hlp, all topics (excluding the table of contents) have the same keyword (the K footnotes): SIMPLE Topics. When you double-click on this keyword, you see all associated topic titles (the $ footnotes), as shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/g21og07x.gif)
    
    What you have here is a two-level help search hierarchy. The user can type the first few letters of the keyword and then select a topic from a list box. The more carefully you select your keywords and topic titles, the more effective your help system will be.
    
    **An Improved Table of Contents**
    ---------------------------------
    
    You've been looking at the "old-style" help table of contents. The latest Win32 version of WinHelp can give you a modern tree-view table of contents. All you need is a text file with a CNT extension. Add a new file, Simple.cnt, in the \vcpp32\ex21a directory, containing this text:
    
    **:Base Simple.hlp
    1 Help topics
    2 Topic 1=HID_TOPIC1
    2 Topic 2=HID_TOPIC2
    2 Topic 3=HID_TOPIC3**
    
    Notice the context IDs that match the help file. The next time you run WinHelp with the Simple.hlp file, you'll see a new contents screen similar to the one shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/g21og08x.gif)
    
    You can also use HCRTF to edit CNT files. The CNT file is independent of the HPJ file and the RTF files. If you update your RTF files, you must make corresponding changes in your CNT file.
________________________________________________________________________
6.9.2. - [The Application Framework and WinHelp](invcpp5/ch21c.htm)
----------------------------------------------------
 The Application Framework and WinHelp 

**The Application Framework and WinHelp**
=========================================

You've seen WinHelp running as a stand-alone program. The application framework and WinHelp cooperate to give you context-sensitive help. Here are some of the main elements:

1.  You select the Context-Sensitive Help option when you run AppWizard.
    
2.  AppWizard generates a Help Topics item on your application's Help menu, and it creates one or more generic RTF files together with an HPJ file and a batch file that runs the Help Compiler.
    
3.  AppWizard inserts a keyboard accelerator for the F1 key, and it maps the F1 key and the Help Topics menu item to member functions in the main frame window object.
    
4.  When your program runs, it calls WinHelp when the user presses F1 or chooses the Help Topics menu item, passing a context ID that determines which help topic is displayed.

You now need to understand how WinHelp is called from another application and how your application generates context IDs for WinHelp.

**Calling WinHelp**
-------------------

The _CWinApp_ member function _WinHelp_ activates WinHelp from within your application. If you look up _WinHelp_ in the online documentation, you'll see a long list of actions that the optional second parameter controls. Ignore the second parameter and pretend that _WinHelp_ has only one unsigned long integer parameter, _dwData_. This parameter corresponds to a help topic. Suppose that the SIMPLE help file is available and that your program contains the statement

AfxGetApp()->WinHelp(HID_TOPIC1);

When the statement is executed in response to the F1 key or some other event the Help Topic 1 screen appears, as it would if the user had clicked on Topic 1 in the Help Table Of Contents screen.

"Wait a minute," you say. "How does WinHelp know which help file to use?" The name of the help file matches the application name. If the executable program name is Simple.exe, the help file is named Simple.hlp.

> NOTE
> 
> You can force _WinHelp_ to use a different help file by setting the _CWinApp_ data member _m_pszHelpFilePath._

"And how does WinHelp match the program constant _HID_TOPIC1_ to the help file's context ID?" you ask. The help project file must contain a MAP section that maps context IDs to numbers. If your application's resource.h file defines _HID_TOPIC1_ as _101_, the Simple.hpj MAP section looks like this:

[MAP]
HID_TOPIC1        101

The program's _#define_ constant name doesn't have to match the help context ID; only the numbers must match. Making the names correspond, however, is good practice.

**Using Search Strings**
------------------------

For a text-based application, you might need help based on a keyword rather than a numeric context ID. In that case, use the WinHelp _HELP_KEY_ or _HELP_PARTIALKEY_ option as follows:

CString string("find this string");
AfxGetApp()->WinHelp((DWORD) (LPCSTR) string, HELP_KEY);

The double cast for _string_ is necessary because the first _WinHelp_ parameter is multipurpose; its meaning depends on the value of the second parameter.

**Calling WinHelp from the Application's Menu**
-----------------------------------------------

AppWizard generates a Help Topics option on the Help menu, and it maps that option to _CWnd::OnHelpFinder_ in the main frame window, which calls WinHelp this way:

AfxGetApp()->WinHelp(0L, HELP_FINDER);

With this call, WinHelp displays the Help Table Of Contents screen, and the user can navigate the help file through jumps and searches.

If you want the old-style table of contents, call WinHelp this way instead:

AfxGetApp()->WinHelp(0L, HELP_INDEX);

And if you want a "help on help" item, make this call:

AfxGetApp()->WinHelp(0L, HELP_HELPONHELP);

**Help Context Aliases**
------------------------

The ALIAS section of the HPJ file allows you to equate one context ID with another. Suppose your HPJ file contained the following statements:

[ALIAS]
HID_TOPIC1 = HID_GETTING_STARTED

[MAP]
HID_TOPIC1        101

Your RTF files could use _HID_TOPIC1_ and _HID_GETTING_STARTED_ interchangeably. Both would be mapped to the help context 101 as generated by your application.

**Determining the Help Context**
--------------------------------

You now have enough information to add a simple context-sensitive help system to an MFC program. You define F1 (the standard MFC library Help key) as a keyboard accelerator, and then you write a command handler that maps the program's help context to a _WinHelp_ parameter. You could invent your own method for mapping the program state to a context ID, but why not take advantage of the system that's already built into the application framework?

The application framework determines the help context based on the ID of the active program element. These identified program elements include menu commands, frame windows, dialog windows, message boxes, and control bars. For example, a menu item might be identified as _ID_EDIT_CLEAR_ALL._ The main frame window usually has the _IDR_MAINFRAME_ identifier. You might expect these identifiers to map directly to help context IDs. _IDR_MAINFRAME_, for example, would map to a help context ID of the same name. But what if a frame ID and a command ID had the same numeric value? Obviously, you need a way to prevent these overlaps.

The application framework solves the overlap problem by defining a new set of help _#define_ constants that are derived from program element IDs. These help constants are the sum of the element ID and a base value, as shown in the following table.

**Program Element**

**Element ID Prefix**

**Help Context ID Prefix**

**Base (Hexadecimal)**

Menu Item or toolbar button

_ID__, _IDM__

_HID__, _HIDM__

10000

Frame or dialog

_IDR__, _IDD__

_HIDR__, _HIDD_

20000

Error message box

_IDP__

_HIDP__

30000

Nonclient area

_H…_

40000

Control bar

_IDW__

_HIDW__

50000

Dispatch error messages

 

 

60000

_HID_EDIT_CLEAR_ALL_ (0x1E121) corresponds to _ID_EDIT_CLEAR_ALL_ (0xE121), and _HIDR_MAINFRAME_ (0x20080) corresponds to _IDR_MAINFRAME_ (0x80).

**F1 Help**
-----------

Two separate context-sensitive help access methods are built into an MFC application and are available if you have selected the AppWizard Context-Sensitive Help option. The first is standard F1 help. The user presses F1; the program makes its best guess about the help context and then calls WinHelp. In this mode, it is possible to determine the currently selected menu item or the currently selected window (frame, view, dialog, or message box).

**Shift-F1 Help**
-----------------

The second context-sensitive help mode is more powerful than the F1 mode. With Shift-F1 help, the program can identify the following help contexts:

*   A menu item selected with the mouse cursor
    
*   A toolbar button
    
*   A frame window
    
*   A view window
    
*   A specific graphics element within a view window
    
*   The status bar
    
*   Various nonclient elements such as the system menu control

> NOTE
> 
> Shift-F1 help doesn't work with modal dialogs or message boxes.

The user activates Shift-F1 help by pressing Shift-F1 or by clicking the Context Help toolbar button, shown here.

![](c:/dl/books/windows/msvc5th/invcpp5/images/g21og09.gif)

In either case, the mouse cursor changes to

![](c:/dl/books/windows/msvc5th/invcpp5/images/g21og10.gif)

On the next mouse click, the help topic appears, with the position of the mouse cursor determining the context.

**Message Box Help—The _AfxMessageBox_ Function**
-------------------------------------------------

The global function _AfxMessageBox_ displays application framework error messages. This function is similar to the _CWnd::MessageBox_ member function except that it has a help context ID as a parameter. The application framework maps this ID to a WinHelp context ID and then calls WinHelp when the user presses F1. If you can use the _AfxMessageBox_ help context parameter, be sure to use prompt IDs that begin with _IDP__. In your RTF file, use help context IDs that begin with _HIDP__.

There are two versions of _AfxMessageBox_. In the first version, the prompt string is specified by a character-array pointer parameter. In the second version, the prompt ID parameter specifies a string resource. If you use the second version, your executable program will be more efficient. Both _AfxMessageBox_ versions take a style parameter that makes the message box display an exclamation point, a question mark, or another graphics symbol.

**Generic Help**
----------------

When context-sensitive help is enabled, AppWizard assembles a series of default help topics that are associated with standard MFC library program elements. Following are some of the standard topics:

*   Menu and toolbar commands (File, Edit, and so forth)
    
*   Nonclient window elements (maximize box, title bar, and so forth)
    
*   Status bar
    
*   Error message boxes

These topics are contained in the files AfxCore.rtf and AfxPrint.rtf, which are copied, along with the associated bitmap files, to the application's \hlp subdirectory. Your job is to customize the generic help files.

> NOTE
> 
> AppWizard generates AfxPrint.rtf only if you specify the Printing And Print Preview option.
________________________________________________________________________
6.9.3. - [A Help Example -- No Programming Required](invcpp5/ch21d.htm)
----------------------------------------------------
 A Help Example -- No Programming Required 

**A Help Example—No Programming Required**
==========================================

If you followed the instructions for EX20D in [Chapter 20](ch20a.htm), you selected the AppWizard Context-Sensitive Help option. We'll now return to that example and explore the application framework's built-in help capability. You'll see how easy it is to link help topics to menu command IDs and frame window resource IDs. You edit RTF files, not CPP files.

Here are the steps for customizing the help for EX20D:

2.  **Verify that the help file was built correctly.** If you have built the EX20D project already, chances are that the help file was created correctly as part of the build process. Check this by running the application and then pressing the F1 key. You should see the generic Application Help screen with the title "Modifying the Document," as shown below.
    
    If you do not see this screen, the MAKEHELP batch file did not run correctly. First check the last two lines of the ex20d.hpj file in the \hlp subdirectory. Are the paths correct for your Visual C++ installation? Next choose Options from the Tools menu, and click on the Directories tab. Make sure that the \VC98\bin subdirectory of your Visual C++ directory is one of the search directories for Executable Files.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g21og11x.gif)]
    
    To generate the help file, highlight the ex20d.hpj file in the Workspace FileView window, and then choose Compile Ex20d.hpj from the Build menu. This runs the MAKEHELP batch file that is in your project directory. (You can also run it directly from an MS-DOS prompt.) You should observe some "file(s) copied" messages but no error messages. Rerun the EX20D program, and press F1 again.
    
    > NOTE
    > 
    > The Visual C++ make processor doesn't always detect all the dependencies in your help system. Sometimes you must run the MAKEHELP batch file yourself to rebuild the HLP file after making changes.
    
3.  **Test the generic help file.** Try the following experiments:
    
    *   Close the Help dialog, press Alt-F and then press F1. This should open the help topic for the File New command. You can also press F1 while holding down the mouse button on the File New menu item to see the same help topic.
        
    *   Close the Help dialog, click the Context Help toolbar button (shown in "[Shift-F1 Help](ch21c.htm#453)"), and then choose Save from the File menu. Do you get the appropriate help topic?
        
    *   Click the Context Help toolbar button again, and then select the frame window's title bar. You should get an explanation of a Windows title bar.
        
    *   Close all child windows and then press F1. You should see a main index page that is also an old-style table of contents.
    
4.  **Change the application title.** The file AfxCore.rtf, in the \vcpp32\ex20d\hlp directory, contains the string _<<YourApp>>_ throughout. Replace it globally with _EX20D_.
    
5.  **Change the Modifying The Document Help screen.** The file AfxCore.rtf in the \vcpp32\ex20d\hlp directory contains text for the generic Application Help screen. Search for _Modifying the Document_, and then change the text to something appropriate for the application. This topic has the help context ID _HIDR_DOC1TYPE_. The generated ex20d.hpj file provides the alias _HIDR_EX20DTYPE_.
    
6.  **Add a topic for the Window New String Window menu item.** The New String Window menu item was added to EX20D and thus didn't have associated help text. Add a topic to AfxCore.rtf, as shown here.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g21og12x.gif)]
    
    Notice the _#_ footnote that links the topic to the context ID _HID_WINDOW_NEW_STRING_ as defined in hlp\ex20d.hm. The program's command ID for the New String Window menu item is, of course, _ID_WINDOW_NEW_STRING_.
    
7.  **Rebuild the help file and test the application.** Run the MAKEHELP batch file again, and then rerun the EX20D program. Try the two new help links.
________________________________________________________________________
6.9.4. - [The MAKEHELP Process](invcpp5/ch21e.htm)
----------------------------------------------------
 The MAKEHELP Process 

**The MAKEHELP Process**
========================

The process of building the application's HLP file is complex. Part of the complexity results from the Help Compiler's nonacceptance of statements such as

HID_MAINFRAME = ID_MAINFRAME + 0x20000

Because of the Help Compiler's nonacceptance, a special preprocessing program named makehm.exe must read the resource.h file to produce a help map file that defines the help context ID values. Below is a diagram of the entire MAKEHELP process.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g21og13x.gif)]

AppWizard generates the application's help project file (HPJ) and the help contents file (CNT). In the project file, the _[FILES]_ section brings in RTF files and the _[MAP]_ section contains _#include_ statements for the generic and the application-specific help map (HM) files. The Help Workshop (HCRTF) processes the project file to produce the help file that WinHelp reads.
________________________________________________________________________
6.9.5. - [Help Command Processing](invcpp5/ch21f.htm)
----------------------------------------------------
 Help Command Processing 

**Help Command Processing**
===========================

You've seen the components of a help file, and you've seen the effects of F1 and Shift-F1. You know how the application element IDs are linked to help context IDs. What you haven't seen is the application framework's internal processing of the help requests. Why should you be concerned? Suppose you want to provide help on a specific view window instead of a frame window. What if you need help topics linked to specific graphics items in a view window? These and other needs can be met by mapping the appropriate help messages in the view class.

Help command processing depends on whether the help request was an F1 request or a Shift-F1 request. The processing of each help request will be described separately.

**F1 Processing**
-----------------

The F1 key is normally handled by a keyboard accelerator entry that AppWizard inserts in the RC file. The accelerator associates the F1 key with an _ID_HELP_ command that is sent to the _OnHelp_ member function in the _CFrameWnd_ class.

> NOTE
> 
> In an active modal dialog or a menu selection in progress, the F1 key is processed by a Windows hook that causes the same _OnHelp_ function to be called. The F1 accelerator key would otherwise be disabled.

The _CFrameWnd::OnHelp_ function sends an MFC-defined WM_COMMANDHELP message to the innermost window, which is usually the view. If your view class does not map this message or if the handler returns _FALSE_, the framework routes the message to the next outer window, which is either the MDI child frame or the main frame. If you have not mapped WM_COMMANDHELP in your derived frame window classes, the message is processed in the MFC _CFrameWnd_ class, which displays help for the symbol that AppWizard generates for your application or document type.

If you map the WM_COMMANDHELP message in a derived class, your handler must call _CWinApp::WinHelp_ with the proper context ID as a parameter.

For any application, AppWizard adds the symbol _IDR_MAINFRAME_ to your project and the HM file defines the help context ID _HIDR_MAINFRAME_, which is aliased to _main_index_ in the HPJ file. The standard AfxCore.rtf file associates the main index with this context ID.

For an MDI application named SAMPLE, for example, AppWizard also adds the symbol _IDR_SAMPLETYPE_ to your project and the HM file defines the help context ID _HIDR_SAMPLETYPE_, which is aliased to _HIDR_DOC1TYPE_ in the HPJ file. The standard AfxCore.rtf file associates the topic "Modifying the Document" with this context ID.

**Shift-F1 Processing**
-----------------------

When the user presses Shift-F1 or clicks the Context Help toolbar button, a command message is sent to the _CFrameWnd_ function _OnContextHelp_. When the user presses the mouse button again after positioning the mouse cursor, an MFC-defined WM_HELPHITTEST message is sent to the innermost window where the mouse click is detected. From that point on, the routing of this message is identical to that for the WM_COMMANDHELP message, described previously in "[F1 Processing](ch21f.htm#459)".

The _lParam_ parameter of _OnHelpHitTest_ contains the mouse coordinates in device units, relative to the upper-left corner of the window's client area. The _y_ value is in the high-order half; the _x_ value is in the low-order half. You can use these coordinates to set the help context ID specifically for an item in the view. Your _OnHelpHitTest_ handler should return the correct context ID; the framework will call _WinHelp_.
________________________________________________________________________
6.9.6. - [A Help Command Processing Example -- EX21B](invcpp5/ch21g.htm)
----------------------------------------------------
 A Help Command Processing Example -- EX21B 

**A Help Command Processing Example—EX21B**
===========================================

EX21B is based on example EX20D from [Chapter 20](ch20a.htm). It's a two-view MDI application with view-specific help added. Each of the two view classes has an _OnCommandHelp_ message handler to process F1 help requests and an _OnHelpHitTest_ message handler to process Shift-F1 help requests.

**Header Requirements**
-----------------------

The compiler recognizes help-specific identifiers only if the following _#include_ statement is present:

**#include <afxpriv.h>**

In EX21B, the statement is in the StdAfx.h file.

**_CStringView_**
-----------------

The modified string view in StringView.h needs message map function prototypes for both F1 help and Shift-F1 help, as shown here:

**afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);**

Here are the message map entries in StringView.cpp:

**ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
ON_MESSAGE(WM_HELPHITTEST, OnHelpHitTest)**

The _OnCommandHelp_ message handler member function in StringView.cpp processes F1 help requests. It responds to the message sent from the MDI main frame and displays the help topic for the string view window, as shown here:

**LRESULT CStringView::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
    if (lParam == 0) { // context not already determined
        lParam = HID_BASE_RESOURCE + IDR_STRINGVIEW;
    }
    AfxGetApp()->WinHelp(lParam);
    return TRUE;
}**

Finally the _OnHelpHitTest_ member function handles Shift-F1 help, as shown here:

**LRESULT CStringView::OnHelpHitTest(WPARAM wParam, LPARAM lParam)
{
    return HID_BASE_RESOURCE + IDR_STRINGVIEW;
}**

In a more complex application, you might want _OnHelpHitTest_ to set the help context ID based on the mouse cursor position.

**_CHexView_**
--------------

The _CHexView_ class processes help requests the same way as the _CStringView_ class does. Following is the necessary header code in HexView.h:

**afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);**

Here are the message map entries in HexView.cpp:

**ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
ON_MESSAGE(WM_HELPHITTEST, OnHelpHitTest)**

And here is the implementation code in HexView.cpp:

**LRESULT CHexView::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
    if (lParam == 0) { // context not already determined
        lParam = HID_BASE_RESOURCE + IDR_HEXVIEW;
    }
    AfxGetApp()->WinHelp(lParam);
    return TRUE;
}

LRESULT CHexView::OnHelpHitTest(WPARAM wParam, LPARAM lParam)
{
    return HID_BASE_RESOURCE + IDR_HEXVIEW;
}**

**Resource Requirements**
-------------------------

Two new symbols were added to the project's Resource.h file. Their values and corresponding help context IDs are shown here.

**Symbol**

**Value**

**Help Context ID**

**Value**

_IDR_STRINGVIEW_

101

_HIDR_STRINGVIEW_

0x20065

_IDR_HEXVIEW_

102

_HIDR_HEXVIEW_

0x20066

**Help File Requirements**
--------------------------

Two topics were added to the AfxCore.rtf file with the help context IDs _HIDR_STRINGVIEW_ and _HIDR_HEXVIEW_, as shown here.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g21og14x.gif)]

The generated ex21b.hm file, in the project's \hlp subdirectory, should look like this:

// MAKEHELP.BAT generated Help Map file.  Used by EX21B.HPJ.

// Commands (ID_\* and IDM_\*)
HID_WINDOW_NEW_STRING                   0x18003
HID_WINDOW_NEW_HEX                      0x18005

// Prompts (IDP_\*)


// Resources (IDR_\*)
HIDR_STRINGVIEW                         0x20065
HIDR_HEXVIEW                            0x20066
HIDR_MAINFRAME                          0x20080
HIDR_EX21BTYPE                          0x20081

// Dialogs (IDD_\*)
HIDD_ABOUTBOX                           0x20064

// Frame Controls (IDW_\*)

**Testing the EX21B Application**
---------------------------------

Open a string child window and a hexadecimal child window. Test the action of F1 help and Shift-F1 help within those windows. If the help file didn't compile correctly, follow the instructions in step 1 of the help example in "[A Help Example—No Programming Required](ch21d.htm#456)."
________________________________________________________________________
6.10. - [Chapter 22 -- Dynamic Link Libraries](invcpp5/ch22a.htm)
----------------------------------------------------
 Chapter 22 -- Dynamic Link Libraries  Chapter 22

Dynamic Link Libraries
======================

If you want to write modular software, you'll be very interested in dynamic link libraries (DLLs). You're probably thinking that you've been writing modular software all along because C++ classes are modular. But classes are build-time modular, and DLLs are runtime modular. Instead of programming giant EXEs that you must rebuild and test each time you make a change, you can build smaller DLL modules and test them individually. You can, for example, put a C++ class in a DLL, which might be as small as 12 KB after compiling and linking. Client programs can load and link your DLL very quickly when they run. Microsoft Windows itself uses DLLs for its major functions.

DLLs are getting easier to write. Win32 has greatly simplified the programming model, and there's more and better support from AppWizard and the Microsoft Foundation Class (MFC) library. This chapter shows you how to write DLLs in C++ and how to write client programs that use DLLs. You'll explore how Win32 maps DLLs into your processes, and you'll learn the differences between MFC library regular DLLs and MFC library extension DLLs. You'll see examples of simple DLLs of each type as well as a more complex DLL example that implements a custom control.
________________________________________________________________________
6.10.1. - [Fundamental DLL Theory](invcpp5/ch22b.htm)
----------------------------------------------------
 Fundamental DLL Theory 

**Fundamental DLL Theory**
==========================

Before you look at the application framework's support for DLLs, you must understand how Win32 integrates DLLs into your process. You might want to review [Chapter 10](ch10a.htm) to refresh your knowledge of processes and virtual memory. Remember that a process is a running instance of a program and that the program starts out as an EXE file on disk.

Basically, a DLL is a file on disk (usually with a DLL extension) consisting of global data, compiled functions, and resources, that becomes part of your process. It is compiled to load at a preferred base address, and if there's no conflict with other DLLs, the file gets mapped to the same virtual address in your process. The DLL has various exported functions, and the client program (the program that loaded the DLL in the first place) imports those functions. Windows matches up the imports and exports when it loads the DLL.

> NOTE
> 
> Win32 DLLs allow exported global variables as well as functions.

In Win32, each process gets its own copy of the DLL's read/write global variables. If you want to share memory among processes, you must either use a memory-mapped file or declare a shared data section as described in Jeffrey Richter's _Advanced Windows_ (Microsoft Press, 1997). Whenever your DLL requests heap memory, that memory is allocated from the client process's heap.

**How Imports Are Matched to Exports**
--------------------------------------

A DLL contains a table of exported functions. These functions are identified to the outside world by their symbolic names and (optionally) by integers called ordinal numbers. The function table also contains the addresses of the functions within the DLL. When the client program first loads the DLL, it doesn't know the addresses of the functions it needs to call, but it does know the symbols or ordinals. The dynamic linking process then builds a table that connects the client's calls to the function addresses in the DLL. If you edit and rebuild the DLL, you don't need to rebuild your client program unless you have changed function names or parameter sequences.

> NOTE
> 
> In a simple world, you'd have one EXE file that imports functions from one or more DLLs. In the real world, many DLLs call functions inside other DLLs. Thus, a particular DLL can have both exports and imports. This is not a problem because the dynamic linkage process can handle cross-dependencies.

In the DLL code, you must explicitly declare your exported functions like this:

__declspec(dllexport) int MyFunction(int n);

(The alternative is to list your exported functions in a module-definition [DEF] file, but that's usually more troublesome.) On the client side, you need to declare the corresponding imports like this:

__declspec(dllimport) int MyFunction(int n);

If you're using C++, the compiler generates a decorated name for _MyFunction_ that other languages can't use. These decorated names are the long names the compiler invents based on class name, function name, and parameter types. They are listed in the project's MAP file. If you want to use the plain name _MyFunction_, you have to write the declarations this way:

extern "C" __declspec(dllexport) int MyFunction(int n);
extern "C" __declspec(dllimport) int MyFunction(int n);

> NOTE
> 
> By default, the compiler uses the ___cdecl_ argument passing convention, which means that the calling program pops the parameters off the stack. Some client languages might require the ___stdcall_ convention, which replaces the Pascal calling convention, and which means that the called function pops the stack. Therefore, you might have to use the ___stdcall_ modifier in your DLL export declaration.

Just having import declarations isn't enough to make a client link to a DLL. The client's project must specify the import library (LIB) to the linker, and the client program must actually contain a call to at least one of the DLL's imported functions. That call statement must be in an executable path in the program.

**Implicit Linkage vs. Explicit Linkage**
-----------------------------------------

The preceding section primarily describes implicit linking, which is what you as a C++ programmer will probably be using for your DLLs. When you build a DLL, the linker produces a companion import LIB file, which contains every DLL's exported symbols and (optionally) ordinals, but no code. The LIB file is a surrogate for the DLL that is added to the client program's project. When you build (statically link) the client, the imported symbols are matched to the exported symbols in the LIB file, and those symbols (or ordinals) are bound into the EXE file. The LIB file also contains the DLL filename (but not its full pathname), which gets stored inside the EXE file. When the client is loaded, Windows finds and loads the DLL and then dynamically links it by symbol or by ordinal.

Explicit linking is more appropriate for interpreted languages such as Microsoft Visual Basic, but you can use it from C++ if you need to. With explicit linking, you don't use an import file; instead, you call the Win32 _LoadLibrary_ function, specifying the DLL's pathname as a parameter. _LoadLibrary_ returns an _HINSTANCE_ parameter that you can use in a call to _GetProcAddress_, which converts a symbol (or an ordinal) to an address inside the DLL. Suppose you have a DLL that exports a function such as this:

extern "C" __declspec(dllexport) double SquareRoot(double d);

Here's an example of a client's explicit linkage to the function:

typedef double (SQRTPROC)(double);
HINSTANCE hInstance;
SQRTPROC\* pFunction;
VERIFY(hInstance = ::LoadLibrary("c:\\winnt\\system32\\mydll.dll"));
VERIFY(pFunction = (SQRTPROC\*)::GetProcAddress(hInstance, "SquareRoot"));
double d = (\*pFunction)(81.0); // Call the DLL function

With implicit linkage, all DLLs are loaded when the client is loaded, but with explicit linkage, you can determine when DLLs are loaded and unloaded. Explicit linkage allows you to determine at runtime which DLLs to load. You could, for example, have one DLL with string resources in English and another with string resources in Spanish. Your application would load the appropriate DLL after the user chose a language.

**Symbolic Linkage vs. Ordinal Linkage**
----------------------------------------

In Win16, the more efficient ordinal linkage was the preferred linkage option. In Win32, the symbolic linkage efficiency was improved. Microsoft now recommends symbolic over ordinal linkage. The DLL version of the MFC library, however, uses ordinal linkage. A typical MFC program might link to hundreds of functions in the MFC DLL. Ordinal linkage permits that program's EXE file to be smaller because it does not have to contain the long symbolic names of its imports. If you build your own DLL with ordinal linkage, you must specify the ordinals in the project's DEF file, which doesn't have too many other uses in the Win32 environment. If your exports are C++ functions, you must use decorated names in the DEF file (or declare your functions with _extern "C"_)_._ Here's a short extract from one of the MFC library DEF files:

?ReadList@CRecentFileList@@UAEXXZ @ 5458 NONAME
?ReadNameDictFromStream@CPropertySection@@QAEHPAUIStream@@@Z @ 5459 NONAME
?ReadObject@CArchive@@QAEPAVCObject@@PBUCRuntimeClass@@@Z @ 5460 NONAME
?ReadString@CArchive@@QAEHAAVCString@@@Z @ 5461 NONAME
?ReadString@CArchive@@QAEPADPADI@Z @ 5462 NONAME
?ReadString@CInternetFile@@UAEHAAVCString@@@Z @ 5463 NONAME
?ReadString@CInternetFile@@UAEPADPADI@Z @ 5464 NONAME

The numbers after the at (@) symbols are the ordinals. (Kind of makes you want to use symbolic linkage instead, doesn't it?)

**The DLL Entry Point—_DllMain_**
---------------------------------

By default, the linker assigns the main entry point __DllMainCRTStartup_ to your DLL. When Windows loads the DLL, it calls this function, which first calls the constructors for global objects and then calls the global function _DllMain_, which you're supposed to write. _DllMain_ is called not only when the DLL is attached to the process but also when it is detached (and at other times as well). Here is a skeleton _DllMain_ function:

HINSTANCE g_hInstance;
extern "C" int APIENTRY
    DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TRACE0("EX22A.DLL Initializing!\n");
        // Do initialization here
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE0("EX22A.DLL Terminating!\n");
        // Do cleanup here
    }
    return 1;   // ok
}

If you don't write a _DllMain_ function for your DLL, a do-nothing version is brought in from the runtime library.

The _DllMain_ function is also called when individual threads are started and terminated, as indicated by the _dwReason_ parameter. Richter's book tells you all you need to know about this complex subject.

**Instance Handles—Loading Resources**
--------------------------------------

Each DLL in a process is identified by a unique 32-bit _HINSTANCE_ value. In addition, the process itself has an _HINSTANCE_ value. All these instance handles are valid only within a particular process, and they represent the starting virtual address of the DLL or EXE. In Win32, the _HINSTANCE_ and _HMODULE_ values are the same and the types can be used interchangeably. The process (EXE) instance handle is almost always 0x400000, and the handle for a DLL loaded at the default base address is 0x10000000. If your program uses several DLLs, each will have a different _HINSTANCE_ value, either because the DLLs had different base addresses specified at build time or because the loader copied and relocated the DLL code.

Instance handles are particularly important for loading resources. The Win32 _FindResource_ function takes an _HINSTANCE_ parameter. EXEs and DLLs can each have their own resources. If you want a resource from the DLL, you specify the DLL's instance handle. If you want a resource from the EXE file, you specify the EXE's instance handle.

How do you get an instance handle? If you want the EXE's handle, you call the Win32 _GetModuleHandle_ function with a _NULL_ parameter. If you want the DLL's handle, you call the Win32 _GetModuleHandle_ function with the DLL name as a parameter. Later you'll see that the MFC library has its own method of loading resources by searching various modules in sequence.

**How the Client Program Finds a DLL**
--------------------------------------

If you link explicitly with _LoadLibrary_, you can specify the DLL's full pathname. If you don't specify the pathname, or if you link implicitly, Windows follows this search sequence to locate your DLL:

2.  The directory containing the EXE file
    
3.  The process's current directory
    
4.  The Windows system directory
    
5.  The Windows directory
    
6.  The directories listed in the Path environment variable

Here's a trap you can easily fall into. You build a DLL as one project, copy the DLL file to the system directory, and then run the DLL from a client program. So far, so good. Next you rebuild the DLL with some changes, but you forget to copy the DLL file to the system directory. The next time you run the client program, it loads the old version of the DLL. Be careful!

**Debugging a DLL**
-------------------

Visual C++ makes debugging a DLL easy. Just run the debugger from the DLL project. The first time you do this, the debugger asks for the pathname of the client EXE file. Every time you "run" the DLL from the debugger after this, the debugger loads the EXE, but the EXE uses the search sequence to find the DLL. This means that you must either set the Path environment variable to point to the DLL or copy the DLL to a directory in the search sequence.
________________________________________________________________________
6.10.2. - [MFC DLLs -- Extension vs. Regular](invcpp5/ch22c.htm)
----------------------------------------------------
 MFC DLLs -- Extension vs. Regular 

**MFC DLLs—Extension vs. Regular**
==================================

We've been looking at Win32 DLLs that have a _DllMain_ function and some exported functions. Now we'll move into the world of the MFC application framework, which adds its own support layer on top of the Win32 basics. AppWizard lets you build two kinds of DLLs with MFC library support: extension DLLs and regular DLLs. You must understand the differences between these two types before you decide which one is best for your needs.

> NOTE
> 
> Of course, Visual C++ lets you build a pure Win32 DLL without the MFC library, just as it lets you build a Windows program without the MFC library. This is an MFC-oriented book, however, so we'll ignore the Win32 option here.

An extension DLL supports a C++ interface. In other words, the DLL can export whole classes and the client can construct objects of those classes or derive classes from them. An extension DLL dynamically links to the code in the DLL version of the MFC library. Therefore, an extension DLL requires that your client program be dynamically linked to the MFC library (the AppWizard default) and that both the client program and the extension DLL be synchronized to the same version of the MFC DLLs (mfc42.dll, mfc42d.dll, and so on). Extension DLLs are quite small; you can build a simple extension DLL with a size of 10 KB, which loads quickly.

If you need a DLL that can be loaded by any Win32 programming environment (including Visual Basic version 6.0), you should use a regular DLL. A big restriction here is that the regular DLL can export only C-style functions. It can't export C++ classes, member functions, or overloaded functions because every C++ compiler has its own method of decorating names. You can, however, use C++ classes (and MFC library classes, in particular) inside your regular DLL.

When you build an MFC regular DLL, you can choose to statically link or dynamically link to the MFC library. If you choose static linking, your DLL will include a copy of all the MFC library code it needs and will thus be self-contained. A typical Release-build statically linked regular DLL is about 144 KB in size. If you choose dynamic linking, the size drops to about 17 KB but you'll have to ensure that the proper MFC DLLs are present on the target machine. That's no problem if the client program is already dynamically linked to the same version of the MFC library.

When you tell AppWizard what kind of DLL or EXE you want, compiler _#define_ constants are set as shown in the following table.

**Dynamically Linked to Shared MFC Library**

**Statically Linked\* to MFC Library**

Regular DLL

__AFXDLL_, __USRDLL_

__USRDLL_

Extension DLL

__AFXEXT_, __AFXDLL_

unsupported option

Client EXE

__AFXDLL_

no constants defined

\* Visual C++ Learning Edition does not support the static linking option.

If you look inside the MFC source code and header files, you'll see a ton of _#ifdef_ statements for these constants. This means that the library code is compiled quite differently depending on the kind of project you're producing.

**The Shared MFC DLLs and the Windows DLLs**
--------------------------------------------

If you build a Windows Debug target with the shared MFC DLL option, your program is dynamically linked to one or more of these (ANSI) MFC DLLs:

mfc42d.dll

Core MFC classes

mfco42d.dll

ActiveX (OLE) classes

mfcd42d.dll

Database classes (ODBC and DAO)

mfcn42d.dll

Winsock, WinInet classes

When you build a Release target, your program is dynamically linked to mfc42.dll only. Linkage to these MFC DLLs is implicit via import libraries. You might assume implicit linkage to the ActiveX and ODBC DLLs in Windows, in which case you would expect all these DLLs to be linked to your Release-build client when it loads, regardless of whether it uses ActiveX or ODBC features. However, this is not what happens. Through some creative thunking, MFC loads the ActiveX and ODBC DLLs explicitly (by calling _LoadLibrary_) when one of their functions is first called. Your client application thus loads only the DLLs it needs.

**MFC Extension DLLs—Exporting Classes**
----------------------------------------

If your extension DLL contains only exported C++ classes, you'll have an easy time building and using it. The steps for building the EX22A example show you how to tell AppWizard that you're building an extension DLL skeleton. That skeleton has only the _DllMain_ function. You simply add your own C++ classes to the project. There's only one special thing you must do. You must add the macro _AFX_EXT_CLASS_ to the class declaration, as shown here:

class AFX_EXT_CLASS CStudent : public CObject

This modification goes into the H file that's part of the DLL project, and it also goes into the H file that client programs use. In other words, the H files are exactly the same for both client and DLL. The macro generates different code depending on the situation—it exports the class in the DLL and imports the class in the client.

**The MFC Extension DLL Resource Search Sequence**
--------------------------------------------------

If you build a dynamically linked MFC client application, many of the MFC library's standard resources (error message strings, print preview dialog templates, and so on) are stored in the MFC DLLs (mfc42.dll, mfco42.dll, and so on), but your application has its own resources too. When you call an MFC function such as _CString::LoadString_ or _CBitmap::LoadBitmap_, the framework steps in and searches first the EXE file's resources and then the MFC DLL's resources.

If your program includes an extension DLL and your EXE needs a resource, the search sequence is first the EXE file, then the extension DLL, and then the MFC DLLs. If you have a string resource ID, for example, that is unique among all resources, the MFC library will find it. If you have duplicate string IDs in your EXE file and your extension DLL file, the MFC library loads the string in the EXE file.

If the extension DLL loads a resource, the sequence is first the extension DLL, then the MFC DLLs, and then the EXE.

You can change the search sequence if you need to. Suppose you want your EXE code to search the extension DLL's resources first. Use code such as this:

HINSTANCE hInstResourceClient = AfxGetResourceHandle();
// Use DLL's instance handle
AfxSetResourceHandle(::GetModuleHandle("mydllname.dll"));
CString strRes;
strRes.LoadString(IDS_MYSTRING);
// Restore client's instance handle
AfxSetResourceHandle(hInstResourceClient);

You can't use _AfxGetInstanceHandle_ instead of _::GetModuleHandle_. In an extension DLL, _AfxGetInstanceHandle_ returns the EXE's instance handle, not the DLL's handle.

**The EX22A Example—An MFC Extension DLL**
------------------------------------------

This example makes an extension DLL out of the _CPersistentFrame_ class you saw in [Chapter 15](ch15a.htm). First you'll build the ex22a.dll file, and then you'll use it in a test client program, EX22B.

Here are the steps for building the EX22A example:

2.  **Run AppWizard to produce \vcpp32\ex22a\ex22a.** Choose New from Visual C++'s File menu, and then click on the Projects tab as usual. Instead of selecting MFC AppWizard (exe), choose MFC AppWizard (dll), as shown here.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g22og01x.gif)]

In this example, only one AppWizard screen appears. Choose MFC Extension DLL, as shown here.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g22og02x.gif)]

3.  **Examine the ex22a.cpp file.** AppWizard generates the following code, which includes the _DllMain_ function:
    
    // ex22a.cpp : Defines the initialization routines for the DLL.
    //
    
    #include "stdafx.h"
    #include <afxdllx.h>
    
    #ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
    static char THIS_FILE[] = _ _FILE_ _;
    #endif
    
    static AFX_EXTENSION_MODULE Ex22aDLL = { NULL, NULL };
    
    extern "C" int APIENTRY
    DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
    {
        // Remove this if you use lpReserved
        UNREFERENCED_PARAMETER(lpReserved);
    
        if (dwReason == DLL_PROCESS_ATTACH)
        {
            TRACE0("EX22A.DLL Initializing!\n");
    
            // Extension DLL one-time initialization
            if (!AfxInitExtensionModule(Ex22aDLL, hInstance))
                return 0;
    
            // Insert this DLL into the resource chain
    
        _(generated comment lines deleted)_
    
            new CDynLinkLibrary(Ex22aDLL);
        }
        else if (dwReason == DLL_PROCESS_DETACH)
        {
            TRACE0("EX22A.DLL Terminating!\n");
            // Terminate the library before destructors are called
            AfxTermExtensionModule(Ex22aDLL);
        }
        return 1;   // ok
    }
    
4.  **Insert the _CPersistentFrame_ class into the project.** Choose Add To Project from the Project menu, and then choose Components And Controls from the submenu. Locate the file Persistent Frame.ogx that you created in [Chapter 15](ch15a.htm) (or locate the copy on the companion CD-ROM). Click the Insert button to insert the class into the current project.

> NOTE
> 
> If you don't want to use the OGX component, you can copy the files Persist.h and Persist.cpp into your project directory and add them to the project by choosing Add To Project from the Visual C++ Project menu.

5.  **Edit the persist.h file.** Modify the line
    
    class CPersistentFrame : public CFrameWnd
    
    to read
    
    class **AFX_EXT_CLASS** CPersistentFrame : public CFrameWnd
    
6.  **Build the project and copy the DLL file.** Copy the file ex22a.dll from the \vcpp32\ex22a\Debug directory to your system directory (\Windows\System or \Winnt\System32).

**The EX22B Example—A DLL Test Client Program**
-----------------------------------------------

This example starts off as a client for ex22a.dll. It imports the _CPersistentFrame_ class from the DLL and uses it as a base class for the SDI frame window. Later you'll add code to load and test the other sample DLLs in this chapter.

Here are the steps for building the EX22B example:

2.  **Run AppWizard to produce \vcpp32\ex22b\ex22b.** This is an ordinary MFC EXE program. Select Single Document. Otherwise, accept the default settings. Be absolutely sure that in Step 5 you accept the As A Shared DLL option.
    
3.  **Copy the file persist.h from the \vcpp32\ex22a directory.** Note that you're copying the header file, not the CPP file.
    
4.  **Change the _CMainFrame_ base class to _CPersistentFrame_ as you did in EX15A.** Replace all occurrences of _CFrameWnd_ with _CPersistentFrame_ in both MainFrm.h and MainFrm.cpp. Also insert the following line into MainFrm.h:
    
    **#include "persist.h"**
    
5.  **Add the ex22a import library to the linker's input library list.** Choose Settings from Visual C++'s Project menu. Select All Configurations in the Settings For drop-down list. Then fill in the Object/Library Modules control on the Link page as shown below.
    
    You must specify the full pathname for the ex22a.lib file unless you have a copy of that file in your project directory.
    

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g22og03x.gif)]

6.  **Build and test the EX22B program.** If you run the program from the debugger and Windows can't find the EX22A DLL, Windows displays a message box when EX22B starts. If all goes well, you should have a persistent frame application that works exactly like the one in EX15A. The only difference is that the _CPersistentFrame_ code is in an extension DLL.

**MFC Regular DLLs—The _CWinApp_ Derived Class**
------------------------------------------------

When AppWizard generates a regular DLL, the _DllMain_ function is inside the framework and you end up with a class derived from _CWinApp_ (and a global object of that class), just as you would with an EXE program. You can get control by overriding _CWinApp::InitInstance_ and _CWinApp::ExitInstance_. Most of the time, you don't bother overriding those functions, though. You simply write the C functions and then export them with the ___declspec(dllexport)_ modifier (or with entries in the project's DEF file).

**Using the _AFX_MANAGE_STATE_ Macro**
----------------------------------------

When mfc42.dll is loaded as part of a process, it stores data in some truly global variables. If you call MFC functions from an MFC program or extension DLL, mfc42.dll knows how to set these global variables on behalf of the calling process. If you call into mfc42.dll from a regular MFC DLL, however, the global variables are not synchronized and the effects will be unpredictable. To solve this problem, insert the line

AFX_MANAGE_STATE(AfxGetStaticModuleState());

at the start of all exported functions in your regular DLL. If the MFC code is statically linked, the macro will have no effect.

**The MFC Regular DLL Resource Search Sequence**
------------------------------------------------

When an EXE links to a regular DLL, resource loading functions inside the EXE will load the EXE's own resources. Resource loading functions inside the regular DLL will load the DLL's own resources.

If you want your EXE code to load resources from the DLL, you can use _AfxSetResourceHandle_ to temporarily change the resource handle. The code will be nearly the same as that shown in "[The MFC Extension DLL Resource Search Sequence](ch22c.htm#480)." If you're writing an application that needs to be localized, you can put language-specific strings, dialogs, menus, and so forth in an MFC regular DLL. You might, for example, include the modules English.dll, German.dll, and French.dll. Your client program would explicitly load the correct DLL and use code such as that in "[The MFC Extension DLL Resource Search Sequence](ch22c.htm#480)" to load the resources, which would have the same IDs in all the DLLs.

**The EX22C Example—An MFC Regular DLL**
----------------------------------------

This example creates a regular DLL that exports a single square root function. First you'll build the ex22c.dll file, and then you'll modify the test client program, EX22B, to test the new DLL.

Here are the steps for building the EX22C example:

2.  **Run AppWizard to produce \vcpp32\ex22c\ex22c.** Proceed as you did for EX22A, but accept Regular DLL Using Shared MFC DLL (instead of choosing MFC Extension DLL) from the one and only AppWizard page.
    
3.  **Examine the ex22c.cpp file.** AppWizard generates the following code, which includes a derived _CWinApp_ class:
    
    // ex22c.cpp : Defines the initialization routines for the DLL.
    //
    
    #include "stdafx.h"
    #include "ex22c.h"
    
    #ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
    static char THIS_FILE[] = _ _FILE_ _;
    #endif
    
    _(generated comment lines omitted)_
    
    //////////////////////////////////////////////////////////////////////
    // CEx22cApp
    
    BEGIN_MESSAGE_MAP(CEx22cApp, CWinApp)
        //{{AFX_MSG_MAP(CEx22cApp)
            // NOTE - the ClassWizard will add and remove mapping macros here.
            //    DO NOT EDIT what you see in these blocks of generated code!
         //}}AFX_MSG_MAP
    END_MESSAGE_MAP()
    
    //////////////////////////////////////////////////////////////////////
    // CEx22cApp construction
    
    CEx22cApp::CEx22cApp()
    {
        // TODO: add construction code here,
        // Place all significant initialization in InitInstance
    }
    
    //////////////////////////////////////////////////////////////////////
    // The one and only CEx22cApp object
    
    CEx22cApp theApp;
    
4.  **Add the code for the exported _Ex22cSquareRoot_ function.** It's okay to add this code in the ex22c.cpp file, although you can use a new file if you want to:
    
    **extern "C" __declspec(dllexport) double Ex22cSquareRoot(double d)
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        TRACE("Entering Ex22cSquareRoot\n");
        if (d >= 0.0) {
            return sqrt(d);
        }
        AfxMessageBox("Can't take square root of a negative number.");
        return 0.0;
    }**
    
    You can see that there's no problem with the DLL displaying a message box or another modal dialog. You'll need to include math.h in the file containing this code.
    
5.  **Build the project and copy the DLL file.** Copy the file ex22c.dll from the \vcpp32\ex22c\Debug directory to your system directory.

**Updating the EX22B Example—Adding Code to Test ex22c.dll**
------------------------------------------------------------

When you first built the EX22B program, it linked dynamically to the EX22A MFC extension DLL. Now you'll update the project to implicitly link to the EX22C MFC regular DLL and to call the DLL's square root function.

Following are the steps for updating the EX22B example.

2.  **Add a new dialog resource and class to \vcpp32\ex22b\ex22b.** Use the dialog editor to create the _IDD_EX22C_ template, as shown here.

![](c:/dl/books/windows/msvc5th/invcpp5/images/g22og04.gif)

Then use ClassWizard to generate a class _CTest22cDialog_, derived from _CDialog_. The controls, data members, and message map function are shown in the following table.

**Control ID**

**Type**

**Data Member**

Message Map Function

_IDC_INPUT_

edit

_m_dInput_ (double)

_IDC_OUTPUT_

edit

_m_dOutput_ (double)

_IDC_COMPUTE_

button

_OnCompute_

3.  **Code the _OnCompute_ function to call the DLL's exported function.** Edit the ClassWizard-generated function in Test22cDialog.cpp as shown here:
    
    void CTest22cDialog::OnCompute()
    {
        **UpdateData(TRUE);
        m_dOutput = Ex22cSquareRoot(m_dInput);
        UpdateData(FALSE);**
    }
    
    You'll have to declare the _Ex22cSquareRoot_ function as an imported function. Add the following line to the Test22cDialog.h file:
    
    **extern "C" __declspec(dllimport) double Ex22cSquareRoot(double d);**
    
4.  **Integrate the _CTest22cDialog_ class into the EX22B application.** You'll need to add a top-level menu, Test, and an Ex22c DLL option with the ID _ID_TEST_EX22CDLL_. Use ClassWizard to map this option to a member function in the _CEx22bView_ class, and then code the handler in Ex22bView.cpp as follows:
    
    void CEx22bView::OnTestEx22cdll()
    {
        **CTest22cDialog dlg;
        dlg.DoModal();**
    }
    
    Of course, you'll have to add this line to the Ex22bView.cpp file:
    
    **#include "Test22cDialog.h"**
    
5.  **Add the EX22C import library to the linker's input library list.** Choose Settings from Visual C++'s Project menu, and then add _\vcpp32\ex22c\Debug\ex22c.lib_ to the Object/Library Modules control on the Link page. (Use a space to separate the new entry from the existing entry.) Now the program should implicitly link to both the EX22A DLL and the EX22C DLL. As you can see, the client doesn't care whether the DLL is a regular DLL or an extension DLL. You just specify the LIB name to the linker.
    
6.  **Build and test the updated EX22B application.** Choose Ex22c DLL from the Test menu. Type a number in the Input edit control, and then click the Compute Sqrt button. The result should appear in the Output control.
________________________________________________________________________
6.10.3. - [A Custom Control DLL](invcpp5/ch22d.htm)
----------------------------------------------------
 A Custom Control DLL 

**A Custom Control DLL**
========================

Programmers have been using DLLs for custom controls since the early days of Windows because custom controls are neatly self-contained. The original custom controls were written in pure C and configured as stand-alone DLLs. Today you can use the features of the MFC library in your custom controls, and you can use the wizards to make coding easier. A regular DLL is the best choice for a custom control because the control doesn't need a C++ interface and because it can be used by any development system that accepts custom controls (such as the Borland C++ compiler). You'll probably want to use the MFC dynamic linking option because the resulting DLL will be small and quick to load.

**What Is a Custom Control?**
-----------------------------

You've seen ordinary controls and Microsoft Windows common controls in [Chapter 6](ch06a.htm), and you've seen ActiveX controls in [Chapter 8](ch08a.htm). The custom control acts like an ordinary control, such as the edit control, in that it sends WM_COMMAND notification messages to its parent window and receives user-defined messages. The dialog editor lets you position custom controls in dialog templates. That's what the "head" control palette item, shown here, is for.

![](c:/dl/books/windows/msvc5th/invcpp5/images/g22og05.gif)

You have a lot of freedom in designing your custom control. You can paint anything you want in its window (which is managed by the client application) and you can define any notification and inbound messages you need. You can use ClassWizard to map normal Windows messages in the control (WM_LBUTTONDOWN, for example), but you must manually map the user-defined messages and manually map the notification messages in the parent window class.

**A Custom Control's Window Class**
-----------------------------------

A dialog resource template specifies its custom controls by their symbolic window class names. Don't confuse the Win32 window class with the C++ class; the only similarity is the name. A window class is defined by a structure that contains the following:

*   The name of the class
    
*   A pointer to the _WndProc_ function that receives messages sent to windows of the class
    
*   Miscellaneous attributes, such as the background brush

The Win32 _RegisterClass_ function copies the structure into process memory so that any function in the process can use the class to create a window. When the dialog window is initialized, Windows creates the custom control child windows from the window class names stored in the template.

Suppose now that the control's _WndProc_ function is inside a DLL. When the DLL is initialized (by a call to _DllMain_), it can call _RegisterClass_ for the control. Because the DLL is part of the process, the client program can create child windows of the custom control class. To summarize, the client knows the name string of a control window class and it uses that class name to construct the child window. All the code for the control, including the _WndProc_ function, is inside the DLL. All that's necessary is that the client load the DLL prior to creating the child window.

**The MFC Library and the _WndProc_ Function**
----------------------------------------------

Okay, so Windows calls the control's _WndProc_ function for each message sent to that window. But you really don't want to write an old-fashioned _switch-case_ statement—you want to map those messages to C++ member functions, as you've been doing all along. Now, in the DLL, you must rig up a C++ class that corresponds to the control's window class. Once you've done that, you can happily use ClassWizard to map messages.

The obvious part is the writing of the C++ class for the control. You simply use ClassWizard to create a new class derived from _CWnd_. The tricky part is wiring the C++ class to the _WndProc_ function and to the application framework's message pump. You'll see a real _WndProc_ in the EX22D example, but here's the pseudocode for a typical control _WndProc_ function:

LRESULT MyControlWndProc(HWND hWnd, UINT message
                         WPARAM wParam, LPARAM lParam)
{
    if (this is the first message for this window) {
        CWnd\* pWnd = new CMyControlWindowClass();
        attach pWnd to hWnd
    }
    return AfxCallWndProc(pWnd, hWnd, message, WParam, lParam);
}

The MFC _AfxCallWndProc_ function passes messages to the framework, which dispatches them to the member functions mapped in _CMyControlWindowClass_.

**Custom Control Notification Messages**
----------------------------------------

The control communicates with its parent window by sending it special WM_COMMAND notification messages with parameters, as shown here.

**Parameter**

**Usage**

_(HIWORD) wParam_

Notification code

_(LOWORD) wParam_

Child window ID

_lParam_

Child window handle

The meaning of the notification code is arbitrary and depends on the control. The parent window must interpret the code based on its knowledge of the control. For example, the code 77 might mean that the user typed a character while positioned on the control.

The control might send a notification message such as this:

GetParent()->SendMessage(WM_COMMAND,

    GetDlgCtrlID() | ID_NOTIFYCODE << 16, (LONG) GetSafeHwnd());

On the client side, you map the message with the MFC _ON_CONTROL_ macro like this:

ON_CONTROL(ID_NOTIFYCODE, IDC_MYCONTROL, OnClickedMyControl)

Then you declare the handler function like this:

afx_msg void OnClickedMyControl();

**User-Defined Messages Sent to the Control**
---------------------------------------------

You have already seen user-defined messages in [Chapter 7](ch07a.htm). This is the means by which the client program communicates with the control. Because a standard message returns a 32-bit value if it is sent rather than posted, the client can obtain information from the control.

**The EX22D Example—A Custom Control**
--------------------------------------

The EX22D program is an MFC regular DLL that implements a traffic light control indicating off, red, yellow, and green states. When clicked with the left mouse button, the DLL sends a clicked notification message to its parent and responds to two user-defined messages, RYG_SETSTATE and RYG_GETSTATE. The state is an integer that represents the color. Credit goes to Richard Wilton, who included the original C-language version of this control in his book _Windows 3 Developer's Workshop_ (Microsoft Press, 1991).

The EX22D project was originally generated using AppWizard, with linkage to the shared MFC DLL, just like EX22C. Figure 22-1 shows the code for the primary source file, with the added code in the _InitInstance_ function in boldface. The dummy exported _Ex22dEntry_ function exists solely to allow the DLL to be implicitly linked. The client program must include a call to this function. That call must be in an executable path in the program or the compiler will eliminate the call. As an alternative, the client program could call the Win32 _LoadLibrary_ function in its _InitInstance_ function to explicitly link the DLL.

**EX22D.CPP**

// ex22d.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include "ex22d.h"
**#include "RygWnd.h"**

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE
__;
#endif

**extern "C" __declspec(dllexport) void Ex22dEntry() {} // dummy function**

_(generated comment lines omitted)_

///////////////////////////////////////////////////////////////////////
// CEx22dApp

BEGIN_MESSAGE_MAP(CEx22dApp, CWinApp)
    //{{AFX_MSG_MAP(CEx22dApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////
// CEx22dApp construction

CEx22dApp::CEx22dApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

///////////////////////////////////////////////////////////////////////
// The one and only CEx22dApp object

CEx22dApp theApp;

BOOL CEx22dApp::InitInstance()
{
    **CRygWnd::RegisterWndClass(AfxGetInstanceHandle());**
    return CWinApp::InitInstance();
}

**Figure 22-1.** _The EX22D primary source listing._

Figure 22-2 shows the code for the _CRygWnd_ class, including the global _RygWndProc_ function. (Click the Add Class button in ClassWizard to create this class.) The code that paints the traffic light isn't very interesting, so we'll concentrate on the functions that are common to most custom controls. The static _RegisterWndClass_ member function actually registers the _RYG_ window class and must be called as soon as the DLL is loaded. The _OnLButtonDown_ handler is called when the user presses the left mouse button inside the control window. It sends the clicked notification message to the parent window. The overridden _PostNcDestroy_ function is important because it deletes the _CRygWnd_ object when the client program destroys the control window. The _OnGetState_ and _OnSetState_ functions are called in response to user-defined messages sent by the client. Remember to copy the DLL to your system directory.

**RYGWND.H**

#if !defined(AFX_RYGWND_H__1AA889D5_9788_11D0_BED2_00C04FC2A0C2
__INCLUDED_)
#define AFX_RYGWND_H__1AA889D5_9788_11D0_BED2_00C04FC2A0C2
__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// RygWnd.h : header file
//

///////////////////////////////////////////////////////////////////////
// CRygWnd window

**#define RYG_SETSTATE WM_USER + 0
#define RYG_GETSTATE WM_USER + 1

LRESULT CALLBACK AFX_EXPORT
    RygWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);**

class CRygWnd : public CWnd
{
**private:
    int m_nState; // 0=off, 1=red, 2=yellow, 3=green
    static CRect  s_rect;
    static CPoint s_point;
    static CRect  s_rColor[3];
    static CBrush s_bColor[4];**

// Construction
public:
    CRygWnd();
**public:
    static BOOL RegisterWndClass(HINSTANCE hInstance);**

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRygWnd)
    protected:
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CRygWnd();

    // Generated message map functions
**private:
    void SetMapping(CDC\* pDC);
    void UpdateColor(CDC\* pDC, int n);**
protected:
    //{{AFX_MSG(CRygWnd)
    afx_msg void OnPaint();
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    //}}AFX_MSG
    **afx_msg LRESULT OnSetState(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnGetState(WPARAM wParam, LPARAM lParam);**
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations
//  immediately before the previous line.
#endif // !defined(AFX_RYGWND_H__1AA889D5_9788_11D0_BED2_00C04FC2A0C2__INCLUDED_)

**RYGWND.CPP**

// RygWnd.cpp : implementation file
//

#include "stdafx.h"
#include "ex22d.h"
#include "RygWnd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE
__;
#endif

**LRESULT CALLBACK AFX_EXPORT
    RygWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWnd\* pWnd;

    pWnd = CWnd::FromHandlePermanent(hWnd);
    if (pWnd == NULL) {
        // Assume that client created a CRygWnd window
        pWnd = new CRygWnd();
        pWnd->Attach(hWnd);
    }
    ASSERT(pWnd->m_hWnd == hWnd);
    ASSERT(pWnd == CWnd::FromHandlePermanent(hWnd));
    LRESULT lResult = AfxCallWndProc(pWnd, hWnd, message,
                                     wParam, lParam);
    return lResult;
}**

///////////////////////////////////////////////////////////////////////
// CRygWnd

**// static data members
CRect  CRygWnd::s_rect(-500, 1000, 500, -1000); // outer rectangle
CPoint CRygWnd::s_point(300, 300); // rounded corners
CRect  CRygWnd::s_rColor[] = {CRect(-250, 800, 250, 300),
                              CRect(-250, 250, 250, -250),
                              CRect(-250, -300, 250, -800)};
CBrush CRygWnd::s_bColor[] = {RGB(192, 192, 192),
                              RGB(0xFF, 0x00, 0x00),
                              RGB(0xFF, 0xFF, 0x00),
                              RGB(0x00, 0xFF, 0x00)};

BOOL CRygWnd::RegisterWndClass(HINSTANCE hInstance) // static member
                                                    //  function
{
    WNDCLASS wc;
    wc.lpszClassName = "RYG"; // matches class name in client
    wc.hInstance = hInstance;
    wc.lpfnWndProc = RygWndProc;
    wc.hCursor = ::LoadCursor(NULL, IDC_ARROW);
    wc.hIcon = 0;
    wc.lpszMenuName = NULL;
    wc.hbrBackground = (HBRUSH) ::GetStockObject(LTGRAY_BRUSH);
    wc.style = CS_GLOBALCLASS;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    return (::RegisterClass(&wc) != 0);
}

///////////////////////////////////////////////////////////////////////**

CRygWnd::CRygWnd()
{
    **m_nState = 0;
    TRACE("CRygWnd constructor\n");**
}

CRygWnd::~CRygWnd()
{
    **TRACE("CRygWnd destructor\n");**
}


BEGIN_MESSAGE_MAP(CRygWnd, CWnd)
    //{{AFX_MSG_MAP(CRygWnd)
    ON_WM_PAINT()
    ON_WM_LBUTTONDOWN()
    //}}AFX_MSG_MAP
    **ON_MESSAGE(RYG_SETSTATE, OnSetState)
    ON_MESSAGE(RYG_GETSTATE, OnGetState)**
END_MESSAGE_MAP()
**void CRygWnd::SetMapping(CDC\* pDC)
{
    CRect clientRect;
    GetClientRect(clientRect);
    pDC->SetMapMode(MM_ISOTROPIC);
    pDC->SetWindowExt(1000, 2000);
    pDC->SetViewportExt(clientRect.right, -clientRect.bottom);
    pDC->SetViewportOrg(clientRect.right / 2, clientRect.bottom / 2);
}

void CRygWnd::UpdateColor(CDC\* pDC, int n)
{
    if (m_nState == n + 1) {
        pDC->SelectObject(&s_bColor[n+1]);
    }
    else {
        pDC->SelectObject(&s_bColor[0]);
    }
    pDC->Ellipse(s_rColor[n]);
}**

///////////////////////////////////////////////////////////////////////
// CRygWnd message handlers

void CRygWnd::OnPaint() 
{
    **int i;**
    CPaintDC dc(this); // device context for painting
    **SetMapping(&dc);
    dc.SelectStockObject(DKGRAY_BRUSH);
    dc.RoundRect(s_rect, s_point);
    for (i = 0; i < 3; i++) {
        UpdateColor(&dc, i);
    }**
}

void CRygWnd::OnLButtonDown(UINT nFlags, CPoint point) 
{
    **// Notification code is HIWORD of wParam, 0 in this case
    GetParent()->SendMessage(WM_COMMAND, GetDlgCtrlID(),
        (LONG) GetSafeHwnd()); // 0**
}
void CRygWnd::PostNcDestroy() 
{
    **TRACE("CRygWnd::PostNcDestroy\n");
    delete this; // CWnd::PostNcDestroy does nothing**
}

**LRESULT CRygWnd::OnSetState(WPARAM wParam, LPARAM lParam)
{
    TRACE("CRygWnd::SetState, wParam = %d\n", wParam);
    m_nState = (int) wParam;
    Invalidate(FALSE);
    return 0L;
}

LRESULT CRygWnd::OnGetState(WPARAM wParam, LPARAM lParam)
{
    TRACE("CRygWnd::GetState\n");
    return m_nState;
}**

**Figure 22-2.** _The_ CRygWnd _class listing._

**Revising the Updated EX22B Example—Adding Code to Test ex22d.dll**
--------------------------------------------------------------------

The EX22B program already links to the EX22A and EX22C DLLs. Now you'll revise the project to implicitly link to the EX22D custom control.

Here are the steps for updating the EX22B example:

2.  **Add a new dialog resource and class to \vcpp32\ex22b\ex22b.**Use the dialog editor to create the _IDD_EX22D_ template with a custom control with child window ID _IDC_RYG_, as shown here.

![](c:/dl/books/windows/msvc5th/invcpp5/images/g22og06.gif)

Specify _RYG_ as the window class name of the custom control, as shown.

![](c:/dl/books/windows/msvc5th/invcpp5/images/g22og07.gif)

Then use ClassWizard to generate a class _CTest22dDialog_, derived from _CDialog_.

4.  **Edit the Test22dDialog.h file.** Add the following private data member:
    
    enum { OFF, RED, YELLOW, GREEN } m_nState;
    
    Also add the following import and user-defined message IDs:
    
    extern "C" __declspec(dllimport) void Ex22dEntry(); // dummy function
    #define RYG_SETSTATE WM_USER + 0
    #define RYG_GETSTATE WM_USER + 1
    
5.  **Edit the constructor in Test22dDialog.cpp to initialize the state data member.** Add the following boldface code:
    
    CTest22dDialog::CTest22dDialog(CWnd\* pParent /\*=NULL\*/)
        : CDialog(CTest22dDialog::IDD, pParent)
    {
        //{{AFX_DATA_INIT(CTest22dDialog)
          // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
        **m_nState = OFF;
        Ex22dEntry(); // Make sure DLL gets loaded**
    }
    
6.  **Map the control's clicked notification message.** You can't use ClassWizard here, so you must add the message map entry and handler function in the Test22dDialog.cpp file, as shown here:
    
    ON_CONTROL(0, IDC_RYG, OnClickedRyg) // Notification code is 0
    
    void CTest22dDialog::OnClickedRyg()
    {
        switch(m_nState) {
        case OFF:
            m_nState = RED;
            break;
        case RED:
            m_nState = YELLOW;
            break;
        case YELLOW:
            m_nState = GREEN;
            break;
        case GREEN:
            m_nState = OFF;
            break;
        }
        GetDlgItem(IDC_RYG)->SendMessage(RYG_SETSTATE, m_nState);
        return;
    }
    
    When the dialog gets the clicked notification message, it sends the RYG_SETSTATE message back to the control in order to change the color. Don't forget to add this prototype in the Test22dDialog.h file:
    
    afx_msg void OnClickedRyg();
    
7.  **Integrate the _CTest22dDialog_ class into the EX22B application.** You'll need to add a second item on the Test menu, an Ex22d DLL option with ID _ID_TEST_EX22DDLL_. Use ClassWizard to map this option to a member function in the _CEx22bView_ class, and then code the handler in Ex22bView.cpp as follows:
    
    void CEx22bView::OnTestEx22ddll()
    {
        CTest22dDialog dlg;
        dlg.DoModal();
    }
    
    Of course, you'll have to add the following line to Ex22bView.cpp:
    
    #include "Test22dDialog.h"
    
8.  **Add the EX22D import library to the linker's input library list.** Choose Settings from Visual C++'s Project menu, and then add _\vcpp32\ex22d\Debug\ex22d.lib_ to the Object/Library Modules control on the Link page. With this addition, the program should implicitly link to all three DLLs.
    
9.  **Build and test the updated EX22B application.** Choose Ex22d DLL from the Test menu. Try clicking the traffic light with the left mouse button. The traffic-light color should change. The result of clicking the traffic light several times is shown here.

![](c:/dl/books/windows/msvc5th/invcpp5/images/g22og08.gif)
________________________________________________________________________
6.11. - [Chapter 23 -- MFC Programs Without Document or View Classes](invcpp5/ch23a.htm)
----------------------------------------------------
 Chapter 23 -- MFC Programs Without Document or View Classes  Chapter 23

MFC Programs Without Document or View Classes
=============================================

The document-view architecture is useful for many applications, but sometimes a simpler program structure is sufficient. This chapter illustrates three applications: a dialog-based program, a Single Document Interface (SDI) program, and a Multiple Document Interface (MDI) program. None of these programs uses document, view, or document-template classes, but they all use command routing and some other Microsoft Foundation Class (MFC) library features. In Visual C++ 6.0, you can create all three types of applications using AppWizard.

In each example, we'll look at how AppWizard generates code that doesn't rely on the document-view architecture and show you how to add your own code to each example.
________________________________________________________________________
6.11.1. - [The EX23A Example -- A Dialog-Based Application](invcpp5/ch23b.htm)
----------------------------------------------------
 The EX23A Example -- A Dialog-Based Application 

**The EX23A Example—A Dialog-Based Application**
================================================

For many applications, a dialog provides a sufficient user interface. The dialog window immediately appears when the user starts the application. The user can minimize the dialog window, and as long as the dialog is not system modal, the user can freely switch to other applications.

In this example, the dialog functions as a simple calculator, as shown in Figure 23-1. ClassWizard takes charge of defining the class data members and generating the DDX (Dialog Data Exchange) function calls—everything but the coding of the compute function. The application's resource script, ex23a.rc, defines an icon as well as the dialog.

![](c:/dl/books/windows/msvc5th/invcpp5/images/f23og01.gif)

**Figure 23-1.** _The EX23A Calculator dialog._

AppWizard gives you the option of generating a dialog-based application. Here are the steps for building the EX23A example:

2.  **Run AppWizard to produce \vcpp32\ex23a\ex23a.** Select the Dialog Based option in the AppWizard Step 1 dialog, as shown here.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g23og01x.gif)]
    
    In the next dialog, enter _EX23A Calculator_ as the dialog title.
    
3.  **Edit the _IDD_EX23A_DIALOG_ resource.** Refer to Figure 23-1 as a guide. Use the dialog editor to assign IDs to the controls shown in the table below.
    
    Open the Properties dialog box and click on the Styles tab. Select the System Menu and Minimize Box options.
    
    Control
    
    ID
    
    Left operand edit control
    
    _IDC_LEFT_
    
    Right operand edit control
    
    _IDC_RIGHT_
    
    Result edit control
    
    _IDC_RESULT_
    
    First radio button (group property set)
    
    _IDC_OPERATION_
    
    Compute pushbutton
    
    _IDC_COMPUTE_
    
4.  **Use ClassWizard to add member variables and a command handler.** AppWizard has already generated a class _CEx23aDlg_. Add the following data members.
    
    **Control ID**
    
    **Member Variable**
    
    **Type**
    
    _IDC_LEFT_
    
    _m_dLeft_
    
    _double_
    
    _IDC_RIGHT_
    
    _m_dRight_
    
    _double_
    
    _IDC_RESULT_
    
    _m_dResult_
    
    _double_
    
    _IDC_OPERATION_
    
    _m_nOperation_
    
    _int_
    
    Add the message handler _OnCompute_ for the _IDC_COMPUTE_ button.
    
5.  **Code the _OnCompute_ member function in the ex23aDlg.cpp file.** Add the following boldface code:
    
    void CEx23aDlg::OnCompute() 
    {
        **UpdateData(TRUE);
        switch (m_nOperation) {
        case 0:  // add
            m_Result = m_dLeft + m_dRight;
            break;
        case 1:  // subtract
            m_dResult = m_dLeft - m_dRight;
            break;
        case 2:  // multiply
            m_dResult = m_dLeft \* m_dRight;
            break;
        case 3:  // divide
            if (m_dRight != 0.0) {
                m_dResult = m_dLeft / m_dRight;
            }
            else {
                AfxMessageBox("Divide by zero");
                m_dResult = 0.0;
            }
            break;
        default:
            TRACE("default; m_nOperation = %d\n", m_nOperation);
        }
        UpdateData(FALSE);**
    }
    
6.  **Build and test the EX23A application.** Notice that the program's icon appears in the Microsoft Windows taskbar. Verify that you can minimize the dialog window.

**The Application Class _InitInstance_ Function**
-------------------------------------------------

The critical element of the EX23A application is the _CEx23aApp::InitInstance_ function generated by AppWizard. A normal _InitInstance_ function creates a main frame window and returns _TRUE_, allowing the program's message loop to run. The EX23A version constructs a modal dialog object, calls _DoModal_, and then returns _FALSE_. This means that the application exits after the user exits the dialog. The _DoModal_ function lets the Windows dialog procedure get and dispatch messages, as it always does. Note that AppWizard does not generate a call to _CWinApp::SetRegistryKey_.

Here is the generated _InitInstance_ code from ex23a.cpp:

BOOL CEx23aApp::InitInstance()
{
    AfxEnableControlContainer();

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

#ifdef _AFXDLL
    Enable3dControls();       // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic(); // Call this when linking to MFC statically
#endif

    CEx23aDlg dlg;
    m_pMainWnd = &dlg;
    int nResponse = dlg.DoModal();
    if (nResponse == IDOK)
    {
        // TODO: Place code here to handle when the dialog is
        //  dismissed with OK
    }
    else if (nResponse == IDCANCEL)
    {
        // TODO: Place code here to handle when the dialog is
        //  dismissed with Cancel
    }

    // Since the dialog has been closed, return FALSE so that we 
    //  exit the application, rather than start the application's 
    //  message pump.
    return FALSE;
}

**The Dialog Class and the Program Icon**
-----------------------------------------

The generated _CEx23aDlg_ class contains these two message map entries:

ON_WM_PAINT()
ON_WM_QUERYDRAGICON()

The associated handler functions take care of displaying the application's icon when the user minimizes the program. This code applies only to Microsoft Windows NT version 3.51, in which the icon is displayed on the desktop. You don't need the three handlers for Windows 95, Windows 98, or Windows NT 4.0 because those versions of Windows display the program's icon directly on the taskbar.

There is some icon code that you do need. It's in the dialog's handler for WM_INITDIALOG, which is generated by AppWizard. Notice the two _SetIcon_ calls in the _OnInitDialog_ function code below. If you checked the About box option, AppWizard generates code to add an About box to the System menu. The variable _m_hIcon_ is a data member of the dialog class that is initialized in the constructor.

BOOL CEx23aDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    // Add "About..." menu item to system menu.

    // IDM_ABOUTBOX must be in the system command range.
    ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
    ASSERT(IDM_ABOUTBOX < 0xF000);

    CMenu\* pSysMenu = GetSystemMenu(FALSE);
    if (pSysMenu != NULL)
    {
        CString strAboutMenu;
        strAboutMenu.LoadString(IDS_ABOUTBOX);
        if (!strAboutMenu.IsEmpty())
        {
            pSysMenu->AppendMenu(MF_SEPARATOR);
            pSysMenu->AppendMenu(MF_STRING, 
                                 IDM_ABOUTBOX, strAboutMenu);
        }
    }

    // Set the icon for this dialog.  The framework does this
    //  automatically when the application's main window
    //  is not a dialog
    SetIcon(m_hIcon, TRUE);         // Set big icon
    SetIcon(m_hIcon, FALSE);        // Set small icon

    // TODO: Add extra initialization here

    return TRUE;  // return TRUE  unless you set the focus to a control
}
________________________________________________________________________
6.11.2. - [The EX23B Example -- An SDI Application](invcpp5/ch23c.htm)
----------------------------------------------------
 The EX23B Example -- An SDI Application 

**The EX23B Example—An SDI Application**
========================================

This SDI "Hello, world!" example builds on the code you saw way back in [Chapter 2](ch02a.htm). The application has only one window, an object of a class derived from _CFrameWnd_. All drawing occurs inside the frame window and all messages are handled there.

2.  **Run AppWizard to produce \vcpp32\ex23b\ex23b.** Select the Single Document option in the AppWizard Step 1 dialog and uncheck the Document/View Architecture Support? option, as shown here.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g23og02x.gif)]
    
3.  **Add code to paint in the dialog.** Add the following boldface code to the _CChildView::OnPaint_ function in the ChildView.cpp source code file:
    
    void CChildView::OnPaint() 
    {
        CPaintDC dc(this); // device context for painting
    
        **dc.TextOut(0, 0, "Hello, world!");**
    
        // Do not call CWnd::OnPaint() for painting messages
    }
    
4.  **Compile and run.** You now have a complete SDI application that has no dependencies on the document-view architecture.

AppWizard automatically takes out dependencies on the document-view architecture and generates an application for you with the following elements:

*   **A main menu**—You can have a Windows-based application without a menu—you don't even need a resource script. But EX23B has both. The application framework routes menu commands to message handlers in the frame class.
*   **An icon**—An icon is useful if the program is to be activated from Microsoft Windows Explorer. It's also useful when the application's main frame window is minimized. The icon is stored in the resource, along with the menu.
*   **Window close message command handler**—Many an application needs to do special processing when its main window is closed. If you were using documents, you could override the _CDocument::SaveModified_ function. Here, to take control of the close process, AppWizard creates message handlers to process close messages sent as a result of user actions and by Windows itself when it shuts down.
*   **Toolbar and status bar**—AppWizard automatically generates a default toolbar and status bar for you and sets up the routing even though there are no document-view classes.

There are several interesting features in the SDI application that have no document-view support, including:

*   _**CChildView**_ **class**—Contrary to its name, this class is actually a CWnd derivative that is declared in ChildView.h and implemented in ChildView.cpp. _CChildView_ implements only a virtual _OnPaint_ member function, which contains any code that you want to draw in the frame window (as illustrated in step 2 of the EX23B sample).
    
*   _**CMainFrame**_ **class**—This class contains a data member, _m_wndView_, that is created and initialized in the _CMainFrame::OnCreate_ member function.
    
*   _**CMainFrame::OnSetFocus**_ **function**—This function makes sure the focus is translated to the _CChildView_:
    
    void CMainFrame::OnSetFocus(CWnd\* pOldWnd)
    {
        // forward focus to the view window
        m_wndView.SetFocus();
    }
    
*   **_CMainFrame::OnCmdMsg_ function**—This function gives the view a chance to handle any command messages first:
    
    BOOL CMainFrame::OnCmdMsg(UINT nID, int nCode, void\* pExtra,
                              AFX_CMDHANDLERINFO\* pHandlerInfo)
    {
        // let the view have first crack at the command
        if (m_wndView.OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
            return TRUE;
    
        // otherwise, do default handling
        return CFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
________________________________________________________________________
6.11.3. - [The EX23C Example -- An MDI Application](invcpp5/ch23d.htm)
----------------------------------------------------
 The EX23C Example -- An MDI Application 

**The EX23C Example—An MDI Application**
========================================

Now let's create an MDI application that doesn't use the document-view architecture.

2.  **Run AppWizard to produce \vcpp32\ex23c\ex23c.** Select the Multiple Documents option in the AppWizard Step 1 dialog and uncheck the Document/View Architecture Support? option, as shown here.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g23og03x.gif)]
    
3.  **Add code to paint in the dialog.** Add the following boldface code to the _CChildView::OnPaint_ function in the ChildView.cpp source code file:
    
    void CChildView::OnPaint() 
    {
        CPaintDC dc(this); // device context for painting
    
        **dc.TextOut(0, 0, "Hello, world!");**
    
        // Do not call CWnd::OnPaint() for painting messages
    }
    
4.  **Compile and run.** You now have a complete MDI application without dependencies on the document-view architecture.
    
    As in EX23B, this example automatically creates a _CChildView_ class. The main difference between EX23B and EX23C is the fact that in EX23C the _CChildView_ class is created in the _CChildFrame::OnCreate_ function instead of in the _CMainFrame_ class.
    

In this chapter you've learned how to create three kinds of applications that do not depend on the document-view architecture. Examining how these applications are generated is also a great way to learn how MFC works. We recommend that you compare the generated results to similar applications with document-view architecture support to get a complete picture of how the document-view classes work with the rest of MFC.
________________________________________________________________________
/7. - [Part IV: Active X: COM, Automation, OLE]()
====================================================
________________________________________________________________________
7.1. - [Chapter 24 -- The Component Object Model](invcpp5/ch24a.htm)
----------------------------------------------------
 Chapter 24 -- The Component Object Model  Chapter 24

The Component Object Model
==========================

The Component Object Model (COM) is the foundation of much of the new Microsoft ActiveX technology, and after five years it's become an integral part of Microsoft Windows. So COM is now an integral part of _Programming Visual C++_. Soon, most Windows programming will involve COM, so you'd better start learning it now. But where do you begin? You could start with the Microsoft Foundation Class classes for ActiveX Controls, Automation, and OLE, but as useful as those classes are, they obscure the real COM architecture. You've got to start with fundamental theory, and that includes COM and something called an interface.

This is the first of seven chapters that make up Part IV of this book. Here you'll get the theory you need for the next six chapters. You'll learn about interfaces and how the MFC library implements interfaces through its macros and interface maps.
________________________________________________________________________
7.1.1. - [ActiveX Technology Background](invcpp5/ch24b.htm)
----------------------------------------------------
 ActiveX Technology Background 

**ActiveX Technology Background**
=================================

The terminology is changing as fast as the technology, and not all groups within Microsoft can agree on how to use the terms ActiveX and OLE. Think of ActiveX as something that was created when the "old" OLE collided with the Internet. ActiveX includes not only those Windows features built on COM (which you'll study in this part of the book) but also the Microsoft Internet Information Server family and the WinInet programming interface (covered in Part VI).

Yes, OLE is still here, but once again it stands for Object Linking and Embedding, just as it did in the days of OLE 1. It's just another subset of ActiveX technology that includes odds and ends such as drag and drop. Unfortunately (or fortunately, if you have existing code), the MFC source code and the Windows API have not kept current with the naming conventions. As a result, you'll see lots of occurrences of "OLE" and "Ole" in class names and in function names, even though some of those classes and functions go beyond linking and embedding. In this part of the book, you might notice references to the "server" in the code generated by AppWizard. Microsoft has now reserved this term for database servers and Internet servers; "component" is the new term for OLE servers.

Bookstore computer sections are now full of books on OLE, COM, and ActiveX. We don't claim to offer that level of detail here, but you should come away with a pretty good understanding of COM theory. We've included a closer connection to the MFC library classes than you might see in other books, with the exception of _MFC Internals_ (Addison-Wesley, 1996) by George Shepherd and Scot Wingo. The net result should be good preparation for the really heavy-duty ActiveX/COM books, including Kraig Brockschmidt's _Inside OLE,_ 2nd ed_._ (Microsoft Press, 1995) and Don Box's _Essential COM_ (Addison-Wesley, 1998). A good mid-level book is Dale Rogerson's _Inside COM_ (Microsoft Press, 1997).

One more thing: don't expect this stuff to be easy. Kraig Brockschmidt reported "six months of mental fog" before he started understanding these concepts. A thorough knowledge of the C++ language is the minimum prerequisite. Don't be afraid to dig in and write code. Make sure you can do the easy things before getting into advanced areas like multithreaded COM, custom marshaling, and distributed COM (DCOM).
________________________________________________________________________
7.1.2. - [The Component Object Model](invcpp5/ch24c.htm)
----------------------------------------------------
 The Component Object Model 

**The Component Object Model**
==============================

COM is an "industry-standard" software architecture supported by Microsoft, Digital Equipment Corporation, and many other companies. It's by no means the only standard. Indeed, it competes directly against other standards, such as Corba from the Open Software Foundation (OSF). Some people are working to establish interoperability between COM and other architectures, but my guess is that COM will become the leading standard.

**The Problem That COM Solves**
-------------------------------

The "problem" is that there's no standard way for Windows program modules to communicate with one another. "But," you say "what about the DLL with its exported functions, Dynamic Data Exchange (DDE), the Windows Clipboard, and the Windows API itself, not to mention legacy standards such as VBX and OLE 1? Aren't they good enough?" Well, no. You can't build an object-oriented operating system for the future out of these ad hoc, unrelated standards. With the Component Object Model, however, you can, and that's precisely what Microsoft is doing.

**The Essence of COM**
----------------------

What's wrong with the old standards? A lot. The Windows API has too large a programming "surface area"—more than 350 separate functions. VBXs don't work in the 32-bit world. DDE comes with a complicated system of applications, topics, and items. How you call a DLL is totally application-specific. COM provides a unified, expandable, object-oriented communications protocol for Windows that already supports the following features:

*   A standard, language-independent way for a Win32 client EXE to load and call a Win32 DLL
    
*   A general-purpose way for one EXE to control another EXE on the same computer (the DDE replacement)
    
*   A replacement for the VBX control, called an ActiveX control
    
*   A powerful new way for application programs to interact with the operating system
    
*   Expansion to accommodate new protocols such as Microsoft's OLE DB database interface
    
*   The distributed COM (DCOM) that allows one EXE to communicate with another EXE residing on a different computer, even if the computers use different microprocessor-chip families

So what is COM? That's an easier question to ask than to answer. At DevelopMentor (a training facility for software developers), the party line is that "COM is love." That is, COM is a powerful integrating technology that allows you to mix all sorts of disparate software parts together at runtime. COM allows developers to write software that runs together regardless of issues such as thread-awareness and language choice.

COM is a protocol that connects one software module with another and then drops out of the picture. After the connection is made, the two modules can communicate through a mechanism called an interface. Interfaces require no statically or dynamically linked entry points or hard-coded addresses other than the few general-purpose COM functions that start the communication process. An interface (more precisely, a COM interface) is a term that you'll be seeing a lot of.

**What Is a COM Interface?**
----------------------------

Before digging into the topic of interfaces, let's re-examine the nature of inheritance and polymorphism in normal C++. We'll use a planetary-motion simulation (suitable for NASA or Nintendo) to illustrate C++ inheritance and polymorphism. Imagine a spaceship that travels through our solar system under the influence of the sun's gravity. In ordinary C++, you could declare a _CSpaceship_ class and write a constructor that sets the spaceship's initial position and acceleration. Then you could write a nonvirtual member function named _Fly_ that implemented Kepler's laws to model the movement of the spaceship from one position to the next—say, over a period of 0.1 second. You could also write a _Display_ function that painted an image of the spaceship in a window. The most interesting feature of the _CSpaceship_ class is that the interface of the C++ class (the way the client talks to the class) and the implementation are tightly bound. One of the main goals of COM is to separate a class's interface from its implementation.

If we think of this example within the context of COM, the spaceship code could exist as a separate EXE or DLL (the component), which is a COM module. In COM the simulation manager (the client program) can't call _Fly_ or any _CSpaceship_ constructor directly: COM provides only a standard global function to gain access to the spaceship object, and then the client and the object use interfaces to talk to one another. Before we tackle real COM, let's build a COM simulation in which both the component and the client code are statically linked in the same EXE file. For our standard global function, we'll invent a function named _GetClassObject._

> NOTE
> 
> If you want to map this process back to the way MFC works, you can look at _CRuntimeClass,_ which serves as a class object for _CObject_\-based classes. A class object is a meta-class (either in concept or in form).

In this COM simulation, clients will use this global single abstract function (_GetClassObject_) for objects of a particular class. In real COM, clients would get a class object first and then ask the class object to manufacture the real object in much the same way MFC does dynamic creation. _GetClassObject_ has the following three parameters:

BOOL GetClassObject(int nClsid, int nIid, void\*\* ppvObj);

The first _GetClassObject_ parameter, _nClsid_, is a 32-bit integer that uniquely identifies the _CSpaceship_ class. The second parameter, _nIid_, is the unique identifier of the interface that we want. The third parameter is a pointer to an interface to the object. Remember that we're going to be dealing with interfaces now, (which are different from classes). As it turns out, a class can have several interfaces, so the last two parameters exist to manage interface selection. The function returns _TRUE_ if the call is successful.

Now let's back up to the design of _CSpaceship_. We haven't really explained spaceship interfaces yet. A COM interface is a C++ base class (actually, a C++ _struct_) that declares a group of pure virtual functions. These functions completely control some aspect of derived class behavior. For _CSpaceship_, let's write an interface named _IMotion_, which controls the spaceship object's position. For simplicity's sake, we'll declare just two functions, _Fly_ and _GetPosition_, and we'll keep things uncomplicated by making the position value an integer. The _Fly_ function calculates the position of the spaceship, and the _GetPosition_ function returns a reference to the current position. Here are the declarations:

struct IMotion
{
    virtual void Fly() = 0;
    virtual int& GetPosition() = 0;
};

class CSpaceship : public IMotion
{
protected:
    int m_nPosition;
public:
    CSpaceship() { m_nPosition = 0; }
    void Fly();
    int& GetPosition() { return m_nPosition; }
};

The actual code for the spaceship-related functions—including _GetClassObject_—is located in the component part of the program. The client part calls the _GetClassObject_ function to construct the spaceship and to obtain an _IMotion_ pointer. Both parts have access to the _IMotion_ declaration at compile time. Here's how the client calls _GetClassObject_:

IMotion\* pMot;
GetClassObject(CLSID_CSpaceship, IID_IMotion, (void\*\*) &pMot);

Assume for the moment that COM can use the unique integer identifiers _CLSID_CSpaceship_ and _IID_IMotion_ to construct a spaceship object instead of some other kind of object. If the call is successful, _pMot_ points to a _CSpaceship_ object that _GetClassObject_ somehow constructs. As you can see, the _CSpaceship_ class implements the _Fly_ and _GetPosition_ functions, and our main program can call them for the one particular spaceship object, as shown here:

int nPos = 50;
pMot->GetPosition() = nPos;
pMot->Fly();
nPos = pMot->GetPosition();
TRACE("new position = %d\n", nPos);

Now the spaceship is off and flying. We're controlling it entirely through the _pMot_ pointer. Notice that _pMot_ is technically not a pointer to a _CSpaceship_ object. However, in this case, a _CSpaceship_ pointer and an _IMotion_ pointer are the same because _CSpaceship_ is derived from _IMotion_. You can see how the virtual functions work here: it's classic C++ polymorphism.

Let's make things a little more complex by adding a second interface, _IVisual_, which handles the spaceship's visual representation. One function is enough—_Display_. Here's the whole base class:

struct IVisual
{
    virtual void Display() = 0;
};

Are you getting the idea that COM wants you to associate functions in groups? You're not imagining it. But why? Well, in your space simulation, you probably want to include other kinds of objects in addition to spaceships. Imagine that the _IMotion_ and _IVisual_ interfaces are being used for other classes. Perhaps a _CSun_ class has an implementation of _IVisual_ but does not have an implementation of _IMotion_, and perhaps a _CSpaceStation_ class has other interfaces as well. If you "published" your _IMotion_ and _IVisual_ interfaces, perhaps other space simulation software companies would adopt them.

Think of an interface as a contract between two software modules. The idea is that interface declarations never change. If you want to upgrade your spaceship code, you don't change the _IMotion_ or the _IVisual_ interface; rather, you add a new interface, such as _ICrew_. The existing spaceship clients can continue to run with the old interfaces, and new client programs can use the new _ICrew_ interface as well. These client programs can find out at runtime which interfaces a particular spaceship software version supports.

Consider the _GetClassObject_ function as a more powerful alternative to the C++ constructor. With the ordinary constructor, you obtain one object with one batch of member functions. With the _GetClassObject_ function, you obtain the object plus your choice of interfaces. As you'll see later, you start with one interface and then use that interface to get other interfaces to the same object.

So how do you program two interfaces for _CSpaceship_? You could use C++ multiple inheritance, but that wouldn't work if two interfaces had the same member function name. The MFC library uses nested classes instead, so that's what we'll use to illustrate multiple interfaces on the _CSpaceship_ class. Not all C++ programmers are familiar with nested classes, so I'll offer a little help. Here's a first cut at nesting interfaces within the _CSpaceship_ class:

class CSpaceship
{
protected:
    int m_nPosition;
    int m_nAcceleration;
    int m_nColor;
public:
    CSpaceship()
        { m_nPosition = m_nAcceleration = m_nColor = 0; }
    class XMotion : public IMotion
    {
    public:
        XMotion() { }
        virtual void Fly();
        virtual int& GetPosition();
    } m_xMotion;

    class XVisual : public IVisual
    {
    public:
        XVisual() { }
        virtual void Display();
    } m_xVisual;

    friend class XVisual;
    friend class XMotion;
};

> NOTE
> 
> It might make sense to make _m_nAcceleration_ a data member of _XMotion_ and _m_nColor_ a data member of _XVisual_. We'll make them data members of _CSpaceship_ because that strategy is more compatible with the MFC macros, as you'll see later.

Notice that the implementations of _IMotion_ and _IVisual_ are contained within the "parent" _CSpaceship_ class. In COM, this parent class is known as the class with object identity. Be aware that _m_xMotion_ and _m_xVisual_ are actually embedded data members of _CSpaceship._ Indeed, you could have implemented _CSpaceship_ strictly with embedding. Nesting, however, brings to the party two advantages : 1) nested class member functions can access parent class data members without the need for _CSpaceship_ pointer data members, and 2) the nested classes are neatly packaged along with the parent while remaining invisible outside the parent. Look at the code below for the _GetPosition_ member function.

int& CSpaceship::XMotion::GetPosition()
{
    METHOD_PROLOGUE(CSpaceship, Motion) // makes pThis
    return pThis->m_nPosition;
}

Notice also the double scope resolution operators, which are necessary for nested class member functions. _METHOD_PROLOGUE_ is a one-line MFC macro that uses the C _offsetof_ operator to retrieve the offset used in generating a _this_ pointer to the parent class, _pThis_. The compiler always knows the offset from the beginning of parent class data to the beginning of nested class data. _GetPosition_ can thus access the _CSpaceship_ data member _m_nPosition_.

Now suppose you have two interface pointers, _pMot_ and _pVis_, for a particular _CSpaceship_ object. (Don't worry yet about how you got these pointers.) You can call interface member functions in the following manner:

pMot->Fly();
pVis->Display();

What's happening under the hood? In C++, each class (at least, each class that has virtual functions and is not an abstract base class) has a virtual function table, which is otherwise known as a vtable. In this example, that means there are vtables for _CSpaceship::XMotion_ and _CSpaceship::XVisual_. For each object, there's a pointer to the object's data, the first element of which is a pointer to the class's vtable. The pointer relationships are shown here.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g24og01x.gif)]

> NOTE
> 
> Theoretically, it's possible to program COM in C. If you look at the Windows header files, you'll see code such as this:
> 
> #ifdef __cplusplus
>         // C++-specific headers
> #else
>         /\* C-specific headers \*/
> #endif
> 
> In C++, interfaces are declared as C++ _structs_, often with inheritance; in C, they're declared as C _typedef structs_ with no inheritance. In C++, the compiler generates vtables for your derived classes; in C, you must "roll your own" vtables, and that gets tedious. It's important to realize, however, that in neither language do the interface declarations have data members, constructors, or destructors. Therefore, you can't rely on the interface having a virtual destructor—but that's not a problem because you never invoke a destructor for an interface.

**The _IUnknown_ Interface and the _QueryInterface_ Member Function**
---------------------------------------------------------------------

Let's get back to the problem of how to obtain your interface pointers in the first place. COM declares a special interface named _IUnknown_ for this purpose. As a matter of fact, all interfaces are derived from _IUnknown_, which has a pure virtual member function, _QueryInterface_, that returns an interface pointer based on the interface ID you feed it.

Once the interface mechanisms are hooked up, the client needs to get an _IUnknown_ interface pointer (at the very least) or a pointer to one of the derived interfaces. Here is the new interface hierarchy, with _IUnknown_ at the top:

struct IUnknown
{
    virtual BOOL QueryInterface(int nIid, void\*\* ppvObj) = 0;
};

struct IMotion : public IUnknown
{
    virtual void Fly() = 0;
    virtual int& GetPosition() = 0;
};

struct IVisual : public IUnknown
{
    virtual void Display() = 0;
};

To satisfy the compiler, we must now add _QueryInterface_ implementations in both _CSpaceship::XMotion_ and _CSpaceship::XVisual._ What do the vtables look like after this is done? For each derived class, the compiler builds a vtable with the base class function pointers on top, as shown here.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g24og02x.gif)]

_GetClassObject_ can get the interface pointer for a given _CSpaceship_ object by getting the address of the corresponding embedded object. Here's the code for the _QueryInterface_ function in _XMotion_:

BOOL CSpaceship::XMotion::QueryInterface(int nIid,
                                         void\*\* ppvObj)
{
    METHOD_PROLOGUE(CSpaceship, Motion)
    switch (nIid) {
    case IID_IUnknown:
    case IID_IMotion:
        \*ppvObj = &pThis->m_xMotion;
        break;
    case IID_IVisual:
        \*ppvObj = &pThis->m_xVisual;
        break;
    default:
        \*ppvObj = NULL;
        return FALSE;
    }
    return TRUE;
}

Because _IMotion_ is derived from _IUnknown_, an _IMotion_ pointer is a valid pointer if the caller asks for an _IUnknown_ pointer.

> NOTE
> 
> The COM standard demands that _QueryInterface_ return exactly the same _IUnknown_ pointer value for _IID_IUnknown_, no matter which interface pointer you start with. Thus, if two _IUnknown_ pointers match, you can assume that they refer to the same object. _IUnknown_ is sometimes known as the "void\*" of COM because it represents the object's identity.

Below is a _GetClassObject_ function that uses the address of _m_xMotion_ to obtain the first interface pointer for the newly constructed _CSpaceship_ object:

BOOL GetClassObject(int& nClsid, int& nIid,
                    void\*\* ppvObj)
{
    ASSERT(nClsid == CLSID_CSpaceship); 
    CSpaceship\* pObj = new CSpaceship();
    IUnknown\* pUnk = &pObj->m_xMotion;
    return pUnk->QueryInterface(nIid, ppvObj);
}

Now your client program can call _QueryInterface_ to obtain an _IVisual_ pointer, as shown here:

IMotion\* pMot;
IVisual\* pVis;
GetClassObject(CLSID_CSpaceship, IID_IMotion, (void\*\*) &pMot);
pMot->Fly();
pMot->QueryInterface(IID_IVisual, (void\*\*) &pVis);
pVis->Display();

Notice that the client uses a _CSpaceship_ object, but it never has an actual _CSpaceship_ pointer. Thus, the client cannot directly access _CSpaceship_ data members even if they're public. Notice also that we haven't tried to delete the spaceship object yet—that will come shortly.

There's a special graphical representation for interfaces and COM classes. Interfaces are shown as small circles (or jacks) with lines attached to their class. The _IUnknown_ interface, which every COM class supports, is at the top, and the others are on the left. The _CSpaceship_ class can be represented like this.

![](c:/dl/books/windows/msvc5th/invcpp5/images/g24og03.gif)

**Reference Counting: The _AddRef_ and _Release_ Functions**
------------------------------------------------------------

COM interfaces don't have virtual destructors, so it isn't cool to write code like the following:

delete pMot;  // pMot is an IMotion pointer; don't do this

COM has a strict protocol for deleting objects; the two other _IUnknown_ virtual functions, _AddRef_ and _Release_, are the key. Each COM class has a data member—_m_dwRef_, in the MFC library—that keeps track of how many "users" an object has. Each time the component program returns a new interface pointer (as in _QueryInterface_), the program calls _AddRef_, which increments _m_dwRef._ When the client program is finished with the pointer, it calls _Release_. When _m_dwRef_ goes to 0, the object destroys itself. Here's an example of a _Release_ function for the _CSpaceship::XMotion_ class:

DWORD CSpaceship::XMotion::Release()
{
    METHOD_PROLOGUE(CSpaceship, Motion) // makes pThis
    if (pThis->m_dwRef == 0)
        return 0;
    if (--pThis->m_dwRef == 0) {
        delete pThis; // the spaceship object
        return 0;
    }
    return pThis->m_dwRef;
}

In MFC COM-based programs, the object's constructor sets _m_dwRef_ to 1. This means that it isn't necessary to call _AddRef_ after the object is first constructed. A client program should call _AddRef_, however, if it makes a copy of an interface pointer.

**Class Factories**
-------------------

Object-oriented terminology can get a little fuzzy sometimes. Smalltalk programmers, for example, talk about "objects" the way C++ programmers talk about "classes." The COM literature often uses the term "component object" to refer to the object plus the code associated with it. COM carries with it the notion of a "class object," which is sometimes referred to as a "class factory." To be more accurate, it should probably be called an "object factory." A COM class object represents the global static area of a specific COM class. Its analog in MFC is the _CRuntimeClass_. A class object is sometimes called a class factory because it often implements a special COM interface named _IClassFactory_. This interface, like all interfaces, is derived from _IUnknown_. _IClassFactory_'s principal member function is _CreateInstance_, which in our COM simulation is declared like this:

virtual BOOL CreateInstance(int& nIid, void\*\* ppvObj) = 0;

Why use a class factory? We've already seen that we can't call the target class constructor directly; we have to let the component module decide how to construct objects. The component provides the class factory for this purpose and thus encapsulates the creation step, as it should. Locating and launching component modules—and thus establishing the class factory—is expensive, but constructing objects with _CreateInstance_ is cheap. We can therefore allow a single class factory to create multiple objects.

What does all this mean? It means that we screwed up when we let _GetClassObject_ construct the _CSpaceship_ object directly. We were supposed to construct a class factory object first and then call _CreateInstance_ to cause the class factory (object factory) to construct the actual spaceship object.

Let's properly construct the spaceship simulation. First we declare a new class, _CSpaceshipFactory_. To avoid complication, we'll derive the class from _IClassFactory_ so that we don't have to deal with nested classes. In addition, we'll add the code that tracks references:

struct IClassFactory : public IUnknown
{
    virtual BOOL CreateInstance(int& nIid, void\*\* ppvObj) = 0;
};

class CSpaceshipFactory : public IClassFactory
{
private:
    DWORD m_dwRef;
public:
    CSpaceshipFactory() { m_dwRef = 1; }
    // IUnknown functions
    virtual BOOL QueryInterface(int& nIid,
                                void\*\* ppvObj);
    virtual DWORD AddRef();
    virtual DWORD Release();
    // IClassFactory function
    virtual BOOL CreateInstance(int& nIid,
                                void\*\* ppvObj);
};

Next we'll write the _CreateInstance_ member function:

BOOL CSpaceshipFactory::CreateInstance(int& nIid, void\*\* ppvObj)
{
    CSpaceship\* pObj = new CSpaceship();
    IUnknown\* pUnk = &pObj->m_xMotion;
    return pUnk->QueryInterface(nIid, ppvObj);
}

Finally, here is the new _GetClassObject_ function, which constructs a class factory object and returns an _IClassFactory_ interface pointer.

BOOL GetClassObject(int& nClsid, int& nIid,
                    void\*\* ppvObj)
{
    ASSERT(nClsid == CLSID_CSpaceship);
    ASSERT((nIid == IID_IUnknown) || (nIid == IID_IClassFactory));
    CSpaceshipFactory\* pObj = new CSpaceshipFactory();
    \*ppObj = pObj; // IUnknown\* = IClassFactory\* = CSpaceship\*
}

The _CSpaceship_ and _CSpaceshipFactory_ classes work together and share the same class ID. Now the client code looks like this (without error-checking logic):

IMotion\* pMot;
IVisual\* pVis;
IClassFactory\* pFac;
GetClassObject(CLSID_CSpaceship, IID_IClassFactory, (void\*\*) &pFac);
pFac->CreateInstance(IID_IMotion, &pMot);
pMot->QueryInterface(IID_IVisual, (void\*\*) &pVis);
pMot->Fly();
pVis->Display();

Notice that the _CSpaceshipFactory_ class implements the _AddRef_ and _Release_ functions. It must do this because _AddRef_ and _Release_ are pure virtual functions in the _IUnknown_ base class. We'll start using these functions in the next iteration of the program.

**The _CCmdTarget_ Class**
--------------------------

We're still a long way from real MFC COM-based code, but we can take one more step in the COM simulation before we switch to the real thing. As you might guess, some code and data can be "factored out" of our spaceship COM classes into a base class. That's exactly what the MFC library does. The base class is _CCmdTarget_, the standard base class for document and window classes. _CCmdTarget_, in turn, is derived from _CObject_. We'll use _CSimulatedCmdTarget_ instead, and we won't put too much in it—only the reference-counting logic and the _m_dwRef_ data member. The _CSimulatedCmdTarget_ functions _ExternalAddRef_ and _ExternalRelease_ can be called in derived COM classes. Because we're using _CSimulatedCmdTarget_, we'll bring _CSpaceshipFactory_ in line with _CSpaceship_, and we'll use a nested class for the _IClassFactory_ interface.

We can also do some factoring out inside our _CSpaceship_ class. The _QueryInterface_ function can be "delegated" from the nested classes to the outer class helper function _ExternalQueryInterface_, which calls _ExternalAddRef_. Thus, each _QueryInterface_ function increments the reference count, but _CreateInstance_ calls _ExternalQueryInterface_, followed by a call to _ExternalRelease_. When the first interface pointer is returned by _CreateInstance_, the spaceship object has a reference count of 1. A subsequent _QueryInterface_ call increments the count to 2, and in this case, the client must call _Release_ twice to destroy the spaceship object.

One last thing—we'll make the class factory object a global object. That way we won't have to call its constructor. When the client calls _Release_, there isn't a problem because the class factory's reference count is 2 by the time the client receives it. (The _CSpaceshipFactory_ constructor sets the reference count to 1, and _ExternalQueryInterface_, called by _GetClassObject_, sets the count to 2.)

**The EX24A Example—A Simulated COM**
-------------------------------------

Figures 24-1, 24-2, 24-3, and 24-4 show code for a working "simulated COM" program, EX24A. This is a Win32 Console Application (without the MFC library) that uses a class factory to construct an object of class _CSpaceship_, calls its interface functions, and then releases the spaceship. The Interface.h header file, shown in Figure 24-1, contains the _CSimulatedCmdTarget_ base class and the interface declarations that are used by both the client and component programs. The Spaceship.h header file shown in Figure 24-2 contains the spaceship-specific class declarations that are used in the component program. Spaceship.cpp, shown in Figure 24-3, is the component that implements _GetClassObject_; Client.cpp, shown in Figure 24-4, is the client that calls _GetClassObject_. What's phony here is that both client and component code are linked within the same ex24a.exe program. Thus, our simulated COM is not required to make the connection at runtime. (You'll see how that's done later in this chapter.)

**INTERFACE.H**

// definitions that make our code look like MFC code
#define BOOL   int
#define DWORD  unsigned int
#define TRUE   1
#define FALSE  0
#define TRACE  printf
#define ASSERT assert
//----------definitions and macros-----------------------------------
#define CLSID_CSpaceship    10
#define IID_IUnknown        0
#define IID_IClassFactory   1
#define IID_IMotion         2
#define IID_IVisual         3
// this macro for 16-bit Windows only
#define METHOD_PROLOGUE(theClass, localClass) \
    theClass\* pThis = ((theClass\*)((char\*)(this) - \
    offsetof(theClass, m_x##localClass))); \


BOOL GetClassObject(int nClsid, int nIid, void\*\* ppvObj);

//----------interface declarations-----------------------------------
struct IUnknown
{
    IUnknown() { TRACE("Entering IUnknown ctor %p\n", this); }
    virtual BOOL QueryInterface(int nIid, void\*\* ppvObj) = 0;
    virtual DWORD Release() = 0;
    virtual DWORD AddRef() = 0;
};

struct IClassFactory : public IUnknown
{
    IClassFactory()
        { TRACE("Entering IClassFactory ctor %p\n", this); }
    virtual BOOL CreateInstance(int nIid, void\*\* ppvObj) = 0;
};

struct IMotion : public IUnknown
{
    IMotion() { TRACE("Entering IMotion ctor %p\n", this); }
    virtual void Fly() = 0; // pure
    virtual int& GetPosition() = 0;
};
struct IVisual : public IUnknown
{
    IVisual() { TRACE("Entering IVisual ctor %p\n", this); }
    virtual void Display() = 0;
};

class CSimulatedCmdTarget // \`simulated' CSimulatedCmdTarget
{
public:
    DWORD m_dwRef;

protected:
    CSimulatedCmdTarget() {
        TRACE("Entering CSimulatedCmdTarget ctor %p\n", this);
        m_dwRef = 1; // implied first AddRef
    }
    virtual ~CSimulatedCmdTarget()
        { TRACE("Entering CSimulatedCmdTarget dtor %p\n", this); }
    DWORD ExternalRelease() {
    TRACE("Entering CSimulatedCmdTarget::ExternalRelease--RefCount = \
          %ld\n", m_dwRef);
        if (m_dwRef == 0)
            return 0;
        if(--m_dwRef == 0L) {
            TRACE("deleting\n");
            delete this;
            return 0;
        }
        return m_dwRef;
    }
    DWORD ExternalAddRef() { return ++m_dwRef; }
};

**Figure 24-1.** _The Interface.h file._

**SPACESHIP.H**

class CSpaceship;

//----------class declarations-----------------------------------------
class CSpaceshipFactory : public CSimulatedCmdTarget
{
public:
    CSpaceshipFactory()
        { TRACE("Entering CSpaceshipFactory ctor %p\n", this); }
    ~CSpaceshipFactory()
        { TRACE("Entering CSpaceshipFactory dtor %p\n", this); }
    BOOL ExternalQueryInterface(int lRid, void\*\* ppvObj);
    class XClassFactory : public IClassFactory
    {
    public:
        XClassFactory()
            { TRACE("Entering XClassFactory ctor %p\n", this); }
        virtual BOOL QueryInterface(int lRid, void\*\* ppvObj);
        virtual DWORD Release();
        virtual DWORD AddRef();
        virtual BOOL CreateInstance(int lRid, void\*\* ppvObj);
    } m_xClassFactory;
    friend class XClassFactory;
};
class CSpaceship : public CSimulatedCmdTarget
{
private:
    int m_nPosition; // We can access these from
                     //  all the interfaces
    int m_nAcceleration;
    int m_nColor;
public:
    CSpaceship() {
        TRACE("Entering CSpaceship ctor %p\n", this);
        m_nPosition = 100;
        m_nAcceleration = 101;
        m_nColor = 102;
    }
    ~CSpaceship()
        { TRACE("Entering CSpaceship dtor %p\n", this); }
    BOOL ExternalQueryInterface(int lRid, void\*\* ppvObj);
    class XMotion : public IMotion
    {
    public:
        XMotion()
            { TRACE("Entering XMotion ctor %p\n", this); }
        virtual BOOL QueryInterface(int lRid, void\*\* ppvObj);
        virtual DWORD Release();
        virtual DWORD AddRef();
        virtual void Fly();
        virtual int& GetPosition();
    } m_xMotion;
    
class XVisual : public IVisual
    {
    public:
        XVisual() { TRACE("Entering XVisual ctor\n"); }
        virtual BOOL QueryInterface(int lRid, void\*\* ppvObj);
        virtual DWORD Release();
        virtual DWORD AddRef();
        virtual void Display();
    } m_xVisual;

    friend class XVisual;  // These must be at the bottom!
    friend class XMotion;
    friend class CSpaceshipFactory::XClassFactory;
};

**Figure 24-2.** _The Spaceship.h file._

**SPACESHIP.CPP**

#include <stdio.h>
#include <stddef.h> // for offsetof in METHOD_PROLOGUE
#include <ASSERT.h>
#include "Interface.h"
#include "Spaceship.h"

CSpaceshipFactory g_factory;

//----------member functions-----------------------------------------
BOOL CSpaceshipFactory::ExternalQueryInterface(int nIid,
                                               void\*\* ppvObj) {
    TRACE("Entering CSpaceshipFactory::ExternalQueryInterface--nIid =  \
          %d\n", nIid);
    switch (nIid) {
    case IID_IUnknown:
    case IID_IClassFactory:
        \*ppvObj = &m_xClassFactory;
        break;
    default:
        \*ppvObj = NULL;
        return FALSE;
    }
    ExternalAddRef();
    return TRUE;
}                               
BOOL CSpaceshipFactory::XClassFactory::QueryInterface(int nIid,
                                                      void\*\* ppvObj) {
    TRACE("Entering CSpaceshipFactory::XClassFactory::\
           QueryInterface--nIid = %d\n", nIid);
    METHOD_PROLOGUE(CSpaceshipFactory, ClassFactory) // makes pThis
    return pThis->
    ExternalQueryInterface(nIid, ppvObj); // delegate to
                                          //  CSpaceshipFactory
}                               

BOOL CSpaceshipFactory::XClassFactory::CreateInstance(int nIid,
                                                      void\*\* ppvObj) {
    TRACE("Entering CSpaceshipFactory::XClassFactory::CreateInstance\n");
    METHOD_PROLOGUE(CSpaceshipFactory, ClassFactory) // makes pThis
    CSpaceship\* pObj = new CSpaceship();
    if (pObj->ExternalQueryInterface(nIid, ppvObj)) {
        pObj->ExternalRelease(); // balance reference count
        return TRUE;
    }
    return FALSE;
}

DWORD CSpaceshipFactory::XClassFactory::Release() {
    TRACE("Entering CSpaceshipFactory::XClassFactory::Release\n");
    METHOD_PROLOGUE(CSpaceshipFactory, ClassFactory) // makes pThis
    return pThis->ExternalRelease(); // delegate to CSimulatedCmdTarget
}

DWORD CSpaceshipFactory::XClassFactory::AddRef() {
    TRACE("Entering CSpaceshipFactory::XClassFactory::AddRef\n");
    METHOD_PROLOGUE(CSpaceshipFactory, ClassFactory) // makes pThis
    return pThis->ExternalAddRef(); // delegate to CSimulatedCmdTarget
}

BOOL CSpaceship::ExternalQueryInterface(int nIid, void\*\* ppvObj) {
    TRACE("Entering CSpaceship::ExternalQueryInterface--nIid = 
           %d\n", nIid);
    switch (nIid) {
    case IID_IUnknown:
    case IID_IMotion:
        \*ppvObj = &m_xMotion; // Both IMotion and IVisual are derived
        break;                //  from IUnknown, so either pointer will do
    case IID_IVisual:
        \*ppvObj = &m_xVisual;
        break;
    default:
        \*ppvObj = NULL;
        return FALSE;
    }
    ExternalAddRef();
    return TRUE;
}

BOOL CSpaceship::XMotion::QueryInterface(int nIid, void\*\* ppvObj) {
    TRACE("Entering CSpaceship::XMotion::QueryInterface--nIid =  \ 
           %d\n", nIid);
    METHOD_PROLOGUE(CSpaceship, Motion) // makes pThis
    return pThis->ExternalQueryInterface(nIid, ppvObj); // delegate to
                                                        //  CSpaceship
} 

DWORD CSpaceship::XMotion::Release() {
    TRACE("Entering CSpaceship::XMotion::Release\n");
    METHOD_PROLOGUE(CSpaceship, Motion) // makes pThis
    return pThis->ExternalRelease(); // delegate to CSimulatedCmdTarget
}

DWORD CSpaceship::XMotion::AddRef() {
    TRACE("Entering CSpaceship::XMotion::AddRef\n");
    METHOD_PROLOGUE(CSpaceship, Motion) // makes pThis
    return pThis->ExternalAddRef(); // delegate to CSimulatedCmdTarget
}

void CSpaceship::XMotion::Fly() {
    TRACE("Entering CSpaceship::XMotion::Fly\n");
    METHOD_PROLOGUE(CSpaceship, Motion) // makes pThis
    TRACE("this = %p, pThis = %p\n", this, pThis);
    TRACE("m_nPosition = %d\n", pThis->m_nPosition);
    TRACE("m_nAcceleration = %d\n", pThis->m_nAcceleration);
}

int& CSpaceship::XMotion::GetPosition() {
    TRACE("Entering CSpaceship::XMotion::GetPosition\n");
    METHOD_PROLOGUE(CSpaceship, Motion) // makes pThis
    TRACE("this = %p, pThis = %p\n", this, pThis);
    TRACE("m_nPosition = %d\n", pThis->m_nPosition);
    TRACE("m_nAcceleration = %d\n", pThis->m_nAcceleration);
    return pThis->m_nPosition;
}

BOOL CSpaceship::XVisual::QueryInterface(int nIid, void\*\* ppvObj) {
    TRACE("Entering CSpaceship::XVisual::QueryInterface--nIid =  \
           %d\n", nIid);
    METHOD_PROLOGUE(CSpaceship, Visual) // makes pThis
    return pThis->ExternalQueryInterface(nIid, ppvObj); // delegate to
                                                        //  CSpaceship
}

DWORD CSpaceship::XVisual::Release() {
    TRACE("Entering CSpaceship::XVisual::Release\n");
    METHOD_PROLOGUE(CSpaceship, Visual) // makes pThis
    return pThis->ExternalRelease(); // delegate to CSimulatedCmdTarget
}

DWORD CSpaceship::XVisual::AddRef() {
    TRACE("Entering CSpaceship::XVisual::AddRef\n");
    METHOD_PROLOGUE(CSpaceship, Visual) // makes pThis
    return pThis->ExternalAddRef(); // delegate to CSimulatedCmdTarget
}

void CSpaceship::XVisual::Display() {
    TRACE("Entering CSpaceship::XVisual::Display\n");
    METHOD_PROLOGUE(CSpaceship, Visual) // makes pThis
    TRACE("this = %p, pThis = %p\n", this, pThis);
    TRACE("m_nPosition = %d\n", pThis->m_nPosition);
    TRACE("m_nColor = %d\n", pThis->m_nColor);
}

//----------simulates COM component -----------------------------------
// In real COM, this would be DllGetClassObject, which would be called
//  whenever a client called CoGetClassObject 

BOOL GetClassObject(int nClsid, int nIid, void\*\* ppvObj)
{
    ASSERT(nClsid == CLSID_CSpaceship);
    ASSERT((nIid == IID_IUnknown) || (nIid == IID_IClassFactory));
    return g_factory.ExternalQueryInterface(nIid, ppvObj);
    // Refcount is 2, which prevents accidental deletion
}

**Figure 24-3.** _The Spaceship.cpp file._

**CLIENT.CPP**

#include <stdio.h>
#include <stddef.h> // for offsetof in METHOD_PROLOGUE
#include <assert.h>
#include "interface.h"


//----------main program-----------------------------------------------
int main() // simulates OLE client program
{
    TRACE("Entering client main\n");
    IUnknown\* pUnk; // If you declare these void\*, you lose type-safety
    IMotion\* pMot;
    IVisual\* pVis;
    IClassFactory\* pClf; 
    
    GetClassObject(CLSID_CSpaceship, IID_IClassFactory,
                  (void\*\*) &pClf); 

    pClf->CreateInstance(IID_IUnknown, (void\*\*) &pUnk);
    pUnk->QueryInterface(IID_IMotion, (void\*\*) &pMot); // All three
    pMot->QueryInterface(IID_IVisual, (void\*\*) &pVis); //  pointers
                                                       //  should work

    TRACE("main: pUnk = %p, pMot = %p, pDis = %p\n", pUnk, pMot, pVis);
    
    // Test all the interface virtual functions
    pMot->Fly();
    int nPos = pMot->GetPosition();
    TRACE("nPos = %d\n", nPos);
    pVis->Display();

    pClf->Release();
    pUnk->Release();
    pMot->Release();
    pVis->Release();
    return 0;
}

**Figure 24-4.** _The Client.cpp file._
________________________________________________________________________
7.1.3. - [Real COM with the MFC Library](invcpp5/ch24d.htm)
----------------------------------------------------
 Real COM with the MFC Library 

**Real COM with the MFC Library**
=================================

So much for simulations. Now we'll get ready to convert the spaceship example to genuine COM. You need to acquire a little more knowledge before we start, though. First you must learn about the _CoGetClassObject_ function, then you must learn how COM uses the Windows Registry to load the component, and then you have to understand the difference between an in-process component (a DLL) and an out-of-process component (an EXE or a DLL running as a surrogate). Finally, you must become familiar with the MFC macros that support nested classes.

The net result will be an MFC regular DLL component that contains all the _CSpaceship_ code with the _IMotion_ and _IVisual_ interfaces. A regular MFC library Windows application acts as the client. It loads and runs the component when the user selects a menu item.

**The COM _CoGetClassObject_ Function**
---------------------------------------

In our simulation, we used a phony function named _GetClassObject_. In real COM, we use the global _CoGetClassObject_ function. (_Co_ stands for "component object.") Compare the following prototype to the _GetClassObject_ function you've seen already:

STDAPI CoGetClassObject(REFCLSID rclsid, DWORD dwClsContext,
    COSERVERINFO\* pServerInfo, REFIID riid, LPVOID\* ppvObj)

The interface pointer goes in the _ppvObj_ parameter, and _pServerInfo_ is a pointer to a machine on which the class object is instantiated (_NULL_ if the machine is local). The types _REFCLSID_ and _REFIID_ are references to 128-bit GUIDs (globally unique identifiers for COM classes and interfaces). STDAPI indicates that the function returns a 32-bit value of type _HRESULT_.

The standard GUIDs (for example, those GUIDs naming interfaces that Microsoft has already created) are defined in the Windows libraries that are dynamically linked to your program. GUIDs for custom classes and interfaces, such as those for spaceship objects, must be defined in your program in this way:

// {692D03A4-C689-11CE-B337-88EA36DE9E4E}
static const IID IID_IMotion =
    {0x692d03a4, 0xc689, 0x11ce, {0xb3, 0x37, 0x88, 0xea, 0x36, 
    0xde, 0x9e, 0x4e}};

If the _dwClsContext_ parameter is _CLSCTX_INPROC_SERVER_, the COM subsytem looks for a DLL. If the parameter is _CLSCTX_LOCAL_SERVER_, COM looks for an EXE. The two codes can be combined to select either a DLL or an EXE—selected in order of performance. For example, inproc servers are fastest because everybody shares the same address space. Communication EXE servers are considerably slower because the interprocess calls involve data copying as well as many thread context switches. The return value is an _HRESULT_ value, which is 0 (_NOERROR_) if no error occurs.

> NOTE
> 
> Another COM function, _CoCreateInstance_, combines the functionality of _CoGetClassObject_ and _IClassFactory::CreateInstance_.

**COM and the Windows Registry**
--------------------------------

In the EX24A example, the component was statically linked to the client, a clearly bogus circumstance. In real COM, the component is either a DLL or a separate EXE. When the client calls the _CoGetClassObject_ function, COM steps in and finds the correct component, which is located somewhere on disk. How does COM make the connection? It looks up the class's unique 128-bit class ID number in the Windows Registry. Thus, the class must be registered permanently on your computer.

If you run the Windows Regedit program (Regedt32 in Microsoft Windows NT 3.51), you'll see a screen similar to the one shown in Figure 24-5. This figure shows subfolders for four class IDs, three of which are class IDs associated with DLLs (InprocServer32) and one of which is a class ID associated with an EXE (LocalServer32). The _CoGetClassObject_ function looks up the class ID in the Registry and then loads the DLL or EXE as required.

What if you don't want to track those ugly class ID numbers in your client program? No problem. COM supports another type of registration database entry that translates a human-readable program ID into the corresponding class ID. Figure 24-6 shows the Registry entries. The COM function _CLSIDFromProgID_ reads the database and performs the translation.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f24og05x.gif)]

**Figure 24-5.** _Subfolders of four class IDs in the Registry._

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f24og06x.gif)]

**Figure 24-6.** _Human-readable program IDs in the Registry._

> NOTE
> 
> The first _CLSIDFromProgID_ parameter is a string that holds the program ID, but it's not an ordinary string. This is your first exposure to double-byte characters in COM. All string parameters of COM functions (except Data Access Objects [DAOs]) are Unicode character string pointers of type _OLECHAR\*._ Your life is going to be made miserable because of the constant need to convert between double-byte strings and ordinary strings. If you need a double-byte literal string, prefix the string with an _L_ character,
> 
> like this:
> 
> CLSIDFromProgID(L"Spaceship", &clsid);
> 
> You'll begin learning about the MFC library's Unicode string conversion capabilities in [Chapter 25](ch25a.htm).

How does the registration information get into the Registry? You can program your component application to call Windows functions that directly update the Registry. The MFC library conveniently wraps these functions with the function _COleObjectFactory::UpdateRegistryAll_, which finds all your program's global class factory objects and registers their names and class IDs.

**Runtime Object Registration**
-------------------------------

You've just seen how the Windows Registry registers COM classes on disk. Class factory objects also must be registered. It's unfortunate that the word "register" is used in both contexts. Objects in out-of-process component modules are registered at runtime with a call to the COM _CoRegisterClassObject_ function, and the registration information is maintained in memory by the Windows DLLs. If the factory is registered in a mode that permits a single instance of the component module to create multiple COM objects, COM can use an existing process when a client calls _CoGetClassObject_.

**How a COM Client Calls an In-Process Component**
--------------------------------------------------

We're beginning with a DLL component instead of an EXE component because the program interactions are simpler. I'll show pseudocode here because you're going to be using the MFC library classes, which hide much of the detail.

_Client_

> CLSID clsid;  
> IClassFactory\* pClf;  
> IUnknown\* pUnk;  
> CoInitialize(NULL);  // Initialize COM  
> CLSIDFromProgID("componentname", &clsid);

_COM_

> COM uses the Registry to look up the class ID from "componentname"

_Client_

> CoGetClassObject(clsid, CLSCTX_INPROC_SERVER, NULL,  
>      IID_IClassFactory, (void\*\*) &pClf );  

_COM_

> COM uses the class ID to look for a component in memory  
> if (component DLL is not loaded already) {  
>      COM gets DLL filename from the Registry  
>      COM loads the component DLL into process memory  
> }

_DLL Component_

> if (component just loaded) {  
>      Global factory objects are constructed  
>      DLL's InitInstance called (MFC only)  
> }  

_COM_

> COM calls DLL's global exported DllGetClassObject with the CLSID  
>      value that was passed to CoGetClassObject  

_DLL Component_

> DllGetClassObject returns IClassFactory\*

_COM_

> COM returns IClassFactory\* to client

_Client_

> pClf->CreateInstance (NULL, IID_IUnknown,  (void\*\*) &pUnk);

_DLL Component_

> Class factory's CreateInstance function called (called directly—through  
>      component's vtable)  
> Constructs object of "componentname" class  
> Returns requested interface pointer  

_Client_

> pClf->Release();  
> pUnk->Release();  

_DLL Component_

> "componentname" Release is called through vtable  
>      if (refcount == 0) {  
>      Object destroys itself  
> }  

_Client_

> CoFreeUnusedLibraries();

_COM_

> COM calls DLL's global exported DllCanUnloadNow

_DLL Component_

> DllCanUnloadNow called if (all DLL's objects destroyed) {  
>      return TRUE  
> }  

_Client_

> CoUninitialize();  // COM frees the DLL if DllCanUnloadNow returns  
>      TRUE just prior to exit  

_COM_

> COM releases resources

_Client_

> Client exits

_DLL Component_

> Windows unloads the DLL if it is still loaded and no other programs are using it

Some important points to note: first, the DLL's exported _DllGetClassObject_ function is called in response to the client's _CoGetClassObject_ call. Second, the class factory interface address returned is the actual physical address of the class factory vtable pointer in the DLL. Third, when the client calls _CreateInstance_, or any other interface function, the call is direct (through the component's vtable).

The COM linkage between a client EXE and a component DLL is quite efficient—as efficient as the linkage to any C++ virtual function in the same process, plus the full C++ parameter and return type-checking at compile time. The only penalty for using ordinary DLL linkage is the extra step of looking up the class ID in the Registry when the DLL is first loaded.

**How a COM Client Calls an Out-of-Process Component**
------------------------------------------------------

The COM linkage to a separate EXE component is more complicated than the linkage to a DLL component. The EXE component is in a different process, or possibly on a different computer. Don't worry, though. Write your programs as if a direct connection existed. COM takes care of the details through its remoting architecture, which usually involves Remote Procedure Calls (RPCs).

In an RPC, the client makes calls to a special DLL called a proxy. The proxy sends a stream of data to a stub, which is inside a DLL in the component's process. When the client calls a component function, the proxy alerts the stub by sending a message to the component program, which is processed by a hidden window. The mechanism of converting parameters to and from data streams is called marshaling.

If you use standard interfaces (those interfaces defined by Microsoft) such as _IClassFactory_ and _IPersist_ (an interface we haven't seen yet but will appear when we examine COM persistence), the proxy and stub code, which implements marshaling, is provided by the Windows OLE32 DLL. If you invent your own interfaces, such as _IMotion_ and _IVisual_, you need to write the proxies and stubs yourself. Fortunately, creating proxy and stub classes only involves defining your interfaces in Interface Definition Language (IDL) and compiling the code produced by the Microsoft Interface Definition Language (MIDL) compiler.

Here's the pseudocode interaction between an EXE client and an EXE component. Compare it to the DLL version found above. Notice that the client-side calls are exactly the same.

_Client_

> CLSID clsid;  
> IClassFactory\* pClf;  
> IUnknown\* pUnk;  
> CoInitialize(NULL);  // Initialize COM  
> CLSIDFromProgID("componentname", &clsid);  

_COM_

> COM uses the Registry to look up the class ID from "componentname"

_Client_

> CoGetClassObject(clsid, CLSCTX_LOCAL_SERVER, NULL,  
>      IID_IClassFactory, (void\*\*) &pClf);  

_COM_

> COM uses the class ID to look for a component in memory  
>      if (component EXE is not loaded already, or  
>      if we need another instance) {  
>      COM gets EXE filename from the Registry  
>      COM loads the component EXE  
> }  

_EXE Component_

> if (just loaded) {  
>      Global factory objects are constructed  
>      InitInstance called (MFC only)  
>      CoInitialize(NULL);  
>      for each factory object {  
>           CoRegisterClassObject(...);  
>           Returns IClassFactory\* to COM  
>           }  
>      }  

_COM_

> COM returns the requested interface pointer to the client  
>      (client's pointer is not the same as the component's interface pointer)

_Client_

> pClf->CreateInstance(NULL, IID_IUnknown, (void\*\*) &pUnk);

_EXE Component_

> Class factory's CreateInstance function called  
>      (called indirectly through marshaling)  
>      Constructs object of "componentname" class  
>      Returns requested interface pointer indirectly  

_Client_

> pClf->Release();  
> pUnk->Release();  

_EXE Component_

> "componentname" Release is called indirectly  
> if (refcount == 0) {  
>      Object destroys itself  
> }  
> if (all objects released) {  
>      Component exits gracefully  
> }  

_Client_

> CoUninitialize();  // just prior to exit

_COM_

> COM calls Release for any objects this client has failed to release

_EXE Component_

> Component exits

_COM_

> COM releases resources

_Client_

> Client exits

As you can see, COM plays an important role in the communication between the client and the component. COM keeps an in-memory list of class factories that are in active EXE components, but it does not keep track of individual COM objects such as the _CSpaceship_ object. Individual COM objects are responsible for updating the reference count and for destroying themselves through the _AddRef/Release_ mechanism. COM does step in when a client exits. If that client is using an out-of-process component, COM "listens in" on the communication and keeps track of the reference count on each object. COM disconnects from component objects when the client exits. Under certain circumstances, this causes those objects to be released. Don't depend on this behavior, however. Be sure that your client program releases all its interface pointers prior to exiting.

**The MFC Interface Macros**
----------------------------

In EX24A, you saw nested classes used for interface implementation. The MFC library has a set of macros that automate this process. For the _CSpaceship_ class, derived from the real MFC _CCmdTarget_ class, you use the macros shown here inside the declaration.

BEGIN_INTERFACE_PART(Motion, IMotion)
    STDMETHOD_(void, Fly) ();
    STDMETHOD_(int&, GetPosition) ();
END_INTERFACE_PART(Motion)

BEGIN_INTERFACE_PART(Visual, IVisual)
    STDMETHOD_(void, Display) ();
END_INTERFACE_PART(Visual)

DECLARE_INTERFACE_MAP()

The _INTERFACE_PART_ macros generate the nested classes, adding _X_ to the first parameter to form the class name and adding _m_x_ to form the embedded object name. The macros generate prototypes for the specified interface functions plus prototypes for _QueryInterface_, _AddRef_, and _Release_.

The _DECLARE_INTERFACE_MAP_ macro generates the declarations for a table that holds the IDs of all the class's interfaces. The _CCmdTarget::ExternalQueryInterface_ function uses the table to retrieve the interface pointers.

In the _CSpaceship_ implementation file, use the following macros:

BEGIN_INTERFACE_MAP(CSpaceship, CCmdTarget)
    INTERFACE_PART(CSpaceship, IID_IMotion, Motion)
    INTERFACE_PART(CSpaceship, IID_IVisual, Visual)
END_INTERFACE_MAP()

These macros build the interface table used by _CCmdTarget::ExternalQueryInterface_. A typical interface member function looks like this:

STDMETHODIMP_(void) CSpaceship::XMotion::Fly()
{
    METHOD_PROLOGUE(CSpaceship, Motion)
    pThis->m_nPosition += 10;
    return;
}

Don't forget that you must implement all the functions for each interface, including _QueryInterface_, _AddRef_, and _Release._ Those three functions can delegate to functions in _CCmdTarget_.

> NOTE
> 
> The _STDMETHOD__ and _STDMETHODIMP__ macros declare and implement functions with the ___stdcall_ parameter passing convention, as required by COM. These macros allow you to specify the return value as the first parameter. Two other macros, _STDMETHOD_ and _STDMETHODIMP_, assume an _HRESULT_ return value.

**The MFC _COleObjectFactory_ Class**
-------------------------------------

In the simulated COM example, you saw a _CSpaceshipFactory_ class that was hard-coded to generate _CSpaceship_ objects. The MFC library applies its dynamic creation technology to the problem. Thus, a single class, aptly named _COleObjectFactory_, can create objects of any class specified at runtime. All you need to do is use macros like these in the class declaration:

DECLARE_DYNCREATE(CSpaceship)
DECLARE_OLECREATE(CSpaceship)

And use macros like these in the implementation file:

IMPLEMENT_DYNCREATE(CSpaceship, CCmdTarget)
// {692D03A3-C689-11CE-B337-88EA36DE9E4E}
IMPLEMENT_OLECREATE(CSpaceship, "Spaceship", 0x692d03a3, 0xc689, 0x11ce,
    0xb3, 0x37, 0x88, 0xea, 0x36, 0xde, 0x9e, 0x4e)

The _DYNCREATE_ macros set up the standard dynamic creation mechanism as described in [Appendix B](chaba.htm). The _OLECREATE_ macros declare and define a global object of class _COleObjectFactory_ with the specified unique CLSID. In a DLL component, the exported _DllGetClassObject_ function finds the specified class factory object and returns a pointer to it based on global variables set by the _OLECREATE_ macros. In an EXE component, initialization code calls the static _COleObjectFactory::RegisterAll_, which finds all factory objects and registers each one by calling _CoRegisterClassObject_. The _RegisterAll_ function is called also when a DLL is initialized. In that case, it merely sets a flag in the factory object(s).

We've really just scratched the surface of MFC's COM support. If you need more details, be sure to refer to Shepherd and Wingo's _MFC Internals_ (Addison-Wesley, 1996).

**AppWizard/ClassWizard Support for COM In-Process Components**
---------------------------------------------------------------

AppWizard isn't optimized for creating COM DLL components, but you can fool it by requesting a regular DLL with Automation support. The following functions in the project's main source file are of interest:

BOOL CEx24bApp::InitInstance()
{
    COleObjectFactory::RegisterAll();
    return TRUE;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID\* ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return AfxDllGetClassObject(rclsid, riid, ppv);
}

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModule_State());
    return AfxDllCanUnloadNow();
}

STDAPI DllRegisterServer(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    COleObjectFactory::UpdateRegistryAll();
    return S_OK;
}

The three global functions are exported in the project's DEF file. By calling MFC functions, the global functions do everything you need in a COM in-process component. The _DllRegisterServer_ function can be called by a utility program to update the system Registry.

Once you've created the skeleton project, your next step is to use ClassWizard to add one or more COM-creatable classes to the project. Just fill in the New Class dialog box, as shown here.

![](c:/dl/books/windows/msvc5th/invcpp5/images/g24og04.gif)

In your generated class, you end up with some Automation elements such as dispatch maps, but you can safely remove those. You can also remove the following two lines from StdAfx.h:

#include <afxodlgs.h>
#include <afxdisp.h>

**MFC COM Client Programs**
---------------------------

Writing an MFC COM client program is a no-brainer. You just use AppWizard to generate a normal application. Add the following line in StdAfx.h:

#include <afxole.h>

Then add the following line at the beginning of the application class _InitInstance_ member function:

AfxOleInit();

You're now ready to add code that calls _CoGetClassObject_.

**The EX24B Example—An MFC COM In-Process Component**
-----------------------------------------------------

The EX24B example is an MFC regular DLL that incorporates a true COM version of the _CSpaceship_ class you saw in EX24A. AppWizard generated the ex24b.cpp and ex24b.h files, as described previously. Figure 24-7 shows the Interface.h file, which declares the _IMotion_ and _IVisual_ interfaces. Figures 24-8 and 24-9 show the code for the _CSpaceship_ class. Compare the code to the code in EX24A. Do you see how the use of the MFC macros reduces code size? Note that the MFC _CCmdTarget_ class takes care of the reference counting and _QueryInterface_ logic.

**INTERFACE.H**

struct IMotion : public IUnknown
{
    STDMETHOD_(void, Fly) () = 0;
    STDMETHOD_(int&, GetPosition) () = 0;
};

struct IVisual : public IUnknown
{
    STDMETHOD_(void, Display) () = 0;
};

**Figure 24-7.** _The Interface.h file._ ,

**SPACESHIP.H**

void ITrace(REFIID iid, const char\* str);

//////////////////////////////////////////////////////////////////////
// CSpaceship command target

class CSpaceship : public CCmdTarget
{
    DECLARE_DYNCREATE(CSpaceship)

private:
    int m_nPosition; // We can access this from all the interfaces
    int m_nAcceleration;
    int m_nColor;
protected:
    CSpaceship();    // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSpaceship)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

// Implementation
protected:    
    virtual ~CSpaceship();

    // Generated message map functions
    //{{AFX_MSG(CSpaceship)
        // NOTE - the ClassWizard will add and remove member 
        //  functions here.
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
    DECLARE_OLECREATE(CSpaceship)
    BEGIN_INTERFACE_PART(Motion, IMotion)
        STDMETHOD_(void, Fly) ();

        STDMETHOD_(int&, GetPosition) ();
    END_INTERFACE_PART(Motion)

    BEGIN_INTERFACE_PART(Visual, IVisual)
        STDMETHOD_(void, Display) ();
    END_INTERFACE_PART(Visual)

    DECLARE_INTERFACE_MAP()
};
//////////////////////////////////////////////////////////////////////

**Figure 24-8.** _The Spaceship.h file._

**SPACESHIP.CPP**

#include "stdAfx.h"
#include "ex24b.h"
#include "Interface.h"
#include "Spaceship.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE
__;
#endif
//////////////////////////////////////////////////////////////////////
// CSpaceship

// {692D03A4-C689-11CE-B337-88EA36DE9E4E}
static const IID IID_IMotion =
{ 0x692d03a4, 0xc689, 0x11ce,
    { 0xb3, 0x37, 0x88, 0xea, 0x36, 0xde, 0x9e, 0x4e } };

// {692D03A5-C689-11CE-B337-88EA36DE9E4E}
static const IID IID_IVisual =
{ 0x692d03a5, 0xc689, 0x11ce,
    { 0xb3, 0x37, 0x88, 0xea, 0x36, 0xde, 0x9e, 0x4e } };

IMPLEMENT_DYNCREATE(CSpaceship, CCmdTarget)
CSpaceship::CSpaceship()
{
    TRACE("CSpaceship ctor\n");
    m_nPosition = 100;
    m_nAcceleration = 101;
    m_nColor = 102;
    // To keep the application running as long as an OLE automation
    //  object is active, the constructor calls AfxOleLockApp.

    AfxOleLockApp();
}

CSpaceship::~CSpaceship()
{
    TRACE("CSpaceship dtor\n");
    // To terminate the application when all objects created with
    //  OLE automation, the destructor calls AfxOleUnlockApp.
    
    AfxOleUnlockApp();
}
void CSpaceship::OnFinalRelease()
{
    // When the last reference for an automation object is released
    //  OnFinalRelease is called. This implementation deletes the 
    //  object. Add additional cleanup required for your object before
    //  deleting it from memory.

    delete this;
}
BEGIN_MESSAGE_MAP(CSpaceship, CCmdTarget)
    //{{AFX_MSG_MAP(CSpaceship)
    // NOTE - ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_INTERFACE_MAP(CSpaceship, CCmdTarget)
    INTERFACE_PART(CSpaceship, IID_IMotion, Motion)
    INTERFACE_PART(CSpaceship, IID_IVisual, Visual)
END_INTERFACE_MAP()

// {692D03A3-C689-11CE-B337-88EA36DE9E4E}
IMPLEMENT_OLECREATE(CSpaceship, "Spaceship", 0x692d03a3, 0xc689,
                    0x11ce, 0xb3, 0x37, 0x88, 0xea, 0x36, 0xde,
                    0x9e, 0x4e)
STDMETHODIMP_(ULONG) CSpaceship::XMotion::AddRef()
{
    TRACE("CSpaceship::XMotion::AddRef\n");
    METHOD_PROLOGUE(CSpaceship, Motion)
    return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CSpaceship::XMotion::Release()
{
    TRACE("CSpaceship::XMotion::Release\n");
    METHOD_PROLOGUE(CSpaceship, Motion)
    return pThis->ExternalRelease();
}

STDMETHODIMP CSpaceship::XMotion::QueryInterface(
    REFIID iid, LPVOID\* ppvObj)
{
    ITrace(iid, "CSpaceship::XMotion::QueryInterface");
    METHOD_PROLOGUE(CSpaceship, Motion)
    return pThis->ExternalQueryInterface(&iid, ppvObj);
}
STDMETHODIMP_(void) CSpaceship::XMotion::Fly()
{
    TRACE("CSpaceship::XMotion::Fly\n");
    METHOD_PROLOGUE(CSpaceship, Motion)
    TRACE("m_nPosition = %d\n", pThis->m_nPosition);
    TRACE("m_nAcceleration = %d\n", pThis->m_nAcceleration);
    return;
}

STDMETHODIMP_(int&) CSpaceship::XMotion::GetPosition()
{
    TRACE("CSpaceship::XMotion::GetPosition\n");
    METHOD_PROLOGUE(CSpaceship, Motion)
    TRACE("m_nPosition = %d\n", pThis->m_nPosition);
    TRACE("m_nAcceleration = %d\n", pThis->m_nAcceleration);
    return pThis->m_nPosition;
}

//////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CSpaceship::XVisual::AddRef()
{
    TRACE("CSpaceship::XVisual::AddRef\n");
    METHOD_PROLOGUE(CSpaceship, Visual)
    return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CSpaceship::XVisual::Release()
{
    TRACE("CSpaceship::XVisual::Release\n");
    METHOD_PROLOGUE(CSpaceship, Visual)
    return pThis->ExternalRelease();
}

STDMETHODIMP CSpaceship::XVisual::QueryInterface(
    REFIID iid, LPVOID\* ppvObj)
{
    ITrace(iid, "CSpaceship::XVisual::QueryInterface");

    METHOD_PROLOGUE(CSpaceship, Visual)
    return pThis->ExternalQueryInterface(&iid, ppvObj);
}
STDMETHODIMP_(void) CSpaceship::XVisual::Display()
{
    TRACE("CSpaceship::XVisual::Display\n");
    METHOD_PROLOGUE(CSpaceship, Visual)
    TRACE("m_nPosition = %d\n", pThis->m_nPosition);
    TRACE("m_nColor = %d\n", pThis->m_nColor);
}

//////////////////////////////////////////////////////////////////////
void ITrace(REFIID iid, const char\* str)
{
    OLECHAR\* lpszIID;
    ::StringFromIID(iid, &lpszIID);
    CString strTemp = (LPCWSTR) lpszIID;
    TRACE("%s - %s\n", (const char\*) strTemp, (const char\*) str);
    AfxFreeTaskMem(lpszIID);
}

//////////////////////////////////////////////////////////////////////
// CSpaceship message handlers

**Figure 24-9.** _The Spaceship.cpp file._

**The EX24C Example—An MFC COM Client**
---------------------------------------

The EX24C example is an MFC program that incorporates a true COM version of the client code you saw in EX24A. This is a generic AppWizard MFC Single Document Interface (SDI) EXE program with an added _#include_ statement for the MFC COM headers and a call to _AfxOleInit_, which initializes the DLL. A Spaceship option on an added Test menu is mapped to the view class handler function shown in Figure 24-10. The project also contains a copy of the EX24B component's Interface.h file, shown in Figure 24-7. You can see an _#include_ statement for this file at the top of ex24cView.cpp.

void CEx24cView::OnTestSpaceship() 
{
    CLSID clsid;
    LPCLASSFACTORY pClf; 
    LPUNKNOWN pUnk;
    IMotion\* pMot;
    IVisual\* pVis;

    HRESULT hr;
    if ((hr = ::CLSIDFromProgID(L"Spaceship", &clsid)) != NOERROR) {
        TRACE("unable to find Program ID -- error = %x\n", hr);
        return;
    }
    if ((hr = ::CoGetClassObject(clsid, CLSCTX_INPROC_SERVER,
        NULL, IID_IClassFactory, (void \*\*) &pClf)) != NOERROR) {;
        TRACE("unable to find CLSID -- error = %x\n", hr);
        return;
    }

    pClf->CreateInstance(NULL, IID_IUnknown, (void\*\*) &pUnk);
    pUnk->QueryInterface(IID_IMotion, (void\*\*) &pMot); // All three
    pMot->QueryInterface(IID_IVisual, (void\*\*) &pVis); //  pointers
                                                       //  should work
    TRACE("main: pUnk = %p, pMot = %p, pDis = %p\n", pUnk, pMot, pVis);

    // Test all the interface virtual functions
    pMot->Fly();
    int nPos = pMot->GetPosition();
    TRACE("nPos = %d\n", nPos);
    pVis->Display();

    pClf->Release();
    pUnk->Release();
    pMot->Release();
    pVis->Release();
    AfxMessageBox("Test succeeded. See Debug window for output.");
}

**Figure 24-10.** _The client's command handler that loads and tests the_ CSpaceship _component._

To test the client and the component, you must first run the component to update the Registry. Several utilities can be used to do this, but you might want to try the REGCOMP program in the \vcpp32\RegComp project on the companion CD-ROM. This program prompts you to select a DLL or an OCX file, and then it calls the exported _DllRegisterServer_ function.

Both client and component show their progress through _TRACE_ calls, so you need the debugger. You can run either the client or the component from the debugger. If you try to run the component, you'll be prompted for the client pathname. In either case, you don't have to copy the DLL because Windows finds it through the Registry.
________________________________________________________________________
7.1.4. - [Containment and Aggregation vs. Inheritance](invcpp5/ch24e.htm)
----------------------------------------------------
 Containment and Aggregation vs. Inheritance 

**Containment and Aggregation vs. Inheritance**
===============================================

In normal C++ programming, you frequently use inheritance to factor out common behavior into a reusable base class. The _CPersistentFrame_ class (discussed in [Chapter 15](ch15a.htm)) is an example of reusability through inheritance.

COM uses containment and aggregation instead of inheritance. Let's start with containment. Suppose you extended the spaceship simulation to include planets in addition to spaceships. Using C++ by itself, you would probably write a _COrbiter_ base class that encapsulated the laws of planetary motion. With COM, you would have "outer" _CSpaceship_ and _CPlanet_ classes plus an "inner" _COrbiter_ class. The outer classes would implement the _IVisual_ interface directly, but those outer classes would delegate their _IMotion_ interfaces to the inner class. The result would look something like this.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g24og05x.gif)]

Note that the _COrbiter_ object doesn't know that it's inside a _CSpaceship_ or _CPlanet_ object, but the outer object certainly knows that it has a _COrbiter_ object embedded inside. The outer class needs to implement all its interface functions, but the _IMotion_ functions, including _QueryInterface_, simply call the same _IMotion_ functions of the inner class.

A more complex alternative to containment is aggregation. With aggregation, the client can have direct access to the inner object's interfaces. Shown here is the aggregation version of the space simulation.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g24og06x.gif)]

The orbiter is embedded in the spaceship and planet, just as it was in the containment case. Suppose the client obtains an _IVisual_ pointer for a spaceship and then calls _QueryInterface_ for an _IMotion_ pointer. Using the outer _IUnknown_ pointer will draw a blank because the _CSpaceship_ class doesn't support _IMotion_. The _CSpaceship_ class keeps track of the inner _IUnknown_ pointer (of its embedded _COrbiter_ object), so the class uses that pointer to obtain the _IMotion_ pointer for the _COrbiter_ object.

Now suppose the client obtains an _IMotion_ pointer and then calls _QueryInterface_ for _IVisual._ The inner object must be able to navigate to the outer object, but how? Take a close look at the _CreateInstance_ call back in Figure 24-10. The first parameter is set to _NULL_ in that case. If you are creating an aggregated (inner) object, you use that parameter to pass an _IUnknown_ pointer for the outer object that you have already created. This pointer is called the controlling unknown. The _COrbiter_ class saves this pointer in a data member and then uses it to call _QueryInterface_ for interfaces that the class itself doesn't support.

The MFC library supports aggregation. The _CCmdTarget_ class has a public data member _m_pOuterUnknown_ that holds the outer object's _IUnknown_ pointer (if the object is aggregated). The _CCmdTarget_ member functions _ExternalQueryInterface_, _ExternalAddRef_, and _ExternalRelease_ delegate to the outer _IUnknown_ if it exists. Member functions _InternalQueryInterface_, _InternalAddRef_, and _InternalRelease_ do not delegate. See Technical Note #38 in the online documentation for a description of the MFC macros that support aggregation.
________________________________________________________________________
7.2. - [Chapter 25 -- Automation](invcpp5/ch25a.htm)
----------------------------------------------------
 Chapter 25 -- Automation  Chapter 25

Automation
==========

After reading [Chapter 24](ch24a.htm), you should know what an interface is; you've already seen two standard COM interfaces, _IUnknown_ and _IClassFactory_. Now you're ready for "applied" COM, or at least one aspect of it—Automation (formerly known as OLE Automation). You'll learn about the COM _IDispatch_ interface, which enables C++ programs to communicate with Microsoft Visual Basic for Applications (VBA) programs and with programs written in other scripting languages. In addition, _IDispatch_ is the key to getting your COM object onto a Web page. You'll use the MFC library implementation of _IDispatch_ to write C++ Automation component and client programs. Both out-of-process components and in-process components are explored.

But before jumping into C++ Automation programming, you need to know how the rest of the world writes programs. In this chapter, you'll get some exposure to VBA as it is implemented in Microsoft Excel. You'll run your C++ components from Excel, and you'll run Excel from a C++ client program.
________________________________________________________________________
7.2.1. - [Connecting C++ with Visual Basic for Applications](invcpp5/ch25b.htm)
----------------------------------------------------
 Connecting C++ with Visual Basic for Applications 

**Connecting C++ with Visual Basic for Applications**
=====================================================

Not all programmers for Microsoft Windows-based applications are going to be C++ programmers, especially if they have to learn the intricacies of COM theory. If you've been paying attention over the last few years, you've probably noticed a trend in which C++ programmers produce reusable modules. Programmers using higher-level languages (Visual Basic, VBA, and Web scripting languages, for example) consume those modules by integrating them into applications. You can participate in this programming model by learning how to make your software Script-friendly. Automation is one tool available now that is supported by the Microsoft Foundation Class library. ActiveX Controls are another tool for C++/VBA integration and are very much a superset of Automation because both tools use the _IDispatch_ interface. Using ActiveX Controls, however, might be overkill in many situations. Many applications, including Microsoft Excel 97, can support both Automation components and ActiveX controls. You'll be able to apply all that you learn about Automation when you write and use ActiveX controls.

Two factors are responsible for Automation's success. First, VBA (or VB Script) is now the programming standard in most Microsoft applications, including Microsoft Word, Microsoft Access, and Excel, not to mention Microsoft Visual Basic itself. All these applications support Automation, which means they can be linked to other Automation-compatible components, including those written in C++ and VBA. For example, you can write a C++ program that uses the text-processing capability of Word, or you can write a C++ matrix inversion component that can be called from a VBA macro in an Excel worksheet.

The second factor connected to Automation's success is that dozens of software companies provide Automation programming interfaces for their applications, mostly for the benefit of VBA programmers. With a little effort, you can run these applications from C++. You can, for example, write an MFC program that controls Shapeware's Visio drawing program.

Automation isn't just for C++ and VBA programmers. Software-tool companies are already announcing Automation-compatible, Basic-like languages that you can license for your own programmable applications. One version of Smalltalk even supports Automation.
________________________________________________________________________
7.2.2. - [Automation Clients and Automation Components](invcpp5/ch25c.htm)
----------------------------------------------------
 Automation Clients and Automation Components 

**Automation Clients and Automation Components**
================================================

A clearly defined "master-slave" relationship is always present in an Automation communication dialog. The master is the Automation client and the slave is the Automation component (server). The client initiates the interaction by constructing a component object (it might have to load the component program) or by attaching to an existing object in a component program that is already running. The client then calls interface functions in the component and releases those interfaces when it's finished.

Here are some interaction scenarios:

*   A C++ Automation client uses a Microsoft or third-party application as a component. The interaction could trigger the execution of VBA code in the component application.
    
*   A C++ Automation component is used from inside a Microsoft application (or a Visual Basic application), which acts as the Automation client. Thus, VBA code can construct and use C++ objects.
    
*   A C++ Automation client uses a C++ Automation component.
    
*   A Visual Basic program uses an Automation-aware application such as Excel. In this case, Visual Basic is the client and Excel is the component.
________________________________________________________________________
7.2.3. - [Microsoft Excel -- A BetterVisual Basic than Visual Basic](invcpp5/ch25d.htm)
----------------------------------------------------
 Microsoft Excel -- A Better Visual Basic than Visual Basic 

**Microsoft Excel—A Better Visual Basic than Visual Basic**
===========================================================

At the time that the first three editions of this book were written, Visual Basic worked as an Automation client, but you couldn't use it to create an Automation component. Since version 5.0, Visual Basic lets you write components too, even ActiveX controls. We originally used Excel instead of VB because Excel was the first Microsoft application to support VBA syntax and it could serve as both a client and a component. We decided to stick with Excel because C++ programmers who look down their noses at Visual Basic might be inclined to buy Excel (if only to track their software royalties).

We strongly recommend that you get a copy of Excel 97 (or a later version). This is a true 32-bit application and a part of the Microsoft Office suite. With this version of Excel, you can write VBA code in a separate location that accesses worksheet cells in an object-oriented manner. Adding visual programming elements—such as pushbuttons—is easy. Forget all you ever knew about the old spreadsheet programs that forced you to wedge macro code inside cells.

This chapter isn't meant to be an Excel tutorial, but we've included a simple Excel workbook. (A workbook is a file that can contain multiple worksheets plus separate VBA code.) This workbook demonstrates a VBA macro that executes from a pushbutton. You can use Excel to load Demo.xls from the \vcpp32\ex25a subdirectory, or you can key in the example from scratch. Figure 25-1 shows the actual spreadsheet with the button and sample data.

In this spreadsheet, you highlight cells A4 through A9 and click the Process Col button. A VBA program iterates down the column and draws a hatched pattern on cells with numeric values greater than 10.

Figure 25-2 shows the macro code itself, which is "behind" the worksheet. In Excel 97, choose Macro from the Tools menu, and then choose Visual Basic Editor. (Alt-F11 is the shortcut.) As you can see, you're working in the standard VBA 5.0 environment at this point.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F25og01x.gif)]

**Figure 25-1.** _An Excel spreadsheet that uses VBA code._

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f25og02x.gif)]

**Figure 25-2.** _The VBA code for the Excel spreadsheet._

If you want to create the example yourself, follow these steps:

2.  Start Excel with a new workbook, press Alt-F11, and then double-click Sheet1 in the top left window.
    
3.  Type in the macro code shown in Figure 25-2.
    
4.  Return to the Excel window by choosing Close And Return To Microsoft Excel from the File menu. Choose Toolbars from the View menu. Check Forms to display the Forms toolbar. (You can also access the list of toolbars by right-clicking on any existing toolbar.)
    
5.  Click the Button control, and then create the pushbutton by dragging the mouse in the upper-left corner of the worksheet. Assign the button to the _Sheet1.ProcessColumn_ macro.
    
6.  Size the pushbutton, and type the caption _Process Col_, as shown in Figure 25-1.
    
7.  Type some numbers in the column starting at cell A4. Select the cells containing these numbers, and then click the button to test the program.

Pretty easy, isn't it?

Let's analyze an Excel VBA statement from the macro above:

Selection.Offset(1, 0).Range("A1").Select

The first element, Selection, is a property of an implied object, the Excel application. The Selection property in this case is assumed to be a _Range_ object that represents a rectangular array of cells. The second element, Offset, is a property of the _Range_ object that returns another _Range_ object based on the two parameters. In this case, the returned _Range_ object is the one-cell range that begins one row down from the original range. The third element, Range, is a property of the _Range_ object that returns yet another range. This time it's the upper-left cell in the second range. Finally, the _Select_ method causes Excel to highlight the selected cell and makes it the new Selection property of the application.

As the program iterates through the loop, the preceding statement moves the selected cell down the worksheet one row at a time. This style of programming takes some getting used to, but you can't afford to ignore it. The real value here is that you now have all the capabilities of the Excel spreadsheet and graphics engine available to you in a seamless programming environment.
________________________________________________________________________
7.2.4. - [Properties, Methods, and Collections](invcpp5/ch25e.htm)
----------------------------------------------------
 Properties, Methods, and Collections 

**Properties, Methods, and Collections**
========================================

The distinction between a property and a method is somewhat artificial. Basically, a property is a value that can be both set and retrieved. You can, for example, set and get the Selection property for an Excel application. Another example is Excel's Width property, which applies to many object types. Some Excel properties are read-only; most are read/write.

Properties don't officially have parameters, but some properties are indexed. The property index acts a lot like a parameter. It doesn't have to be an integer, and it can have more than one element (row and column, for example). You'll find many indexed properties in Excel's object model, and Excel VBA can handle indexed properties in Automation components.

Methods are more flexible than properties. They can have zero or many parameters, and they can either set or retrieve object data. Most frequently they perform some action, such as showing a window. Excel's _Select_ method is an example of an action method.

The Excel object model supports collection objects. If you use the Worksheets property of the _Application_ object, you get back a _Sheets_ collection object, which represents all the worksheets in the active workbook. You can use the Item property (with an integer index) to get a specific _Worksheet_ object from a Sheets collection, or you can use an integer index directly on the collection.
________________________________________________________________________
7.2.5. - [The Problem That Automation Solves](invcpp5/ch25f.htm)
----------------------------------------------------
 The Problem That Automation Solves 

**The Problem That Automation Solves**
======================================

You've already learned that a COM interface is the ideal way for Windows programs to communicate with one another, but you've also learned that designing your own COM interfaces is mostly impractical. Automation's general-purpose interface, _IDispatch_, serves the needs of both C++ and VBA programmers. As you might guess from your glimpse of Excel VBA, this interface involves objects, methods, and properties.

You can write COM interfaces that include functions with any parameter types and return values you specify. _IMotion_ and _IVisual_, created in [Chapter 24](ch24a.htm), are some examples. If you're going to let VBA programmers in, however, you can't be fast and loose anymore. You can solve the communication problem with one interface that has a member function smart enough to accommodate methods and properties as defined by VBA. Needless to say, _IDispatch_ has such a function: _Invoke_. You use _IDispatch::Invoke_ for COM objects that can be constructed and used in either C++ or VBA programs.

Now you're beginning to see what Automation does. It funnels all intermodule communication through the _IDispatch::Invoke_ function. How does a client first connect to its component? Because _IDispatch_ is merely another COM interface, all the registration logic supported by COM comes into play. Automation components can be DLLs or EXEs, and they can be accessed over a network using distributed COM (DCOM).
________________________________________________________________________
7.2.6. - [The IDispatch Interface](invcpp5/ch25g.htm)
----------------------------------------------------
 The IDispatch Interface 

**The _IDispatch_ Interface**
=============================

_IDispatch_ is the heart of Automation. It's fully supported by COM marshaling (that is, Microsoft has already marshaled it for you), as are all the other standard COM interfaces, and it's supported well by the MFC library. At the component end, you need a COM class with an _IDispatch_ interface (plus the prerequisite class factory, of course). At the client end, you use standard COM techniques to obtain an _IDispatch_ pointer. (As you'll see, the MFC library and the wizards take care of a lot of these details for you.)

Remember that _Invoke_ is the principal member function of _IDispatch_. If you looked up _IDispatch::Invoke_ in the Visual C++ online documentation, you'd see a really ugly set of parameters. Don't worry about those now. The MFC library steps in on both sides of the _Invoke_ call, using a data-driven scheme to call component functions based on dispatch map parameters that you define with macros.

_Invoke_ isn't the only _IDispatch_ member function. Another function your controller might call is _GetIDsOfNames_. From the VBA programmer's point of view, properties and methods have symbolic names, but C++ programmers prefer more efficient integer indexes. _Invoke_ uses integers to specify properties and methods, so _GetIDsOfNames_ is useful at the start of a program for converting each name to a number if you don't know the index numbers at compile time. You've already seen that _IDispatch_ supports symbolic names for methods. In addition, the interface supports symbolic names for a method's parameters. The _GetIDsOfNames_ function returns those parameter names along with the method name. Unfortunately, the MFC _IDispatch_ implementation doesn't support named parameters.
________________________________________________________________________
7.2.7. - [Automation Programming Choices](invcpp5/ch25h.htm)
----------------------------------------------------
 Automation Programming Choices 

**Automation Programming Choices**
==================================

Suppose you're writing an Automation component in C++. You've got some choices to make. Do you want an in-process component or an out-of-process component? What kind of user interface do you want? Does the component need a user interface at all? Can users run your EXE component as a stand-alone application? If the component is an EXE, will it be SDI or MDI? Can the user shut down the component program directly?

If your component is a DLL, COM linkage will be more efficient than it would be with an EXE component because no marshaling is required. Most of the time, your in-process Automation components won't have their own user interfaces, except for modal dialog boxes. If you need a component that manages its own child window, you should use an ActiveX control, and if you want to use a main frame window, use an out-of-process component. As with any 32-bit DLL, an Automation DLL is mapped into the client's process memory. If two client programs happen to request the same DLL, Windows loads and links the DLL twice. Each client is unaware that the other is using the same component.

With an EXE component, however, you must be careful to distinguish between a component program and a component object. When a client calls _IClassFactory::CreateInstance_ to construct a component object, the component's class factory constructs the object, but COM might or might not need to start the component program.

Here are some scenarios:

2.  The component's COM-creatable class is programmed to require a new process for each object constructed. In this case, COM starts a new process in response to the second and subsequent _CreateInstance_ calls, each of which returns an _IDispatch_ pointer.
    
3.  Here's a special case of scenario 1 above, specific to MFC applications. The component class is an MFC document class in an SDI application. Each time a client calls _CreateInstance_, a new component process starts, complete with a document object, a view object, and an SDI main frame window.
    
4.  The component class is programmed to allow multiple objects in a single process. Each time a client calls _CreateInstance_, a new component object is constructed. There is only one component process, however.
    
5.  Here's a special case of scenario 3 above, specific to MFC applications. The component class is an MFC document class in an MDI application. There is a single component process with one MDI main frame window. Each time a client calls _CreateInstance_, a new document object is constructed, along with a view object and an MDI child frame window.

There's one more interesting case. Suppose a component EXE is running before the client needs it, and then the client decides to access a component object that already exists. You'll see this case with Excel. The user might have Excel running but minimized on the desktop, and the client needs access to Excel's one and only Application object. Here the client calls the COM function _GetActiveObject_, which provides an interface pointer for an existing component object. If the call fails, the client can create the object with _CoCreateInstance_.

For component object deletion, normal COM rules apply. Automation objects have reference counts, and they delete themselves when the client calls _Release_ and the reference count goes to 0. In an MDI component, if the Automation object is an MFC document, its destruction causes the corresponding MDI child window to close. In an SDI component, the destruction of the document object causes the component process to exit. The client is responsible for calling _Release_ for each _IDispatch_ interface before the client exits. For EXE components, COM will intervene if the client exits without releasing an interface, thus allowing the component process to exit. You can't always depend on this intervention, however, so be sure that your client cleans up its interfaces!

With generic COM, a client application often obtains multiple interface pointers for a single component object. Look back at the spaceship example in [Chapter 24](ch24a.htm), in which the simulated COM component class had both an _IMotion_ pointer and an _IVisual_ pointer. With Automation, however, there's usually only a single (_IDispatch_) pointer per object. As in all COM programming, you must be careful to release all your interface pointers. In Excel, for example, many properties return an _IDispatch_ pointer to new or existing objects. If you fail to release a pointer to an in-process COM component, the Debug version of the MFC library alerts you with a memory-leak dump when the client program exits.

**The MFC _IDispatch_ Implementation**
--------------------------------------

The component program can implement its _IDispatch_ interface in several ways. The most common of these pass off much of the work to the Windows COM DLLs by calling the COM function _CreateStdDispatch_ or by delegating the _Invoke_ call to the _ITypeInfo_ interface, which involves the component's type library. A type library is a table, locatable through the Registry, which allows a client to query the component for the symbolic names of objects, methods, and properties. A client could, for example, contain a browser that allows the user to explore the component's capabilities.

The MFC library supports type libraries, but it doesn't use them in its implementation of _IDispatch_, which is instead driven by a dispatch map. MFC programs don't call _CreateStdDispatch_ at all, nor do they use a type library to implement _IDispatch::GetIDsOfNames_. This means that you can't use the MFC library if you implement a multilingual Automation component—one that supports English and German property and method names, for example. (_CreateStdDispatch_ doesn't support multilingual components either.)

Later in this chapter you'll learn how a client can use a type library, and you'll see how AppWizard and ClassWizard create and maintain type libraries for you. Once your component has a type library, a client can use it for browsing, independent of the _IDispatch_ implementation.
________________________________________________________________________
7.2.8. - [An MFC Automation Component](invcpp5/ch25i.htm)
----------------------------------------------------
 An MFC Automation Component 

**An MFC Automation Component**
===============================

Let's look at what happens in an MFC Automation component—in this case, a simplified version of the EX25C alarm clock program that is discussed later in this chapter. In the MFC library, the _IDispatch_ implementation is part of the _CCmdTarget_ base class, so you don't need _INTERFACE_MAP_ macros. You write an Automation component class—_CClock_, for example—derived from _CCmdTarget_. This class's CPP file contains _DISPATCH_MAP_ macros:

BEGIN_DISPATCH_MAP(CClock, CCmdTarget)
    DISP_PROPERTY(CClock, "Time", m_time, VT_DATE)
    DISP_PROPERTY_PARAM(CClock, "Figure", GetFigure,
                        SetFigure, VT_VARIANT, VTS_I2)
    DISP_FUNCTION(CClock, "RefreshWin", Refresh, VT_EMPTY, VTS_NONE)
    DISP_FUNCTION(CClock, "ShowWin", ShowWin, VT_BOOL, VTS_I2)
END_DISPATCH_MAP()

Looks a little like an MFC message map, doesn't it? The _CClock_ class header file contains related code, shown here:

public:
    DATE m_time;
    afx_msg VARIANT GetFigure(short n);
    afx_msg void SetFigure(short n, const VARIANT& vaNew);
    afx_msg void Refresh();
    afx_msg BOOL ShowWin(short n);
    DECLARE_DISPATCH_MAP()

What does all this stuff mean? It means that the _CClock_ class has the following properties and methods.

**Name**

**Type**

**Description**

Time

Property

Linked directly to class data member _m_time_

Figure

Property

Indexed property, accessed through member functions _GetFigure_ and _SetFigure_: first parameter is the index; second (for _SetFigure_) is the string value (The figures are the "XII," "III," "VI," and "IX" that appear on the clock face.)

_RefreshWin_

Method

Linked to class member function _Refresh_—no parameters or return value

_ShowWin_

Method

Linked to class member function _ShowWin_—short integer parameter, Boolean return value

How does the MFC dispatch map relate to _IDispatch_ and the _Invoke_ member function? The dispatch-map macros generate static data tables that the MFC library's _Invoke_ implementation can read. A controller gets an _IDispatch_ pointer for _CClock_ (connected through the _CCmdTarget_ base class), and it calls _Invoke_ with an array of pointers as a parameter. The MFC library's implementation of _Invoke_, buried somewhere inside _CCmdTarget_, uses the _CClock_ dispatch map to decode the supplied pointers and either calls one of your member functions or accesses _m_time_ directly.

As you'll see in the examples, ClassWizard can generate the Automation component class for you and help you code the dispatch map.
________________________________________________________________________
7.2.9. - [An MFC Automation Client Program](invcpp5/ch25j.htm)
----------------------------------------------------
 An MFC Automation Client Program 

**An MFC Automation Client Program**
====================================

Let's move on to the client's end of the Automation conversation. How does an MFC Automation client program call _Invoke_? The MFC library provides a base class _COleDispatchDriver_ for this purpose. This class has a data member, _m_lpDispatch_, which contains the corresponding component's _IDispatch_ pointer. To shield you from the complexities of the _Invoke_ parameter sequence, _COleDispatchDriver_ has several member functions, including _InvokeHelper_, _GetProperty_, and _SetProperty_. These three functions call _Invoke_ for an _IDispatch_ pointer that links to the component. The _COleDispatchDriver_ object incorporates the _IDispatch_ pointer.

Let's suppose our client program has a class _CClockDriver_, derived from _COleDispatchDriver_, that drives _CClock_ objects in an Automation component. The functions that get and set the Time property are shown here.

DATE CClockDriver::GetTime()
{
    DATE result;
    GetProperty(1, VT_DATE, (void\*)&result);
    return result;
}

void CClockDriver::SetTime(DATE propVal)
{
    SetProperty(1, VT_DATE, propVal);
}

Here are the functions for the indexed Figure property:

VARIANT CClockDriver::GetFigure(short i)
{
    VARIANT result;
    static BYTE parms[] = VTS_I2;
    InvokeHelper(2, DISPATCH_PROPERTYGET, VT_VARIANT,
                (void\*)&result, parms, i);
    return result;
}

void CClockDriver::SetFigure(short i, const VARIANT& propVal)
{
    static BYTE parms[] = VTS_I2 VTS_VARIANT;
    InvokeHelper(2, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL,
                 parms, i, &propVal);
}

And finally, here are the functions that access the component's methods:

void CClockDriver::RefreshWin()
{
    InvokeHelper(3, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

BOOL CClockDriver::ShowWin(short i)
{
    BOOL result;
    static BYTE parms[] = VTS_I2;
    InvokeHelper(4, DISPATCH_METHOD, VT_BOOL, 
                (void\*)&result, parms, i);
    return result;
}

The function parameters identify the property or method, its return value, and its parameters. You'll learn about dispatch function parameters later, but for now take special note of the first parameter for the _InvokeHelper_, _GetProperty_, and _SetProperty_ functions. This is the unique integer index, or dispatch ID (DISPID), for the property or method. Because you're using compiled C++, you can establish these IDs at compile time. If you're using an MFC Automation component with a dispatch map, the indexes are determined by the map sequence, beginning with 1. If you don't know a component's dispatch indexes, you can call the _IDispatch_ member function _GetIDsOfNames_ to convert the symbolic property or method names to integers.

The following illustration shows the interactions between the client (or controller) and the component.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g25og01x.gif)]

The solid lines show the actual connections through the MFC base classes and the _Invoke_ function. The dotted lines represent the resulting logical connections between client class members and component class members.

Most Automation components have a binary type library file with a TLB extension. ClassWizard can access this type library file to generate a class derived from _COleDispatchDriver_. This generated controller class contains member functions for all the component's methods and properties with hard-coded dispatch IDs. Sometimes you need to do some surgery on this generated code, but that's better than writing the functions from scratch.

After you have generated your driver class, you embed an object of this class in your client application's view class (or in another class) like this:

CClockDriver m_clock;

Then you ask COM to create a clock component object with this statement:

m_clock.CreateDispatch("Ex25c.Document");

Now you're ready to call the dispatch driver functions:

m_clock.SetTime(COleDateTime::GetCurrentTime());
m_clock.RefreshWin();

When the _m_clock_ object goes out of scope, its destructor releases the _IDispatch_ pointer.
________________________________________________________________________
7.2.10. - [An Automation Client Program Using the Compiler's #import Directive](invcpp5/ch25k.htm)
----------------------------------------------------
 An Automation Client Program Using the Compiler's #import Directive 

**An Automation Client Program Using the Compiler's _#import_ Directive**
=========================================================================

Now there's an entirely new way of writing Automation client programs. Instead of using ClassWizard to generate a class derived from _COleDispatchDriver_, you use the compiler to generate header and implementation files directly from a component's type library. For the clock component, your client program contains the following statement:

#import"..\ex25c\debug\ex25c.tlb" rename_namespace("ClockDriv") using namespace ClockDriv;

The compiler then generates (and processes) two files, ex25c.tlh and ex25c.tli, in the project's Debug or Release subdirectory. The TLH file contains the _IEx25c_ clock driver class declaration plus this smart pointer declaration:

_COM_SMARTPTR_TYPEDEF(IEx25c, __uuidof(IDispatch));

The __COM_SMARTPTR_TYPEDEF_ macro generates the _IEx25cPtr_ pointer type, which encapsulates the component's _IDispatch_ pointer. The TLI file contains inline implementations of member functions, some of which are shown in the following code:

inline HRESULT IEx25c::RefreshWin ( ) {
    return _com_dispatch_method(this, 0x4, DISPATCH_METHOD, 
        VT_EMPTY, NULL, NULL);
}

inline DATE IEx25c::GetTime ( ) {
    DATE _result;
    _com_dispatch_propget(this, 0x1, VT_DATE, (void\*)&_result);
    return _result;
}

inline void IEx25c::PutTime ( DATE _val ) {
    _com_dispatch_propput(this, 0x1, VT_DATE, _val);
}

Note the similarity between these functions and the _COleDispatchDriver_ member functions you've already seen. The functions __com_dispatch_method_, __com_dispatch_propget_, and __com_dispatch_propput_ are in the runtime library.

In your Automation client program, you declare an embedded smart pointer member in your view class (or in another class) like this:

IEx25cPtr  m_clock;

Then you create a clock component object with this statement:

m_clock.CreateInstance(__uuidof(Document));

Now you're ready to use the _IEx25cPtr_ class's overloaded -> operator to call the member functions defined in the TLI file:

m_clock->PutTime(COleDateTime::GetCurrentTime());
m_clock->RefreshWin();

When the _m_clock_ smart pointer object goes out of scope, its destructor calls the COM _Release_ function.

The _#import_ directive is the future of COM programming. With each new version of Visual C++, you'll see COM features moving into the compiler, along with the document_view architecture itself.
________________________________________________________________________
7.2.11. - [The VARIANT  Type](invcpp5/ch25l.htm)
----------------------------------------------------
 The VARIANT Type 

**The _VARIANT_ Type**
======================

No doubt you've noticed the _VARIANT_ type used in both Automation client and component functions in the previous example. _VARIANT_ is an all-purpose data type that _IDispatch::Invoke_ uses to transmit parameters and return values. The _VARIANT_ type is the natural type to use when exchanging data with VBA. Let's look at a simplified version of the _VARIANT_ definition in the Windows header files.

struct tagVARIANT {
    VARTYPE vt; // unsigned short integer type code
    WORD wReserved1, wReserved2, wReserved3;
    union {
        short      iVal;                 // VT_I2  short integer
        long       lVal;                 // VT_I4  long integer
        float      fltVal;               // VT_R4  4-byte float
        double     dblVal;               // VT_R8  8-byte IEEE float
        DATE       date;                 // VT_DATE stored as dbl
                                         //  date.time
        CY         vtCY                  // VT_CY 64-bit integer
        BSTR       bstrVal;              // VT_BSTR
        IUnknown\*  punkVal;              // VT_UNKNOWN
        IDispatch\* pdispVal;             // VT_DISPATCH
        short\*     piVal;                // VT_BYREF | VT_I2
        long\*      plVal;                // VT_BYREF | VT_I4
        float\*     pfltVal;              // VT_BYREF | VT_R4
        double\*    pdblVal;              // VT_BYREF | VT_R8
        DATE\*      pdate;                // VT_BYREF | VT_DATE
        CY\*        pvtCY;                // VT_BYREF | VT_CY
        BSTR\*      pbstrVal;             // VT_BYREF | VT_BSTR
    }
};

typedef struct tagVARIANT VARIANT;

As you can see, the _VARIANT_ type is a C structure that contains a type code _vt_, some reserved bytes, and a big union of types that you already know about. If _vt_ is VT___I2, for example, you would read the _VARIANT_'s value from _iVal_, which contains a 2-byte integer. If _vt_ is VT___R8, you would read this value from _dblVal_, which contains an 8-byte real value.

A _VARIANT_ object can contain actual data or a pointer to data. If _vt_ has the VT_BYREF bit set, you must access a pointer in _piVal_, _plVal_, and so on. Note that a _VARIANT_ object can contain an _IUnknown_ pointer or an _IDispatch_ pointer. This means that you can pass a complete COM object using an Automation call, but if you want VBA to process that object, its class should have an _IDispatch_ interface.

Strings are special. The _BSTR_ type is yet another way to represent character strings. A _BSTR_ variable is a pointer to a zero-terminated character array with a character count in front. A _BSTR_ variable could, therefore, contain binary characters, including zeros. If you had a _VARIANT_ object with _vt_ = VT_BSTR, memory would look like this.

![](c:/dl/books/windows/msvc5th/invcpp5/images/g25og02x.gif)

Because the string has a terminating 0, you can use _bstrVal_ as though it were an ordinary _char_ pointer, but you have to be very, very careful about memory cleanup. You can't simply delete the string pointer, because the allocated memory begins with the character count. Windows provides the _SysAllocString_ and _SysFreeString_ functions for allocating and deleting _BSTR_ objects.

> NOTE
> 
> _SysAllocString_ is another COM function that takes a wide string pointer as a parameter. This means that all _BSTR_s contain wide characters, even if you haven't defined __UNICODE_. Be careful.

Windows supplies some useful functions for _VARIANT_s, including those shown in the following table. If a _VARIANT_ contains a _BSTR_, these functions ensure that memory is allocated and cleared properly. The _VariantInit_ and _VariantClear_ functions set _vt_ to VT___EMPTY. All the variant functions are global functions and take a _VARIANT\*_ parameter.

**Function**

**Description**

_VariantInit_

Initializes a _VARIANT_

_VariantClear_

Clears a _VARIANT_

_VariantCopy_

Frees memory associated with the destination _VARIANT_ and copies the source _VARIANT_

_VariantCopyInd_

Frees the destination _VARIANT_ and performs any indirection necessary to copy the source _VARIANT_

_VariantChangeType_

Changes the type of the _VARIANT_
________________________________________________________________________
7.2.12. - [The COleVariant Class](invcpp5/ch25m.htm)
----------------------------------------------------
 The COleVariant Class 

**The _COleVariant_ Class**
===========================

Writing a C++ class to wrap the _VARIANT_ structure makes a lot of sense. Constructors can call _VariantInit_, and the destructor can call _VariantClear_. The class can have a constructor for each standard type, and it can have copy constructors and assignment operators that call _VariantCopy_. When a variant object goes out of scope, its destructor is called and memory is cleaned up automatically.

Well, the MFC team created just such a class, mostly for use in the Data Access Objects (DAO) subsystem, described in [Chapter 32](ch32a.htm). It works well in Automation clients and components, however. A simplified declaration is shown here.

class COleVariant : public tagVARIANT
{
// Constructors
public:
    COleVariant();

    COleVariant(const VARIANT& varSrc);
    COleVariant(const COleVariant& varSrc);

    COleVariant(LPCTSTR lpszSrc);
    COleVariant(CString& strSrc);

    COleVariant(BYTE nSrc);
    COleVariant(short nSrc, VARTYPE vtSrc = VT_I2);
    COleVariant(long lSrc, VARTYPE vtSrc = VT_I4);

    COleVariant(float fltSrc);
    COleVariant(double dblSrc);
    COleVariant(const COleDateTime& dateSrc);
// Destructor
    ~COleVariant(); // deallocates BSTR
// Operations
public:
    void Clear(); // deallocates BSTR
    VARIANT Detach(); // more later
    void ChangeType(VARTYPE vartype, LPVARIANT pSrc = NULL);
};

In addition, the _CArchive_ and _CDumpContext_ classes have comparison operators, assignment operators, conversion operators, and friend insertion/extraction operators. See the online documentation for a complete description of this useful MFC _COleVariant_ class.

Now let's see how the _COleVariant_ class helps us write the component's _GetFigure_ function that you previously saw referenced in the sample dispatch map. Assume that the component stores strings for four figures in a class data member:

private:
    CString m_strFigure[4];

Here's what we'd have to do if we used the _VARIANT_ structure directly:

VARIANT CClock::GetFigure(short n)
{
    VARIANT vaResult;
    ::VariantInit(&vaResult);
    vaResult.vt = VT_BSTR;
    // CString::AllocSysString creates a BSTR
    vaResult.bstrVal = 
m_strFigure[n].AllocSysString();
    return vaResult; // Copies vaResult without copying BSTR
                     //  BSTR still must be freed later
}

Here's the equivalent, with a _COleVariant_ return value:

VARIANT CClock::GetFigure(short n)
{
    return COleVariant(m_strFigure[n]).Detach();
}

Calling the _COleVariant::Detach_ function is critical here. The _GetFigure_ function is constructing a temporary object that contains a pointer to a _BSTR_. That object gets bitwise-copied to the return value. If you didn't call _Detach_, the _COleVariant_ destructor would free the _BSTR_ memory and the calling program would get a _VARIANT_ that contained a pointer to nothing.

A component's variant dispatch function parameters are declared as _const VARIANT&_. You can always cast a _VARIANT_ pointer to a _COleVariant_ pointer inside the function. Here's the _SetFigure_ function:

void CClock::SetFigure(short n, const VARIANT& vaNew)
{
    COleVariant vaTemp;
    vaTemp.ChangeType(VT_BSTR, (COleVariant\*) &vaNew);
    m_strFigure[n] = vaTemp.bstrVal;
}

> NOTE
> 
> Remember that all _BSTR_s contain wide characters. The _CString_ class has a constructor and an assignment operator for the _LPCWSTR_ (wide-character pointer) type. Thus, the _m_strFigure_ string will contain single-byte characters, even though _bstrVal_ points to a wide-character array.

Client dispatch function variant parameters are also typed as _const VARIANT&._ You can call those functions with either a _VARIANT_ or a _COleVariant_ object. Here's an example of a call to the _CClockDriver::SetFigure_ function:

pClockDriver->SetFigure(0, COleVariant("XII"));

> NOTE
> 
> Visual C++ 5.0 added two new classes for _BSTR_s and _VARIANT_s. These classes are independent of the MFC library:__bstr_t_ and __variant_t_. The __bstr_t_ class encapsulates the _BSTR_ data type; the __variant_t_ class encapsulates the _VARIANT_ type. Both classes manage resource allocation and deallocation. For more information on these classes, see the online documentation.

**Parameter and Return Type Conversions for _Invoke_**
------------------------------------------------------

All _IDispatch::Invoke_ parameters and return values are processed internally as _VARIANT_s. Remember that! The MFC library implementation of _Invoke_ is smart enough to convert between a _VARIANT_ and whatever type you supply (where possible), so you have some flexibility in declaring parameter and return types. Suppose, for example, that your controller's _GetFigure_ function specifies the return type _BSTR._ If a component returns an _int_ or a _long_, all is well: COM and the MFC library convert the number to a string. Suppose your component declares a _long_ parameter and the controller supplies an _int_. Again, no problem.

> NOTE
> 
> An MFC library Automation client specifies the expected return type as a _VT__ parameter to the _COleDispatchDriver_ functions _GetProperty_, _SetProperty_, and _InvokeHelper_. An MFC library Automation component specifies the expected parameter types as _VTS__ parameters in the _DISP_PROPERTY_ and _DISP_FUNCTION_ macros.

Unlike C++, VBA is not a strongly typed language. VBA variables are often stored internally as _VARIANT_s. Take an Excel spreadsheet cell value, for example. A spreadsheet user can type a text string, an integer, a floating-point number, or a date/time in a cell. VBA treats the cell value as a _VARIANT_ and returns a _VARIANT_ object to an Automation client. If your client function declares a _VARIANT_ return value, it can test _vt_ and process the data accordingly.

VBA uses a date/time format that is distinct from the MFC library _CTime_ class. Variables of type _DATE_ hold both the date and the time in one double value. The fractional part represents time (.25 is 6:00 AM), and the whole part represents the date (number of days since December 30, 1899). The MFC library provides a _COleDateTime_ class that makes dates easy to deal with. You could construct a date this way:

COleDateTime date(1998, 10, 1, 18, 0, 0);

The above declaration initializes the date to October 1, 1998, at 6:00 PM.

The _COleVariant_ class has an assignment operator for _COleDateTime_, and the _COleDateTime_ class has member functions for extracting date/time components. Here's how you print the time:

TRACE("time = %d:%d:%d\n",
      date.GetHour(),date.GetMinute(),date.GetSecond());

If you have a variant that contains a _DATE_, you use the _COleVariant::ChangeType_ function to convert a date to a string, as shown here:

COleVariant vaTimeDate = date;
COleVariant vaTemp;
vaTemp.ChangeType(VT_BSTR, &vaTimeDate);
CString str = vaTemp.bstrVal;
TRACE("date = %s\n", str);

One last item concerning _Invoke_ parameters: a dispatch function can have optional parameters. If the component declares trailing parameters as _VARIANT_s, the client doesn't have to supply them. If the client calls the function without supplying an optional parameter, the _VARIANT_ object's _vt_ value on the component end is VT_ERROR.
________________________________________________________________________
7.2.13. - [Automation Examples](invcpp5/ch25n.htm)
----------------------------------------------------
 Automation Examples 

**Automation Examples**
=======================

The remainder of this chapter presents five sample programs. The first three programs are Automation components—an EXE component with no user interface, a DLL component, and a multi-instance SDI EXE component. Each of these component programs comes with a Microsoft Excel driver workbook file. The fourth sample program is an MFC Automation client program that drives the three components and also runs Excel using the _COleDispatchDriver_ class. The last sample is a client program that uses the C++ _#import_ directive instead of the MFC _COleDispatchDriver_ class.

**The EX25A Automation Component  
EXE Example—No User Interface**
------------------------------------------------------------------

The Visual C++ Autoclik example is a good demonstration of an MDI framework application with the document object as the Automation component. (To find the Autoclik example, look in the online documentation under Visual C++ Documentation/Samples/MFC Samples/Tutorial Samples.) The EX25A example is different from the Autoclik example because EX25A has no user interface. There is one Automation-aware class, and in the first version of the program, a single process supports the construction of multiple Automation component objects. In the second version, a new process starts up each time an Automation client creates an object.

The EX25A example represents a typical use of Automation. A C++ component implements financial transactions. VBA programmers can write User-interface-intensive applications that rely on the audit rules imposed by the Automation component. A production component program would probably use a database, but EX25A is simpler. It implements a bank account with two methods, _Deposit_ and _Withdrawal_, and one read-only property, Balance. Obviously, _Withdrawal_ can't permit withdrawals that make the balance negative. You can use Excel to control the component, as shown in Figure 25-3.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f25og03x.gif)]

**Figure 25-3.** _This Excel workbook is controlling the EX25A component._

Here are the steps for creating the program from scratch:

2.  **Run AppWizard to create the EX25A project in the \vcpp32\ex25a directory.** Select the Dialog Based option (Step 1). Deselect all options in Step 2, and accept the remaining default settings. This is the simplest application that AppWizard can generate.
    
3.  **Eliminate the dialog class from the project.** Using Windows Explorer or the command-line prompt, delete the files ex25aDlg.cpp and ex25aDlg.h. Remove ex25aDlg.cpp and ex25aDlg.h from the project by deleting them from the project's Workspace window (FileView). Edit ex25a.cpp. Remove the dialog _#include_, and remove all dialog-related code from the _InitInstance_ function. In ResourceView, delete the _IDD_EX25A_DIALOG_ dialog resource template.
    
4.  **Add code to enable Automation.** Add this line in StdAfx.h:
    
    #include <afxdisp.h>
    
    Edit the _InitInstance_ function (in Ex25a.cpp) to look like this:
    
    BOOL CEx25aApp::InitInstance()
    {
        **AfxOleInit();
        if(RunEmbedded() || RunAutomated()) {
            // component started by COM
            COleTemplateServer::RegisterAll();
            return TRUE;
        }
        // Component is being run directly by the user
        COleObjectFactory::UpdateRegistryAll();**
       ** AfxMessageBox("Bank server is registered");**
        return FALSE;
    }
    
5.  **Use ClassWizard to add a new class, _CBank_, as shown here.**
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/g25og03.gif)
    
    Be sure to select the Createable By Type ID option.
    

6.  **Use ClassWizard to add two methods and a property.** Click on the Automation tab, and then add a Withdrawal method, as shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/g25og04.gif)
    
    The _dAmount_ parameter is the amount to be withdrawn, and the return value is the actual amount withdrawn. If you try to withdraw $100 from an account that contains $60, the amount withdrawn is $60.
    
    Add a similar _Deposit_ method that returns _void_, and then add the Balance property, as shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/g25og05x.gif)
    
    We could have chosen direct access to a component data member, but then we wouldn't have read-only access. We choose Get/Set Methods so that we can code the _SetBalance_ function to do nothing.
    

7.  **Add a public _m_dBalance_ data member of type _double_ to the _CBank_ class.** Because we've chosen the Get/Set Methods option for the Balance property, ClassWizard doesn't generate a data member for us. You should declare _m_dBalance_ in the Bank.h file and initialize _m_dBalance_ to 0.0 in the _CBank_ constructor located in the bank.cpp file.
    
8.  **Edit the generated method and property functions.** Add the following boldface code:
    
    double CBank::Withdrawal(double dAmount) 
    {
            **if (dAmount < 0.0) {
            return 0.0;
            }
            if (dAmount <= m_dBalance) {
                m_dBalance -= dAmount;**
                return dAmount
            **}
            double dTemp = m_dBalance;
            m_dBalance = 0.0;
            return dTemp;**
    }
    
    void CBank::Deposit(double dAmount) 
    {
            **if (dAmount < 0.0) {
                return;
            }
            m_dBalance += dAmount;**
    }
    
    double CBank::GetBalance( ) 
    {
            **return m_dBalance;**
    }
    
    void CBank::SetBalance(double newValue) 
    {
            **TRACE("Sorry, Dave, I can't do that!\n");**
    }
    
9.  **Build the EX25A program; run it once to register the component.**
    
10.  **Set up five Excel macros in a new workbook file, ex25a.xls.** Add the following code:
    
    Dim Bank As Object
    Sub LoadBank()
        Set Bank = CreateObject("Ex25a.Bank")
    End Sub
    
    Sub UnloadBank()
        Set Bank = Nothing
    End Sub
    
    Sub DoDeposit()
        Range("D4").Select
        Bank.Deposit (ActiveCell.Value)
    End Sub
    
    Sub DoWithdrawal()
        Range("E4").Select
        Dim Amt
        Amt = Bank.Withdrawal(ActiveCell.Value)
        Range("E5").Select
        ActiveCell.Value = Amt
    End Sub
    
    Sub DoInquiry()
        Dim Amt
        Amt = Bank.Balance()
        Range("G4").Select
        ActiveCell.Value = Amt
    End Sub
    
11.  **Arrange an Excel worksheet as shown in Figure 25-3.** Attach the macros to the pushbuttons (by right-clicking the pushbuttons).
    
12.  **Test the EX25A bank component.** Click the Load Bank Program button, and then enter a deposit value in cell D4 and click the Deposit button. Click the Balance Inquiry button, and watch the balance appear in cell G4. Enter a withdrawal value in cell E4, and click the Withdrawal button. To see the balance, click the Balance Inquiry button.

> NOTE
> 
> Sometimes you need to click the buttons twice. The first click switches the focus to the worksheet, and the second click runs the macro. The hourglass pointer tells you the macro is working.

What's happening in this program? Look closely at the _CEx25aApp::InitInstance_ function. When you run the program directly from Windows, it displays a message box and then quits, but not before it updates the Registry. The _COleObjectFactory::UpdateRegistryAll_ function hunts for global class factory objects, and the _CBank_ class's _IMPLEMENT_OLECREATE_ macro invocation defines such an object. (The _IMPLEMENT_OLECREATE_ line was generated because you checked ClassWizard's Createable By Type ID check box when you added the _CBank_ class.) The unique class ID and the program ID, _EX25A.BANK_, are added to the Registry.

When Excel now calls _CreateObject_, COM loads the EX25A program, which contains the global factory for _CBank_ objects; COM then calls the factory object's _CreateInstance_ function to construct the _CBank_ object and return an _IDispatch_ pointer. Here's the _CBank_ class declaration that ClassWizard generated in the bank.h file, with unnecessary detail (and the method and property functions you've already seen) omitted:

class CBank : public CCmdTarget
{
    DECLARE_DYNCREATE(CBank)
public:
    double m_dBalance;
    CBank();   // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CBank)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

// Implementation
protected:
    virtual ~CBank();

    // Generated message map functions
    //{{AFX_MSG(CBank)
        // NOTE - the ClassWizard will add and remove member
        //  functions here.
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
    DECLARE_OLECREATE(CBank)

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CBank)
    afx_msg double GetBalance();
    afx_msg void SetBalance(double newValue);
    afx_msg double Withdrawal(double dAmount);
    afx_msg void Deposit(double dAmount);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()
};

Here is the code automatically generated by ClassWizard in bank.cpp:

IMPLEMENT_DYNCREATE(CBank, CCmdTarget)

CBank::CBank()
{
    EnableAutomation();
    
    // To keep the application running as long as an OLE automation 
    //  object is active, the constructor calls AfxOleLockApp.
    
    AfxOleLockApp();
}

CBank::~CBank()
{
    // To terminate the application when all objects created with
    //  OLE automation, the destructor calls AfxOleUnlockApp.
    
    AfxOleUnlockApp();
}

void CBank::OnFinalRelease()
{
    // When the last reference for an automation object is released,
    //  OnFinalRelease is called. This implementation deletes the 
    //  object. Add additional cleanup required for your object
    //  before deleting it from memory.

    CCmdTarget::OnFinalRelease
}

BEGIN_MESSAGE_MAP(CBank, CCmdTarget)
    //{{AFX_MSG_MAP(CBank)
        // NOTE - the ClassWizard will add and remove 
        //  mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CBank, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CBank)
    DISP_PROPERTY_EX(CBank, "Balance", GetBalance, SetBalance, VT_R8)
    DISP_FUNCTION(CBank, "Withdrawal", Withdrawal, VT_R8, VTS_R8)
    DISP_FUNCTION(CBank, "Deposit", Deposit, VT_EMPTY, VTS_R8)
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IBank to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {A9515AB6-5B85-11D0-848F-00400526305B}
static const IID IID_IBank =
{ 0xa9515ab6, 0x5b85, 0x11d0, { 0x84, 0x8f, 0x0, 0x40, 0x5, 0x26, 
    0x30, 0x5b } };

BEGIN_INTERFACE_MAP(CBank, CCmdTarget)
    INTERFACE_PART(CBank, IID_IBank, Dispatch)
END_INTERFACE_MAP()

// {632B1E4C-F287-11CE-B5E3-00AA005B1574}
IMPLEMENT_OLECREATE2(CBank, "EX25A.BANK", 0x632b1e4c, 0xf287, 
    0x11ce, 0xb5, 0xe3, 0x0, 0xaa, 0x0, 0x5b, 0x15, 0x74)

This first version of the EX25A program runs in single-process mode, as does the Autoclik program. If a second Automation client asks for a new _CBank_ object, COM calls the class factory _CreateInstance_ function again and the existing process constructs another _CBank_ object on the heap. You can verify this by making a copy of the ex25a.xls workbook (under a different name) and loading both the original and the copy. Click the Load Bank Program button in each workbook, and watch the Debug window. _InitInstance_ should be called only once.

A small change in the EX25A program makes it behave differently. To have a new EX25A process start up each time a new component object is requested, follow these steps.

2.  **Add the following macro in bank.h:**
    
    **#define IMPLEMENT_OLECREATE2(class_name, external_name, \
        l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        AFX_DATADEF COleObjectFactory class_name::factory(class_name::guid, \
        RUNTIME_CLASS(class_name), TRUE, _T(external_name)); \
        const AFX_DATADEF GUID class_name::guid = \
        { l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } };**
    
    This macro is the same as the standard MFC _IMPLEMENT_OLECREATE_ macro except that the original _FALSE_ parameter (after the _RUNTIME_CLASS_ parameter) has been changed to _TRUE_.
    
3.  **In bank.cpp, change the _IMPLEMENT_OLECREATE_ macro invocation to _IMPLEMENT_OLECREATE2_**.
    
4.  **Build the program and test it using Excel.** Start two Excel processes and then load the bank program from each. Use the Microsoft Windows NT Task Manager or PVIEW95 to verify that two EX25A processes are running.
    
    > NOTE
    > 
    > The EX25A program on the companion CD-ROM uses the _IMPLEMENT_OLECREATE2_ macro.
    
    **Debugging an EXE Component Program**
    
    When an Automation client launches an EXE component program, it sets the _/Embedding_ command-line parameter. If you want to debug your component, you must do the same. Choose Settings from the Visual C++ Project menu, and then enter _/Embedding_ in the Program Arguments box on the Debug page, as shown here.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g25og06x.gif)]
    
    When you click the Go button on the Debug toolbar, your program will start and then wait for a client to activate it. At this point, you should start the client program from Windows (if it is not already running) and then use it to create a component object. Your component program in the debugger should then construct its object. It might be a good idea to include a _TRACE_ statement in the component object's constructor.
    
    Don't forget that your component program must be registered before the client can find it. That means you have to run it once without the _/Embedding_ flag. Many clients don't synchronize with Registry changes. If your client is running when you register the component, you may have to restart the client.
    

**The EX25B Automation Component DLL Example**
----------------------------------------------

You could easily convert EX25A from an EXE to a DLL. The _CBank_ class would be exactly the same, and the Excel driver would be similar. It's more interesting, though, to write a new application—this time with a minimal user interface (UI). We'll use a modal dialog box because it's the most complex UI we can conveniently use in an Automation DLL.

**Parameters Passed by Reference**

So far, you've seen VBA parameters passed by value. VBA has pretty strange rules for calling methods. If the method has one parameter, you can use parentheses; if it has more than one, you can't (unless you're using the function's return value, in which case you must use parentheses). Here is some sample VBA code that passes the string parameter by value:

Object.Method1 parm1, "text"
Object.Method2("text")
Dim s as String
s = "text"
Object.Method2(s)

Sometimes, though, VBA passes the address of a parameter (a reference). In this example, the string is passed by reference:

Dim s as String
s = "text"
Object.Method1 parm1, s

You can override VBA's default behavior by prefixing a parameter with _ByVal_ or _ByRef_. Your component can't predict if it's getting a value or a reference—it must prepare for both. The trick is to test _vt_ to see whether its _VT_BYREF_ bit is set. Here's a sample method implementation that accepts a string (in a _VARIANT_) passed either by reference or value:

void CMyComponent::Method(long nParm1, const VARIANT& vaParm2)
{
    CString str;
    if ((vaParm2.vt & 0x7f) == VT_BSTR) {
        if ((vaParm2.vt & VT_BYREF) != 0)
            str = \*(vaParm2.pbstrVal); // byref
        else
            str = vaParm2.bstrVal; // byval
    }
    AfxMessageBox(str);
}

If you declare a _BSTR_ parameter, the MFC library does the conversion for you. Suppose your client program passed a _BSTR_ reference to an out-of-process component and the component program changed the value. Because the component can't access the memory of the client process, COM must copy the string to the component and then copy it back to the client after the function returns. So before you declare reference parameters, remember that passing references through _IDispatch_ is not like passing references in C++.

The EX25B program is fairly simple. An Automation component class, identified by the registered name Ex25b.Auto, has the following properties and method:

**LongData**

Long integer property

TextData

_VARIANT_ property

_DisplayDialog_

Method—no parameters, _BOOL_ return

_DisplayDialog_ displays the EX25B data gathering dialog box shown in Figure 25-4. An Excel macro passes two cell values to the DLL and then updates the same cells with the updated values.

![](c:/dl/books/windows/msvc5th/invcpp5/images/f25og04.gif)

**Figure 25-4.** _The EX25B DLL dialog in action._

The example was first generated as an MFC AppWizard DLL with the Regular DLL Using Shared MFC DLL option and the Automation option selected. Here are the steps for building and testing the EX25B component DLL from the code installed from the companion CD-ROM:

2.  **From Visual C++, open the \vcpp32\ex25b\ex25b.dsw workspace.** Build the project.
    
3.  **Register the DLL with the RegComp utility.** You can use the RegComp program in the \vcpp32\RegComp\Release directory on the companion CD-ROM; a file dialog makes it easy to select the DLL file.
    
4.  **Start Excel, and then load the \vcpp32\ex25b\ex25b.xls workbook file.** Type an integer in cell C3, and type some text in cell D3.
    
    **Debugging a DLL Component**
    
    To debug a DLL, you must tell the debugger which EXE file to load. Choose Settings from Visual C++'s Project menu, and then enter the controller's full pathname (including the EXE extension) in the Executable For Debug Session box on the Debug page.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g25og08x.gif)]
    
    When you click the Go button on the Debug toolbar, your controller will start (loading the DLL as part of its process) and then wait for you to activate the component.
    
    When you activate the component, your DLL in the debugger should then construct its component object. It might be a good idea to include a _TRACE_ statement in the component object's constructor. Don't forget that your DLL must be registered before the client can load it.
    
    Here's another option. If you have the source code for the client program, you can start the client program in the debugger. When the client loads the component DLL, you can see the output from the component program's _TRACE_ statements.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g25og07x.gif)]
    
    Click the Load DLL button, and then click the Gather Data button. Edit the data, click OK, and watch the new values appear in the spreadsheet.
    

5.  **Click the Unload DLL button.**If you've started the DLL (and Excel) from the debugger, you can watch the Debug window to be sure the DLL's _ExitInstance_ function is called.

Now let's look at the EX25B code. Like an MFC EXE, an MFC regular DLL has an application class (derived from _CWinApp_) and a global application object. The overridden _InitInstance_ member function in ex25b.cpp looks like this:

BOOL CEx25bApp::InitInstance()
{
    TRACE("CEx25bApp::InitInstance\n");
    // Register all OLE server (factories) as running.  This 
    //  enables the OLE libraries to create objects from other 
    //  applications.
    COleObjectFactory::RegisterAll();

    return TRUE;
}

There's also an _ExitInstance_ function for diagnostic purposes only, as well as the following code for the three standard COM DLL exported functions:

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID\* ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return AfxDllGetClassObject(rclsid, riid, ppv);
}

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return AfxDllCanUnloadNow();
}

STDAPI DllRegisterServer(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    COleObjectFactory::UpdateRegistryAll();
    VERIFY(AfxOleRegisterTypeLib(AfxGetInstanceHandle(),
           theTypeLibGUID, "ex25b.tlb"));
       return S_OK;
}

The PromptDl.cpp file contains code for the _CPromptDlg_ class, but that class is a standard class derived from _CDialog_. The file PromptDl.h contains the _CPromptDlg_ class header.

The _CEx25bAuto_ class, the Automation component class initially generated by ClassWizard (with the Createable By Type ID option), is more interesting. This class is exposed to COM under the program ID ex25b.Auto. Figure 25-5 below shows the header file ex25bAuto.h.

**EX25BAUTO.H**

class CEx25bAuto : public CCmdTarget
{
    DECLARE_DYNCREATE(CEx25bAuto)

    CEx25bAuto(); // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEx25bAuto)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

// Implementation
protected:
    virtual ~CEx25bAuto();

    // Generated message map functions
    //{{AFX_MSG(CEx25bAuto)
        // NOTE - the ClassWizard will add and remove member 
        //  functions here.
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
    DECLARE_OLECREATE(CEx25bAuto)

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CEx25bAuto)
    long m_lData;
    afx_msg void OnLongDataChanged();
    VARIANT m_vaTextData;
    afx_msg void OnTextDataChanged();
    afx_msg BOOL DisplayDialog();
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()
};

**Figure 25-5.** _Excerpt from the ex25bAuto.h header file._

Figure 25-6 shows the implementation file ex25bAuto.cpp.

**EX25BAUTO.CPP**

#include "stdafx.h"
#include "ex25b.h"
#include "Ex25bAuto.h"
#include "PromptDl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE
__;
#endif

////////////////////////////////////////////////////////////////////
// CEx25bAuto

IMPLEMENT_DYNCREATE(CEx25bAuto, CCmdTarget)

CEx25bAuto::CEx25bAuto()
{
    EnableAutomation();

    // To keep the application running as long as an OLE automation
    //  object is active, the constructor calls AfxOleLockApp.

    ::VariantInit(&m_vaTextData); // necessary initialization
    m_lData = 0;

    AfxOleLockApp();
}

CEx25bAuto::~CEx25bAuto()
{
    // To terminate the application when all objects created with
    //  with OLE automation, the destructor calls AfxOleUnlockApp.

    AfxOleUnlockApp();
}

void CEx25bAuto::OnFinalRelease()
{
    // When the last reference for an automation object is released,
    //  OnFinalRelease is called. The base class will automatically
    //  delete the object. Add additional cleanup required for your
    //  object before calling the base class.

    CCmdTarget::OnFinalRelease();
}

BEGIN_MESSAGE_MAP(CEx25bAuto, CCmdTarget)
    //{{AFX_MSG_MAP(CEx25bAuto)
        // NOTE - the ClassWizard will add and remove mapping 
        //  macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CEx25bAuto, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CEx25bAuto)
        DISP_PROPERTY_NOTIFY(CEx25bAuto, "LongData", 
m_lData, 
            OnLongDataChanged, VT_I4)
        DISP_PROPERTY_NOTIFY(CEx25bAuto, "TextData", 
m_vaTextData, 
**Figure 25-6.**_continued_
            OnTextDataChanged, VT_VARIANT)
        DISP_FUNCTION(CEx25bAuto, "DisplayDialog", DisplayDialog,
            VT_BOOL, VTS_NONE)
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IEx25bAuto to support typesafe
//  binding from VBA. This IID must match the GUID that is attached 
//  to the dispinterface in the .ODL file.

// {A9515AD7-5B85-11D0-848F-00400526305B}
static const IID IID_IEx25bAuto =
{ 0xa9515ad7, 0x5b85, 0x11d0, { 0x84, 0x8f, 0x0, 0x40, 0x5, 0x26,
     0x30, 0x5b } };

BEGIN_INTERFACE_MAP(CEx25bAuto, CCmdTarget)
    INTERFACE_PART(CEx25bAuto, IID_IEx25bAuto, Dispatch)
END_INTERFACE_MAP()

// {A9515AD8-5B85-11D0-848F-00400526305B}
IMPLEMENT_OLECREATE(CEx25bAuto, "ex25b.Auto", 0xa9515ad8, 0x5b85, 
    0x11d0, 0x84, 0x8f, 0x0, 0x40, 0x5, 0x26, 0x30, 0x5b)

////////////////////////////////////////////////////////////////////
// CEx25bAuto message handlers

void CEx25bAuto::OnLongDataChanged() 
{
    TRACE("CEx25bAuto::OnLongDataChanged\n");
}
void CEx25bAuto::OnTextDataChanged() 
{
    TRACE("CEx25bAuto::OnTextDataChanged\n");
}

BOOL CEx25bAuto::DisplayDialog() 
{
    TRACE("Entering CEx25bAuto::DisplayDialog %p\n", this);
    BOOL bRet = TRUE;
    AfxLockTempMaps();  // See MFC Tech Note #3
    CWnd\* pTopWnd = CWnd::FromHandle(::GetTopWindow(NULL));
    try {
        CPromptDlg dlg /\*(pTopWnd)\*/;
        if (
m_vaTextData.vt == VT_BSTR){
            dlg.
m_strData = m_vaTextData.bstrVal; // converts 
                                                  // 
 double-byte
                                                  //  character to
                                                  //  single-byte
                                                  //  character
        }
        dlg.
m_lData = m_lData;
        if (dlg.DoModal() == IDOK) {
            
m_vaTextData = COleVariant(dlg.m_strData).Detach();
            
m_lData = dlg.m_lData;
            bRet = TRUE;
        }
        else {
            bRet =  FALSE;
        }
    }
    catch (CException\* pe) {
        TRACE("Exception: failure to display dialog\n");
        bRet =  FALSE;
        pe->Delete();
    }
    AfxUnlockTempMaps();
    return bRet;
}

**Figure 25-6.** _The ex25bAuto.cpp implementation file._

The two properties, LongData and TextData, are represented by class data members _m_lData_ and _m_vaTextData_, both initialized in the constructor. When the LongData property was added in ClassWizard, a notification function, _OnLongDataChanged_, was specified. This function is called whenever the controller changes the property value. Notification functions apply only to properties that are represented by data members. Don't confuse this notification with the notifications that ActiveX controls give their container when a bound property changes.

The _DisplayDialog_ member function, which is the _DisplayDialog_ method, is ordinary except that the _AfxLockTempMaps_ and _AfxUnlockTempMaps_ functions are necessary for cleaning up temporary object pointers that would normally be deleted in an EXE program's idle loop.

What about the Excel VBA code? Here are the three macros and the global declarations:

Dim Dllcomp As Object
Private Declare Sub CoFreeUnusedLibraries Lib "OLE32" ()

Sub LoadDllComp()
    Set Dllcomp = CreateObject("Ex25b.Auto")
    Range("C3").Select
    Dllcomp.LongData = Selection.Value
    Range("D3").Select
    Dllcomp.TextData = Selection.Value
End Sub

Sub RefreshDllComp() \`Gather Data button
    Range("C3").Select
    Dllcomp.LongData = Selection.Value
    Range("D3").Select
    Dllcomp.TextData = Selection.Value
    Dllcomp.DisplayDialog
    Range("C3").Select
    Selection.Value = Dllcomp.LongData
    Range("D3").Select
    Selection.Value = Dllcomp.TextData
End Sub
    
Sub UnloadDllComp()
    Set Dllcomp = Nothing
    Call CoFreeUnusedLibraries
End Sub

The first line in _LoadDllComp_ creates a component object as identified by the registered name _Ex25b.Auto_. The _RefreshDllComp_ macro accesses the component object's LongData and TextData properties. The first time you run _LoadDllComp_, it loads the DLL and constructs an _Ex25b.Auto_ object. The second time you run _LoadDllComp_, something curious happens: a second object is constructed, and the original object is destroyed. If you run _LoadDllComp_ from another copy of the workbook, you get two separate _Ex25b.Auto_ objects. Of course, there's only one mapping of ex25b.dll in memory at any time unless you're running more than one Excel process.

Look closely at the _UnloadDllComp_ macro. When the "Set Dllcomp = Nothing" statement is executed, the DLL is disconnected, but it's not unmapped from Excel's address space, which means the component's _ExitInstance_ function is not called. The _CoFreeUnusedLibraries_ function calls the exported _DllCanUnloadNow_ function for each component DLL and, if that function returns _TRUE_, _CoFreeUnusedLibraries_ frees the DLL. MFC programs call _CoFreeUnusedLibraries_ in the idle loop (after a one-minute delay), but Excel doesn't. That's why _UnloadDllComp_ must call _CoFreeUnusedLibraries_ after disconnecting the component.

> NOTE
> 
> The _CoFreeUnusedLibraries_ function doesn't do anything in Windows NT 3.51 unless you have Service Pack 2 (SP2) installed.

**The EX25C SDI Automation Component**

**EXE Example—with User Interface**


-----------------------------------------------------------------------------

This Automation component example illustrates the use of a document component class in an SDI application in which a new process is started for each object. This component program demonstrates an indexed property plus a method that constructs a new COM object.

The first Automation component example you saw, EX25A, didn't have a user interface. The global class factory constructed a _CBank_ object that did the component's work. What if you want your EXE component to have a window? If you've bought into the MFC document_view architecture, you'll want the document, view, and frame, with all the benefits they provide.

Suppose you created a regular MFC application and then added a COM-creatable class such as _CBank_. How do you attach the _CBank_ object to the document and view? From a _CBank_ class member function, you could navigate through the application object and main frame to the current document or view, but you'd have a tough time in an MDI application if you encountered several component objects and several documents. There is a better way. You make the document class the creatable class, and you have the full support of AppWizard for this task. This is true for both MDI and SDI applications.

The MDI Autoclik example demonstrates how COM triggers the construction of new document, view, and child frame objects each time an Automation client creates a new component object. Because the EX25C example is an SDI program, Windows starts a new process each time the client creates an object. Immediately after the program starts, COM, with the help of the MFC application framework, constructs not only the Automation-aware document but also the view and the main frame window.

Now is a good time to experiment with the EX25C application, which was first generated by AppWizard with the Automation option checked. It's a Windows-based alarm clock program designed to be manipulated from an Automation client such as Excel. EX25C has the following properties and methods.

**Name**

**Description**

Time

_DATE_ property that holds a _COM DATE_ (_m_vaTime_)

Figure

Indexed _VARIANT_ property for the four figures on the clockface (_m_strFigure[]_)

_RefreshWin_

Method that invalidates the view window and brings the main frame window to the top (_Refresh_)

_ShowWin_

Method that displays the application's main window (_ShowWin_)

_CreateAlarm_

Method that creates a _CAlarm_ object and returns its _IDispatch_ pointer (_CreateAlarm_)

Here are the steps for building and running EX25C from the companion CD-ROM:

2.  **From Visual C++, open the workspace \vcpp32\ex25c\ex25c.dsw.** Build the project to produce the ex25c.exe file in the project's Debug subdirectory.
    
3.  **Run the program once to register it.** The program is designed to be executed either as a stand-alone application or as an Automation component. When you run it from Windows or from Visual C++, it updates the Registry and displays the face of a clock with the characters XII, III, VI, and IX at the 12, 3, 6, and 9 o'clock positions. Exit the program.
    
4.  **Load the Excel workbook file \vcpp32\ex25c\ex25c.xls.**The worksheet should look like the one shown here.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g25og09x.gif)]
    
    Click the Load Clock button, and then double-click the Set Alarm button. (There could be a long delay after you click the Load Clock button, depending on your system.) The clock should appear as shown below, with the letter _A_ indicating the alarm setting.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/g25og10.gif)
    
    If you've started the component program from the debugger, you can watch the Debug window to see when _InitInstance_ is called and when the document object is constructed.
    
    If you're wondering why there's no menu, it's because of the following statement in the _CMainFrame::PreCreateWindow_ function:
    
    cs.hMenu = NULL;
    

5.  **Close the Clock program and then click the Unload Clock button.** If you've started the component program from the debugger, you can watch the Debug window for a message box that indicates that the _ExitInstance_ function is called.

AppWizard did most of the work of setting up the document as an Automation component. In the derived application class _CEx25cApp_, it generated a data member for the component, as shown here:

public:
    COleTemplateServer m_server;

The MFC _COleTemplateServer_ class is derived from _COleObjectFactory_. It is designed to create a COM document object when a client calls _IClassFactory::CreateInstance_. The class ID comes from the global _clsid_ variable defined in ex25c.cpp. The human-readable program ID (Ex25c.Document) comes from the _IDR_MAINFRAME_ string resource.

In the _InitInstance_ function (in ex25c.cpp), AppWizard generated the code below, which connects the component object (the document) to the application's document template.

CSingleDocTemplate\* pDocTemplate;
pDocTemplate = new CSingleDocTemplate(
    IDR_MAINFRAME,
    RUNTIME_CLASS(CEx25cDoc),
    RUNTIME_CLASS(CMainFrame),     // main SDI frame window
    RUNTIME_CLASS(CEx25cView));
AddDocTemplate(pDocTemplate);
.
.
.
m_server.ConnectTemplate(clsid, pDocTemplate, TRUE);

Now all the plumbing is in place for COM and the framework to construct the document, together with the view and frame. When the objects are constructed, however, the main window is not made visible. That's your job. You must write a method that shows the window.

The following _UpdateRegistry_ call from the _InitInstance_ function updates the Windows Registry with the contents of the project's _IDR_MAINFRAME_ string resource:

m_server.UpdateRegistry(OAT_DISPATCH_OBJECT);

The following dispatch map in the ex25cDoc.cpp file shows the properties and methods for the _CEx25cDoc_ class. Note that the Figure property is an indexed property that ClassWizard can generate if you specify a parameter. Later you'll see the code you have to write for the _GetFigure_ and _SetFigure_ functions.

BEGIN_DISPATCH_MAP(CEx25cDoc, CDocument)
    //{{AFX_DISPATCH_MAP(CEx25cDoc)
    DISP_PROPERTY_NOTIFY(CEx25cDoc, "Time", 
m_time, OnTimeChanged,
        VT_DATE)
    DISP_FUNCTION(CEx25cDoc, "ShowWin", ShowWin, VT_EMPTY, VTS_NONE)
    DISP_FUNCTION(CEx25cDoc, "CreateAlarm", CreateAlarm,
        VT_DISPATCH, VTS_DATE)
    DISP_FUNCTION(CEx25cDoc, "RefreshWin", Refresh, VT_EMPTY,
        VTS_NONE)
    DISP_PROPERTY_PARAM(CEx25cDoc, "Figure", GetFigure, SetFigure, 
        VT_VARIANT, VTS_I2)
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

The _ShowWin_ and _RefreshWin_ member functions aren't very interesting, but the _CreateAlarm_ method is worth a close look. Here's the corresponding _CreateAlarm_ member function:

LPDISPATCH CEx25cDoc::CreateAlarm(DATE time)
{
    TRACE("Entering CEx25cDoc::CreateAlarm, time = %f\n", time);
    // OLE deletes any prior CAlarm object
    m_pAlarm = new CAlarm(time);
    return m_pAlarm->GetIDispatch(FALSE);   // no AddRef here
}

We've chosen to have the component create an alarm object when a controller calls _CreateAlarm._ _CAlarm_ is an Automation component class that we've generated with ClassWizard. It is not COM-creatable, which means there's no _IMPLEMENT_OLECREATE_ macro and no class factory. The _CreateAlarm_ function constructs a _CAlarm_ object and returns an _IDispatch_ pointer. (The _FALSE_ parameter for _CCmdTarget::GetIDispatch_ means that the reference count is not incremented; the _CAlarm_ object already has a reference count of 1 when it is constructed.)

The _CAlarm_ class is declared in alarm.h as follows:

class CAlarm : public CCmdTarget
{
    DECLARE_DYNAMIC(CAlarm)
public:
    CAlarm(DATE time);

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAlarm)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

// Implementation
protected:
    virtual ~CAlarm();

    // Generated message map functions
    //{{AFX_MSG(CAlarm)
        // NOTE - the ClassWizard will add and remove member 
        //  functions here.
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
    // Generated OLE dispatch map functions
public:
    //{{AFX_DISPATCH(CAlarm)
    DATE m_time;
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()
};

Notice the absence of the _DECLARE_DYNCREATE_ macro.

Alarm.cpp contains a dispatch map, as follows:

BEGIN_DISPATCH_MAP(CAlarm, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CAlarm)
    DISP_PROPERTY(CAlarm, "Time", 
m_time, VT_DATE)
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

Why do we have a _CAlarm_ class? We could have added an AlarmTime property in the _CEx25cDoc_ class instead, but then we would have needed another property or method to turn the alarm on and off. By using the _CAlarm_ class, what we're really doing is setting ourselves up to support multiple alarms—a collection of alarms.

To implement an Automation collection, we would write another class, _CAlarms_, that would contain the methods _Add, Remove,_ and _Item_. _Add_ and _Remove_ are self-explanatory; _Item_ returns an IDispatch pointer for a collection element identified by an index, numeric, or some other key. We would also implement a read-only Count property that returned the number of elements. The document class (which owns the collection) would have an _Alarms_ method with an optional _VARIANT_ parameter. If the parameter were omitted, the method would return the _IDispatch_ pointer for the collection. If the parameter specified an index, the method would return an _IDispatch_ pointer for the selected alarm.

> NOTE
> 
> If we wanted our collection to support the VBA "For Each" syntax, we'd have some more work to do. We'd add an _IEnum VARIANT_ interface to the _CAlarms_ class to enumerate the collection of variants and implement the _Next_ member function of this interface to step through the collection. Then we'd add a _CAlarms_ method named __NewEnum_ that returned an _IEnumVARIANT_ interface pointer. If we wanted the collection to be general, we'd allow separate enumerator objects (with an _IEnum VARIANT_ interface) and we'd implement the other _IEnumVARIANT_ functions—_Skip_, _Reset_, and _Clone_.

The Figure property is an indexed property, which makes it interesting. The Figure property represents the four figures on the clock face—XII, III, VI, and IX. It's a _CString_ array, so we can use Roman numerals. Here's the declaration in ex25cDoc.h:

public:
    CString m_strFigure[4];

And here are the _GetFigure_ and _SetFigure_ functions in ex25cDoc.cpp:

VARIANT CEx25cDoc::GetFigure(short n) 
{
    TRACE("Entering CEx25cDoc::GetFigure -
-           n = %d 
m_strFigure[n] = %s\n",
           n, 
m_strFigure[n]);
    return COleVariant(m_strFigure[n]).Detach();
}

void CEx25cDoc::SetFigure(short n, const VARIANT FAR& newValue) 
{
    TRACE("Entering CEx25cDoc::SetFigure -- n = %d, vt = %d\n", n, 
          newValue.vt);
    COleVariant vaTemp;
    vaTemp.ChangeType(VT_BSTR, (COleVariant\*) &newValue);
    m_strFigure[n] = vaTemp.bstrVal; // converts double-to-single
}

These functions tie back to the _DISP_PROPERTY_PARAM_ macro in the _CEx25cDoc_ dispatch map. The first parameter is the index number, specified as a short integer by the last macro parameter. Property indexes don't have to be integers, and the index can have several components (row and column numbers, for example). The _ChangeType_ call in _SetFigure_ is necessary because the controller might otherwise pass numbers instead of strings.

You've just seen collection properties and indexed properties. What's the difference? A controller can't add or delete elements of an indexed property, but it can add elements to a collection and it can delete elements from a collection.

What draws the clock face? As you might expect, it's the _OnDraw_ member function of the view class. This function uses _GetDocument_ to get a pointer to the document object, and then it accesses the document's property data members and method member functions.

The Excel macro code appears below.

Dim Clock As Object
Dim Alarm As Object

Sub LoadClock()
    Set Clock = CreateObject("ex25c.Document")
    Range("A3").Select
    n = 0
    Do Until n = 4
        Clock.figure(n) = Selection.Value
        Selection.Offset(0, 1).Range("A1").Select
        n = n + 1
    Loop
    RefreshClock
    Clock.ShowWin
End Sub

Sub RefreshClock()
    Clock.Time = Now()
    Clock.RefreshWin
End Sub
    
Sub CreateAlarm()
    Range("E3").Select
    Set Alarm = Clock.CreateAlarm(Selection.Value)
    RefreshClock
End Sub
    
Sub UnloadClock()
    Set Clock = Nothing
End Sub

Notice the Set Alarm statement in the _CreateAlarm_ macro. It calls the _CreateAlarm_ method to return an _IDispatch_ pointer, which is stored in an object variable. If the macro is run a second time, a new alarm is created, but the original one is destroyed because its reference count goes to 0.

> WARNING
> 
> You've seen a modal dialog in a DLL (EX25B) and you've seen a main frame window in an EXE (EX25C). Be careful with modal dialogs in EXEs. It's fine to have an About dialog that is invoked directly by the component program, but it isn't a good idea to invoke a modal dialog in an out-of-process component method function. The problem is that once the modal dialog is on the screen, the user can switch back to the client program. MFC clients handle this situation with a special "Server Busy" message box, which appears right away. Excel does something similar, but it waits 30 seconds, and this could confuse the user.

**The EX25D Automation Client Example**
---------------------------------------

So far, you've seen C++ Automation component programs. Now you'll see a C++ Automation client program that runs all the previous components and also controls Microsoft Excel 97. The EX25D program was originally generated by AppWizard, but without any COM options. It was easier to add the COM code than it would have been to rip out the component-specific code. If you do use AppWizard to build such an Automation controller, add the following line at the end of StdAfx.h:

#include <afxdisp.h>

Then add this call at the beginning of the application's _InitInstance_ function:

AfxOleInit();

To prepare EX25D, open the \vcpp32\ex25d\ex25d project and do the build. Run the application from the debugger, and you'll see a standard SDI application with a menu structure similar to that shown in Figure 25-7.

If you have built and registered all the components, you can test them from EX25D. Notice that the DLL doesn't have to be copied to the \Winnt\System32 directory because Windows finds it through the Registry. For some components, you'll have to watch the Debug window to verify that the test results are correct. The program is reasonably modular. Menu commands and update command UI events are mapped to the view class. Each component object has its own C++ controller class and an embedded data member in ex25dView.h. We'll look at each part separately after we delve into type libraries.

![](c:/dl/books/windows/msvc5th/invcpp5/images/f25og07x.gif)

**Figure 25-7.** _A sample menu structure for a standard SDI application._

**Type Libraries and ODL Files**

We've told you that type libraries aren't necessary for the MFC _IDispatch_ implementation, but Visual C++ has been quietly generating and updating type libraries for all your components. What good are these type libraries? VBA can use a type library to browse your component's methods and properties, and it can use the type library for improved access to properties and methods, a process called early binding described later in this chapter. But we're building a C++ client program here, not a VBA program. It so happens that ClassWizard can read a component's type library and use the information to generate C++ code for the client to use to "drive" an Automation component.

> NOTE
> 
> AppWizard initializes a project's Object Description Language (ODL) file when you first create it. ClassWizard edits this file each time you generate a new Automation component class or add properties and methods to an existing class. Unlike it does with the ClassWizard (CLW) file, ClassWizard can't rebuild an ODL file from the contents of your source files. If you mess up your ODL file, you'll have to re-create it manually.

When you were adding properties and methods to your component classes, ClassWizard was updating the project's ODL file. This file is a text file that describes the component in an ODL. (Your GUID will be different if you used AppWizard to generate this project.) Here's the ODL file for the bank component:

// ex25a.odl : type library source for ex25a.exe

// This file will be processed by the MIDL compiler to produce the
//  type library (ex25a.tlb).

[ uuid(85D56DE4-789D-11D0-92E1-D74D1B9CCD32), version(1.0) ]
library Ex25a
{
    importlib("stdole32.tlb");

    // Primary dispatch interface for CBank

    [ uuid(99EA95E1-78A1-11D0-92E1-D74D1B9CCD32) ]
    dispinterface IBank
    {
        properties:
            // NOTE - ClassWizard will maintain property information
            //  here.
            //  Use extreme caution when editing this section.
            //{{AFX_ODL_PROP(CBank)
            [id(1)] double Balance;
            //}}AFX_ODL_PROP

        methods:
        // NOTE - ClassWizard will maintain method information here.
        // Use extreme caution when editing this section.
        //{{AFX_ODL_METHOD(CBank)
        [id(2)] double Withdrawal(double dAmount);
        [id(3)] void Deposit(double dAmount);
        //}}AFX_ODL_METHOD

    };

    // Class information for CBank

        [ uuid(99EA95E2-78A1-11D0-92E1-D74D1B9CCD32) ]
        coclass Bank
        {
            [default] dispinterface IBank;
        };

    // {{AFX_APPEND_ODL}}
};

The ODL file has a unique GUID type library identifier, 85D56DE4-789D-11D0-92E1-D74D1B9CCD32, and it completely describes the bank component's properties and methods under a dispinterface named _IBank_. In addition, it specifies the dispinterface GUID, 99EA95E1-78A1-11D0-92E1-D74D1B9CCD32, which is the same GUID that's in the interface map of the _CBank_ class. You'll see the significance of this GUID when you read the "VBA Early Binding" section near the end of this chapter. The CLSID, 99EA95E2-78A1-11D0-92E1-D74D1B9CCD32, is what a VBA browser can actually use to load your component.

Anyway, when you build your component project, Visual C++ invokes the MIDL utility, which reads the ODL file and generates a binary TLB file in your project's debug or release subdirectory. Now when you develop a C++ client program, you can ask ClassWizard to generate a driver class from the component project's TLB file.

> NOTE
> 
> The MIDL utility generates the type library in a stand-alone TLB file, and that's what Automation controllers such as Excel look for. ActiveX controls have their type libraries bound into their resources.

To actually do this, you click the ClassWizard Add Class button and then select From A Type Library from the drop-down list. You navigate to the component project's TLB file, and then ClassWizard shows you a dialog similar to the illustration below.

![](c:/dl/books/windows/msvc5th/invcpp5/images/g25og11.gif)

_IBank_ is the dispinterface specified in the ODL file. You can keep this name for the class if you want, and you can specify the H and CPP filenames. If a type library contains several interfaces you can make multiple selections. You'll see the generated controller classes in the sections that follow.

**The Controller Class for ex25a.exe**

ClassWizard generated the _IBank_ class (derived from _COleDispatchDriver_) listed in Figure 25-8. Look closely at the member function implementations. Note the first parameters of the _GetProperty_, _SetProperty_, and _InvokeHelper_ function calls. These are hard-coded DISPIDs for the component's properties and methods, as determined by the component's dispatch map sequence.

> WARNING
> 
> If you use ClassWizard to delete a property and then add the property back, you'll probably change the component's dispatch IDs. That means that you'll have to regenerate or edit the controller class so that the IDs match.

**BANKDRIVER.H**

class IBank : public COleDispatchDriver
{
public:
    IBank() {} // calls COleDispatchDriver default constructor
    IBank(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
    IBank(const IBank& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
    double GetBalance();
    void SetBalance(double);

// Operations
public:
    double Withdrawal(double dAmount);
    void Deposit(double dAmount);
}; 

**BANKDRIVER.CPP**

#include "StdAfx.h"
#include "BankDriver.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE
__;
#endif

////////////////////////////////////////////////////////////////////
// IBank properties

double IBank::GetBalance()
{
    double result;
    GetProperty(0x1, VT_R8, (void\*)&result);
    return result;
}
void IBank::SetBalance(double propVal)
{
    SetProperty(0x1, VT_R8, propVal);
}

////////////////////////////////////////////////////////////////////
// IBank operations

double IBank::Withdrawal(double dAmount)
{
    double result;
    static BYTE parms[] =
        VTS_R8;
    InvokeHelper(0x2, DISPATCH_METHOD, VT_R8, (void\*)&result, parms,
                 dAmount);
    return result;
}

void IBank::Deposit(double dAmount)
{
    static BYTE parms[] =
        VTS_R8;
    InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
                 dAmount);
}

**Figure 25-8.** _The_ IBank _class listing._

The _CEx25dView_ class has a data member _m_bank_ of class _IBank_. The _CEx25dView_ member functions for the Ex25a.Bank component are listed below. They are hooked up to options on the EX25D main menu. Of particular interest is the _OnBankoleLoad_ function. The _COleDispatchDriver::CreateDispatch_ function loads the component program (by calling _CoGetClassObject_ and _IClassFactory::CreateInstance_) and then calls _QueryInterface_ to get an _IDispatch_ pointer, which it stores in the object's _m_lpDispatch_ data member. The _COleDispatchDriver::ReleaseDispatch_ function, called in _OnBankoleUnload_, calls _Release_ on the pointer.

void CEx25dView::OnBankoleLoad() 
{
   if(!m_bank.CreateDispatch("Ex25a.Bank")) {
        AfxMessageBox("Ex25a.Bank component not found");
        return;
   }
}

void CEx25dView::OnUpdateBankoleLoad(CCmdUI\* pCmdUI) 
{
    pCmdUI->Enable(m_bank.m_lpDispatch == NULL);
}
 
void CEx25dView::OnBankoleTest() 
{
    m_bank.Deposit(20.0);
    m_bank.Withdrawal(15.0);
    TRACE("new balance = %f\n", 
m_bank.GetBalance());
}

void CEx25dView::OnUpdateBankoleTest(CCmdUI\* pCmdUI) 
{
    pCmdUI->Enable(m_bank.m_lpDispatch != NULL);
}

void CEx25dView::OnBankoleUnload() 
{   
    m_bank.ReleaseDispatch();
}

void CEx25dView::OnUpdateBankoleUnload(CCmdUI\* pCmdUI) 
{
    pCmdUI->Enable(m_bank.m_lpDispatch != NULL);
}

**The Controller Class for ex25b.dll**

Figure 25-9 shows the class header file generated by ClassWizard.

**AUTODRIVER.H**

class IEx25bAuto : public COleDispatchDriver
{
public:
    IEx25bAuto() {} // calls COleDispatchDriver default constructor
    IEx25bAuto(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
    IEx25bAuto(const IEx25bAuto& dispatchSrc) :
        COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
    long GetLongData();
    void SetLongData(long);
    VARIANT GetTextData();
    void SetTextData(const VARIANT&);

// Operations
public:
    BOOL DisplayDialog();
};

**Figure 25-9.** _The_ Ex25bAuto _class header file._

Notice that each property requires separate _Get_ and _Set_ functions in the client class, even though a data member in the component represents the property.

The view class header has a data member _m_auto_ of class _IEx25bAuto_. Here are some DLL-related command handler member functions from ex25dView.cpp:

void CEx25dView::OnDlloleGetdata() 
{
    m_auto.DisplayDialog();
    COleVariant vaData = 
m_auto.GetTextData();
    ASSERT(vaData.vt == VT_BSTR);
    CString strTextData = vaData.bstrVal;
    long lData = 
m_auto.GetLongData();
    TRACE("CEx25dView::OnDlloleGetdata — long = %ld, text = %s\n",
          lData, strTextData);
}

void CEx25dView::OnUpdateDlloleGetdata(CCmdUI\* pCmdUI) 
{
    pCmdUI->Enable(m_auto.m_lpDispatch != NULL);
}

void CEx25dView::OnDlloleLoad() 
{
    if(!m_auto.CreateDispatch("Ex25b.Auto")) {
        AfxMessageBox("Ex25b.Auto component not found");
        return;
    }
    m_auto.SetTextData(COleVariant("test"));  // testing
    m_auto.SetLongData(79);  // testing
    // verify dispatch interface
    //  {A9515AD7-5B85-11D0-848F-00400526305B}
    static const IID IID_IEx25bAuto =
        { 0xa9515ad7, 0x5b85, 0x11d0, { 0x84, 0x8f, 0x0, 0x40, 0x5,
            0x26, 0x30, 0x5b } };
    LPDISPATCH p;
    HRESULT hr = 
m_auto.m_lpDispatch->QueryInterface(IID_IEx25bAuto,
        (void\*\*) &p);
    TRACE("OnDlloleLoad — QueryInterface result = %x\n", hr);
    p->Release();
}

void CEx25dView::OnUpdateDlloleLoad(CCmdUI\* pCmdUI) 
{
    pCmdUI->Enable(m_auto.m_lpDispatch == NULL);
}

void CEx25dView::OnDlloleUnload() 
{
    m_auto.ReleaseDispatch();
}

void CEx25dView::OnUpdateDlloleUnload(CCmdUI\* pCmdUI) 
{
    pCmdUI->Enable(m_auto.m_lpDispatch != NULL);
}

**The Controller Class for ex25c.exe**

Figure 25-10 shows the headers for the _IEx25c_ and _IAlarm_ classes, which drive the EX25C Automation component.

**CLOCKDRIVER.H**

class IEx25c : public COleDispatchDriver
{
public:
    IEx25c() {} // calls COleDispatchDriver default constructor
    IEx25c(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
    IEx25c(const IEx25c& dispatchSrc) : 
        COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
    DATE GetTime();
    void SetTime(DATE);

// Operations
public:
    void ShowWin();
    LPDISPATCH CreateAlarm(DATE time);
    void RefreshWin();
    void SetFigure(short n, const VARIANT& newValue);
    VARIANT GetFigure(short n);
};

class IAlarm : public COleDispatchDriver
{
public:
    IAlarm() {} // calls COleDispatchDriver default constructor
    IAlarm(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
    IAlarm(const IAlarm& dispatchSrc) :
        COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
    DATE GetTime();
    void SetTime(DATE);

// Operations
public:
};

**Figure 25-10.** _The_ IEx25c _and_ IAlarm _class header files._

Of particular interest is the _IEx25c::CreateAlarm_ member function in ClockDriver.cpp:

LPDISPATCH IEx25c::CreateAlarm(DATE time)
{
    LPDISPATCH result;
    static BYTE parms[] =
        VTS_DATE;
    InvokeHelper(0x3, DISPATCH_METHOD, VT_DISPATCH, (void\*)&result,
        parms, time);
    return result;
}

This function can be called only after the clock object (document) has been constructed. It causes the EX25C component to construct an alarm object and return an _IDispatch_ pointer with a reference count of 1. The _COleDispatchDriver::AttachDispatch_ function connects that pointer to the client's _m_alarm_ object, but if that object already has a dispatch pointer, the old pointer is released. That's why, if you watch the Debug window, you'll see that the old EX25C instance exits immediately after you ask for a new instance. You'll have to test this behavior with the Excel driver because EX25D disables the Load menu option when the clock is running.

The view class has the data members _m_clock_ and _m_alarm_. Here are the view class command handlers:

void CEx25dView::OnClockoleCreatealarm() 
{
    CAlarmDialog dlg;
    if (dlg.DoModal() == IDOK) {
        COleDateTime dt(1995, 12, 23, dlg.
m_nHours, dlg.m_nMinutes,
            dlg.
m_nSeconds);
        LPDISPATCH pAlarm = 
m_clock.CreateAlarm(dt);
        m_alarm.AttachDispatch(pAlarm);  // releases prior object!
        m_clock.RefreshWin();
    }
}
void CEx25dView::OnUpdateClockoleCreatealarm(CCmdUI\* pCmdUI) 
{
    pCmdUI->Enable(m_clock.m
_lpDispatch != NULL);
}

void CEx25dView::OnClockoleLoad() 
{
   if(!m_clock.CreateDispatch("Ex25c.Document")) {
        AfxMessageBox("Ex25c.Document component not found");
        return;
   }
    m_clock.SetFigure(0, COleVariant("XII"));
    m_clock.SetFigure(1, COleVariant("III"));
    m_clock.SetFigure(2, COleVariant("VI"));
    m_clock.SetFigure(3, COleVariant("IX"));
    OnClockoleRefreshtime();
    m_clock.ShowWin();
}

void CEx25dView::OnUpdateClockoleLoad(CCmdUI\* pCmdUI) 
{
    pCmdUI->Enable(m_clock.m
_lpDispatch == NULL);
}

void CEx25dView::OnClockoleRefreshtime() 
{
    COleDateTime now = COleDateTime::GetCurrentTime();
    m_clock.SetTime(now);
    m_clock.RefreshWin();
}

void CEx25dView::OnUpdateClockoleRefreshtime(CCmdUI\* pCmdUI) 
{
    pCmdUI->Enable(m_clock.m_lpDispatch != NULL);
}

void CEx25dView::OnClockoleUnload() 
{
    m_clock.ReleaseDispatch();
}

void CEx25dView::OnUpdateClockoleUnload(CCmdUI\* pCmdUI) 
{
    pCmdUI->Enable(m_clock.m
_lpDispatch != NULL);
}

**Controlling Microsoft Excel**

The EX25D program contains code that loads Excel, creates a workbook, and reads from and writes to cells from the active worksheet. Controlling Excel is exactly like controlling an MFC Automation component, but you need to know about a few Excel peculiarities.

If you study Excel VBA, you'll notice that you can use more than 100 "objects" in your programs. All of these objects are accessible through Automation, but if you write an MFC Automation client program, you'll need to know about the objects' properties and methods. Ideally, you'd like a C++ class for each object, with member functions coded to the proper dispatch IDs.

Excel has its own type library, found in the file Excel8.olb, usually in the \Program Files\Microsoft Office\Office directory. ClassWizard can read this file—exactly as it reads TLB files—to create C++ driver classes for individual Excel objects. It makes sense to select the objects you need and then combine the classes into a single pair of files, as shown in Figure 25-11.

![](c:/dl/books/windows/msvc5th/invcpp5/images/f25og11.gif)

**Figure 25-11.** _ClassWizard can create C++ classes for the Excel objects listed in Excel8.olb._

You might need to edit the generated code to suit your needs. Let's look at an example. If you use ClassWizard to generate a driver class for the _Worksheet_ object, you get a _GetRange_ member function, as shown here:

LPDISPATCH _Worksheet::GetRange(const VARIANT& Cell1,
                                const VARIANT& Cell2)
{
    LPDISPATCH result;
    static BYTE parms[] = VTS_VARIANT VTS_VARIANT;
    InvokeHelper(0xc5, DISPATCH_PROPERTYGET, VT_DISPATCH,
        (void\*)&result, parms, &Cell1, &Cell2);
    return result;
}

You know (from the Excel VBA documentation) that you can call the method with either a single cell (one parameter) or a rectangular area specified by two cells (two parameters). Remember: you can omit optional parameters in a call to _InvokeHelper_. Now it makes sense to add a second overloaded _GetRange_ function with a single cell parameter like this:

LPDISPATCH _Worksheet::GetRange(const VARIANT& Cell1) // added
{
    LPDISPATCH result;
    static BYTE parms[] = VTS_VARIANT;
    InvokeHelper(0xc5, DISPATCH_PROPERTYGET, VT_DISPATCH,
        (void\*)&result, parms, &Cell1);
    return result;
}

How do you know which functions to fix up? They're the functions you decide to use in your program. You'll have to read the Excel VBA reference manual to figure out the required parameters and return values. Perhaps someday soon someone will write a set of C++ Excel controller classes.

The EX25D program uses the Excel objects and contains the corresponding classes shown in the table below. All the code for these objects is contained in the files excel8.h and excel8.cpp.

**Object/Class**

**View Class Data Member**

__Application_

_m_app_

_Range_

_m_range[5]_

__Worksheet_

_m_worksheet_

_Workbooks_

_m_workbooks_

_Worksheets_

_m_worksheets_

The following view member function, _OnExceloleLoad_, handles the Excel Comp Load menu command. This function must work if the user already has Excel running on the desktop. The COM _GetActiveObject_ function tries to return an _IUnknown_ pointer for Excel. _GetActiveObject_ requires a class ID, so we must first call _CLSIDFromProgID_. If _GetActiveObject_ is successful, we call _QueryInterface_ to get an _IDispatch_ pointer and we attach it to the view's _m_app_ controller object of class __Application_. If _GetActiveObject_ is unsuccessful, we call _COleDispatchDriver::CreateDispatch_, as we did for the other components.

void CEx25dView::OnExceloleLoad() 
{   // If Excel is already running, attach to it; otherwise, start it
    LPDISPATCH pDisp;
    LPUNKNOWN pUnk;
    CLSID clsid;
    TRACE("Entering CEx25dView::OnExcelLoad\n");
    BeginWaitCursor();
    ::CLSIDFromProgID(L"Excel.Application.8", &clsid); // from Registry
    if(::GetActiveObject(clsid, NULL, &pUnk) == S_OK) {
        VERIFY(pUnk->QueryInterface(IID_IDispatch, 
              (void\*\*) &pDisp) == S_OK);
        m_app.AttachDispatch(pDisp);
        pUnk->Release();
        TRACE(" attach complete\n");
    } 
    else {
        if(!m_app.CreateDispatch("Excel.Application.8")) {
            AfxMessageBox("Excel 97 program not found");
        }
        TRACE(" create complete\n");
    }
    EndWaitCursor();
}

_OnExceloleExecute_ is the command handler for the Execute item in the Excel Comp menu. Its first task is to find the Excel main window and bring it to the top. We must write some Windows code here because a method for this purpose couldn't be found. We must also create a workbook if no workbook is currently open.

We have to watch our method return values closely. The _Workbooks Add_ method, for example, returns an _IDispatch_ pointer for a _Workbook_ object and, of course, increments the reference count. If we generated a class for _Workbook_, we could call _COleDispatchDriver::AttachDispatch_ so that _Release_ would be called when the _Workbook_ object was destroyed. Because we don't need a _Workbook_ class, we'll simply release the pointer at the end of the function. If we don't properly clean up our pointers, we might get memory-leak messages from the Debug version of MFC.

The rest of the _OnExceloleExecute_ function accesses the cells in the worksheet. It's easy to get and set numbers, dates, strings, and formulas. The C++code is similar to the VBA code you would write to do the same job.

void CEx25dView::OnExceloleExecute() 
{
   LPDISPATCH pRange, pWorkbooks;
    
   CWnd\* pWnd = CWnd::FindWindow("XLMAIN", NULL);
   if (pWnd != NULL) {
     TRACE("Excel window found\n");
     pWnd->ShowWindow(SW_SHOWNORMAL);
     pWnd->UpdateWindow();
     pWnd->BringWindowToTop();
   }

   m_app.SetSheetsInNewWorkbook(1);
   
   VERIFY(pWorkbooks = m_app.GetWorkbooks());
   m_workbooks.AttachDispatch(pWorkbooks);

   LPDISPATCH pWorkbook = NULL;
   if (m_workbooks.GetCount() == 0) {
      // Add returns a Workbook pointer, but we
      //  don't have a Workbook class
      pWorkbook = 
m_workbooks.Add(); // Save the pointer for
                                     //  later release
   }
   LPDISPATCH pWorksheets = 
m_app.GetWorksheets();
   ASSERT(pWorksheets != NULL);
   m_worksheets.AttachDispatch(pWorksheets);
   LPDISPATCH pWorksheet = 
m_worksheets.GetItem(COleVariant((short) 1));

   m_worksheet.AttachDispatch(pWorksheet);
   m_worksheet.Select();

   VERIFY(pRange = m_worksheet.GetRange(COleVariant("A1")));
   m_range[0].AttachDispatch(pRange);

   VERIFY(pRange = m_worksheet.GetRange(COleVariant("A2")));
   m_range[1].AttachDispatch(pRange);
   
   VERIFY(pRange = m_worksheet.GetRange(COleVariant("A3")));
   m_range[2].AttachDispatch(pRange);

   VERIFY(pRange = m_worksheet.GetRange(COleVariant("A3"), 
        COleVariant("C5")));
   m_range[3].AttachDispatch(pRange);

   VERIFY(pRange = m_worksheet.GetRange(COleVariant("A6")));
    m_range[4].AttachDispatch(pRange);

    m_range[4].SetValue(COleVariant(COleDateTime
                                    (1998, 4, 24, 15, 47, 8)));
    // Retrieve the stored date and print it as a string
    COleVariant vaTimeDate = 
m_range[4].GetValue();
    TRACE("returned date type = %d\n", vaTimeDate.vt);
    COleVariant vaTemp;
    vaTemp.ChangeType(VT_BSTR, &vaTimeDate);
    CString str = vaTemp.bstrVal;
    TRACE("date = %s\n", (const char\*) str);

    m_range[0].SetValue(COleVariant("test string"));

    COleVariant vaResult0 = 
m_range[0].GetValue();
    if (vaResult0.vt == VT_BSTR) {
        CString str = vaResult0.bstrVal;
        TRACE("vaResult0 = %s\n", (const char\*) str);
    }

    m_range[1].SetValue(COleVariant(3.14159));
    
    COleVariant vaResult1 = 
m_range[1].GetValue();
    if (vaResult1.vt == VT_R8) {
        TRACE("vaResult1 = %f\n", vaResult1.dblVal);
    }

    m_range[2].SetFormula(COleVariant("=$A2\*2.0"));

    COleVariant vaResult2 = 
m_range[2].GetValue();
    if (vaResult2.vt == VT_R8) {
        TRACE("vaResult2 = %f\n", vaResult2.dblVal);
    }

    COleVariant vaResult2a = 
m_range[2].GetFormula();
    if (vaResult2a.vt == VT_BSTR) {
        CString str = vaResult2a.bstrVal;
        TRACE("vaResult2a = %s\n", (const char\*) str);
    }

    m_range[3].FillRight();
    m_range[3].FillDown();

    // cleanup  
    if (pWorkbook != NULL) {
        pWorkbook->Release();
    }
}

**The EX25E Automation Client Example**
---------------------------------------

This program uses the new _#import_ directive to generate smart pointers. It behaves just like EX25D except that it doesn't run Excel. The _#import_ statements are in the StdAfx.h file to minimize the number of times the compiler has to generate the driver classes. Here is the added code:

#include <afxdisp.h>

#import "..\ex25a\debug\ex25a.tlb" rename_namespace("BankDriv") 
using namespace BankDriv;

#import "..\ex25b\debug\ex25b.tlb" rename_namespace("Ex25bDriv") 
using namespace Ex25bDriv;

#import "..\ex25c\debug\ex25c.tlb" rename_namespace("ClockDriv")
using namespace ClockDriv;

And of course you'll need to call _AfxOleInit_ in your application class _InitInstance_ member function.

The view class header contains embedded smart pointers as shown:

IEx25bAutoPtr m_auto;
IBankPtr m_bank;
IEx25cPtr m_clock;
IAlarmPtr m_alarm;

Here is the code for the view class menu command handlers:

void CEx25eView::OnBankoleLoad() 
{
    if(m_bank.CreateInstance(__uuidof(Bank)) != S_OK) {
        AfxMessageBox("Bank component not found");
        return;
    }
}

void CEx25eView::OnUpdateBankoleLoad(CCmdUI\* pCmdUI) 
{
    pCmdUI->Enable(m_bank.GetInterfacePtr() == NULL);
}

void CEx25eView::OnBankoleTest() 
{
    try {
        m_bank->Deposit(20.0);
        m_bank->Withdrawal(15.0);
        TRACE("new balance = %f\n", 
m_bank->GetBalance());
    } catch(_com_error& e) {
        AfxMessageBox(e.ErrorMessage());
    }
}

void CEx25eView::OnUpdateBankoleTest(CCmdUI\* pCmdUI) 
{
    pCmdUI->Enable(m_bank.GetInterfacePtr() != NULL);
}

void CEx25eView::OnBankoleUnload() 
{
    m_bank.Release();
}

void CEx25eView::OnUpdateBankoleUnload(CCmdUI\* pCmdUI) 
{
    pCmdUI->Enable(m_bank.GetInterfacePtr() != NULL);
}

void CEx25eView::OnClockoleCreatealarm() 
{
    CAlarmDialog dlg;
    try {
        if (dlg.DoModal() 
== IDOK) {
            COleDateTime dt(1995, 12, 23, dlg.
m_nHours, dlg.m_nMinutes, 
                dlg.
m_nSeconds);
            LPDISPATCH pAlarm = m_clock->CreateAlarm(dt);
            
m_alarm.Attach((IAlarm\*) pAlarm);  // releases prior object!
            
m_clock->RefreshWin();
        }
    } catch(_com_error& e) {
        AfxMessageBox(e.ErrorMessage());
    }
}

void CEx25eView::OnUpdateClockoleCreatealarm(CCmdUI\* pCmdUI) 
{
    pCmdUI->Enable(m_clock.GetInterfacePtr() != NULL);
}

void CEx25eView::OnClockoleLoad() 
{
    if(m_clock.CreateInstance(_
_uuidof(Document)) != S_OK) {
        AfxMessageBox("Clock component not found");
        return;
    }
    try {
        m_clock->PutFigure(0, COleVariant("XII"));
        m_clock->PutFigure(1, COleVariant("III"));
        m_clock->PutFigure(2, COleVariant("VI"));
        m_clock->PutFigure(3, COleVariant("IX"));
        OnClockoleRefreshtime();
        m_clock->ShowWin();
    } catch(_com_error& e) {
        AfxMessageBox(e.ErrorMessage());
    }
}

void CEx25eView::OnUpdateClockoleLoad(CCmdUI\* pCmdUI) 
{
    pCmdUI->Enable(m_clock.GetInterfacePtr() == NULL);
}

void CEx25eView::OnClockoleRefreshtime() 
{
    COleDateTime now = COleDateTime::GetCurrentTime();
    try {
        m_clock->PutTime(now);
        m_clock->RefreshWin();
    } catch(_com_error& e) {
        AfxMessageBox(e.ErrorMessage());
    }
}

void CEx25eView::OnUpdateClockoleRefreshtime(CCmdUI\* pCmdUI) 
{
    pCmdUI->Enable(m_clock.GetInterfacePtr() != NULL);
}

void CEx25eView::OnClockoleUnload() 
{
    m_clock.Release();
}

void CEx25eView::OnUpdateClockoleUnload(CCmdUI\* pCmdUI) 
{
    pCmdUI->Enable(m_clock.GetInterfacePtr() != NULL);
}

void CEx25eView::OnDlloleGetdata() 
{
    try {
        m_auto->DisplayDialog();
        COleVariant vaData = 
m_auto->GetTextData();
        ASSERT(vaData.vt == VT_BSTR);
        CString strTextData = vaData.bstrVal;
        long lData = 
m_auto->GetLongData();
        TRACE("CEx25dView::OnDlloleGetdata—long = %ld, text = %s\n",
              lData, strTextData);
    } catch(_com_error& e) {
        AfxMessageBox(e.ErrorMessage());
    }
}

void CEx25eView::OnUpdateDlloleGetdata(CCmdUI\* pCmdUI) 
{
    pCmdUI->Enable(m_auto.GetInterfacePtr() != NULL);
}

void CEx25eView::OnDlloleLoad() 
{
    if(m_auto.CreateInstance(__uuidof(Ex25bAuto)) != S_OK) {
        AfxMessageBox("Ex25bAuto component not found");
        return;
    }
}

void CEx25eView::OnUpdateDlloleLoad(CCmdUI\* pCmdUI) 
{
    pCmdUI->Enable(m_auto.GetInterfacePtr() == NULL);
}

void CEx25eView::OnDlloleUnload() 
{
    m_auto.Release();
}

void CEx25eView::OnUpdateDlloleUnload(CCmdUI\* pCmdUI) 
{
    pCmdUI->Enable(m_auto.GetInterfacePtr() != NULL);
}

Note the use of the _try/catch_ blocks in the functions that manipulate the components. These are particularly necessary for processing errors that occur when a component program stops running. In the previous example, EX25D, the MFC _COleDispatchDriver_ class took care of this detail.
________________________________________________________________________
7.2.14. - [VBA Early Binding](invcpp5/ch25o.htm)
----------------------------------------------------
 VBA Early Binding 

**VBA Early Binding**
=====================

When you ran the EX25A, EX25B, and EX25C components from Excel VBA, you used something called late binding. Normally, each time VBA accesses a property or a method, it calls _IDispatch::GetIDsOfNames_ to look up the dispatch ID from the symbolic name. Not only is this inefficient, VBA can't do type-checking until it actually accesses a property or a method. Suppose, for example, that a VBA program tried to get a property value that it assumed was a number, but the component provided a string instead. VBA would give you a runtime error when it executed the Property Get statement.

With early binding, VBA can preprocess the Visual Basic code, converting property and method symbols to DISPIDs before it runs the component program. In so doing, it can check property types, method return types, and method parameters, giving you compile-time error messages. Where can VBA get the advance information it needs? From the component's type library, of course. It can use that same type library to allow the VBA programmer to browse the component's properties and methods. VBA reads the type library before it even loads the component program.

**Registering a Type Library**
------------------------------

You've already seen that Visual C++ generates a TLB file for each component. For VBA to locate that type library, its location must be specified in the Windows Registry. The simplest way of doing this is to write a text REG file that the Windows Regedit program can import. Here's the ex25b.reg file for the EX25B DLL component:

REGEDIT4

[HKEY_CLASSES_ROOT\TypeLib\{A9515ACA-5B85-11D0-848F-00400526305B}]

[HKEY_CLASSES_ROOT\TypeLib\{A9515ACA-5B85-11D0-848F-00400526305B}\1.0]
@="Ex25b"

[HKEY_CLASSES_ROOT\TypeLib\{A9515ACA-5B85-11D0-848F-00400526305B}\1.0\0]

[HKEY_CLASSES_ROOT\TypeLib\{A9515ACA-5B85-11D0-848F-00400526305B}\1.0\0\win32]
@="C:\\vcpp32\\ex25b\\Debug\\ex25b.tlb"

[HKEY_CLASSES_ROOT\TypeLib\{A9515ACA-5B85-11D0-848F-00400526305B}\1.0\FLAGS]
@="0"

[HKEY_CLASSES_ROOT\TypeLib\{A9515ACA-5B85-11D0-848F-00400526305B}\1.0\HELPDIR]
@="C:\\vcpp32\\ex25b\\Debug"

[HKEY_CLASSES_ROOT\Interface\{A9515AD7-5B85-11D0-848F-00400526305B}]
@="IEx25bAuto"

[HKEY_CLASSES_ROOT\Interface\{A9515AD7-5B85-11D0-848F-00400526305B}\ProxyStubClsid]
@="{00020420-0000-0000-C000-000000000046}"

[HKEY_CLASSES_ROOT\Interface\{A9515AD7-5B85-11D0-848F-00400526305B}\ProxyStubClsid32]
@="{00020420-0000-0000-C000-000000000046}"

[HKEY_CLASSES_ROOT\Interface\{A9515AD7-5B85-11D0-848F-00400526305B}\TypeLib]
@="{A9515ACA-5B85-11D0-848F-00400526305B}"
"Version"="1.0"

Notice that this file generates subtrees under the Registry's TypeLib and Interface keys. The third entry specifies the path for the version 1.0 TLB file. The 0 subkey stands for "neutral language." If you had a multilingual application, you would have separate entries for English, French, and so forth. Browsers use the TypeLib entries, and the Interface entries are used for runtime type-checking and, for an EXE component, marshaling the dispinterface.

**How a Component Can Register Its Own Type Library**
-----------------------------------------------------

When an EXE component is run stand-alone, it can call the MFC _AfxRegisterTypeLib_ function to make the necessary Registry entries, as shown here:

VERIFY(AfxOleRegisterTypeLib(AfxGetInstanceHandle(), theTypeLibGUID,
       "ex25b.tlb"));

Shown here is _theTypeLibGUID_, a static variable of type _GUID_:

// {A9515ACA-5B85-11D0-848F-00400526305B}
static const GUID theTypeLibGUID =
{ 0xa9515aca, 0x5b85, 0x11d0, { 0x84, 0x8f, 0x00, 0x40, 0x05, 0x26,
    0x30, 0x5b } };

The _AfxRegisterTypeLib_ function is declared in the afxwin.h header, which requires __AFXDLL_ to be defined. That means you can't use it in a regular DLL unless you copy the code from the MFC source files.

**The ODL File**
----------------

Now is a good time to look at the ODL file for the same project.

// ex25b.odl : type library source for ex25b.dll

// This file will be processed by the MIDL compiler to produce the
//  type library (ex25b.tlb)

[ uuid(A9515ACA-5B85-11D0-848F-00400526305B), version(1.0) ]

// GUID for the type library—matches TypeLib Registry key and 
//  AfxOleRegisterTypeLib parameter
library Ex25b
{
    // library name for Excel's object borrower

    importlib("stdole32.tlb");
    // primary dispatch interface for CEx25bAuto

    [ uuid(A9515AD7-5B85-11D0-848F-00400526305B) ]

    // GUID from component's interface map—matches Registry Interface 
    //  entry

    dispinterface IEx25bAuto
    {
        // name used in VBA Dim statement and Object list
        properties:
            // NOTE - ClassWizard will maintain property
            //  information here.
            //  Use extreme caution when editing this section.
            //{{AFX_ODL_PROP(CEx25bAuto)
            [id(1)] long LongData;
            [id(2)] VARIANT TextData;
            //}}AFX_ODL_PROP

        methods:
            // NOTE - ClassWizard will maintain method 
            //  information here.
            //  Use extreme caution when editing this section.
            //{{AFX_ODL_METHOD(CEx25bAuto)
            [id(3)] boolean DisplayDialog();
            //}}AFX_ODL_METHOD
    };



    [ uuid(A9515AD8-5B85-11D0-848F-00400526305B) ]
    
// component's CLSID
    
    coclass Ex25bAuto
    {
        [default] dispinterface IEx25bAuto;
    };

    //{{AFX_APPEND_ODL}}
};

As you can see, numerous connections exist among the Registry, the type library, the component, and the VBA client.

> NOTE
> 
> A useful Visual C++ utility, OLEVIEW, lets you examine registered components and their type libraries.

**How Excel Uses a Type Library**
---------------------------------

Let's examine the sequence of steps Excel uses to utilize your type library:

2.  When Excel starts up, it reads the TypeLib section of the Registry to compile a list of all type libraries. It loads the type libraries for VBA and for the Excel object library.
    
3.  After starting Excel, loading a workbook, and switching to the Visual Basic Editor, the user (or workbook author) chooses References from the Tools menu and checks the EX25B LIB line.
    
    When the workbook is saved, this reference information is saved with it.
    
4.  Now the Excel user will be able to browse through the EX25B properties and methods by choosing Object Browser from the Visual Basic Editor's View menu to view the Object Browser dialog.
    
5.  To make use of the type library in your VBA program, you simply replace the line
    
    Dim DllComp as Object
    
    with
    
    Dim DllComp as IEx25bAuto
    
    The VBA program will exit immediately if it can't find _IEx25bAuto_ in its list of references.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g25og12x.gif)]
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/g25og13x.gif)
    

6.  Immediately after VBA executes the CreateObject statement and loads the component program, it calls _QueryInterface_ for _IID_IEx25bAuto_, which is defined in the Registry, the type library, and the component class's interface map. (_IEx25bAuto_ is really an _IDispatch_ interface.) This is a sort of security check. If the component can't deliver this interface, the VBA program exits. Theoretically, Excel could use the CLSID in the type library to load the component program, but it uses the CLSID from the Registry instead, just as it did in late binding mode.

**Why Use Early Binding?**
--------------------------

You might think that early binding would make your Automation component run faster. You probably won't notice any speed increase, though, because the _IDispatch::Invoke_ calls are the limiting factor. A typical MFC _Invoke_ call from a compiled C++ client to a compiled C++ component requires about 0.5 millisecond, which is pretty gross.

The browse capability that the type library provides is probably more valuable than the compiled linkage. If you are writing a C++ controller, for example, you can load the type library through various COM functions, including _LoadTypeLib_, and then you can access it through the _ITypeLib_ and _ITypeInfo_ interfaces. Plan to spend some time on that project, however, because the type library interfaces are tricky.

**Faster Client-Component Connections**
---------------------------------------

Microsoft has recognized the limitations of the _IDispatch_ interface. It's naturally slow because all data must be funneled through _VARIANT_s and possibly converted on both ends. There's a new variation called a dual interface. (A discussion of dual interfaces is beyond the scope of this book. See Kraig Brockschmidt's _Inside OLE,_ 2d ed. [Microsoft Press, 1995], for more information.) In a dual interface, you define your own custom interface, derived from _IDispatch_. The _Invoke_ and _GetIDsOfNames_ functions are included, but so are other functions. If the client is smart enough, it can bypass the inefficient _Invoke_ calls and use the specialized functions instead. Dual interfaces can support only standard Automation types, or they can support arbitrary types.

There is no direct MFC support for dual interfaces in Visual C++ 6.0, but the ACDUAL Visual C++ sample should get you started.
________________________________________________________________________
7.3. - [Chapter 26 -- Uniform Data Transfer -- Clipboard Transfer and OLE Drag and Drop](invcpp5/ch26a.htm)
----------------------------------------------------
 Chapter 26 -- Uniform Data Transfer -- Clipboard Transfer and OLE Drag and Drop  Chapter 26

Uniform Data Transfer—Clipboard Transfer and OLE Drag and Drop
==============================================================

ActiveX technology includes a powerful mechanism for transferring data within and among Microsoft Windows-based applications. The COM _IDataObject_ interface is the key element of what is known as Uniform Data Transfer. As you'll see, Uniform Data Transfer (UDT) gives you all sorts of options for the formatting and storage of your transferred data, going well beyond standard clipboard transfers.

Microsoft Foundation Class support is available for Uniform Data Transfer, but MFC's support for UDT is not so high-level as to obscure what's going on at the COM interface level. One of the useful applications of UDT is OLE Drag and Drop. Many developers want to use drag-and-drop capabilities in their applications, and drag-and-drop support means that programs now have a standard for information interchange. The MFC library supports drag-and-drop operations, and that, together with clipboard transfer, is the main focus of this chapter.
________________________________________________________________________
7.3.1. - [The IDataObject Interface](invcpp5/ch26b.htm)
----------------------------------------------------
 The IDataObject Interface 

**The _IDataObject_ Interface**
===============================

The _IDataObject_ interface is used for clipboard transfers and drag-and-drop operations, but it's also used in compound documents, ActiveX Controls, and custom OLE features. In his book _Inside OLE,_ 2d ed. (Microsoft Press, 1995) Kraig Brockschmidt says, "Think of objects as little piles of stuff." The _IDataObject_ interface helps you move those piles around, no matter what kind of stuff they contain.

If you were programming at the Win32 level, you would write C++ code that supported the _IDataObject_ interface. Your program would then construct data objects of this class, and you would manipulate those objects with the _IDataObject_ member functions. In this chapter you'll see how to accomplish the same results by using MFC's implementation of _IDataObject_. Let's start by taking a quick look at why the OLE clipboard is an improvement on the regular Windows clipboard.

**How _IDataObject_ Improves on Standard Clipboard Support**
------------------------------------------------------------

There has never been much MFC support for the Windows Clipboard. If you've written programs for the clipboard already, you've used Win32 clipboard functions such as _OpenClipboard_, _CloseClipboard_, _GetClipboardData_, and _SetClipboardData_. One program copies a single data element of a specified format to the clipboard, and another program selects the data by format code and pastes it. Standard clipboard formats include global memory (specified by an _HGLOBAL_ variable) and various GDI objects, such as bitmaps and metafiles (specified by their handles). Global memory can contain text as well as custom formats.

The _IDataObject_ interface picks up where the Windows Clipboard leaves off. To make a long story short, you transfer a single _IDataObject_ pointer to or from the clipboard instead of transferring a series of discrete formats. The underlying data object can contain a whole array of formats. Those formats can carry information about target devices, such as printer characteristics, and they can specify the data's aspect or view. The standard aspect is content. Other aspects include an icon for the data and a thumbnail picture.

Note that the _IDataObject_ interface specifies the storage medium of a data object format. Conventional clipboard transfer relies exclusively on global memory. The _IDataObject_ interface permits the transmission of a disk filename or a structured storage pointer instead. Thus, if you want to transfer a very large block of data that's already in a disk file, you don't have to waste time copying it to and from a memory block.

In case you were wondering, _IDataObject_ pointers are compatible with programs that use existing clipboard transfer methods. The format codes are the same. Windows takes care of the conversion to and from the data object. Of course, if an OLE-aware program puts an _IStorage_ pointer in a data object and puts the object on the clipboard, older, non-OLE-aware programs are unable to read that format.
________________________________________________________________________
7.3.2. - [The FORMATETC and STGMEDIUM Structures](invcpp5/ch26c.htm)
----------------------------------------------------
 The FORMATETC and STGMEDIUM Structures 

**The _FORMATETC_ and _STGMEDIUM_ Structures**
==============================================

Before you're ready for the _IDataObject_ member functions, you need to examine two important COM structures that are used as parameter types: the _FORMATETC_ structure and the _STGMEDIUM_ structure.

**_FORMATETC_**
---------------

The _FORMATETC_ structure is often used instead of a clipboard format to represent data format information. However, unlike the clipboard format, the _FORMATETC_ structure includes information about a target device, the aspect or view of the data, and a storage medium indicator. Here are the members of the _FORMATETC_ structure.

**Type**

**Name**

**Description**

_CLIPFORMAT_

_cfFormat_

Structure that contains clipboard formats, such as standard interchange formats (for example, _CF_TEXT_, which is a text format, and _CF_DIB_, which is an image compression format), custom formats (such as rich text format), and OLE formats used to create linked or embedded objects

_DVTARGETDEVICE_\*

_ptd_

Structure that contains information about the target device for the data, including the device driver name (can be _NULL_)

_DWORD_

_dwAspect_

A _DVASPECT_ enumeration constant (_DVASPECT_CONTENT_, _DVASPECT _THUMBNAIL_, and so on)

_LONG_

_lindex_

Usually -1

_DWORD_

_tymed_

Specifies type of media used to transfer the object's data (TYMED_HGLOBAL, TYMED_FILE, TYMED_ISTORAGE, and so on)

An individual data object accommodates a collection of FORMATETC elements, and the IDataObject interface provides a way to enumerate them. A useful macro for filling in a _FORMATETC_ structure appears below.

#define SETFORMATETC(fe, cf, asp, td, med, li)   \
    ((fe).cfFormat=cf, \
    (fe).dwAspect=asp, \
    (fe).ptd=td, \
    (fe).tymed=med, \
    (fe).lindex=li)

**_STGMEDIUM_**
---------------

The other important structure for _IDataObject_ members is the _STGMEDIUM_ structure. The _STGMEDIUM_ structure is a global memory handle used for operations involving data transfer. Here are the members.

**Type**

**Name**

**Description**

_DWORD_

_tymed_

Storage medium value used in marshaling and unmarshaling routines

_HBITMAP_

_hBitmap_

Bitmap handle\*

_HMETAFILEPICT_

_hMetaFilePict_

Metafile handle\*

_HENHMETAFILE_

_hEnhMetaFile_

Enhanced metafile handle\*

_HGLOBAL_

_hGlobal_

Global memory handle\*

_LPOLESTR_

_lpszFileName_

Disk filename (double-byte)\*

_ISTREAM_\*

_pstm_

_IStream_ interface pointer\*

_ISTORAGE_\*

_pstg_

_IStorage_ interface pointer\*

_IUNKNOWN_

_pUnkForRelease_

Used by clients to call _Release_ for formats with interface pointers

\* This member is part of a union, including handles, strings, and interface pointers used by the receiving process to access the transferred data.

As you can see, the _STGMEDIUM_ structure specifies where data is stored. The _tymed_ variable determines which union member is valid.

**The _IDataObject_ Interface Member Functions**
------------------------------------------------

This interface has nine member functions. Both Brockschmidt and the online documentation do a good job of describing all of these functions. Following are the functions that are important for this chapter.

### **HRESULT EnumFormatEtc(DWORD _dwDirection_, IEnumFORMATETC _ppEnum_);**

If you have an _IDataObject_ pointer for a data object, you can use _EnumFormatEtc_ to enumerate all the formats that it supports. This is an ugly API that the MFC library insulates you from. You'll learn how this happens when you examine the _COleDataObject_ class.

### **HRESULT GetData(FORMATETC\* _pFEIn_, STGMEDIUM\* _pSTM_);**

_GetData_ is the most important function in the interface. Somewhere, up in the sky, is a data object, and you have an _IDataObject_ pointer to it. You specify, in a _FORMATETC_ variable, the exact format you want to use when you retrieve the data, and you prepare an empty _STGMEDIUM_ variable to accept the results. If the data object has the format you want, _GetData_ fills in the _STGMEDIUM_ structure. Otherwise, you get an error return value.

### **HRESULT QueryGetData(FORMATETC\* _pFE_);**

You call _QueryGetData_ if you're not sure whether the data object can deliver data in the format specified in the _FORMATETC_ structure. The return value says, "Yes, I can" (_S_OK_) or "No, I can't" (an error code). Calling this function is definitely more efficient than allocating a _STGMEDIUM_ variable and calling _GetData_.

### **HRESULT SetData(FORMATETC\* _pFEIn_, STGMEDIUM\* _pSTM_, BOOL _fRelease_);**

Data objects rarely support _SetData_. Data objects are normally loaded with formats in their own server module; clients retrieve data by calling _GetData_. With _SetData_, you'd be transferring data in the other direction—like pumping water from your house back to the water company.

### **Other _IDataObject_ Member Functions—Advisory Connections**

The interface contains other important functions that let you implement an advisory connection. When the program using a data object needs to be notified whether the object's data changes, the program can pass an _IAdviseSink_ pointer to the object by calling the _IDataObject::DAdvise_ function. The object then calls various _IAdviseSink_ member functions, which the client program implements. You won't need advisory connections for drag-and-drop operations, but you will need them when you get to embedding in [Chapter 28](ch28a.htm).
________________________________________________________________________
7.3.3. - [MFC Uniform Data Transfer Support](invcpp5/ch26d.htm)
----------------------------------------------------
 MFC Uniform Data Transfer Support 

**MFC Uniform Data Transfer Support**
=====================================

The MFC library does a lot to make data object programming easier. As you study the MFC data object classes, you'll start to see a pattern in MFC COM support. At the component end, the MFC library provides a base class that implements one or more OLE interfaces. The interface member functions call virtual functions that you override in your derived class. At the client end, the MFC library provides a class that wraps an interface pointer. You call simple member functions that use the interface pointer to make COM calls.

The terminology needs some clarification here. The data object that's been described is the actual C++ object that you construct, and that's the way Brockschmidt uses the term. In the MFC documentation, a data object is what the client program sees through an _IDataObject_ pointer. A data source is the object you construct in a component program.

**The _COleDataSource_ Class**
------------------------------

When you want to use a data source, you construct an object of class _COleDataSource_, which implements the _IDataObject_ interface (without advisory connection support). This class builds and manages a collection of data formats stored in a cache in memory. A data source is a regular COM object that keeps a reference count. Usually, you construct and fill a data source, and then you pass it to the clipboard or drag and drop it in another location, never to worry about it again. If you decide not to pass off a data source, you can invoke the destructor, which cleans up all its formats.

Following are some of the more useful member functions of the _COleDataSource_ class.

### **void CacheData(CLIPFORMAT _cfFormat_, STGMEDIUM\* _lpStgMedium_, FORMATETC\* _lpFormatEtc_ = NULL);**

This function inserts an element in the data object's cache for data transfer. The _lpStgMedium_ parameter points to the data, and the _lpFormatEtc_ parameter describes the data. If, for example, the _STGMEDIUM_ structure specifies a disk filename, that filename gets stored inside the data object. If _lpFormatEtc_ is set to _NULL_, the function fills in a _FORMATETC_ structure with default values. It's safer, though, if you create your _FORMATETC_ variable with the _tymed_ member set.

### **void CacheGlobalData(CLIPFORMAT _cfFormat_, HGLOBAL _hGlobal_, FORMATETC\* _lpFormatEtc_ = NULL);**

You call this specialized version of _CacheData_ to pass data in global memory (identified by an _HGLOBAL_ variable). The data source object is considered the owner of that global memory block, so you should not free it after you cache it. You can usually omit the _lpFormatEtc_ parameter. The _CacheGlobalData_ function does not make a copy of the data.

### **DROPEFFECT DoDragDrop(DWORD _dwEffects_ = DROPEFFECT_COPY|DROPEFFECT_MOVE| DROPEFFECT_LINK, LPCRECT _lpRectStartDrag_ = NULL, COleDropSource\* _pDropSource_ = NULL);**

You call this function for drag-and-drop operations on a data source. You'll see it used in the EX26B example.

### **void SetClipboard(void);**

The _SetClipboard_ function, which you'll see in the EX26A example, calls the _OleSetClipboard_ function to put a data source on the Windows Clipboard. The clipboard is responsible for deleting the data source and thus for freeing the global memory associated with the formats in the cache. When you construct a _COleDataSource_ object and call _SetClipboard_, COM calls _AddRef_ on the object.

**The _COleDataObject_ Class**
------------------------------

This class is on the destination side of a data object transfer. Its base class is _CCmdTarget_, and it has a public member _m_lpDataObject_ that holds an _IDataObject_ pointer. That member must be set before you can effectively use the object. The class destructor only calls _Release_ on the _IDataObject_ pointer.

Following are a few of the more useful _COleDataObject_ member functions.

### **BOOL AttachClipboard(void);**

As Brockschmidt points out, OLE clipboard processing is internally complex. From your point of view, however, it's straightforward—as long as you use the _COleDataObject_ member functions. You first construct an "empty" _COleDataObject_ object, and then you call _AttachClipboard_, which calls the global _OleGetClipboard_ function. Now the _m_lpDataObject_ data member points back to the source data object (or so it appears), and you can access its formats.

If you call the _GetData_ member function to get a format, you must remember that the clipboard owns the format and you cannot alter its contents. If the format consists of an _HGLOBAL_ pointer, you must not free that memory and you cannot hang on to the pointer. If you need to have long-term access to the data in global memory, consider calling _GetGlobalData_ instead.

If a non-COM-aware program copies data onto the clipboard, the _AttachClipboard_ function still works because COM invents a data object that contains formats corresponding to the regular Windows data on the clipboard.

### **void BeginEnumFormats(void); BOOL GetNextFormat(FORMATETC\* _lpFormatEtc_);**

These two functions allow you to iterate through the formats that the data object contains. You call _BeginEnumFormats_ first, and then you call _GetNextFormat_ in a loop until it returns _FALSE_.

### **BOOL GetData(CLIPFORMAT _cfFormat_, STGMEDIUM\* _lpStgMedium_ FORMATETC\* _lpFormatEtc_ = NULL);**

This function calls _IDataObject::GetData_ and not much more. The function returns _TRUE_ if the data source contains the format you asked for. You generally need to supply the _lpFormatEtc_ parameter.

### **HGLOBAL GetGlobalData(CLIPFORMAT _cfFormat_, FORMATETC\*** **_lpFormatEtc_** **\= NULL);**

Use the _GetGlobalData_ function if you know your requested format is compatible with global memory. This function makes a copy of the selected format's memory block, and it gives you an _HGLOBAL_ handle that you must free later. You can often omit the _lpFormatEtc_ parameter.

### **BOOL IsDataAvailable(CLIPFORMAT _cfFormat_, FORMATETC\* _lpFormatEtc_ = NULL);**

The _IsDataAvailable_ function tests whether the data object contains a given format.

**MFC Data Object Clipboard Transfer**
--------------------------------------

Now that you've seen the _COleDataObject_ and _COleDataSource_ classes, you'll have an easy time doing clipboard data object transfers. But why not just do clipboard transfers the old way with _GetClipboardData_ and _SetClipboardData_? You could for most common formats, but if you write functions that process data objects, you can use those same functions for drag and drop.

Figure 26-1 shows the relationship between the clipboard and the _COleDataSource_ and _COleDataObject_ classes. You construct a _COleDataSource_ object

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f26og01x.gif)]

**Figure 26-1.** _MFC OLE clipboard processing._

on the copy side, and then you fill its cache with formats. When you call _SetClipboard_, the formats are copied to the clipboard. On the paste side, you call _AttachClipboard_ to attach an _IDataObject_ pointer to a _COleDataObject_ object, after which you can retrieve individual formats.

Suppose you have a document-view application whose document has a _CString_ data member _m_strText_. You want to use view class command handler functions that copy to and paste from the clipboard. Before you write those functions, write two helper functions. The first, _SaveText_, creates a data source object from the contents of _m_strText_. The function constructs a _COleDataSource_ object, and then it copies the string contents to global memory. Last it calls _CacheGlobalData_ to store the _HGLOBAL_ handle in the data source object. Here is the _SaveText_ code:

COleDataSource\* CMyView::SaveText()

{
    CEx26fDoc\* pDoc = GetDocument();
    if (!pDoc->m_strtext.IsEmpty()) {
        COleDataSource\* pSource = new COleDataSource();
        int nTextSize = GetDocument()->
m_strText.GetLength() + 1;
        HGLOBAL hText = ::GlobalAlloc(GMEM_SHARE, nTextSize);
        LPSTR pText = (LPSTR) ::GlobalLock(hText);
        ASSERT(pText);
        strcpy(pText, GetDocument()->
m_strText);
        ::GlobalUnlock(hText);
        pSource->CacheGlobalData(CF_TEXT, hText);
        return pSource;
    }
    return NULL;
}

The second helper function, _DoPasteText_, fills in _m_strText_ from a data object specified as a parameter. We're using _COleDataObject::GetData_ here instead of _GetGlobalData_ because _GetGlobalData_ makes a copy of the global memory block. That extra copy operation is unnecessary because we're copying the text to the _CString_ object. We don't free the original memory block because the data object owns it. Here is the _DoPasteText_ code:

// Memory is MOVEABLE, so we must use GlobalLock!
    SETFORMATETC(fmt, CF_TEXT, DVASPECT_CONTENT, NULL, TYMED_HGLOBAL, -1);
    VERIFY(pDataObject->GetData(CF_TEXT, &stg, &fmt));
    HGLOBAL hText = stg.hGlobal;
    GetDocument()->m_strText = (LPSTR) ::GlobalLock(hText);
    ::GlobalUnlock(hText);
    return TRUE;
}

Here are the two command handler functions:

void CMyView::OnEditCopy()
{
    COleDataSource\* pSource = SaveText();
    if (pSource) {
        pSource->SetClipboard(); 
    }
}
void CMyView::OnEditPaste()
{
    COleDataObject dataObject;
    VERIFY(dataObject.AttachClipboard());
    DoPasteText(&dataObject);
    // dataObject released
}
________________________________________________________________________
7.3.4. - [The MFC CRectTracker Class](invcpp5/ch26e.htm)
----------------------------------------------------
 The MFC CRectTracker Class 

**The MFC _CRectTracker_ Class**
================================

The _CRectTracker_ class is useful in both OLE and non-OLE programs. It allows the user to move and resize a rectangular object in a view window. There are two important data members: the _m_nStyle_ member determines the border, resize handle, and other characteristics; and the _m_rect_ member holds the device coordinates for the rectangle.

The important member functions follow.

### **void Draw(CDC\* _pDC_) const;**

The _Draw_ function draws the tracker, including border and resize handles, but it does not draw anything inside the rectangle. That's your job.

### **BOOL Track(CWnd\* _pWnd_, CPoint _point_, BOOL _bAllowInvert_ = FALSE, CWnd\* _pWndClipTo_ = NULL);**

You call this function in a _WM_LBUTTONDOWN_ handler. If the cursor is on the rectangle border, the user can resize the tracker by holding down the mouse button; if the cursor is inside the rectangle, the user can move the tracker. If the cursor is outside the rectangle, _Track_ returns _FALSE_ immediately; otherwise, _Track_ returns _TRUE_ only when the user releases the mouse button. That means _Track_ works a little like _CDialog::DoModal_. It contains its own message dispatch logic.

### **int HitTest(CPoint _point_) const;**

Call _HitTest_ if you need to distinguish between mouse button hits inside and on the tracker rectangle. The function returns immediately with the hit status in the return value.

### **BOOL SetCursor(CWnd\* _pWnd_, UINT _nHitTest_) const;**

Call this function in your view's _WM_SETCURSOR_ handler to ensure that the cursor changes during tracking. If _SetCursor_ returns _FALSE_, call the base class _OnSetCursor_ function; if _SetCursor_ returns _TRUE_, you return _TRUE_.

**_CRectTracker_ Rectangle Coordinate Conversion**
--------------------------------------------------

You must deal with the fact that the _CRectTracker::m_rect_ member stores device coordinates. If you are using a scrolling view or have otherwise changed the mapping mode or viewport origin, you must do coordinate conversion. Here's a strategy:

2.  Define a _CRectTracker_ data member in your view class. Use the name _m_tracker_.
    
3.  Define a separate data member in your view class to hold the rectangle in logical coordinates. Use the name _m_rectTracker_.
    
4.  In your view's _OnDraw_ function, set _m_rect_ to the updated device coordinates, and then draw the tracker. This adjusts for any scrolling since the last _OnDraw_. Some sample code appears below.
    
    m_tracker.m_rect = m_rectTracker;
    pDC->LPtoDP(m_tracker.m_rect); // tracker requires device
                                   //  coordinates
    m_tracker.Draw(pDC);
    
5.  In your mouse button down message handler, call _Track_, set _m_rectTracker_ to the updated logical coordinates, and call _Invalidate_, as shown here:
    
    if (m_tracker.Track(this, point, FALSE, NULL)) {
        CClientDC dc(this);
        OnPrepareDC(&dc);
        m_rectTracker = m_tracker.m_rect;
        dc.DPtoLP(m_rectTracker);
        Invalidate();
    }
________________________________________________________________________
7.3.5. - [The EX26A Example -- A Data Object Clipboard](invcpp5/ch26f.htm)
----------------------------------------------------
 The EX26A Example -- A Data Object Clipboard 

**The EX26A Example—A Data Object Clipboard**
=============================================

This example uses the _CDib_ class from EX11C. Here you'll be able to move and resize the DIB image with a tracker rectangle, and you'll be able to copy and paste the DIB to and from the clipboard using a COM data object. The example also includes functions for reading DIBs from and writing DIBs to BMP files.

If you create such an example from scratch, use AppWizard without any ActiveX or Automation options and then add the following line in your StdAfx.h file:

#include <afxole.h>

Add the following call at the start of the application's _InitInstance_ function:

AfxOleInit();

To prepare EX26A, open the \vcpp32\ex26a\ex26a.dsw workspace and then build the project. Run the application, and paste a bitmap into the rectangle by choosing Paste From on the Edit menu. You'll see an MDI application similar to the one shown in Figure 26-2.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f26og02x.gif)]

**Figure 26-2.** _The EX26A program in operation._

**The _CMainFrame_ Class**
--------------------------

This class contains the handlers _OnQueryNewPalette_ and _OnPaletteChanged_ for the WM_QUERYNEWPALETTE and WM_PALETTECHANGED messages, respectively. These handlers send a user-defined WM_VIEWPALETTECHANGED message to all the views, and then the handler calls _CDib::UsePalette_ to realize the palette. The value of _wParam_ tells the view whether it should realize the palette in background or foreground mode.

**The _CEx26aDoc_ Class**
-------------------------

This class is pretty straightforward. It contains an embedded _CDib_ object, _m_dib_, plus a Clear All command handler. The overridden _DeleteContents_ member function calls the _CDib::Empty_ function.

**The _CEx26aView_ Class**
--------------------------

This class contains the clipboard function command handlers, the tracking code, the DIB drawing code, and the palette message handler. Figure 26-3 shows the header and implementation files with manually entered code in boldface.

**EX26AVIEW.H**

#if !defined(AFX_EX26AVIEW_H__4F329B0F_5DF1_11D0_848F_00400526305B
_ _INCLUDED_)
#define AFX_EX26AVIEW_H__4F329B0F_5DF1_11D0_848F_00400526305B
_ _INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif// _MSC_VER > 1000

#define WM_VIEWPALETTECHANGED  WM_USER + 5

class CEx26aView : public CScrollView
{
    **// for tracking
    CRectTracker m_tracker;
    CRect m_rectTracker; // logical coordinates
    CSize m_sizeTotal;   // document size**
protected: // create from serialization only
    CEx26aView();
    DECLARE_DYNCREATE(CEx26aView)

// Attributes
public:
    CEx26aDoc\* GetDocument();
// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEx26aView)
    public:
    virtual void OnDraw(CDC\* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual void OnPrepareDC(CDC\* pDC, CPrintInfo\* pInfo = NULL);
    virtual void OnInitialUpdate();
    protected:
    virtual BOOL OnPreparePrinting(CPrintInfo\* pInfo);
    virtual void OnBeginPrinting(CDC\* pDC, CPrintInfo\* pInfo);
    virtual void OnEndPrinting(CDC\* pDC, CPrintInfo\* pInfo);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CEx26aView();

#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// generated message map functions
protected:
    //{{AFX_MSG(CEx26aView)
    afx_msg void OnEditCopy();
    afx_msg void OnUpdateEditCopy(CCmdUI\* pCmdUI);]
    afx_msg void OnEditCopyto();
    afx_msg void OnEditCut();
    afx_msg void OnEditPaste();
    afx_msg void OnUpdateEditPaste(CCmdUI\* pCmdUI);
    afx_msg void OnEditPastefrom();
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg BOOL OnSetCursor(CWnd\* pWnd, UINT nHitTest, UINT message);
    afx_msg LONG OnViewPaletteChanged(UINT wParam, LONG lParam);
    afx_msg void OnSetFocus(CWnd\* pOldWnd);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
**private:
    BOOL DoPasteDib(COleDataObject\* pDataObject);
    COleDataSource\* SaveDib();**
};

#ifndef _DEBUG  // debug version in Ex26aView.cpp
inline CEx26aDoc\* CEx26aView::GetDocument()
    { return (CEx26aDoc\*)
m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
//  immediately before the previous line

#endif 
// !defined(AFX_EX26AVIEW_H__4F329B0F_5DF1_11D0_848F_00400526305B
__INCLUDED_)

**EX26AVIEW.CPP**
#include "stdafx.h"
#include "ex26a.h"

#include "cdib.h"
#include "ex26aDoc.h"
#include "ex26aView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE
__;
#endif

///////////////////////////////////////////////////////////////////////
// CEx26aView

IMPLEMENT_DYNCREATE(CEx26aView, CScrollView)

BEGIN_MESSAGE_MAP(CEx26aView, CScrollView)
    //{{AFX_MSG_MAP(CEx26aView)
    ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
    ON_COMMAND(ID_EDIT_COPYTO, OnEditCopyto)
    ON_COMMAND(ID_EDIT_CUT, OnEditCut)
    ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
    ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
    ON_COMMAND(ID_EDIT_PASTEFROM, OnEditPastefrom)
    ON_WM_LBUTTONDOWN()
    ON_WM_SETCURSOR()
    ON_MESSAGE(WM_VIEWPALETTECHANGED, OnViewPaletteChanged)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPYTO, OnUpdateEditCopy)
    ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCopy)
    ON_WM_SETFOCUS()
    //}}AFX_MSG_MAP
    // standard printing commands
    ON_COMMAND(ID_FILE_PRINT, CScrollView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_DIRECT, CScrollView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, CScrollView::OnFilePrintPreview)
END_MESSAGE_MAP()

//////////////////////////////////////////////////////////////////////
// CEx26aView construction/destruction

CEx26aView::CEx26aView() **: m_sizeTotal(800, 1050), // 8-by-10.5 inches
                                                   //  when printed
    m_rectTracker(50, 50, 250, 250)**
{
}

CEx26aView::~CEx26aView()
{
}

BOOL CEx26aView::PreCreateWindow(CREATESTRUCT& cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return CScrollView::PreCreateWindow(cs);
}

//////////////////////////////////////////////////////////////////////
// CEx26aView drawing

void CEx26aView::OnDraw(CDC\* pDC)
{
    **CDib& dib = GetDocument()->m_dib;
    m_tracker.m_rect = m_rectTracker;
    pDC->LPtoDP(m_tracker.m_rect); // tracker wants device coordinates
    m_tracker.Draw(pDC);
    dib.Draw(pDC, m_rectTracker.TopLeft(), 
m_rectTracker.Size());**
}

//////////////////////////////////////////////////////////////////////
// CEx26aView printing

BOOL CEx26aView::OnPreparePrinting(CPrintInfo\* pInfo)
{
    **pInfo->SetMaxPage(1);**
    return DoPreparePrinting(pInfo);
}

void CEx26aView::OnBeginPrinting(CDC\* /\*pDC\*/, CPrintInfo\* /\*pInfo\*/)
{
    // TODO: add extra initialization before printing
}

void CEx26aView::OnEndPrinting(CDC\* /\*pDC\*/, CPrintInfo\* /\*pInfo\*/)
{
    // TODO: add cleanup after printing
}

//////////////////////////////////////////////////////////////////////
// CEx26aView diagnostics

#ifdef _DEBUG
void CEx26aView::AssertValid() const
{
    CScrollView::AssertValid();
}

void CEx26aView::Dump(CDumpContext& dc) const
{
    CScrollView::Dump(dc);
}

CEx26aDoc\* CEx26aView::GetDocument() // nondebug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CEx26aDoc)));
    return (CEx26aDoc\*)m_pDocument;
}
#endif //_DEBUG

**//////////////////////////////////////////////////////////////
// helper functions used for clipboard and drag-drop 

BOOL CEx26aView::DoPasteDib(COleDataObject\* pDataObject)
{
    // update command user interface should keep us out of 
    //  here if not CF_DIB
    if (!pDataObject->IsDataAvailable(CF_DIB)) {
        TRACE("CF_DIB format is unavailable\n");
        return FALSE;
    }
    CEx26aDoc\* pDoc = GetDocument();
    // Seems to be MOVEABLE memory, so we must use GlobalLock!
    //  (hDib != lpDib) GetGlobalData copies the memory, so we can
    //  hang onto it until we delete the CDib.
    HGLOBAL hDib = pDataObject->GetGlobalData(CF_DIB);
    ASSERT(hDib != NULL);
    LPVOID lpDib = ::GlobalLock(hDib);
    ASSERT(lpDib != NULL);
    pDoc->m_dib.AttachMemory(lpDib, TRUE, hDib);
    pDoc->SetModifiedFlag();
    pDoc->UpdateAllViews(NULL);
    return TRUE;
}

COleDataSource\* CEx26aView::SaveDib()
{
    CDib& dib = GetDocument()->m_dib;
    if (dib.GetSizeImage() > 0) {
        COleDataSource\* pSource = new COleDataSource();
        int nHeaderSize = dib.GetSizeHeader();
        int nImageSize = dib.GetSizeImage();
        HGLOBAL hHeader = ::GlobalAlloc(GMEM_SHARE,
            nHeaderSize + nImageSize);
        LPVOID pHeader = ::GlobalLock(hHeader);
        ASSERT(pHeader != NULL);
        LPVOID pImage = (LPBYTE) pHeader + nHeaderSize;
        memcpy(pHeader, dib.m_lpBMIH, nHeaderSize); 
        memcpy(pImage, dib.m_lpImage, nImageSize);
        // Receiver is supposed to free the global memory 
        ::GlobalUnlock(hHeader);
        pSource->CacheGlobalData(CF_DIB, hHeader);
        return pSource;
    }
    return NULL;
}**

//////////////////////////////////////////////////////////////////////
// CEx26aView message handlers

void CEx26aView::OnEditCopy() 
{
    **COleDataSource\* pSource = SaveDib();
    if (pSource) {
        pSource->SetClipboard(); // OLE deletes data source
    }**
}

void CEx26aView::OnUpdateEditCopy(CCmdUI\* pCmdUI) 
{
    **// serves Copy, Cut, and Copy To
    CDib& dib = GetDocument()->m_dib;
    pCmdUI->Enable(dib.GetSizeImage() > 0L);**
}

void CEx26aView::OnEditCopyto()
{
    **CDib& dib = GetDocument()->m_dib;
    CFileDialog dlg(FALSE, "bmp", "\*.bmp");
    if (dlg.DoModal() != IDOK) return;

    BeginWaitCursor();
    dib.CopyToMapFile(dlg.GetPathName());
    EndWaitCursor();**
}

void CEx26aView::OnEditCut() 
{
    **OnEditCopy();
    GetDocument()->OnEditClearAll();**
}
void CEx26aView::OnEditPaste() 
{
    **CEx26aDoc\* pDoc = GetDocument();
    COleDataObject dataObject;
    VERIFY(dataObject.AttachClipboard());
    DoPasteDib(&dataObject);
    CClientDC dc(this);
    pDoc->m_dib.UsePalette(&dc);
    pDoc->SetModifiedFlag();
    pDoc->UpdateAllViews(NULL);**
}

void CEx26aView::OnUpdateEditPaste(CCmdUI\* pCmdUI) 
{
    **COleDataObject dataObject;
    BOOL bAvail = dataObject.AttachClipboard() &&
        dataObject.IsDataAvailable(CF_DIB);
    pCmdUI->Enable(bAvail);**
}

void CEx26aView::OnEditPastefrom() 
{
    **CEx26aDoc\* pDoc = GetDocument();
    CFileDialog dlg(TRUE, "bmp", "\*.bmp");
    if (dlg.DoModal() != IDOK) return;
    if (pDoc->m_dib.AttachMapFile(dlg.GetPathName(), TRUE)) { // share
        CClientDC dc(this);
        pDoc->m_dib.SetSystemPalette(&dc);
        pDoc->m_dib.UsePalette(&dc);
        pDoc->SetModifiedFlag();
        pDoc->UpdateAllViews(NULL);
    }**
}

void CEx26aView::OnPrepareDC(CDC\* pDC, CPrintInfo\* pInfo) 
{
    **// custom MM_LOENGLISH; positive y is down
    if (pDC->IsPrinting()) {
        int nHsize = pDC->GetDeviceCaps(HORZSIZE) \* 1000 / 254;
        int nVsize = pDC->GetDeviceCaps(VERTSIZE) \* 1000 / 254;
        pDC->SetMapMode(MM_ANISOTROPIC);
        pDC->SetWindowExt(nHsize, nVsize);
        pDC->SetViewportExt(pDC->GetDeviceCaps(HORZRES),
                            pDC->GetDeviceCaps(VERTRES));
    }
    else {
        CScrollView::OnPrepareDC(pDC, pInfo);
    }**
}
void CEx26aView::OnInitialUpdate() 
{
    **SetScrollSizes(MM_TEXT, m_sizeTotal);
    m_tracker.m_nStyle = CRectTracker::solidLine |
        CRectTracker::resizeOutside;
    CScrollView::OnInitialUpdate();**
}

void CEx26aView::OnLButtonDown(UINT nFlags, CPoint point) 
{
    **if (m_tracker.Track(this, point, FALSE, NULL)) {
        CClientDC dc(this);
        OnPrepareDC(&dc);
        m_rectTracker = m_tracker.m_rect;
        dc.DPtoLP(m_rectTracker); // Update logical coordinates
        Invalidate();
    }**
}

BOOL CEx26aView::OnSetCursor(CWnd\* pWnd, UINT nHitTest, UINT message)
{
    **if (m_tracker.SetCursor(pWnd, nHitTest)) {
        return TRUE;
    }
    else {
        return CScrollView::OnSetCursor(pWnd, nHitTest, message);
    }**
}

LONG CEx26aView::OnViewPaletteChanged(UINT wParam, LONG lParam) 
{
    **TRACE("CEx26aView::OnViewPaletteChanged, HWND = %x,  \ 
        code = %d\n", GetSafeHwnd(), wParam);
    CClientDC dc(this);
    GetDocument()->m_dib.UsePalette(&dc, wParam);
    Invalidate();
    return 0;**
}

void CEx26aView::OnSetFocus(CWnd\* pOldWnd) 
{
    **CScrollView::OnSetFocus(pOldWnd);
    AfxGetApp()->m_pMainWnd->SendMessage(WM_PALETTECHANGED, 
        (UINT) GetSafeHwnd());**
}

**Figure 26-3.** _The_ CEx26aView _class listing._

Several interesting things happen in the view class. In the _DoPasteDib_ helper, we can call _GetGlobalData_ because we can attach the returned _HGLOBAL_ variable to the document's _CDib_ object. If we called _GetData_, we would have to copy the memory block ourselves. The Paste From and Copy To command handlers rely on the memory-mapped file support in the _CDib_ class. The _OnPrepareDC_ function creates a special printer-mapping mode that is just like MM_LOENGLISH except that positive _y_ is down. One pixel on the display corresponds to 0.01 inch on the printer.
________________________________________________________________________
7.3.6. - [MFC Drag and Drop](invcpp5/ch26g.htm)
----------------------------------------------------
 MFC Drag and Drop 

**MFC Drag and Drop**
=====================

Drag and drop was the ultimate justification for the data object code you've been looking at. OLE supports this feature with its _IDropSource_ and _IDropTarget_ interfaces plus some library code that manages the drag-and-drop process. The MFC library offers good drag-and-drop support at the view level, so we'll use it. Be aware that drag-and-drop transfers are immediate and independent of the clipboard. If the user cancels the operation, there's no "memory" of the object being dragged.

Drag-and-drop transfers should work consistently between applications, between windows of the same application, and within a window. When the user starts the operation, the cursor should change to an arrow_rectangle combination. If the user holds down the Ctrl key, the cursor turns into a plus sign (+), which indicates that the object is being copied rather than moved.

MFC also supports drag-and-drop operations for items in compound documents. This is the next level up in MFC OLE support, and it's not covered in this chapter. Look up the OCLIENT example in the online documentation under Visual C++ Samples.

**The Source Side of the Transfer**
-----------------------------------

When your source program starts a drag-and-drop operation for a data object, it calls _COleDataSource::DoDragDrop_. This function internally creates an object of MFC class _COleDropSource_, which implements the _IOleDropSource_ interface. _DoDragDrop_ is one of those functions that don't return for a while. It returns when the user drops the object or cancels the operation or when a specified number of milliseconds have elapsed.

If you're programming drag-and-drop operations to work with a _CRectTracker_ object, you should call _DoDragDrop_ only when the user clicks inside the tracking rectangle, not on its border. _CRectTracker::HitTest_ gives you that information. When you call _DoDragDrop_, you need to set a flag that tells you whether the user is dropping the object into the same view (or document) that it was dragged from.

**The Destination Side of the Transfer**
----------------------------------------

If you want to use the MFC library's view class drag-and-drop support, you must add a data member of class _COleDropTarget_ to your derived view class. This class implements the _IDropTarget_ interface, and it holds an _IDropSource_ pointer that links back to the _COleDropSource_ object. In your view's _OnInitialUpdate_ function, you call the _Register_ member function for the embedded _COleDropTarget_ object.

After you have made your view a drop target, you must override four _CView_ virtual functions, which the framework calls during the drag-and-drop operation. Here's a summary of what they should do, assuming that you're using a tracker.

_OnDragEnter_

Adjusts the focus rectangle and then calls _OnDragOver_

_OnDragOver_

Moves the dotted focus rectangle and sets the drop effect (determines cursor shape)

_OnDragLeave_

Cancels the transfer operation; returns the rectangle to its original position and size

_OnDrop_

Adjusts the focus rectangle and then calls the _DoPaste_ helper function to get formats from the data object

**The Drag-and-Drop Sequence**
------------------------------

Figure 26-4 illustrates the MFC drag-and-drop process.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f26og04x.gif)]

**Figure 26-4.** _MFC OLE drag-and-drop processing._

Here's a summary of what's going on:

2.  User presses the left mouse button in the source view window.
    
3.  Mouse button handler calls _CRectTracker::HitTest_ and finds out that the cursor was inside the tracker rectangle.
    
4.  Handler stores formats in a _COleDataSource_ object.
    
5.  Handler calls _COleDataSource::DoDragDrop_ for the data source.
    
6.  User moves the cursor to the view window of the target application.
    
7.  OLE calls _IDropTarget::OnDragEnter_ and _OnDragOver_ for the _COleDropTarget_ object, which calls the corresponding virtual functions in the target's view. The _OnDragOver_ function is passed a _COleDataObject_ pointer for the source object, which the target tests for a format it can understand.
    
8.  _OnDragOver_ returns a drop effect code, which OLE uses to set the cursor.
    
9.  OLE calls _IDataSource::QueryContinueDrag_ on the source side to find out whether the drag operation is still in progress. The MFC _COleDataSource_ class responds appropriately.
    
10.  User releases the mouse button to drop the object in the target view window.
    
11.  OLE calls _IDropTarget::OnDrop_, which calls _OnDrop_ for the target's view. Because _OnDrop_ is passed a _COleDataObject_ pointer, it can retrieve the desired format from that object.
    
12.  When _OnDrop_ returns in the target program, _DoDragDrop_ can return in the source program.
________________________________________________________________________
7.3.7. - [The EX26B Example -- OLE Drag and Drop](invcpp5/ch26h.htm)
----------------------------------------------------
 The EX26B Example -- OLE Drag and Drop 

**The EX26B Example—OLE Drag and Drop**
=======================================

This example picks up where the EX26A example leaves off. It adds drag-and-drop support, using the existing _SaveDib_ and _DoPasteDib_ helper functions. All of the clipboard code is the same. You should be able to adapt EX26B to other applications that require drag and drop for data objects.

To prepare EX26B, open the \vcpp32\ex26b\ex26b.dsw workspace and build the project. Run the application, and test drag and drop between child windows and between instances of the program.

**The _CEx26bDoc_ Class**
-------------------------

This class is just like the EX26A version except for an added flag data member, _m_bDragHere_. This flag is _TRUE_ when a drag-and-drop operation is in progress for this document. The flag is in the document and not in the view because it is possible to have multiple views attached to the same document. It doesn't make sense to drag a DIB from one view to another when both views reflect the document's _m_dib_ member.

**The _CEx26bView_ Class**
--------------------------

To start with, this class has three additional data members and a constructor that initializes all the data members, as shown here:

CRect m_rectTrackerEnter; // original logical coordinates
COleDropTarget m_dropTarget;
CSize m_dragOffset; // device coordinates

CEx26bView::CEx26bView() : m_sizeTotal(800, 1050), // 8-by-10.5 inches
                                                   //  when printed
    m_rectTracker(50, 50, 250, 250),
    m_dragOffset(0, 0),
    m_rectTrackerEnter(50, 50, 250, 250)
{
}

The _OnInitialUpdate_ function needs one additional line to register the drop target:

m_dropTarget.Register(this);

Following are the drag-and-drop virtual override functions. Note that _OnDrop_ replaces the DIB only if the document's _m_bDragHere_ flag is _TRUE_, so if the user drops the DIB in the same window or in another window connected to the same document, nothing happens.

DROPEFFECT CEx26bView::OnDragEnter(COleDataObject\* pDataObject,
    DWORD dwKeyState, CPoint point)
{
    TRACE("Entering CEx26bView::OnDragEnter, point = (%d, %d)\n",
        point.x, point.y);
    m_rectTrackerEnter = m_rectTracker; // save original coordinates
                                        //  for cursor leaving
                                        //  rectangle
    CClientDC dc(this);
    OnPrepareDC(&dc);
    dc.DrawFocusRect(m_rectTracker); // will be erased in OnDragOver
    return OnDragOver(pDataObject, dwKeyState, point);
}

DROPEFFECT CEx26bView::OnDragOver(COleDataObject\* pDataObject,
    DWORD dwKeyState, CPoint point)
{
    if (!pDataObject->IsDataAvailable(CF_DIB)) {
        return DROPEFFECT_NONE;
    }
    MoveTrackRect(point);
    if ((dwKeyState & MK_CONTROL) == MK_CONTROL) {
        return DROPEFFECT_COPY;
    }
    // Check for force move
    if ((dwKeyState & MK_ALT) == MK_ALT) {
        return DROPEFFECT_MOVE;
    }
    // default -- recommended action is move
    return DROPEFFECT_MOVE;
}

void CEx26bView::OnDragLeave()
{
    TRACE("Entering CEx26bView::OnDragLeave\n");
    CClientDC dc(this);
    OnPrepareDC(&dc);
    dc.DrawFocusRect(m_rectTracker);
    m_rectTracker = m_rectTrackerEnter; // Forget it ever happened
}

BOOL CEx26bView::OnDrop(COleDataObject\* pDataObject, 
    DROPEFFECT dropEffect, CPoint point)
{
    TRACE("Entering CEx26bView::OnDrop --
  dropEffect = %d\n", dropEffect);
    BOOL bRet;
    CEx26bDoc\* pDoc = GetDocument();
    MoveTrackRect(point);
    if (pDoc->m_bDragHere) {
        pDoc->m_bDragHere = FALSE;
        bRet = TRUE;
    }
    else {
        bRet = DoPasteDib(pDataObject);
    }
    return bRet;
}

The handler for the WM_LBUTTONDOWN message needs substantial overhaul. It must call _DoDragDrop_ if the cursor is inside the rectangle and _Track_ if it is on the rectangle border. The revised code is shown here:

void CEx26bView::OnLButtonDown(UINT nFlags, CPoint point) 
{
    CEx26bDoc\* pDoc = GetDocument();
    if (m_tracker.HitTest(point) == CRectTracker::hitMiddle) {
        COleDataSource\* pSource = SaveDib();
        if (pSource) {
            // DoDragDrop returns only after drop is complete
            CClientDC dc(this);
            OnPrepareDC(&dc);
            CPoint topleft = m_rectTracker.TopLeft();
            dc.LPtoDP(&topleft);
            // \`point' here is not the same as the point parameter in 
            //   OnDragEnter, so we use this one to compute the offset
            m_dragOffset = point - topleft;  // device coordinates
            pDoc->m_bDragHere = TRUE;
            DROPEFFECT dropEffect = pSource->DoDragDrop(
                DROPEFFECT_MOVE | DROPEFFECT_COPY, CRect(0, 0, 0, 0));
            TRACE("after DoDragDrop -- dropEffect = %ld\n", dropEffect);
            if (dropEffect == DROPEFFECT_MOVE && pDoc->m_bDragHere) {
                pDoc>OnEditClearAll();
            }
            pDoc->m_bDragHere = FALSE;
            delete pSource;
        }
    }
    else {
        if (m_tracker.Track(this, point, FALSE, NULL)) {
            CClientDC dc(this);
            OnPrepareDC(&dc);
            // should have some way to prevent it going out of bounds
            m_rectTracker = m_tracker.m_rect;
            dc.DPtoLP(m_rectTracker); // update logical coordinates
        }
    }
    Invalidate();
}

Finally, the new _MoveTrackRect_ helper function, shown here, moves the tracker's focus rectangle each time the _OnDragOver_ function is called. This job was done by _CRectTracker::Track_ in the EX26A example.

void CEx26bView::MoveTrackRect(CPoint point)
{
    CClientDC dc(this);
    OnPrepareDC(&dc);
    dc.DrawFocusRect(m_rectTracker);
    dc.LPtoDP(m_rectTracker);
    CSize sizeTrack = m_rectTracker.Size();
    CPoint newTopleft = point - m_dragOffset;  // still device
    m_rectTracker = CRect(newTopleft, sizeTrack);
    m_tracker.m_rect = m_rectTracker;
    dc.DPtoLP(m_rectTracker);
    dc.DrawFocusRect(m_rectTracker);
}
________________________________________________________________________
7.3.8. - [Windows Applications and Drag and Drop -- Dobjview](invcpp5/ch26i.htm)
----------------------------------------------------
 Windows Applications and Drag and Drop -- Dobjview 

**Windows Applications and Drag and Drop—Dobjview**
===================================================

I tested EX26B with the Microsoft Office 97 suite. I tried both drag-and-drop and clipboard transfers, with the results shown in the following table.

**EX26B**

**Word**

**Excel**

**PowerPoint**

Sends clipboard data to

x

x (no palettes)

x

Accepts clipboard data from

Sends drag-drop data to

x

x

Accepts drag-drop data from

When I started to investigate why these programs were so uncooperative, I discovered a useful OLE utility called Dobjview (_IDataObject_ viewer). I could use Dobjview to examine a data object on the clipboard, and I could drag objects to the Dobjview window. Here's what I got when I dragged a picture from Microsoft Excel.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g26og01x.gif)]

No _CF_DIB_ format is present. If you want pictures from Excel, you must enhance EX26B to process metafiles. Another alternative is to rewrite the program with compound document support as described in [Chapter 28](ch28a.htm). The OLE libraries contain code to display bitmaps and metafiles.
________________________________________________________________________
7.3.9. - [Conclusion](invcpp5/ch26j.htm)
----------------------------------------------------
 Conclusion 

**Conclusion**
==============

As you can see, MFC makes clipboard and drag-and-drop data transfer pretty easy. While you can always write all the code necessary to implement the interfaces (_IDataObject_, _IDropTarget_, and _IDropSource_), using MFC's implementations is much more convenient. While we've looked only at clipboard and drag and drop transfers through _IDataObject_ in this chapter, everything you learn about the _IDataObject_ interface will carry forward to your study of compound documents in the [next chapter](ch27a.htm).
________________________________________________________________________
7.4. - [Chapter 27 -- Structured Storage](invcpp5/ch27a.htm)
----------------------------------------------------
 Chapter 27 -- Structured Storage  Chapter 27

Structured Storage
==================

Like Automation and Uniform Data Transfer, structured storage is one of those COM features that you can use effectively by itself. Of course, it's also behind much of the ActiveX technology, particularly compound documents.

In this chapter, you'll learn to write and read compound files with the _IStorage_ and _IStream_ interfaces. The _IStorage_ interface is used to create and manage structured storage objects. _IStream_ is used to manipulate the data contained by the storage object. The _IStorage_ and _IStream_ interfaces, like all COM interfaces, are simply virtual function declarations. Compound files, on the other hand, are implemented by code in the Microsoft Windows OLE32 DLL. Compound files represent a Microsoft file I/O standard that you can think of as "a file system inside a file."

When you're familiar with _IStorage_ and _IStream_, you'll move on to the _IPersistStorage_ and _IPersistStream_ interfaces. With the _IPersistStorage_ and _IPersistStream_ interfaces, you can program a class to save and load objects to and from a compound file. You say to an object, "Save yourself," and it knows how.
________________________________________________________________________
7.4.1. - [Compound Files](invcpp5/ch27b.htm)
----------------------------------------------------
 Compound Files 

**Compound Files**
==================

This book discusses four options for file I/O. You can read and write whole sequential files (like the MFC archive files you saw first in [Chapter 17](ch17a.htm)). You can use a database management system (as described in [Chapter 31](ch31a.htm) and [Chapter 32](ch32a.htm)). You can write your own code for random file access. Finally, you can use compound files.

Think of a compound file as a whole file system within a file. Figure 27-1 shows a traditional disk directory as supported by early MS-DOS systems and by Microsoft Windows. This directory is composed of files and subdirectories, with a root directory at the top. Now imagine the same structure inside a single disk file. The files are called streams, and the directories are called storages. Each is identified by a name of up to 32 wide characters in length. A stream is a logically sequential array of bytes, and a storage is a collection of streams and substorages.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f27og01x.gif)]

**Figure 27-1.** _A disk directory with files and subdirectories._

(A storage can contain other storages, just as a directory can contain subdirectories.) In a disk file, the bytes aren't necessarily stored in contiguous clusters. Similarly, the bytes in a stream aren't necessarily contiguous in their compound file. They just appear that way.

> NOTE
> 
> Storage and stream names cannot contain the characters /, \, :, or !. If the first character has an ASCII value of less than 32, the element is marked as managed by some agent other than the owner.

You can probably think of many applications for a compound file. The classic example is a large document composed of chapters and paragraphs within chapters. The document is so large that you don't want to read the whole thing into memory when your program starts, and you want to be able to insert and delete portions of the document. You could design a compound file with a root storage that contains substorages for chapters. The chapter substorages would contain streams for the paragraphs. Other streams could be for index information.

One useful feature of compound files is transactioning. When you start a transaction for a compound file, all changes are written to a temporary file. The changes are made to your file only when you commit the transaction.
________________________________________________________________________
7.4.2. - [Storages and the IStorage Interface](invcpp5/ch27c.htm)
----------------------------------------------------
 Storages and the IStorage Interface 

**Storages and the _IStorage_ Interface**
=========================================

If you have a storage object, you can manipulate it through the _IStorage_ interface. Pay attention to these functions because Microsoft Foundation Class offers no support for storage access. Following are some of the important member functions and their significant parameters.

### **HRESULT Commit(…);**

Commits all the changes to this storage and to all elements below it.

### **HRESULT CopyTo(…, IStorage\*\*  
_pStgDest_);**

Copies a storage, with its name and all its substorages and streams (recursively), to another existing storage. Elements are merged into the target storage, replacing elements with matching names.

### **HRESULT CreateStorage(const WCHAR\*  
_pName_, …, DWORD _mode_, …, IStorage\*\* _ppStg_);**

Creates a new substorage under this storage object.

### **HRESULT CreateStream(const WCHAR\*  
_pName_, …, DWORD _mode_, …, IStream\*\* _ppStream_);**

Creates a new stream under this storage object.

### **HRESULT DestroyElement(const WCHAR\* _pName_);**

Destroys the named storage or stream that is under this storage object. A storage cannot destroy itself.

### **HRESULT EnumElements(…, IEnumSTATSTG\*\* _ppEnumStatstg_);**

Iterates through all the storages and streams under this storage object. The _IEnumSTATSTG_ interface has _Next_, _Skip_, and _Clone_ member functions, as do other COM enumerator interfaces.

### **HRESULT MoveElementTo(const WCHAR\* _pName_,  
IStorage\* _pStgDest_, const LPWSTR\* _pNewName_, DWORD _flags_);**

Moves an element from this storage object to another storage object.

### **HRESULT OpenStream(const WCHAR\*  
_pName_, …, DWORD _mode_, …, IStorage\*\* _ppStg_);**

Opens an existing stream object, designated by name, under this storage object.

### **HRESULT OpenStorage(const WCHAR\*  
_pName_, …, DWORD _mode_, …, IStorage\*\* _ppStg_);**

Opens an existing substorage object, designated by name, under this storage object.

### **DWORD Release(void);**

Decrements the reference count. If the storage is a root storage representing a disk file, _Release_ closes the file when the reference count goes to 0.

### **HRESULT RenameElement(const  
WCHAR\* _pOldName_, const WCHAR\* _pNewName_);**

Assigns a new name to an existing storage or stream under this storage object.

### **HRESULT Revert(void);**

Abandons a transaction, leaving the compound file unchanged.

### **HRESULT SetClass(CLSID& _clsid_);**

Inserts a 128-bit class identifier into this storage object. This ID can then be retrieved with the _Stat_ function.

### **HRESULT Stat(STATSTG\* _pStatstg_**, **DWORD** **_flag_);**

Fills in a _STATSTG_ structure with useful information about the storage object, including its name and class ID_._

**Getting an _IStorage_ Pointer**
---------------------------------

Where do you get the first _IStorage_ pointer? COM gives you the global function _StgCreateDocfile_ to create a new structured storage file on disk and the function _StgOpenStorage_ to open an existing file. Both of these set a pointer to the file's root storage. Here's some code that opens an existing storage file named MyStore.stg and then creates a new substorage:

IStorage\* pStgRoot;
IStorage\* pSubStg;

if (::StgCreateDocfile(L"MyStore.stg",
    STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
    0, &pStgRoot) == S_OK) {
    if (pStgRoot->CreateStorage(L"MySubstorageName",
        STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
        0, 0, &pSubStg) == S_OK) {
        // Do something with pSubStg
        pSubStg->Release();
    }
    pStgRoot->Release();
}

**Freeing _STATSTG_ Memory**
----------------------------

When you call _IStorage::Stat_ with a _STATFLAG_DEFAULT_ value for the flag parameter, COM allocates memory for the element name. You must free this memory in a manner compatible with its allocation. COM has its own allocation system that uses an allocator object with an _IMalloc_ interface. You must get an _IMalloc_ pointer from COM, call _IMalloc::Free_ for the string, and then release the allocator. The code below illustrates this.

If you want just the element size and type and not the name, you can call _Stat_ with the _STATFLAG_NONAME_ flag. In that case, no memory is allocated and you don't have to free it. This seems like an irritating detail, but if you don't follow the recipe, you'll have a memory leak.

**Enumerating the Elements in a Storage Object**
------------------------------------------------

Following is some code that iterates through all the elements under a storage object, differentiating between substorages and streams. The elements are retrieved in a seemingly random sequence, independent of the sequence in which they were created; however, I've found that streams are always retrieved first. The _IEnumSTATSTG::Next_ element fills in a _STATSTG_ structure that tells you whether the element is a stream or a storage object.

IEnumSTATSTG\* pEnum;
IMalloc\* pMalloc;
STATSTG statstg;
extern IStorage\* pStg;  // maybe from OpenStorage
::CoGetMalloc(MEMCTX_TASK, &pMalloc); // assumes AfxOleInit called
VERIFY(pStg->EnumElements(0, NULL, 0, &pEnum) == S_OK)
while (pEnum->Next(1, &statstg, NULL) == NOERROR) {
    if (statstg.type == STGTY_STORAGE) {
        if (pStg->OpenStorage(statstg.pwcsName, NULL,
            STGM_READ | STGM_SHARE_EXCLUSIVE,
            NULL, 0, &pSubStg) == S_OK) {
            // Do something with the substorage
        }
        else if (statstg.type == STGTY_STREAM) {
            // Process the stream
        }
        pMalloc->Free(statstg.pwcsName); // avoids memory leaks
    }
    pMalloc->Release();
}

**Sharing Storages Among Processes**
------------------------------------

If you pass an _IStorage_ pointer to another process, the marshaling code ensures that the other process can access the corresponding storage element and everything below it. This is a convenient way of sharing part of a file. One of the standard data object media types of the _TYMED_ enumeration is _TYMED_ISTORAGE_, and this means you can pass an _IStorage_ pointer on the clipboard or through a drag-and-drop operation.
________________________________________________________________________
7.4.3. - [Streams and the IStream Interface](invcpp5/ch27d.htm)
----------------------------------------------------
 Streams and the IStream Interface 

**Streams and the _IStream_ Interface**
=======================================

If you have a stream object, you can manipulate it through the _IStream_ interface. Streams are always located under a root storage or a substorage object. Streams grow automatically (in 512-byte increments) as you write to them. An MFC class for streams, _COleStreamFile_, makes a stream look like a _CFile_ object. That class won't be of much use to us in this chapter, however.

Once you have a pointer to _IStream_, a number of functions are available to you for manipulating the stream. Here is a list of all the _IStream_ functions:

### **HRESULT CopyTo(IStream\*\* _pStm_, ULARGE_INTEGER _cb_, …);**

Copies _cb_ bytes from this stream to the named stream. _ULARGE_INTEGER_ is a structure with two 32-bit members—_HighPart_ and _LowPart_.

### **HRESULT Clone(IStream\*\* _ppStm_);**

Creates a new stream object with its own seek pointer that references the bytes in this stream. The bytes are not copied, so changes in one stream are visible in the other.

### **HRESULT Commit(…);**

Transactions are not currently implemented for streams.

### **HRESULT Read(void const\* _pv_, ULONG _cb_, ULONG\* _pcbRead_);**

Tries to read _cb_ bytes from this stream into the buffer pointed to by _pv_. The variable _pcbRead_ indicates how many bytes were actually read.

### **DWORD Release(void);**

Closes this stream.

### **HRESULT Revert(void);**

Has no effect for streams.

### **HRESULT Seek(LARGE_INTEGER _dlibMove_,**  
**DWORD _dwOrigin_, ULARGE_INTEGER\* _NewPosition_);**

Seeks to the specified position in this stream. The _dwOrigin_ parameter specifies the origin of the offset defined in the _NewPosition_ parameter.

### **HRESULT SetSize(ULARGE_INTEGER _libNewSize_);**

Extends or truncates a stream. Streams grow automatically as they are written, but calling _SetSize_ can optimize performance.

### **HRESULT Stat(STATSTG\* _pStatstg_,** **DWORD** **_flag_);**

Fills in the _STATSTG_ structure with useful information about the stream, including the stream name and size. The size is useful if you need to allocate memory for a read.

### **HRESULT Write(void const\* _pv_, ULONG _cb_, ULONG\* _pcbWritten_);**

Tries to write _cb_ bytes to this stream from the buffer pointed to by _pv_. The variable _pcbWritten_ indicates how many bytes were actually written.

**_IStream_ Programming**
-------------------------

Here is some sample code that creates a stream under a given storage object and writes some bytes from _m_buffer_ to the stream:

extern IStorage\* pStg;
IStream\* pStream;
ULONG nBytesWritten;

if (pStg->CreateStream(L"MyStreamName",
    STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
    0, 0, &pStream) == S_OK) {
    ASSERT(pStream != NULL);
    pStream->Write(m_buffer, m_nLength, &nBytesWritten);
    pStream->Release();
}
________________________________________________________________________
7.4.4. - [The ILockBytes Interface](invcpp5/ch27e.htm)
----------------------------------------------------
 The ILockBytes Interface 

**The _ILockBytes_ Interface**
==============================

As already mentioned, the compound file system you've been looking at is implemented in the OLE32 DLL. The structured storage interfaces are flexible enough, however, to permit you to change the underlying implementation. The key to this flexibility is the _ILockBytes_ interface. The _StgCreateDocfile_ and _StgOpenStorage_ global functions use the default Windows file system. You can write your own file access code that implements the _ILockBytes_ interface and then call _StgCreateDocfileOnILockBytes_ or _StgOpenStorageOnILockBytes_ to create or open the file, instead of calling the other global functions.

Rather than implement your own _ILockBytes_ interface, you can call _CreateILockBytesOnHGlobal_ to create a compound file in RAM. If you wanted to put compound files inside a database, you would implement an _ILockBytes_ interface that used the database's blobs (binary large objects).
________________________________________________________________________
7.4.5. - [The EX27A Example -- Structured Storage](invcpp5/ch27f.htm)
----------------------------------------------------
 The EX27A Example -- Structured Storage 

**The EX27A Example—Structured Storage**
========================================

When you choose the Storage Write option in the EX27A example, the program walks through your entire disk directory looking for TXT files. As it looks, it writes a compound file (\direct.stg) on the top level of your directory structure. This file contains storages that match your subdirectories. For each TXT file that the program finds in a subdirectory, it copies the first line of text to a stream in the corresponding storage. When you choose the Storage Read option, the program reads the direct.stg compound file and prints the contents of this file in the Debug window.

If you create such an example from scratch, use AppWizard without any ActiveX or Automation options and then add the following lines in your StdAfx.h file:

#include <afxole.h>
#include <afxpriv.h> // for wide-character conversion

Then delete the following line:

#define VC_EXTRALEAN

To prepare EX27A, open the \vcpp32\ex27a\ex27a.dsw workspace and build the project. Run the program from the debugger. First choose Write from the Storage menu and wait for a "Write complete" message box. Then choose Read. Observe the output in the Debug window.

**The Menu**
------------

The EX27A example has an added top-level Storage menu with Write and Read options.

**The _CEx27aView_ Class**
--------------------------

This class maps the new Storage Read and Write menu commands listed above to start worker threads. The handlers are shown here:

void CEx27aView::OnStorageRead()
{
    CWinThread\* pThread = AfxBeginThread(ReadThreadProc, GetSafeHwnd());
}

void CEx27aView::OnStorageWrite()
{
    CWinThread\* pThread = AfxBeginThread(WriteThreadProc, GetSafeHwnd());
}

**The Worker Threads**
----------------------

Figure 27-2 lists the code for the Storage Write and Storage Read worker threads.

**THREAD.H**

extern int g_nIndent;
extern const char\* g_szBlanks;
extern const char\* g_szRootStorageName;

UINT WriteThreadProc(LPVOID pParam);
UINT ReadThreadProc(LPVOID pParam);
void ReadDirectory(const char\* szPath, LPSTORAGE pStg);
void ReadStorage(LPSTORAGE pStg);

**WRITETHREAD.CPP**

#include "StdAfx.h"
#include "Thread.h"

int g_nIndent = 0;
const char\* g_szBlanks = "                                          ";
const char\* g_szRootStorageName = "\\direct.stg";

UINT WriteThreadProc(LPVOID pParam)
{
    USES_CONVERSION;
    LPSTORAGE pStgRoot = NULL;
    g_nIndent = 0;
    VERIFY(::StgCreateDocfile(T2COLE(g_szRootStorageName),
           STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
           0, &pStgRoot) == S_OK);
    ReadDirectory("\\", pStgRoot);
    pStgRoot->Release();
    AfxMessageBox("Write complete");
    return 0;
}

void ReadDirectory(const char\* szPath, LPSTORAGE pStg)
{
    // recursive function
    USES_CONVERSION;
    WIN32_FIND_DATA fData;
    HANDLE h;
    char szNewPath[MAX_PATH];
    char szStorageName[100];
    char szStreamName[100];
    char szData[81];
    char\* pch = NULL;
    LPSTORAGE pSubStg = NULL;
    LPSTREAM pStream = NULL;

    g_nIndent++;
    strcpy(szNewPath, szPath);
    strcat(szNewPath, "\*.\*");
    h = ::FindFirstFile(szNewPath, &fData);
    if (h == (HANDLE) 0xFFFFFFFF) return;  // can't find directory
    do {
        if (!strcmp(fData.cFileName, "..") ||
            !strcmp(fData.cFileName, ".") ) continue;
        while((pch = strchr(fData.cFileName, \`!')) != NULL) {
            \*pch = \`|';
        }
        if (fData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            // It's a directory, so make a storage
            strcpy(szNewPath, szPath);
            strcat(szNewPath, fData.cFileName);
            strcat(szNewPath, "\\");

            strcpy(szStorageName, fData.cFileName);
            szStorageName[31] = \`\0';    // limit imposed by OLE
            TRACE("%0.\*sStorage = %s\n", (g_nIndent - 1) \* 4,
                  g_szBlanks, szStorageName);
            VERIFY(pStg->CreateStorage(T2COLE(szStorageName),
                   STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                   0, 0, &pSubStg) == S_OK);
            ASSERT(pSubStg != NULL);
            ReadDirectory(szNewPath, pSubStg);
            pSubStg->Release();
        }
        else {
            if ((pch = strrchr(fData.cFileName, \`.')) != NULL) {
                if (!stricmp(pch, ".TXT")) {
                    // It's a text file, so make a stream
                    strcpy(szStreamName, fData.cFileName);
                    strcpy(szNewPath, szPath);
                    strcat(szNewPath, szStreamName);
                    szStreamName[32] = \`\0'; // OLE max length
                    TRACE("%0.\*sStream = %s\n", (g_nIndent - 1) \* 4,
                          g_szBlanks, szNewPath);
                    CStdioFile file(szNewPath, CFile::modeRead);
                    // Ignore zero-length files
                    if(file.ReadString(szData, 80)) {
                        TRACE("%s\n", szData);
                       VERIFY(pStg->CreateStream(T2COLE(szStreamName),
                               STGM_CREATE | STGM_READWRITE | 
                               STGM_SHARE_EXCLUSIVE,
                               0, 0, &pStream) == S_OK);
                        ASSERT(pStream != NULL);
                        // Include the null terminator in the stream
                        pStream->Write(szData, strlen(szData) + 1, NULL);
                        pStream->Release();
                    }
                }
            }
        }
    } while (::FindNextFile(h, &fData));
    g_nIndent—;
}

**READTHREAD.CPP**

#include "StdAfx.h"
#include "Thread.h"

UINT ReadThreadProc(LPVOID pParam)
{
    USES_CONVERSION;
    LPSTORAGE pStgRoot = NULL;
    // doesn't work without STGM_SHARE_EXCLUSIVE
    g_nIndent = 0;
    if (::StgOpenStorage(T2COLE(g_szRootStorageName), NULL,
        STGM_READ | STGM_SHARE_EXCLUSIVE,
        NULL, 0, &pStgRoot) == S_OK) {
        ASSERT(pStgRoot!= NULL);
        ReadStorage(pStgRoot);
        pStgRoot->Release();
    }
    else {
        AfxMessageBox("Storage file not available or not readable.");
    }
    AfxMessageBox("Read complete");
    return 0;
}

void ReadStorage(LPSTORAGE pStg)
// reads one storage — recursive calls for substorages
{
    USES_CONVERSION;
    LPSTORAGE pSubStg = NULL;
    LPSTREAM pStream = NULL;
    LPENUMSTATSTG pEnum = NULL;
    LPMALLOC pMalloc = NULL; // for freeing statstg
    STATSTG statstg;
    ULONG nLength;
    BYTE buffer[101];

    g_nIndent++;
    ::CoGetMalloc(MEMCTX_TASK, &pMalloc); // assumes AfxOleInit
                                          //  was called
    VERIFY(pStg->EnumElements(0, NULL, 0, &pEnum) == S_OK);
    while (pEnum->Next(1, &statstg, NULL) == S_OK) {
        if (statstg.type == STGTY_STORAGE) {
            VERIFY(pStg->OpenStorage(statstg.pwcsName, NULL,
                   STGM_READ | STGM_SHARE_EXCLUSIVE,
                   NULL, 0, &pSubStg) == S_OK);
            ASSERT(pSubStg != NULL);
            TRACE("%0.\*sStorage = %s\n", (g_nIndent - 1) \* 4,
                  g_szBlanks, OLE2CT(statstg.pwcsName));
            ReadStorage(pSubStg);
            pSubStg->Release();
        }
        else if (statstg.type == STGTY_STREAM) {
            VERIFY(pStg->OpenStream(statstg.pwcsName, NULL,
                   STGM_READ | STGM_SHARE_EXCLUSIVE,
                   0, &pStream) == S_OK);
            ASSERT(pStream != NULL);
            TRACE("%0.\*sStream = %s\n", (g_nIndent - 1) \* 4,
                  g_szBlanks, OLE2CT(statstg.pwcsName));
            pStream->Read(buffer, 100, &nLength);
            buffer[nLength] = \`\0';
            TRACE("%s\n", buffer);
            pStream->Release();
        }
        else {
            ASSERT(FALSE);  // LockBytes?
        }
        pMalloc->Free(statstg.pwcsName); // avoids memory leaks
    }
    pMalloc->Release();
    pEnum->Release();
    g_nIndent—;
}

**Figure 27-2.** _The Storage menu worker threads._

To keep the program simple, there's no synchronization between the main thread and the two worker threads. You could run both threads at the same time if you used two separate compound files.

From your study of the Win32 threading model, you might expect that closing the main window would cause the read thread or write thread to terminate "midstream," possibly causing memory leaks. But this does not happen because MFC senses that the worker threads are using COM objects. Even though the window closes immediately, the program does not exit until all threads exit.

Both threads use recursive functions. The _ReadStorage_ function reads a storage and calls itself to read the substorages. The _ReadDirectory_ function reads a directory and calls itself to read the subdirectories. This function calls the Win32 functions _FindFirstFile_ and _FindNextFile_ to iterate through the elements in a directory. The _dwFileAttributes_ member of the _WIN32_FIND_DATA_ structure indicates whether the element is a file or a subdirectory. _ReadDirectory_ uses the MFC _CStdioFile_ class because the class is ideal for reading text.

The _USES_CONVERSION_ macro is necessary to support the wide-character conversion macros _OLE2CT_ and _T2COLE_. These macros are used here because the example doesn't use the _CString_ class, which has built-in conversion logic.
________________________________________________________________________
7.4.6. - [Structured Storage and Persistent COM Objects](invcpp5/ch27g.htm)
----------------------------------------------------
 Structured Storage and Persistent COM Objects 

**Structured Storage and Persistent COM Objects**
=================================================

The EX27A program explicitly called member functions of _IStorage_ and _IStream_ to write and read a compound file. In the object-oriented world, objects should know how to save and load themselves to and from a compound file. That's what the _IPersistStorage_ and _IPersistStream_ interfaces are for. If a COM component implements these interfaces, a container program can "connect" the object to a compound file by passing the file's _IStorage_ pointer as a parameter to the _Save_ and _Load_ member functions of the _IPersistStorage_ interface. Such objects are said to be persistent. Figure 27-3 shows the process of calling the _IPersistStorage::Save_ function.

A COM component is more likely to work with an _IStorage_ interface than an _IStream_ interface. If the COM object is associated with a particular storage, the COM component can manage substorages and streams under that storage once it gets the _IStorage_ pointer. A COM component uses the _IStream_ interface only if it stores all its data in an array of bytes. ActiveX controls implement the _IStream_ interface for storing and loading property values.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f27og03x.gif)]

**Figure 27-3.** _Calling_ IPersistStorage::Save.

**The _IPersistStorage_ Interface**
-----------------------------------

Both the _IPersistStorage_ and _IPersistStream_ interfaces are derived from _IPersist_, which contributes the _GetClassID_ member function. Here's a summary of the _IPersistStorage_ member functions:

### **HRESULT GetClassID(CLSID\* _pClsid_);**

Returns the COM component's 128-bit class identifier.

### **HRESULT InitNew(IStorage\* _pStg_);**

Initializes a newly created object. The component might need to use the storage for temporary data, so the container must provide an _IStorage_ pointer that's valid for the life of the object. The component should call _AddRef_ if it intends to use the storage. The component should not use this _IStorage_ pointer for saving and loading; it should wait for _Save_ and _Load_ calls and then use the passed-in _IStorage_ pointer to call _IStorage::Write_ and _Read_.

### **HRESULT IsDirty(void);**

Returns _S_OK_ if the object has changed since it was last saved; otherwise, returns _S_FALSE_.

### **HRESULT Load(IStorage\* _pStg_);**

Loads the COM object's data from the designated storage.

### **HRESULT Save(IStorage\* _pStg_, BOOL _fSameAsLoad_);**

Saves the COM object's data in the designated storage.

**The _IPersistStream_ Interface**
----------------------------------

Here's a summary of the _IPersistStream_ member functions:

### **HRESULT GetClassID(CLSID\* _pClsid_);**

Returns the COM component's 128-bit class identifier.

### **HRESULT GetMaxSize(ULARGE_INTEGER\* _pcbSize_);**

Returns the number of bytes needed to save the object.

### **HRESULT IsDirty(void);**

Returns _S_OK_ if the object has changed since it was last saved; otherwise, returns _S_FALSE_.

### **HRESULT Load(IStream\* _pStm_);**

Loads the COM object's data from the designated stream.

### **HRESULT Save(IStream\* _pStm_, BOOL _fClearDirty_);**

Saves the COM object's data to the designated stream. If the _fClearDirty_ parameter is _TRUE_, _Save_ clears the object's dirty flag.

**_IPersistStream_ Programming**
--------------------------------

The following container program code fragment creates a stream and saves a COM object's data in it. Both the _IPersistStream_ pointer for the COM object and the _IStorage_ pointer are set elsewhere.

extern IStorage\* pStg;
extern IPersistStream\* pPersistStream;
IStream\* pStream;
if (pStg->CreateStream(L"MyStreamName",
    STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
    0, 0, &pStream) == S_OK) {
    ASSERT(pStream != NULL);
    pPersistStream->Save(pStream, TRUE);
    pStream->Release();
}

If you program your own COM class for use in a container, you'll need to use the MFC interface macros to add the _IPersistStream_ interface. Too bad there's not an "interface wizard" to do the job.
________________________________________________________________________
7.4.7. - [The EX27B Example -- A Persistent DLL Component](invcpp5/ch27h.htm)
----------------------------------------------------
 The EX27B Example -- A Persistent DLL Component 

**The EX27B Example—A Persistent DLL Component**
================================================

The EX27B program, which is used by EX27C, is a COM DLL that contains the _CText_ component. This is a simple COM class that implements the _IDispatch_ and _IPersistStream_ interfaces. The _IDispatch_ interface allows access to the component's one and only property, Text, and the _IPersistStream_ interface allows an object to save and load that Text property to and from a structured storage file.

To prepare EX27B, open the \vcpp32\ex27b\ex27b.dsw workspace and build the project. Use regsvr32 or REGCOMP to register the DLL.

Figure 27-4 lists the code for the _CText_ class in Text.h and Text.cpp.

**TEXT.H**

#ifndef __TEXT_H__
#define __TEXT_H__
// CText command target
class CText : public CCmdTarget
{
private:
    char\* m_pchText;

    DECLARE_DYNCREATE(CText)

    CText();           // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CText)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

// Implementation
protected:
    virtual ~CText();
// Generated message map functions

    //{{AFX_MSG(CText)
        // NOTE the ClassWizard will add and remove member functions here.
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
    DECLARE_OLECREATE(CText)

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CText)
    afx_msg VARIANT GetText();
    afx_msg void SetText(const VARIANT FAR& newValue);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()

    BEGIN_INTERFACE_PART(PersistStream, IPersistStream)
        STDMETHOD(GetClassID)(LPCLSID);
        STDMETHOD(IsDirty)();
        STDMETHOD(Load)(LPSTREAM);
        STDMETHOD(Save)(LPSTREAM, BOOL);
        STDMETHOD(GetSizeMax)(ULARGE_INTEGER FAR\*);
    END_INTERFACE_PART(PersistStream)
};

//////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations
//  immediately before the previous line.

#endif // __TEXT_H__

**TEXT.CPP**

#include "stdafx.h"
#include "ex27b.h"
#include "Text.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] =__FILE__;
#endif
//////////////////////////////////////////////////////////////////////
// CText

IMPLEMENT_DYNCREATE(CText, CCmdTarget)

CText::CText()
{
    EnableAutomation();

    // To keep the application running as long as an OLE automation 
    //  object is active, the constructor calls AfxOleLockApp.

    AfxOleLockApp();
    m_pchText = NULL;
}

CText::~CText()
{
    // To terminate the application when all objects created
    //  with OLE automation, the destructor calls AfxOleUnlockApp.

    if(m_pchText != NULL) {
        delete [] m_pchText;
    }
    AfxOleUnlockApp();
}

void CText::OnFinalRelease()
{
    // When the last reference for an automation object is released,
    //  OnFinalRelease is called. The base class will automatically
    //  delete the object. Add additional cleanup required for your
    //  object before calling the base class.

    CCmdTarget::OnFinalRelease();
}

BEGIN_MESSAGE_MAP(CText, CCmdTarget)
    //{{AFX_MSG_MAP(CText)
        // NOTE - ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
BEGIN_DISPATCH_MAP(CText, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CText)
    DISP_PROPERTY_EX(CText, "Text", GetText, SetText, VT_VARIANT)
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IText to support typesafe binding
//  from VBA. This IID must match the GUID that is attached to the 
//  dispinterface in the ODL file.

// {4EBFDD71-5F7D-11D0-848F-00400526305B}
static const IID IID_IText =
{ 0x4ebfdd71, 0x5f7d, 0x11d0, { 0x84, 0x8f, 0x0, 0x40, 0x5, 0x26, 
    0x30, 0x5b } };

BEGIN_INTERFACE_MAP(CText, CCmdTarget)
    INTERFACE_PART(CText, IID_IPersistStream, PersistStream)
    INTERFACE_PART(CText, IID_IText, Dispatch)
END_INTERFACE_MAP()

// {4EBFDD72-5F7D-11D0-848F-00400526305B}
IMPLEMENT_OLECREATE(CText, "Ex27b.Text", 0x4ebfdd72, 0x5f7d, 
    0x11d0, 0x84, 0x8f, 0x0, 0x40, 0x5, 0x26, 0x30, 0x5b)

//////////////////////////////////////////////////////////////////////
// CText message handlers

VARIANT CText::GetText() 
{
    return COleVariant(m_pchText).Detach();
}

void CText::SetText(const VARIANT FAR& newValue) 
{
    CString strTemp;
    ASSERT(newValue.vt == VT_BSTR);
    if(m_pchText != NULL) {
        delete [] m_pchText;
    }
    strTemp = newValue.bstrVal; // converts to narrow chars
    m_pchText = new char[strTemp.GetLength() + 1];
    strcpy(m_pchText, strTemp);
}
//////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CText::XPersistStream::AddRef()
{
    METHOD_PROLOGUE(CText, PersistStream)
    return (ULONG) pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CText::XPersistStream::Release()
{
    METHOD_PROLOGUE(CText, PersistStream)
    return (ULONG) pThis->ExternalRelease();
}

STDMETHODIMP CText::XPersistStream::QueryInterface(REFIID iid,
    void FAR\* FAR\* ppvObj)
{
    METHOD_PROLOGUE(CText, PersistStream)
    // ExternalQueryInterface looks up IID in the macro-generated tables
    return (HRESULT) pThis->ExternalQueryInterface(&iid, ppvObj);
}
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CText::XPersistStream::GetClassID(LPCLSID lpClassID)
{
    TRACE("Entering CText::XPersistStream::GetClassID\n");
    METHOD_PROLOGUE(CText, PersistStream)
    ASSERT_VALID(pThis);

    \*lpClassID = CText::guid;
    return NOERROR;
}

STDMETHODIMP CText::XPersistStream::IsDirty()
{
    TRACE("Entering CText::XPersistStream::IsDirty\n");
    METHOD_PROLOGUE(CText, PersistStream)
    ASSERT_VALID(pThis);

    return NOERROR;
}
STDMETHODIMP CText::XPersistStream::Load(LPSTREAM pStm)
{
    ULONG nLength;
    STATSTG statstg;
    METHOD_PROLOGUE(CText, PersistStream)
    ASSERT_VALID(pThis);
    if(pThis->m_pchText != NULL) {
        delete [] pThis->m_pchText;
    }
    // don't need to free statstg.pwcsName because of NONAME flag
    VERIFY(pStm->Stat(&statstg, STATFLAG_NONAME) == NOERROR);
    int nSize = statstg.cbSize.LowPart; // assume < 4 GB
    if(nSize > 0) {
        pThis->m_pchText = new char[nSize];
        pStm->Read(pThis->m_pchText, nSize, &nLength);
    }
    return NOERROR;
}

STDMETHODIMP CText::XPersistStream::Save(LPSTREAM pStm, BOOL fClearDirty)
{
    METHOD_PROLOGUE(CText, PersistStream)
    ASSERT_VALID(pThis);
    int nSize = strlen(pThis->m_pchText) + 1;
    pStm->Write(pThis->m_pchText, nSize, NULL);
    return NOERROR;
}

STDMETHODIMP CText::XPersistStream::GetSizeMax(ULARGE_INTEGER FAR\* pcbSize)
{
    TRACE("Entering CText::XPersistStream::GetSizeMax\n");
    METHOD_PROLOGUE(CText, PersistStream)
    ASSERT_VALID(pThis);
    pcbSize->LowPart = strlen(pThis->m_pchText) + 1;
    pcbSize->HighPart = 0; // assume < 4 GB
    return NOERROR;
}

**Figure 27-4.** _The code listing for the_ CText _class in Text.h and Text.cpp._

ClassWizard generated the _CText_ class as an ordinary Automation component. The _IPersistStream_ interface was added manually. Look carefully at the _XPersistStream::Load_ and _XPersistStream::Save_ functions. The _Load_ function allocates heap memory and then calls _IStream::Read_ to load the contents of the stream. The _Save_ function copies the object's data to the stream by calling _IStream::Write_.
________________________________________________________________________
7.4.8. - [The EX27C Example -- A Persistent Storage Client Program](invcpp5/ch27i.htm)
----------------------------------------------------
 The EX27C Example -- A Persistent Storage Client Program 

**The EX27C Example—A Persistent Storage Client Program**
=========================================================

This program is similar to EX27A in function—indeed, the storage files are compatible. Internally, however, both worker threads use the persistent COM class _CText_ (EX27B) for loading and storing text.

To prepare EX27C, open the \vcpp32\ex27c\ex27c.dsw workspace and build the project. Run the program from the debugger, first choosing Write from the Storage menu and then choosing Read. Observe the output in the Debug window.

The menu, the view class, and the application class are the same as the EX27A versions. Only the thread code is different.

Figure 27-5 lists the code for both the WriteThread.cpp and the ReadThread.cpp files. ,

**WRITETHREAD.CPP**

#include "StdAfx.h"
#include "Thread.h"
#include "itext.h"

CLSID g_clsid; // for the Text server
int g_nIndent = 0;
const char\* g_szBlanks = "                                          ";
const char\* g_szRootStorageName = "\\direct.stg";

UINT WriteThreadProc(LPVOID pParam)
{
    USES_CONVERSION;
    LPSTORAGE pStgRoot = NULL;
    g_nIndent = 0;
    ::CoInitialize(NULL);
    ::CLSIDFromProgID(L"EX27B.TEXT", &g_clsid);
    VERIFY(::StgCreateDocfile(T2COLE(g_szRootStorageName),
           STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
           0, &pStgRoot) == S_OK);
    ReadDirectory("\\", pStgRoot);
    pStgRoot->Release();
    AfxMessageBox("Write complete");
    return 0;
}
void ReadDirectory(const char\* szPath, LPSTORAGE pStg)
{
    // recursive function
    USES_CONVERSION;
    WIN32_FIND_DATA fData;
    HANDLE h;
    char szNewPath[MAX_PATH];
    char szStorageName[100];
    char szStreamName[100];
    char szData[81];
    char\* pch = NULL;

    LPSTORAGE pSubStg = NULL;
    LPSTREAM pStream = NULL;
    LPPERSISTSTREAM pPersistStream = NULL;

    g_nIndent++;
    strcpy(szNewPath, szPath);
    strcat(szNewPath, "\*.\*");
    h = ::FindFirstFile(szNewPath, &fData);

    if (h == (HANDLE) 0xFFFFFFFF) return;  // can't find directory
    do {
            if (!strcmp(fData.cFileName, "..") ||
                !strcmp(fData.cFileName, ".") ) continue;
            while((pch = strchr(fData.cFileName, \`!')) != NULL) {
                \*pch = \`|';
        }
        if (fData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            // It's a directory, so make a storage
            strcpy(szNewPath, szPath);
            strcat(szNewPath,fData.cFileName);
            strcat(szNewPath, "\\");

            strcpy(szStorageName, fData.cFileName);
            szStorageName[31] = \`\0';    // limit imposed by OLE
            TRACE("%0.\*sStorage = %s\n", (g_nIndent - 1) \* 4,
                  g_szBlanks, szStorageName);
            VERIFY(pStg->CreateStorage(T2COLE(szStorageName),
                   STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                   0, 0, &pSubStg) == S_OK);
            ASSERT(pSubStg != NULL);
            ReadDirectory(szNewPath, pSubStg);
            pSubStg->Release();
        }
        else {
            if ((pch = strrchr(fData.cFileName, \`.')) != NULL) {
                if (!stricmp(pch, ".TXT")) {
                    // It's a text file, so make a stream
                    strcpy(szStreamName, fData.cFileName);
                    strcpy(szNewPath, szPath);
                    strcat(szNewPath, szStreamName);
                    szStreamName[32] = \`\0'; // OLE max length
                    TRACE("%0.\*sStream = %s\n", (g_nIndent - 1) \* 4,
                          g_szBlanks, szNewPath);
                    CStdioFile file(szNewPath, CFile::modeRead);
                    // Ignore zero-length files
                    if(file.ReadString(szData, 80)) {
                        TRACE("%s\n", szData);
                        VERIFY(pStg->CreateStream(T2COLE(szStreamName),
                               STGM_CREATE | STGM_READWRITE | 
                               STGM_SHARE_EXCLUSIVE,
                               0, 0, &pStream) == S_OK);
                        ASSERT(pStream != NULL);
                        // Include the null terminator in the stream
                        IText text;
                        VERIFY(text.CreateDispatch(g_clsid));
                        text.m_lpDispatch->QueryInterface
                            (IID_IPersistStream,
                            (void\*\*) &pPersistStream);
                        ASSERT(pPersistStream != NULL);
                        text.SetText(COleVariant(szData));
                        pPersistStream->Save(pStream, TRUE);
                        pPersistStream->Release();
                        pStream->Release();
                    }
                }
            }
        }
    } while (::FindNextFile(h, &fData));
    g_nIndent—;
}

**READTHREAD.CPP**

#include "StdAfx.h"
#include "Thread.h"
#include "itext.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE
__;
#endif


UINT ReadThreadProc(LPVOID pParam)
{
    g_nIndent = 0;
    ::CoInitialize(NULL);
    ::CLSIDFromProgID(L"EX27B.TEXT", &g_clsid);
    LPSTORAGE pStgRoot = NULL;
    if(::StgOpenStorage(L"\\DIRECT.STG", NULL,
                        STGM_READ|STGM_SHARE_EXCLUSIVE,
                        NULL, 0, &pStgRoot) == S_OK) {
        ASSERT(pStgRoot!= NULL);
        ReadStorage(pStgRoot);
        pStgRoot->Release();
    }
    else {
        AfxMessageBox("Storage file not available or not readable.");
    }
    AfxMessageBox("Read complete");
    return 0;
}

void ReadStorage(LPSTORAGE pStg)
// reads one storage — recursive calls for substorages
{
    LPSTORAGE pSubStg = NULL;
    LPSTREAM pStream = NULL;
    LPENUMSTATSTG pEnum = NULL;
    STATSTG statstg;
    LPPERSISTSTREAM pPersistStream = NULL;

    g_nIndent++;
    if(pStg->EnumElements(0, NULL, 0, &pEnum) != NOERROR) {
        ASSERT(FALSE);
        return;
    }
    while(pEnum->Next(1, &statstg, NULL) == NOERROR) {
        if(statstg.type == STGTY_STORAGE) {
            VERIFY(pStg->OpenStorage(statstg.pwcsName, NULL,
                   STGM_READ|STGM_SHARE_EXCLUSIVE,
                   NULL, 0, &pSubStg) == S_OK);
            ASSERT(pSubStg != NULL);
            ReadStorage(pSubStg);
            pSubStg->Release();
        }
        else if(statstg.type == STGTY_STREAM) {
            VERIFY(pStg->OpenStream(statstg.pwcsName, NULL,
                   STGM_READ|STGM_SHARE_EXCLUSIVE,
                   0, &pStream) == S_OK);
            ASSERT(pStream != NULL);
            IText text;
            VERIFY(text.CreateDispatch(g_clsid));
            text.m_lpDispatch->QueryInterface(IID_IPersistStream, 
                (void\*\*) &pPersistStream);
            ASSERT(pPersistStream != NULL);
            pPersistStream->Load(pStream);
            pPersistStream->Release();
            COleVariant va = text.GetText();
            ASSERT(va.vt == VT_BSTR);
            CString str = va.bstrVal;
            TRACE("%s\n", str);
            pStream->Release();
        }
        else {
            ASSERT(FALSE);  // LockBytes?
        }
        ::CoTaskMemFree(statstg.pwcsName);
    }
    pEnum->Release();
    g_nIndent—;
}

**Figure 27-5.** _The code listing for the two worker threads in EX27C._

Look at the second half of the _ReadDirectory_ function in the WriteThread.cpp file in Figure 27-5. For each TXT file, the program constructs a _CText_ object by constructing an _IText_ driver object and then calling _CreateDispatch_. Then it calls the _SetText_ member function to write the first line of the file to the object. After that, the program calls _IPersistStream::Save_ to write the object to the compound file. The _CText_ object is deleted after the _IPersistStream_ pointer is released and after the _IText_ object is deleted, releasing the object's _IDispatch_ pointer.

Now look at the second half of the _ReadStorage_ function in the ReadThread.cpp file. Like _ReadDirectory_, it constructs an _IText_ driver object and calls _CreateDispatch_. Then it calls _QueryInterface_ to get the object's _IPersistStream_ pointer, which it uses to call _Load_. Finally, the program calls _GetText_ to retrieve the line of text for tracing.

As you've learned already, a COM component usually implements _IPersistStorage_, not _IPersistStream_. The _CText_ class could have worked this way, but then the compound file would have been more complex because each TXT file would have needed both a storage element (to support the interface) and a subsidiary stream element (to hold the text).

Now get ready to take a giant leap. Suppose you have a true creatable-by-CLSID COM component that supports the _IPersistStorage_ interface. Recall the _IStorage_ functions for class IDs. If a storage element contains a class ID, together with all the data an object needs, COM can load the server, use the class factory to construct the object, get an _IPersistStorage_ pointer, and call _Load_ to load the data from a compound file. This is a preview of compound documents, which you'll see in [Chapter 28](ch28a.htm).
________________________________________________________________________
7.4.9. - [Compound File Fragmentation](invcpp5/ch27j.htm)
----------------------------------------------------
 Compound File Fragmentation 

**Compound File Fragmentation**
===============================

Structured storage has a dark side. Like the disk drive itself, compound files can become fragmented with frequent use. If a disk drive becomes fragmented, however, you still have the same amount of free space. With a compound file, space from deleted elements isn't always recovered. This means that compound files can keep growing even if you delete data.

Fortunately, there is a way to recover unused space in a compound file. You simply create a new file and copy the contents. The _IStorage::CopyTo_ function can do the whole job in one call if you use it to copy the root storage. You can either write a stand-alone utility or build a file regeneration capability into your application.
________________________________________________________________________
7.4.10. - [Other Compound File Advantages](invcpp5/ch27k.htm)
----------------------------------------------------
 Other Compound File Advantages 

**Other Compound File Advantages**
==================================

You've seen how compound files add a kind of random access capability to your programs, and you can appreciate the value of transactioning. Now consider the brave new world in which every program can read any other program's documents. We're not there yet, but we have a start. Compound files from Microsoft applications have a stream under the root storage named \005SummaryInformation. This stream is formatted as a property set, as defined for ActiveX controls. If you can decode the format for this stream, you can open any conforming file and read the summary.

Visual C++ comes with a compound file viewing utility named DocFile Viewer (Dfview.exe), which uses a tree view to display the file's storages and streams. Here is the DocFile Viewer output for the structured storage file generated by EX27A.

![](c:/dl/books/windows/msvc5th/invcpp5/images/g27og01.gif)

As a matter of fact, you can use DFVIEW to view the structure of any compound file. Are you starting to see the potential of this "universal file format?"
________________________________________________________________________
7.5. - [Chapter 28 -- OLE Embedded Components and Containers](invcpp5/ch28a.htm)
----------------------------------------------------
 Chapter 28 -- OLE Embedded Components and Containers  Chapter 28

OLE Embedded Components and Containers
======================================

In this chapter, you'll get familiar with the core of Object Linking and Embedding (OLE). You'll learn how an embedded component talks to its container. This is knowledge you'll need to use ActiveX controls, in-place activation (Visual Editing), and linking, all of which are described in Adam Denning's _ActiveX Controls Inside Out_ (Microsoft Press, 1997), Kraig Brockschmidt's _Inside OLE,_ 2d ed. (Microsoft Press, 1995), and other books.

You'll get started with a Microsoft Foundation Class mini-server, an out-of-process OLE component program that supports in-place activation but can't run as a stand-alone program. Running this component will give you a good idea of what OLE looks like to the user, in case you don't know already. You'll also see the extensive MFC support for this kind of application. If you work at only the top MFC level, however, you won't appreciate or understand the underlying OLE mechanisms. For that, you'll have to dig deeper. Shepherd and Wingo's _MFC Internals_ (Addison-Wesley, 1996) provides extensive coverage of the internal workings of MFC's OLE Document support.

Next you'll build a container program that uses the familiar parts of the MFC library but supports embedded OLE objects that can be edited in their own windows. This container can, of course, run your MFC mini-server, but you'll really start to learn OLE when you build a mini-server from scratch and watch the interactions between it and the container.
________________________________________________________________________
7.5.1. - [Embedding vs. In-Place Activation (Visual Editing)](invcpp5/ch28b.htm)
----------------------------------------------------
 Embedding vs. In-Place Activation (Visual Editing) 

**Embedding vs. In-Place Activation (Visual Editing)**
======================================================

Visual Editing is Microsoft's name for in-place activation. A component that supports in-place activation also supports embedding. Both in-place activation and embedding store their data in a container's document, and the container can activate both. An in-place-capable component can run inside the container application's main window, taking over the container's menu and toolbar, and it can run in its own top-level window if necessary. An embedded component can run only in its own window, and that window has a special menu that does not include file commands. Figure 28-1 shows a Microsoft Excel spreadsheet in-place activated inside a Microsoft Word document. Notice the Excel menus and toolbars.

Some container applications support only embedded components; others support both in-place and embedded components. Usually, an in-place container program allows the user to activate in-place components either in place or in their own windows. You should be getting the idea that embedding is a subset of in-place activation. This is true not only at the user level but also at the OLE implementation level. Embedding relies on two key interfaces, _IOleObject_ and _IOleClientSite_, which are used for in-place activation as well.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f28og01x.gif)]

**Figure 28-1.** _An Excel spreadsheet activated inside a Word document._
________________________________________________________________________
7.5.2. - [Mini-Servers vs. Full Servers (Components) -- Linking](invcpp5/ch28c.htm)
----------------------------------------------------
 Mini-Servers vs. Full Servers (Components) -- Linking 

**Mini-Servers vs. Full Servers (Components)—Linking**
======================================================

A mini-server can't be run as a stand-alone program; it depends on a container application to launch it. It can't do its own file I/O but depends on the container's files. A full server, on the other hand, can be run both as a stand-alone program and from a container. When it's running as a stand-alone program, it can read and write its own files, which means that it supports OLE linking. With embedding, the container document contains all the data that the component needs; with linking, the container contains only the name of a file that the component must open.
________________________________________________________________________
7.5.3. - [The Dark Side of Visual Editing](invcpp5/ch28d.htm)
----------------------------------------------------
 The Dark Side of Visual Editing 

**The Dark Side of Visual Editing**
===================================

We're really enthusiastic about the COM architecture, and we truly believe that ActiveX Controls will take over the programming world. We're not so sure about Visual Editing, though, and we aren't alone. From our cumulative experience meeting developers around the world, we've learned that few developers are writing applications that fit the "objects embedded in a document" model. From our programming experiences, we've learned that it is tricky for containers and components to coordinate the size and scale of embedded objects. From our "user" experience, we've learned that in-place activation can be slow and awkward, although the situation is improving with faster computers.

If you don't believe us, try embedding an Excel worksheet in a Word document, as shown in Figure 28-1. Resize the worksheet in both the active mode and the nonactive mode. Notice that the two sizes don't track and that processing is slow.

Consider the need for drawing graphics. Older versions of Microsoft PowerPoint used an in-place component named Microsoft Draw. The idea was that other applications could use this component for all their graphics needs. Well, it didn't work out that way, and PowerPoint now has its own built-in drawing code. If you have old PowerPoint files with Microsoft Draw objects, you'll have a hard time converting them.

Now consider printing. Let's say you receive a Word document over the Internet from Singapore, and that document contains the metafiles for some embedded objects. You don't have the objects' component programs, however. You print the document on your trusty 1200-dpi color laser printer, and the metafiles print with it. Embedded object metafiles can be rendered for a specific printer, but it's doubtful that the person in Singapore used your printer driver when creating the document. The result is less-than-optimal output with incorrect line breaks.

We do believe, however, that the OLE embedding technology has a lot of potential. Playing sounds and movies is cool, and storing objects in a database is interesting. What you learn in this chapter will help you think of new uses for this technology.
________________________________________________________________________
7.5.4. - [Windows Metafiles and Embedded Objects](invcpp5/ch28e.htm)
----------------------------------------------------
 Windows Metafiles and Embedded Objects 

**Windows Metafiles and Embedded Objects**
==========================================

You're going to need a little more Windows theory before you can understand how in-place and embedded components draw in their clients' windows. We've avoided metafiles up to this point because we haven't needed them, but they've always been an integral part of Windows. Think of a metafile as a cassette tape for GDI instructions. To use a cassette, you need a player/recorder, and that's what the metafile device context (DC) is. If you specify a filename when you create the metafile DC, your metafile will be saved on disk; otherwise, it's saved in memory and you get a handle.

In the world of OLE embedding, components create metafiles and containers play them. Here's some component code that creates a metafile containing some text and a rectangle:

CMetaFileDC dcm; // MFC class for metafile DC
VERIFY(dcm.Create());
dcm.SetMapMode(MM_ANISOTROPIC);
dcm.SetWindowOrg(0,0);
dcm.SetWindowExt(5000, -5000);
// drawing code
dcm.Rectangle(CRect(500, -1000, 1500, -2000));
dcm.TextOut(0, 0, m_strText);
HMETAFILE hMF = dcm.Close();
ASSERT(hMF != NULL);

It's possible to create a metafile that uses a fixed mapping mode such as _MM_LOENGLISH_, but with OLE we'll always use the _MM_ANISOTROPIC_ mode, which is not fixed. The metafile contains a _SetWindowExt_ call to set the _x_ and _y_ extents of the window, and the program that plays the metafile calls _SetViewportExt_ to set the extents of the viewport. Here's some code that you might put inside your container view's _OnDraw_ function:

pDC->SetMapMode(MM_HIMETRIC);
pDC->SetViewportExt(5000, 5000);
pDC->PlayMetafile(hMF);

What's supposed to show up on the screen is a rectangle 1-by-1-cm square because the component assumes the _MM_HIMETRIC_ mapping mode. It will be 1-by-1 cm as long as the viewport extent matches the window extent. If the container sets the viewport extent to (5000, 10000) instead, the rectangle will be stretched vertically but the text will be the same size because it's drawn with the nonscalable system font. If the container decided to use a mapping mode other than _MM_HIMETRIC_, it could adjust the viewport extent to retain the 1-by-1-cm size.

To reiterate, the component sets the window extent to the assumed size of the viewable area and draws inside that box. If the component uses a negative _y_ extent, the drawing code works just as it does in _MM_HIMETRIC_ mapping mode. The container somehow gets the component's extent size and attempts to draw the metafile in an area with those _HIMETRIC_ dimensions.

Why are we bothering with metafiles? Because the container needs to draw something in the component's rectangle, even if the component program isn't running. The component creates the metafile and hands it off in a data object to the in-process OLE handler module on the container side of the Remote Procedure Call (RPC) link. The handler then caches the metafile and plays it on demand and also transfers it to and from the container's storage. When a component is in-place active, however, its view code is drawing directly in a window that's managed by the container.
________________________________________________________________________
7.5.5. - [The MFC OLE Architecturefor Component Programs](invcpp5/ch28f.htm)
----------------------------------------------------
 The MFC OLE Architecture for Component Programs 

**The MFC OLE Architecture for Component Programs**
===================================================

We're not going into too many details here—just enough to allow you to understand the new files in the next example. You need to know about three new MFC base classes—_COleIPFrameWnd_, _COleServerDoc_, and _COleServerItem_.

When you use AppWizard to generate an OLE component, AppWizard generates a class derived from each of the base classes, in addition to an application class, a main frame class, and a view class. The _COleIPFrameWnd_ class is rather like _CFrameWnd_. It's your application's main frame window, which contains the view. It has a menu associated with it, _IDR_SRVR_INPLACE_, which will be merged into the container program's menu. When your component program is running in place, it's using the in-place frame, and when it's running stand-alone or embedded, it's using the regular frame, which is an object of a class derived from _CFrameWnd_. The embedded menu is _IDR_SRVR_EMBEDDED_, and the stand-alone menu is _IDR_MAINFRAME_.

The _COleServerDoc_ class is a replacement for _CDocument_. It contains added features that support OLE connections to the container. The _COleServerItem_ class works with the _COleServerDoc_ class. If components never supported OLE linking, the functionality of the two classes could be combined into one class. Because stand-alone component programs do support linking, the MFC architecture dictates that both classes be present in all components. You'll see in the EX28C example that we can make our own simple mini-server without this division.

Together, the _COleServerItem_ class and the _COleServerDoc_ class implement a whole series of OLE interfaces, including _IOleObject_, _IDataObject_, _IPersistStorage_, and _IOleInPlaceActiveObject_. These classes make calls to the container, using interface pointers that the container passes to them. The important things to know, however, are that your derived _CView_ class draws in the component's in-place-active window and that the derived _COleServerItem_ class draws in the metafile on command from the container.
________________________________________________________________________
7.5.6. - [The EX28A Example -- An MFC In-Place_Activated Mini-Server](invcpp5/ch28g.htm)
----------------------------------------------------
 The EX28A Example -- An MFC In-Place-Activated Mini-Server 

**The EX28A Example—An MFC In-Place-Activated Mini-Server**
===========================================================

You don't need much OLE theory to build an MFC mini-server. This example is a good place to start, though, because you'll get an idea of how containers and components interact. This component isn't too sophisticated. It simply draws some text and graphics in a window. The text is stored in the document, and there's a dialog for updating it.

Here are the steps for creating the program from scratch:

2.  **Run AppWizard to create the EX28A project in the \vcpp32\ex28a directory.** Select Single Document interface. Click the Mini-Server option in the AppWizard Step 3 dialog shown here.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g28og01x.gif)]
    
3.  **Examine the generated files.** You've got the familiar application, document, main frame, and view files, but you've got two new files too.
    
    **Header**
    
    **Implementation**
    
    **Class**
    
    **MFC Base Class**
    
    SrvrItem.h
    
    SrvrItem.cpp
    
    _CEx28aSrvrItem_
    
    _COleServerItem_
    
    IpFrame.h
    
    IpFrame.cpp
    
    _CInPlaceFrame_
    
    _COleIPFrameWnd_
    
4.  **Add a text member to the document class.** Add the following public data member in the class declaration in ex28aDoc.h:
    
    **CString m_strText;**
    
    Set the string's initial value to _Initial default text_ in the document's _OnNewDocument_ member function.
    
5.  **Add a dialog to modify the text.** Insert a new dialog template with an edit control, and then use ClassWizard to generate a _CTextDialog_ class derived from _CDialog_. Don't forget to include the dialog class header in ex28aDoc.cpp. Also, use ClassWizard to add a _CString_ member variable named _m_strText_ for the edit control.
    
6.  **Add a new menu command in both the embedded and in-place menus.** Add a Modify menu command in both the _IDR_SRVR_EMBEDDED_ and _IDR_SRVR_INPLACE_ menus. To insert this menu command on the _IDR_SRVR_EMBEDDED_ menu, use the resource editor to add an EX28A-EMBED menu item on the top level, and then add a Modify option on the submenu for this item. Next add an EX28A-INPLACE menu item on the top level of the _IDR_SRVR_INPLACE_ menu and add a Modify option on the EX28A-INPLACE submenu.
    
    To associate both Modify options with one _OnModify_ function, use _ID_MODIFY_ as the ID for the Modify option of both the _IDR_SRVR_EMBEDDED_ and _IDR_SRVR_INPLACE_ menus. Then use ClassWizard to map both Modify options to the _OnModify_ function in the document class. Code the Modify command handler as shown here:
    
    void CEx28aDoc::OnModify() 
    {
        **CTextDialog dlg;
        dlg.m_strText = m_strText;
        if (dlg.DoModal() == IDOK) {
            m_strText = dlg.m_strText;
            UpdateAllViews(NULL); // Trigger CEx28aView::OnDraw
            UpdateAllItems(NULL); // Trigger CEx28aSrvrItem::OnDraw
            SetModifiedFlag();
        }**
    }
    
7.  **Override the view's _OnPrepareDC_ function.** Use ClassWizard to generate the function, and then replace any existing code with the following line:
    
    **pDC->SetMapMode(MM_HIMETRIC);**
    
8.  **Edit the view's _OnDraw_ function.** The following code in ex28aView.cpp draws a 2-cm circle centered in the client rectangle, with the text wordwrapped in the window:
    
    void CEx28aView::OnDraw(CDC\* pDC)
    {
        CEx28aDoc\* pDoc = GetDocument();
        ASSERT_VALID(pDoc);
        **CFont font;
        font.CreateFont(-500, 0, 0, 0, 400, FALSE, FALSE, 0,
                        ANSI_CHARSET, OUT_DEFAULT_PRECIS,
                        CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                        DEFAULT_PITCH | FF_SWISS, "Arial");
        CFont\* pFont = pDC->SelectObject(&font);
        CRect rectClient;
        GetClientRect(rectClient);
        CSize sizeClient = rectClient.Size();
        pDC->DPtoHIMETRIC(&sizeClient);
        CRect rectEllipse(sizeClient.cx / 2 - 1000,
                         -sizeClient.cy / 2 + 1000,
                          sizeClient.cx / 2 + 1000,
                         -sizeClient.cy / 2 - 1000);
        pDC->Ellipse(rectEllipse);
        pDC->TextOut(0, 0, pDoc->m_strText);
        pDC->SelectObject(pFont);**
    }
    
9.  **Edit the server item's _OnDraw_ function.** The following code in the SrvrItem.cpp file tries to draw the same circle drawn in the view's _OnDraw_ function. You'll learn what a server item is shortly.
    
    BOOL CEx28aSrvrItem::OnDraw(CDC\* pDC, CSize& rSize)
    {
        // Remove this if you use rSize
        UNREFERENCED_PARAMETER(rSize);
    
        CEx28aDoc\* pDoc = GetDocument();
        ASSERT_VALID(pDoc);
    
        // TODO: set mapping mode and extent
        //  (The extent is usually the same as the size returned from 
        //  OnGetExtent)
        pDC->SetMapMode(MM_ANISOTROPIC);
        pDC->SetWindowOrg(0,0);
        pDC->SetWindowExt(3000, **\-**3000);
    
        **CFont font;
        font.CreateFont(-500, 0, 0, 0, 400, FALSE, FALSE, 0,
                        ANSI_CHARSET, OUT_DEFAULT_PRECIS,
                        CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                        DEFAULT_PITCH | FF_SWISS, "Arial");
        CFont\* pFont = pDC->SelectObject(&font);
        CRect rectEllipse(CRect(500, -500, 2500, -2500));
        pDC->Ellipse(rectEllipse);
        pDC->TextOut(0, 0, pDoc->m_strText);
        pDC->SelectObject(pFont);**
    
        return TRUE;
    }
    
10.  **Edit the document's _Serialize_ function.** The framework takes care of loading and saving the document's data from and to an OLE stream named _Contents_ that is attached to the object's main storage. You simply write normal serialization code, as shown here:
    
    void CEx28aDoc::Serialize(CArchive& ar)
    {
        if (ar.IsStoring())
        {
            **ar << m_strText;**
        }
        else
        {
            **ar >> m_strText;**
        }
    }
    
    There is also a _CEx28aSrvrItem::Serialize_ function that delegates to the document _Serialize_ function.
    
11.  **Build and register the EX28A application.** You must run the application directly once to update the Registry.
    
12.  **Test the EX28A application.** You need a container program that supports in-place activation. Use Microsoft Excel 97 or a later version if you have it, or build the project in the MFC DRAWCLI sample. Choose the container's Insert Object menu item. If this option does not appear on the Insert menu, it might appear on the Edit menu instead. Then select Ex28a Document from the list.

> NOTE
> 
> You debug an embedded component the same way you debug an Automation EXE component. See the sidebar, "[Debugging an EXE Component Program](ch25n.htm#100)", for more information.

When you first insert the EX28A object, you'll see a hatched border, which indicates that the object is in-place active. The bounding rectangle is 3-by-3-cm square, with a 2-cm circle in the center, as illustrated here.

![](c:/dl/books/windows/msvc5th/invcpp5/images/g28og02.gif)

If you click elsewhere in the container's window, the object becomes inactive, and it's shown like this.

![](c:/dl/books/windows/msvc5th/invcpp5/images/G28og03.gif)

In the first case, you saw the output of the view's _OnDraw_ function; in the second case, you saw the output of the server item's _OnDraw_ function. The circles are the same, but the text is formatted differently because the server (component) item code is drawing on a metafile device context.

If you use the resize handles to extend the height of the object (click once on the object to see the resize handles; don't double-click), you'll stretch the circle and the font will get bigger, as shown below in the figure on the left. If you reactivate the object by double-clicking on it, it's reformatted as shown in the figure on the right.

![](c:/dl/books/windows/msvc5th/invcpp5/images/g28og04.gif) ![](c:/dl/books/windows/msvc5th/invcpp5/images/g28og05.gif)

Click elsewhere in the container's window, single-click on the object, and then choose Ex28a Object from the bottom of the Edit menu. Choose Open from the submenu. This starts the component program in embedded mode rather than in in-place mode, as shown here.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g28og06x.gif)]

Notice that the component's _IDR_SRVR_EMBEDDED_ menu is visible.

**An MDI Embedded Component?**
------------------------------

The EX28A example is an SDI mini-server. Each time a controller creates an EX28A object, a new EX28A process is started. You might expect an MDI mini-server process to support multiple component objects, each with its own document, but this is not the case. When you ask AppWizard to generate an MDI mini-server, it generates an SDI program, as in EX28A. It's theoretically possible to have a single process support multiple embedded objects in different windows, but you can't easily create such a program with the MFC library.

**In-Place Component Sizing Strategy**
--------------------------------------

If you look at the EX28A output, you'll observe that the metafile image does not always match the image in the in-place frame window. We had hoped to create another example in which the two images matched. We were unsuccessful, however, when we tried to use the Microsoft Office 97 applications as containers. Each one did something a little different and unpredictable. A complicating factor is the containers' different zooming abilities.

When AppWizard generates a component program, it gives you an overridden _OnGetExtent_ function in your server item class. This function returns a hard-coded size of (3000, 3000). You can certainly change this value to suit your needs, but be careful if you change it dynamically. We tried maintaining our own document data member for the component's extent, but that messed us up when the container's zoom factor changed. We thought containers would make more use of another component item virtual function, _OnSetExtent_, but they don't.

You'll be safest if you simply make your component extents fixed and assume that the container will do the right thing. Keep in mind that when the container application prints its document, it prints the component metafiles. The metafiles are more important than the in-place views.

If you control both container and component programs, however, you have more flexibility. You can build up a modular document processing system with its own sizing protocol. You can even use other OLE interfaces.
________________________________________________________________________
7.5.7. - [Container_Component Interactions](invcpp5/ch28h.htm)
----------------------------------------------------
 Container-Component Interactions 

**Container-Component Interactions**
====================================

Analyzing the component and the container separately won't help you to understand fully how they work. You must watch them working together to understand their interactions. Let's reveal the complexity one step at a time. Consider first that you have a container EXE and a component EXE, and the container must manage the component by means of OLE interfaces.

Look back to the space simulation example in [Chapter 24](ch24a.htm). The client program called _CoGetClassObject_ and _IClassFactory::CreateInstance_ to load the spaceship component and to create a spaceship object, and then it called _QueryInterface_ to get _IMotion_ and _IVisual_ pointers. An embedding container program works the same way that the space simulation client works. It starts the component program based on the component's class ID, and the component program constructs an object. Only the interfaces are different.

Figure 28-2 shows a container program looking at a component. You've already seen all the interfaces except one—_IOleObject_.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f28og02x.gif)]

**Figure 28-2.** _A container program's view of the component._

**Using the Component's _IOleObject_ Interface**
------------------------------------------------

Loading a component is not the same as activating it. Loading merely starts a process, which then sits waiting for further instructions. If the container gets an _IOleObject_ pointer to the component object, it can call the _DoVerb_ member function with a verb parameter such as _OLEIVERB_SHOW_. The component should then show its main window and act like a Windows-based program. If you look at the _IOleObject::DoVerb_ description, you'll see an _IOleClientSite\*_ parameter. We'll consider client sites shortly, but for now you can simply set the parameter to _NULL_ and most components will work okay.

Another important _IOleObject_ function, _Close_, is useful at this stage. As you might expect, the container calls _Close_ when it wants to terminate the component program. If the component process is currently servicing one embedded object (as is the case with MFC components), the process exits.

**Loading and Saving the Component's Native Data—Compound Documents**
---------------------------------------------------------------------

Figure 28-2 demonstrates that the container manages a storage through an _IStorage_ pointer and that the component implements _IPersistStorage_. That means that the component can load and save its native data when the container calls the _Load_ and _Save_ functions of _IPersistStorage_. You've seen the _IStorage_ and _IPersistStorage_ interfaces used in [Chapter 27](ch27a.htm), but this time the container is going to save the component's class ID in the storage. The container can read the class ID from the storage and use it to start the component program prior to calling _IPersistStorage::Load._

Actually, the storage is very important to the embedded object. Just as a virus needs to live in a cell, an embedded object needs to live in a storage. The storage must always be available because the object is constantly loading and saving itself and reading and writing temporary data.

A compound document appears at the bottom of Figure 28-2. The container manages the whole file, but the embedded components are responsible for the storages inside it. There's one main storage for each embedded object, and the container doesn't know or care what's inside those storages.

**Clipboard Data Transfers**
----------------------------

If you've run any OLE container programs, including Microsoft Excel, you've noticed that you can copy and paste whole embedded objects. There's a special data object format, _CF_EMBEDDEDOBJECT_, for embedded objects. If you put an _IDataObject_ pointer on the clipboard and that data object contains the _CF_EMBEDDEDOBJECT_ format (and the companion _CF___OBJECTDESCRIPTOR_ format), another program can load the proper component program and reconstruct the object.

There's actually less here than meets the eye. The only thing inside the _CF_EMBEDDEDOBJECT_ format is an _IStorage_ pointer. The clipboard copy program verifies that _IPersistStorage::Save_ has been called to save the embedded object's data in the storage, and then it passes off the _IStorage_ pointer in a data object. The clipboard paste program gets the class ID from the source storage, loads the component program, and then calls _IPersistStorage::Load_ to load the data from the source storage.

The data objects for the clipboard are generated as needed by the container program. The component's _IDataObject_ interface isn't used for transferring the objects' native data.

**Getting the Component's Metafile**
------------------------------------

You already know that a component program is supposed to draw in a metafile and that a container is supposed to play it. But how does the component deliver the metafile? That's what the _IDataObject_ interface, shown in Figure 28-2, is for. The container calls _IDataObject::GetData_, asking for a _CF_METAFILEPICT_ format. But wait a minute. The container is supposed to get the metafile even if the component program isn't running. So now you're ready for the next complexity level.

**The Role of the In-Process Handler**
--------------------------------------

If the component program is running, it's in a separate process. Sometimes it's not running at all. In either case, the OLE32 DLL is linked into the container's process. This DLL is known as the object handler.

> NOTE
> 
> It's possible for an EXE component to have its own custom handler DLL, but most components use the "default" OLE32 DLL.

Figure 28-3 shows the new picture. The handler communicates with the component over the RPC link, marshaling all interface function calls. But the handler does more than act as the component's proxy for marshaling; it maintains a cache that contains the component object's metafile. The handler saves and loads the cache to and from storage, and it can fill the cache by calling the component's _IDataObject::GetData_ function.

When the container wants to draw the metafile, it doesn't do the drawing itself; instead, it asks the handler to draw the metafile by calling the handler's _IViewObject2::Draw_ function. The handler tries to satisfy as many container requests as it can without bothering the component program. If the handler needs to call a component function, it takes care of loading the component program if it is not already loaded.

> NOTE
> 
> The _IViewObject2_ interface is an example of OLE's design evolution. Someone decided to add a new function—in this case, _GetExtent_—to the _IViewObject_ interface. _IViewObject2_ is derived from _IViewObject_ and contains the new function. All new components should implement the new interface and should return an _IViewObject2_ pointer when _QueryInterface_ is called for either _IID_IViewObject_ or _IID_IViewObject2_. This is easy with the MFC library because you write two interface map entries that link to the same nested class.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f28og03x.gif)]

**Figure 28-3.** _The in-process handler and the component._

Figure 28-3 shows both object data and metafile data in the object's storage. When the container calls the handler's _IPersistStorage::Save_ function, the handler writes the cache (containing the metafile) to the storage and then calls the component's _IPersistStorage::Save_ function, which writes the object's native data to the same storage. The reverse happens when the object is loaded.
________________________________________________________________________
7.5.8. - [Component States](invcpp5/ch28i.htm)
----------------------------------------------------
 Component States 

**Component States**
====================

Now that you know what a handler is, you're ready for a description of the four states that an embedded object can assume.

**State**

**Description**

Passive

The object exists only in a storage.

Loaded

The object handler is running and has a metafile in its cache, but the EXE component program is not running.

Running

The EXE component program is loaded and running, but the window is not visible to the user.

Active

The EXE component's window is visible to the user.

**The Container Interfaces**
----------------------------

Now for the container side of the conversation. Look at Figure 28-4. The container consists of a document and one or more sites. The _IOleContainer_ interface has functions for iterating over the sites, but we won't worry about iterating over the client sites here. The important interface is _IOleClientSite_. Each site is an object that the component accesses through an _IOleClientSite_ pointer. When the container creates an embedded object, it calls _IOleObject::SetClientSite_ to establish one of the two connections from component to container. The site maintains an _IOleObject_ pointer to its component object.

One important _IOleClientSite_ function is _SaveObject_. When the component decides it's time to save itself to its storage, it doesn't do so directly; instead, it asks the site to do the job by calling _IOleClientSite::SaveObject_. "Why the indirection?" you ask. The handler needs to save the metafile to the storage, that's why. The _SaveObject_ function calls _IPersistStorage::Save_ at the handler level, so the handler can do its job before calling the component's _Save_ function.

Another important _IOleClientSite_ function is _OnShowWindow_. The component program calls this function when it starts running and when it stops running. The client is supposed to display a hatched pattern in the embedded object's rectangle when the component program is running or active.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f28og04x.gif)]

**Figure 28-4.** _The interaction between the container and the component._

**The Advisory Connection**
---------------------------

Figure 28-4 shows another interface attached to the site—_IAdviseSink_. This is the container's end of the second component connection. Why have another connection? The _IOleClientSite_ connection goes directly from the component to the container, but the _IAdviseSink_ connection is routed through the handler. After the site has created the embedded object, it calls _IViewObject2::SetAdvise_, passing its _IAdviseSink_ pointer. Meanwhile, the handler has gone ahead and established two advisory connections to the component. When the embedded object is created, the handler calls _IOleObject::Advise_ and then calls _IDataObject::DAdvise_ to notify the advise sink of changes in the data object. When the component's data changes, it notifies the handler through the _IDataObject_ advisory connection. When the user saves the component's data or closes the program, the component notifies the handler through the _IOleObject_ advisory connection. Figure 28-5 shows these connections.

When the handler gets the notification that the component's data has changed (the component calls _IAdviseSink::OnDataChange_), it can notify the container by calling _IAdviseSink::OnViewChange_. The container responds by calling _IViewObject2::Draw_ in the handler. If the component program is not running, the handler draws its metafile from the cache. If the component program is running, the handler calls the component's _IDataObject::GetData_ function to get the latest metafile, which it draws. The _OnClose_ and _OnSave_ notifications are passed in a similar manner.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f28og05x.gif)]

**Figure 28-5.** _Advisory connection details._

**A Metafile for the Clipboard**
--------------------------------

As you've just learned, the container doesn't deal with the metafile directly when it wants to draw the embedded object; instead, it calls _IViewObject2::Draw_. In one case, however, the container needs direct access to the metafile. When the container copies an embedded object to the clipboard, it must copy a metafile in addition to the embedded object and the object descriptor. That's what the handler's _IDataObject_ interface is for. The container calls _IDataObject::GetData_, requesting a metafile format, and it copies that format into the clipboard's data object.
________________________________________________________________________
7.5.9. - [An Interface Summary](invcpp5/ch28j.htm)
----------------------------------------------------
 An Interface Summary 

**An Interface Summary**
========================

Following is a summary of the important OLE interfaces we'll be using in the remaining examples in this chapter. The function lists are by no means complete, nor are the parameter lists. See MSDN Online Help or Brockschmidt's book for the complete specifications.

**The _IOleObject_ Interface**
------------------------------

Embedded components implement this interface. The client site maintains an _IOleObject_ pointer to an embedded object.

### **HRESULT Advise(IAdviseSink\* _AdvSink_, DWORD\* _pdwConnection_);**

The handler calls this function to establish one of the two advisory connections from the component to the handler. The component usually implements _Advise_ with an OLE advise holder object, which can manage multiple advisory connections.

### **HRESULT Close(DWORD _dwSaveOption_);**

The container calls _Close_ to terminate the component application but to leave the object in the loaded state. Containers call this function when the user clicks outside an in-place-active component's window. Components that support in-place activation should clean up and terminate.

### **HRESULT DoVerb(LONG _iVerb_, …, IOleClientSite\* _pActiveSite_, …);**

Components support numeric verbs as defined in the Registry. A sound component might support a "Play" verb, for example. Embedded components should support the _OLEIVERB_SHOW_ verb, which instructs the object to show itself for editing or viewing. If the component supports in-place activation, this verb starts the Visual Editing process; otherwise, it starts the component program in a window separate from that of its container. The _OLEIVERB_OPEN_ verb causes an in-place-activation-capable component to start in a separate window.

### **HRESULT GetExtent(DWORD _dwDrawAspect_, SIZEL\* _pSizel_);**

The component returns the object extent in _HIMETRIC_ dimensions. The container uses these dimensions to size the rectangle for the component's metafile. Sometimes the container uses the extents that are included in the component's metafile picture.

### **HRESULT SetClientSite(IOleClientSite\* _pClientSite_);**

The container calls _SetClientSite_ to enable the component to store a pointer back to the site in the container.

### **HRESULT SetExtent(DWORD _dwDrawAspect_, SIZEL\* _pSizel_);**

Some containers call this function to impose extents on the component.

### **HRESULT SetHostNames(LPCOLESTR _szContainerApp_, PCOLESTR _szContainerObj_);**

The container calls _SetHostNames_ so that the component can display the container program's name in its window caption.

### **HRESULT Unadvise(DWORD\* _dwConnection_);**

This function terminates the advisory connection set up by _Advise_.

**The _IViewObject2_ Interface**
--------------------------------

Embedded component handlers implement this interface. Handlers are a type of COM component for dealing with certain client-side aspects of linking and embedding. The default handler (the one provided by Microsoft) lives in a DLL named "OLE32.DLL." The container calls its functions, but the component program itself doesn't implement them. An _IViewObject2_ interface cannot be marshaled across a process boundary because it's associated with a device context.

### **HRESULT Draw(DWORD _dwAspect_, …, const LPRECTL _lprcBounds_, …);**

The container calls this function to draw the component's metafile in a specified rectangle.

### **HRESULT SetAdvise(DWORD _dwAspect_, …, IAdviseSink\* _pAdvSink_);**

The container calls _SetAdvise_ to set up the advisory connection to the handler, which in turn sets up the advisory connection to the component.

**The _IOleClientSite_ Interface**
----------------------------------

Containers implement this interface. There is one client site object per component object.

### **HRESULT GetContainer(IOleContainer\*\* _ppContainer_);**

The _GetContainer_ function retrieves a pointer to the container object (document), which can be used to enumerate the container's sites.

### **HRESULT OnShowWindow(BOOL _fShow_);**

The component program calls this function when it switches between the running and the loaded (or active) state. When the object is in the loaded state, the container should display a hatched pattern on the embedded object's rectangle.

### **HRESULT SaveObject(void);**

The component program calls _SaveObject_ when it wants to be saved to its storage. The container calls _IPersistStorage::Save_.

**The _IAdviseSink_ Interface**
-------------------------------

Containers implement this interface. Embedded object handlers call its functions in response to component notifications.

### **void OnClose(void);**

Component programs call this function when they are being terminated.

### **void OnViewChange(DWORD dwAspect, …);**

The handler calls _OnViewChange_ when the metafile has changed. Because the component program must have been running for this notification to have been sent, the handler can call the component's _IDataObject::GetData_ function to get the latest metafile for its cache. The container can then draw this metafile by calling _IViewObject2::Draw_.
________________________________________________________________________
7.5.10. - [OLE Helper Functions](invcpp5/ch28k.htm)
----------------------------------------------------
 OLE Helper Functions 

**OLE Helper Functions**
========================

A number of global OLE functions encapsulate a sequence of OLE interface calls. Following are some that we'll use in the EX28B example:

### **HRESULT OleCreate(REFCLSID _rclsid_, REFIID _riid_, …, IOleClientSite\* _pClientSite_, IStorage\* _pStg_, void\*\* _ppvObj_);**

The _OleCreate_ function first executes the COM creation sequence using the specified class ID. This loads the component program. Then the function calls _QueryInterface_ for an _IPersistStorage_ pointer, which it uses to call _InitNew_, passing the _pStg_ parameter. It also calls _QueryInterface_ to get an _IOleObject_ pointer, which it uses to call _SetClientSite_ using the _pClientSite_ parameter. Finally it calls _QueryInterface_ for the interface specified by _riid_, which is usually _IID_IOleObject_.

### **HRESULT OleCreateFromData(IDataObject\* _pSrcDataObj_, REFIID _riid_, …, IOleClientSite\* _pClientSite_, IStorage\* _pStg_, void\*\* _ppvObj_);**

The _OleCreateFromData_ function creates an embedded object from a data object. In the EX28B example, the incoming data object has the _CF_EMBEDDEDOBJECT_ format with an _IStorage_ pointer. The function then loads the component program based on the class ID in the storage, and then it calls _IPersistStorage::Load_ to make the component load the object's native data. Along the way, it calls _IOleObject::SetClientSite_.

### **HRESULT OleDraw(IUnknown\* _pUnk_, DWORD _dwAspect_, HDC _hdcDraw_, LPCRECT _lprcBounds_);**

This function calls _QueryInterface_ on _pUnk_ to get an _IViewObject_ pointer, and then it calls _IViewObject::Draw_, passing the _lprcBounds_ parameter.

### **HRESULT OleLoad(IStorage\* _pStg_, REFIID _riid_, IOleClientSite\* _pClientSite_, void\*\* _ppvObj_);**

The _OleLoad_ function first executes the COM creation sequence by using the class ID in the specified storage. Then it calls _IOleObject::SetClientSite_ and _IPersistStorage::Load_. Finally, it calls _QueryInterface_ for the interface specified by _riid_, which is usually _IID_IOleObject_.

### **HRESULT OleSave(IPersistStorage\* _pPS_, IStorage\* _pStg_, …);**

This function calls _IPersistStorage::GetClassID_ to get the object's class ID, and then it writes that class ID in the storage specified by _pStg_. Finally it calls _IPersistStorage::Save_.
________________________________________________________________________
7.5.11. - [An OLE Embedding Container Application](invcpp5/ch28l.htm)
----------------------------------------------------
 An OLE Embedding Container Application 

**An OLE Embedding Container Application**
==========================================

Now that we've got a working mini-server that supports embedding (EX28A), we'll write a container program to run it. We're not going to use the MFC container support, however, because you need to see what's happening at the OLE interface level. We will use the MFC document-view architecture and the MFC interface maps, and we'll also use the MFC data object classes.

**MFC Support for OLE Containers**
----------------------------------

If you did use AppWizard to build an MFC OLE container application, you'd get a class derived from _COleDocument_ and a class derived from _COleClientItem_. These MFC base classes implement a number of important OLE container interfaces for embedding and in-place activation. The idea is that you have one _COleClientItem_ object for each embedded object in a single container document. Each _COleClientItem_ object defines a site, which is where the component object lives in the window.

The _COleDocument_ class maintains a list of client items, but it's up to you to specify how to select an item and how to synchronize the metafile's position with the in-place frame position. AppWizard generates a basic container application with no support for linking, clipboard processing, or drag and drop. If you want those features, you might be better off looking at the MFC DRAWCLI and OCLIENT samples.

We will use one MFC OLE class in the container—_COleInsertDialog_. This class wraps the _OleUIInsertObject_ function, which invokes the standard Insert Object dialog box. This Insert Object dialog enables the user to select from a list of registered component programs.

**Some Container Limitations**
------------------------------

Because our container application is designed for learning, we'll make some simplifications to reduce the bulk of the code. First of all, this container won't support in-place activation—it allows the user to edit embedded objects only in a separate window. Also, the container supports only one embedded item per document, and that means there's no linking support. The container uses a structured storage file to hold the document's embedded item, but it handles the storage directly, bypassing the framework's serialization system. Clipboard support is provided; drag-and-drop support is not. Outside these limitations, however, it's a pretty good container!

**Container Features**
----------------------

So, what does the container actually do? Here's a list of features:

*   As an MFC MDI application, it handles multiple documents.
    
*   Displays the component's metafile in a sizeable, moveable tracker rectangle in the view window.
    
*   Maintains a temporary storage for each embedded object.
    
*   Implements the Insert Object menu option, which allows the user to select a registered component. The selected component program starts in its own window.
    
*   Allows embedded objects to be copied (and cut) to the clipboard and pasted. These objects can be transferred to and from other containers such as Microsoft Word and Microsoft Excel.
    
*   Allows an embedded object to be deleted.
    
*   Tracks the component program's loaded-running transitions and hatches the tracker rectangle when the component is running or active.
    
*   Redraws the embedded object's metafile on receipt of component change notifications.
    
*   Saves the object in its temporary storage when the component updates the object or exits.
    
*   Copies the embedded object's temporary storage to and from named storage files in response to Copy To and Paste From commands on the Edit menu.
________________________________________________________________________
7.5.12. - [The EX28B Example -- An Embedding Container](invcpp5/ch28m.htm)
----------------------------------------------------
 The EX28B Example -- An Embedding Container 

**The EX28B Example—An Embedding Container**
============================================

Now we can move on to the working program. It's a good time to open the \vcpp32\ex28b\ex28b.dsw workspace and build the EX28B project. If you choose Insert Object from the Edit menu and select Ex28a Document, the EX28A component will start. If you change the component's data, the container and the component will look like this.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g28og07x.gif)]

**The _CEx28bView_ Class**
--------------------------

You can best understand the program by first concentrating on the view class. Look at the code in Figure 28-6, but ignore all _IOleClientSite_ pointers. The container program will actually work if you pass _NULL_ in every _IOleClientSite_ pointer parameter. It just won't get notifications when the metafile or the native data changes. Also, components will appear displaying their stand-alone menus instead of the special embedded menus.

**EX28BVIEW.H**

#if !defined(AFX_EX28BVIEW_H__1EAAB6E1_6011_11D0_848F_00400526305B__INCLUDED_)
#define AFX_EX28BVIEW_H__1EAAB6E1_6011_11D0_848F_00400526305B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define CF_OBJECTDESCRIPTOR "Object Descriptor"
#define CF_EMBEDDEDOBJECT "Embedded Object"
#define SETFORMATETC(fe, cf, asp, td, med, li)   \
    ((fe).cfFormat=cf, \
     (fe).dwAspect=asp, \
     (fe).ptd=td, \
     (fe).tymed=med, \
     (fe).lindex=li)
////////////////////////////////////////////////////////////////////
class CEx28bView : public CScrollView
{
public:
    CLIPFORMAT m_cfObjDesc;
    CLIPFORMAT m_cfEmbedded;
    CSize m_sizeTotal;  // document size
    CRectTracker m_tracker;
    CRect m_rectTracker; // logical coords
protected: // create from serialization only
    CEx28bView();
    DECLARE_DYNCREATE(CEx28bView)

// Attributes
public:
    CEx28bDoc\* GetDocument();

private:
    void GetSize();
    void SetNames();
    void SetViewAdvise();
    BOOL MakeMetafilePict(COleDataSource\* pSource);
    COleDataSource\* SaveObject();
    BOOL DoPasteObject(COleDataObject\* pDataObject);
    BOOL DoPasteObjectDescriptor(COleDataObject\* pDataObject);

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEx28bView)
    public:
    virtual void OnDraw(CDC\* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual void OnInitialUpdate();
    protected:
    virtual BOOL OnPreparePrinting(CPrintInfo\* pInfo);
    virtual void OnBeginPrinting(CDC\* pDC, CPrintInfo\* pInfo);
    virtual void OnEndPrinting(CDC\* pDC, CPrintInfo\* pInfo);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CEx28bView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CEx28bView)
    afx_msg void OnEditCopy();
    afx_msg void OnUpdateEditCopy(CCmdUI\* pCmdUI);
    afx_msg void OnEditCopyto();
    afx_msg void OnEditCut();
    afx_msg void OnEditPaste();
    afx_msg void OnUpdateEditPaste(CCmdUI\* pCmdUI);
    afx_msg void OnEditPastefrom();
    afx_msg void OnEditInsertobject();
    afx_msg void OnUpdateEditInsertobject(CCmdUI\* pCmdUI);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
    afx_msg BOOL OnSetCursor(CWnd\* pWnd, UINT nHitTest, 
                             UINT message);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in ex28bView.cpp
inline CEx28bDoc\* CEx28bView::GetDocument()
    { return (CEx28bDoc\*)
m_pDocument; }
#endif

////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
//  immediately before the previous line.

#endif 
//!defined(AFX_EX28BVIEW_H__1EAAB6E1_6011_11D0_848F_00400526305B__INCLUDED_)

**EX28BVIEW.CPP**

#include "stdafx.h"
#include "ex28b.h"

#include "ex28bDoc.h"
#include "ex28bView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = _FILE_;
#endif

////////////////////////////////////////////////////////////////////
// CEx28bView

IMPLEMENT_DYNCREATE(CEx28bView, CScrollView)

BEGIN_MESSAGE_MAP(CEx28bView, CScrollView)
    //{{AFX_MSG_MAP(CEx28bView)
    ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
    ON_COMMAND(ID_EDIT_COPYTO, OnEditCopyto)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPYTO, OnUpdateEditCopy)
    ON_COMMAND(ID_EDIT_CUT, OnEditCut)
    ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCopy)
    ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
    ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
    ON_COMMAND(ID_EDIT_PASTEFROM, OnEditPastefrom)
    ON_COMMAND(ID_EDIT_INSERTOBJECT, OnEditInsertobject)
    ON_UPDATE_COMMAND_UI(ID_EDIT_INSERTOBJECT, 
                         OnUpdateEditInsertobject)
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONDBLCLK()
    ON_WM_SETCURSOR()
    //}}AFX_MSG_MAP
    // Standard printing commands
    ON_COMMAND(ID_FILE_PRINT, CScrollView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_DIRECT, CScrollView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW,
               CScrollView::OnFilePrintPreview)
END_MESSAGE_MAP()

////////////////////////////////////////////////////////////////////
// CEx28bView construction/destruction

CEx28bView::CEx28bView() : m_sizeTotal(20000, 25000),
    // 20 x 25 cm when printed
    m_rectTracker(0, 0, 0, 0) 
{
    m_cfObjDesc = ::RegisterClipboardFormat(CF_OBJECTDESCRIPTOR);
    m_cfEmbedded = ::RegisterClipboardFormat(CF_EMBEDDEDOBJECT);
}

CEx28bView::~CEx28bView()
{
}

BOOL CEx28bView::PreCreateWindow(CREATESTRUCT& cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return CScrollView::PreCreateWindow(cs);
}

////////////////////////////////////////////////////////////////////
// CEx28bView drawing

void CEx28bView::OnDraw(CDC\* pDC)
{
    CEx28bDoc\* pDoc = GetDocument();

    if(pDoc->m_lpOleObj != NULL) {
        VERIFY(::OleDraw(pDoc->
m_lpOleObj, DVASPECT_CONTENT,
               pDC->GetSafeHdc(), 
m_rectTracker) == S_OK);
    }

    m_tracker.m_rect = 
m_rectTracker;
    pDC->LPtoDP(m_tracker.m_rect);   // device
    if(pDoc->m_bHatch) {
        m_tracker.
m_nStyle |= CRectTracker::hatchInside;
    }
    else {
        m_tracker.
m_nStyle &= ~CRectTracker::hatchInside;
    }
    m_tracker.Draw(pDC);
}

////////////////////////////////////////////////////////////////////
// CEx28bView printing

BOOL CEx28bView::OnPreparePrinting(CPrintInfo\* pInfo)
{
    pInfo->SetMaxPage(1);
    return DoPreparePrinting(pInfo);
}

void CEx28bView::OnBeginPrinting(CDC\* /\*pDC\*/, CPrintInfo\* /\*pInfo\*/)
{
    // TODO: add extra initialization before printing
}

void CEx28bView::OnEndPrinting(CDC\* /\*pDC\*/, CPrintInfo\* /\*pInfo\*/)
{
    // TODO: add cleanup after printing
}

////////////////////////////////////////////////////////////////////
// CEx28bView diagnostics

#ifdef _DEBUG
void CEx28bView::AssertValid() const
{
    CScrollView::AssertValid();
}

void CEx28bView::Dump(CDumpContext& dc) const
{
    CScrollView::Dump(dc);
}

CEx28bDoc\* CEx28bView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CEx28bDoc)));
    return (CEx28bDoc\*)m_pDocument;
}
#endif //_DEBUG

////////////////////////////////////////////////////////////////////
// CEx28bView message handlers

void CEx28bView::OnInitialUpdate() 
{
    TRACE("CEx28bView::OnInitialUpdate\n");
    m_rectTracker = CRect(1000, -1000, 5000, -5000);
    m_tracker.m_nStyle = CRectTracker::solidLine |
        CRectTracker::resizeOutside;
    SetScrollSizes(MM_HIMETRIC, 
m_sizeTotal);
    CScrollView::OnInitialUpdate();
}

void CEx28bView::OnEditCopy() 
{
    COleDataSource\* pSource = SaveObject();
    if(pSource) {
        pSource->SetClipboard(); // OLE deletes data source 
    }
}

void CEx28bView::OnUpdateEditCopy(CCmdUI\* pCmdUI) 
{
    // serves Copy, Cut, and Copy To
    pCmdUI->Enable(GetDocument()->
m_lpOleObj != NULL);
}

void CEx28bView::OnEditCopyto() 
{
    // Copy text to an STG file (nothing special about STG ext)
    CFileDialog dlg(FALSE, "stg", "\*.stg");
    if (dlg.DoModal() != IDOK) {
        return;
    }
    CEx28bDoc\* pDoc = GetDocument();
    // Create a structured storage home for the object ( pStgSub).
    //  Create a root storage file, then a substorage named "sub".
    LPSTORAGE pStgRoot;
    VERIFY(::StgCreateDocfile(dlg.GetPathName().AllocSysString(),
           STGM_READWRITE|STGM_SHARE_EXCLUSIVE|STGM_CREATE,
           0, &pStgRoot) == S_OK);
    ASSERT(pStgRoot != NULL);

    LPSTORAGE pStgSub;
    VERIFY(pStgRoot->CreateStorage(CEx28bDoc::s_szSub,
           STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
           0, 0, &pStgSub) == S_OK); 
    ASSERT(pStgSub != NULL);

    // Get the IPersistStorage\* for the object
    LPPERSISTSTORAGE pPS = NULL;
    VERIFY(pDoc->m_lpOleObj->QueryInterface(IID_IPersistStorage,
          (void\*\*) &pPS) == S_OK);

    // Finally, save the object in its new home in the user's file
    VERIFY(::OleSave(pPS, pStgSub, FALSE) == S_OK); 
    // FALSE means different stg
    pPS->SaveCompleted(NULL);  // What does this do?
    pPS->Release();

    pStgSub->Release();
    pStgRoot->Release();
}

void CEx28bView::OnEditCut() 
{
    OnEditCopy();
    GetDocument()->OnEditClearAll();
}
void CEx28bView::OnEditPaste() 
{
    CEx28bDoc\* pDoc = GetDocument();
    COleDataObject dataObject;
    VERIFY(dataObject.AttachClipboard());
    pDoc->DeleteContents();
    DoPasteObjectDescriptor(&dataObject);
    DoPasteObject(&dataObject);
    SetViewAdvise();
    GetSize();
    pDoc->SetModifiedFlag();
    pDoc->UpdateAllViews(NULL);
}

void CEx28bView::OnUpdateEditPaste(CCmdUI\* pCmdUI) 
{
    // Make sure that object data is available
    COleDataObject dataObject;
    if (dataObject.AttachClipboard() &&
        dataObject.IsDataAvailable(
m_cfEmbedded)) {
        pCmdUI->Enable(TRUE);
    } else {
        pCmdUI->Enable(FALSE);
    }
}

void CEx28bView::OnEditPastefrom() 
{
    CEx28bDoc\* pDoc = GetDocument();
    // Paste from an STG file
    CFileDialog dlg(TRUE, "stg", "\*.stg");
    if (dlg.DoModal() != IDOK) {
        return;
    }
    // Open the storage and substorage
    LPSTORAGE pStgRoot;
    VERIFY(::StgOpenStorage(dlg.GetPathName().AllocSysString(),
           NULL, STGM_READ|STGM_SHARE_EXCLUSIVE,
           NULL, 0, &pStgRoot) == S_OK);
    ASSERT(pStgRoot != NULL);

    LPSTORAGE pStgSub;
    VERIFY(pStgRoot->OpenStorage(CEx28bDoc::s_szSub, NULL,
           STGM_READ|STGM_SHARE_EXCLUSIVE,
           NULL, 0, &pStgSub) == S_OK);
    ASSERT(pStgSub != NULL);

    // Copy the object data from the user storage to the temporary
    //  storage
    VERIFY(pStgSub->CopyTo(NULL, NULL, NULL, 
           pDoc->
m_pTempStgSub) == S_OK);
    // Finally, load the object -- pClientSite not necessary
    LPOLECLIENTSITE pClientSite =
        (LPOLECLIENTSITE) pDoc->GetInterface(&IID_IOleClientSite);
    ASSERT(pClientSite != NULL);
    pDoc->DeleteContents();
    VERIFY(::OleLoad(pDoc->m
_pTempStgSub, IID_IOleObject,
           pClientSite, (void\*\*) &pDoc->
m_lpOleObj) == S_OK);
    SetViewAdvise();
    pStgSub->Release();
    pStgRoot->Release();
    GetSize();
    pDoc->SetModifiedFlag();
    pDoc->UpdateAllViews(NULL);
}

void CEx28bView::OnEditInsertobject() 
{
    CEx28bDoc\* pDoc = GetDocument();
    COleInsertDialog dlg;
    if(dlg.DoModal() == IDCANCEL) return;
    // no addrefs done for GetInterface
    LPOLECLIENTSITE pClientSite =
        (LPOLECLIENTSITE) pDoc->GetInterface(&IID_IOleClientSite);
    ASSERT(pClientSite != NULL);
    pDoc->DeleteContents();
    VERIFY(::OleCreate(dlg.GetClassID(), IID_IOleObject,
           OLERENDER_DRAW, NULL, pClientSite, pDoc->m_pTempStgSub,
           (void\*\*) &pDoc->
m_lpOleObj) == S_OK);
    SetViewAdvise();

    pDoc->m_lpOleObj->DoVerb(OLEIVERB_SHOW, NULL, pClientSite, 0, 
        NULL, NULL); // OleRun doesn't show it
    SetNames();
    GetDocument()->SetModifiedFlag();
    GetSize();
    pDoc->UpdateAllViews(NULL);
}

void CEx28bView::OnUpdateEditInsertobject(CCmdUI\* pCmdUI) 
{
    pCmdUI->Enable(GetDocument()->m_lpOleObj == NULL);
}

void CEx28bView::OnLButtonDown(UINT nFlags, CPoint point) 
{
    TRACE("\*\*Entering CEx28bView::OnLButtonDown -- point = "
          "(%d, %d)\n", point.x, point.y);
    if(m_tracker.Track(this, point, FALSE, NULL)) {
        CClientDC dc(this);
        OnPrepareDC(&dc);
        m_rectTracker = 
m_tracker.m_rect;
        dc.DPtoLP(
m_rectTracker); // Update logical coords
        GetDocument()->UpdateAllViews(NULL);
    }
    TRACE("\*\*Leaving CEx28bView::OnLButtonDown\n");
}

void CEx28bView::OnLButtonDblClk(UINT nFlags, CPoint point) 
{
    if(m_tracker.HitTest(point) == CRectTracker::hitNothing) return;
    // Activate the object
    CEx28bDoc\* pDoc = GetDocument();
    if(pDoc->m_lpOleObj != NULL) {
        LPOLECLIENTSITE pClientSite =
            (LPOLECLIENTSITE) 
             pDoc->GetInterface(&IID_IOleClientSite);
        ASSERT(pClientSite != NULL);
        VERIFY(pDoc->
m_lpOleObj->DoVerb(OLEIVERB_OPEN, NULL,
               pClientSite, 0,GetSafeHwnd(), CRect(0, 0, 0, 0))
               == S_OK);
        SetNames();
        GetDocument()->SetModifiedFlag();
    }
}

BOOL CEx28bView::OnSetCursor(CWnd\* pWnd, UINT nHitTest, UINT message)
{
    if(m_tracker.SetCursor(pWnd, nHitTest)) {
        return TRUE;
    }
    else {
        return CScrollView::OnSetCursor(pWnd, nHitTest, message);
    }
}

////////////////////////////////////////////////////////////////////

void CEx28bView::SetViewAdvise() 
{
    CEx28bDoc\* pDoc = GetDocument();
    if(pDoc->m_lpOleObj != NULL) {
        LPVIEWOBJECT2 pViewObj;
        pDoc->
m_lpOleObj->QueryInterface(IID_IViewObject2, 
            (void\*\*) &pViewObj);
        LPADVISESINK pAdviseSink = 
            (LPADVISESINK) pDoc->GetInterface(&IID_IAdviseSink);
        VERIFY(pViewObj->SetAdvise(DVASPECT_CONTENT, 0, pAdviseSink)
            == S_OK);
        pViewObj->Release();
    }
}

void CEx28bView::SetNames() // sets host names
{
    CEx28bDoc\* pDoc = GetDocument();
    CString strApp = AfxGetApp()->
m_pszAppName;
    if(pDoc->m_lpOleObj != NULL) {
        pDoc->
m_lpOleObj->SetHostNames(strApp.AllocSysString(),
        NULL);
    }
}

void CEx28bView::GetSize()
{
    CEx28bDoc\* pDoc = GetDocument();
    if(pDoc->m_lpOleObj != NULL) {
        SIZEL size;      // Ask the component for its size
        pDoc->
m_lpOleObj->GetExtent(DVASPECT_CONTENT, &size);
        m_rectTracker.right = m_rectTracker.left + size.cx;
        m_rectTracker.bottom = m_rectTracker.top - size.cy;
    }
}

BOOL CEx28bView::DoPasteObject(COleDataObject\* pDataObject)
{
    TRACE("Entering CEx28bView::DoPasteObject\n");
    // Update command UI should keep us out of here if not 
    //  CF_EMBEDDEDOBJECT
    if (!pDataObject->IsDataAvailable(m_cfEmbedded)) {
        TRACE("CF_EMBEDDEDOBJECT format is unavailable\n");
        return FALSE;
    }
    CEx28bDoc\* pDoc = GetDocument();
    // Now create the object from the IDataObject\*.
    //  OleCreateFromData will use CF_EMBEDDEDOBJECT format if
    //  available.
    LPOLECLIENTSITE pClientSite = 
        (LPOLECLIENTSITE) pDoc->GetInterface(&IID_IOleClientSite);
    ASSERT(pClientSite != NULL);
    VERIFY(::OleCreateFromData(pDataObject->m_lpDataObject,
           IID_IOleObject, OLERENDER_DRAW, NULL, pClientSite,
           pDoc->
m_pTempStgSub, (void\*\*) &pDoc->m_lpOleObj) == S_OK);
    return TRUE;
}

BOOL CEx28bView::DoPasteObjectDescriptor(COleDataObject\* pDataObject)
{
    TRACE("Entering CEx28bView::DoPasteObjectDescriptor\n");
    STGMEDIUM stg;

    FORMATETC fmt;
    CEx28bDoc\* pDoc = GetDocument();
    if (!pDataObject->IsDataAvailable(m_cfObjDesc)) {
        TRACE("OBJECTDESCRIPTOR format is unavailable\n");
        return FALSE;
    }
    SETFORMATETC(fmt, m_cfObjDesc, DVASPECT_CONTENT, NULL, 
        TYMED_HGLOBAL, -1);
    VERIFY(pDataObject->GetDatam_cfObjDesc, &stg, &fmt));

    return TRUE;
}

// helper function used for clipboard and drag-drop 
COleDataSource\* CEx28bView::SaveObject()
{
    TRACE("Entering CEx28bView::SaveObject\n");
    CEx28bDoc\* pDoc = GetDocument();
    if (pDoc->m_lpOleObj != NULL) {
        COleDataSource\* pSource = new COleDataSource();

        // CODE FOR OBJECT DATA
        FORMATETC fmte;
        SETFORMATETC(fmte, m_cfEmbedded, DVASPECT_CONTENT, NULL,
            TYMED_ISTORAGE, -1);
        STGMEDIUM stgm;
        stgm.tymed = TYMED_ISTORAGE;
        stgm.pstg = pDoc->m_pTempStgSub;
        stgm.pUnkForRelease = NULL;
        pDoc->m_pTempStgSub->AddRef();   // must do both!
        pDoc->m_pTempStgRoot->AddRef();
        pSource->CacheData(m_cfEmbedded, &stgm, &fmte);

        // metafile needed too
        MakeMetafilePict(pSource);

        // CODE FOR OBJECT DESCRIPTION DATA
        HGLOBAL hObjDesc = ::GlobalAlloc(GMEM_SHARE,
            sizeof(OBJECTDESCRIPTOR));
        LPOBJECTDESCRIPTOR pObjDesc =
            (LPOBJECTDESCRIPTOR) ::GlobalLock(hObjDesc);
        pObjDesc->cbSize = sizeof(OBJECTDESCRIPTOR);
        pObjDesc->clsid = CLSID_NULL;
        pObjDesc->dwDrawAspect = 0;
        pObjDesc->dwStatus = 0;
        pObjDesc->dwFullUserTypeName = 0;
        pObjDesc->dwSrcOfCopy = 0;
        pObjDesc->sizel.cx = 0;
        pObjDesc->sizel.cy = 0;
        pObjDesc->pointl.x = 0;
        pObjDesc->pointl.y = 0;
        ::GlobalUnlock(hObjDesc);
        pSource->CacheGlobalData(
m_cfObjDesc, hObjDesc);
        return pSource;
    }
    return NULL;
}

BOOL CEx28bView::MakeMetafilePict(COleDataSource\* pSource)
{
    CEx28bDoc\* pDoc = GetDocument();
    COleDataObject dataObject;
    LPDATAOBJECT pDataObj; // OLE object's IDataObject interface
    VERIFY(pDoc->m_lpOleObj->QueryInterface(IID_IDataObject,
          (void\*\*) &pDataObj) == S_OK);
    dataObject.Attach(pDataObj);
    FORMATETC fmtem;
    SETFORMATETC(fmtem, CF_METAFILEPICT, DVASPECT_CONTENT, NULL,
        TYMED_MFPICT, -1);
    if (!dataObject.IsDataAvailable(CF_METAFILEPICT, &fmtem)) {
        TRACE("CF_METAFILEPICT format is unavailable\n");
        return FALSE;
    }
    // Just copy the metafile handle from the OLE object
    //  to the clipboard data object
    STGMEDIUM stgmm;
    VERIFY(dataObject.GetData(CF_METAFILEPICT, &stgmm, &fmtem));
    pSource->CacheData(CF_METAFILEPICT, &stgmm, &fmtem);
    return TRUE;
}

**Figure 28-6.** _The container's_ CEx28bView _class listing._

Study the message map and the associated command handlers. They're all relatively short, and they mostly call the OLE functions described earlier. A few private helper functions need some explanation, however.

> NOTE
> 
> You'll see many calls to a _GetInterface_ function. This is a member of class _CCmdTarget_ and returns the specified OLE interface pointer for a class in your project. It's used mostly to get the _IOleClientSite_ interface pointer for your document. It's more efficient than calling _ExternalQueryInterface_, but it doesn't increment the object's reference count.

### **_GetSize_**

This function calls _IOleObject::GetSize_ to get the embedded object's extents, which it converts to a rectangle for storage in the tracker.

### **_SetNames_**

The _SetNames_ function calls _IOleObject::SetHostNames_ to send the container application's name to the component.

### **_SetViewAdvise_**

This function calls the embedded object's _IViewObject2::SetAdvise_ function to set up the advisory connection from the component object to the container document.

### **_MakeMetafilePict_**

The _MakeMetafilePict_ function calls the embedded object's _IDataObject::GetData_ function to get a metafile picture to copy to the clipboard data object. (A metafile picture, by the way, is a Windows _METAFILEPICT_ structure instance, which contains a pointer to the metafile plus extent information.)

### **_SaveObject_**

This function acts like the _SaveDib_ function in the EX25A example. It creates a _COleDataSource_ object with three formats: embedded object, metafile, and object descriptor.

### **_DoPasteObjectDescriptor_**

The _DoPasteObjectDescriptor_ function pastes an object descriptor from the clipboard but doesn't do anything with it. This function must be called prior to calling _DoPasteObject_.

### **_DoPasteObject_**

This function calls _OleCreateFromData_ to create an embedded object from an embedded object format on the clipboard.

**The _CEx28bDoc_ Class**
-------------------------

This class implements the _IOleClientSite_ and _IAdviseSink_ interfaces. Because of our one-embedded-item-per-document simplification, we don't need to track separate site objects. The document is the site. We're using the standard MFC interface macros, and, as always, we must provide at least a skeleton function for all interface members.

Look carefully at the functions _XOleClientSite::SaveObject_, _XOleClientSite::OnShowWindow_, and _XAdviseSink::OnViewChange_ in Figure 28-7. They're the important ones. The other ones are less important, but they contain TRACE statements as well, so you can watch the functions as they're called by the handler. Look also at the _OnNewDocument_, _OnCloseDocument_, and _DeleteContents_ functions of the _CEx28bView_ class. Notice how the document is managing a temporary storage. The document's _m_pTempStgSub_ data member holds the storage pointer for the embedded object, and the _m_lpOleObj_ data member holds the embedded object's _IOleObject_ pointer.

**EX28BDOC.H**

#if !defined(AFX_EX28BDOC_H__1EAAB6DF_6011_11D0_848F_00400526305B__INCLUDED_)
#define AFX_EX28BDOC_H__1EAAB6DF_6011_11D0_848F_00400526305B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif //_MSC_VER > 1000

void ITrace(REFIID iid, const char\* str);

class CEx28bDoc : public CDocument
{
protected: // create from serialization only
    CEx28bDoc();
    DECLARE_DYNCREATE(CEx28bDoc)
    BEGIN_INTERFACE_PART(OleClientSite, IOleClientSite)
        STDMETHOD(SaveObject)();
        STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER\*);
        STDMETHOD(GetContainer)(LPOLECONTAINER\*);
        STDMETHOD(ShowObject)();
        STDMETHOD(OnShowWindow)(BOOL);
        STDMETHOD(RequestNewObjectLayout)();
    END_INTERFACE_PART(OleClientSite)

    BEGIN_INTERFACE_PART(AdviseSink, IAdviseSink)
        STDMETHOD_(void,OnDataChange)(LPFORMATETC, LPSTGMEDIUM);
        STDMETHOD_(void,OnViewChange)(DWORD, LONG);
        STDMETHOD_(void,OnRename)(LPMONIKER);
        STDMETHOD_(void,OnSave)();
        STDMETHOD_(void,OnClose)();
    END_INTERFACE_PART(AdviseSink)

    DECLARE_INTERFACE_MAP()

friend class CEx28bView;
private:
    LPOLEOBJECT m_lpOleObj;
    LPSTORAGE m_pTempStgRoot;
    LPSTORAGE m_pTempStgSub;
    BOOL m_bHatch;
    static const OLECHAR\* s_szSub;
// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEx28bDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void Serialize(CArchive& ar);
    virtual void OnCloseDocument();
    virtual void DeleteContents();
    protected:
    virtual BOOL SaveModified();
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CEx28bDoc();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CEx28bDoc)
    afx_msg void OnEditClearAll();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations
//  immediately before the previous line.

#endif 
// !defined(AFX_EX28BDOC_H__1EAAB6DF_6011_11D0_848F_00400526305B__INCLUDED_)
**EX28BDOC.CPP**
#include "stdafx.h"
#include "ex28b.h"

#include "ex28bDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE
__;
#endif
const OLECHAR\* CEx28bDoc::s_szSub = L"sub";   // static

////////////////////////////////////////////////////////////////////
// CEx28bDoc

IMPLEMENT_DYNCREATE(CEx28bDoc, CDocument)

BEGIN_MESSAGE_MAP(CEx28bDoc, CDocument)
    //{{AFX_MSG_MAP(CEx28bDoc)
    ON_COMMAND(ID_EDIT_CLEAR_ALL, OnEditClearAll)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_INTERFACE_MAP(CEx28bDoc, CDocument)
    INTERFACE_PART(CEx28bDoc, IID_IOleClientSite, OleClientSite)
    INTERFACE_PART(CEx28bDoc, IID_IAdviseSink, AdviseSink)
END_INTERFACE_MAP()

////////////////////////////////////////////////////////////////////
// implementation of IOleClientSite

STDMETHODIMP_(ULONG) CEx28bDoc::XOleClientSite::AddRef()
{
    TRACE("CEx28bDoc::XOleClientSite::AddRef\n");
    METHOD_PROLOGUE(CEx28bDoc, OleClientSite)
    return pThis->InternalAddRef();
}

STDMETHODIMP_(ULONG) CEx28bDoc::XOleClientSite::Release()
{
    TRACE("CEx28bDoc::XOleClientSite::Release\n");
    METHOD_PROLOGUE(CEx28bDoc, OleClientSite)
    return pThis->InternalRelease();
}

STDMETHODIMP CEx28bDoc::XOleClientSite::QueryInterface(
    REFIID iid, LPVOID\* ppvObj)
{
    ITrace(iid, "CEx28bDoc::XOleClientSite::QueryInterface");
    METHOD_PROLOGUE(CEx28bDoc, OleClientSite)
    return pThis->InternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CEx28bDoc::XOleClientSite::SaveObject()
{
    TRACE("CEx28bDoc::XOleClientSite::SaveObject\n");
    METHOD_PROLOGUE(CEx28bDoc, OleClientSite)
    ASSERT_VALID(pThis);

    LPPERSISTSTORAGE lpPersistStorage;
    pThis->m_pOleObj->QueryInterface(IID_IPersistStorage,
        (void\*\*) &lpPersistStorage);
    ASSERT(lpPersistStorage != NULL);
    HRESULT hr = NOERROR;
    if (lpPersistStorage->IsDirty() == NOERROR)
    {
        // NOERROR == S_OK != S_FALSE, therefore object is dirty!
        hr = ::OleSave(lpPersistStorage, pThis->
m_pTempStgSub,
                       TRUE);
        if (hr != NOERROR)
            hr = lpPersistStorage->SaveCompleted(NULL);

        // Mark the document as dirty if save successful
        pThis->SetModifiedFlag();
    }
    lpPersistStorage->Release();
    pThis->UpdateAllViews(NULL);
    return hr;
}

STDMETHODIMP CEx28bDoc::XOleClientSite::GetMoniker(
    DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER\* ppMoniker)
{
    TRACE("CEx28bDoc::XOleClientSite::GetMoniker\n");
    return E_NOTIMPL;
}

STDMETHODIMP CEx28bDoc::XOleClientSite::GetContainer(
    LPOLECONTAINER\* ppContainer)
{
    TRACE("CEx28bDoc::XOleClientSite::GetContainer\n");
    return E_NOTIMPL;
}

STDMETHODIMP CEx28bDoc::XOleClientSite::ShowObject()
{
    TRACE("CEx28bDoc::XOleClientSite::ShowObject\n");
    METHOD_PROLOGUE(CEx28bDoc, OleClientSite)
    ASSERT_VALID(pThis);
    pThis->UpdateAllViews(NULL);
    return NOERROR;
}

STDMETHODIMP CEx28bDoc::XOleClientSite::OnShowWindow(BOOL fShow)
{
    TRACE("CEx28bDoc::XOleClientSite::OnShowWindow\n");
    METHOD_PROLOGUE(CEx28bDoc, OleClientSite)
    ASSERT_VALID(pThis);
    pThis->m_bHatch = fShow;
    pThis->UpdateAllViews(NULL);
    return NOERROR;
}
STDMETHODIMP CEx28bDoc::XOleClientSite::RequestNewObjectLayout()
{
    TRACE("CEx28bDoc::XOleClientSite::RequestNewObjectLayout\n");
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////
// implementation of IAdviseSink

STDMETHODIMP_(ULONG) CEx28bDoc::XAdviseSink::AddRef()
{
    TRACE("CEx28bDoc::XAdviseSink::AddRef\n");
    METHOD_PROLOGUE(CEx28bDoc, AdviseSink)
    return pThis->InternalAddRef();
}

STDMETHODIMP_(ULONG) CEx28bDoc::XAdviseSink::Release()
{
    TRACE("CEx28bDoc::XAdviseSink::Release\n");
    METHOD_PROLOGUE(CEx28bDoc, AdviseSink)
    return pThis->InternalRelease();
}
STDMETHODIMP CEx28bDoc::XAdviseSink::QueryInterface(
    REFIID iid, LPVOID\* ppvObj)

{
    ITrace(iid, "CEx28bDoc::XAdviseSink::QueryInterface");
    METHOD_PROLOGUE(CEx28bDoc, AdviseSink)
    return pThis->InternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP_(void) CEx28bDoc::XAdviseSink::OnDataChange(
    LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
    TRACE("CEx28bDoc::XAdviseSink::OnDataChange\n");
    METHOD_PROLOGUE(CEx28bDoc, AdviseSink)
    ASSERT_VALID(pThis);

    // Interesting only for advanced containers. Forward it such
    //  that containers do not have to implement the entire
    //  interface.
}

STDMETHODIMP_(void) CEx28bDoc::XAdviseSink::OnViewChange(
    DWORD aspects, LONG /\*lindex\*/)
{
    TRACE("CEx28bDoc::XAdviseSink::OnViewChange\n");
    METHOD_PROLOGUE(CEx28bDoc, AdviseSink)
    ASSERT_VALID(pThis);

    pThis->UpdateAllViews(NULL);        // the really important one
}

STDMETHODIMP_(void) CEx28bDoc::XAdviseSink::OnRename(
    LPMONIKER /\*lpMoniker\*/)
{
    TRACE("CEx28bDoc::XAdviseSink::OnRename\n");
    // Interesting only to the OLE link object. Containers ignore
    //  this.
}

STDMETHODIMP_(void) CEx28bDoc::XAdviseSink::OnSave()
{
    TRACE("CEx28bDoc::XAdviseSink::OnSave\n");
    METHOD_PROLOGUE(CEx28bDoc, AdviseSink)
    ASSERT_VALID(pThis);

    pThis->UpdateAllViews(NULL);
}
STDMETHODIMP_(void) CEx28bDoc::XAdviseSink::OnClose()
{
    TRACE("CEx28bDoc::XAdviseSink::OnClose\n");
    METHOD_PROLOGUE(CEx28bDoc, AdviseSink)
    ASSERT_VALID(pThis);

    pThis->UpdateAllViews(NULL);
}

////////////////////////////////////////////////////////////////////
// CEx28bDoc construction/destruction

CEx28bDoc::CEx28bDoc()
{
    m_lpOleObj = NULL;
    m_pTempStgRoot = NULL;
    m_pTempStgSub = NULL;
    m_bHatch = FALSE;
}

CEx28bDoc::~CEx28bDoc()
{
}

BOOL CEx28bDoc::OnNewDocument()
{
    TRACE("Entering CEx28bDoc::OnNewDocument\n");
    // Create a structured storage home for the object
    //  (m_pTempStgSub). This is a temporary file -- random name
    //  supplied by OLE.
    VERIFY(::StgCreateDocfile(NULL,
           STGM_READWRITE|STGM_SHARE_EXCLUSIVE|STGM_CREATE|
           STGM_DELETEONRELEASE,
           0, &m_pTempStgRoot) == S_OK);
    ASSERT(m_pTempStgRoot != NULL);

    VERIFY(m_pTempStgRoot->CreateStorage(OLESTR("sub"),
           STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
           0, 0, &m_pTempStgSub) == S_OK);
    ASSERT(m_pTempStgSub != NULL);
    return CDocument::OnNewDocument();
}

////////////////////////////////////////////////////////////////////
// CEx28bDoc serialization

void CEx28bDoc::Serialize(CArchive& ar)
{
    // no hookup to MFC serialization
    if (ar.IsStoring())
    {
        // TODO: add storing code here
    }
    else
    {
        // TODO: add loading code here
    }
}

////////////////////////////////////////////////////////////////////
// CEx28bDoc diagnostics

#ifdef _DEBUG
void CEx28bDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CEx28bDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG

////////////////////////////////////////////////////////////////////
// CEx28bDoc commands

void CEx28bDoc::OnCloseDocument() 
{
    m_pTempStgSub->Release(); // must release BEFORE calling
                              //  base class
    m_pTempStgRoot->Release();
    CDocument::OnCloseDocument();
}

void CEx28bDoc::DeleteContents() 
{
    if(m_lpOleObj != NULL) {
        // If object is running, close it, which releases our
        //  IOleClientSite
        m_lpOleObj->Close(OLECLOSE_NOSAVE);
        m_lpOleObj->Release(); // should be final release
                               //  (or else...)
        m_lpOleObj = NULL;
    }
}

void CEx28bDoc::OnEditClearAll() 
{
    DeleteContents();
    UpdateAllViews(NULL);
    SetModifiedFlag();
    m_bHatch = FALSE;
}

BOOL CEx28bDoc::SaveModified() 
{
    // Eliminate "save to file" message
    return TRUE;
}

void ITrace(REFIID iid, const char\* str)
{
    OLECHAR\* lpszIID;
    ::StringFromIID(iid, &lpszIID);
    CString strIID = lpszIID;
    TRACE("%s - %s\n", (const char\*) strIID, (const char\*) str);
    AfxFreeTaskMem(lpszIID);
}

**Figure 28-7.** _The container's_ CEx28bDoc _class listing._
________________________________________________________________________
7.5.13. - [The EX28C Example -- An OLE Embedded Component](invcpp5/ch28n.htm)
----------------------------------------------------
 The EX28C Example -- An OLE Embedded Component 

**The EX28C Example—An OLE Embedded Component**
===============================================

You've already seen an MFC embedded component with in-place-activation capability (EX28A). Now you'll see a bare-bones component program that activates an embedded object in a separate window. It doesn't do much except display text and graphics in the window, but you'll learn a lot if you study the code. The application started as an SDI AppWizard Automation component with the document as the creatable object. The document's _IDispatch_ interface was ripped out and replaced with _IOleObject_, _IDataObject_, and _IPersistStorage_ interfaces. All the template server code carries through, so the document, view, and main frame objects are created when the container starts the component.

Open and build the EX28C project now. Run the application to register it, and then try it with the EX28B container or any other container program.

**The _CEx28cView_ Class**
--------------------------

This class is straightforward. The only member functions of interest are the _OnDraw_ function and the _OnPrepareDC_ function, shown here:

void CEx28cView::OnDraw(CDC\* pDC)
{
    CEx28cDoc\* pDoc = GetDocument();
    ASSERT_VALID(pDoc);

    **pDC->Rectangle(CRect(500, -1000, 1500, -2000));
    pDC->TextOut(0, 0, pDoc->m_strText);**
}

void CEx28cView::OnPrepareDC(CDC\* pDC, CPrintInfo\* pInfo) 
{
    **pDC->SetMapMode(MM_HIMETRIC);**

}

**The _CEx28cDoc_ Class**
-------------------------

This class does most of the component's work and is too big to list here. Figure 28-8 lists the header file, but you'll have to go to the companion CD-ROM for the implementation code. A few of the important functions are listed here, however.

**EX28CDOC.H**

#if !defined(AFX_EX28CDOC_H__1EAAB6F5_6011_11D0_848F_00400526305B  __INCLUDED_)
#define AFX_EX28CDOC_H__1EAAB6F5_6011_11D0_848F_00400526305B  __INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

extern const CLSID clsid; // defined in ex28c.cpp
void ITrace(REFIID iid, const char\* str);

#define SETFORMATETC(fe, cf, asp, td, med, li)   \
    ((fe).cfFormat=cf, \
     (fe).dwAspect=asp, \
     (fe).ptd=td, \

     (fe).tymed=med, \
     (fe).lindex=li)

class CEx28cDoc : public CDocument
{
friend class CEx28cView;
private:
    CString m_strText;
    LPOLECLIENTSITE m_lpClientSite;
    LPOLEADVISEHOLDER m_lpOleAdviseHolder;
    LPDATAADVISEHOLDER m_lpDataAdviseHolder;
    CString m_strContainerApp;
    CString m_strContainerObj;
    HGLOBAL MakeMetaFile();

    BEGIN_INTERFACE_PART(OleObject, IOleObject)
        STDMETHOD(SetClientSite)(LPOLECLIENTSITE);
        STDMETHOD(GetClientSite)(LPOLECLIENTSITE\*);
        STDMETHOD(SetHostNames)(LPCOLESTR, LPCOLESTR);
        STDMETHOD(Close)(DWORD);
        STDMETHOD(SetMoniker)(DWORD, LPMONIKER);
        STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER\*);
        STDMETHOD(InitFromData)(LPDATAOBJECT, BOOL, DWORD);
        STDMETHOD(GetClipboardData)(DWORD, LPDATAOBJECT\*);
        STDMETHOD(DoVerb)(LONG, LPMSG, LPOLECLIENTSITE, LONG,
                          HWND, LPCRECT);
        STDMETHOD(EnumVerbs)(LPENUMOLEVERB\*);
        STDMETHOD(Update)();
        STDMETHOD(IsUpToDate)();
        STDMETHOD(GetUserClassID)(LPCLSID);
        STDMETHOD(GetUserType)(DWORD, LPOLESTR\*);
        STDMETHOD(SetExtent)(DWORD, LPSIZEL);
        STDMETHOD(GetExtent)(DWORD, LPSIZEL);
        STDMETHOD(Advise)(LPADVISESINK, LPDWORD);
        STDMETHOD(Unadvise)(DWORD);
        STDMETHOD(EnumAdvise)(LPENUMSTATDATA\*);
        STDMETHOD(GetMiscStatus)(DWORD, LPDWORD);
        STDMETHOD(SetColorScheme)(LPLOGPALETTE);
    END_INTERFACE_PART(OleObject)

    BEGIN_INTERFACE_PART(DataObject, IDataObject)
        STDMETHOD(GetData)(LPFORMATETC, LPSTGMEDIUM);
        STDMETHOD(GetDataHere)(LPFORMATETC, LPSTGMEDIUM);
        STDMETHOD(QueryGetData)(LPFORMATETC);
        STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC, LPFORMATETC);
        STDMETHOD(SetData)(LPFORMATETC, LPSTGMEDIUM, BOOL);

        STDMETHOD(EnumFormatEtc)(DWORD, LPENUMFORMATETC\*);
        STDMETHOD(DAdvise)(LPFORMATETC, DWORD, LPADVISESINK, LPDWORD);
        STDMETHOD(DUnadvise)(DWORD);
        STDMETHOD(EnumDAdvise)(LPENUMSTATDATA\*);
    END_INTERFACE_PART(DataObject)

    BEGIN_INTERFACE_PART(PersistStorage, IPersistStorage)
        STDMETHOD(GetClassID)(LPCLSID);
        STDMETHOD(IsDirty)();
        STDMETHOD(InitNew)(LPSTORAGE);
        STDMETHOD(Load)(LPSTORAGE);
        STDMETHOD(Save)(LPSTORAGE, BOOL);
        STDMETHOD(SaveCompleted)(LPSTORAGE);
        STDMETHOD(HandsOffStorage)();
    END_INTERFACE_PART(PersistStorage)

    DECLARE_INTERFACE_MAP()

protected: // Create from serialization only
    CEx28cDoc();
    DECLARE_DYNCREATE(CEx28cDoc)

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEx28cDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void Serialize(CArchive& ar);
    virtual void OnFinalRelease();
    virtual void OnCloseDocument();
    protected:
    virtual BOOL SaveModified();
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CEx28cDoc();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
public:
    //{{AFX_MSG(CEx28cDoc)
    afx_msg void OnModify();
    afx_msg void OnFileUpdate();
    afx_msg void OnUpdateFileUpdate(CCmdUI\* pCmdUI);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional
//  declarations immediately before the previous line

#endif 
// !defined(AFX_EX28CDOC_H__1EAAB6F5_6011_11D0_848F_00400526305B  __INCLUDED_)

**Figure 28-8.** _The component's_ CEx28cDoc _class handler file listing._

Here's a list of the important interface functions in ex28cDoc.cpp:

> _XOleObject::SetClientSite  
> XOleObject::DoVerb  
> XOleObject::Advise  
> XDataObject::GetData  
> XDataObject::QueryGetData  
> XDataObject::DAdvise  
> XPersistStorage::GetClassID  
> XPersistStorage::InitNew  
> XPersistStorage::Load  
> XPersistStorage::Save_

You've seen the container code that draws a metafile. Here's the component code that creates it. The object handler calls the component's _XDataObject::GetData_ function when it needs a metafile. This _GetData_ implementation calls a helper function, _MakeMetaFile_, which creates the metafile picture. Compare the drawing code with the drawing code in _CEx28cView::OnDraw_.

STDMETHODIMP CEx28cDoc::XDataObject::GetData(
    LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
    TRACE("CEx28cDoc::XDataObject::GetData -- %d\n",
          lpFormatEtc->cfFormat);
    METHOD_PROLOGUE(CEx28cDoc, DataObject)
    ASSERT_VALID(pThis);

    if (lpFormatEtc->cfFormat != CF_METAFILEPICT) {
        return S_FALSE;
    }
    HGLOBAL hPict = pThis->MakeMetaFile();
    lpStgMedium->tymed = TYMED_MFPICT;
    lpStgMedium->hMetaFilePict = hPict;
    lpStgMedium->pUnkForRelease = NULL;
    return S_OK;
}

HGLOBAL CEx28cDoc::MakeMetaFile
{
    HGLOBAL hPict;
    CMetaFileDC dcm;
    VERIFY(dcm.Create());
    CSize size(5000, 5000); // initial size of object in Excel & Word
    dcm.SetMapMode(MM_ANISOTROPIC);
    dcm.SetWindowOrg(0,0);
    dcm.SetWindowExt(size.cx, -size.cy);
    // drawing code
    dcm.Rectangle(CRect(500, -1000, 1500, -2000));
    CFont font;
    font.CreateFont(-500, 0, 0, 0, 400, FALSE, FALSE, 0,
                    ANSI_CHARSET, OUT_DEFAULT_PRECIS,
                    CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                    DEFAULT_PITCH | FF_SWISS, "Arial");
    CFont\* pFont = dcm.SelectObject(&font);
    dcm.TextOut(0, 0, m_strText);
    dcm.SelectObject(pFont);

    HMETAFILE hMF = dcm.Close();
    ASSERT(hMF != NULL);
    hPict = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE,
                          sizeof(METAFILEPICT));
    ASSERT(hPict != NULL);
    LPMETAFILEPICT lpPict;
    lpPict = (LPMETAFILEPICT) ::GlobalLock(hPict);
    ASSERT(lpPict != NULL);
    lpPict->mm = MM_ANISOTROPIC;
    lpPict->hMF = hMF;
    lpPict->xExt = size.cx;
    lpPict->yExt = size.cy;  // HIMETRIC height
    ::GlobalUnlock(hPict);
    return hPict;
}

The _XOleObject::Advise_ and the _XDataObject::DAdvise_ functions are similar. Both functions call global OLE functions to set up OLE advise holder objects that can manage multiple advise sinks. (In this program, there is only one advise sink per OLE advise holder object.) The _XOleObject::Advise_ function, listed below, establishes an OLE advise holder object with the _IOleAdviseHolder_ interface. Other document functions call _IOleAdviseHolder::SendOnClose_ and _SendOnSave_, which in turn call _IAdviseSink::OnClose_ and _OnSave_ for each attached sink.

STDMETHODIMP CEx28cDoc::XOleObject::Advise(
    IAdviseSink\* pAdvSink, DWORD\* pdwConnection)
{
    TRACE("CEx28cDoc::XOleObject::Advise\n");
    METHOD_PROLOGUE(CEx28cDoc, OleObject)
    ASSERT_VALID(pThis);
    \*pdwConnection = 0;
    if (pThis->m_lpOleAdviseHolder == NULL &&
        ::CreateOleAdviseHolder(&pThis->m_lpOleAdviseHolder)
        != NOERROR) {
            return E_OUTOFMEMORY;
    }
    ASSERT(pThis->m_lpOleAdviseHolder != NULL);
    return pThis->m_lpOleAdviseHolder->Advise(pAdvSink,
                                              pdwConnection);
}

The framework calls the _OnModify_ function when the user chooses Modify from the EX28C-MAIN menu. The user enters a string through a dialog, and the function sends the _OnDataChange_ notification to the object handler's data advise sink. (Figure 28-5 illustrates the advisory connections.)

Here is the _OnModify_ function code:

void CEx28cDoc::OnModify() 
{
    CTextDialog dlg;
    dlg.m_strText = m_strText;
    if (dlg.DoModal() == IDOK) {
        m_strText = dlg.m_strText;
        UpdateAllViews(NULL); // redraw view
        // Notify the client that the metafile has changed.
        //  Client must call IViewObject::SetAdvise.
        LPDATAOBJECT lpDataObject = 
            (LPDATAOBJECT) GetInterface(&IID_IDataObject);
        HRESULT hr = 
            m_lpDataAdviseHolder->SendOnDataChange(lpDataObject,
                                                   0, NULL);
        ASSERT(hr == NOERROR);
        SetModifiedFlag(); // won't update without this
    }
}

The framework calls the _OnFileUpdate_ function when the user chooses Update from the File menu. The function calls _IOleClientSite::SaveObject_, which in turn causes the container to save the metafile and the object's native data in the storage. The function also sends the _OnSave_ notification back to the client's advise sink. Here is the _OnFileUpdate_ function code:

void CEx28cDoc::OnFileUpdate() 
{
    if (m_lpClientSite == NULL) return;
    VERIFY(m_lpClientSite->SaveObject() == NOERROR);
    if (m_lpOleAdviseHolder != NULL)
        m_lpOleAdviseHolder->SendOnSave(); 
    SetModifiedFlag(FALSE);
}
________________________________________________________________________
7.6. - [Chapter 29 -- Introducing the Active Template Library](invcpp5/ch29a.htm)
----------------------------------------------------
 Chapter 29 -- Introducing the Active Template Library  Chapter 29

Introducing the Active Template Library
=======================================

In this chapter, you'll take a look at the second framework (MFC being the first) now included within Microsoft Visual C++—the Active Template Library (ATL). You'll start by quickly revisiting the Component Object Model (COM) and looking at an alternative method of writing [Chapter 24](ch24a.htm)'s _CSpaceship_ object, illustrating that there is more than one way to write a COM class. (This will become important as you examine ATL's class composition methods.) Next you'll investigate the Active Template Library, focusing first on C++ templates and raw C++ smart pointers and how they might be useful in COM development. You'll cover the client side of ATL programming and examine some of ATL's smart pointers. Finally you'll check out the server side of ATL programming, reimplementing the [Chapter 24](ch24a.htm) spaceship example using ATL to get a feel for ATL's architecture.
________________________________________________________________________
7.6.1. - [Revisiting COM](invcpp5/ch29b.htm)
----------------------------------------------------
 Revisiting COM 

Revisiting COM
==============

The most important concept to understand about COM programming is that it is interface-based. As you saw in [Chapter 24](ch24a.htm), you don't need real COM or even Microsoft runtime support to use interface-based programming. All you need is some discipline.

Think back to the spaceship example in [Chapter 24](ch24a.htm). You started out with a single class named _CSpaceship_ that implemented several functions. Seasoned C++ developers usually sit down at the computer and start typing a class like this:

class CSpaceship {
    void Fly();
    int& GetPosition();
};

However, the procedure is a little different with interface-based development. Instead of writing the class directly, interface-based programming involves spelling out an interface before implementing it. In [Chapter 24](ch24a.htm), the _Fly_ and _GetPosition_ functions were moved into an abstract base class named _IMotion_.

struct IMotion {
    virtual void Fly() = 0;
    virtual int& GetPosition() = 0;
};

Then we inherited the _CSpaceship_ class from the _IMotion_ interface like this:

class CSpaceship : IMotion {
    void Fly();
    int& GetPosition();
};

Notice that at this point the motion interface has been separated from its implementation. When practicing interface development, the interface comes first. You can work on the interface as you develop it, making sure it's complete while at the same time not over-bloated. But once the interface has been published (that is, once a lot of other developers have started coding to it), the interface is frozen and can never change.

This subtle distinction between class-based programming and interface-based programming seems to introduce some programming overhead. However, it turns out to be one of the key points to understanding COM. By collecting the _Fly_ and the _GetPosition_ functions in an interface, you've developed a binary signature. That is, by defining the interface ahead of time and talking to the class through the interface, client code has a potentially language-neutral way of talking to the class.

Gathering functions together into interfaces is itself quite powerful. Imagine you want to describe something other than a spaceship—an airplane, for example. It's certainly conceivable that an airplane would also have _Fly_ and _GetPosition_ functions. Interface programming provides a more advanced form of polymorphism—polymorphism at the interface level, not only at the single-function level.

Separating interface from implementation is the basis of interface-based development. The Component Object Model is centered on interface programming. COM enforces the distinction between interface and implementation. In COM, the only way client code can talk to an object is through an interface. However, gathering functions together into interfaces isn't quite enough. There's one more ingredient needed—a mechanism for discovering functionality at runtime.

The Core Interface: _IUnknown_
------------------------------

The key element that makes COM different from ordinary interface programming is this rule: the first three functions of every COM interface are the same. The core interface in COM, _IUnknown,_ looks like this:

struct IUnknown {
    virtual HRESULT QueryInterface(REFIID riid, void\*\* ppv) = 0;
    virtual ULONG AddRef() = 0;
    virtual ULONG Release() = 0;
};

Every COM interface derives from this interface (meaning the first three functions of every COM interface you ever see will be _QueryInterface, AddRef,_ and _Release_). To turn _IMotion_ into a COM interface, derive it from _IUnknown_ like this:

struct IMotion : IUnknown {
    void Fly();
    int& GetPosition();
};

> NOTE
> 
> If you wanted these interfaces to work out-of-process, you'd have to make each function return an HRESULT. You'll see this when we cover Interface Definition Language (IDL) later in this chapter.

_AddRef_ and _Release_ deserve some mention because they are part of _IUnknown_. _AddRef_ and _Release_ allow an object to control its own lifetime if it chooses to. As a rule, clients are supposed to treat interface pointers like resources: clients acquire interfaces, use them, and release them when they are done using them. Objects learn about new references to themselves via _AddRef_. Objects learn they have been unreferenced through the _Release_ function. Objects often use this information to control their lifetimes. For example, many objects self-destruct when their reference count reaches zero.

Here's how some client code might use the spaceship:

void UseSpaceship() {
    IMotion\* pMotion = NULL;

    pMotion = GetASpaceship(); // This is a member of the
                               //  hypothetical Spaceship 
                               //  API. It's presumably an
                               //  entry point into some DLL.
                               //  Returns an IMotion\* and
                               //  causes an implicit AddRef.
    If(pMotion) {
        pMotion->Fly();
        int i = pMotion->GetPosition();
        pMotion->Release(); // done with this instance of CSpaceship
    }
}

The other (and more important) function within _IUnknown_ is the first one: _QueryInterface. QueryInterface_ is the COM mechanism for discovering functionality at runtime. If someone gives you a COM interface pointer to an object and you don't want to use that pointer, you can use the pointer to ask the object for a different interface to the same object. This mechanism, along with the fact that interfaces remain constant once published, are the key ingredients that allow COM-based software to evolve safely over time. The result is that you can add functionality to your COM software without breaking older versions of the clients running that software. In addition, clients have a widely recognized means of acquiring that new functionality once they know about it. For example, you add functionality to the implementation of _CSpaceship_ by adding a new interface named _IVisual_. Adding this interface makes sense because you can have objects in three-dimensional space that move in and out of view. You might also have an invisible object in three-dimensional space (a black hole, for example). Here's the _IVisual_ interface:

struct IVisual : IUnknown {
    virtual void Display() = 0;
};

A client might use the _IVisual_ interface like this:

void UseSpaceship() {
    IMotion\* pMotion = NULL;

    pMotion = GetASpaceship(); // Implicit AddRef
    if(pMotion) {
        pMotion->Fly();
        int i = pMotion->GetPosition();

        IVisual\* pVisual = NULL;
        PMotion->QueryInterface(IID_IVisual, (void\*\*) &pVisual);
        // Implicit AddRef within QueryInterface

        if(pVisible) {
            pVisual->Display(); // uncloaking now
            pVisual->Release(); // done with this interface
        }
    }
    pMotion->Release(); // done with this instance of IMotion
}

Notice that the preceding code uses interface pointers very carefully: it uses them only if the interface was acquired properly, and then it releases the interface pointers when it is done using them. This is raw COM programming at the lowest level—you acquire an interface pointer, you use the interface pointer, and you release it when you're done with it.
________________________________________________________________________
7.6.2. - [Writing COM Code](invcpp5/ch29c.htm)
----------------------------------------------------
 Writing COM Code 

Writing COM Code
================

As you can see, writing COM client code isn't a whole lot different from writing regular C++ code. However, the C++ classes that the client talks to are abstract base classes. Instead of calling _operator new_ as you would in C++, you create COM objects and acquire COM interfaces by explicitly calling some sort of API function. And instead of deleting the object outright, you simply follow the COM interface rule of balancing calls to _AddRef_ with calls to _Release_.

What does it take to get the COM class up and running? You saw how to do it using MFC in [Chapter 24](ch24a.htm). Here's another example of implementing _CSpaceship_ as a COM class. This example uses the multiple inheritance approach to writing COM classes. That is, the C++ class inherits from several interfaces and then implements the union of all the functions (including _IUnknown_, of course).

struct CSpaceship : IMotion, IDisplay {
    ULONG m_cRef;
    int m_nPosition;

    CSpaceship() : m_cRef(0),
                   m_nPosition(0) {
    }

    HRESULT QueryInterface(REFIID riid,
                           void\*\* ppv);
    ULONG AddRef() {
        return InterlockedIncrement(&m_cRef);
    }
    ULONG Release() {
        ULONG cRef = InterlockedIncrement(&m_cRef);
        if(cRef == 0){
            delete this;
            return 0;
        } else
            return m_cRef;
    }

    // IMotion functions:
    void Fly() {
        // Do whatever it takes to fly here
    }
    int GetPosition() {
        return m_nPosition;
    }

    // IVisual functions:
    void Display() {
        // Uncloak
    }
};

COM Classes Using Multiple Inheritance
--------------------------------------

If you're used to seeing plain C++ code, the preceding code might look a little strange to you. This is a less common form of multiple inheritance called interface inheritance. Most C++ developers are used to an implementation inheritance in which the derived class inherits everything from the base class—including the implementation. Interface inheritance simply means the derived class inherits the interfaces of the base class. The preceding code effectively adds two data members to the _CSpaceship_ class—a _vptr_ for each implied _vtable_.

When using the multiple inheritance approach to implementing interfaces, each interface shares _CSpaceship_'s implementation of _IUnknown_. This sharing illustrates a rather esoteric yet important concept known as COM identity. The basic idea of COM identity is that _IUnknown_ is the void\* of COM. _IUknown_ is the one interface guaranteed to be hanging off any object, and you can always get to it. COM identity also says (in the previous example) the client can call _QueryInterface_ through the _CSpaceship_ _IMotion_ interface to get the _IVisible_ interface. Conversely, the client can call _QueryInterface_ through the _CSpaceship_ _IVisible_ interface to get the _IMotion_ interface. Finally, the client can call _QueryInterface_ through _IUnknown_ to acquire the _IMotion_ or the _IVisible_ interface, and the client can call _QueryInterface_ through either _IMotion_ or _IVisual_ to get a pointer to _IUnknown_. To learn more about COM identity, see _Essential COM_ by Don Box (Addison-Wesley, 1997) or _Inside COM_ by Dale Rogerson (Microsoft Press, 1997).

Often you'll see COM classes illustrated with "lollipop" diagrams depicting the interfaces implemented by a COM class. You can see an example of a lollipop diagram in "[The _IUnknown_ Interface and the _QueryInterface_ Member Function](ch24c.htm#507)" in Chapter 24.

The multiple inheritance method of implementing _CSpaceship_ automatically fulfills the rules of COM identity. Note that all calls to _QueryInterface, AddRef,_ and _Release_ land in the same place in the C++ class, regardless of the interface through which they were called.

This is more or less the essence of COM. As a COM developer, your job is to create useful services and expose them through COM interfaces. At the most basic level, this means wiring up some function tables to follow COM's identity rules. You've seen two ways to accomplish this so far. ([Chapter 24](ch24a.htm) showed you how to do it using nested classes and MFC. This chapter just showed you how to write a COM class using multiple inheritance in C++.) However, in addition to interface programming and writing classes to implement interfaces, there are several other pieces to the COM puzzle.
________________________________________________________________________
7.6.3. - [The COM Infrastructure](invcpp5/ch29d.htm)
----------------------------------------------------
 The COM Infrastructure 

The COM Infrastructure
======================

Once you get your mind around the concept of interface-based programming, quite a few details need implementation in order to get the class to mix in with the rest of the system. These details often overshadow the fundamental beauty of COM.

To start off with, COM classes need a place to live, so you must package them in either an EXE or a DLL. In addition, each COM class you write needs an accompanying class object (often referred to as a class factory). The way in which a COM server's class object is exposed differs depending upon how you package the COM class (in a DLL or an EXE). The server lifetime also needs to be considered. The server should stay in memory for as long as it's needed, and it should go away when it's not needed. To accomplish this, servers maintain global lock counts indicating the number of objects with extant interface pointers. Finally, well-behaved servers insert the necessary values in the Windows Registry so that client software can easily activate them.

You've spent a lot of time looking at MFC while reading this book. As you saw in [Chapter 24](ch24a.htm), MFC takes care of most of the COM-based details for you. For example, _CCmdTarget_ has an implementation of _IUnknown_. MFC has even created C++ classes and macros to implement class objects (such as _COleObjectFactory,_ _COleTemplateServer, DECLARE_OLE_CREATE,_ and _IMPLEMENT_OLE_CREATE_) that will put most of the correct entries into the Registry. MFC has the easiest-to-implement, zippiest version of _IDispatch_ around—all you need is a _CCmdTarget_ object and ClassWizard. If you decide OLE Documents or ActiveX Documents are your thing, MFC provides standard implementations of the Object Linking and Embedding and ActiveX Document protocols. Finally, MFC remains hands-down the easiest way to write fast, powerful ActiveX controls. (You can write ActiveX controls in Microsoft Visual Basic, but you don't have quite as much flexibility). These are all great features. However, using MFC has a downside.

To get these features, you need to buy into MFC 100%. Now, that's not necessarily a bad idea. However, you should be aware of the cost of entry when you decide to use MFC. MFC is big. It has to be—it's a C++ framework with many capabilities.

A New Framework
---------------

As you can see from the examples we've looked at so far, implementing COM classes and making them available to clients involves writing a great deal of code—code that remains the same from one class implementation to another. _IUnknown_ implementations are generally the same for every COM class you encounter—the main difference between them is the interfaces exposed by each class.

But just as you no longer need to understand assembly language to get software working these days, pretty soon you'll no longer need to understand all the nuances of _IUnknown_ and COM's relationship to C++ to get your COM-based software up and running. You're not quite at that stage, but the Active Template Library (ATL) from Microsoft is a great first step in that direction. (However, ATL does not absolve you from learning the important concepts behind COM, such as apartments and remoting.)

Before diving into ATL, let's take a quick peek at where COM and ATL fit into the big picture.

ActiveX, OLE, and COM
---------------------

COM is simply the plumbing for a series of higher-level application integration technologies consisting of such items as ActiveX Controls and OLE Documents. These technologies define protocols based on COM interfaces. For example, for a COM object to qualify as a minimal OLE Document object, that COM object has to implement at least three interfaces—_IPersistStorage, IOleObject_, and _IDataObject_. You might choose to implement the higher-level features of OLE Documents and controls. However, it makes more sense to let some sort of application framework do the grunt work. Of course, that's why there's MFC.

> NOTE
> 
> For more information about how to implement higher-level features in raw C++, see Kraig Brockschmidt's _Inside OLE_, 2d. ed. (Microsoft Press, 1995).

ActiveX, MFC, and COM
---------------------

While the pure plumbing of COM is quite interesting by itself (it's simply amazing to see how COM remoting works), the higher-level features are what sell applications. MFC is a huge framework geared toward creating entire Windows applications. Inside MFC, you'll find tons of utility classes, a data management/rendering mechanism (the Document-View architecture), as well as support for OLE Documents, drag and drop, Automation, and ActiveX Controls. You probably don't want to develop an OLE Document application from scratch; you're much better off using MFC. However, if you need to create a small or medium-size COM-based service, you might want to turn away from MFC so you don't have to include all the baggage MFC maintains for the higher-level features.

You can use raw C++ to create COM components, but doing so forces you to spend a good portion of your time hacking out the boilerplate code (_IUnknown_ and class objects, for example). Using MFC to write COM-based applications turns out to be a less painful way of adding the big-ticket items to your application, but it's difficult to write lightweight COM classes in MFC. ATL sits between pure C++ and MFC as a way to implement COM-based software without having to type in the boilerplate code or buy into all of MFC's architecture. ATL is basically a set of C++ templates and other kinds of support for writing COM classes.
________________________________________________________________________
7.6.4. - [The ATL Roadmap](invcpp5/ch29e.htm)
----------------------------------------------------
 The ATL Roadmap 

The ATL Roadmap
===============

If you look at the source code for ATL, you'll find ATL consists of a collection of header files and C++ source code files. Most of it resides inside ATL's Include directory. Here's a rundown of some of the ATL files and what's inside each of them.

ATLBASE.H
---------

This file contains:

*   ATL's function _typedefs_
    
*   Structure and macro definitions
    
*   Smart pointers for managing COM interface pointers
    
*   Thread synchronization support classes
    
*   Definitions for _CComBSTR_, _CComVariant_, threading, and apartment support
    

ATLCOM.H
--------

This file contains:

*   Template classes for class object/class factory support
    
*   _IUnknown_ implementations
    
*   Support for tear-off interfaces
    
*   Type information management and support
    
*   ATL's _IDispatch_ implementation
    
*   COM enumerator templates
    
*   Connection point support
    

ATLCONV.CPP and ATLCONV.H
-------------------------

These two source code files include support for Unicode conversions.

ATLCTL.CPP and ATLCTL.H
-----------------------

These two files contain:

*   The source code for ATL's _IDispatch_ client support and event firing support
    
*   _CComControlBase_
    
*   The OLE embedding protocol support for controls
    
*   Property page support
    

ATLIFACE.IDL and ATLIFACE.H
---------------------------

ATLIFACE.IDL (which generates ATLIFACE.H) includes an ATL-specific interface named _IRegistrar_.

ATLIMPL.CPP
-----------

ATLIMPL.CPP implements such classes as _CComBSTR,_ which is declared in ATLBASE.H.

ATLWIN.CPP and ATLWIN.H
-----------------------

These files provide windowing and user-interface support, including:

*   A message-mapping mechanism
    
*   A windowing class
    
*   Dialog support
    

STATREG.CPP and STATREG.H
-------------------------

ATL features a COM component named the Registrar that handles putting appropriate entries into the Registry. The code for implementing this feature is in STATREG.H and STATREG.CPP.

Let's start our excursions into ATL by examining ATL's support for client-side COM development.
________________________________________________________________________
7.6.5. - [Client-Side ATL Programming](invcpp5/ch29f.htm)
----------------------------------------------------
 Client-Side ATL Programming 

Client-Side ATL Programming
===========================

There are basically two sides to ATL—client-side support and object-side support. By far the largest portion of support is on the object side because of all the code necessary to implement ActiveX controls. However, the client-side support provided by ATL turns out to be useful and interesting also. Let's take a look at the client side of ATL. Because C++ templates are the cornerstone of ATL, we'll take a little detour first to examine them.

C++ Templates
-------------

The key to understanding the Active Template Library is understanding C++ templates. Despite the intimidating template syntax, the concept of templates is fairly straightforward. C++ templates are sometimes called compiler-approved macros, which is an appropriate description. Think about what macros do: when the preprocessor encounters a macro, the preprocessor looks at the macro and expands it into regular C++ code. But the problem with macros is that they are sometimes error-prone and they are never type-safe. If you use a macro and pass an incorrect parameter, the compiler won't complain but your program might very well crash. Templates, however, are like type-safe macros. When the compiler encounters a template, the compiler expands the template just as it would a macro. But because templates are type-safe, the compiler catches any type problems before the user encounters them.

Using templates to reuse code is different from what you're used to with conventional C++ development. Components written using templates reuse code by template substitution rather than by inheriting functionality from base classes. All the boilerplate code from templates is literally pasted into the project.

The archetypal example of using a template is a dynamic array. Imagine you need an array for holding integers. Rather than declaring the array with a fixed size, you want the array to grow as necessary. So you develop the array as a C++ class. Then someone you work with gets wind of your new class and says that he or she needs the exact same functionality. However, this person wants to use floating point numbers in the array. Rather than pumping out the exact same code (except for using a different type of data), you can use a C++ template.

Here's an example of how you might use templates to solve the problem described above. The following is a dynamic array implemented as a template:

template <class T> class DynArray {
public:
    DynArray();
    ~DynArray(); // clean up and do memory management
    int Add(T Element); // adds an element and does
                        //  memory management
    void Remove(int nIndex) // remove element and 
                            //  do memory management
    T GetAt(nIndex) const;
    int GetSize();
private:
    T\* TArray;
    int m_nArraysize;
};

void UseDynArray() { 
    DynArray<int> intArray;
    DynArray<float> floatArray;

    intArray.Add(4);
    floatArray.Add(5.0);

    intArray.Remove(0);
    floatArray.Remove(0);

    int x = intArray.GetAt(0);
    float f = floatArray.GetAt(0);
}

As you can imagine, creating templates is useful for implementing boilerplate COM code, and templates are the mechanism ATL uses for providing COM support. The previous example is just one of the many uses available for templates. Not only are templates useful for applying type information to a certain kind of data structure, they're also useful for encapsulating algorithms. You'll see how when you take a closer look at ATL. Let's take a look at the Active Template Library to see what comes with it.

Smart Pointers
--------------

One of the most common uses of templates is for smart pointers. The traditional C++ literature calls C++'s built-in pointers "dumb" pointers. That's not a very nice name, but normal C++ pointers don't do much except point. It's often up to the client to perform details such as pointer initialization.

As an example, let's model two types of software developer using C++ classes. You can start by creating the classes: _CVBDeveloper_ and _CCPPDeveloper_.

class CVBDeveloper {
public:
    CVBDeveloper() {
    }
    ~CVBDeveloper() {
        AfxMessageBox("I used VB, so I got home early.");
    }
    virtual void DoTheWork() {
        AfxMessageBox("Write them forms");
    }
};

class CCPPDeveloper {
public:
    CCPPDeveloper() {
    }
    ~CCPPDeveloper() {
        AfxMessageBox("Stay at work and fix those pointer problems");
    }
    virtual void DoTheWork() {
        AfxMessageBox("Hacking C++ code");
    }
};

The Visual Basic developer and the C++ developer both have functions for eliciting optimal performance. Now imagine some client code that looks like this:

//UseDevelopers.CPP

void UseDevelopers() {
    CVBDeveloper\* pVBDeveloper;
    .
    .
    .
    // The VB Developer pointer needs 
    //  to be initialized 
    //  sometime. But what if 
    //  you forget to initialize and later 
    //  on do something like this:
    if(pVBDeveloper) {
        // Get ready for fireworks
        //  because pVBDeveloper is 
        //  NOT NULL, it points
        //  to some random data.
        c->DoTheWork();
    }
}

In this case, the client code forgot to initialize the _pVBDeveloper_ pointer to _NULL_. (Of course, this never happens in real life!) Because _pVBDeveloper_ contains a non-_NULL_ value (the value is actually whatever happened to be on the stack at the time), the test to make sure the pointer is valid succeeds when in fact you're expecting it to fail. The client gleefully proceeds, believing all is well. The client crashes, of course, because the client is "calling into darkness." (Who knows where _pVBDeveloper_ is pointing—probably to nothing that even resembles a Visual Basic developer.) Naturally, you'd like some mechanism for ensuring that the pointers are initialized. This is where smart pointers come in handy.

Now imagine a second scenario. Perhaps you'd like to plug a little extra code into your developer-type classes that performs some sort of operation common to all developers. For example, perhaps you'd like all the developers to do some design work before they begin coding. Consider the earlier VB developer and C++ developer examples. When the client calls _DoTheWork,_ the developer gets right to coding without proper design, and he or she probably leaves the poor clients in a lurch. What you'd like to do is add a very generic hook to the developer classes so they make sure the design is done before beginning to code.

The C++ solution to coping with these problems is called a smart pointer. Let's find out exactly what a smart pointer is.

Giving C++ Pointers Some Brains
-------------------------------

Remember that a smart pointer is a C++ class for wrapping pointers. By wrapping a pointer in a class (and specifically, a template), you can make sure certain operations are taken care of automatically instead of deferring mundane, boilerplate-type operations to the client. One good example of such an operation is to make sure pointers are initialized correctly so that embarrassing crashes due to randomly assigned pointers don't occur. Another good example is to make certain that boilerplate code is executed before function calls are made through a pointer.

Let's invent a smart pointer for the developer model described earlier. Consider a template-based class named _SmartDeveloper_:

template<class T>
class SmartDeveloper {
    T\* m_pDeveloper;

public:
    SmartDeveloper(T\* pDeveloper) {
        ASSERT(pDeveloper != NULL);
        m_pDeveloper = pDeveloper;
    }
    ~SmartDeveloper() {
        AfxMessageBox("I'm smart so I'll get paid.");
    }
    SmartDeveloper & 
      operator=(const SmartDeveloper& rDeveloper) {
        return \*this;
    }
    T\* operator->() const {
        AfxMessageBox("About to de-reference pointer. Make /
                      sure everything's okay. ");
        return m_pDeveloper;
    }
};

The _SmartDeveloper_ template listed above wraps a pointer—any pointer. Because the _SmartDeveloper_ class is based on a template, it can provide generic functionality regardless of the type associated with the class. Think of templates as compiler-approved macros: declarations of classes (or functions) whose code can apply to any type of data.

We want the smart pointer to handle all developers, including those using VB, Visual C++, Java, and Delphi (among others). The _template <class T>_ statement at the top accomplishes this. The _SmartDeveloper_ template includes a pointer (_m_pDeveloper_) to the type of developer for which the class will be defined. The _SmartDeveloper_ constructor takes a pointer to that type as a parameter and assigns it to _m_pDeveloper_. Notice that the constructor generates an assertion if the client passes a NULL parameter to construct _SmartDeveloper_.

In addition to wrapping a pointer, the _SmartDeveloper_ implements several operators. The most important one is the "->" operator (the member selection operator). This operator is the workhorse of any smart pointer class. Overloading the member selection operator is what turns a regular class into a smart pointer. Normally, using the member selection operator on a regular C++ dumb pointer tells the compiler to select a member belonging to the class or structure being pointed to. By overriding the member selection operator, you provide a way for the client to hook in and call some boilerplate code every time that client calls a method. In the _SmartDeveloper_ example, the smart developer makes sure the work area is in order before working. (This example is somewhat contrived. In real life, you might want to put in a debugging hook, for example.)

Adding the -> operator to the class causes the class to behave like C++'s built-in pointer. To behave like native C++ pointers in other ways, smart pointer classes need to implement the other standard operators such as the de-referencing and assignment operators.

Using Smart Pointers
--------------------

Using smart pointers is really no different from using the regular built-in C++ pointers. Let's start by looking at a client that uses plain vanilla developer classes:

void UseDevelopers() {
    CVBDeveloper VBDeveloper;
    CCPPDeveloper CPPDeveloper;

    VBDeveloper.DoTheWork();
    CPPDeveloper.DoTheWork();
}

No surprises here—executing this code causes the developers simply to come in and do the work. However, you want to use the smart developers—the ones that make sure the design is done before actually starting to hack. Here's the code that wraps the VB developer and C++ developer objects in the smart pointer class:

void UseSmartDevelopers { 
    CVBDeveloper VBDeveloper;
    CCPPDeveloper CPPDeveloper;

    SmartDeveloper<CVBDeveloper> smartVBDeveloper(&VBDeveloper);
    SmartDeveloper<CCPPDeveloper> smartCPPDeveloper(&CPPDeveloper);

    smartVBDeveloper->DoTheWork();
    smartCPPDeveloper->DoTheWork();
}

Instead of bringing in any old developer to do the work (as in the previous example), the client asks the smart developers to do the work. The smart developers will automatically prepare the design before proceeding with coding.

Smart Pointers and COM
----------------------

While the last example was fabricated to make an interesting story, smart pointers do have useful applications in the real world. One of those applications is to make client-side COM programming easier.

Smart pointers are frequently used to implement reference counting. Because reference counting is a very generic operation, hoisting client-side reference count management up into a smart pointer makes sense.

Because you're now familiar with the Microsoft Component Object Model, you understand that COM objects expose interfaces. To C++ clients, interfaces are simply pure abstract base classes, and C++ clients treat interfaces more or less like normal C++ objects. However, as you discovered in previous chapters, COM objects are a bit different from regular C++ objects. COM objects live at the binary level. As such, they are created and destroyed using language- independent means. COM objects are created via API functions calls. Most COM objects use a reference count to know when to delete themselves from memory. Once a COM object is created, a client object can refer to it in a number of ways by referencing multiple interfaces belonging to the same COM object. In addition, several different clients can talk to a single COM object. In these situations, the COM object must stay alive for as long as it is referred to. Most COM objects destroy themselves when they're no longer referred to by any clients. COM objects use reference counting to accomplish this self-destruction.

To support this reference-counting scheme, COM defines a couple of rules for managing COM interfaces from the client side. The first rule is that creating a new copy of a COM interface should result in bumping the object's reference count up by one. The second rule is that clients should release interface pointers when they have finished with them. Reference counting is one of the more difficult aspects of COM to get right—especially from the client side. Keeping track of COM interface reference counting is a perfect use of smart pointers.

For example, the smart pointer's constructor might take the live interface pointer as an argument and set an internal pointer to the live interface pointer. Then the destructor might call the interface pointer's _Release_ function to release the interface so that the interface pointer will be released automatically when the smart pointer is deleted or falls out of scope. In addition, the smart pointer can help manage COM interfaces that are copied.

For example, imagine you've created a COM object and you're holding on to the interface. Suppose you need to make a copy of the interface pointer (perhaps to pass it as an out parameter). At the native COM level, you'd perform several steps. First you must release the old interface pointer. Next you need to copy the old pointer to the new pointer. Finally you must call _AddRef_ on the new copy of the interface pointer. These steps need to occur regardless of the interface being used, making this process ideal for boilerplate code. To implement this process in the smart pointer class, all you need to do is override the assignment operator. The client can then assign the old pointer to the new pointer. The smart pointer does all the work of managing the interface pointer, relieving the client of the burden.

ATL's Smart Pointers
--------------------

Much of ATL's support for client-side COM development resides in a pair of ATL smart pointers: _CComPtr_ and _CComQIPtr_. _CComPtr_ is a basic smart pointer that wraps COM interface pointers. _CComQIPtr_ adds a little more smarts by associating a GUID (for use as the interface ID) with a smart pointer. Let's start by looking at _CComPtr_.

_CComPtr_
---------

Here's an abbreviated version of _CComPtr_ showing its most important parts:

template <class T>
class CComPtr {
public:
    typedef T _PtrClass;
    CComPtr() {p=NULL;}
    CComPtr(T\* lp) {
        if ((p = lp) != NULL) p->AddRef();
    }
    CComPtr(const CComPtr<T>& lp) {
        if ((p = lp.p) != NULL) p->AddRef();
    }
    ~CComPtr() {if (p) p->Release();}
    void Release() {if (p) p->Release(); p=NULL;}
    operator T\*() {return (T\*)p;}
    T& operator\*() {_ASSERTE(p!=NULL); return \*p; }
    T\*\* operator&() { _ASSERTE(p==NULL); return &p; }
    T\* operator->() { _ASSERTE(p!=NULL); return p; }
    T\* operator=(T\* lp){return (T\*)AtlComPtrAssign(
                                   (IUnknown\*\*)&p, lp);}
    T\* operator=(const CComPtr<T>& lp) {
        return (T\*)AtlComPtrAssign((IUnknown\*\*)&p, lp.p);
    }
    T\* p;
};

_CComPtr_ is a fairly basic smart pointer. Notice the data member _p_ of type T (the type introduced by the template parameter). _CComPtr_'s constructor performs an _AddRef_ on the pointer while the destructor releases the pointer—no surprises here. _CComPtr_ also has all the necessary operators for wrapping a COM interface. Only the assignment operator deserves special mention. The assignment does a raw pointer re-assignment. The assignment operator calls a function named _AtlComPtrAssign_:

ATLAPI_(IUnknown\*) AtlComPtrAssign(IUnknown\*\* pp, IUnknown\* lp) {
    if (lp != NULL)
        lp->AddRef();
    if (\*pp)
        (\*pp)->Release();
    \*pp = lp;
    return lp;
}

_AtlComPtrAssign_ does a blind pointer assignment, _AddRef_\-ing the assignee before calling _Release_ on the assignor. You'll soon see a version of this function that calls _QueryInterface_.

_CComPtr_'s main strength is that it helps you manage the reference count on a pointer to some degree.

Using _CComPtr_
---------------

In addition to helping you manage _AddRef_ and _Release_ operations, _CComPtr_ can help you manage code layout. Looking at a bit of code will help illustrate the usefulness of _CComPtr_. Imagine that your client code needs three interface pointers to get the work done as shown here:

void GetLottaPointers(LPUNKNOWN pUnk){
    HRESULT hr;
    LPPERSIST pPersist; 
    LPDISPATCH pDispatch; 
    LPDATAOBJECT pDataObject;
    hr = pUnk->QueryInterface(IID_IPersist, (LPVOID \*)&pPersist);
    if(SUCCEEDED(hr)) {
        hr = pUnk->QueryInterface(IID_IDispatch, (LPVOID \*) 
                                  &pDispatch);
        if(SUCCEEDED(hr)) {
            hr = pUnk->QueryInterface(IID_IDataObject, 
                                      (LPVOID \*) &pDataObject);
            if(SUCCEEDED(hr)) {
                DoIt(pPersist, pDispatch, pDataObject);
                pDataObject->Release();
            }
            pDispatch->Release();
         }
         pPersist->Release();
    }
}

You could use the controversial _goto_ statement (and risk facing derisive comments from your co-workers) to try to make your code look cleaner, like this:

void GetLottaPointers(LPUNKNOWN pUnk){
    HRESULT hr;
    LPPERSIST pPersist; LPDISPATCH pDispatch;
    LPDATAOBJECT pDataObject;

    hr = pUnk->QueryInterface(IID_IPersist, (LPVOID \*)&pPersist);
    if(FAILED(hr)) goto cleanup;

    hr = pUnk->QueryInterface(IID_IDispatch, (LPVOID \*) &pDispatch);
    if(FAILED(hr)) goto cleanup;

    hr = pUnk->QueryInterface(IID_IDataObject,
                              (LPVOID \*) &pDataObject);
    if(FAILED(hr)) goto cleanup;

    DoIt(pPersist, pDispatch, pDataObject);

cleanup:
    if (pDataObject) pDataObject->Release();
    if (pDispatch) pDispatch->Release();
    if (pPersist) pPersist->Release();
}

That may not be as elegant a solution as you would like. Using _CComPtr_ makes the same code a lot prettier and much easier to read, as shown here:

void GetLottaPointers(LPUNKNOWN pUnk){
    HRESULT hr;
    CComPtr<IUnknown> persist;
    CComPtr<IUnknown> dispatch;
    CComPtr<IUnknown> dataobject;

    hr = pUnk->QueryInterface(IID_IPersist, (LPVOID \*)&persist);
    if(FAILED(hr)) return;

    hr = pUnk->QueryInterface(IID_IDispatch, (LPVOID \*) &dispatch);
    if(FAILED(hr)) return;

    hr = pUnk->QueryInterface(IID_IDataObject,
                              (LPVOID \*) &dataobject);
    if(FAILED(hr)) return;

    DoIt(pPersist, pDispatch, pDataObject);

    // Destructors call release...
}

At this point, you're probably wondering why _CComPtr_ doesn't wrap _QueryInterface_. After all, _QueryInterface_ is a hot spot for reference counting. Adding _QueryInterface_ support for the smart pointer requires some way of associating a GUID with the smart pointer. _CComPtr_ was introduced in the first version of ATL. Rather than disrupt any existing code base, Microsoft introduced a beefed-up version of _CComPtr_ named _CComQIPtr._

_CComQIPtr_
-----------

Here's part of _CComQIPtr_'s definition:

template <class T, const IID\* piid = &__uuidof(T)>
class CComQIPtr {
public:
    typedef T _PtrClass;
    CComQIPtr() {p=NULL;}
    CComQIPtr(T\* lp) {
        if ((p = lp) != NULL)
            p->AddRef();
    }
    CComQIPtr(const CComQIPtr<T,piid>& lp) {
        if ((p = lp.p) != NULL)
            p->AddRef();
    }
    CComQIPtr(IUnknown\* lp) {
        p=NULL;
        if (lp != NULL)
            lp->QueryInterface(\*piid, (void \*\*)&p);
    }
    ~CComQIPtr() {if (p) p->Release();}
    void Release() {if (p) p->Release(); p=NULL;}
    operator T\*() {return p;}
    T& operator\*() {_ASSERTE(p!=NULL); return \*p; }
    T\*\* operator&() { _ASSERTE(p==NULL); return &p; }
    T\* operator->() {_ASSERTE(p!=NULL); return p; }
    T\* operator=(T\* lp){
        return (T\*)AtlComPtrAssign((IUnknown\*\*)&p, lp);
    }
    T\* operator=(const CComQIPtr<T,piid>& lp) {
        return (T\*)AtlComPtrAssign((IUnknown\*\*)&p, lp.p);
    }
    T\* operator=(IUnknown\* lp) {
        return (T\*)AtlComQIPtrAssign((IUnknown\*\*)&p, lp, \*piid);
    }
    bool operator!(){return (p == NULL);}
    T\* p;
};

What makes _CComQIPtr_ different from _CComPtr_ is the second template parameter, _piid_—the interfaces's GUID. This smart pointer has several constructors: a default constructor, a copy constructor, a constructor that takes a raw interface pointer of unspecified type, and a constructor that accepts an _IUnknown_ interface as a parameter. Notice in this last constructor that if the developer creates an object of this type and initializes it with a plain old _IUnknown_ pointer, _CComQIPtr_ calls _QueryInterface_ using the GUID template parameter. Also notice that the assignment to an _IUnknown_ pointer calls _AtlComQIPtrAssign_ to make the assignment. As you can imagine, _AtlComQIPtrAssign_ performs a _QueryInterface_ under the hood using the GUID template parameter.

Using _CComQIPtr_
-----------------

Here's how you might use _CComQIPtr_ in some COM client code:

void GetLottaPointers(ISomeInterface\* pSomeInterface){
    HRESULT hr;
    CComQIPtr<IPersist, &IID_IPersist> persist;
    CComQIPtr<IDispatch, &IID_IDispatch> dispatch;
    CComPtr<IDataObject, &IID_IDataObject> dataobject;

    dispatch = pSomeInterface;   // implicit QI
    persist = pSomeInterface;    //  implicit QI
    dataobject = pSomeInterface; //  implicit QI

    DoIt(persist, dispatch, dataobject); // send to a function 
                                         // that needs IPersist\*,
                                         // IDispatch\*, and 
                                         // IDataObject\*

    // Destructors call release...
}

The _CComQIPtr_ is useful whenever you want the Java-style or Visual Basic-style type conversions. Notice that the code listed above didn't require any calls to _QueryInterface_ or _Release_. Those calls happened automatically.

ATL Smart Pointer Problems
--------------------------

Smart pointers can be quite convenient in some places (as in the _CComPtr_ example where we eliminated the _goto_ statement). Unfortunately, C++ smart pointers aren't the panacea that programmers pray for to solve their reference-counting and pointer-management problems. Smart pointers simply move these problems to a different level.

One situation in which to be very careful with smart pointers is when converting from code that is not smart-pointer based to code that uses the ATL smart pointers. The problem is that the ATL smart pointers don't hide the _AddRef_ and _Release_ calls. This just means you need to take care to understand how the smart pointer works rather than be careful about how you call _AddRef_ and _Release_.

For example, imagine taking this code:

void UseAnInterface(){
    IDispatch\* pDispatch = NULL;

    HRESULT hr = GetTheObject(&pDispatch);
    if(SUCCEEDED(hr)) {
        DWORD dwTICount;
        pDispatch->GetTypeInfoCount(&dwTICount);
        pDispatch->Release();
    }
}

and capriciously converting the code to use a smart pointer like this:

void UseAnInterface() {
    CComPtr<IDispatch> dispatch = NULL;

    HRESULT hr = GetTheObject(&dispatch);
    if(SUCCEEDED(hr)) {
        DWORD dwTICount;
        dispatch->GetTypeInfoCount(&dwTICount);
        dispatch->Release();
    }
}

Because _CComPtr_ and _CComQIPtr_ do not hide calls to _AddRef_ and _Re-lease_, this blind conversion causes a problem when the release is called through the dispatch smart pointer. The _IDispatch_ interface performs its own release, so the code above calls _Release_ twice—the first time explicitly through the call _dispatch->Release()_ and the second time implicitly at the function's closing curly bracket.

In addition, ATL's smart pointers include the implicit cast operator that allows smart pointers to be assigned to raw pointers. In this case, what's actually happening with the reference count starts to get confusing.

The bottom line is that while smart pointers make some aspect of client-side COM development more convenient, they're not foolproof. You still have to have some degree of knowledge about how smart pointers work if you want to use them safely.
________________________________________________________________________
7.6.6. - [Server-Side ATL Programming](invcpp5/ch29g.htm)
----------------------------------------------------
 Server-Side ATL Programming 

Server-Side ATL Programming
===========================

We've covered ATL's client-side support. While a fair amount of ATL is devoted to client-side development aids (such as smart pointers and BSTR wrappers), the bulk of ATL exists to support COM-based servers, which we'll cover next. First you'll get an overview of ATL in order to understand how the pieces fit together. Then you'll re-implement the spaceship example in ATL to investigate ATL's Object Wizard and get a good feel for what it takes to write COM classes using ATL.

ATL and COM Classes
-------------------

Your job as a COM class developer is to wire up the function tables to their implementations and to make sure _QueryInterface_, _AddRef_, and _Release_ work as advertised. How you get that to happen is your own business. As far as users are concerned, they couldn't care less what methods you use. You've seen two basic approaches so far—the raw C++ method using multiple inheritance of interfaces and the MFC approach using macros and nested classes. The ATL approach to implementing COM classes is somewhat different from either of these approaches.

Compare the raw C++ approach to MFC's approach. Remember that one way of developing COM classes using raw C++ involves multiply inheriting a single C++ class from at least one COM interface and then writing all the code for the C++ class. At that point, you've got to add any extra features (such as supporting _IDispatch_ or COM aggregation) by hand. The MFC approach to COM classes involves using macros that define nested classes (with one nested class implementing each interface). MFC supports _IDispatch_ and COM aggregation—you don't have to do a lot to get those features up and running. However, it's very difficult to paste any new interfaces onto a COM class without a lot of typing. (As you saw in [Chapter 24](ch24a.htm), MFC's COM support uses some lengthy macros.)

The ATL approach to composing COM classes requires inheriting a C++ class from several template-based classes. However, Microsoft has already done the work of implementing _IUnknown_ for you through the class templates within ATL.

Let's dive right in and create the spaceship example as a COM class. As always, start by selecting New from the File in Visual C++. This opens the New dialog with the Projects tab activated, as shown in Figure 29-1. Select ATL COM AppWizard from the Projects tab. Give your project a useful name such as spaceshipsvr, and click OK.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f29og01x.gif)]

**Figure 29-1.** _Selecting ATL COM AppWizard from the New dialog box._

ATL COM AppWizard Options
-------------------------

In the Step 1 dialog, shown in Figure 29-2, you can choose the server type for your project from a list of options. The ATL COM AppWizard gives you the choice of creating a Dynamic Link Library (DLL), an Executable (EXE), or a Service (EXE). If you select the DLL option, the options for attaching the proxy/stub code to the DLL and for including MFC in your ATL project will be activated.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f29og02x.gif)]

**Figure 29-2.** _Step 1 of the ATL COM AppWizard._

Selecting DLL as the server type produces all the necessary pieces to make your server DLL fit into the COM milieu. Among these pieces are the following well-known COM functions: _DllGetClassObject, DllCanUnloadNow, DllRegisterServer,_ and _DllUnregisterServer._ Also included are the correct server lifetime mechanisms for a DLL.

If you decide you might want to run your DLL out of process as a surrogate, selecting the Allow Merging Of Proxy/Stub Code option permits you to package all your components into a single binary file. (Proxy/stub code has traditionally shipped as a separate DLL.) That way you have to distribute only a single DLL. If you decide you absolutely must include MFC in your DLL, go ahead and select the Support MFC check box. MFC support includes AfxWin.h and AfxDisp.h in your StdAfx.h file and links your project to the current version of MFC's import library. While using MFC can be very convenient and almost addictive at times, beware of dependencies you're inheriting when you include MFC. You can also select Support MTS to add support for Microsoft Transaction Server.

If you elect to produce an Executable EXE server, the ATL COM AppWizard produces code that compiles to an EXE file. The EXE will correctly register the class objects with the operating system by using _CoRegisterClassObject_ and _CoRevokeClassObject_. The project will also insert the correct code for managing the lifetime of the executable server. Finally, if you choose the Service EXE option, the ATL COM AppWizard adds the necessary service-oriented code.

Using the ATL COM AppWizard to write a lightweight COM server yields several products. First, you get a project file for compiling your object. The project file ties together all the source code for the project and maintains the proper build instructions for each of the files. Second, you get some boilerplate Interface Definition Language (IDL) code. The IDL file is important because as the starting point for genuine COM development, it's one of the primary files you'll focus on when writing COM classes.

IDL is a purely declarative language for describing COM interfaces. Once a COM interface is described in an IDL file, a simple pass though the Microsoft Interface Definition Language (MIDL) compiler creates several more useful products.

These products include:

*   The pure abstract base classes needed to write COM classes
    
*   A type library
    
*   Source code for building the proxy stub DLL (necessary for standard COM remoting)
    

Creating a COM Class
--------------------

Once you've created a COM server, you're ready to start piling COM classes into the server. Fortunately, there's an easy way to do that with the ATL Object Wizard, shown in Figure 29-3. Select New ATL Object from the Insert menu to start the ATL Object Wizard.

Using the ATL Object Wizard to generate a new object adds a C++ source file and a header file containing the new class definition and implementation to your project. In addition, the ATL Object Wizard adds an interface to the IDL code. Although the ATL Object Wizard takes care of pumping out a skeleton IDL file, you'll still need to understand IDL to some extent if you want to write effective COM interfaces (as you'll soon see).

![](c:/dl/books/windows/msvc5th/invcpp5/images/f29og03x.gif)

**Figure 29-3.** _Using the ATL Object Wizard to insert a new ATL-based COM class into the project._

After you choose the type of ATL object, click Next to display the ATL Object Wizard Properties dialog. Depending on which object you choose, the Attributes tab of the ATL Object Wizard Properties dialog allows you to select the threading model for your COM class, and whether you want a dual (_IDispatch_\-based) or a custom interface. The dialog also allows you to choose how your class will support aggregation. In addition, the Object Wizard lets you easily include the _ISupportErrorInfo_ interface and connection points in your class. Finally, you can aggregate to the Free-Threaded Marshaler if you so choose.

Apartments and Threading
------------------------

To figure out COM, you have to understand that COM is centered on the notion of abstraction—hiding as much information as possible from the client. One piece of information that COM hides from the client is whether COM class is thread-safe. The client should be able to use an object as it sees fit without having to worry about whether an object properly serializes access to itself—that is, properly protects access to its internal data. COM defines the notion of an apartment to provide this abstraction.

An apartment defines an execution context, or thread, that houses interface pointers. A thread enters an apartment by calling a function from the _CoInitialize_ family: _CoInitialize, CoInitializeEx,_ or _OleInitialize_. Then COM requires that all method calls to an interface pointer be executed within the apartment that initialized the pointer (in other words, from the same thread that called _CoCreateInstance_). COM defines two kinds of apartments—single-threaded apartments and multithreaded apartments. Single-threaded apartments can house only one thread while multithreaded apartments can house several threads. While a process can have only one multithreaded apartment, it can have many single-threaded apartments. An apartment can house any number of COM objects.

A single-threaded apartment guarantees that COM objects created within it will have method calls serialized through the remoting layer, while a COM object created within a multithreaded apartment will not. A helpful way to remember the difference between apartments is to think of it this way: instantiating a COM object within the multithreaded apartment is like putting a piece of data into the global scope where multiple threads can get to it. Instantiating a COM object within a single-threaded apartment is like putting data within the scope of only one thread. The bottom line is that COM classes that want to live in the multithreaded apartment had better be thread-safe, while COM classes that are satisfied living in their own apartments need not worry about concurrent access to their data.

A COM object living within a different process space from its client has its method calls serialized automatically via the remoting layer. However, a COM object living in a DLL might want to provide its own internal protection (using critical sections, for example) rather than having the remoting layer protect it. A COM class advertises its thread safety to the world via a Registry setting. This named value lives in the Registry under the CLSID under _HKEY_CLASSES_ROOT_ like this:

[HKCR\CLSID\{some GUID …}\InprocServer32]
@="C:\SomeServer.DLL"
ThreadingModel=<thread model>

The ThreadingModel can be one of four values: _Single_, _Both_, _Free_, or _Apartment_, or it can be blank. ATL provides support for all current threading models. Here's a rundown of what each value indicates:

*   _Single_ or blank indicates that the class executes in the main thread only (the first single thread created by the client).
    
*   _Both_ indicates that the class is thread-safe and can execute in both the single-threaded and multithreaded apartments. This value tells COM to use the same kind of apartment as the client.
    
*   _Free_ indicates that the class is thread-safe. This value tells COM to force the object inside the multithreaded apartment.
    
*   _Apartment_ indicates that the class isn't thread-safe and must live in its own single-threaded apartment.
    

When you choose a threading model in the ATL Object Wizard, the wizard inserts different code into your class depending upon your selection. For example, if you select the apartment model, the Object Wizard derives your class from _CComObjectRootEx_ and includes _CComSingleThreadModel_ as the template parameter like this:

class ATL_NO_VTABLE CAtlSpaceship : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CAtlSpaceship, &CLSID_AtlSpaceship>,
    public IDispatchImpl<IAtlSpaceship, &IID_IAtlSpaceship,
                         &LIBID_SPACESHIPSVRLib>
{
.
.
.
};

The _CComSingleThreadModel_ template parameter mixes in the more efficient standard increment and decrement operations for _IUnknown_ (because access to the class is automatically serialized). In addition, the ATL Object Wizard causes the class to insert the correct threading model value in the Registry. If you choose the Single option in the ATL Object Wizard, the class uses the _CComSingleThreadModel_ but leaves the ThreadingModel value blank in the Registry.

Choosing Both or Free causes the class to use the _CComMultiThreadModel_ template parameter, which employs the thread-safe Win32 increment and decrement operations _InterlockedIncrement_ and _InterlockedDecrement_. For example, a free-threaded class definition looks like this:

class ATL_NO_VTABLE CAtlSpaceship : 
    public CComObjectRootEx< CComMultiThreadModel>,
    public CComCoClass<CAtlSpaceship, &CLSID_AtlSpaceship>,
    public IDispatchImpl<IAtlSpaceship, &IID_IAtlSpaceship,
                         &LIBID_SPACESHIPSVRLib>
{
.
.
.
};

Choosing Both for your threading model inserts _Both_ as the data for the ThreadingModel value, while choosing Free uses the data value _Free_ for the ThreadingModel value.

Connection Points and _ISupportErrorInfo_
-----------------------------------------

Adding connection to your COM class is easy. Selecting the Support Connection Points check box causes the class to derive from _IConnectionPointImpl_. This option also adds a blank connection map to your class. Adding connection points (for example, an event set) to your class is simply a matter of performing the following four steps:

1.  Define the callback interface in the IDL file.
    
2.  Use the ATL proxy generator to create a proxy.
    
3.  Add the proxy class to the COM class.
    
4.  Add the connection points to the connection point map.
    

ATL also includes support for _ISupportErrorInfo_. The _ISupportErrorInfo_ interface ensures that error information is propagated up the call chain correctly. OLE Automation objects that use the error-handling interfaces must implement _ISupportErrorInfo_. Selecting Support _ISupportErrorInfo_ in the ATL Object Wizard dialog causes the ATL-based class to derive from _ISupportErrorInfoImpl_.

The Free-Threaded Marshaler
---------------------------

Selecting the Free Threaded Marshaler option aggregates the COM free-threaded marshaler to your class. The generated class does this by calling _CoCreateFreeThreadedMarshaler_ in its _FinalConstruct_ function. The free-threaded marshaler allows thread-safe objects to bypass the standard marshaling that occurs whenever cross-apartment interface methods are invoked, allowing threads living in one apartment to access interface methods in another apartment as though they were in the same apartment. This process speeds up cross-apartment calls tremendously. The free-threaded marshaler does this by implementing the _IMarshal_ interface. When the client asks the object for an interface, the remoting layer calls _QueryInterface,_ asking for _IMarshal_. If the object implements _IMarshal_ (in this case, the object implements _IMarshal_ because the ATL Object Wizard also adds an entry into the class's interface to handle _QueryInterface_ requests for _IMarshal_) and the marshaling request is in process, the free-threaded marshaler actually copies the pointer into the marshaling packet. That way, the client receives an actual pointer to the object. The client talks to the object directly without having to go through proxies and stubs. Of course, if you choose the Free Threaded Marshaler option, all data in your object had better be thread-safe. Just be very cautious if you check this box.

Implementing the Spaceship Class Using ATL
------------------------------------------

We'll create the spaceship class using the defaults provided by the ATL Object Wizard in the ATL Object Wizard Properties dialog. For example, the spaceship class will have a dual interface, so it will be accessible from environments such as VBScript on a Web page. In addition, the spaceship class will be an apartment model object, meaning COM will manage most of the concurrency issues. The only information you need to supply to the ATL Object Wizard is a clever name. Enter a value such as _AtlSpaceship_ in the Short Name text box on the Names tab.

You don't need to set any of the other options right now. For instance, you don't need to set the Support Connection Points option because we'll cover connections in the next chapter. You can always add connection points later by typing them in by hand.

If you tell the ATL Object Wizard to create a Simple Object COM class named _ATLSpaceship_, here's the class definition it generates:

class ATL_NO_VTABLE CAtlSpaceship : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CAtlSpaceship, &CLSID_AtlSpaceship>,
    public IDispatchImpl<IAtlSpaceship, &IID_IAtlSpaceship,
                         &LIBID_SPACESHIPSVRLib>
{
.
.
.
};

While ATL includes quite a few COM-oriented C++ classes, those listed in the spaceship class's inheritance list above are enough to get a flavor of how ATL works.

The most generic ATL-based COM objects derive from three base classes: _CComObjectRoot_, _CComCoClass_, and _IDispatch_. _CComObjectRoot_ implements _IUnknown_ and manages the identity of the class. This means _CComObjectRoot_ implements _AddRef_ and _Release_ and hooks into ATL's _QueryInterface_ mechanism. _CComCoClass_ manages the COM class's class object and some general error reporting. In the class definition above, _CComCoClass_ adds the class object that knows how to create _CAtlSpaceship_ objects. Finally, the code produced by the ATL Object Wizard includes an implementation of _IDispatch_ based on the type library produced by compiling the IDL. The default _IDispatch_ is based on a dual interface (which is an _IDispatch_ interface followed by the functions defined in the IDL).

As you can see, using ATL to implement COM classes is different from using pure C++. The Tao of ATL differs from what you might be used to when developing normal C++ classes. With ATL, the most important part of the project is the interfaces, which are described in IDL. By adding functions to the interfaces in the IDL code, you automatically add functions to the concrete classes implementing the interfaces. The functions are added automatically because the projects are set up such that compiling the IDL file yields a C++ header file with those functions. All that's left for you to do after adding the functions in the interface is to implement those functions in the C++ class. The IDL file also provides a type library so the COM class can implement _IDispatch_. However, while ATL is useful for implementing lightweight COM services and objects, ATL is also a new means by which you can create ActiveX controls, as you'll see in the [next chapter](ch30a.htm).

Basic ATL Architecture
----------------------

If you've experimented at all with ATL, you've seen how it simplifies the process of implementing COM classes. The tool support is quite good—it's almost as easy to develop COM classes using Visual C++ 6.0 as it is to create MFC-based programs. Just use AppWizard to create a new ATL-based class. However, instead of using ClassWizard (as you would to handle messages and to add dialog box member variables), use ClassView to add new function definitions to an interface. Then simply fill in the functions within the C++ code generated by ClassView. The code generated by AppWizard includes all the necessary code for implementing your class, including an implementation of _IUnknown_, a server module to house your COM class, and a class object that implements _IClassFactory_.

Writing COM objects as we've just described is certainly more convenient than most other methods. But exactly what happens when you use the AppWizard to generate the code for you? Understanding how ATL works is important if you want to extend your ATL-based COM classes and servers much beyond what AppWizard and ClassView provide. For example, ATL provides support for advanced interface techniques such as tear-off interfaces. Unfortunately, there's no Wizard option for implementing a tear-off interface. Even though ATL supports it, you've got to do a little work by hand to accomplish the tear-off interface. Understanding how ATL implements _IUnknown_ is helpful in this situation.

Let's examine the _CAtlSpaceship_ class in a bit more detail. Here's the entire definition:

class ATL_NO_VTABLE CAtlSpaceship : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CAtlSpaceship, &CLSID_AtlSpaceship>,
    public IDispatchImpl<IAtlSpaceship, &IID_IAtlSpaceship,
                         &LIBID_SPACESHIPSVRLib>
{
public:
    CAtlSpaceship()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_ATLSPACESHIP)

BEGIN_COM_MAP(CAtlSpaceship)
    COM_INTERFACE_ENTRY(IAtlSpaceship)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IAtlSpaceship
public:
};

While this is ordinary vanilla C++ source code, it differs from normal everyday C++ source code for implementing a COM object in several ways. For example, while many COM class implementations derive strictly from COM interfaces, this COM class derives from several templates. In addition, this C++ class uses several odd-looking macros. As you examine the code, you'll see ATL's implementation of _IUnknown_, as well as a few other interesting topics, such as a technique for managing _vtable_ bloat and an uncommon use for templates. Let's start by taking a look at the first symbol in the wizard-generated macro code: _ATL_NO_VTABLE_.

Managing VTBL Bloat
-------------------

COM interfaces are easily expressed in C++ as pure abstract base classes. Writing COM classes using multiple inheritance (there are other ways to write COM classes) is merely a matter of adding the COM interface base classes to your inheritance list and implementing the union of all the functions. Of course, this means that the memory footprint of your COM server will include a significant amount of vtable overhead for each interface implemented by your class. That's not a big deal if you have only a few interfaces and your C++ class hierarchy isn't very deep. However, implementing interfaces this way does add overhead that tends to accumulate as interfaces are added and hierarchies deepen. ATL provides a way to cut down on some of the overhead introduced by a lot of virtual functions. ATL defines the following symbol:

#define ATL_NO_VTABLE  __declspec(novtable)

Using _ATL_NO_VTABLE_ prevents an object's vtable (_vtable_) from being initialized in the constructor, thereby eliminating from the linker the vtable and all the functions pointed to by the vtable for that class. This elimination can lower the size of your COM server somewhat, provided the most-derived class does not use the _novtable declspec_ shown above. You'll notice the size difference in classes with deep derivation lists. One caveat, however: calling virtual functions from the constructor of any object that uses this _declspec_ is unsafe because _vptr_ is uninitialized.

The second line in the class declaration previously shown demonstrates that _CAtlSpaceship_ derives from _CComObjectRootEx_. This is where you get to ATL's version of _IUnknown_.

ATL's _IUnknown: CComObjectRootEx_
----------------------------------

While _CComObjectRootEx_ isn't quite at the top of the ATL hierarchy, it's pretty close. The actual base class for a COM object in ATL is a class named _CComObjectRootBase_. (Both class definitions are located in ATLCOM.H.) Looking at _CComObjectRootBase_ reveals the code you might expect for a C++ based COM class. _CComObjectRootBase_ includes a DWORD member named _m_dwRef_ for reference counting. You'll also see _OuterAddRef_, _OuterRelease_, and _OuterQueryInterface_ to support COM aggregation and tear-off interfaces. Looking at _CComObjectRootEx_ reveals _InternalAddRef_, _InternalRelease_, and _InternalQueryInterface_ for performing the regular native reference counting, and _QueryInterface_ mechanisms for class instances with object identity.

Notice that _CAtlSpaceship_'s definition shows that the class is derived from _CComObjectRootEx_ and that _CComObjectRootEx_ is a parameterized template class. The listing below shows the definition of _CComObjectRootEx_.

template <class ThreadModel>
class CComObjectRootEx : public CComObjectRootBase
{
public:
    typedef ThreadModel _ThreadModel;
    typedef _ThreadModel::AutoCriticalSection _CritSec;
    typedef CComObjectLockT<_ThreadModel> ObjectLock;

    ULONG InternalAddRef() {
        ATLASSERT(m_dwRef != -1L);
        return _ThreadModel::Increment(&m_dwRef);
    }
    ULONG InternalRelease() {
        ATLASSERT(m_dwRef > 0);
        return _ThreadModel::Decrement(&m_dwRef);
    }

    void Lock() {m_critsec.Lock();}
    void Unlock() {m_critsec.Unlock();}
private:
    _CritSec m_critsec;
};

_CComObjectRootEx_ is a template class that varies in type based on the kind of threading model class passed in as the template parameter. In fact, ATL supports several threading models: Single-Threaded Apartments (STAs), Multi-Threaded Apartments (MTAs), and Free Threading. ATL includes three preprocessor symbols for selecting the various default threading models for your project: __ATL_SINGLE_THREADED_, __ATL_APARTMENT_THREADED_, and __ATL_FREE_THREADED_.

Defining the preprocessor symbol __ATL_SINGLE_THREADED_ in stdafx.h changes the default threading model to support only one STA-based thread. This option is useful for out-of-process servers that don't create any extra threads. Because the server supports only one thread, ATL's global state can remain unprotected by critical sections and the server is therefore more efficient. The downside is that your server can support only one thread. Defining __ATL_APARTMENT_THREADED_ for the preprocessor causes the default threading model to support multiple STA-based threads. This is useful for apartment model in-process servers (servers supporting the _ThreadingModel=Apartment_ Registry value). Because a server employing this threading model can support multiple threads, ATL protects its global state using critical sections. Finally, defining the __ATL_FREE_THREADED_ preprocessor symbol creates servers compatible with any threading environment. That is, ATL protects its global state using critical sections, and each object in the server will have its own critical sections to maintain data safety.

These preprocessor symbols merely determine which threading class to plug into _CComObjectRootEx_ as a template parameter. ATL provides three threading model classes. The classes provide support for the most efficient yet thread-safe behavior for COM classes within each of the three contexts listed above. The three classes are _CComMultiThreadModelNoCS, CComMultiThreadModel,_ and _CComSingleThreadModel._ The following listing shows the three threading model classes within ATL:

class CComMultiThreadModelNoCS
{
public:
    static ULONG WINAPI Increment(LPLONG p)
                        {return InterlockedIncrement(p);}
    static ULONG WINAPI Decrement(LPLONG p) 
                        {return InterlockedDecrement(p);}
    typedef CComFakeCriticalSection AutoCriticalSection;
    typedef CComFakeCriticalSection CriticalSection;
    typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};

class CComMultiThreadModel
{
public:
    static ULONG WINAPI Increment(LPLONG p)
                        {return InterlockedIncrement(p);}
    static ULONG WINAPI Decrement(LPLONG p)
                        {return InterlockedDecrement(p);}
    typedef CComAutoCriticalSection AutoCriticalSection;
    typedef CComCriticalSection CriticalSection;
    typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};

class CComSingleThreadModel
{
public:
    static ULONG WINAPI Increment(LPLONG p) {return ++(\*p);}
    static ULONG WINAPI Decrement(LPLONG p) {return --(\*p);}
    typedef CComFakeCriticalSection AutoCriticalSection;
    typedef CComFakeCriticalSection CriticalSection;
    typedef CComSingleThreadModel ThreadModelNoCS;
};

Notice that each of these classes exports two static functions—_Increment_ and _Decrement_—and various aliases for critical sections.

_CComMultiThreadModel_ and _CComMultiThreadModelNoCS_ both implement _Increment_ and _Decrement_ using the thread-safe Win32 _InterlockedIncrement_ and _InterlockedDecrement_ functions. _CComSingleThreadModel_ implements _Increment_ and _Decrement_ using the more conventional ++ and -- operators.

In addition to implementing incrementing and decrementing differently, the three threading models also manage critical sections differently. ATL provides wrappers for two critical sections—a _CComCriticalSection_ (which is a plain wrapper around the Win32 critical section API) and _CComAutoCriticalSection_ (which is the same as _CComCriticalSection_ with the addition of automatic initialization and cleanup of critical sections). ATL also defines a "fake" critical section class that has the same binary signature as the other critical section classes but doesn't do anything. As you can see from the class definitions, _CComMultiThreadModel_ uses real critical sections while _CComMultiThreadModelNoCS_ and _CComSingleThreadModel_ use the fake no-op critical sections.

So now the minimal ATL class definition makes a bit more sense. _CComObjectRootEx_ takes a thread model class whenever you define it. _CAtlSpaceship_ is defined using the _CComSingleThreadModel_ class, so it uses the _CComSingleThreadModel_ methods for incrementing and decrementing as well as the fake no-op critical sections. Thus _CAtlSpaceship_ uses the most efficient behavior since it doesn't need to worry about protecting data. However, you're not stuck with that model. If you want to make _CAtlSpaceship_ safe for any threading environment, for example, simply redefine _CAtlSpaceship_ to derive from _CComObjectRootEx_ using _CComMultiThreadModel_ as the template parameter. _AddRef_ and _Release_ calls are automatically mapped to the correct _Increment_ and _Decrement_ functions.

ATL and _QueryInterface_
------------------------

It looks as though ATL took a cue from MFC for implementing _QueryInterface_—ATL uses a lookup table just like MFC's version. Take a look at the middle of _CAtlSpaceship_'s definition—you'll see a construct based on macros called the interface map. ATL's interface maps constitute its _QueryInterface_ mechanism.

Clients use _QueryInterface_ to arbitrarily widen the connection to an object. That is, when a client needs a new interface, it calls _QueryInterface_ through an existing interface. The object then looks at the name of the requested interface and compares that name to all the interfaces implemented by the object. If the object implements the interface, the object hands the interface back to the client. Otherwise, _QueryInterface_ returns an error indicating that no interface was found.

Traditional _QueryInterface_ implementations usually consist of long if-then statements. For example, a standard implementation of _QueryInterface_ for a multiple-inheritance COM class might look like this:

class CAtlSpaceship: public IDispatch,
                            IAtlSpaceship {
    HRESULT QueryInterface(RIID riid, 
                           void\*\* ppv) {
        if(riid == IID_IDispatch)
            \*ppv = (IDispatch\*) this;
        else if(riid == IID_IAtlSpaceship ||
                riid == IID_IUnknown)
            \*ppv = (IAtlSpaceship \*) this;
        else {
            \*ppv = 0;
            return E_NOINTERFACE;
        }

        ((IUnknown\*)(\*ppv))->AddRef();
        return NOERROR;
    }
    // AddRef, Release, and other functions
};

As you'll see in a moment, ATL uses a lookup table instead of this conventional if-then statement.

ATL's lookup table begins with a macro named _BEGIN_COM_MAP_. The listing below shows the full definition of _BEGIN_COM_MAP_.

#define BEGIN_COM_MAP(x) public: 
    typedef x _ComMapClass; 
    static HRESULT WINAPI _Cache(void\* pv, 
                                 REFIID iid, 
                                 void\*\* ppvObject, 
                                 DWORD dw) {  
        _ComMapClass\* p = (_ComMapClass\*)pv;
        p->Lock();
        HRESULT hRes = 
          CComObjectRootBase::_Cache(pv, 
                                     iid, 
                                     ppvObject, 
                                     dw);
        p->Unlock();
        return hRes;
    }
    IUnknown\* GetRawUnknown() { 
        ATLASSERT(_GetEntries()[0].pFunc == 
              _ATL_SIMPLEMAPENTRY); 
        return (IUnknown\*)((int)this+_GetEntries()->dw); 
    }
    _ATL_DECLARE_GET_UNKNOWN(x)
    HRESULT _InternalQueryInterface(REFIID iid, 
                                    void\*\* ppvObject) { 
        return InternalQueryInterface(this, 
                                      _GetEntries(), 
                                      iid, 
                                      ppvObject); 
    } 
    const static _ATL_INTMAP_ENTRY\* WINAPI _GetEntries() { 
    static const _ATL_INTMAP_ENTRY _entries[] = { 
        DEBUG_QI_ENTRY(x)
        .
        .
        .
    #define END_COM_MAP()   {NULL, 0, 0}};\
    return _entries;}

Each class that uses ATL for implementing _IUnknown_ specifies an interface map to provide to _InternalQueryInterface_. ATL's interface maps consist of structures containing interface ID (GUID)/DWORD/function pointer tuples. The following listing shows the type named __ATL_INTMAP_ENTRY_ that contains these tuples.

struct _ATL_INTMAP_ENTRY {
    const IID\* piid;       
    DWORD dw;
    _ATL_CREATORARGFUNC\* pFunc; 
};

The first member is the interface ID (a GUID), and the second member indicates what action to take when the interface is queried. There are three ways to interpret the third member. If _pFunc_ is equal to the constant __ATL_SIMPLEMAPENTRY_ (the value 1), _dw_ is an offset into the object. If _pFunc_ is non-null but not equal to 1, _pFunc_ indicates a function to be called when the interface is queried. If _pFunc_ is _NULL_, _dw_ indicates the end of the _QueryInterface_ lookup table.

Notice that _CAtlSpaceship_ uses _COM_INTERFACE_ENTRY_. This is the interface map entry for regular interfaces. Here's the raw macro:

#define offsetofclass(base, derived) 
((DWORD)(static_cast<base\*>((derived\*)8))-8)

#define COM_INTERFACE_ENTRY(x)\
    {&_ATL_IIDOF(x), \
    offsetofclass(x, _ComMapClass), \
    _ATL_SIMPLEMAPENTRY}

_COM_INTERFACE_ENTRY_ fills the __ATL_INTMAP_ENTRY_ structure with the interface's GUID. In addition, notice how _offsetofclass_ casts the _this_ pointer to the right kind of interface and fills the _dw_ member with that value. Finally, _COM_INTERFACE_ENTRY_ fills the last field with __ATL_SIMPLEMAPENTRY_ to indicate that _dw_ points to an offset into the class.

For example, the interface map for _CAtlSpaceship_ looks like this after the preprocessor is done with it:

const static _ATL_INTMAP_ENTRY\* _
_stdcall _GetEntries() { 
    static const _ATL_INTMAP_ENTRY _entries[] = { 
        {&IID_IAtlSpaceship, 
        ((DWORD)(static_cast< IAtlSpaceship\*>((_ComMapClass\*)8))-8),
        ((_ATL_CREATORARGFUNC\*)1)},
        {&IID_IDispatch, 
        ((DWORD)(static_cast<IDispatch\*>((_ComMapClass\*)8))-8), 
        ((_ATL_CREATORARGFUNC\*)1)},
        {0, 0, 0}
    };
    return _entries;
}

Right now, the _CAtlSpaceship_ class supports two interfaces—_IAtlSpaceship_ and _IDispatch_, so there are only two entries in the map.

_CComObjectRootEx_'s implementation of _InternalQueryInterface_ uses the __GetEntries_ function as the second parameter. _CComObjectRootEx::InternalQueryInterface_ uses a global ATL function named _AtlInternalQueryInterface_ to look up the interface in the map. _AtlInternalQueryInterface_ simply walks through the map trying to find the interface.

In addition to _COM_INTERFACE_ENTRY,_ ATL includes 16 other macros for implementing composition techniques ranging from tear-off interfaces to COM aggregation. Now you'll see what it takes to beef up the _IAtlSpaceship_ interface and add those two other interfaces, _IMotion_ and _IVisual_. You'll also learn about the strange COM beast known as a dual interface.

Making the Spaceship Go
-----------------------

Now that you've got some ATL code staring you in the face, what can you do with it? This is COM, so the place to start is in the IDL file. Again, if you're a seasoned C++ developer, this is a new aspect of software development you're probably not used to. Remember that these days, software distribution and integration are becoming very important. You've been able to get away with hacking out C++ classes and throwing them into a project together because you (as a developer) know the entire picture. However, component technologies (like COM) change that. You as a developer no longer know the entire picture. Often you have only a component—you don't have the source code for the component. The only way to know how to talk to a component is through the interfaces it exposes.

Keep in mind that modern software developers use many different tools—not just C++. You've got Visual Basic developers, Java developers, Delphi developers, and C developers. COM is all about making the edges line up so that software pieces created by these various components can all integrate smoothly when they come together. In addition, distributing software remotely (either out-of-process on the same machine or even to a different machine) requires some sort of inter-process communication. That's why there's Interface Definition Language (IDL). Here's the default IDL file created by the ATL wizards with the new spaceship class:

import "oaidl.idl";
import "ocidl.idl";
    [
        object,
        uuid(A9D750E1-51A1-11D1-8CAA-FD10872CC837),
        dual,
        helpstring("IAtlSpaceship Interface"),
        pointer_default(unique)
    ]
    interface IAtlSpaceship : IDispatch
    {
    };

[
    uuid(A0736061-50DF-11D1-8CAA-FD10872CC837),
    version(1.0),
    helpstring("spaceshipsvr 1.0 Type Library")
]
library SPACESHIPSVRLib
{
    importlib("stdole32.tlb");
    importlib("stdole2.tlb");

    [
        uuid(A9D750E2-51A1-11D1-8CAA-FD10872CC837),
        helpstring("AtlSpaceship Class")
    ]
    coclass AtlSpaceship
    {
        [default] interface IAtlSpaceship;
    };
};

The key concept involved here is that IDL is a purely declarative language. This language defines how other clients will talk to an object. Remember—you'll eventually run this code through the MIDL compiler to get a pure abstract base class (useful for C++ clients) and a type library (useful for Visual Basic and Java clients as well as others). If you understand plain C code, you're well on your way to understanding IDL. You might think of IDL as C with footnotes. The syntax of IDL dictates that attributes will always precede what they describe. For example, attributes precede items such as interface declarations, library declarations, and method parameters.

If you look at the IDL file, you'll notice that it begins by importing oaidl.idl and ocidl.idl. Importing these files is somewhat akin to including windows.h inside one of your C or C++ files. These IDL files include definitions for all of the basic COM infrastructures (including definitions for _IUnknown_ and _IDispatch_).

An open square bracket ([) follows the _import_ statement. In IDL, square brackets always enclose attributes. The first element described in this IDL file is the _IAtlSpaceship_ interface. However, before you can describe the interface, you need to apply some attributes to it. For example, it needs a name (a GUID), and you need to tell the MIDL compiler that this interface is COM-oriented rather than being used for standard RPC and that this is a dual interface (more on dual interfaces shortly). Next comes the actual interface itself. Notice how it appears very much like a normal C structure.

Once the interfaces are described in IDL, it is often useful to collect this information into a type library, which is what the next section of the IDL file does. Notice the type library section also begins with an open square bracket, designating that attributes are to follow. As always, the type library is a discrete "thing" in COM and as such requires a name (GUID). The library statement tells the MIDL compiler that this library includes a COM class named _AtlSpaceship_ and that clients of this class can acquire the _IAtlSpaceship_ interface.

Adding Methods to an Interface
------------------------------

Right now the _IAtlSpaceship_ interface is pretty sparse. It looks like it could use a method or two. Let's add one. Notice that Visual C++ now extends ClassView to include COM interfaces. (You can tell they're COM interfaces because of the little lollipop next to the symbol.) Notice also that _CAtlSpaceship_ de- rives from something named _IAtlSpaceship. IAtlSpaceship_ is, of course, a COM interface. Double-clicking on _IAtlSpaceship_ in the ClassView brings that specific section of the IDL into the editor window, as shown in Figure 29-4.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f29og04x.gif)]

**Figure 29-4.** _Interfaces in ClassView._

At this point, you could begin typing the COM interface into the IDL file. If you add functions and methods this way (straight into the IDL file), you'll have to touch the AtlSpaceship.h and AtlSpaceship.cpp files and insert the methods by hand. A more effective way to add functions to the interface is through the ClassView. To edit the IDL through the ClassView, simply right-click the mouse on the interface within ClassView. Two items that appear in the context menu are Add Method and Add Property. Let's add a method named _CallStarFleet_. Figure 29-5 shows the dialog box that appears when adding a method.

To add a method, simply type the name of the method into the Method Name text box. Then type the method parameters into the Parameters text box. Here's where it helps to understand a little bit about IDL.

![](c:/dl/books/windows/msvc5th/invcpp5/images/F29OG05.GIF)

**Figure 29-5.** _Adding a method to an interface._

Remember that IDL's purpose is to provide completely unambiguous information about how methods can be invoked. In the standard C++ world, you could often get away with ambiguities like open-ended arrays because the caller and the callee shared the same stack frame—there was always a lot of wiggle room available. Now that method calls might eventually go over the wire, it's important to tell the remoting layer exactly what to expect when it encounters a COM interface. This is done by applying attributes to the method parameters (more square brackets).

The method call shown in Figure 29-5 (_CallStartFleet_) has two parameters in its list—a floating point number indicating the stardate and a BSTR indicating who received the communication. Notice that the method definition spells out the parameter direction. The stardate is passed into the method call, designated by the [in] attribute. A BSTR identifying the recipient is passed back as a pointer to a BSTR. The [out] attribute indicates the direction of the parameter is from the object back to the client. The [retval] attribute indicates that you can assign the result of this method to a variable in higher languages supporting this feature.

Dual Interfaces
---------------

If you read through [Chapter 25](ch25a.htm), you had a chance to see the _IDispatch_ interface. _IDispatch_ makes it possible to expose functionality (at the binary level) to environments such as VBScript that don't have a clue about vtables. For _IDispatch_ to work, the client has to go through a lot of machinations before it can call _Invoke_. The client first has to acquire the invocation tokens. Then the client has to set up the VARIANT arguments. On the object side, the object has to decode all those VARIANT parameters, make sure they're correct, put them on some sort of stack frame, and then make the function call. As you can imagine, all this work is complex and time-consuming. If you're writing a COM object and you expect some of your clients to use scripting languages and other clients to use languages like C++, you've got a dilemma. You've got to include _IDispatch_ or you lock your scripting language clients out. If you provide only _IDispatch_, you make accessing your object from C++ very inconvenient. Of course, you can provide access through both _IDispatch_ and a custom interface, but that involves a lot of bookkeeping work. Dual interfaces evolved to handle this problem.

A dual interface is simply _IDispatch_ with functions pasted onto the end. For example, the _IMotion_ interface described below is a valid dual interface:

interface IMotion : public IDispatch {
    virtual HRESULT Fly() = 0;
    virtual HRESULT GetPosition() = 0;
};

Because _IMotion_ derives from _IDispatch_, the first seven functions of _IMotion_ are those of _IDispatch_. Clients who understand only _IDispatch_ (VBScript for instance) look at the interface as just another version of _IDispatch_ and feed DISPIDs to the _Invoke_ function in the hopes of invoking a function. Clients who understand vtable-style custom interfaces look at the entire interface, ignore the middle four functions (the _IDispatch_ functions), and concentrate on the first three functions (_IUnknown_) and the last three functions (the ones that represent the interface's core functions). Figure 29-6 shows the vtable layout of _IMotion_.

Most raw C++ implementations load the type library right away and delegate to _ITypeInfo_ to perform the nasty task of implementing _Invoke_ and _GetIDsOfNames_. To get an idea of how this works, see Kraig Brockschmidt's book _Inside OLE_, 2d. ed. (Microsoft Press, 1995) or Dale Rogerson's book _Inside COM_ (Microsoft Press, 1997).

![](c:/dl/books/windows/msvc5th/invcpp5/images/F29og06.GIF)

**Figure 29-6.**

_The layout of a dual interface._

ATL and _IDispatch_
-------------------

ATL's implementation of _IDispatch_ delegates to the type library. ATL's implementation of _IDispatch_ lives in the class _IDispatchImpl_. Objects that want to implement a dual interface include the _IDispatchImpl_ template in the inheritance list like this:

class ATL_NO_VTABLE CAtlSpaceship : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CAtlSpaceship, &CLSID_AtlSpaceship>,
    public IDispatchImpl<IAtlSpaceship, &IID_IAtlSpaceship,
                         &LIBID_SPACESHIPSVRLib>,
    public IDispatchImpl<IVisual, &IID_IVisual,
                         &LIBID_SPACESHIPSVRLib>,
    public IDispatchImpl<IMotion, &IID_IMotion,
                         &LIBID_SPACESHIPSVRLib>
{
.
.
.
};

In addition to including the _IDispatchImpl_ template class in the inheritance list, the object includes entries for the dual interface and for _IDispatch_ in the interface map so that _QueryInterface_ works properly:

BEGIN_COM_MAP(CAtlSpaceship)
    COM_INTERFACE_ENTRY(IAtlSpaceship)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

As you can see, the _IDispatchImpl_ template class arguments include the dual interface itself, the GUID for the interface, and the GUID representing the type library holding all the information about the interface. In addition to these template arguments, the _IDispatchImpl_ class has some optional parameters not illustrated in Figure 29-6. The template parameter list also includes room for a major and minor version of the type library. Finally, the last template parameter is a class for managing the type information. ATL provides a default class named _CComTypeInfoHolder_.

In most raw C++ implementations of _IDispatch_, the class calls _LoadTypeLib_ and _ITypeLib::GetTypeInfoOfGuid_ in the constructor and holds on to the _ITypeInfo_ pointer for the life of the class. ATL's implementation does things a little differently by using the _CComTypeInfoHolder_ class to help manage the _ITypeInfo_ pointer. _CComTypeInfoHolder_ maintains an _ITypeInfo_ pointer as a data member and wraps the critical _IDispatch_\-related functions _GetIDsOfNames_ and _Invoke_.

Clients acquire the dual interface by calling _QueryInterface_ for _IID_IAtlSpaceship._ (The client can also get this interface by calling _QueryInterface_ for _IDispatch._) If the client calls _CallStartFleet_ on the interface, the client accesses those functions directly (as for any other COM interface).

When a client calls _IDispatch::Invoke_, the call lands inside _IDispatchImpl's_ _Invoke_ function as you'd expect. From there, _IDispatchImpl::Invoke_ delegates to the _CComTypeInfoHolder_ class to perform the invocation, _CComTypeInfoHolder_'s _Invoke_. The _CComTypeInfoHolder_ class doesn't call _LoadTypeLib_ until an actual call to _Invoke_ or _GetIDsOfNames. CComTypeInfoHolder_ has a member function named _GetTI_ that consults the Registry for the type information (using the GUID and any major/minor version numbers passed in as a template parameter). Then _CComTypeInfoHolder_ calls _ITypeLib::GetTypeInfo_ to get the information about the interface. At that point, the type information holder delegates to the type information pointer. _IDispatchImpl_ implements _IDispatch::GetIDsOfNames_ in the same manner.

The _IMotion_ and _IVisual_ Interfaces
--------------------------------------

To get this COM class up to snuff with the other versions (the raw C++ version and the MFC version described in [Chapter 24](ch24a.htm)), you need to add the _IMotion_ and _IVisible_ interfaces to the project and to the class. Unfortunately, at the present time the only way to get this to happen is by typing the interfaces in by hand (the ATL AppWizard gives you only one interface by default). Open the IDL file and position the cursor near the top (somewhere after the _#import_ statements but before the _library_ statement), and start typing interface definitions as described in the following paragraph.

Once you get the hang of IDL, your first instinct when describing an interface should be to insert an open square bracket. Remember that in IDL, distinct items get attributes. One of the most important attributes for an interface is the name, or the GUID. In addition, at the very least the interface has to have the _object_ attribute to tell the MIDL compiler you're dealing with COM at this point (as opposed to regular RPC). You also want these interfaces to be dual interfaces. The keyword "dual" in the interface attributes indicates this and inserts certain Registry entries to get the universal marshaling working correctly. After the attributes are closed off with a closing square bracket, the interface keyword kicks in to describe the interface. You'll make _IMotion_ a dual interface and _IVisual_ a plain custom interface to illustrate how the two different types of interfaces are attached to the _CSpaceship_ class. Here are the _IMotion_ and _IVisible_ interfaces described in IDL:

   [
        object,
        uuid(97B5C101-5299-11d1-8CAA-FD10872CC837),
        dual,
        helpstring("IMotion interface")
    ]
    interface IMotion : IDispatch
    {
        HRESULT Fly();
        HRESULT GetPosition([out,retval]long\* nPosition);
    };

    [
        object,
        uuid(56F58464-52A4-11d1-8CAA-FD10872CC837),
        helpstring("IVisual interface")
    ]
    interface IVisual : IUnknown
    {
        HRESULT Display();
    };

Once the interfaces are described in IDL, you run the IDL through the MIDL compiler again. The MIDL compiler spits out a new copy of spaceshipsvr.h with the pure abstract base classes for _IMotion_ and _IVisual_.

Now you need to add these interfaces to the _CSpaceship_ class. There are two steps here. The first step is to create the interface part of the COM class's identity. Let's do the _IMotion_ interface first. Adding the _IMotion_ interface to _CSpaceship_ is easy. Just use the _IDispatchImpl_ template to provide an implementation of a dual interface like this:

class ATL_NO_VTABLE CAtlSpaceship : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CAtlSpaceship, &CLSID_AtlSpaceship>,
    public IDispatchImpl<IAtlSpaceship, &IID_IAtlSpaceship,
                         &LIBID_SPACESHIPSVRLib>,
    public IDispatchImpl<IMotion, &IID_IMotion,
                         &LIBID_SPACESHIPSVRLib>
{
.
.
.
};

The second step involves beefing up the interface map so the client can acquire the _IMotion_ interface. However, having two dual interfaces in a single COM class brings up an interesting issue. When a client calls _QueryInterface_ for _IMotion_, the client should definitely get _IMotion_. However, when the client calls _QueryInterface_ for _IDispatch_, which version of _IDispatch_ should the client get—_IAtlSpaceship_'s dispatch interface or _IMotion_'s dispatch interface?

Multiple Dual Interfaces
------------------------

Remember that all dual interfaces begin with the seven functions of _IDispatch_. A problem occurs whenever the client calls _QueryInterface_ for _IID_IDispatch_. As a developer, you need to choose which version of _IDispatch_ to pass out.

The interface map is where the _QueryInterface_ for _IID_IDispatch_ is specified. ATL has a specific macro for handling the dual interface situation. First consider the interface map for _CAtlSpaceship_ so far:

BEGIN_COM_MAP(CAtlSpaceship)
    COM_INTERFACE_ENTRY(IAtlSpaceship)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

When the client calls _QueryInterface_, ATL rips through the table trying to match the requested IID to one in the table. The interface map above handles two interfaces: _IAtlSpaceship_ and _IDispatch_. If you want to add another dual interface to the _CAtlSpaceship_ class, you need a different macro.

The macro handling multiple dispatch interfaces in an ATL-based COM class is named _COM_INTERFACE_ENTRY2_. To get _QueryInterface_ working correctly, all you need to do is decide which version of _IDispatch_ the client should get when asking for _IDispatch,_ like this:

BEGIN_COM_MAP(CAtlSpaceship)
    COM_INTERFACE_ENTRY(IAtlSpaceship)
    COM_INTERFACE_ENTRY(IMotion)
    COM_INTERFACE_ENTRY2(IDispatch, IAtlSpaceship)
END_COM_MAP()

In this case, a client asking for _IDispatch_ gets a pointer to _IAtlSpaceship_ (whose first seven functions include the _IDispatch_ functions).

Adding a nondual interface to an ATL-based COM class is even easier. Just add the interface to the inheritance list like this:

class ATL_NO_VTABLE CAtlSpaceship : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CAtlSpaceship, &CLSID_AtlSpaceship>,
    public IDispatchImpl<IAtlSpaceship, &IID_IAtlSpaceship, 
                         &LIBID_SPACESHIPSVRLib>,
    public IDispatchImpl<IMotion, &IID_IMotion,
                         &LIBID_SPACESHIPSVRLib>,
    public IVisual
{
.
.
. 
};

Then add an interface map entry like this:

BEGIN_COM_MAP(CAtlSpaceship)
    COM_INTERFACE_ENTRY(IAtlSpaceship)
    COM_INTERFACE_ENTRY(IMotion)
    COM_INTERFACE_ENTRY2(IDispatch, IAtlSpaceship)
    COM_INTERFACE_ENTRY(IVisual)
END_COM_MAP()
________________________________________________________________________
7.6.7. - [Conclusion](invcpp5/ch29h.htm)
----------------------------------------------------
 Conclusion 

Conclusion
==========

There are a couple of key points in this chapter to remember. COM is a binary object model. Clients and objects agree on a binary layout (the interface). Once both parties agree on the layout, they talk together via the interface. The client is not at all concerned about how that interface is actually wired up. As long as the functions work as advertised, the client is happy. There are a number of ways to hook up COM interfaces, including multiply inheriting a single C++ class from several interfaces, using nested classes, or using a framework such as ATL.

ATL is Microsoft's framework for assembling small COM classes. ATL has two sides—some smart pointers to help with client-side coding and a complete framework for implementing COM classes. ATL implements _IUnknown_, _IDispatch_, and _IClassFactory_ in templates provided through the library. In addition, ATL includes a wizard for helping you get started with a COM server and a wizard for inserting COM classes into your project.

While ATL does a lot for you, it doesn't completely excuse you from learning the basics of how COM works. In fact, you'll be able to use ATL a lot more efficiently once you understand COM. In the [next chapter](ch30a.htm), we'll take a look at how to use ATL to write ActiveX controls effectively.
________________________________________________________________________
7.7. - [Chapter 30 -- ATL and ActiveX Controls](invcpp5/ch30a.htm)
----------------------------------------------------
 Chapter 30 -- ATL and ActiveX Controls  Chapter 30

ATL and ActiveX Controls
========================

If you've finished reading about COM and ATL and still wonder how COM fits into your day-to-day programming activities, you're not alone. Figuring out how to use COM in real life isn't always obvious at first glance. After all, a whole lot of extra code must be typed in just to get a COM object up and running. However, there's a very real application of COM right under your nose —ActiveX Controls. ActiveX controls are small gadgets (usually UI-oriented) written around the Component Object Model.

In [Chapter 29](ch29a.htm), you examined COM classes created by using ATL. In this chapter, you'll learn how to write a certain kind of COM class—an ActiveX control. You had a chance to work with ActiveX Controls from the client side in [Chapter 8](ch08a.htm). Now it's time to write your own.

There are several steps involved in creating an ActiveX control using ATL, including:

*   Deciding what to draw
    
*   Developing incoming interfaces for the control
    
*   Developing outgoing interfaces (events) for the control
    
*   Implementing a persistence mechanism for the control
    
*   Providing a user interface for manipulating the control's properties
    

This chapter covers all these steps. Soon you'll be able to use ATL to create ActiveX controls that you (or other developers) can use within other programs.
________________________________________________________________________
7.7.1. - [ActiveX Controls](invcpp5/ch30b.htm)
----------------------------------------------------
 ActiveX Controls 

ActiveX Controls
================

Even today, there's some confusion as to what really constitutes an ActiveX control. In 1994, Microsoft tacked some new interfaces onto its Object Linking and Embedding protocol, packaged them within DLLs, and called them OLE Controls. Originally, OLE Controls implemented nearly the entire OLE Document embedding protocol. In addition, OLE Controls supported the following:

*   Dynamic invocation (Automation)
    
*   Property pages (so the user could modify the control's properties)
    
*   Outbound callback interfaces (event sets)
    
*   Connections (a standard way to for clients and controls to hook up the event callbacks)
    

When the Internet became a predominant factor in Microsoft's marketing plans, Microsoft announced its intention to plant ActiveX Controls on Web pages. At that point, the size of these components became an issue. Microsoft took its OLE Control specification, changed the name from OLE Controls to ActiveX Controls, and stated that all the features listed above were optional. This means that under the new ActiveX Control definition, a control's only requirement is that it be based on COM and that it implement _IUnknown_. Of course, for a control to be useful it really needs to implement most of the features listed above. So in the end, ActiveX Controls and OLE Controls refer to more or less the same animal.

Developers have been able to use MFC to create ActiveX controls since mid-1994. However, one of the downsides of using MFC to create ActiveX controls is that the controls become bound to MFC. Sometimes you want your controls to be smaller or to work even if the end user doesn't have the MFC DLLs on his or her system. In addition, using MFC to create ActiveX controls forces you into making certain design decisions. For example, if you decide to use MFC to write an ActiveX control, you more or less lock yourself out of using dual interfaces (unless you feel like writing a lot of extra code). Using MFC to create ActiveX controls also means the control and its property pages need to use _IDispatch_ to communicate between themselves.

To avoid the problems described so far, developers can now use ATL to create ActiveX controls. ATL now includes the facilities to create full-fledged ActiveX controls, complete with every feature an ActiveX control should have. These features include incoming interfaces, persistent properties, property pages, and connection points. If you've ever written an ActiveX control using MFC, you'll see how much more flexible using ATL can be.
________________________________________________________________________
7.7.2. - [Using ATL to Write a Control](invcpp5/ch30c.htm)
----------------------------------------------------
 Using ATL to Write a Control 

Using ATL to Write a Control
============================

Although creating an ActiveX control using ATL is actually a pretty straightforward process, using ATL ends up being a bit more burdensome than using MFC. That's because ATL doesn't include all of MFC's amenities. For example, ATL doesn't include device context wrappers. When you draw on a device context, you need to use the raw device context handle. In addition, ClassWizard doesn't understand ATL-based source code, so when you want your control to handle messages, you end up using the "TypingWizard". (That is, you end up typing the message maps in by hand.)

Despite these issues, creating an ActiveX control using ATL is a whole lot easier than creating one from scratch. Also, using ATL gives you a certain amount of flexibility you don't get when you use MFC. For example, while adding dual interfaces to your control is a tedious process with MFC, you get them for free when you use ATL. The ATL COM Object Wizard also makes adding more COM classes (even noncontrol classes) to your project very easy, while adding new controls to an MFC-based DLL is a bit more difficult.

For this chapter's example, we'll represent a small pair of dice as an ATL-based ActiveX control. The dice control will illustrate the most important facets of ActiveX Controls, including control rendering, incoming interfaces, properties, property pages, and events.

Creating the Control
--------------------

As always, the easiest way to create a COM server in ATL is to use the ATL COM Object Wizard. To use the ATL COM Object Wizard, select New from the File menu. Select the Project tab in the New dialog, and highlight the ATL COM AppWizard item. Name the project something clever like _ATLDiceSvr_. As you step through AppWizard, just leave the defaults checked. Doing so will ensure that the server you create is a DLL.

Once the DLL server has been created, perform the following steps:

1.  Select New ATL Object from the Insert menu to insert a new ATL object into the project.
    
2.  In the ATL Object Wizard, select Controls from the Category list and then select Full Control from the Objects list.
    
3.  Click Next to open the ATL Object Wizard Properties dialog. In the Short Name text box on the Names tab, give the control some clever name (like _ATLDiceOb_). The dialog box should look similar to Figure 30-1.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/f30og01x.gif)
    
    **Figure 30-1.** _The ATL Object Wizard Properties dialog box._
    

4.  Select the Attributes tab. Here's where you configure the control. For example, you can
    
    *   Designate the threading model for the control
        
    *   Decide whether the main interface is a dual or custom interface
        
    *   Indicate whether your control supports aggregation
        
    *   Choose whether you want to use COM exceptions and connection points in your control
    
5.  To make your life easier for now, select Support Connection Points. (This will save you some typing later on.) Leave everything else as the default value. Figure 30-2 shows what the Attributes tab on the ATL Object Wizard Properties dialog box looks like now.
    
6.  Select the Miscellaneous tab. Here you have the option of applying some miscellaneous traits to your control. For example, you can give the control behaviors based on regular Microsoft Windows controls such as buttons and edit controls. You might also select other options for your control, such as having your control appear invisible at runtime or giving your control an opaque background. Figure 30-3 shows the available options.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/f30og02x.gif)
    
    **Figure 30-2.** _The Attributes tab on the ATL Object Wizard Properties dialog box._
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/f30og03x.gif)
    
    **Figure 30-3.** _The Miscellaneous control properties tab on the ATL Object Wizard Properties dialog box._
    

7.  Finally, select the Stock Properties tab if you want to give your control some stock properties. Stock properties are those properties that you might expect any control to have, including background colors, border colors, foreground colors, and a caption. Figure 30-4 shows the Stock Properties tab.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/f30og04x.gif)
    
    **Figure 30-4.** _The Stock Properties tab on the ATL Object Wizard Properties dialog box._
    
    8.  When you've finished selecting the attributes for the control, click OK.
    
    The ATL Object Wizard adds a header file and a source file defining the new control. In addition, the ATL Object Wizard sets aside space in the IDL file to hold the control's main interface and assigns a GUID to the interface. Here's the C++ definition of the control produced by the ATL Object Wizard:
    
    class ATL_NO_VTABLE CATLDiceObjj : 
        public CComObjectRootEx<CComSingleThreadModel>,
        public IDispatchImpl<IATLDieceObj, 
                             &IID_IATLDieceObj, 
                             &LIBID_ATLDICESVRLib>,
        public CComControl<CATLDiceObj>,
        public IPersistStreamInitImpl<CATLDiceObj>,
        public IOleControlImpl<CATLDiceObj>,
        public IOleObjectImpl<CATLDiceObj>,
        public IOleInPlaceActiveObjectImpl<CATLDiceObj>,
        public IViewObjectExImpl<CATLDiceObj>,
        public IOleInPlaceObjectWindowlessImpl<CATLDiceObj>,
        public IConnectionPointContainerImpl<CATLDiceObj>,
        public IPersistStorageImpl<CATLDiceObj>,
        public ISpecifyPropertyPagesImpl<CATLDiceObj>,
        public IQuickActivateImpl<CATLDiceObj>,
        public IDataObjectImpl<CATLDiceObj>,
        public IProvideClassInfo2Impl<&CLSID_ATLDiceOb, 
                                     &DIID__DDiceEvents, 
                                     &LIBID_ATLDICESVRLib>,
        public IPropertyNotifySinkCP<CATLDiceObj>,
        public CComCoClass<CATLDiceObj, &CLSID_ATLDiceOb>
    {
    .
    .
    .
    };
    
    That's a pretty long inheritance list. You've already seen the template implementations of _IUnknown_ and support for class objects. They exist in _CComObjectRootEx_ and _CComCoClass_. You've also seen how ATL implements _IDispatch_ within the _IDispatchImpl_ template. However, for a basic control there are about 11 more interfaces required to make everything work. These in- terfaces can be categorized into several areas as shown in the following table.
    
    **Category**
    
    **Interface**
    
    Interfaces for handling self-description
    
    _IProvideClassInfo2_
    
    Interfaces for handling persistence
    
    _IPersistStreamInit  
    IPersistStorage_
    
    Interfaces for handling activation
    
    _IQuickActivate_ (and some of _IOleObject_)
    
    Interfaces from the original OLE Control specification
    
    _IOleControl_
    
    Interfaces from the OLE Document specification
    
    _IOleObject_
    
    Interfaces for rendering
    
    _IOleInPlaceActiveObject  
    IViewObject  
    IOleInPlaceObjectWindowless  
    IDataObject_
    
    Interfaces for helping the container manage property pages
    
    _ISpecifyPropertyPages_
    
    Interfaces for handling connections
    
    _IPropertyNotifySinkCP  
    IConnectionPointContainer_
    
    > NOTE
    > 
    > These are by and large boilerplate interfaces—ones that a COM class must implement to qualify as an ActiveX control. Most of the implementations are standard and vary only slightly (if at all) from one control to the next. The beauty of ATL is that it implements this standard behavior and gives you programmatic hooks where you can plug in your custom code. That way, you don't have to burn your eyes out by looking directly at the COM code. You can live a full and rich life without understanding exactly how these interfaces work. However, if you want to know more about the internal workings of ActiveX Controls, be sure to check out these books: _Inside_ _OLE_ by Kraig Brockschmidt (Microsoft Press, 1995), _ActiveX Controls Inside Out_ by Adam Denning (Microsoft Press, 1997), and _Designing and Using ActiveX Controls_ by Tom Armstrong (IDG Books Worldwide, 1997).
    
    ATL's Control Architecture
    --------------------------
    
    From the highest level, an ActiveX control has two aspects to it: its external state (what it renders on the screen) and its internal state (its properties). Once an ActiveX control is hosted by some sort of container (such as a Microsoft Visual Basic form or an MFC dialog box), it maintains a symbiotic relationship with that container. The client code talks to the control through incoming COM interfaces such as _IDispatch_ and OLE Document interfaces like _IOleObject_ and _IDataObject_.
    
    The control also has the opportunity to talk back to the client. One method of implementing this two-way communication is for the client to implement an _IDispatch_ interface to represent the control's event set. The container maintains a set of properties called ambient properties that the control can use to find out about its host. For instance, a control can camouflage itself within the container because the container makes the information stored in these properties available through a specifically named _IDispatch_ interface. The container can implement an interface named _IPropertyNotifySink_ to find out when the properties within a control might change. Finally, the container implements _IOleClientSite_ and _IOleControlSite_ as part of the control-embedding protocol.
    
    The interfaces listed allow the client and the object to exhibit the behaviors expected of an ActiveX control. We'll tackle some of these interfaces as we go along. The best place to begin looking at ATL-based controls is the _CComControl_ class and its base classes.
    
    ### _CComControl_
    
    You can find the definition of _CComControl_ in Microsoft's ATLCTL.H file under ATL's Include directory. _CComControl_ is a template class that takes a single class parameter:
    
    template <class T>
    class ATL_NO_VTABLE CComControl :  public CComControlBase, 
                                       public CWindowImpl<T>
    {
    .
    .
    .
    };
    
    _CComControl_ is a rather lightweight class that does little by itself—it derives functionality from _CComControlBase_ and _CWindowImpl_. _CComControl_ expects the template parameter to be an ATL-based COM object derived from _CComObjectRootEx_. _CComControl_ requires the template parameter for various reasons, the primary reason being that from time to time the control class uses the template parameter to call back to the control's _InternalQueryInterface_.
    
    _CComControl_ implements several functions that make it easy for the control to call back to the client. For example, _CComControl_ implements a function named _FireOnRequestEdit_ to give controls the ability to tell the client that a specified property is about to change. This function calls back to the client through the client-implemented interface _IPropertyNotifySink_. _FireOnRequestEdit_ notifies all connected _IPropertyNotifySink_ interfaces that the property specified by a certain _DISPID_ is about to change.
    
    _CComControl_ also implements the _FireOnChanged_ function. _FireOnChanged_ is very much like _FireOnRequestEdit_ in that it calls back to the client through the _IPropertyNotifySink_ interface. This function tells the clients of the control (all clients connected to the control through _IPropertyNotifySink_) that a property specified by a certain _DISPID_ has already changed.
    
    In addition to mapping the _IPropertyNotifySink_ interface to some more easily understood functions, _CComControl_ implements a function named _ControlQueryInterface,_ which simply forwards on to the control's _IUnknown_ interface. (This is how you can get a control's _IUnknown_ interface from inside the control.) Finally, _CComControl_ implements a function named _CreateControlWindow_. The default behavior for this function is to call _CWindowImpl::Create_. (Notice that _CComControl_ also derives from _CWindowImpl._) If you want to, you can override this function to do something other than create a single window. For example, you might want to create multiple windows for your control.
    
    Most of the real functionality for _CComControl_ exists within those two other classes—_CComControlBase_ and _CWindowImpl_. Let's take a look at those classes now.
    
    ### _CComControlBase_
    
    _CComControlBase_ is a much more substantial class than _CComControl_. To begin with, _CComControlBase_ maintains all the pointers used by the control to talk back to the client. _CComControlBase_ uses ATL's _CComPtr_ smart pointer to include member variables that wrap the following interfaces implemented for calling back to the client:
    
    *   A wrapper for _IOleInPlaceSite_(_m_spInPlaceSite_)
        
    *   An advise holder for the client's data advise sink (_m_spDataAdviseHolder_)
        
    *   An OLE advise holder for the client's OLE advise sink (_m_spOleAdviseHolder_)
        
    *   A wrapper for _IOleClientSite_ (_m_spClientSite_)
        
    *   A wrapper for _IAdviseSink_ (_m_spAdviseSink_)
        
    
    _CComControlBase_ also uses ATL's _CComDispatchDriver_ to wrap the client's dispatch interface for exposing its ambient properties.
    
    _CComControlBase_ is also where you'll find the member variables that contain the control's sizing and positioning information: _m_sizeNatural_, _m_sizeExtent_, and _m_rcPos_. The other important data member within _CComControlBase_ is the control's window handle. Most ActiveX controls are UI gadgets and as such maintain a window. _CWindowImpl_ and _CWindowImplBase_ handle the windowing aspects of an ATL-based ActiveX control.
    
    ### _CWindowImpl_ and _CWindowImplBase_
    
    _CWindowImpl_ derives from _CWindowImplBase_, which in turn derives from _CWindow_ and _CMessageMap_. As a template class, _CWindowImpl_ takes a single parameter upon instantiation. The template parameter is the control being created. _CWindowImpl_ needs the control type because _CWindowImpl_ calls back to the control during window creation. Let's take a closer look at how ATL handles windowing.
    
    ### ATL Windowing
    
    Just as _CComControl_ is relatively lightweight (most work happens in _CComControlBase_), _CWindowImpl_ is also relatively lightweight. _CWindowImpl_ more or less handles only window creation. In fact, that's the only function explicitly defined by _CWindowImpl_. _CWindowImpl::Create_ creates a new window based on the window class information managed by a class named __ATLWNDCLASSINFO_. There's an ASCII character version and a wide character version.
    
    struct _ATL_WNDCLASSINFOA
    {
        WNDCLASSEXA m_wc;
        LPCSTR m_lpszOrigName;
        WNDPROC pWndProc;
        LPCSTR m_lpszCursorID;
        BOOL m_bSystemCursor;
        ATOM m_atom;
        CHAR m_szAutoName[13];
        ATOM Register(WNDPROC\* p)
        {
            return AtlModuleRegisterWndClassInfoA(&_Module, this, p);
        }
    };
    struct _ATL_WNDCLASSINFOW
    {
        WNDCLASSEXW m_wc;
        LPCWSTR m_lpszOrigName;
        WNDPROC pWndProc;
        LPCWSTR m_lpszCursorID;
        BOOL m_bSystemCursor;
        ATOM m_atom;
        WCHAR m_szAutoName[13];
        ATOM Register(WNDPROC\* p)
        {
            return AtlModuleRegisterWndClassInfoW(&_Module, this, p);
        }
    };
    
    Then ATL uses typedefs to alias this structure to a single class named _CWndClassInfo_:
    
    typedef _ATL_WNDCLASSINFOA CWndClassInfoA;
    typedef _ATL_WNDCLASSINFOW CWndClassInfoW;
    #ifdef UNICODE
    #define CWndClassInfo CWndClassInfoW
    #else
    #define CWndClassInfo CWndClassInfoA
    #endif 
    
    _CWindowImpl_ uses a macro named _DECLARE_WND_CLASS_ to add window class information to a _CWindowImpl_\-derived class. _DECLARE_WND_CLASS_ also adds a function named _GetWndClassInfo_. Here's the _DECLARE_WND_CLASS_ macro:
    
    #define DECLARE_WND_CLASS(WndClassName) \
    static CWndClassInfo& GetWndClassInfo() \
    { \
        static CWndClassInfo wc = \
        { \
            { sizeof(WNDCLASSEX), CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS,\ 
              StartWindowProc, \
              0, 0, NULL, NULL, NULL, (HBRUSH)(COLOR_WINDOW + 1), \
              NULL, WndClassName, NULL }, \
              NULL, NULL, IDC_ARROW, TRUE, 0, _T("") \
        }; \
        return wc; \
    } 
    
    This macro expands to provide a _CWndClassInfo_ structure for the control class. Because _CWndClassInfo_ manages the information for a single window class, each window created through a specific instance of _CWindowImpl_ will be based on the same window class.
    
    _CWindowImpl_ derives from _CWindowImplBaseT. CWindowImplBaseT_ derives from _CWindowImplRoot_, which is specialized around the _CWindow_ class and the _CControlWinTraits_ classes like this:
    
    template <class TBase = CWindow, 
              class TWinTraits = CControlWinTraits>
    class ATL_NO_VTABLE CWindowImplBaseT : 
        public CWindowImplRoot< TBase >
    {
    public:
    .
    .
    .
    };
    
    _CWindowImplRoot_ derives from _CWindow_ (by default) and _CMessageMap_. _CWindowImplBaseT_ manages the window procedure of a _CWindowImpl_\-derived class. _CWindow_ is a lightweight class that wraps window handles in the same way (but not as extensively) as MFC's _CWnd_ class. _CMessageMap_ is a tiny class that defines a single pure virtual function named _ProcessWindowMessage_. ATL-based message-mapping machinery assumes this function is available, so ATL-based classes that want to use message maps need to derive from _CMessageMap_. Let's take a quick look at ATL message maps.
    
    ### ATL Message Maps
    
    The root of ATL's message mapping machinery lies within the _CMessageMap_ class. ATL-based controls expose message maps by virtue of indirectly deriving from _CWindowImplBase_. In MFC, by contrast, deriving from _CCmdTarget_ enables message mapping. However, just as in MFC, it's not enough to derive from a class that supports message maps. The message maps actually have to be there—and those message maps are implemented via macros.
    
    To implement a message map in an ATL-based control, use message map macros. First ATL's _BEGIN_MSG_MAP_ macro goes into the control class's header file. _BEGIN_MSG_MAP_ marks the beginning of the default message map. _CWindowImpl::WindowProc_ uses this default message map to process messages sent to the window. The message map directs messages either to the appropriate handler function or to another message map. ATL defines another macro named _END_MSG_MAP_ to mark the end of a message map. Between _BEGIN_MSG_MAP_ and _END_MSG_MAP_ lie some other macros for mapping window messages to member functions in the control. For example, here's a typical message map you might find in an ATL-based control:
    
    BEGIN_MSG_MAP(CAFullControl)
        CHAIN_MSG_MAP(CComControl<CAFullControl>)
        DEFAULT_REFLECTION_HANDLER()
        MESSAGE_HANDLER(WM_TIMER, OnTimer);
        MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButton);
    END_MSG_MAP()
    
    This message map delegates most of the message processing to the control through the _CHAIN_MSG_MAP_ macro and handles message reflection through the _DEFAULT_REFLECTION_HANDLER_ macro. The message map also handles two window messages explicitly: WM_TIMER and WM_LBUTTONDOWN. These are standard window messages that are mapped using the _MESSAGE_HANDLER_ macro. The macros simply produce a table relating window messages to member functions in the class. In addition to regular messages, message maps are capable of handling other sorts of events. Here's a rundown of the kinds of macros that can go in a message map.
    
    **Macro**
    
    **Description**
    
    _MESSAGE_HANDLER_
    
    Maps a Windows message to a handler function
    
    _MESSAGE_RANGE_HANDLER_
    
    Maps a contiguous range of Windows messages to a handler function
    
    _COMMAND_HANDLER_
    
    Maps a WM_COMMAND message to a handler function, based on the identifier and the notification code of the menu item, control, or accelerator
    
    _COMMAND_ID_HANDLER_
    
    Maps a WM_COMMAND message to a handler function, based on the identifier of the menu item, control, or accelerator
    
    _COMMAND_CODE_HANDLER_
    
    Maps a WM_COMMAND message to a handler function, based on the notification code
    
    _COMMAND_RANGE_HANDLER_
    
    Maps a contiguous range of WM_COMMAND messages to a handler function, based on the identifier of the menu item, control, or accelerator
    
    _NOTIFY_HANDLER_
    
    Maps a WM_NOTIFY message to a handler function, based on the notification code and the control identifier
    
    _NOTIFY_ID_HANDLER_
    
    Maps a WM_NOTIFY message to a handler function, based on the control identifier
    
    _NOTIFY_CODE_HANDLER_
    
    Maps a WM_NOTIFY message to a handler function, based on the notification code
    
    _NOTIFY_RANGE_HANDLER_
    
    Maps a contiguous range of WM_NOTIFY messages to a handler function, based on the control identifier
    
    Handling messages within ATL works much the same as in MFC. ATL includes a single window procedure through which messages are routed. Technically, you can build your controls effectively without understanding everything about ATL's control architecture. However, this knowledge is sometimes helpful as you develop a control, and it's even more useful when debugging a control.
    
    Developing the Control
    ----------------------
    
    Once the control is inserted into the server, you need to add some code to make the control do something. If you were to compile and load ATL's default control into a container, the results wouldn't be particularly interesting. You'd simply see a blank rectangle with the string "ATL 3.0 : ATLDiceOb." You'll want to add code to render the control, to represent the internal state of the control, to respond to events, and to generate events to send back to the container.
    
    ### Deciding What to Draw
    
    A good place to start working on a control is on its drawing code—you get instant gratification that way. This is a control that is visually represented by a couple of dice. The easiest way to render to the dice control is to draw bitmaps representing each of the six possible dice sides and then show the bitmaps on the screen. This implies that the dice control will maintain some variables to represent its state. For example, the control needs to manage the bitmaps for representing the dice as well as two numbers representing the first value shown by each die. Here is the code from ATLDICEOBJ.H that represents the state of the dice:
    
        #define MAX_DIEFACES 6
    
        HBITMAP m_dieBitmaps[MAX_DIEFACES];
        unsigned short m_nFirstDieValue;
        unsigned short m_nSecondDieValue;
    
    Before diving headfirst into the control's drawing code, you need to do a bit of preliminary work—the bitmaps need to be loaded. Presumably each die rendered by the dice control will show any one of six dice faces, so the control needs one bitmap for each face. Figure 30-5 shows what one of the dice bitmaps looks like.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/f30og05.gif)
    
    **Figure 30-5.** _A bitmap for the dice control._
    
    If you draw the bitmaps one at a time, they'll have sequential identifiers in the resource.h file. Giving the bitmaps sequential identifiers will make them easier to load. Otherwise, you might need to modify the resource.h file, which contains the following identifiers:
    
    #define IDB_DICE1                       207
    #define IDB_DICE2                       208
    #define IDB_DICE3                       209
    #define IDB_DICE4                       210
    #define IDB_DICE5                       211
    #define IDB_DICE6                       212
    
    Loading bitmaps is fairly straightforward. Cycle through the bitmap array, and load the bitmap resources. When they're stored in an array like this, grabbing the bitmap out of the array and showing it is much easier than if you didn't use an array. Here is the function that loads the bitmaps into the array:
    
    BOOL CATLDiceObj::LoadBitmaps() {
        BOOL bSuccess = TRUE;
    
        for(int i=0; i<MAX_DIEFACES; i++) {
            DeleteObject(m_dieBitmaps[i]);
            m_dieBitmaps[i] = LoadBitmap(_Module.m_hInst, 
                                         MAKEINTRESOURCE(IDB_DICE1+i));
            if(!m_dieBitmaps[i]) {
                ::MessageBox(NULL, 
                             "Failed to load bitmaps",
                             NULL, 
                             MB_OK);
                bSuccess = FALSE;
            } 
        }
        return bSuccess;
    }
    
    The best place to call _LoadBitmaps_ is from within the control's constructor, as shown in the following code. To simulate a random roll of the dice, set the control's state so that the first and second die values are random numbers between 0 and 5 (these numbers will be used when the dice control is drawn):
    
    class CATLDiceObj : // big inheritance list {
        CATLDiceObj () {
            LoadBitmaps();
            srand((unsigned)time(NULL));      
            m_nFirstDieValue = (rand() % (MAX_DIEFACES)) + 1;
            m_nSecondDieValue = (rand() % (MAX_DIEFACES)) + 1;
        }
    
    Once the bitmaps are loaded, you'll want to render them. The dice control should include a function for showing each die face based on the current internal state of the dice. Here's where you first encounter ATL's drawing machinery.
    
    One of the most convenient things about ATL-based controls (and MFC-based controls) is that all the drawing code happens in one place: within the control's _OnDraw_ function. _OnDraw_ is a virtual function of _COleControlBase_. Here's _OnDraw_'s signature:
    
    virtual HRESULT OnDraw(ATL_DRAWINFO& di);
    
    _OnDraw_ takes a single parameter: a pointer to an _ATL_DRAWINFO_ structure. Among other things, the _ATL_DRAWINFO_ structure contains a device context on which to render your control. Here's the _ATL_DRAWINFO_ structure:
    
    struct ATL_DRAWINFO {
        UINT cbSize;
        DWORD dwDrawAspect;
        LONG lindex;
        DVTARGETDEVICE\* ptd;
        HDC hicTargetDev; 
        HDC hdcDraw;
        LPCRECTL prcBounds; //Rectangle in which to draw
        LPCRECTL prcWBounds; //WindowOrg and Ext if metafile
        BOOL bOptimize;
        BOOL bZoomed;
        BOOL bRectInHimetric;
        SIZEL ZoomNum;      //ZoomX = ZoomNum.cx/ZoomNum.cy
        SIZEL ZoomDen;
    };
    
    As you can see, there's a lot more information here than a simple device context. While you can count on the framework filling it out correctly for you, it's good to know where the information in the structure comes from and how it fits into the picture.
    
    ActiveX Controls are interesting because they are drawn in two contexts. The first and most obvious context is when the control is active and it draws within the actual drawing space of the client. The other, less-obvious context in which controls are drawn is during design time (as when an ActiveX control resides in a Visual Basic form in design mode). In the first context, ActiveX Controls render themselves to a live screen device context. In the second context, ActiveX Controls render themselves to a metafile device context.
    
    Many (though not all) ATL-based controls are composed of at least one window. So ActiveX Controls need to render themselves during the WM_PAINT message. Once the control receives the WM_PAINT message, the message routing architecture passes control to _CComControlBase::OnPaint._ (Remember, _CComControlBase_ is one of the control's base classes.) _CComControlBase::OnPaint_ performs several steps. The function begins by creating a painting device context (using _BeginPaint_). Then _OnPaint_ creates an _ATL_DRAWINFO_ structure on the stack and initializes the fields within the structure. _OnPaint_ sets up _ATL_DRAWINFO_ to show the entire content (the _dwDrawAspect_ field is set to _DVASPECT_CONTENT_). _OnPaint_ also sets the _lindex_ field to _1, sets the drawing device context to the newly created painting device context, and sets up the bounding rectangle to be the client area of the control's window. Then _OnPaint_ goes on to call _OnDrawAdvanced_.
    
    The default _OnDrawAdvanced_ function prepares a normalized device context for drawing. You can override this method if you want to use the device context passed by the container without normalizing it. ATL then calls your control class's _OnDraw_ method.
    
    The second context in which the _OnDraw_ function is called is when the control draws on to a metafile. The control draws itself on to a metafile whenever someone calls _IViewObjectEx::Draw._ (_IViewObjectEx_ is one of the interfaces implemented by the ActiveX control.) ATL implements the _IViewObjectEx_ interface through the template class _IViewObjectExImpl_. _IViewObjectEx- Impl::Draw_ is called whenever the control needs to take a snapshot of its presentation space for the container to store. In this case, the container creates a metafile device context and hands it to the control. _IViewObjectExImpl_ puts an _ATL_DRAWINFO_ structure on the stack and initializes. The bounding rectangle, the index, the drawing aspect, and the device contexts are all passed in as parameters by the client. The rest of the drawing is the same in this case—the control calls _OnDrawAdvanced_, which in turn calls your version of _OnDraw_.
    
    Once you're armed with this knowledge, writing functions to render the bitmaps becomes fairly straightforward. To show the first die face, create a memory-based device context, select the object into the device context, and _BitBlt_ the memory device context into the real device context. Here's the code:
    
    void CATLDiceObj::ShowFirstDieFace(ATL_DRAWINFO& di) {
    
        BITMAP bmInfo;
        GetObject(m_dieBitmaps[m_nFirstDieValue-1],
                              sizeof(bmInfo), &bmInfo);
    
        SIZE size;
    
        size.cx = bmInfo.bmWidth;
        size.cy = bmInfo.bmHeight;
    
        HDC hMemDC;
        hMemDC = CreateCompatibleDC(di.hdcDraw);
    
        HBITMAP hOldBitmap;
        HBITMAP hbm = m_dieBitmaps[m_nFirstDieValue-1];
        hOldBitmap = (HBITMAP)SelectObject(hMemDC, hbm); 
    
        if (hOldBitmap == NULL)
            return;     // destructors will clean up
    
        BitBlt(di.hdcDraw,
               di.prcBounds->left+1,
               di.prcBounds->top+1,
               size.cx,
               size.cy,
               hMemDC, 0,
               0,
               SRCCOPY);
    
        SelectObject(di.hdcDraw, hOldBitmap);
        DeleteDC(hMemDC);
    }
    
    Showing the second die face is more or less the same process—just make sure that the dice are represented separately. For example, you probably want to change the call to _BitBlt_ so that the two dice bitmaps are shown side by side.
    
    void CATLDiceObj::ShowSecondDieFace(ATL_DRAWINFO& di) {
        // 
        // This code is exactly the same as ShowFirstDieFace
        //  except the second die is positioned next to the first die.
        //
        BitBlt(di.hdcDraw,
               di.prcBounds->left+size.cx + 2,
               di.prcBounds->top+1,
               size.cx,
               size.cy,
               hMemDC, 0,
               0, SRCCOPY);
        // The rest is the same as in ShowFirstDieFace
    }
    
    The last step is to call these two functions whenever the control is asked to render itself—during the control's _OnDraw_ function. _ShowFirstDieFace_ and _ShowSecondDieFace_ will show the correct bitmap based on the state of _m_nFirstDieValue_ and _m_nSecondDieValue_:
    
    HRESULT CATLDiceObj::OnDraw(ATL_DRAWINFO& di) {
        ShowFirstDieFace(di);
        ShowSecondDieFace(di);
        return S_OK;
    }
    
    At this point, if you compile and load this control into some ActiveX Control container (like a Visual Basic form or an MFC-based dialog), you'll see two die faces staring back at you. Now it's time to add some code to enliven the control and roll the dice.
    
    ### Responding to Window Messages
    
    Just looking at two dice faces isn't that much fun. You want to make the dice work. A good way to get the dice to appear to jiggle is to use a timer to generate events and then respond to the timer by showing a new pair of dice faces. Setting up a Windows timer in the control means adding a function to handle the timer message and adding a macro to the control's message map. Start by using ClassView to add a handler for WM_TIMER. Right-click on the CAtlDiceOb symbol in ClassView, and select Add Windows Message Handler from the context menu. This adds a prototype for the _OnTimer_ function and an entry into the message map to handle the WM_TIMER message. Add some code to the _OnTimer_ function to handle the WM_TIMER message. The _OnTimer_ function should look like the code shown below.
    
    LRESULT CATLDiceObj::OnTimer(UINT msg, WPARAM wParam, 
                                LPARAM lParam, BOOL& bHandled) {
    
        if(m_nTimesRolled > 15) {
    
            m_nTimesRolled = 0;
            KillTimer(1);
        } else {
            m_nFirstDieValue = (rand() % (MAX_DIEFACES)) + 1;
            m_nSecondDieValue = (rand() % (MAX_DIEFACES)) + 1;
            FireViewChange();
            m_nTimesRolled++;
        }
        bHandled = TRUE;
        return 0;
    }
    
    This function responds to the timer message by generating two random numbers, setting up the control's state to reflect these two new numbers, and then asking the control to refresh itself by calling _FireViewChange_. Notice the function kills the timer as soon as the dice have rolled a certain number of times. Also notice that the message handler tells the framework that it successfully handled the function by setting the _bHandled_ variable to TRUE.
    
    Notice there's an entry for WM_TIMER in the control's message map. Because WM_TIMER is just a plain vanilla window message, it's represented with a standard _MESSAGE_HANDLER_ macro as follows:
    
    BEGIN_MSG_MAP(CATLDiceObj)
        CHAIN_MSG_MAP(CComControl<CATLDiceObj>)
        DEFAULT_REFLECTION_HANDLER()
        **MESSAGE_HANDLER(WM_TIMER, OnTimer);**
    END_MSG_MAP()
    
    As you can tell from this message map, the dice control already handles the gamut of Windows messages through the _CHAIN_MSG_MAP_ macro. However, now the pair of dice has the ability to simulate rolling by responding to the timer message. Setting a timer causes the control to repaint itself with a new pair of dice numbers every quarter of a second or so. Of course, there needs to be some way to start the dice rolling. Because this is an ActiveX control, it's reasonable to allow client code to start rolling the dice via a call to a function in one of its incoming interfaces. Use ClassView to add a _RollDice_ function to the main interface. Do this by right-clicking on the _IATLDiceObj_ interface appearing in ClassView on the left side of the screen and selecting Add Method from the pop up menu. Then add a _RollDice_ function. Microsoft Visual C++ adds a function named _RollDice_ to your control. Implement _RollDice_ by setting the timer for a reasonably short interval and then returning S_OK. Add the following boldface code:
    
    STDMETHODIMP CATLDiceObj::RollDice()
    {
        **SetTimer(1, 250);**
        return S_OK;
    }
    
    If you load the dice into an ActiveX control container, you'll now be able to browse and call the control's methods and roll the dice.
    
    In addition to using the incoming interface to roll the dice, the user might reasonably expect to roll the dice by double-clicking the control. To enable this behavior, just add a message handler to trap the mouse-button-down message by adding a function to handle a left-mouse double click.
    
    LRESULT CATLDiceObj::OnLButtonDblClick(UINT uMsg, 
                                          WPARAM wParam, 
                                          LPARAM lParam, 
                                          BOOL& bHandled) {
        RollDice();
        bHandled = TRUE;
        return 0;
    }
    
    Then be sure you add an entry to the message map to handle the WM_LBUTTONDOWN message:
    
    BEGIN_MSG_MAP(CATLDiceObj)
        // Other message handlers
        MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDblClick)
    END_MSG_MAP()
    
    When you load the dice control into a container and double-click on it, you should see the dice roll. Now that you've added rendering code and given the control the ability to roll, it's time to add some properties.
    
    ### Adding Properties and Property Pages
    
    You've just seen that ActiveX controls have an external presentation state. (The presentation state is the state reflected when the control draws itself.) In addition, most ActiveX controls also have an internal state. The control's internal state is a set of variables exposed to the outside world via interface functions. These internal variables are also known as properties.
    
    For example, imagine a simple grid implemented as an ActiveX control. The grid has an external presentation state and a set of internal variables for describing the state of the grid. The properties of a grid control would probably include the number of rows in the grid, the number of columns in the grid, the color of the lines composing the grid, the type of font used, and so forth.
    
    As you saw in [Chapter 29](ch29a.htm), adding properties to an ATL-based class means adding member variables to the class and then using ClassWizard to create _get_ and _put_ functions to access these properties. For example, two member variables that you might add to the dice control include the dice color and the number of times the dice are supposed to roll before stopping. Those two properties could easily be represented as a pair of short integers as shown here:
    
    class ATL_NO_VTABLE CATLDiceObj : 
    .
    .
    .
    {
        .
        .
        .
        short m_nDiceColor;
        short m_nTimesToRoll; 
        .
        .
        .
    };
    
    To make these properties accessible to the client, you need to add _get_ and _put_ functions to the control. Right-clicking on the interface symbol in ClassView brings up a context menu, giving you a choice to Add Property, which will present you with the option of adding these functions. Adding DiceColor and TimesToRoll properties to the control using ClassView will add four new functions to the control_: get_DiceColor, put_DiceColor, get_TimesToRoll,_ and _put_TimesToRoll_.
    
    The _get_DiceColor_ function should retrieve the state of _m_nDiceColor_:
    
    STDMETHODIMP CATLDiceObj::get_DiceColor(short \* pVal)
    {
        **\*pVal = m_nDiceColor;**
        return S_OK;
    }
    
    To make the control interesting, _put_DiceColor_ should change the colors of the dice bitmaps and redraw the control immediately. This example uses red and blue dice as well as the original black and white dice. To make the control show the new color bitmaps immediately after the client sets the dice color, the _put_DiceColor_ function should load the new bitmaps according to new color, and redraw the control:
    
    STDMETHODIMP CATLDiceObj::put_DiceColor(short newVal)
    {
        **if(newVal < 3 && newVal >= 0)
            m_nDiceColor = newVal;
        LoadBitmaps();
        FireViewChange();**
        return S_OK;
    }
    
    Of course, this means that _LoadBitmaps_ needs to load the bitmaps based on the state of _m_nDiceColor_, so we need to add the following boldface code to our existing _LoadBitmaps_ function:
    
    BOOL CATLDiceObj::LoadBitmaps() {
        **int i;**
        BOOL bSuccess = TRUE;
        **int nID = IDB_DICE1;
    
        switch(m_nDiceColor) {
            case 0:
                nID = IDB_DICE1;
                break;
    
            case 1:
                nID = IDB_BLUEDICE1;
                break;
    
            case 2:
                nID = IDB_REDDICE1;
                break;
    
        }**
    
        for(i=0; i<MAX_DIEFACES; i++) {
            DeleteObject(m_dieBitmaps[i]);
            m_dieBitmaps[i] = LoadBitmap(_Module.m_hInst, 
                                         MAKEINTRESOURCE(**nID**+i));
            if(!m_dieBitmaps[i]) {
                ::MessageBox(NULL, 
                             "Failed to load bitmaps",
                             NULL, MB_OK);
                bSuccess = FALSE;
            } 
        }
        return bSuccess;
    }
    
    Just as the dice color property reflects the color of the dice, the number of times the dice rolls should be reflected by the state of the TimesToRoll property. The _get_TimesToRoll_ function needs to read the _m_nTimesToRoll_ member, and the _put_TimesToRoll_ function needs to modify _m_nTimesToRoll_. Add boldface code shown below.
    
    STDMETHODIMP CATLDiceObj::get_TimesToRoll(short \* pVal)
    {
        **\*pVal = m_nTimesToRoll;**
        return S_OK;
    }
    
    STDMETHODIMP CATLDiceObj::put_TimesToRoll(short newVal)
    {
        **m_nTimesToRoll = newVal;**
        return S_OK;
    }
    
    Finally, instead of hard-coding the number of times the dice rolls, use the _m_nTimesToRoll_ variable to determine when to kill the timer.
    
    LRESULT CATLDiceObj::OnTimer(UINT msg, WPARAM wParam, 
                                LPARAM lParam, BOOL& bHandled) {
    
        if(m_nTimesRolled > m_nTimesToRoll) {
            m_nTimesRolled = 0;
            KillTimer(1);
            **Fire_DiceRolled(m_nFirstDieValue, m_nSecondDieValue);
            if(m_nFirstDieValue == m_nSecondDieValue)
                Fire_Doubles(m_nFirstDieValue);
            if(m_nFirstDieValue == 1 && m_nSecondDieValue == 1)
                Fire_SnakeEyes();**
        } else {
            m_nFirstDieValue = (rand() % (MAX_DIEFACES)) + 1;
            m_nSecondDieValue = (rand() % (MAX_DIEFACES)) + 1;            
            FireViewChange();
            m_nTimesRolled++;
        }
    
        bHandled = TRUE;
        return 0;
    }
    
    Now these two properties are exposed to the outside world. When the client code changes the color of the dice, the control loads a new set of bitmaps and redraws the control with the new dice faces. When the client code changes the number of times to roll, the dice control uses that information to determine the number of times the dice control should respond to the WM_TIMER message. So the next question is, "How are these properties accessed by the client code?" One way is through a control's property pages.
    
    ### Property Pages
    
    Since ActiveX controls are usually UI gadgets meant to be mixed into much larger applications, they often find their homes within places such as Visual Basic forms and MFC form views and dialogs. When a control is instantiated, the client code can usually reach into the control and manipulate its properties by calling certain functions on the control's incoming interface functions. However, when an ActiveX control is in design mode, accessing the properties through the interface functions isn't always practical. It would be unkind to tool developers to force them to go through the interface functions all the time just to tweak some properties in the control. Why should the tool vendor who is creating the client have to provide UI for managing control properties? That's what property pages are for. Property pages are sets of dialogs implemented by the control for manipulating properties. That way, the tool vendors don't have to keep re-creating dialog boxes for tweaking the properties of an ActiveX control.
    
    **How Property Pages Are Used** Property pages are usually used in one of two ways. The first way is through the control's _IOleObject_ interface. The client can call _IOleObject_'s _DoVerb_ function, passing in the properties verb identifier (named _OLEIVERB_PROPERTIES_ and defined as the number -7) to ask the control to show its property pages. The control then displays a dialog, or property frame, that contains all the control's property pages. For example, Figure 30-6 shows the Property Pages dialog containing the property pages for the Microsoft FlexGrid 6.0 control.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/f30og06x.gif)
    
    **Figure 30-6.** _The Microsoft FlexGrid 6.0 control executing the properties verb._
    
    Property pages are a testament to the power of COM. As it turns out, each single property page is a separate COM object (named using a GUID and registered like all the other COM classes on your system). When a client asks an ActiveX control to show its property pages via the properties verb, the control passes its own list of property page GUIDs into a system API function named _OleCreatePropertyFrame._ _OleCreatePropertyFrame_ enumerates the property page GUIDs, calling _CoCreateInstance_ for each property page. The property frame gets a copy of an interface so that the frame can change the properties within the control. _OleCreatePropertyFrame_ calls back to the control when the user clicks the OK or Apply button.
    
    The second way clients use property pages is when the client asks the control for a list of property page GUIDs. Then the client calls _CoCreateInstance_ on each property page and installs each property page in its own frame. Figure 30-7 shows an example of how Visual C++ uses the Microsoft FlexGrid property pages in its own property dialog frame.
    
    This second method is by far the most common way for a control's property pages to be used. Notice that the property sheet in Figure 30-7 contains a General tab in addition to the control's property pages, and that the General tab shown in Figure 30-6 has been renamed to the Control tab. The General property page in Figure 30-7 belongs to Visual C++. The Control, Style, Font, Color, and Picture property pages belong to the control (even though they're being shown within the context of Visual C++).
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/f30og07x.gif)
    
    **Figure 30-7.** _Microsoft Visual C++ inserting the Microsoft FlexGrid 6.0 property pages into its own dialog box for editing resource properties._
    
    For a property page to work correctly, the control that the property page is associated with needs to implement _ISpecifyPropertyPages_ and the property page object needs to implement an interface named _IPropertyPage_. With this in mind, let's examine exactly how ATL implements property pages.
    
    **Adding a Property Page to Your Control** You can use the Visual Studio ATL Object Wizard to create property pages in your ATL project. To create a property page, perform the following steps:
    
    1.  Select New ATL Object from the Visual C++ Insert menu.
        
    2.  From the ATL Object Wizard dialog, select Controls from the Category list.
        
    3.  Select Property Page from the Objects list.
        
    4.  Click Next.
        
    5.  Fill in the required information on the ATL Object Wizard Properties dialog, and click OK.
        
    
    ATL's Object Wizard generates a dialog template and includes it as part of a control's resources. In the dice control example, the two properties you're concerned with are the color of the dice and the number of times to roll the dice. The dialog template created by ATL's Object Wizard is blank, so you'll want to add a couple of controls to represent these properties. In this example, the user will be able to select the dice color from a combo box and enter the number of times the dice should roll in an edit control, as shown in Figure 30-8.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/F30OG08.GIF)
    
    **Figure 30-8.** _The property page dialog template._
    
    The ATL Object Wizard also creates a C++ class for you that implements the interface necessary for the class to behave as a property page. In addition to generating this C++ class, the ATL Object Wizard makes the class part of the project. The ATL Object Wizard adds the new property page class to the IDL file within the coclass section. In addition, the ATL Object Wizard appends the property page to the object map so that _DllGetClassObject_ can find the property page class. Finally, the ATL Object Wizard adds a new Registry script (so that the DLL makes the correct Registry entries when the control is registered). Here is the header file created by the ATL Object Wizard for a property page named DiceMainPropPage:
    
    #include "resource.h"       // main symbols
    
    class ATL_NO_VTABLE CDiceMainPropPage :
        public CComObjectRootEx<CComSingleThreadModel>,
        public CComCoClass<CDiceMainPropPage, &CLSID_DiceMainPropPage>,
        public IPropertyPageImpl<CDiceMainPropPage>,
        public CDialogImpl<CDiceMainPropPage>
    {
    public:
        CDiceMainPropPage() 
        {
            m_dwTitleID = IDS_TITLEDiceMainPropPage;
            m_dwHelpFileID = IDS_HELPFILEDiceMainPropPage;
            m_dwDocStringID = IDS_DOCSTRINGDiceMainPropPage;
        }
    
        enum {IDD = IDD_DICEMAINPROPPAGE};
    
    DECLARE_REGISTRY_RESOURCEID(IDR_DICEMAINPROPPAGE)
    
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    
    BEGIN_COM_MAP(CDiceMainPropPage) 
        COM_INTERFACE_ENTRY(IPropertyPage)
    END_COM_MAP()
    
    BEGIN_MSG_MAP(CDiceMainPropPage)
        CHAIN_MSG_MAP(IPropertyPageImpl<CDiceMainPropPage>)
    END_MSG_MAP()
    
    STDMETHOD(Apply)(void)
    {
        ATLTRACE(_T("CDiceMainPropPage::Apply\n"));
        for (UINT i = 0; i < m_nObjects; i++)
        {
            // Do something interesting here
            // ICircCtl\* pCirc;
            // m_ppUnk[i]->QueryInterface(IID_ICircCtl, (void\*\*)&pCirc);
            // pCirc->put_Caption(CComBSTR("something special"));
            // pCirc->Release();
        }
        m_bDirty = FALSE;
        return S_OK;
    }
    };
    
    Examining this property page listing reveals that ATL's property page classes are composed of several ATL templates: _CComObjectRootEx_ (to implement _IUnknown_), _CComCoClass_ (the class object for the property page), _IPropertyPageImpl_ (for implementing _IPropertyPage_), and _CDialogImpl_ (for implementing the dialog-specific behavior).
    
    As with most other COM classes created by ATL's Object Wizard, most of the code involved in getting a property page to work is boilerplate code. Notice that besides the constructor and some various maps, the only other function is one named _Apply_.
    
    Before getting into the mechanics of implementing a property page, it's helpful to take a moment to understand how the property page architecture works. The code you need to type in to get the property pages working will then make more sense.
    
    When the client decides it's time to show some property pages, a modal dialog frame needs to be constructed. The frame is constructed by either the client or by the control itself. If the property pages are being shown via the _DoVerb_ function, the control constructs the frame. If the property pages are being shown within the context of another application—as when Visual C++ shows the control's property pages within the IDE—the client constructs the dialog frame. The key to the dialog frame is that it holds property page sites (small objects that implement _IPropertyPageSite_) for each property page.
    
    The client code (the modal dialog frame, in this case) then enumerates through a list of GUIDs, calling _CoCreateInstance_ on each one of them and asking for the _IPropertyPage_ interface. If the COM object produced by _CoCreateInstance_ is a property page, it implements the _IPropertyPage_ interface. The dialog frame uses the _IPropertyPage_ interface to talk to the property page. Here's the declaration of the _IPropertyPage_ interface:
    
    interface IPropertyPage : public IUnknown {
        HRESULT SetPageSite(IPropertyPageSite \*pPageSite) = 0;
        HRESULT Activate(HWND hWndParent,
                         LPCRECT pRect,
                         BOOL bModal) = 0;
        HRESULT Deactivate( void) = 0;
        HRESULT GetPageInfo(PROPPAGEINFO \*pPageInfo) = 0;
        HRESULT SetObjects(ULONG cObjects,
                           IUnknown \*\*ppUnk) = 0;
        HRESULT Show(UINT nCmdShow) = 0;
        HRESULT Move(LPCRECT pRect) = 0;
        HRESULT IsPageDirty( void) = 0;
        HRESULT Apply( void) = 0;
        HRESULT Help(LPCOLESTR pszHelpDir) = 0;
        HRESULT TranslateAccelerator(MSG \*pMsg) = 0;
    };
    
    Once a property page has been created, the property page and the client code need some channels to communicate back and forth with the control. After the property dialog frame successfully calls _QueryInterface_ for _IPropertyPage_ on the property page objects, the frame calls _IPropertyPage::SetPageSite_ on each _IPropertyPage_ interface pointer it holds, passing in an _IPropertyPageSite_ interface pointer. The property page sites within the property frame provide a way for each property page to call back to the frame. The property page site provides information to the property page and receives notifications from the page when changes occur. Here's the _IPropertyPageSite_ interface:
    
    interface IPropertyPageSite : public IUnknown {
        public:
            virtual HRESULT OnStatusChange(DWORD dwFlags) = 0;
            virtual HRESULT GetLocaleID(LCID \*pLocaleID) = 0;
            virtual HRESULT GetPageContainer(IUnknown \*ppUnk) = 0;
            virtual HRESULT TranslateAccelerator(MSG \*pMsg) = 0;
    };
    
    In addition to the frame and control connecting to each other through _IPropertyPage_ and _IPropertyPageSite_, each property page needs a way to talk back to the control. This is usually done when the dialog frame calls _IPropertyPage::SetObjects_, passing in the control's _IUnknown_. Figure 30-9 illustrates the property page architecture.
    
    Now that you see how ActiveX Control property pages work in general, understanding how they work within ATL will be a lot easier. You'll see how ATL's property pages work—in cases when the client code exercises the control's properties verb as well as in cases when environments like Visual C++ integrate a control's property pages into the IDE.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/F30OG09.JPG)
    
    **Figure 30-9.** _How the property pages, the property frame, and the property page sites communicate._
    
    **ATL and the Properties Verb** The first way in which an ActiveX control shows its property pages is when the client invokes the properties verb by calling _IOleObject::DoVerb_ using the constant _OLEIVERB_PROPERTIES_. When the client calls _DoVerb_ in an ATL-based control, the call ends up in the function _CComControlBase::DoVerbProperties,_ which simply calls _OleCreatePropertyFrame_, passing in its own _IUnknown_ pointer and the list of property page GUIDs. _OleCreatePropertyFrame_ takes the list of GUIDs, calling _CoCreateInstance_ on each one to create the property pages, and arranges them within the dialog frame. _OleCreatePropertyFrame_ uses each property page's _IPropertyPage_ interface to manage the property page, as described in "[How Property Pages Are Used](#100)"
    
    **ATL Property Maps** Of course, understanding how _OleCreatePropertyFrame_ works from within the ATL-based control begs the next question: where does the list of property pages actually come from? ATL uses macros to generate lists of property pages called property maps. Whenever you add a new property page to an ATL-based control, you need to set up the list of property pages through these macros. ATL includes several macros for implementing property maps: _BEGIN_PROPERTY_MAP_, _PROP_ENTRY_, _PROP_ENTRY_EX_, _PROP_PAGE_, and _END_PROPERTY_MAP_. Here are those macros in the raw:
    
    struct ATL_PROPMAP_ENTRY
    {
        LPCOLESTR szDesc;
        DISPID dispid;
        const CLSID\* pclsidPropPage;
        const IID\* piidDispatch;
        DWORD dwOffsetData;
        DWORD dwSizeData;
        VARTYPE vt;
    };
    
    #define BEGIN_PROPERTY_MAP(theClass) \
        typedef _ATL_PROP_NOTIFY_EVENT_CLASS __ATL_PROP_NOTIFY_EVENT_CLASS; \
            typedef theClass _PropMapClass; \
        static ATL_PROPMAP_ENTRY\* GetPropertyMap()\
        {\
            static ATL_PROPMAP_ENTRY pPropMap[] = \
        {
    
    #define PROP_PAGE(clsid) \
        {NULL, NULL, &clsid, &IID_NULL},
    
    #define PROP_ENTRY(szDesc, dispid, clsid) \
        {OLESTR(szDesc), dispid, &clsid, &IID_IDispatch},
    
    #define PROP_ENTRY_EX(szDesc, dispid, clsid, iidDispatch) \
        {OLESTR(szDesc), dispid, &clsid, &iidDispatch},
    
    #define END_PROPERTY_MAP() \
            {NULL, 0, NULL, &IID_NULL} \
        }; \
        return pPropMap; \
    }
    
    When you decide to add property pages to a COM class using ATL's property page macros, according to the ATL documentation you should put these macros into your class's header file. For example, if you want to add property pages to the dice control, you'd add the following code to the C++ class:
    
    class ATL_NO_VTABLE CATLDiceObj : 
        .
        .
        .
    {
        .
        .
        .
    
        BEGIN_PROP_MAP(CATLDiceObj)
            PROP_ENTRY("Caption goes here…", 2, 
                       CLSID_MainPropPage)
            PROP_ENTRY_EX("Caption goes here…", 3,
                          CLSID_SecondPropPage, 
                          DIID_SecondDualInterface)
            PROP_PAGE(CLSID_StockColorPage)
        END_PROPERTY_MAP()
    
    };
    
    ATL's property map macros set up the list of GUIDs representing property pages. ATL's property maps are composed of an array of _ATL_PROPMAP_ENTRY_ structures. The _BEGIN_PROPERTY_MAP_ macro declares a static variable of this structure. The _PROP_PAGE_ macro inserts a GUID into the list of property pages. _PROP_ENTRY_ inserts a property page GUID into the list as well as associating a specific control property with the property page. The final macro, _PROP_ENTRY_EX_, lets you associate a certain dual interface to a property page. When client code invokes the control's properties verb, the control just rips through this list of GUIDs and hands the list over to the _OleCreatePropertyFrame_ so that the property can create the property pages.
    
    **Property Pages and Development Tools** Executing the properties verb isn't the only way for an ActiveX control to show its property pages. As we mentioned before, folks who write tools such as Visual Basic and Visual C++ might want programmatic access to a control's property pages. For example, when using MFC to work on a dialog box containing an ActiveX control, right-clicking on the control to view the properties gives you a dialog frame produced by Visual C++ (as opposed to the dialog frame produced by _OleCreatePropertyFrame_).
    
    Visual C++ uses the control's _ISpecifyPropertyPages_ interface to get the list of GUIDs (the list generated by the property page macros). Here's the _ISpecifyPropertyPages_ interface definition:
    
    interface ISpecifyPropertyPages : public IUnknown {
        HRESULT GetPages(CAUUID \*pPages);
    };
    
    typedef struct tagCAUUID 
    { 
        ULONG     cElems; 
        GUID FAR\* pElems; 
    } CAUUID;
    
    ATL implements the _ISpecifyPropertyPages::GetPages_ function by cycling through the list of GUIDS (produced by the property map macros) and returning them within the _CAUUID_ structure. Environments like Visual C++ use each GUID in a call to _CoCreateInstance_ to create a new property page. The property page site and the property page exchange interfaces. The property page site holds on to the property page's _IPropertyPage_ interface, and the property page holds on to the property site's _IPropertyPageSite_ interface. After the dialog frame constructs the property pages, it needs to reflect the current state of the ActiveX control through the dialog controls. For that you need to override the property page's _Show_ method.
    
    **Showing the Property Page** The property page's _Show_ method is called whenever the property page is about to be shown. A good thing for a property page to do at this time is fetch the values from the ActiveX control and populate the property page's controls. Remember that the property page holds on to an array of unknown pointers (they're held in the _IPropertyPageImpl_'s _m_ppUnk_ array.) To access the ActiveX control's properties, you need to call _QueryInterface_ on the unknown pointers and ask for the interface that exposes the properties. In this case, the interface is _IATLDiceObj_. Once the property page has the interface, it can use the interface to fetch the properties and plug the values into the dialog box controls. Here's the overridden _Show_ method:
    
    #include "atldicesrvr.h"
    
    class ATL_NO_VTABLE CDiceMainPropPage :
        public CComObjectRootEx<CComSingleThreadModel>,
        public CComCoClass<CDiceMainPropPage, &CLSID_DiceMainPropPage>,
        public IPropertyPageImpl<CDiceMainPropPage>,
        public CDialogImpl<CDiceMainPropPage>
    {
        .
        .
        .
    STDMETHOD(Show)( UINT nCmdShow ) {
            HRESULT hr;
    
            USES_CONVERSION;
    
            if(nCmdShow == SW_SHOW ||
               nCmdShow == SW_SHOWNORMAL) {
                for (UINT i = 0; i < m_nObjects; i++)
                {
                    CComQIPtr< IATLDieceObj,
                               &IID_IATLDieceObj > pATLDiceOb(m_ppUnk[i]);
                    short nColor = 0;
    
                    if FAILED(pATLDiceOb->get_DiceColor(&nColor))
                    {
                        CComPtr<IErrorInfo> pError;
                        CComBSTR            strError;
                        GetErrorInfo(0, &pError);
                        pError->GetDescription(&strError);
                        MessageBox(OLE2T(strError), 
                              _T("Error"), MB_ICONEXCLAMATION);
                        return E_FAIL;
                    }
                    HWND hWndComboBox = GetDlgItem(IDC_COLOR);
                    ::SendMessage(hWndComboBox,
                                  CB_SETCURSEL,
                                  nColor, 0);
    
                    short nTimesToRoll = 0; 
                    if FAILED(
                        pATLDiceOb->get_TimesToRoll(&nTimesToRoll))
                    {
                        CComPtr<IErrorInfo> pError;
                        CComBSTR            strError;
                        GetErrorInfo(0, &pError);
                        pError->GetDescription(&strError);
                        MessageBox(OLE2T(strError), 
                            _T("Error"), MB_ICONEXCLAMATION);
                        return E_FAIL;
                    }
                    SetDlgItemInt(IDC_TIMESTOROLL, nTimesToRoll, FALSE);
                }
            }
            m_bDirty = FALSE;
            hr = IPropertyPageImpl<CDiceMainPropPage>::Show(nCmdShow);
            return hr;
        }
    };
    
    In addition to adding code to prepare to show the dialog box, you need to add code allowing users to set the control's properties. Whenever the user changes a property, the property dialog activates the Apply button, indicating that the user can apply the newly set properties. When the user presses the Apply button, control jumps to the property page's _Apply_ function so you need to insert some code in here to make the Apply button work.
    
    **Handling the Apply Button** After the user finishes manipulating the properties, he or she clicks either the Apply button or the OK button to save the changes. In response, the client code asks the property page to apply the new properties to the control. Remember that the ActiveX control and the property page are separate COM objects, so they need to communicate via interfaces. Here's how the process works.
    
    When you create a property page using the ATL Object Wizard, ATL overrides the _Apply_ function from _IPropertyPage_ for you. The property page site uses this function for notifying the property page of changes that need to be made to the control. When the property page's _Apply_ function is called, it's time to synch up the state of the property page with the state of the control. Remember, the control's _IUnknown_ interface was passed into the property page early in the game via a call to _IPropertyPage::SetObjects._ (The interface pointers are stored in the property page's _m_ppUnk_ array.) Most property pages respond to the _Apply_ function by setting the state of the ActiveX control properties through the interface provided. In the case of our example ATL-based property page, this means examining the value in the combo box and the edit box and setting the new values inside the control itself, like this:
    
    #include "atldicesrvr.h"
    
    class ATL_NO_VTABLE CDiceMainPropPage :
        public CComObjectRootEx<CComSingleThreadModel>,
        public CComCoClass<CDiceMainPropPage, &CLSID_DiceMainPropPage>,
        public IPropertyPageImpl<CDiceMainPropPage>,
        public CDialogImpl<CDiceMainPropPage>
    {
        .
        .
        .
        STDMETHOD(Apply)(void)
        {
            USES_CONVERSION;
            ATLTRACE(_T("CDiceMainPropPage::Apply\n"));
            for (UINT i = 0; i < m_nObjects; i++)
            {
                CComQIPtr<IATLDieceObj, 
                          &IID_IATLDieceObj> pATLDiceOb(m_ppUnk[i]);
                HWND hWndComboBox = GetDlgItem(IDC_COLOR);
                short nColor  = (short)::SendMessage(hWndComboBox,
                                                     CB_GETCURSEL,
                                                     0, 0);
                if(nColor >= 0 && nColor <= 2) {
                    if FAILED(pATLDiceOb->put_DiceColor(nColor))
                    {
                        CComPtr<IErrorInfo> pError;
                        CComBSTR            strError;
                        GetErrorInfo(0, &pError);
                        pError->GetDescription(&strError);
                        MessageBox(OLE2T(strError), 
                              _T("Error"), 
                              MB_ICONEXCLAMATION);
                        return E_FAIL;
                    }
                }
                short nTimesToRoll = (short)GetDlgItemInt
                                                (IDC_TIMESTOROLL);
                if FAILED(pATLDiceOb->put_TimesToRoll(nTimesToRoll))
                {
                    CComPtr<IErrorInfo> pError;
                    CComBSTR            strError;
                    GetErrorInfo(0, &pError);
                    pError->GetDescription(&strError);
                    MessageBox(OLE2T(strError), 
                           _T("Error"), 
                           MB_ICONEXCLAMATION);
                    return E_FAIL;
                }
            }
            m_bDirty = FALSE;
            return S_OK;
        }
    
    ### Property Persistence
    
    Once you have added properties to the control, it's logical that you might want to have those properties persist with their container. For example, imagine Hasbro buys your dice control to include in its new Windows version of Monopoly. The game vendor uses your dice control within one of the Monopoly dialog boxes and configures the control so that the dice are blue and they roll 23 times before stopping. If the dice control had a sound property, the Mono-poly authors could configure the dice to emit a beep every time they roll. When someone plays the game and rolls the dice, that person will see a pair of blue dice that roll 23 times before stopping and they will hear the dice make a sound while they roll. Remember that these properties are all properties of the control. If you're using the control in an application, chances are good you'll want these properties to be saved with the application.
    
    Fortunately, adding persistence support to your control is almost free when you use the ATL property macros. You've already seen how to add the property pages to the control DLL using the property map macros. As it turns out, these macros also make the properties persistent.
    
    You can find ATL's code for handling the persistence of a control's properties within the _CComControlBase_ class. _CComControlBase_ has a member function named _IPersistStreamInit_Save_ that handles saving a control's properties to a stream provided by the client. Whenever the container calls _IPersistStreamInit::Save_, ATL ends up calling _IPersistStreamInit_Save_ to do the actual work. _IPersistStreamInit_Save_ works by retrieving the control's property map—the list of properties maintained by the control. (Remember that the _BEGIN_PROPERTY_MAP_ macro adds a function named _GetPropertyMap_ to the control.) The first item written out by _IPersistStreamInit_Save_ is the control's extents (its size on the screen). _IPersistStreamInit_Save_ then cycles through the property map to write the contents of the property map out to the stream. For each property, the control calls _QueryInterface_ on itself to get its own _dispatch_ interface. As _IPersistStreamInit_Save_ goes through the list of properties, the control calls _IDispatch::Invoke_ on itself to get the property based on the _DISPID_ associated with the property. (The property's _DISPID_ is included as part of the property map structure.) The property comes back from _IDispatch::Invoke_ as a Variant, and _IPersistStreamInit_Save_ writes the property to the stream provided by the client.
    
    ### Bidirectional Communication (Events)
    
    Now that the dice control has properties and property pages and renders itself to a device context, the last thing to do is to add some events to the control. Events provide a way for the control to call back to the client code and inform the client code of certain events as they occur.
    
    For example, the user can roll the dice. Then when the dice stop rolling, the client application can fish the dice values out of the control. However, another way to implement the control is to set it up so that the control notifies the client application when the dice have rolled using an event. Here you'll see how to add some events to the dice control. We'll start by understanding how ActiveX Control events work.
    
    **How Events Work** When a control is embedded in a container (such as a Visual Basic form or an MFC-based dialog box), one of the steps the client code takes is to establish a connection to the control's event set. That is, the client implements an interface that has been described by the control and makes that interface available to the control. That way, the control can talk back to the container.
    
    Part of developing a control involves defining an interface that the control can use to call back to the client. For example, if you're developing the control using MFC, ClassWizard will define the interface and produce some functions you can call from within the control to fire events back to the client. If you're developing the control in ATL, you can accomplish the same result by defining the event callback interface in the control's IDL and using ClassView to create a set of callback proxy functions for firing the events to the container. When the callback interface is defined by the control, the container needs to implement that interface and hand it over to the control. The client and the control do this through the _IConnectionPointContainer_ and _IConnectionPoint_ interfaces.
    
    _IConnectionPointContainer_ is the interface a COM object implements to indicate that it supports connections. _IConnectionPointContainer_ represents a collection of connections available to the client. Within the context of ActiveX Controls, one of these connections is usually the control's main event set. Here's the _IConnectionPointContainer_ interface:
    
    interface IConnectionPointContainer : IUnknown {
        HRESULT FindConnectionPoint(REFIID riid, 
                                    IConnectionPoint \*\*ppcp) = 0;
        HRESULT EnumConnectionPoints(IEnumConnectionsPoint \*\*ppec) = 0;
    };
    
    _IConnectionPointContainer_ represents a collection of _IConnectionPoint_ interfaces. Here's the _IConnectionPoint_ interface:
    
    interface IConnectionPoint : IUnknown {
        HRESULT GetConnectionInterface(IID \*pid) = 0;
        HRESULT GetConnectionPointContainer(
                                IConnectionPointContainer \*\*ppcpc) = 0;
        HRESULT Advise(IUnknown \*pUnk, DWORD \*pdwCookie) = 0;
        HRESULT Unadvise(dwCookie) = 0;
        HRESULT EnumConnections(IEnumConnections \*\*ppec) = 0;
    }
    
    The container creates the control by calling _CoCreateInstance_ on the control. As the control and the container are establishing the interface connections between themselves, one of the interfaces the container asks for is _IConnectionPointContainer_ (that is, the container calls _QueryInterface_ asking for _IID_IConnectionPointContainer_). If the control supports connection points (the control answers "Yes" when queried for _IConnectionPointContainer_), the control uses _IConnectionPointContainer::FindConnectionPoint_ to get the _IConnectionPoint_ interface representing the main event set. The container knows the GUID representing the main event set by looking at the control's type information as the control is inserted into the container.
    
    If the container can establish a connection point to the control's main event set (that is, _IConnectionPointContainer::FindConnectionPoint_ returns an _IConnectionPoint_ interface pointer), the container uses _IConnectionPoint::Advise_ to subscribe to the callbacks. Of course, to do this the container needs to implement the callback interface defined by the control (which the container can learn about by using the control's type library). Once the connection is established, the control can call back to the container whenever the control fires off an event. Here's what it takes to make events work within an ATL-based ActiveX control.
    
    **Adding Events to the Dice Control** There are several steps to adding event sets to your control. Some of them are hidden by clever wizardry. First, use IDL to describe the events. Second, add a proxy that encapsulates the connection points and event functions. Finally, fill out the control's connection map so that the client and the object have a way to connect to each other. Let's examine each step in detail.
    
    When using ATL to write an ActiveX control, IDL is the place to start adding events to your control. The event callback interface is described within the IDL so the client knows how to implement the callback interface correctly. The IDL is compiled into a type library that the client will use to figure out how to implement the callback interface. For example, if you wanted to add events indicating the dice were rolled, doubles were rolled, and snake eyes were rolled, you'd describe the callback interface like this in the control's IDL file:
    
    library ATLDICESRVRLib
    {
        importlib("stdole32.tlb");
        importlib("stdole2.tlb");
    
        [
            uuid(21C85C43-0BFF-11d1-8CAA-FD10872CC837),
            helpstring("Events created from rolling dice")
        ]
        dispinterface _IATLDiceObjEvents {
            properties:
            methods:
                [id(1)] void DiceRolled([in]short x, [in] short y);
                [id(2)] void Doubles([in] short x);
                [id(3)] void SnakeEyes();
        }
    
        [
            uuid(6AED4EBD-0991-11D1-8CAA-FD10872CC837),
            helpstring("ATLDiceOb Class")
        ]
        coclass ATLDiceOb
        {
            [default] interface IATLDieceObj;
            [default, source] dispinterface _IATLDiceObjEvents;
        };
    
    The control's callback interface is defined as a dispatch interface (note the _dispinterface_ keyword) because that's the most generic kind of interface available. When it comes to callback interfaces, most environments understand only _IDispatch_. The code on the previous page describes a callback interface to be implemented by the client (if the client decides it wants to receive these callbacks). We added this dice events interface by hand. The Object Wizard will put one in for you. It might have a different name than the one we have listed. (For example, the Wizard is likely to put in an interface named _IATLObjEvents_.)
    
    **Implementing the Connection Point** After you've described the callback interface within the IDL and compiled the control, the control's type information will contain the callback interface description so that the client will know how to implement the callback interface. However, you don't yet have a convenient way to fire these events from the control. You could, of course, call back to the client by setting up calls to _IDispatch::Invoke_ by hand. However, a better way to do this is to set up a proxy (a set of functions wrapping calls to _IDispatch_) to handle the hard work for you. To generate a set of functions that you can call to fire events in the container, use the Implement Connection Point menu option from ClassView.
    
    In ClassView, click the right mouse button while the cursor is hovering over the CATLDiceOb symbol. This brings up the context menu for the CATLDiceOb item. Choose Implement Connection Point from the menu to bring up the Implement Connection Point dialog box. This dialog box asks you to locate the type information describing the interface you expect to use when calling back to the container (the __IATLDiceObjEvents_ interface, in this case). By default, this dialog box looks at your control's type library. The dialog box reads the type library and shows the interfaces found within it. Choose __IATLDiceObjEvents_ and click OK. Doing so creates a C++ class that wraps the dice events interface. Given the above interface definition, here's the code generated by the Implement Connection Point dialog box:
    
    template <class T>
    class CProxy_IATLDieceObjEvents : 
    public IConnectionPointImpl<T, 
                                &DIID__IATLDieceObjEvents, 
                                CComDynamicUnkArray>
    {
        //Warning this class may be recreated by the wizard.
    public:
    };
    
    {
        //Warning this class may be recreated by the wizard.
    public:
        VOID Fire_Doubles(SHORT x)
        {
            T\* pT = static_cast<T\*>(this);
            int nConnectionIndex;
            CComVariant\* pvars = new CComVariant[1];
            int nConnections = m_vec.GetSize();
    
            for (nConnectionIndex = 0; 
                 nConnectionIndex < nConnections; 
                 nConnectionIndex++)
            {
                pT->Lock();
                CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
                pT->Unlock();
                IDispatch\* pDispatch = 
                    reinterpret_cast<IDispatch\*>(sp.p);
                if (pDispatch != NULL)
                {
                    pvars[0].vt = VT_I2;
                    pvars[0].iVal= x;
                    DISPPARAMS disp = { pvars, NULL, 1, 0 };
                    pDispatch->Invoke(0x1, IID_NULL, 
                                      LOCALE_USER_DEFAULT, 
                                      DISPATCH_METHOD, &disp, 
                                      NULL, NULL, NULL);
                }
            }
            delete[] pvars;
        }
        VOID Fire_DiceRolled(SHORT x, SHORT y)
        {
            T\* pT = static_cast<T\*>(this);
            int nConnectionIndex;
            CComVariant\* pvars = new CComVariant[2];
            int nConnections = m_vec.GetSize();
     
            for (nConnectionIndex = 0; 
                 nConnectionIndex < nConnections; 
                 nConnectionIndex++)
            {
                pT->Lock();
                CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
                pT->Unlock();
                IDispatch\* pDispatch = 
                    reinterpret_cast<IDispatch\*>(sp.p);
                if (pDispatch != NULL)
                {
                    pvars[1].vt = VT_I2;
                    pvars[1].iVal= x;
                    pvars[0].vt = VT_I2;
                    pvars[0].iVal= y;
                    DISPPARAMS disp = { pvars, NULL, 2, 0 };
                    pDispatch->Invoke(0x2, IID_NULL, 
                                      LOCALE_USER_DEFAULT, 
                                      DISPATCH_METHOD, &disp, 
                                      NULL, NULL, NULL);
                }
            }
            delete[] pvars;
     
        }
        VOID Fire_SnakeEyes()
        {
            T\* pT = static_cast<T\*>(this);
            int nConnectionIndex;
            int nConnections = m_vec.GetSize();
            
            for (nConnectionIndex = 0; 
                 nConnectionIndex < nConnections; 
                 nConnectionIndex++)
            {
                pT->Lock();
                CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
                pT->Unlock();
                IDispatch\* pDispatch = 
                    reinterpret_cast<IDispatch\*>(sp.p);
                if (pDispatch != NULL)
                {
                    DISPPARAMS disp = { NULL, NULL, 0, 0 };
                    pDispatch->Invoke(0x3, IID_NULL, 
                                      LOCALE_USER_DEFAULT, 
                                      DISPATCH_METHOD, &disp, 
                                      NULL, NULL, NULL);
                }
            }
     
        }
    };
    
    The C++ class generated by the connection point generator serves a dual purpose. First, it acts as the specific connection point. (Notice that it derives from _IConnectionPointImpl._) Second, the class serves as a proxy to the interface implemented by the container. For example, if you want to call over to the client and tell the client that doubles were rolled, you'd simply call the proxy's _Fire_Doubles_ function. Notice how the proxy wraps the _IDispatch_ call so that you don't have to get your hands messy dealing with variants by yourself.
    
    **Establishing the Connection and Firing the Events** The final step in setting up the event set is to add the connection point to the dice control and turn on the _IConnectionPointContainer_ interface. The connection point dialog box added the _CProxy_IATLDiceObjEvents_ class to the dice control's inheritance list, which provides the _IConnectionPoint_ implementation inside the control. An ATL class named _IConnectionPointContainerImpl_ provides the implementation of _IConnectionPointContainer_. These two interfaces should be in the dice control's inheritance list like this:
    
    class CATLDiceObj : 
        public CComObjectRootEx<CComSingleThreadModel>,
        public CStockPropImpl<CATLDiceObj, IATLDieceObj, 
                              &IID_IATLDieceObj, 
                              &LIBID_ATLDICESRVRLib>,
        public CComControl<CATLDiceObj>,
        public IPersistStreamInitImpl<CATLDiceObj>,
        public IOleControlImpl<CATLDiceObj>,
        public IOleObjectImpl<CATLDiceObj>,
        public IOleInPlaceActiveObjectImpl<CATLDiceObj>,
        public IViewObjectExImpl<CATLDiceObj>,
        public IOleInPlaceObjectWindowlessImpl<CATLDiceObj>,
        public IConnectionPointContainerImpl<CATLDiceObj>,
        public IPersistStorageImpl<CATLDiceObj>,
        public ISpecifyPropertyPagesImpl<CATLDiceObj>,
        public IQuickActivateImpl<CATLDiceObj>,
        public IDataObjectImpl<CATLDiceObj>,
        public IProvideClassInfo2Impl<&CLSID_ATLDiceOb, 
                                      &DIID__IATLDiceObjEvents, 
                                      &LIBID_ATLDICESRVRLib>,
        public IPropertyNotifySinkCP<CATLDiceObj>,
        public CComCoClass<CATLDiceObj, &CLSID_ATLDiceOb>,
        public CProxy_DDiceEvents< CATLDiceObj >
    {
    .
    .
    . 
    };
    
    Having these classes in the inheritance list inserts the machinery in your control that makes connection points work. Whenever you want to fire an event to the container, all you need to do is call one of the functions in the proxy. For example, a good time to fire these events is from within the control's _OnTimer_ method, firing a DiceRolled event whenever the timer stops, firing a SnakeEyes event whenever both die faces have the value 1, and firing a Doubles event when both die faces are equal:
    
    CATLDiceObj::OnTimer(UINT msg, WPARAM wParam, 
                        LPARAM lParam, BOOL& bHandled) {
    
        if(m_nTimesRolled > m_nTimesToRoll) {
            m_nTimesRolled = 0;
            KillTimer(1);
            Fire_DiceRolled(m_nFirstDieValue, m_nSecondDieValue);
            if(m_nFirstDieValue == m_nSecondDieValue)
                Fire_Doubles(m_nFirstDieValue);
            if(m_nFirstDieValue == 1 &&
               m_nSecondDieValue == 1)
                Fire_SnakeEyes();
        } else {
            m_nFirstDieValue = (rand() % (MAX_DIEFACES)) + 1;
            m_nSecondDieValue = (rand() % (MAX_DIEFACES)) + 1; 
            FireViewChange();
            m_nTimesRolled++;
        }
            bHandled = TRUE;
            return 0;
    }
    
    Finally, notice the connection map contains entries for the control's connection points:
    
    BEGIN_CONNECTION_POINT_MAP(CATLDiceObj)
        CONNECTION_POINT_ENTRY(DIID__IATLDiceObjEvents)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP()
    
    The control uses this map to hand back connection points as the client requests them.
    
    ### Using the Control
    
    So how do you use the control once you've written it? The beauty of COM is that as long as the client and the object agree on their shared interfaces, they don't need to know anything else about each other. All the interfaces implemented within the dice control are well understood by a number of programming environments. You've already seen how to use ActiveX Controls within an MFC-based dialog box. The control you just wrote will work fine within an MFC-based dialog box—just use the Add To Project menu option under the Project menu. Select Registered ActiveX Controls and insert the ATLDiceOb component into your project. Visual C++ will read the dice control's type information and insert all the necessary COM glue to make the dialog box and the control talk together. (This includes all the OLE embedding interfaces as well as the connection and event interfaces.) In addition, you could just as easily use this control from within a Visual Basic form. When working on a Visual Basic project, select References from the Project menu and insert the dice control into the Visual Basic project.
________________________________________________________________________
7.7.3. - [Conclusion](invcpp5/ch30d.htm)
----------------------------------------------------
 Conclusion 

Conclusion
==========

ActiveX Controls are one of the most widely used applications of COM in the real world today. To summarize, ActiveX controls are just COM objects that happen to implement a number of standard interfaces that environments like Visual C++ and Visual Basic understand how to use. These interfaces deal with rendering, persistence, and events, allowing you to drop these components into the aforementioned programming environments and use them right away.

In the past, MFC was the only practical way to implement ActiveX Controls. However, these days ATL provides a reasonable way of implementing ActiveX Controls, provided you're willing to follow ATL's rules. For example, if you buy into the ATL architecture for writing controls, you'll have to dip down into Windows and start working with window handles and device context handles in their raw forms. However, the tradeoff is often worthwhile, because ATL provides more flexibility when developing ActiveX controls. For example, dual interfaces are free when using ATL, whereas they're a real pain to implement in MFC.
________________________________________________________________________
/8. - [Part V: Database Management]()
====================================================
________________________________________________________________________
8.1. - [Chapter 31 -- Database Management with Microsoft ODBC](invcpp5/ch31a.htm)
----------------------------------------------------
 Chapter 31 -- Database Management with Microsoft ODBC  Chapter 31

Database Management with Microsoft ODBC
=======================================

Microcomputers became popular, in part, because businesspeople saw them as a low-cost means of tracking inventory, processing orders, printing payroll checks, and so forth. Business applications required fast access to individual records in a large database. One of the first microcomputer database tools was dBASE II, a single-user product with its own programming language and file format. Today Windows programmers have a wide choice of programmable database management systems (DBMS's), including Inprise Paradox, Microsoft Access, Microsoft FoxPro, and Powersoft PowerBuilder. Most of these products can access both local data and remote data on a central computer. The latter case requires the addition of database server software such as ORACLE or Microsoft SQL Server.

> NOTE
> 
> Microsoft SQL Server is included with the Enterprise Edition of Visual C++.

How do you, as an MFC programmer, fit into the picture? Visual C++ contains all the components you'll need to write C++ database applications for Microsoft Windows. Indeed, the product contains two separate client-side database access systems: Open Database Connectivity (ODBC) and Data Access Objects (DAO). In addition, Visual C++ now contains wrapper templates for interacting with data directly through OLE DB. This chapter covers the ODBC standard, which consists of an extensible set of dynamic link libraries (DLLs) that provide a standard database application programming interface. ODBC is based on a standardized version of Structured Query Language (SQL). With ODBC and SQL, you can write database access code that is independent of any database product.

Visual C++ includes tools and MFC classes for ODBC, and that's the subject of this chapter. You'll learn the basics of ODBC, and you'll see four sample programs: one that uses the ODBC rowset with support from the MFC _CRecordset_ class (EX31A), one that uses the MFC _CRecordView_ class (EX31B), one that uses multiple recordsets (EX31C), and one that uses the _CRecordset_ class without binding (EX31D).
________________________________________________________________________
8.1.1. - [The Advantages of Database Management](invcpp5/ch31b.htm)
----------------------------------------------------
 The Advantages of Database Management 

The Advantages of Database Management
=====================================

The serialization process, introduced in [Chapter 17](ch17a.htm) and [Chapter 18](ch18a.htm), ties a document object to a disk file. All the document's data must be read into memory when the document is opened, and all the data must be written back to disk when an updated document is closed. Obviously, you can't serialize a document that's bigger than the available virtual memory. Even if the document is small enough to fit in memory, you might not need to read and write all the data every time the program runs.

You could program your own random access disk file, thus inventing your own DBMS, but you probably have enough work to do already. Besides, using a real DBMS gives you many advantages, including the following:

*   **Use of standard file formats**—Many people think of dBASE/Xbase DBF files when they think of database formats. This is only one database file format, but it's a popular one. A lot of data is distributed in DBF files, and many programs can read and write in this format. Lately, the Microsoft Access MDB format has become popular, too. With the MDB format, all of a database's tables and indexes can be contained in a single disk file.
    
*   **Indexed file access**—If you need quick access to records by key (a customer name, for example), you need indexed file access. You could always write your own B-tree file access routines, but that's a tedious job that's been done already. All DBMS's contain efficient indexed access routines.
    
*   **Data integrity safeguards**—Many professional DBMS products have procedures for protecting their data. One example is transaction processing. A transaction encompasses a series of related changes. If the entire transaction can't be processed, it is rolled back so that the database reverts to its original state before the transaction.
    
*   **Multiuser access control**—If your application doesn't need multiuser access now, it might in the future. Most DBMS's provide record locking to prevent interference among simultaneous users. Some multiuser DBMS's use the client-server model, which means that most processing is handled on a single database server computer; the workstations handle the user interface. Other multiuser DBMSs handle database processing on the workstations, and they control each workstation's access to shared files.
________________________________________________________________________
8.1.2. - [Structured Query Language](invcpp5/ch31c.htm)
----------------------------------------------------
 Structured Query Language 

Structured Query Language
=========================

You could not have worked in the software field without at least hearing about Structured Query Language (SQL), a standard database access language with its own grammar. In the SQL world, a database is a collection of tables that consist of rows and columns. Many DBMS products support SQL, and many programmers know SQL. The SQL standard is continually evolving, and SQL grammar varies among products. SQL extensions, such as blob (binary large object) capability, allow storage of pictures, sound, and complex data structures.
________________________________________________________________________
8.1.3. - [The ODBC Standard](invcpp5/ch31d.htm)
----------------------------------------------------
 The ODBC Standard 

The ODBC Standard
=================

The Microsoft Open Database Connectivity (ODBC) standard defines not only the rules of SQL grammar but also the C-language programming interface to any SQL database. It's now possible for a single compiled C or C++ program to access any DBMS that has an ODBC driver. The ODBC Software Development Kit (SDK), included with Visual C++, contains 32-bit drivers for DBF files, Microsoft Access MDB databases, Microsoft Excel XLS files, Microsoft FoxPro files, ASCII text files, and Microsoft SQL Server databases.

Other database companies, including Oracle, Informix, Progress, Ingres, and Centura Software, provide ODBC drivers for their own DBMS's. If you develop an MFC program with the dBASE/Xbase driver, for example, you can run the same program with an Access database driver. No recompilation is necessary—the program simply loads a different DLL.

Not only can C++ programs use ODBC but other DBMS programming environments can also take advantage of this new standard. You could write a C++ program to update a SQL Server database, and then you could use an off-the-shelf ODBC-compatible report writer to format and print the data. ODBC thus separates the user interface from the actual database-management process. You no longer have to buy your interface tools from the same company that supplies the database engine.

Some people have criticized ODBC because it doesn't let programmers take advantage of the special features of some particular DBMS's. Well, that's the whole point! Programmers only need to learn one application programming interface (API), and they can choose their software components based on price, performance, and support. No longer will developers be locked into buying all their tools from their database suppliers.

What's the future of ODBC? That's a difficult question. Microsoft is driving the standard, but it isn't actually "selling" ODBC; it's giving ODBC away for the purpose of promoting other products. Other companies are selling their own proprietary ODBC libraries. Meanwhile, Microsoft has introduced OLE-based DAO, which relies on the Jet database engine from Microsoft Access. ([Chapter 32](ch32a.htm) describes DAO and compares its features with the features of ODBC.) And if that isn't enough, Microsoft is in the process of introducing OLE DB, an alternative to ODBC based on the Component Object Model (COM). [Chapter 33](ch33a.htm) covers Visual C++'s new templates for wrapping OLE DB consumer and provider code.

The ODBC Architecture
---------------------

ODBC's unique DLL-based architecture makes the system fully modular. A small top-level DLL, ODBC32.DLL, defines the API. ODBC32.DLL loads database-specific DLLs, known as drivers, during program execution. With the help of the Windows Registry (maintained by the ODBC Administrator module in the Windows Control Panel), ODBC32.DLL tracks which database-specific DLLs are available and thus allows a single program to access data in several DBMSs simultaneously. A program could, for example, keep some local tables in DBF format and use other tables controlled by a database server. Figure 31-1 shows the 32-bit ODBC DLL hierarchy.

Note from this figure that many standard database formats can be accessed through the Microsoft Access Jet database engine, a redistributable module packaged with Visual C++. If, for example, you access a DBF file through the Jet engine, you're using the same code that Microsoft Access uses.

ODBC SDK Programming
--------------------

If you program directly at the ODBC C-language API level, you must know about three important ODBC elements: the environment, the connection, and the statement. All three are accessed through handles.

First you need an environment that establishes the link between your program and the ODBC system. An application usually has only one environment handle.

Next you need one or more connections. The connection references a specific driver and data source combination. You might have several connections to subdirectories that contain DBF files, and you might have connections to several SQL servers on the same network. A specific ODBC connection can be hardwired into a program, or the user can be allowed to choose from a list of available drivers and data sources.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f31og01x.gif)]

**Figure 31-1.** _32-bit ODBC architecture._

ODBC32.DLL has a built-in Windows dialog box that lists the connections that are defined in the Registry (under HKEY_LOCAL_MACHINE-\SOFTWARE\ODBC). Once you have a connection, you need a SQL statement to execute. The statement might be a query, such as this:

> SELECT FNAME, LNAME, CITY FROM AUTHORS  
> WHERE STATE = 'UT' ORDER BY LNAME

Or the statement could be an update statement, such as this:

> UPDATE AUTHORS SET PHONE = '801 232-5780'  
> WHERE ID = '357-86-4343'

Because query statements need a program loop to process the returned rows, your program might need several statements active at the same time. Many ODBC drivers allow multiple active statement handles per connection.

Look again at the SQL statement above. Suppose there were 10 authors in Utah. ODBC lets you define the query result as a block of data, called a rowset, which is associated with an SQL statement. Through the ODBC SDK function _SQLExtendedFetch_, your program can move forward and backward through the 10 selected records by means of an ODBC cursor. This cursor is a programmable pointer into the rowset.

What if, in a multiuser situation, another program modified (or deleted) a Utah author record while your program was stepping through the rowset? With an ODBC Level 2 driver, the rowset would probably be dynamic and ODBC could update the rowset whenever the database changed. A dynamic rowset is called a dynaset. The Jet engine supports ODBC Level 2, and thus it supports dynasets.

Visual C++ includes the ODBC cursor library module ODBCCR32.DLL, which supports static rowsets (called snapshots) for Level 1 drivers. With a snapshot, a _SELECT_ statement causes ODBC to make what amounts to a local copy of the 10 author records and build an in-memory list of pointers to those records. These records are guaranteed not to change once you've scrolled through them; in a multiuser situation, you might need to requery the database periodically to rebuild the snapshot.
________________________________________________________________________
8.1.4. - [The MFC ODBC Classes -- CRecordset and CDatabase](invcpp5/ch31e.htm)
----------------------------------------------------
 The MFC ODBC Classes -- CRecordset and CDatabase 

The MFC ODBC Classes—_CRecordset_ and _CDatabase_
=================================================

With the MFC classes for Windows, you use C++ objects instead of window handles and device context handles; with the MFC ODBC classes, you use objects instead of connection handles and statement handles. The environment handle is stored in a global variable and is not represented by a C++ object. The two principal ODBC classes are _CDatabase_ and _CRecordset_. Objects of class _CDatabase_ represent ODBC connections to data sources, and objects of class _CRecordset_ represent scrollable rowsets. The Visual C++ documentation uses the term "recordset" instead of "rowset" to be consistent with Microsoft Visual Basic and Microsoft Access. You seldom derive classes from _CDatabase_, but you generally derive classes from _CRecordset_ to match the columns in your database tables.

For the author query in the previous section, you would derive (with the help of ClassWizard) a _CAuthorSet_ class from _CRecordset_ that had data members for first name, last name, city, state, and zip code. Your program would construct a _CAuthorSet_ object (typically embedded in the document) and call its inherited _Open_ member function. Using the values of parameters and data members, _CRecordset::Open_ constructs and opens a _CDatabase_ object; this function issues an SQL _SELECT_ statement and then moves to the first record. Your program would then call other _CRecordset_ member functions to position the ODBC cursor and exchange data between the database fields and the _CAuthorSet_ data members. When the _CAuthorSet_ object is deleted, the recordset is closed and, under certain conditions, the database is closed and deleted. Figure 31-2 shows the relationships between the C++ objects and the ODBC components.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f31og02x.gif)]

**Figure 31-2.** _MFC ODBC class database relationships._

It's important to recognize that the _CAuthorSet_ object contains data members that represent only one row in a table, the so-called "current record." The _CRecordset_ class, together with the underlying ODBC rowset code, manages the database dynaset or snapshot.

> NOTE
> 
> It's possible to have several active dynasets or snapshots per data source, and you can use multiple data sources within the same program.

The important _CRecordset_ member functions discussed in this chapter are summarized in the table below.

**Function**

**Description**

_Open_

Opens the recordset

_AddNew_

Prepares to add a new record to the table

_Update_

Completes an _AddNew_ or _Edit_ operation by saving the new or edited data in the data source

_Delete_

Deletes the current record from the recordset

_Edit_

Prepares to implement changes on the current record

_IsBOF_

Determines whether the recordset has been positioned before the first record

_IsEOF_

Determines whether the recordset has been positioned after the last record

_MoveNext_

Sets the current record to the next record or to the next rowset

_MoveFirst_

Sets the current record to the first record in the recordset

_MoveLast_

Sets the current record to the last record or to the last rowset

_MovePrev_

Sets the current record to the previous record or to the previous rowset

_GetDefaultConnect_

Gets the default connect string for the data source on which the recordset is based

_GetDefaultSQL_

Gets the default SQL string

_DoFieldExchange_

Exchanges data between the recordset data fields and the corresponding record on the data source

_GetStatus_

Gets the index of the current record in the recordset and the final count status

_GetRecordCount_

Determines the highest-numbered record yet encountered as the user moves through the records

_GetODBCFieldCount_

Gets the number of fields in the recordset object

_GetODBCFieldInfo_

Gets information about the fields in the recordset

Counting the Rows in a Recordset
--------------------------------

It's difficult to know how many records are contained in an ODBC recordset. ODBC doesn't provide an accurate count of the rows in a recordset until you've read past the end. Until that time, the count returned from the _CRecordset::GetRecordCount_ member function is a "high-water mark" that returns only the last row accessed by _CRecordset::MoveNext_. The _CRecordset::GetStatus_ function returns a _CRecordsetStatus_ object, which has a member _m_bRecordCountFinal_ that indicates whether the count is final.

The _CRecordset::MoveLast_ function does not register the record count for you, even for dynasets. If you want to know how many records are included in a recordset, loop through the whole table with _MoveNext_ calls. (A faster alternative is to use the COUNT function.) If your program adds or deletes a record or if another user adds or deletes a record, the record count is not adjusted.

Processing ODBC Exceptions
--------------------------

Many MFC ODBC calls don't return an error code but instead throw a _CDBException_ object, which contains a string describing the error. Suppose you are trying to delete a record from a table in an Access database. Access might be enforcing referential integrity rules, which means that you're not allowed to delete that row because a row in another table depends on it. If you call _CRecordset::Delete_, you'll see an ODBC error message box that came from the MFC base classes.

You certainly appreciate the error message, but now ODBC has "lost its place" in the recordset, and there is no longer a current record. Your program needs to detect the error so that it won't call functions that depend on a current record, such as _CRecordset::MoveNext_. You must handle the exception in this way:

try {
    m_pSet->Delete();
}
catch(CDBException\* e) {
    AfxMessageBox(e->m_strError);
    e->Delete();
    m_pSet->MoveFirst(); // lost our place!
    UpdateData(FALSE);
    return;
}
m_pSet->MoveNext();
________________________________________________________________________
8.1.5. - [The Student Registration Database](invcpp5/ch31f.htm)
----------------------------------------------------
 The Student Registration Database 

The Student Registration Database
=================================

The Visual C++ Enroll tutorial uses a ready-made sample Access database (STDREG32.MDB) that tracks students, classes, and instructors. (See Tutorial Samples under Visual C++ Documentation\Samples\MFC Samples\Database Samples in the online documentation.) Figure 31-3 shows the four database tables and the relationships among them. The boldfaced fields are indexed fields, and the 1-? relationships represent referential integrity constraints. If there's at least one section for the course MATH101, for example, Access prevents the user from deleting the MATH101 course record.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f31og03x.gif)]

**Figure 31-3.** _The Student Registration database schema._
________________________________________________________________________
8.1.6. - [The EX31A Recordset Example](invcpp5/ch31g.htm)
----------------------------------------------------
 The EX31A Recordset Example 

The EX31A Recordset Example
===========================

You can use AppWizard to generate a complete forms-oriented database application, and that's what the Enroll tutorial is all about. If customers or users wanted a straightforward business database application like that, however, they probably wouldn't call in a Visual C++ programmer; instead, they might use a less technical tool, such as Microsoft Access. Visual C++ and the MFC ODBC classes are more appropriate for a complex application that might have an incidental need for database access. You can also use the classes to make your own general-purpose database query tool.

The EX31A program isolates the database access code from user interface code so that you can see how to add ODBC database capability to any MFC application. You'll be using ClassWizard to generate a _CRecordset_ class, but you won't be using the _CRecordView_ class that AppWizard generates when you ask for a database view application.

The EX31A application is fairly simple. It displays the rows from the student database table in a scrolling view, as shown in the screen at the end of this section. The student table is part of the Student Registration (Microsoft Access 97) sample database that's included with Visual C++.

Here are the steps for building the EX31A example:

2.  **Copy the Student Registration database to your hard disk.** You can find the file stdreg32.mdb in the \Samples\VC98\Mfc\Database\Stdreg directory on the Visual C++ MSDN CD-ROM. Copy it to the new project directory on your hard disk, and make sure the copy does not have its read-only attribute set.
    
3.  **Run the ODBC Data Source Administrator to install the Student Registration data source.** Click the ODBC icon in the Windows Control Panel. The Visual C++ Setup program should have already installed the required ODBC drivers on your hard disk. If you are running Windows 95, click the Drivers button to see whether the Microsoft Access driver is available. If you're running Windows 98, click the Drivers tab to see whether the Microsoft Access driver is available. (If the Microsoft Access driver is not available, rerun Visual C++ Setup.) Click the Add button (in Windows 98, the Add button is on the User DSN tab), choose Microsoft Access Driver in the Add Data Source dialog box (in Windows 98, select the Microsoft Access Driver in the Create New Data Source dialog box and click the Finish button), and fill in the ODBC Microsoft Access 97 Setup dialog box as shown here.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G31OG01x.gif)]
    
    Set the database to point to stdreg32.mdb using the Select button. Finally, click the OK button.
    
    > NOTE
    > 
    > If you are using Microsoft Windows NT version 4.0, click on the ODBC icon in the Windows Control Panel and then click on the ODBC Drivers tab to see whether the Microsoft Access Driver is available. On the User DSN tab, click the Add button, choose Microsoft Access Driver in the Create New Data Source dialog box, click the Finish button, and then fill in the dialog box as shown above.
    
4.  **Run AppWizard to produce \vcpp32\ex31a\.** Specify an SDI application (Step 1 dialog box) with _CScrollView_ as the view's class type (Step 6 dialog box). Select the Header Files Only option from the AppWizard Step 2 dialog box, as shown here.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g31og02x.gif)]
    
5.  **Use ClassWizard to create the _CEx31aSet_ recordset class.** Choose New from the Add Class menu, and then fill in the New Class dialog box as shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/g31og03x.gif)
    
6.  **Select the Student Registration database's Student table for the _CEx31aSet_ class.** When you click the OK button in the New Class dialog box, ClassWizard displays the Database Options dialog box. Select the Student Registration data source, and select the Dynaset option as shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/g31og04.gif)
    
    After you select the data source, ClassWizard prompts you to select a table. Select Student, as shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/g31og05.gif)
    
7.  **Examine the data members that ClassWizard generates.** Click on the Member Variables tab for the newly generated _CEx31aSet_ class. ClassWizard should have generated data members based on student column names, as shown here.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g31og06x.gif)]
    
8.  **Declare an embedded recordset object in ex31aDoc.h.** Add the following public data member in the _CEx31aDoc_ class declaration:
    
    **CEx31aSet m_ex31aSet;**
    
9.  **Edit the ex31aDoc.cpp file.** Add the line
    
    **#include "ex31aSet.h"**
    
    just before the line
    
    #include "ex31aDoc.h"
    
10.  **Declare a recordset pointer in ex31aView.h.** Add the following private data member in the _CEx31aView_ class declaration:
    
    **CEx31aSet\* m_pSet;**
    
11.  **Edit the _OnDraw_ and _OnInitialUpdate_ functions in ex31aView.cpp.** Add the following boldface code:
    
    void CEx31aView::OnDraw(CDC\* pDC)
    {
        **TEXTMETRIC tm;
        pDC->GetTextMetrics(&tm);
        int nLineHeight=tm.tmHeight+tm.tmExternalLeading;
        CPoint pText(0,0);
    
        int y = 0;
        CString str;**
        **if (m_pSet->IsBOF()) { // detects empty recordset
            return;
        }
        m_pSet->MoveFirst();   // fails if recordset is empty
        while (!m_pSet->IsEOF()) {
            str.Format("%ld", m_pSet->m_StudentID);
            pDC->TextOut(pText.x, pText.y, str);
            pDC->TextOut(pText.x+1000, pText.y, m_pSet->m_Name);
            str.Format("%d", m_pSet->m_GradYear);
            pDC->TextOut(pText.x+4000, pText.y, str);
            m_pSet->MoveNext();
            pText.y -= nLineHeight;
        }**
    }
    void CEx31aView::OnInitialUpdate() 
    {
        CScrollView::OnInitialUpdate();
        CSize sizeTotal(8000, 10500);
    
        **SetScrollSizes(MM_HIENGLISH, sizeTotal);
    
        m_pSet = &GetDocument()->m_ex31aSet;
        // Remember that documents/views are reused in SDI applications!
        if (m_pSet->IsOpen()) {
            m_pSet->Close();
        }
        m_pSet->Open();**
    } 
    
    Also in ex31aView.cpp, add the line
    
    **#include "ex31aSet.h"**
    
    just before the line
    
    #include "ex31aDoc.h"
    
12.  **Edit the ex31a.cpp file.** Add the line
    
    **#include "ex31aSet.h"**
    
    just before the line
    
    #include "ex31aDoc.h"
    
13.  **Build and test the EX31A application.** Does the resulting screen look like the one shown here?
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G31OG07x.gif)]
    

> **Adding ODBC Capability to an MFC Application**
> 
> If you need to add ODBC capability to an existing MFC application, make the following changes to the project:
> 
> *   Add the following line at the end of StdAfx.h:
>     
>     #include <afxdb.h>
>     
> *   Edit the RC file in text mode. After the line
>     
>     "#include ""afxprint.rc"" // printing print preview resources\r\n"
>     
>     add the line
>     
>     "#include ""afxdb.rc""    // database resources\r\n"
>     
>     And after the line
>     
>     #include "afxprint.rc"    // printing print preview resources
>     
>     add the line
>     
>     #include "afxdb.rc"       // database resources
>
________________________________________________________________________
8.1.7. - [The EX31A Program Elements](invcpp5/ch31h.htm)
----------------------------------------------------
 The EX31A Program Elements 

The EX31A Program Elements
==========================

Let's take a look at the major elements in the EX31A program.

Connecting the Recordset Class to the Application
-------------------------------------------------

When ClassWizard generates the _CEx31aSet_ class, it adds the CPP and H files to the project—and that's all it does. It's up to you to link the recordset to your view and to your document. By embedding a _CEx31aSet_ object inside the _CEx31aDoc_ class, you ensure that the recordset object will be constructed when the application starts.

The view could always get the recordset from the document, but it's more efficient if the view has its own recordset pointer. Notice how the view's _OnInitialUpdate_ function sets the _m_pSet_ data member.

> NOTE
> 
> If you run AppWizard with either of the Database View options, AppWizard generates a class derived from _CRecordset_, a class derived from _CRecordView_ (for ODBC), and all the necessary linkage as just described. We're not using AppWizard in this mode because we don't want a form-based application.

The _CEx31aView_ Class's _OnInitialUpdate_ Member Function
----------------------------------------------------------

The job of the _CEx31aView::OnInitialUpdate_ function is to open the recordset that's associated with the view. The recordset constructor was called with a _NULL_ database pointer parameter, so the _CRecordset::Open_ function knows it must construct a _CDatabase_ object and link that database one to one with the recordset. But how does _Open_ know what data source and table to use? It calls two _CRecordset_ virtual functions, _GetDefaultConnect_ and _GetDefaultSQL_. ClassWizard generates implementations of these functions in your derived recordset class, as shown here:

CString CEx31aSet::GetDefaultConnect()
{
    return _T("ODBC;DSN=Student Registration");
}

CString CEx31aSet::GetDefaultSQL()
{
    return _T("[Student]");
}

> NOTE
> 
> ClassWizard and AppWizard place brackets around all column and table [names]. These brackets are necessary only if the names contain embedded blanks.

_GetDefaultSQL_ is a pure virtual function, so the derived class must implement it. _GetDefaultConnect_, on the other hand, has a base class implementation that opens an ODBC dialog box, which in turn prompts the user for the data source name.

Because documents and views are reused in SDI applications, the _OnInitialUpdate_ function must close any open recordset before it opens a new recordset. The _CRecordSet::IsOpen_ member function is used to test this.

The _CEx31aView_ Class's _OnDraw_ Member Function
-------------------------------------------------

As in any document_view application, the _CEx31aView::OnDraw_ function is called every time the view is invalidated and once for every printed page. Here _OnDraw_ inefficiently slogs through every row in the recordset and paints its column values with the _CDC::TextOut_ function. The principal _CRecordset_ member functions it calls are _MoveFirst_ and _MoveNext_. _MoveFirst_ will fail if the recordset is empty, so the initial call to _CRecordset::IsBOF_ is necessary to detect the beginning-of-file condition. The _CRecordset::IsEOF_ call detects the end-of-file condition for the recordset and terminates the row loop.

Remember that ClassWizard generated _CEx31aSet_ class data members for the recordset's columns. This means that the recordset class and now the view class are both hard-coded for the student record. The _CRecordset_ member functions call a pure virtual function, _DoFieldExchange_, that ClassWizard generates based on the data members _m_StudentID_, _m_Name_, and _m_GradYear_. Here is the code for this example's derived recordset class:

void CEx31aSet::DoFieldExchange(CFieldExchange\* pFX)
{
    //{{AFX_FIELD_MAP(CEx31aSet)
    pFX->SetFieldType(CFieldExchange::outputColumn);
    RFX_Long(pFX, _T("[StudentID]"), m_StudentID);
    RFX_Text(pFX, _T("[Name]"), m_Name);
    RFX_Int(pFX, _T("[GradYear]"), m_GradYear);
    //}}AFX_FIELD_MAP
}

Each SQL data type has a record field exchange (RFX) function. RFX functions are quite complex and are called many times during database processing. You might think at first that the RFX functions are like the _CDialog_ DDX functions and thus actually transfer data between the database and the data members. This is not the case. The primary purpose of the RFX functions is to bind the database columns to the data members so that the underlying ODBC functions, such as _SQLExtendedFetch_, can transfer the column data. To this end, the _DoFieldExchange_ function is called from _CRecordSet::Open_. _DoFieldExchange_ is also called by the _Move_ functions for the purpose of reallocating strings and clearing status bits.

Because the _DoFieldExchange_ function is so tightly integrated with MFC database processing, you are advised not to call this function directly in your programs.
________________________________________________________________________
8.1.8. - [Filter and Sort Strings](invcpp5/ch31i.htm)
----------------------------------------------------
 Filter and Sort Strings 

Filter and Sort Strings
=======================

SQL query statements can have an ORDER BY clause and a WHERE clause. The _CRecordset_ class has a public data member _m_strSort_ that holds the text of the ORDER BY clause (excluding the words "ORDER BY"). Another public data member, _m_strFilter_, holds the text of the WHERE clause (excluding the word "WHERE"). You can set the values of these strings prior to opening the recordset.
________________________________________________________________________
8.1.9. - [Joining Two Database Tables](invcpp5/ch31j.htm)
----------------------------------------------------
 Joining Two Database Tables 

Joining Two Database Tables
===========================

Most database programmers know that a join is one big logical table composed of fields from two or more related tables. In the Student Registration database, you could join the Student table with the Enrollment table to get a list of students and the classes they are enrolled in.

Joins are easy to do with Visual C++ because ClassWizard lets you add tables to an existing recordset. A few additional programming tasks are needed, though. Here are the steps for joining the Enrollment table to the Student table in EX31A.

1.  Use ClassWizard to access the _CEx31aSet_ class on the Member Variables tab. Click the Update Columns button, and then select the Enrollment table from the Student Registration database. If you get a warning message indicating that the data source does not contain all the columns that the recordset classes need, click the Yes button to continue. Then click the Bind All button to add the data members for the Enrollment fields.
    
2.  Edit the _CEx31aSet::GetDefaultSQL_ function, as shown here, to access the Student and Enrollment tables:
    
    CString CEx31aSet::GetDefaultSQL()
    {
        **return _T("[Student],[Enrollment]");**
    }
    
3.  Two StudentID fields are now in the joined table. In the _CEx31aSet::DoFieldExchange_ function, edit the StudentID line to qualify the field with a table name:
    
    **RFX_Long(pFX, _T("[Student].[StudentID]"), m_StudentID);**
    
4.  In the _CEx31aView::OnInitialUpdate_ function, set the recordset's _m_strFilter_ string as follows:
    
    **m_pSet->m_strFilter = "[Student].[StudentID] =
        [Enrollment].[StudentID]";**
    
5.  In the _CEx31aView::OnDraw_ function, add code to display the new Enrollment fields. Here is a sample:
    
    **pDC->TextOut(pText.x+5000, pText.y, m_pSet->m_CourseID);**
________________________________________________________________________
8.1.10. - [The MFC CRecordView Class](invcpp5/ch31k.htm)
----------------------------------------------------
 The MFC CRecordView Class 

The MFC _CRecordView_ Class
===========================

The _CRecordView_ class is a form view class that's attached to a recordset. Figure 31-4 illustrates an MFC record view application. The toolbar buttons enable the user to step forward and backward through a database table.

![](c:/dl/books/windows/msvc5th/invcpp5/images/f31og04.gif)

**Figure 31-4.** _An MFC application based on the_ CRecordView _class._

Like the _CFormView_ class, the _CRecordView_ class depends on a dialog template resource. The _CFormView_ class has data members that correspond to the controls in the dialog box, but the _CRecordView_ class accesses data members in a foreign object, namely the attached _CRecordset_ object. When the user enters data in the controls, the record view's DDX (Dialog Data Exchange) code moves the data into the recordset's data members, which are bound to database columns by the recordset's RFX (Record Field Exchange) code.

When you specify a database view application, AppWizard generates a class derived from _CRecordView_ together with an empty dialog template. AppWizard also generates a class derived from _CRecordset_, so it must ask you for a database table name. At runtime, the record view object and the recordset object are connected. Your job is to add controls to the dialog template and match the controls to recordset data members—no C++ programming is required to create a working form-based database application.

AppWizard generates a read-only, view-based database application. If you want to modify, add, and delete records, you must do some coding. The default behavior of the resulting application matches the behavior of Visual Basic and Access, which is a little weird. A record is added or modified only when the user moves out of it. If that's what you want, you can pattern your applications after the ENROLL sample program in the \ \Samples\VC98\Mfc\Tutorial\Enroll directory on the Visual C++ MSDN CD-ROM.
________________________________________________________________________
8.1.11. - [The EX31B Record View Example](invcpp5/ch31l.htm)
----------------------------------------------------
 The EX31B Record View Example 

The EX31B Record View Example
=============================

The EX31B example is an "add-change-delete" application that's different from the Access model. The user must explicitly add, update, and delete records. Even if you prefer the Access-style behavior, you can learn a lot about the _CRecordView_ class by going through the steps in the EX31B example.

Here are the steps for building the EX31B example:

2.  **Run AppWizard to produce \vcpp32\ex31b.** As you move through the AppWizard steps, select Single Document Interface (Step 1 dialog box) and Database View Without File Support (Step 2). In the Step 2 dialog box, also click the Data Source button and choose the ODBC datasource named Student Registration. Choose Dynaset as the Recordset Type, then select the Instructor table. Finally, deselect Printing And Print Preview (Step 4). The options and the default class names are shown below.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/g31og08x.gif)
    
3.  **Add edit controls to the _IDD_EX31B_FORM_ template.** Use the IDs _IDC_ID_, _IDC_NAME_, and _IDC_ROOM_, and position the controls as shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G31OG09.GIF)
    
4.  **Use ClassWizard to link the edit controls to the recordset data members.** To add a data member, click on the Member Variables tab and choose the ID corresponding to the edit box for each variable. Click the Add Variable button, and click the arrow in the Member Variable Name combo box to display a list of variables. Select only the appropriate variable, as shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/g31og10.gif)
    
    When you're finished adding variable names for each edit box, you'll see a screen like the one shown here.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g31og11x.gif)]
    
5.  **Build and test the EX31B application.**You should have a working read-only database application that looks like Figure 31-4. Use the toolbar buttons to sequence through the instructor records.
    
6.  **Back up your database.** Now you're going to include the logic to add, change, and delete records. It's a good idea to make a copy of the STDREG32.MDB file first. That way you have something to refer back to after you delete all the records.
    
7.  **Add menu commands.** Add the following items to the Record pop-up menu in the _IDR_MAINFRAME_ menu. Also, use ClassWizard to map the commands to the specified _CEx31bView_ class members.
    
    **Menu Command**
    
    **Command ID**
    
    **Command Handler**
    
    **Update Command UI Handler**
    
    Add Record
    
    _ID_RECORD_ADD_
    
    _OnRecordAdd_
    
     
    
    Clear Fields
    
    _ID_RECORD_CLEARFIELDS_
    
    _OnRecordClearfields_
    
     
    
    Delete Record
    
    _ID_RECORD_DELETE_
    
    _OnRecordDelete_
    
    _OnUpdateRecordDelete_
    
    Update Record
    
    _ID_RECORD_UPDATE_
    
    _OnRecordUpdate_
    
    _OnUpdateRecordUpdate_
    
8.  **Add and override the _OnMove_ function in the _CEx31bView_ class.** The _CRecordView::OnMove_ function does the work of updating the database when the user moves out of a record. Because we don't want this behavior, we must override the function as follows:
    
    **BOOL CEx31bView::OnMove(UINT nIDMoveCommand) 
    {
        switch (nIDMoveCommand)
        {
        case ID_RECORD_PREV:
            m_pSet->MovePrev();
            if (!m_pSet->IsBOF())
                break;
    
        case ID_RECORD_FIRST:
            m_pSet->MoveFirst();
            break;
    
        case ID_RECORD_NEXT:
            m_pSet->MoveNext();
            if (!m_pSet->IsEOF())
                break;
            if (!m_pSet->CanScroll()) {
                // Clear screen since we're sitting on EOF
                m_pSet->SetFieldNull(NULL);
                break;
            }
    
        case ID_RECORD_LAST:
            m_pSet->MoveLast();
            break;
    
        default:
            // unexpected case value
            ASSERT(FALSE);
        }
    
        // Show results of Move operation
        UpdateData(FALSE);
        return TRUE;
    }**
    
    Also, add the declaration for this overridden function to the ex31bView.h header file.
    
9.  **Edit the menu command handlers.**The following functions call various _CRecordset_ member functions to edit the database. To add a record, you must call _CRecordset::AddNew_, followed by _Update_. To modify a record, you must call _CRecordset::Edit_, followed by _Update_. When you add a new record to the database, you should call _CRecordset::MoveLast_ because the new record is always added to the end of the dynaset.
    
    > NOTE
    > 
    > If you have a sorted recordset (or if your ODBC driver doesn't put added records in the recordset), you should call _CRecordset::Requery_ to completely regenerate the recordset. In that case, there's no convenient way to position the cursor on the newly added record, and that's a basic problem with SQL.
    
    Add the following boldface code:
    
    void CEx31bView::OnRecordAdd()
    {
        **m_pSet->AddNew();
        UpdateData(TRUE);
        if (m_pSet->CanUpdate()) {
            m_pSet->Update();
        }
        if (!m_pSet->IsEOF()) {
            m_pSet->MoveLast();
        }**
        **m_pSet->Requery(); // for sorted sets
        UpdateData(FALSE);**
    }
    
    void CEx31bView::OnRecordClearfields() 
    {
        **m_pSet->SetFieldNull(NULL);
        UpdateData(FALSE);**
    }
    
    void CEx31bView::OnRecordDelete() 
    {
        **CRecordsetStatus status;
        try {
            m_pSet->Delete();
        }
        catch(CDBException\* e) {
            AfxMessageBox(e->m_strError);
            e->Delete();
            m_pSet->MoveFirst(); // lost our place!
            UpdateData(FALSE);
            return;
        }
        m_pSet->GetStatus(status);
        if (status.m_lCurrentRecord == 0) {
            // We deleted last of 2 records
            m_pSet->MoveFirst();
        }
        else {
            m_pSet->MoveNext();
        }
        UpdateData(FALSE);**
    }
    
    void CEx31bView::OnUpdateRecordDelete(CCmdUI\* pCmdUI) 
    {
        **pCmdUI->Enable(!m_pSet->IsEOF());**
    }
    
    void CEx31bView::OnRecordUpdate() 
    {
        **m_pSet->Edit();
        UpdateData(TRUE);
        if (m_pSet->CanUpdate()) {
            m_pSet->Update();
        }
    // should requery if key field changed**
    }
    
    void CEx31bView::OnUpdateRecordUpdate(CCmdUI\* pCmdUI) 
    {
        **pCmdUI->Enable(!m_pSet->IsEOF());**
    }
    
10.  **Build and test the EX31B application again.** Now you can add, change, and delete records. Observe what happens if you try to add a record with a duplicate key. You get an error message that comes from an exception handler inside the framework. You can add try/catch logic in _OnRecordAdd_ to customize the error processing.
________________________________________________________________________
8.1.12. - [Multiple Recordsets](invcpp5/ch31m.htm)
----------------------------------------------------
 Multiple Recordsets 

Multiple Recordsets
===================

Both the EX31A and EX31B examples relied on a single recordset. In many cases, you'll need simultaneous access to multiple recordsets. Suppose you're writing a program that lets the user add Section records, but you want the user to select a valid CourseID and InstructorID. You'll need auxiliary Course and Instructor recordsets in addition to the primary Section recordset.

In the previous examples, the view object contained an embedded recordset that was created with the _CRecordset_ default constructor, which caused the creation of a _CDatabase_ object. The view's _OnInitialUpdate_ function called _CRecordset::Open_, which called the virtual _CRecordset::GetDefaultConnect_ function, opened the database, and then called the virtual _CRecordset::GetDefaultSQL_ function. The problem with this scenario is that there can be only one recordset per database because the database is embedded in the recordset.

To get multiple recordsets, you have to do things differently—you must create the _CDatabase_ object first. Then you can construct as many recordsets as you want, passing a _CDatabase_ pointer as a parameter to the _CRecordset_ constructor. You start by embedding a _CDatabase_ object in the document in place of the _CRecordset_ object. You also include a pointer to the primary recordset. Here are the document data members:

CEx31bSet\* m_pEx31bSet;
CDatabase m_database;

In your overridden _CDocument::OnNewDocument_ function, you construct the primary recordset on the heap, passing the address of the _CDatabase_ object to the recordset constructor. Here's the code you insert:

if (m_pEx31bSet == NULL) {
    m_pEx31bSet = new CEx31bSet(&m_database);
    CString strConnect = m_pEx31bSet->GetDefaultConnect();
    m_database.Open(NULL, FALSE, FALSE, strConnect, FALSE);
}

The _CRecordView::OnInitialUpdate_ function still opens the recordset, but this time _CRecordset::Open_ does not open the database. (It's already open.) Now the code for setting the view's _m_pSet_ data member is a little different:

m_pSet = GetDocument()->m_pEx31bSet;

Figure 31-5 shows the new relationship between the document, the view, and the primary recordset. Also shown are possible auxiliary recordsets.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f31og05x.gif)]

**Figure 31-5.** _Object relationships for multiple recordsets._

The EX31C Multiple Recordset Example
------------------------------------

The EX31C program is similar to EX31B except that the new database_recordset relationships are implemented and an auxiliary recordset allows listing of the sections an instructor teaches. The EX31C window looks like the screen shown below.

Build the EX31C project, and test the application. Sequence through the instructor records, and watch the Sections Taught list change.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g31og12x.gif)]

As you can see, there's a new list-box control in the form dialog box. Also, there's one short helper function in the view class, _LoadListbox_, which loads the list box with the rows in the Section recordset, as shown here:

void CEx31cView::LoadListbox()
{
    CEx31cDoc\* pDoc = GetDocument();
    CListBox\* pLB = (CListBox\*) GetDlgItem(IDC_SECTIONS);
    CSectionSet sect(&pDoc->m_database);  // db passed via constructor

    sect.m_strFilter.Format("InstructorID = \`%s'",
        (LPCSTR) m_pSet->m_InstructorID);

    sect.Open();
    pLB->ResetContent();
    while (!sect.IsEOF()) {
        pLB->AddString(sect.m_CourseID + " " + sect.m_SectionNo);
        sect.MoveNext();
    }
    // sect closed by CRecordset destructor
}

Notice that this function sets up a filter string based on the value of the _InstructorID_ field in the primary recordset. _LoadListbox_ is called from these member functions: _OnInitDialog_, _OnMove_, _OnUpdate_, _OnRecordAdd_, and _OnRecordDelete_.

Parameterized Queries
---------------------

The EX31C example sets up and executes a new query each time it accesses the auxiliary recordset. It's more efficient, however, if you set up a single parameterized query, which enables ODBC to bind to a parameter in your program. You can simply change the value of that parameter and re-execute the query.

Here are the steps for querying the section set for all the sections a selected instructor teaches.

1.  Add a parameter data member to the section recordset class:
    
    **CString m_InstructorIDParam;**
    
2.  Add the following line to the section recordset constructor, which sets the value of the inherited _m_nParams_ data member to the total number of query parameters, in this case 1:
    
    **m_nParams = 1;**
    
3.  Add the following code to the section recordset _DoFieldExchange_ function:
    
    **pFX->SetFieldType(CFieldExchange::param);
    RFX_Text(pFX, "Param", m_InstructorIDParam); // Any name will do**
    
4.  Add the following code to the view class prior to calling _Open_ for the section recordset:
    
    **sect.m_strFilter = "InstructorID = ?";
    sect.m_InstructorIDParam = m_pSet->m_InstructorID;**
________________________________________________________________________
8.1.13. - [ODBC Multithreading](invcpp5/ch31n.htm)
----------------------------------------------------
 ODBC Multithreading 

ODBC Multithreading
===================

ODBC itself supports multithreaded programming, but not all ODBC drivers do. In particular, the Access driver you've used for the preceding examples does not support multithreading, but the Microsoft SQL Server driver does. Even if your ODBC driver does not support multithreading, you can put all your database access code in a worker thread if you want to. (Multithreaded programming and worker threads are described in [Chapter 12](ch12a.htm).)
________________________________________________________________________
8.1.14. - [Bulk Row Fetches](invcpp5/ch31o.htm)
----------------------------------------------------
 Bulk Row Fetches 

Bulk Row Fetches
================

If you're using Microsoft SQL Server or another client_server DBMS, you can speed up your database access by using the bulk row_fetch feature of ODBC that is now supported by the _CRecordset_ class. As the name implies, your program fetches multiple records from the data source instead of only one record at a time. The data source is bound to elements in an array that is attached to an object of a class derived from _CRecordset_. Currently, no MFC support exists for adding, changing, or deleting records from a bulk-fetch_enabled recordset. (See the InfoView article "Recordset: Fetching Records in Bulk (ODBC)" for details.)
________________________________________________________________________
8.1.15. - [Using Recordsets Without Binding](invcpp5/ch31p.htm)
----------------------------------------------------
 Using Recordsets Without Binding 

Using Recordsets Without Binding
================================

All three of the examples in this chapter used recordset classes derived from _CRecordset_. The data members of those classes were bound to database columns at recordset creation time using the ODBC binding mechanism. When the programs called _CRecordset::Move_, the ODBC driver copied data directly from the data source into the data members.

ODBC has always supported unbound data access through the functions _SQLGetData_ and _SQLPutData_. Now the _CRecordset_ class supports read-only unbound data access through its _GetFieldValue_ member function. One overloaded version of this function retrieves the value of a field specified by name and then stores it in an object of class _CDBVariant_. This class is similar to the _COleVariant_ class described in [Chapter 25](ch25a.htm), but it does not use any OLE code and it doesn't have as many overloaded operators and member functions. The _COleVariant_ class has a data member, _m_dwType_, followed by a union. If the type code is DBVT_LONG, for example, you access an integer in the union member _m_lVal_.

You can use _CRecordset::GetFieldValue_ for circumstances in which you don't know the database schema at design time. Your "dynamic database" program constructs an object of class _CRecordset_, and you access the column values with code like this:

void CEx31dView::DrawDataRow(CDC\* pDC, int y)
{
    int x = 0;
    CString strTime, str;
    CEx31dDoc\* pDoc = GetDocument();
    for (int i = 0; i < pDoc->m_nFields; i++) {
        CDBVariant var; // must declare this inside the loop
        m_pSet->GetFieldValue(i, var);
        switch (var.m_dwType) {
        case DBVT_STRING:
            str = \*var.m_pstring; // narrow characters
            break;
        case DBVT_SHORT:
            str.Format("%d", (int) var.m_iVal);
            break;
        case DBVT_LONG:
            str.Format("%d", var.m_lVal);
            break;
        case DBVT_SINGLE:
            str.Format("%10.2f", (double) var.m_fltVal);
            break;
        case DBVT_DOUBLE:
            str.Format("%10.2f", var.m_dblVal);
            break;
        case DBVT_DATE:
            str.Format("%d/%d/%d", var.m_pdate->month, var.m_pdate->day,
                var.m_pdate->year);
            break;
        case DBVT_BOOL:
            str = (var.m_boolVal == 0) ? "FALSE" : "TRUE";
            break;
        case DBVT_NULL:
            str =  "——";
            break;
        default:
            str.Format("Unk type %d\n", var.m_dwType);
            TRACE("Unknown type %d\n", var.m_dwType);
        }
        pDC->TextOut(x, y, str);
        x += pDoc->m_arrayFieldSize[i] \* m_nCharWidth;
    }
}

The code above is excerpted from a sample program EX31D, which is on the CD-ROM included with this book. That program uses the _CRowView_ code from the DAO example, EX32A, described in the [next chapter](ch32a.htm). The programs EX31D and EX32A are similar in architecture and function. EX31D uses ODBC, and EX32A uses DAO.

Although MFC gives you the _CRecordset_ functions _GetODBCFieldCount_ and _GetODBCFieldInfo_ to get field lengths and types, you must call the ODBC function _SQLTables_ to get a "table of tables." The _CTables_ class in the EX31D project encapsulates this table.
________________________________________________________________________
8.2. - [Chapter 32 -- Database Management with Microsoft Data Access Objects](invcpp5/ch32a.htm)
----------------------------------------------------
 Chapter 32 -- Database Management with Microsoft Data Access Objects  Chapter 32

Database Management with Microsoft Data Access Objects
======================================================

In [Chapter 31](ch31a.htm), you saw database management programming with the Microsoft Foundation Class (MFC) Library and Microsoft Open Database Connectivity (ODBC). In this chapter, you'll see a completely different database programming approach—the MFC Data Access Objects (DAO) classes and the underlying DAO software. Actually, the approach is not so different. Instead of the ODBC classes _CDatabase_ and _CRecordset_, you'll be using _CDaoDatabase_ and _CDaoRecordset_. The ODBC and DAO classes are so similar (many member function names are the same) that you can convert ODBC applications, such as the examples in [Chapter 31](ch31a.htm), to DAO applications simply by changing class names and little else. Thus, you can look at DAO as a sort of replacement for ODBC. But as you'll see, DAO goes far beyond ODBC.

This chapter merely scratches the surface of DAO, highlighting its features and outlining the differences between DAO and ODBC. Along the way, it explains the relationships between DAO, COM, the Microsoft Jet database engine, Visual Basic for Applications (VBA), and the MFC library. Finally, it presents a dynamic database example.
________________________________________________________________________
8.2.1. - [DAO, COM, and the Microsoft Jet Database Engine](invcpp5/ch32b.htm)
----------------------------------------------------
 DAO, COM, and the Microsoft Jet Database Engine 

**DAO, COM, and the Microsoft Jet Database Engine**
===================================================

One feature of DAO is a set of COM interfaces, which, like all COM interfaces, are nothing more than specifications—sets of pure virtual function declarations. These interfaces have names such as _DAOWorkspace_, _DAODatabase_, and _DAORecordset_. (Notice that these interface names don't begin with the letter _I_ as do most other interface names.)

The other feature of DAO is the implementation of those interfaces. Microsoft supplies the COM module DAO350.DLL, which connects to the same Jet database engine DLL that serves the Microsoft Access database product. As a Visual C++ developer, you have royalty-free redistribution rights to these DLLs. At the moment, the only DAO implementation available with Jet is DAO350.DLL, but nothing prevents other database software companies from providing their own DAO implementations.
________________________________________________________________________
8.2.2. - [DAO and VBA](invcpp5/ch32c.htm)
----------------------------------------------------
 DAO and VBA 

**DAO and VBA**
===============

In [Chapter 25](ch25a.htm), you learned about Automation. A VBA Automation controller (such as Microsoft Excel or Microsoft Visual Basic) can load any Automation component and then use it to create objects. Once the objects are created, the component can get and set properties and can call methods. The components you created in [Chapter 25](ch25a.htm) all communicated through the COM _IDispatch_ interface. But VBA can use interfaces other than _IDispatch_ to communicate with a component.

If you look in the Windows Registry under HKEY_CLASSES_ROOT-\TypeLib, you'll find the class ID {00025E01-0000-0000-C000-000000000046} and the pathname for DAO350.DLL, which contains the DAO type library. If you select this item as a VBA reference (by pressing Alt-F11 in Excel and then choosing Object Browser from the Visual Basic View menu, for example), your VBA programs can use the DAO objects and you can browse the DAO library, as shown here.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g32og01x.gif)]

Like _IDispatch_ servers, the Microsoft DAO component implements objects that have properties and methods.
________________________________________________________________________
8.2.3. - [DAO and MFC](invcpp5/ch32d.htm)
----------------------------------------------------
 DAO and MFC 

**DAO and MFC**
===============

The MFC library has the following five DAO database classes.

**Class**

**Use**

_CDaoWorkspace_

An interface for managing a single user's database session

_CDaoDatabase_

An interface for working with a database

_CDaoRecordset_

An interface for working with a set of records (such as table-type recordsets, dynaset-type recordsets, or snapshot-type recordsets)

_CDaoTableDef_

An interface for manipulating a definition of a base table or an attached table

_CDaoQueryDef_

An interface for querying a database

These classes more or less wrap the COM interfaces with corresponding names. (_CDaoRecordset_ wraps _DAORecordset_, for example.) The _CDaoWorkspace_ class actually wraps two interfaces, _DAOWorkspace_ and _DAODBEngine_. The MFC wrapping is fairly complete, so you need to make direct COM DAO calls only when you need access to certain database security features. If you use the MFC library, all reference counting is taken care of; if you call DAO directly, you must be sure to call _Release_ on your interfaces.

Both AppWizard and ClassWizard fully support DAO. You can use AppWizard to generate a complete form-based application that works like EX31B in [Chapter 31](ch31a.htm), and you can use ClassWizard to generate a table-specific class that is derived from _CDaoRecordset_.
________________________________________________________________________
8.2.4. - [What Databases Can You Open with DAO?](invcpp5/ch32e.htm)
----------------------------------------------------
 What Databases Can You Open with DAO? 

**What Databases Can You Open with DAO?**
=========================================

The following four database options are supported by DAO:

*   **Opening an Access database (MDB file)**—An MDB file is a self-contained database that includes query definitions, security information, indexes, relationships, and of course the actual data tables. You simply specify the MDB file's pathname.
    
*   **Opening an ODBC data source directly**—There's a significant limitation here. You can't open an ODBC data source that uses the Jet engine as a driver; you can use only data sources that have their own ODBC driver DLLs.
    
*   **Opening an ISAM-type (indexed sequential access method) data source (a group of dBASE, FoxPro, Paradox, Btrieve, Excel, or text files) through the Jet engine**—Even if you've set up an ODBC data source that uses the Jet engine to access one of these file types, you must open the file as an ISAM-type data source, not as an ODBC data source.
    
*   **Attaching external tables to an Access database**—This is actually the preferred way of using DAO to access ODBC data. First you use Access to attach the ODBC tables to an MDB file, and then you use DAO to open the MDB file as in the first option. You can also use Access to attach ISAM files to an MDB file.
________________________________________________________________________
8.2.5. - [Using DAO in ODBC Mode -- Snapshots and Dynasets](invcpp5/ch32f.htm)
----------------------------------------------------
 Using DAO in ODBC Mode -- Snapshots and Dynasets 

**Using DAO in ODBC Mode—Snapshots and Dynasets**
=================================================

You've already heard that DAO goes far beyond ODBC, but let's take things one step at a time. We'll start with DAO snapshots and dynasets, which behave pretty much the same way in DAO as they do in ODBC. You can use snapshots and dynasets with ODBC data sources, ISAM-type files, and Access tables. You write programs using the MFC library classes _CDaoDatabase_ and _CDaoRecordset_, which are very similar to the ODBC classes _CDatabase_ and _CRecordset_. There are a few notable differences, however:

*   The _CDaoRecordset::GetRecordCount_ function works differently from the _CRecordset::GetRecordCount_ function. For attached tables and ODBC data sources, _CDaoRecordset::GetRecordCount_ always returns -1. For Access tables and ISAM-type files, it returns the number of records actually read, which is the final count for the recordset only if you have moved to the last record. Unfortunately, DAO has no equivalent for the ODBC _CRecordset::GetStatus_ function, so you can't test a DAO recordset to find out whether the record count is indeed final.
    
*   With DAO, you can get and set the absolute position of the current record in a dynaset or a snapshot, you can get and set a percent position, you can find a record containing a matching string, and you can use bookmarks to mark records for later retrieval.
    
*   DAO makes it easy to get and set column values without binding. Because values are passed as _VARIANT_s, you can build dynamic applications that adjust to the database schema at runtime.

One important thing to remember about snapshot recordsets is that the record count never changes. With dynasets, the record count changes only if you delete or add records in the dynaset. If another user deletes a record, that record is marked as deleted in your dynaset; if another user adds a record, you don't see that record in your dynaset. If you add a record to a dynaset, that record is added at the end of the dynaset, regardless of the sort order.
________________________________________________________________________
8.2.6. - [DAO Table-Type Recordsets](invcpp5/ch32g.htm)
----------------------------------------------------
 DAO Table-Type Recordsets 

**DAO Table-Type Recordsets**
=============================

DAO introduces a new type of recordset unknown in the ODBC universe. A table-type recordset (supported by the _CDaoRecordset_ class) is a direct view of an entire database table. You can use a table-type recordset only with a table in an Access database. Table-type recordsets have the following characteristics that distinguish them from snapshots and dynasets:

*   The _CDaoRecordset::GetRecordCount_ function returns an approximate record count that reflects records added or deleted by other users.
    
*   You can't use the _CDaoRecordset_ functions that access a record's absolute position or percent position.
    
*   The _CDaoRecordset::Seek_ function lets you position to a record by key value. You first call the _CDaoRecordset::SetCurrentIndex_ function to select the index.
    
*   If you add a record to a table-type recordset, the record is added in its proper place using the sort order that is determined by the current index.

The table-type recordset is a significant departure from ODBC and SQL. You can now select an individual record without first issuing a query. You can find a record with one index and then move sequentially using a different index. It's like dBASE or FoxPro programming!
________________________________________________________________________
8.2.7. - [DAO QueryDefs and TableDefs](invcpp5/ch32h.htm)
----------------------------------------------------
 DAO QueryDefs and TableDefs 

**DAO _QueryDef_s and _TableDef_s**
===================================

If you're working with an Access database, you can store parameterized queries in the database, using the MFC _CDaoQueryDef_ class. Also, you can use the _CDaoTableDef_ class to define tables at runtime, which is more convenient than using a SQL CREATE statement.
________________________________________________________________________
8.2.8. - [DAO Multithreading](invcpp5/ch32i.htm)
----------------------------------------------------
 DAO Multithreading 

**DAO Multithreading**
======================

The Microsoft Access Jet engine is not multithreaded, and that means that DAO is not multithreaded. Furthermore, you must confine all DAO calls to your application's main thread.
________________________________________________________________________
8.2.9. - [Displaying Database Rows in a Scrolling Window](invcpp5/ch32j.htm)
----------------------------------------------------
 Displaying Database Rows in a Scrolling Window 

**Displaying Database Rows in a Scrolling Window**
==================================================

You've seen all the general DAO theory you're going to get here. Now you're ready for a practical example. Before you dig into the code for EX32A, however, you need to study the general problem of displaying database rows in a scrolling window. If this were an easy problem to solve, there would probably be an MFC _CScrollDatabaseView_ class. But there isn't, so we'll write our own class. Actually, it's not that difficult if we make some simplifying assumptions about the database. First, our scrolling row-view class will be based on a dynaset, and that means that it can accommodate any table, including those in ODBC data sources and ISAM-type files. Second, we'll specify read-only access, which means that the number of rows in the dynaset can't change.

**Scrolling Alternatives**
--------------------------

There are lots of ways to implement scrolling with Visual C++. If you look at the DAOVIEW MFC sample database program on the Visual C++ CD-ROM, you'll see the use of the MFC _CListView_ class, which encapsulates the Windows list view common control. The trouble with this approach is that you must copy all the selected rows into the control, which can be slow, and more significantly, you can't see updates that other programs are making in the same table. The list view is a de facto snapshot of a database table.

We'll base our scrolling view on the MFC _CScrollView_ class, and our code will be smart enough to retrieve only those records that are needed for the client area of the window. The only limitation here is the logical size of the scrolling window. In Microsoft Windows 95, the limits are ±32,767, and that restricts the number of rows we can display. If the distance between rows is 14 units, we can display only up to 2340 rows.

**A Row-View Class**
--------------------

If you've read other books about programming for Windows, you know that authors spend lots of time on the problem of scrolling lists. This is a tricky programming exercise that must be repeated over and over. Why not encapsulate a scrolling list in a base class? All the ugly details would be hidden, and you could get on with the business of writing your application.

The _CRowView_ class, adapted from the class of the identical name in the CHKBOOK MFC advanced sample program on the Visual C++ CD-ROM, does the job. Through its use of virtual callback functions, it serves as a model for other derivable base classes. _CRowView_ has some limitations, and it's not built to industrial-strength specifications, but it works well in the DAO example. Figure 32-1 shows the header file listing.

**ROWVIEW.H**

// rowview.h : interface of the CRowView class
//
// This class implements the behavior of a scrolling view that presents
//  multiple rows of fixed-height data. A row view is similar to an
//  owner-draw list box in its visual behavior; but unlike list boxes,
//  a row view has all of the benefits of a view (as well as scroll view),
//  including perhaps most importantly printing and print preview.
/////////////////////////////////////////////////////////////////////////

class CRowView : public CScrollView 
{
DECLARE_DYNAMIC(CRowView)
protected:
// Construction/destruction
    CRowView();
    virtual ~CRowView();

// Attributes
protected:
    int m_nRowWidth;            // width of row in logical units
    int m_nRowHeight;           // height of row in logical units
    int m_nCharWidth;           // avg char width in logical units
    int m_nPrevSelectedRow;     // index of the most recently selected row
    int m_nPrevRowCount;        // most recent row count, before update
    int m_nRowsPerPrintedPage;  // how many rows fit on a printed page

// Operations-Attributes
protected:
    virtual void UpdateRow(int nInvalidRow); // called by derived class 
                                             //  OnUpdate
    virtual void CalculateRowMetrics(CDC\* pDC)
        { GetRowWidthHeight(pDC, m_nRowWidth, m_nRowHeight,
            m_nCharWidth); }
    virtual void UpdateScrollSizes();
    virtual CRect RowToWndRect(CDC\* pDC, int nRow);

virtual int RowToYPos(int nRow);
    virtual void RectLPtoRowRange(const CRect& rectLP, int& nFirstRow,
        int& nLastRow, BOOL bIncludePartiallyShownRows);
    virtual int LastViewableRow();

// Overridables
protected:
    virtual void GetRowWidthHeight(CDC\* pDC, int& nRowWidth, 
        int& nRowHeight, int& nCharWidth) = 0;
    virtual int GetActiveRow() = 0;
    virtual int GetRowCount() = 0;
    virtual void OnDrawRow(CDC\* pDC, int nRow, int y, BOOL bSelected) = 0;
    virtual void ChangeSelectionNextRow(BOOL bNext) = 0;
    virtual void ChangeSelectionToRow(int nRow) = 0;

// Implementation
protected:
    // standard overrides of MFC classes
    virtual void OnInitialUpdate();
    virtual void OnDraw(CDC\* pDC);  // overridden to draw this view
    virtual void OnPrepareDC(CDC\* pDC, CPrintInfo\* pInfo = NULL);
    virtual BOOL OnPreparePrinting(CPrintInfo\* pInfo);
    virtual void OnBeginPrinting(CDC\* pDC, CPrintInfo\* pInfo);
    virtual void OnPrint(CDC\* pDC, CPrintInfo\* pInfo);

// Generated message map functions
protected:
    //{{AFX_MSG(CRowView)
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

**Figure 32-1.** _The_ CRowView _header file listing._

**Dividing the Work Between Base and Derived Classes**
------------------------------------------------------

Because the _CRowView_ class (itself derived from _CScrollView_) is designed to be a base class, it is as general as possible. _CRowView_ relies on its derived class to access and paint the row's data. The EX32A example's document class obtains its row data from a scrollable DAO database, but the CHKBOOK example uses a random access disk file. The _CRowView_ class serves both examples effectively. It supports the concept of a selected row that is highlighted in the view. Through the _CRowView_ virtual member functions, the derived class is alerted when the user changes the selected row.

**The _CRowView_ Pure Virtual Member Functions**
------------------------------------------------

Classes derived from _CRowView_ must implement the following pure virtual member functions:

*   **_GetRowWidthHeight_**—This function returns the character width and height of the currently selected font and the width of the row, based on average character widths. As the device context switches between printer and display, the returned font metric values change accordingly.
    
*   **_GetActiveRow_**—The base class calls this function frequently, so if another view changes the selected row, this view can track it.
    
*   **_ChangeSelectionNextRow_, _ChangeSelectionToRow_**—These two functions serve to alert the derived class that the user has changed the selected row. The derived class can then update the document (and other views) if necessary.
    
*   **_OnDrawRow_**—The _OnDrawRow_ function is called by the function _CRowView::OnDraw_ to draw a specific row.

**Other _CRowView_ Functions**
------------------------------

Three other _CRowView_ functions are available to be called by derived classes and the application framework:

*   **_UpdateRow_**—This public function triggers a view update when the row selection changes. Normally, only the newly selected row and the deselected row are invalidated, and this means that the final invalid rectangle spans both rows. If the total number of rows has changed, _UpdateRow_ calls _UpdateScrollSizes_.
    
*   **_UpdateScrollSizes_**—This is a virtual function, so you can override it if necessary. The _CRowView_ implementation updates the size of the view, which invalidates the visible portion. _UpdateScrollSizes_ is called by _OnSize_ and by _OnUpdate_ (after the user executes a new query).
    
*   **_OnPrint_**—The _CRowView_ class overrides this function to cleverly adjust the viewport origin and clipping rectangle so that _OnDraw_ can paint on the printed page exactly as it does in the visible portion of a window.

> **The MFC Dialog Bar**
> 
> You haven't seen the _CDialogBar_ class yet because it hasn't made sense to use it. (A dialog bar is a child of the frame window that is arranged according to a dialog template resource and that routes commands in a manner similar to that of a toolbar.) It fits well in the DAO example, however. (See Figure 32-2.) The dialog bar contains an edit control for the SQL query string, and it has a pushbutton to re-execute the query. The button sends a command message that can be handled in the view, and it can be disabled by an update command UI handler. Most dialog bars reside at the top of the frame window, immediately under the toolbar. It's surprisingly easy to add a dialog bar to an application. You don't even need a new derived class. Here are the steps:
> 
> 2.  Use the resource editor to lay out the dialog bar. Apply the following styles:
>     
>     Style = Child
>     
>     Border = None
>     
>     Visible = Unchecked
>     
>     You can choose a horizontally oriented bar for the top or bottom of the frame, or you can choose a vertically oriented bar for the left or right side of the frame. Add any controls you need, including buttons and edit controls.
>     
> 3.  Declare an embedded _CDialogBar_ object in your derived main frame class declaration, as shown here:
>     
>     CDialogBar m_wndMyBar;
>     
> 4.  Add dialog bar object creation code to your main frame class _OnCreate_ member function, as shown here:
>     
>     if (!m_wndMyBar.Create(this, IDD_MY_BAR, CBRS_TOP, 
>         ID_MY_BAR)) {
>         TRACE("Failed to create dialog bar\n");
>         return -1;
>     }
>     
> 
> _IDD_MY_BAR_ is the dialog resource ID assigned in the resource editor. The _CBRS_TOP_ style tells the application framework to place the dialog bar at the top of the frame window. _ID_MY_BAR_ is the dialog bar's control window ID, which should be within the range 0xE800 through 0xE820 to ensure that the Print Preview window preempts the dialog bar.
________________________________________________________________________
8.2.10. - [Programming a Dynamic Recordset](invcpp5/ch32k.htm)
----------------------------------------------------
 Programming a Dynamic Recordset 

**Programming a Dynamic Recordset**
===================================

If you use AppWizard to create a DAO database application, AppWizard generates a class derived from _CDaoRecordset_ with a _DoFieldExchange_ function that binds data members to the columns in a specific database table. For a dyna-mic recordset class, however, you need to determine the column names and data types at runtime. The EX31A example shows how to do this with ODBC.

With DAO, the procedure is similar. You simply construct a _CDaoRecordset_ object and call the _GetFieldValue_ member function, which returns a _VARIANT_ representing the column value. Other member functions tell you the number of columns in the table and the name, type, and width of each column.

> NOTE
> 
> If a field _VARIANT_ contains a _BSTR_, assume the string contains 8-bit characters. This is an exception to the rule that all _BSTR_s contain wide characters.
________________________________________________________________________
8.2.11. - [The EX32A Example](invcpp5/ch32l.htm)
----------------------------------------------------
 The EX32A Example 

**The EX32A Example**
=====================

Now we'll put everything together and build another working program—an MDI application that connects to any DAO data source. The application dynamically displays tables in scrolling view windows, and it allows the user to type in the SQL QUERY statement, which is stored in the document along with data source and table information. AppWizard generates the usual MDI main frame, document, application, and view classes, and we change the view class base to _CRowView_ and add the DAO-specific code. Figure 32-2 shows the EX32A program in operation.

The document's File menu includes the following commands:

> DAO Open MDB
> 
> DAO Open ISAM
> 
> DAO Open ODBC

The user must choose one of these commands after opening a document. As you will see, the code for opening the database is different depending on the data source type.

You can learn a lot about this application by looking at the three-view window in Figure 32-2. The two view windows in the upper part of the main window are tied to the same document, and the lower view window is tied to another document. The dialog bar shows the SQL statement associated with the active view window.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f32og02x.gif)]

**Figure 32-2.** _The EX32A program in operation._

The EX32A example includes source code listings and resource requirements. Here is a table of the files and classes.

**Header File**

**Source Code File**

**Class**

**Description**

Ex32a.h

Ex32a.cpp

_CEx32aApp_

Main application

MainFrm.h

MainFrm.cpp

_CMainFrame_

MDI main frame

ChildFrm.h

ChildFrm.cpp

_CChildFrame_

MDI child frame

Ex32aDoc.h

Ex32aDoc.cpp

_CEx32aDoc_

EX32A document

Ex32aView.h

Ex32aView.cpp

_CEx32aView_

Scrolling database view class

Rowview.h

Rowview.cpp

_CRowView_

Row view base class

Tablesel.h

Tablesel.cpp

_CTableSelect_

Table selection dialog class

IsamSelect.h

IsamSelect.cpp

_CIsamSelect_

ISAM-type data source selection dialog class

StdAfx.h

StdAfx.cpp

Precompiled headers

Now we'll go through the application's classes one at a time, excluding _CRowView_. You'll see the important data members and the principal member functions.

**_CEx32aApp_**
---------------

The application class is the unmodified output from AppWizard. Nothing special here.

**_CMainFrame_ and _CChildFrame_**
----------------------------------

These classes are the standard output from AppWizard except for the addition of the dialog bar created in the _CMainFrame::OnCreate_ member function.

**_CEx32aDoc_**
---------------

The document class manages the database connections and recordsets. Each document object can support one main recordset attached to one data source. A document object can have several views attached. Data sources (represented by _CDaoDatabase_ objects) are not shared among document objects; each document has its own.

### **Data Members**

The important _CEx32aDoc_ data members are listed in the following table.

**Data Member**

**Description**

_m_pRecordset_

Pointer to the document's recordset object

_m_database_

Document's embedded _CDaoDatabase_ object

_m_strDatabase_

Database pathname (MDB file)

_m_strConnect_

ODBC connection string or ISAM connection string

_m_strQuery_

Entire SQL SELECT statement

_m_bConnected_

Flag that is _TRUE_ when the document is connected to a recordset

_m_nFields_

Number of fields (columns) in the recordset

_m_nRowCount_

Number of records (rows) in the recordset

_m_nDatabaseType_

_enum {UNK, MDB, ISAM, ODBC}_

### **_OnOpenDocument_**

This overridden _CDocument_ function is called when the user loads a document from disk. The document contains the name of the database and the query string, so the program can open the database and run the query upon loading.

BOOL CEx32aDoc::OnOpenDocument(LPCTSTR lpszPathName) 
{
    if (!CDocument::OnOpenDocument(lpszPathName))
        return FALSE;
    PutQuery();
    switch (m_nDatabaseType) {
    case UNK:
        break;
    case MDB:
        DaoOpenMdb();
        break;
    case ISAM:
        DaoOpenIsam();
        break;
    case ODBC:
        DaoOpenOdbc();
        break;
    }
    return TRUE;
}

### **_OnCloseDocument_**

This overridden _CDocument_ function closes the database if one is connected:

void CEx32aDoc::OnCloseDocument() 
{
    m_strQuery.Empty();
    PutQuery();
    if (m_bConnected) {
        delete m_pRecordset; // Destructor calls Close
        m_database.Close();
        m_bConnected = FALSE;
        m_pRecordset = NULL;
        m_nRowCount = 0;
    }
    CDocument::OnCloseDocument();
}

### **_OnFileDaoOpenOdbc_ and _DaoOpenOdbc_**

These functions are called in response to the user choosing the DAO Open ODBC command from the File menu. _DaoOpenOdbc_, which is also called by _OnOpenDocument_, calls _CDaoDatabase::Open_ with the connect parameter string. The string _"ODBC;"_ causes the ODBC data source selection dialog to be displayed. Notice the use of the _try_/_catch_ block to detect SQL processing errors.

void CEx32aDoc::OnFileDaoOpenOdbc()
{
    m_strConnect.Empty();
    m_strQuery.Empty();
    DaoOpenOdbc();
}

void CEx32aDoc::DaoOpenOdbc()
{
    // can't open ODBC using Access driver
    if (m_strConnect.IsEmpty()) {
        m_strConnect = "ODBC;";
    }
    BeginWaitCursor();
    try {
        // nonexclusive, read-only
        m_database.Open("", FALSE, TRUE, m_strConnect);
    }
    catch (CDaoException\* e) {
        ::DaoErrorMsg(e);
        EndWaitCursor();
        e->Delete();
        return;
    }
    m_strConnect = m_database.GetConnect();
    TRACE("database name = %s, connect = %s\n",
         (const char\*) m_strDatabase,
         (const char\*) m_strConnect);
    OpenRecordset();
    m_nDatabaseType = ODBC;
    EndWaitCursor();
}

### **_OnFileDaoOpenIsam_ and _DaoOpenIsam_**

These functions are called in response to the user choosing the DAO Open ISAM command from the File menu. _DaoOpenIsam_, which is also called by _OnOpenDocument_, gets a directory name from the user (through the _CIsamSelect_ class) and then calls _CDaoDatabase::Open_ with the connect parameter string. The _CIsamSelect::m_strIsam_ string specifies the type of file. Example strings are _"dBASE III"_, _"FoxPro 2.6"_, and _"Excel 8.0"_.

void CEx32aDoc::OnFileDaoOpenIsam() 
{
    m_strConnect.Empty();
    m_strQuery.Empty();
    DaoOpenIsam();
}

void CEx32aDoc::DaoOpenIsam() 
{
    BeginWaitCursor();
    if (m_strConnect.IsEmpty()) {
        CIsamSelect isamDlg;
        if (isamDlg.DoModal() != IDOK) {
            return;
        }
        m_strConnect = isamDlg.m_strIsam + ";DATABASE=" +
            isamDlg.m_strDirectory;
        TRACE("m_strConnect = %s\n", (const char\*) m_strConnect);
    }
    try {
        // nonexclusive, read-only
        m_database.Open("", FALSE, TRUE, m_strConnect);
    }
    catch(CDaoException\* e) {
        ::DaoErrorMsg(e);
        EndWaitCursor();
        e->Delete();
        return;
    }
    m_strConnect = m_database.GetConnect();
    TRACE("database name = %s, connect = %s\n",
         (const char\*) m_strDatabase, (const char\*) m_strConnect);
    OpenRecordset();
    m_nDatabaseType = ISAM;
    EndWaitCursor();
}

### **_OnFileDaoOpenMdb_ and _DaoOpenMdb_**

These functions are called in response to the user choosing the DAO Open MDB command from the File menu. _DaoOpenMdb_, which is also called by _OnOpenDocument_, uses the MFC _CFileDialog_ class to get an MDB file pathname from the user. Compare the _CDaoDatabase::Open_ call with the calls in the two preceding functions. Notice that the MDB pathname is passed as the first parameter.

void CEx32aDoc::OnFileDaoOpenMdb()
{
    m_strDatabase.Empty();
    m_strQuery.Empty();
    DaoOpenMdb();
}

void CEx32aDoc::DaoOpenMdb()
{
    if (m_strDatabase.IsEmpty()) {
        CFileDialog dlg(TRUE, ".mdb", "\*.mdb");
        if (dlg.DoModal() == IDCANCEL) return;
        m_strDatabase = dlg.GetPathName();
    }
    BeginWaitCursor();
    try {
        // nonexclusive, read-only
        m_database.Open(m_strDatabase, FALSE, TRUE);
    }
    catch (CDaoException\* e) {
        ::DaoErrorMsg(e);
        EndWaitCursor();
        e->Delete();
        return;
    }
    m_strDatabase = m_database.GetName();
    TRACE("database name = %s, connect = %s\n",
         (const char\*) m_strDatabase, (const char\*) m_strConnect);
    OpenRecordset();
    m_nDatabaseType = MDB;
    EndWaitCursor();
}

### **_OnFileDaoDisconnect_**

This function closes the DAO database, enabling the document to be saved.

void CEx32aDoc::OnFileDaoDisconnect() 
{
    if (m_bConnected) {
        delete m_pRecordset; // Destructor calls Close
        m_database.Close();
        m_bConnected = FALSE;
        m_pRecordset = NULL;
        m_nRowCount = 0;
        UpdateAllViews(NULL);
    }
}

### **_OpenRecordset_**

This helper function is called by _DaoOpenOdbc_, _DaoOpenIsam_, and _DaoOpenMdb_. The _CTableSelect_ class allows the user to select a table name, which is used to construct a SELECT statement. Calls to _CDaoRecordset::MoveLast_ and _CDaoRecordset::GetAbsolutePosition_ set the record count for ODBC, ISAM, and MDB data sources.

void CEx32aDoc::OpenRecordset()
{
    GetQuery();
    if (m_strQuery.IsEmpty()) {
        CTableSelect tableDlg(&m_database);
        if (tableDlg.DoModal() != IDOK) {
            m_database.Close();  // escape route
            return;
        }
        m_strQuery.Format("select \* from [%s]", tableDlg.m_strSelection);
        PutQuery();
    }

    m_pRecordset = new CDaoRecordset(&m_database);
    try {    
        m_pRecordset->Open(dbOpenDynaset, m_strQuery, dbReadOnly);
    }
    catch (CDaoException\* e) {
        ::DaoErrorMsg(e);
        UpdateAllViews(NULL);
        m_bConnected = FALSE;
        e->Delete();
        return;
    }
    if (!m_pRecordset->IsBOF()) {
        // might be expensive for a really big table
        // View adjusts its m_nRowCount if you supply a big value here
        m_pRecordset->MoveLast(); // to validate record count
    }
    m_nRowCount = m_pRecordset->GetAbsolutePosition() + 2;
    TRACE("m_nRowCount = %d\n", m_nRowCount);
    GetFieldSpecs();
    UpdateAllViews(NULL);
    m_bConnected = TRUE;
}

> NOTE
> 
> The MFC _CDaoRecordset_ class has _m_strFilter_ and _m_strSort_ data members, as does the ODBC _CRecordset_ class. You can't use these strings, however, if your recordset doesn't have bound fields; you must construct the entire SELECT statement as shown above.

### **_OnRequery_**

This message handler is called in response to the user clicking the Requery button on the dialog bar. This message handler reads the query string value and regenerates the recordset. Note that the _CDaoRecordset::Requery_ function doesn't handle an updated SELECT statement, so we close and reopen the recordset instead.

void CEx32aDoc::OnRequery()
{ 
    GetQuery();
    // Requery won't work because we're changing the SQL statement
    BeginWaitCursor();
    if(m_pRecordset->IsOpen()) {
        m_pRecordset->Close();
    }
    try {    
        m_pRecordset->Open(dbOpenDynaset, m_strQuery, dbReadOnly);
    }
    catch (CDaoException\* e) {
        ::DaoErrorMsg(e);
        m_nRowCount = 0;
        UpdateAllViews(NULL);
        EndWaitCursor();
        e->Delete();
        return;
    }
    if (!m_pRecordset->IsBOF()) {
        m_pRecordset->MoveLast(); // to validate record count
    }
    m_nRowCount = m_pRecordset->GetAbsolutePosition() + 2;
    TRACE("m_nRowCount = %d\n", m_nRowCount);
    GetFieldSpecs();
    UpdateAllViews(NULL); 
    EndWaitCursor();
}

### **_PutQuery_ and _GetQuery_**

These utility functions move the document's query string to and from the edit control on the dialog bar.

### **_Serialize_**

The _Serialize_ function reads and writes the _m_strConnect_, _m_strDatabase_, and _m_strQuery_ data members.

**_CEx32aView_**
----------------

This class is derived from _CRowView_ and implements the virtual functions.

### **Data Members**

The _CEx32aView_ class uses the integer variable _m_nSelectedRow_ to track the currently selected row. The recordset pointer is held in _m_pSet_.

### **_OnUpdate_**

This virtual _CView_ function is called through the application framework when the view is created and when the document's contents change in response to a database open or requery event. If several views are active for a given document, all views reflect the current query but each can maintain its own current row and scroll position. _OnUpdate_ also sets the value of the _m_pSet_ data member. This can't be done in _OnInitialUpdate_ because the recordset is not open at that point.

### **_GetRowWidthHeight_, _GetActiveRow_,  
_ChangeSelectionNextRow_, and _ChangeSelectionToRow_**

These functions are implementations of the _CRowView_ class pure virtual functions. They take care of drawing a specified query result row, and they track the current selection.

### **_GetRowCount_**

This virtual function, which is called from _CRowView_, simply returns the record count value stored in the document.

### **_OnDrawRow_ and _DrawDataRow_**

The _OnDrawRow_ virtual function is called from _CRowView_ member functions to perform the actual work of drawing a designated row. _OnDrawRow_ reads the recordset's current row and then calls the _CDaoRecordset::Move_ function to position the cursor and read the data. The _try_/_catch_ block detects catastrophic errors resulting from unreadable data. The _DrawDataRow_ helper function steps through the columns and prints the values. Notice that _OnDrawRow_ displays "\*\*RECORD DELETED\*\*" when it encounters a record that has been deleted by another user since the dynaset was first created. _OnDrawRow_ and _DrawDataRow_ are shown here:

void CEx32aView::OnDrawRow(CDC\* pDC, int nRow, int y, BOOL bSelected)
{
    int x = 0;
    int i;
    CEx32aDoc\* pDoc = GetDocument();

    if (m_pSet == NULL) return;
    
    if (nRow == 0) {    // title row
        for (i = 0; i < pDoc->m_nFields; i++) {
            pDC->TextOut(x, y, pDoc->m_arrayFieldName[i]);
            x += pDoc->m_arrayFieldSize[i] \* m_nCharWidth;
        }    
    }
    else {
        try {
            m_pSet->SetAbsolutePosition(nRow - 1);
            // adjust for title row
            // SetAbsolutePosition doesn't throw exception until AFTER  
            //  end of set
            if (m_pSet->GetAbsolutePosition() == (nRow - 1)) {
                DrawDataRow(pDC, y);
            }
        }
        catch (CDaoException\* e) {
            // might be a time delay before delete is seen in this program
            if (e->m_pErrorInfo->m_lErrorCode == 3167) {
                pDC->TextOut(0, y, "\*\*RECORD DELETED\*\*");
            }
            else {
                m_pSet->MoveLast(); // in case m_nRowCount is too big
                pDoc->m_nRowCount = m_pSet->GetAbsolutePosition() + 2;
            }
            e->Delete();
        }
    }
}

void CEx32aView::DrawDataRow(CDC\* pDC, int y)
{
    int x = 0;
    CString strTime;

    COleVariant var;
    CString str;
    CEx32aDoc\* pDoc = GetDocument();
    for (int i = 0; i < pDoc->m_nFields; i++) {
        var = m_pSet->GetFieldValue(i);
        switch (var.vt) {
            case VT_BSTR:
                str = (LPCSTR) var.bstrVal; // narrow characters in DAO
                break;



            case VT_I2:
                str.Format("%d", (int) var.iVal);
                break;
            case VT_I4:
                str.Format("%d", var.lVal);
                break;
            case VT_R4:
                str.Format("%10.2f", (double) var.fltVal);
                break;
            case VT_R8:
                str.Format("%10.2f", var.dblVal);
                break;
            case VT_CY:
                str = COleCurrency(var).Format();
                break;
            case VT_DATE:
                str = COleDateTime(var).Format();
                break;
            case VT_BOOL:
                str = (var.boolVal == 0) ? "FALSE" : "TRUE";
                break;
            case VT_NULL:
                str =  "----";
                break;
            default:
                str.Format("Unk type %d\n", var.vt);
                TRACE("Unknown type %d\n", var.vt);
            }
        pDC->TextOut(x, y, str);
        x += pDoc->m_arrayFieldSize[i] \* m_nCharWidth;
    }
}

### **_OnInitialUpdate_ and _OnTimer_**

Because we're working with a dynaset, we want to show database changes made by other programs. The timer handler calls _CWnd::Invalidate_, which causes all records in the client area to be refreshed, as shown here:

void CEx32aView::OnInitialUpdate() 
{
    CRowView::OnInitialUpdate(); 
}

void CEx32aView::OnTimer(UINT nIDEvent) 
{
    Invalidate(); // Update view from database
}

**_CTableSelect_**
------------------

This is a ClassWizard-generated dialog class that contains a list box used for selecting the table. For the student registration database, the dialog looks like the one shown below.

![](c:/dl/books/windows/msvc5th/invcpp5/images/g32og02.gif)

### **Data Members**

The _CTableSelect_ data members are as follows.

**Data Member**

**Description**

_m_pDatabase_

Pointer to the recordset's _CDaoDatabase_ object

_m_strSelection_

ClassWizard-generated variable that corresponds to the list-box selection

### **Constructor**

The constructor takes a database pointer parameter, which it uses to set the _m_pDatabase_ data member, as shown here:

CTableSelect::CTableSelect(CDaoDatabase\* pDatabase,
    CWnd\* pParent /\*=NULL\*/)
    : CDialog(CTableSelect::IDD, pParent)
{
    //{{AFX_DATA_INIT(CTableSelect)
    m_strSelection = "";
    //}}AFX_DATA_INIT
    m_pDatabase = pDatabase;
}

### **_OnInitDialog_**

This self-contained function creates, opens, and reads the data source's list of tables and puts the table name strings in the dialog's list box, as shown here:

BOOL CTableSelect::OnInitDialog()
{
    CListBox\* pLB = (CListBox\*) GetDlgItem(IDC_LIST1);
    int nTables = m_pDatabase->GetTableDefCount();
    TRACE("CTableSelect::OnInitDialog, nTables = %d\n", nTables);
    CDaoTableDefInfo tdi;
    for (int n = 0; n < nTables; n++) {
        m_pDatabase->GetTableDefInfo(n, tdi);
        TRACE("table name = %s\n", (const char\*) tdi.m_strName);
        if (tdi.m_strName.Left(4) != "MSys") {
            pLB->AddString(tdi.m_strName);
        }
    }
    return CDialog::OnInitDialog();
}

### **_OnDblclkList1_**

It's handy for the user to choose a list-box entry with a double click. This function is mapped to the appropriate list-box notification message, as shown here:

void CTableSelect::OnDblclkList1()
{
    OnOK();  // Double-clicking on list-box item exits dialog
}

**_CIsamSelect_**
-----------------

This ClassWizard-generated dialog class contains a list box and an edit control used for selecting the ISAM-type data source. The user must type the directory for the files, as shown here.

![](c:/dl/books/windows/msvc5th/invcpp5/images/g32og03.gif)

### **Data Members**

The _CIsamSelect_ class data members are as follows.

**Data Member**

**Definition**

_m_strIsam_

ClassWizard-generated variable that corresponds to the list-box selection

_m_strDirectory_

ClassWizard-generated variable that corresponds to the edit control contents

### **_OnInitDialog_**

This function sets the initial values of the list box, which are the options from the "Connect Property" topic in Books Online, as shown here:

BOOL CIsamSelect::OnInitDialog() 
{
    CListBox\* pLB = (CListBox\*) GetDlgItem(IDC_LIST1);
    pLB->AddString("dBASE III");
    pLB->AddString("dBASE IV");
    pLB->AddString("dBASE 5");
    pLB->AddString("Paradox 3.x");
    pLB->AddString("Paradox 4.x");
    pLB->AddString("Paradox 5.x");
    pLB->AddString("Btrieve");
    pLB->AddString("FoxPro 2.0");
    pLB->AddString("FoxPro 2.5");
    pLB->AddString("FoxPro 2.6");
    pLB->AddString("Excel 3.0");
    pLB->AddString("Excel 4.0");
    pLB->AddString("Excel 5.0");
    pLB->AddString("Excel 7.0");
    pLB->AddString("Text");
    CDialog::OnInitDialog();
    
    return TRUE;  // Return TRUE unless you set the focus to a control.
                  // EXCEPTION: OCX Property Pages should return FALSE.
}
________________________________________________________________________
8.2.12. - [The EX32A Resource File](invcpp5/ch32m.htm)
----------------------------------------------------
 The EX32A Resource File 

**The EX32A Resource File**
===========================

This application uses a dialog bar, so you'll need a dialog resource for it. Figure 32-2 shows the dialog bar. The dialog resource ID is _IDD_QUERY_BAR_. The controls are listed below.

**Control**

**ID**

Button

_IDC_REQUERY_

Edit

_IDC_QUERY_

The following styles are set:

> Style = Child
> 
> Border = None
> 
> Visible = Unchecked

There's also a table selection dialog template, _IDD_TABLE_SELECT_, which has a list-box control with ID _IDC_LIST1_ and an ISAM selection dialog template, _IDD_ISAM_SELECT_. The File menu has the following four added items.

**Menu Item**

**Command ID**

DAO Open MDB

_ID_FILE_DAOOPEN_MDB_

DAO Open ISAM

_ID_FILE_DAOOPEN_ISAM_

DAO Open ODBC

_ID_FILE_DAOOPEN_ODBC_

DAO Disconnect

_ID_FILE_DAODISCONNECT_
________________________________________________________________________
8.2.13. - [Running the EX32A Program](invcpp5/ch32n.htm)
----------------------------------------------------
 Running the EX32A Program 

**Running the EX32A Program**
=============================

You can run the EX32A program with any DAO data source, but try the student registration database (STDREG32.MDB) from the Visual C++ CD-ROM first. To test the multiuser capabilities of the program, run it simultaneously with EX31B. Use EX31B to change and delete instructor records while displaying the instructor table in EX32A.
________________________________________________________________________
8.3. - [Chapter 33 -- The OLE DB Templates](invcpp5/ch33a.htm)
----------------------------------------------------
 Chapter 33 -- The OLE DB Templates  Chapter 33

The OLE DB Templates
====================

[Chapter 31](ch31a.htm) and [Chapter 32](ch32a.htm) covered two alternative ways to manage databases using the Microsoft Foundation Class Library version 6.0 and Microsoft Visual C++ 6.0—using ODBC and using DAO. Microsoft has defined another way to access data—through a technology called OLE DB. This chapter covers the new OLE DB templates—Visual C++ 6.0's support for accessing data through OLE DB directly. While ODBC is designed to provide access primarily to Structured Query Language (SQL) data in a multiplatform environment, OLE DB is designed to provide access to all types of data within a system. OLE DB uses the Component Object Model (COM) to accomplish this. OLE DB is fairly flexible: it covers all the SQL functionality defined in ODBC as well as defining interfaces suitable for gaining access to other-than-SQL types of data.

This chapter covers the highlights of the new OLE DB templates. OLE DB data access is divided into two major pieces: consumers and providers. We'll take a look at the basic OLE DB architecture and then examine how the consumer templates work. Then we'll look at how the provider side templates work.
________________________________________________________________________
8.3.1. - [Why OLE DB?](invcpp5/ch33b.htm)
----------------------------------------------------
 Why OLE DB? 

Why OLE DB?
===========

OLE DB exists to provide a uniform way to access all sorts of disparate data sources. For example, imagine all the types of data sources you might find in a typical organization. These might include sources as varied as production systems, file systems, spreadsheets, personal databases (such as Xbase and Btrieve), and e-mail. The problem is that each of these sources requires its own protocol: if you want to access data from a specific source, you need to learn the protocol for managing the data source. (ugh!) OLE DB is the middle layer that makes accessing data from different sources uniform. With OLE DB, client-side developers need to concentrate on only a few details to get access to data (instead of needing to know tons of different database access protocols).

The most important thing to realize about OLE DB is that it is built upon COM. In other words, OLE DB is a set of ActiveX interfaces for accessing data through COM. The OLE DB interfaces are general enough to provide a uniform means of accessing data, regardless of the method that is used to store the data. For example, developers use the same OLE DB interfaces to get to data without being concerned as to whether data is stored in a DBMS or a non-DBMS information source. At the same time, OLE DB lets developers continue to take advantage of the benefits of the underlying database technology (like speed and flexibility) without having to move data around just to access those benefits.

At the highest level, the OLE DB architecture consists of consumers and providers. A consumer is any bit of system or application code that uses an OLE DB interface. This includes OLE DB components themselves. A provider is any software component that exposes an OLE DB interface.

There are two types of OLE DB providers: data providers and service providers. The names are pretty self-explanatory. Data providers own data and expose that data in a tabular form as a rowset. (A rowset is just an abstraction for exposing data in a tabular form.) Some good examples of data providers include relational Database Management Systems (DBMS's), storage managers, spreadsheets, and Indexed Sequential Access Method (ISAM) databases.

A service provider is any OLE DB component that does not own data but encapsulates some service by massaging data through OLE DB interfaces. In one sense, a service component is both a consumer and a provider. For example, a heterogeneous query processor is a service component. In one case where a consumer tries to join data from tables in two different data sources, as a consumer the query processor retrieves rows from rowsets created over each of the base tables. As a provider, the query processor creates a rowset from these rows and returns it to the consumer.

To sum up, there are many different kinds of data and numerous ways of accessing that data in the real world. However, many developers understand how to manipulate data using standard database-management techniques. OLE DB defines an architecture that "component-izes" data access. As a component database-management system, OLE DB offers greater efficiency than traditional database-management systems by separating database functionality into the roles of consumers and producers. Because data consumers generally require only a portion of the database-management functionality, OLE DB separates that functionality, thereby reducing client-side resource overhead.

By the same token, OLE DB reduces the burden on the provider side, since providers need to worry only about providing data (and don't have to concern themselves with any client-side junk). For example, OLE DB allows a simple tabular data provider to implement functionality native to its data store yet provide a singular access protocol to get to the data. That way, a minimal implementation of a provider can choose to use only the interfaces that expose data as tables. This opens up the opportunity for the development of completely different query-processor components that can consume tabular information from any provider that exposes its data through OLE DB. In addition, SQL DBMS's can expose their functionality in a more layered manner by using the OLE DB interfaces.
________________________________________________________________________
8.3.2. - [Basic OLE DB Architecture](invcpp5/ch33c.htm)
----------------------------------------------------
 Basic OLE DB Architecture 

Basic OLE DB Architecture
=========================

In addition to defining a basic relationship between consumers and providers, OLE DB defines the following components that make up the OLE DB architecture (each component is a COM object):

*   **Enumerators** Enumerators search for available data sources. Consumers that are not hardwired for a particular data source employ enumerators to search for a data source to use.
    
*   **Data source objects** Data source objects contain the machinery to connect to a data source, such as a file or a DBMS. A data source object generates sessions.
    
*   **Sessions** Sessions represent connections to a database. For example, sessions provide a context for database transactions. A single data source object can create multiple sessions. Sessions generate transactions, commands, and rowsets.
    
*   **Transaction objects** Transaction objects are used for managing database transactions in order to maintain database security.
    
*   **Commands** Commands execute text commands, such as a SQL statement. If the text command specifies a rowset, such as a SQL SELECT statement, the command generates rowsets. A single session can create multiple commands.
    
*   **Rowsets** Rowsets expose data in a tabular format. A special case of a rowset is an index. Rowsets can be created from the session or the command.
    
*   **Errors** Errors can be created by any interface on any OLE DB object. They contain additional information about an error, including an optional custom error object.

Here's an example of how you might apply these components to create an OLE DB consumer. If you aren't sure where the data source is, you might first use an enumerator to find a data source. Once you've located a data source, you create a session with it. The session lets you access the data as rowsets as well as create commands that generate rowsets.

The upside of using the OLE DB architecture is that you get a terrific, homogenous way to access heterogeneous data sources. The downside is that you have to implement a bunch of COM interfaces to make that happen. That's why the OLE DB templates exist.
________________________________________________________________________
8.3.3. - [Basic OLE DB Template Architecture](invcpp5/ch33d.htm)
----------------------------------------------------
 Basic OLE DB Template Architecture 

Basic OLE DB Template Architecture
==================================

Now that you understand the basic architecture behind OLE DB, it's time to take a look at a specific implementation of the OLE DB interfaces (provided by the new OLE DB consumer and provider templates). Like most other COM-based technologies, OLE DB involves implementing a bunch of interfaces. Of course, just as with ActiveX Controls, you can choose to implement them by hand (often an inefficient approach—unless you're just trying to understand the technology inside-out), or you can find someone else to do most of the dirty work. While OLE DB is a rich and powerful data access technology, getting it up and running by hand is a somewhat tedious task.

Just as Visual C++ provides a template library (ATL) for implementing ActiveX Controls, Visual C++ also provides a template library that helps you manage OLE DB. The OLE DB template support provides classes that implement many of the commonly used OLE DB interfaces. In addition, Visual C++ provides great wizard support for generating code to apply to common scenarios.

From a high level, you can divide the classes in this template library into the two groups defined by OLE DB itself: the consumer classes and the provider classes. The consumer classes help you implement database client (consumer) applications, while the provider classes help you implement database server (provider) applications. Remember that OLE DB consumers are applications that call the COM interfaces exposed by OLE DB service providers (or regular providers) to access data. OLE DB providers are COM servers that provide data and services in a form that a consumer can understand.

OLE DB Consumer Template Architecture
-------------------------------------

Microsoft has kept the top layer classes in the OLE DB Consumer Templates as close to the OLE DB specification as possible. That is, OLE DB templates don't define another object model. Their purpose is simply to wrap the existing OLE DB object model. For each of the consumer-related components listed, you'll find a corresponding C++ template class. This design philosophy leverages the flexibility of OLE DB and allows more advanced features—such as multiple accessors on rowsets—to be available through the OLE DB Templates.

The OLE DB Templates are small and flexible. They are implemented using C++ templates and multiple inheritance. Because OLE DB templates are close to the metal (they wrap only the existing OLE DB architecture), each class mirrors an existing OLE DB component. For example, _CDataSource_ corresponds to the data source object in OLE DB.

The OLE DB Consumer Template architecture can be divided into three parts: the general data source support classes, classes for supporting data access and rowset operations, and classes for handling tables and commands. Here's a quick summary of these classes.

### General Data Source Support

A data source is the most fundamental concept to remember when talking about data access using OLE DB. That is, where is the data coming from? Of course, the OLE DB templates have support for data sources. General data source support comprises three classes as shown in this table.

**Class**

**Use**

_CDataSource_

This class represents the data source component and manages the connection to a data source.

_CEnumerator_

This class provides a way to select a provider by cycling through a list of providers. Its functionality is equivalent to the _SQLBrowseConnect_ and _SQLDriverConnect_ functions.

_CSession_

This class handles transactions. You can use this class to create rowsets, commands, and many other objects. A _CDataSource_ object creates a _CSession_ object using the _CSession::Open_ method.

### Data Access and Rowset Support

The OLE DB templates provide binding and rowset support through several classes. The accessor classes talk to the data source while the rowset manages the data in tabular form. The data access and rowset components are implemented through the _CAccessorRowset_ class. _CAccessorRowset_ is a template class that's specialized on an accessor and a rowset. This class can handle multiple accessors of different types.

The OLE DB Template library defines the accessors in this table.

**Class**

**Use**

_CAccessor_

This class is used when a record is statically bound to a data source—it contains the pre-existing data buffer and understands the data format up front. _CAccessor_ is used when you know the structure and the type of the database ahead of time.

_CDynamicAccessor_

This class is used for retrieving data from a source whose structure is not known at design time. This class uses _IColumnsInfo::GetColumnInfo_ to get the database column information. _CDynamicAccessor_ creates and manages the data buffer.

_CDynamicParameterAccessor_

This class is similar to _CDynamicAccessor_ except that it's used with commands. When used to prepare commands, _CDynamicParameterAccessor_ can get parameter information from the _ICommandWithParameters_ interface, which is especially useful for handling unknown command types.

_CManualAccessor_

This class lets you access whatever data types you want as long as the provider can convert the type. _CManualAccessor_ handles both result columns and command parameters.

Along with the accessors, the OLE DB templates define three types of rowsets: single fetching, bulk, and array. These are fairly self-explanatory descriptions. Clients use a function named _MoveNext_ to navigate through the data. The difference between the single fetching, bulk, and array rowsets lies in the number of row handles retrieved when _MoveNext_ is called. Single fetching rowsets retrieve a single rowset for each call to _MoveNext_ while bulk rowsets fetch multiple rows. Array rowsets provide a convenient array syntax for fetching data. The OLE DB Templates provide the single row-fetching capability by default.

### Table and Command Support

The final layer in the OLE DB Template consumer architecture consists of two more classes: table and command classes (_CTable_ and _CCommand_). These classes are used to open the rowset, execute commands, and initiate bindings. Both classes derive from _CAccessorRowset_

The _CTable_ class is a minimal class implementation that opens a table on a data source (which you can specify programmatically). Use this class when you need bare-bones access to a source, since _CTable_ is designed for simple providers that do not support commands.

Other data sources also support commands. For those sources, you'll want to use the OLE DB Templates' _CCommand_ class. As its name implies, _CCommand_ is used mostly for executing commands. This class has a function named _Open_ that executes singular commands. This class also has a function named _Prepare_ for setting up a command to execute multiple times.

When using the _CCommand_ class, you'll specialize it with three template arguments: an accessor, a rowset, and a third template argument (which defaults to _CNoMultipleResults_). If you specify _CMultipleResults_ for this third argu- ment, the _CCommand_ class will support the _IMultipleResults_ interface for a command that returns multiple rowsets.

OLE DB Provider Template Architecture
-------------------------------------

Remember that OLE DB is really just a set of interfaces that specify a protocol for managing data. OLE DB defines several interfaces (some mandatory and others optional) for the following types of objects: data source, session, rowset, and command. Here's a description of each followed by a code snippet that shows how the templates bring in the correct functionality for each component.

*   **Data source object** A data source object wraps most aspects of data access. For example, a data source consists of actual data and its associated database management system (DBMS), the platform on which the DBMS exists, and the network used to access that platform. A data source is just a COM object that implements a bunch of interfaces, as shown in Table 33-1.
    

**Interface**

**Required?**

**Implemented?**

_IDBInitialize_

Mandatory

Yes

_IDBCreateSession_

Mandatory

Yes

_IDBProperties_

Mandatory

Yes

_IPersist_

Mandatory

Yes

_IDBDataSourceAdmin_

Optional

No

_IDBInfo_

Optional

No

_IPersistFile_

Optional

No

_ISupportErrorInfo_

Optional

No

**Table 33-1.** _Data source object interface requirements._

> NOTE
> 
> Tables in this section were compiled from the Microsoft Visual Studio MSDN Online Help.

Here's a code snippet showing the code that is inserted by the ATL Object Wizard when you create a data source for an OLE DB provider:

class ATL_NO_VTABLE CAProviderSource : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CAProviderSource, &CLSID_AProvider>,
    public IDBCreateSessionImpl<CAProviderSource, CAProviderSession>,
    public IDBInitializeImpl<CAProviderSource>,
    public IDBPropertiesImpl<CAProviderSource>,
    public IPersistImpl<CAProviderSource>,
    public IInternalConnectionImpl<CAProviderSource> {
}; 

Notice that this is a normal COM class (with ATL's _IUnknown_ implementation). The OLE DB data source object brings in implementations of the _IDBCreateSession_, _IDBInitialize_, _IDBProperties_, and _IPersist_ interfaces through inheritance. Notice how the templates are specialized on the _CAProviderSource_ and _CAProviderSession_ classes. If you decide to add more functionality to your class, you can do so by inheriting from one of the OLE DB interface implementation classes.

*   **Command object** Providers that support building and executing queries expose a command object. Command objects specify, prepare, and execute a Database Manipulation Language (DML) query or Data Definition Language (DDL) definition and its associated properties. For example, the command object translates a SQL-type command into an operation specific to the data source. Compared to ODBC, the command corresponds to the general functionality of an ODBC statement in an unexecuted state. A single session can be associated with multiple commands. Table 33-2 shows the interfaces used in a command object.
    
    Here's a code snippet showing the code inserted by the ATL Object Wizard to implement a command object when you create an OLE DB provider:
    
    class ATL_NO_VTABLE CAProviderCommand : 
        public CComObjectRootEx<CComSingleThreadModel>,
        public IAccessorImpl<CAProviderCommand>,
        public ICommandTextImpl<CAProviderCommand>,
        public ICommandPropertiesImpl<CAProviderCommand>,
        public IObjectWithSiteImpl<CAProviderCommand>,
        public IConvertTypeImpl<CAProviderCommand>,
        public IColumnsInfoImpl<CAProviderCommand> {
    };
    
    As with the data source, notice that this is just a regular COM class. This class brings in the required interfaces through inheritance. (For example, _IAccesor_ comes in through the _IAccessorImpl_ template.) A command object uses _IAccessor_ to specify parameter bindings. Consumers call _IAccessor::CreateAccessor,_ passing an array of _DBBINDING_ structures. _DBBINDING_ contains information on the column bindings (type, length, and so on). The provider receives the structures and determines how the data should be transferred and whether conversions are necessary.
    
    The _ICommandText_ interface provides a way to specify a text command. The _ICommandProperties_ interface handles all of the command properties.
    
    The command class is the heart of the data provider. Most of the action happens within this class.
    

**Interface**

**Required?**

**Implemented?**

_IAccessor_

Mandatory

Yes

_IColumnsInfo_

Mandatory

Yes

_ICommand_

Mandatory

Yes

_ICommandProperties_

Mandatory

Yes

_ICommandText_

Mandatory

Yes

_IConvertType_

Mandatory

Yes

_IColumnsRowset_

Optional

No

_ICommandPrepare_

Optional

No

_ICommandWithParameters_

Optional

No

_ISupportErrorInfo_

Optional

No

**Table 33-2.** _Command object interfaces requirements._

*   **Session object** Session objects define the scope of a transaction and generate rowsets from the data source. Session objects also generate command objects. The command object executes commands on the rowset. For providers that support commands, the session acts as a command factory. Compared to ODBC, the session object and the data source object encapsulate the functionality of the ODBC connection. Calling _IDBCreateSession::CreateSession_ creates a session from the data source object. A single data source object can be associated with many sessions. Table 33-3 shows the interfaces found on a session object.
    

**Interface**

**Required?**

**Implemented?**

_IGetDataSource_

Mandatory

Yes

_IOpenRowset_

Mandatory

Yes

_ISessionProperties_

Mandatory

Yes

_IDBCreateCommand_

Optional

Yes

_IDBSchemaRowset_

Optional

Yes

_IIndexDefinition_

Optional

No

_ISupportErrorInfo_

Optional

No

_ITableDefinition_

Optional

No

_ITransactionJoin_

Optional

No

_ITransactionLocal_

Optional

No

_ITransactionObject_

Optional

No

**Table 33-3.** _Session object interfaces requirements._

Here's a code snippet showing the code inserted by the ATL Object Wizard to implement a session object when you create an OLE DB provider:

class ATL_NO_VTABLE CAProviderSession : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IGetDataSourceImpl<CAProviderSession>,
    public IOpenRowsetImpl<CAProviderSession>,
    public ISessionPropertiesImpl<CAProviderSession>,
    public IObjectWithSiteSessionImpl<CAProviderSession>,
    public IDBSchemaRowsetImpl<CAProviderSession>,
    public IDBCreateCommandImpl<CAProviderSession, CAProviderCommand>
{
};

*   **Rowset object** A rowset object represents tabular data. At the raw OLE DB level, rowsets are generated by calling _IOpenRowset::OpenRowset_ on the session. For providers that support commands, rowsets are used to represent the results of row-returning queries. In addition to _IOpenRowset::OpenRowset_, there are a number of other methods in OLE DB that return rowsets. For example, the schema functions return rowsets. Compared to ODBC, a rowset encapsulates the general functionality of an ODBC statement in the executed state. Single sessions can be associated with multiple rowsets. In addition, single command objects can be associated with multiple rowsets. Table 33-4 shows the interfaces associated with the rowset object.

Interface

Required?

Implemented?

_IAccessor_

Mandatory

Yes

_IColumnsInfo_

Mandatory

Yes

_IConvertType_

Mandatory

Yes

_IRowset_

Mandatory

Yes

_IRowsetInfo_

Mandatory

Yes

_IColumnsRowset_

Optional

No

_IConnectionPointContainer_

Optional

Yes, through ATL

_IRowsetChange_

Optional

No

_IRowsetIdentity_

Required for Level 0

Yes

_IRowsetLocate_

Optional

No

_IRowsetResynch_

Optional

No

_IRowsetScroll_

Optional

No

_IRowsetUpdate_

Optional

No

_ISupportErrorInfo_

Optional

No

**Table 33-4.** _Rowset object interfaces requirements._

Here's a code snippet showing the code inserted by the ATL Object Wizard to implement a rowset object when you create an OLE DB provider:

class CAProviderWindowsFile: 
    public WIN32_FIND_DATA
{
public:
BEGIN_PROVIDER_COLUMN_MAP(CAProviderWindowsFile)
    PROVIDER_COLUMN_ENTRY("FileAttributes", 1, dwFileAttributes)
    PROVIDER_COLUMN_ENTRY("FileSizeHigh", 2, nFileSizeHigh)
    PROVIDER_COLUMN_ENTRY("FileSizeLow", 3, nFileSizeLow)
    PROVIDER_COLUMN_ENTRY("FileName", 4, cFileName)
    PROVIDER_COLUMN_ENTRY("AltFileName", 5, cAlternateFileName)
END_PROVIDER_COLUMN_MAP()
};

class CAProviderRowset : 
public CRowsetImpl<CAProviderRowset, 
                     CAProviderWindowsFile, 
                     CAProviderCommand> {
}

The wizard-generated rowset object implements the _IAccessor, IRowset_, and _IRowsetInfo_ interfaces, among others. _IAccessorImpl_ binds both output columns. The _IRowset_ interface fetches rows and data. The _IRowsetInfo_ interface handles the rowset properties. The _CWindowsFile_ class represents the user record class. The class generated by the Wizard is really just a placeholder. It doesn't do very much. When you decide on the column format of your data provider, this is the class you'll modify.

### How the Provider Parts Work Together

The use for the first part of the architecture—the data source—should be obvious. Every provider must include a data source object. When a consumer application needs data, the consumer calls _CoCreateInstance_ to create the data source object and start the provider. Within the provider, it's the data source object's job to create a session object using the _IDBCreateSession_ interface. The consumer uses this interface to connect to the data source object. In comparing this to how ODBC works, the data source object is equivalent to ODBC's HENV and the session object is the equivalent of ODBC's HDBC.

The command object does most of the work. To make the data provider actually do something, you'll modify the command class's _Execute_ function.

Like most COM-based protocols, the OLE DB protocol makes sense once you've examined it for a little while. Also, like most COM-based protocols, the OLE DB protocol involves a good amount of code to get going—code that could be easily implemented by some sort of framework. That's what the Data Consumer and Data Provider templates are all about. The rest of the chapter shows you what you need to do to create Data Consumers and Data Providers.
________________________________________________________________________
8.3.4. - [Creating an OLE DB Consumer](invcpp5/ch33e.htm)
----------------------------------------------------
 Creating an OLE DB Consumer 

Creating an OLE DB Consumer
===========================

Creating an OLE DB consumer is pretty straightforward—most of the support comes through the ATL Object Wizard. You can see an example of a consumer in the x33a folder on the companion CD. Here are the steps for creating a consumer using the ATL Object Wizard.

1.  Create an application or a control to drive the data consumption. For example, you might want to create an ActiveX control.
    
2.  While inside the IDE, use the ATL Object Wizard to insert a data consumer. Do this by either selecting New ATL Object from the Insert menu or by right-clicking on the project icon in ClassView and selecting New ATL Object from the context menu to start the ATL Object Wizard.
    
3.  From the ATL Object Wizard, select the Data Access category of objects. Then select Consumer and click Next. This will cause the ATL Object Wizard Properties dialog, shown in Figure 33-1, to appear. There will be only one page in it, for naming the class and selecting the data source.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/f33og01x.gif)
    
    **Figure 33-1.** _The ATL Object Wizard Properties._
    
4.  Click Select Datasource to configure the data consumer. Once you've picked out a data source, choose OK. The ATL Object Wizard will create an OLE DB Consumer template ready for you to use.
    

As an example, we took the BIBLIO.MDB database (a Microsoft Access database) that comes in the Visual Studio VB98 directory and made a data consumer out of it. The BIBLIO database includes the titles and the authors of various programming texts. Using the ATL Object Wizard to create the OLE DB Consumer template for the authors in the database yielded these classes:

// Authors.H : Declaration of the CAuthors class

#ifndef __AUTHORS_H_
#define __AUTHORS_H_

class CAuthorsAccessor
{
public:
    LONG m_AuID;
    TCHAR m_Author[51];
    SHORT m_YearBorn;

BEGIN_COLUMN_MAP(CAuthorsAccessor)
    COLUMN_ENTRY(1, m_AuID)
    COLUMN_ENTRY(2, m_Author)
    COLUMN_ENTRY(3, m_YearBorn)
END_COLUMN_MAP()

DEFINE_COMMAND(CAuthorsAccessor, _T("SELECT \* FROM Authors"))
};

class CAuthors : public CCommand<CAccessor<CAuthorsAccessor> >
{
public:
    HRESULT Open()
    {
        HRESULT   hr;

        hr = OpenDataSource();
        if (FAILED(hr))
            return hr;

        return OpenRowset();
    }
    HRESULT OpenDataSource()
    {
        HRESULT      hr;
        CDataSource  db;
        CDBPropSet   dbinit(DBPROPSET_DBINIT);

        dbinit.AddProperty(DBPROP_AUTH_CACHE_AUTHINFO, true);
        dbinit.AddProperty(DBPROP_AUTH_ENCRYPT_PASSWORD, false);
        dbinit.AddProperty(DBPROP_AUTH_MASK_PASSWORD, false);
        dbinit.AddProperty(DBPROP_AUTH_PASSWORD, OLESTR(""));
        dbinit.AddProperty(DBPROP_AUTH_PERSIST_ENCRYPTED, false);
        dbinit.AddProperty(DBPROP_AUTH_PERSIST_SENSITIVE_AUTHINFO,
                           false);
        dbinit.AddProperty(DBPROP_AUTH_USERID, OLESTR("Admin"));
        dbinit.AddProperty(DBPROP_INIT_DATASOURCE,
                           OLESTR("c:\\biblio.mdb"));
        dbinit.AddProperty(DBPROP_INIT_MODE, (long)16);
        dbinit.AddProperty(DBPROP_INIT_PROMPT, (short)4);
        dbinit.AddProperty(DBPROP_INIT_PROVIDERSTRING, OLESTR
                           (";COUNTRY=0;CP=1252;LANGID=0x0409"));
        dbinit.AddProperty(DBPROP_INIT_LCID, (long)1033);
        hr = db.Open(_T("Microsoft.Jet.OLEDB.3.51"), &dbinit);
        if (FAILED(hr))
            return hr;

        return m_session.Open(db);
    }
    HRESULT OpenRowset()
    {
        return CCommand<CAccessor<CAuthorsAccessor> 
               >::Open(m_session, _T("Authors"));
    }
    Csession   m_session;
};

#endif // __AUTHORS_H_

The _CAuthorsAccessor_ class defines the structure of the author record. Notice that the class includes an author ID field, a name field, and a field indicating when the author was born.

The _CAuthors_ class represents the actual data consumer class that connects to the database. Notice that it's derived from _CCommand_. Remember that command objects represent a command (such as a SQL statement) and generate rowsets. The COLUMN_MAP represents data returned in the rowset. The PARAM_MAP represents parameter data for a command.

The column maps and the parameter maps represent the user's view of the accessor. As with many data structures in ATL and MFC, these maps are built up with macros. Here's how the maps work: when running against a database, the data that comes back is contained in a contiguous block of memory. OLE DB templates work with this block of memory to extract the data. The data members in the entries represent offsets into that block of memory. The entries in the maps filter out the data from the database. That way, you as a developer do not have to worry about doing anything funky like performing pointer arithmetic on the block to get information.
________________________________________________________________________
8.3.5. - [Using the OLE DB Consumer Code](invcpp5/ch33f.htm)
----------------------------------------------------
 Using the OLE DB Consumer Code 

Using the OLE DB Consumer Code
==============================

Using the database consumer class is just about as easy as creating it. Here's how to take advantage of the database consumer class:

1.  Declare an instance of _CAuthors_ wherever you need to use it:
    
    class CUseAuthors : public CDialog {
        CAuthors m_authors;
        .
        .
        .
    };
    
2.  Open the Authors database by calling _Open_ on the database consumer object:
    
    CUseAuthors::OnInitDialog() {
        m_authors.Open();
    }
    
3.  Use member functions to navigate through and manipulate the database. Here's a short sampling of some of the things you can do:
    
    CUseAuthors::OnNext() {
        m_authors.MoveNext();
    }
    CUseAuthors::OnFirst() {
        m_authors.MoveFirst();
    }
    CUseAuthors::OnLast() {
        m_authors.MoveLast();
    }
    CUseAuthors::OnInsert() {
        m_authors.Insert();
    }
    
4.  As you navigate through the database, the data ends up in the member variables. For example, if you want to find out the name of the next author in the database, the code would look like this:
    
    m_authors.MoveNext();
    m_strAuthorName = m_authors.m_Author;
    

As you can see, using the templates greatly simplifies getting the data out of the database. All you need to do is find the database, point the ATL Object Wizard there, and get the Wizard to generate your code. Then the accessor class has functions useful for moving around the database and fetching the data. The other half of the OLE DB Template equation is the data provider. Here's a rundown of how to work with providers.
________________________________________________________________________
8.3.6. - [Creating an OLE DB Provider](invcpp5/ch33g.htm)
----------------------------------------------------
 Creating an OLE DB Provider 

Creating an OLE DB Provider
===========================

It's pretty obvious how OLE DB consumers are useful. You just ask a wizard to create a wrapper for you, and you get a fairly easy way to access the data in a database. However, it might be a bit less obvious why you'd want to create an OLE DB provider.

Why Write an OLE DB Provider?
-----------------------------

Writing an OLE DB allows you to insert a layer between a client of some data and the actual data itself. Here are just a few reasons you might want to write a provider.

*   Writing an OLE DB provider means clients don't necessarily touch the data directly. Therefore, you can add additional capabilities to your data, such as query processing.
    
*   In some cases, writing an OLE DB provider gives you the opportunity to increase data access performance by controlling how the data is manipulated.
    
*   Adding an OLE DB provider layer increases the potential audience of your data. For example, if you have a proprietary data format that can be accessed by only one programming language, you have a single point of failure. OLE DB providers give you a way to open that proprietary format to a wider variety of programmers, regardless of the programming language they use.
    

Writing an OLE DB Provider
--------------------------

Working with the OLE DB Providers is similar to working with the Consumers. The wizards do a lot of the work for you. You just need to know how to work with the generated classes. The steps for creating an OLE DB Provider are listed here.

1.  The first step is to decide what you want the provider to do. Remember the philosophy behind OLE DB: it's all about providing a singular way to access multiple data sources. For example, you might want to write a provider that recursively enumerates the contents of a structured storage file. Or you might want a provider that sifts through e-mail folders and allows clients database-style access to your e-mail system. The possibilities are nearly endless.
    
2.  Just as you did when writing a data consumer, use the ATL Object Wizard to create a provider. Just start the ATL Object Wizard from ClassView or from the Insert menu. Select the Data Access objects category, and choose Provider. The ATL Object Wizard will ask you to provide a name for your object and will allow you to modify the default names for the files it will create.
    
3.  After you click OK, the ATL Object Wizard creates the code for a provider, including a data source, a rowset, and a session. In addition to these objects, a provider supports one or more properties, which are defined in property maps within the files created by the OLE DB Provider Template Wizard. When the Wizard creates the files, it inserts maps for the properties belonging to the OLE DB property group defined for the object or objects included in those files. For example, the header file containing the data source object also contains the property map for the DataSource properties. The session header file contains the property map for the Session properties. Finally, the rowset and command objects reside in a single header file, which includes properties for the command object.

For example, here's what the ATL Object Wizard produces for an OLE DB provider named AProvider. First the ATL Object Wizard creates a data source object, which lives in a file named AProviderDS.H:

class ATL_NO_VTABLE CAProviderSource : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CAProviderSource, &CLSID_AProvider>,
    public IDBCreateSessionImpl<CAProviderSource, CAProviderSession>,
    public IDBInitializeImpl<CAProviderSource>,
    public IDBPropertiesImpl<CAProviderSource>,
    public IPersistImpl<CAProviderSource>,
    public IInternalConnectionImpl<CAProviderSource>
{
public:
    HRESULT FinalConstruct()
    {
        return FInit();
    }
DECLARE_REGISTRY_RESOURCEID(IDR_APROVIDER)
BEGIN_PROPSET_MAP(CAProviderSource)
    BEGIN_PROPERTY_SET(DBPROPSET_DATASOURCEINFO)
        PROPERTY_INFO_ENTRY(ACTIVESESSIONS)
        PROPERTY_INFO_ENTRY(DATASOURCEREADONLY)
        PROPERTY_INFO_ENTRY(BYREFACCESSORS)
        PROPERTY_INFO_ENTRY(OUTPUTPARAMETERAVAILABILITY)
        PROPERTY_INFO_ENTRY(PROVIDEROLEDBVER)
        PROPERTY_INFO_ENTRY(DSOTHREADMODEL)
        PROPERTY_INFO_ENTRY(SUPPORTEDTXNISOLEVELS)
        PROPERTY_INFO_ENTRY(USERNAME)
    END_PROPERTY_SET(DBPROPSET_DATASOURCEINFO)
    BEGIN_PROPERTY_SET(DBPROPSET_DBINIT)
        PROPERTY_INFO_ENTRY(AUTH_PASSWORD)
        PROPERTY_INFO_ENTRY(AUTH_PERSIST_SENSITIVE_AUTHINFO)
        PROPERTY_INFO_ENTRY(AUTH_USERID)
        PROPERTY_INFO_ENTRY(INIT_DATASOURCE)
        PROPERTY_INFO_ENTRY(INIT_HWND)
        PROPERTY_INFO_ENTRY(INIT_LCID)
        PROPERTY_INFO_ENTRY(INIT_LOCATION)
        PROPERTY_INFO_ENTRY(INIT_MODE)
        PROPERTY_INFO_ENTRY(INIT_PROMPT)
        PROPERTY_INFO_ENTRY(INIT_PROVIDERSTRING)
        PROPERTY_INFO_ENTRY(INIT_TIMEOUT)
    END_PROPERTY_SET(DBPROPSET_DBINIT)
    CHAIN_PROPERTY_SET(CAProviderCommand)
END_PROPSET_MAP()
BEGIN_COM_MAP(CAProviderSource)
    COM_INTERFACE_ENTRY(IDBCreateSession)
    COM_INTERFACE_ENTRY(IDBInitialize)
    COM_INTERFACE_ENTRY(IDBProperties)
    COM_INTERFACE_ENTRY(IPersist)
    COM_INTERFACE_ENTRY(IInternalConnection)
END_COM_MAP()
public:
};

In addition to the data object, the ATL Object Wizard produces a command object and a rowset that both live within AProviderRS.H:

class ATL_NO_VTABLE CAProviderCommand : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IAccessorImpl<CAProviderCommand>,
    public ICommandTextImpl<CAProviderCommand>,
    public ICommandPropertiesImpl<CAProviderCommand>,
    public IObjectWithSiteImpl<CAProviderCommand>,
    public IConvertTypeImpl<CAProviderCommand>,
    public IColumnsInfoImpl<CAProviderCommand>
{
public:
BEGIN_COM_MAP(CAProviderCommand)
    COM_INTERFACE_ENTRY(ICommand)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(IAccessor)
    COM_INTERFACE_ENTRY(ICommandProperties)
    COM_INTERFACE_ENTRY2(ICommandText, ICommand)
    COM_INTERFACE_ENTRY(IColumnsInfo)
    COM_INTERFACE_ENTRY(IConvertType)
END_COM_MAP()
// ICommand
public:
    HRESULT FinalConstruct()
    {
        HRESULT hr = CConvertHelper::FinalConstruct();
        if (FAILED (hr))
            return hr;
        hr = IAccessorImpl<CAProviderCommand>::FinalConstruct();
        if (FAILED(hr))
            return hr;
        return CUtlProps<CAProviderCommand>::FInit();
    }
    void FinalRelease()
    {
        IAccessorImpl<CAProviderCommand>::FinalRelease();
    }
    HRESULT WINAPI Execute(IUnknown \* pUnkOuter, 
                           REFIID riid, DBPARAMS \* pParams, 
                           LONG \* pcRowsAffected, 
                           IUnknown \*\* ppRowset);
    static ATLCOLUMNINFO\* GetColumnInfo(CAProviderCommand\* pv,
                                        ULONG\* pcInfo)
    {
        return CAProviderWindowsFile::GetColumnInfo(pv,pcInfo);
    }
BEGIN_PROPSET_MAP(CAProviderCommand)
    BEGIN_PROPERTY_SET(DBPROPSET_ROWSET)
        PROPERTY_INFO_ENTRY(IAccessor)
        PROPERTY_INFO_ENTRY(IColumnsInfo)
        PROPERTY_INFO_ENTRY(IConvertType)
        PROPERTY_INFO_ENTRY(IRowset)
        PROPERTY_INFO_ENTRY(IRowsetIdentity)
        PROPERTY_INFO_ENTRY(IRowsetInfo)
        PROPERTY_INFO_ENTRY(IRowsetLocate)
        PROPERTY_INFO_ENTRY(BOOKMARKS)
        PROPERTY_INFO_ENTRY(BOOKMARKSKIPPED)
        PROPERTY_INFO_ENTRY(BOOKMARKTYPE)
        PROPERTY_INFO_ENTRY(CANFETCHBACKWARDS)
        PROPERTY_INFO_ENTRY(CANHOLDROWS)
        PROPERTY_INFO_ENTRY(CANSCROLLBACKWARDS)
        PROPERTY_INFO_ENTRY(LITERALBOOKMARKS)
        PROPERTY_INFO_ENTRY(ORDEREDBOOKMARKS)
    END_PROPERTY_SET(DBPROPSET_ROWSET)
END_PROPSET_MAP()
};

class RAProviderRowset : public CRowsetImpl<RAProviderRowset, 
                                            CWindowsFile, 
                                            CAProviderCommand>
{
public:
    HRESULT Execute(DBPARAMS \* pParams, LONG\* pcRowsAffected)
    {
        USES_CONVERSION;
        BOOL bFound = FALSE;
        HANDLE hFile;
        LPTSTR  szDir = (m_strCommandText == _T("")) ? _T("\*.\*") : 
                         OLE2T(m_strCommandText);
        CAProviderWindowsFile wf;
        hFile = FindFirstFile(szDir, &wf);
        if (hFile == INVALID_HANDLE_VALUE)
            return DB_E_ERRORSINCOMMAND;
        LONG cFiles = 1;
        BOOL bMoreFiles = TRUE;
        while (bMoreFiles)
        {
            if (!m_rgRowData.Add(wf))
                return E_OUTOFMEMORY;
            bMoreFiles = FindNextFile(hFile, &wf);
            cFiles++;
        }
        FindClose(hFile);
        if (pcRowsAffected != NULL)
            \*pcRowsAffected = cFiles;
        return S_OK;
    }
};

The ATL Object Wizard produces a session object in a file named AProviderSess.H as shown in this code:

class ATL_NO_VTABLE CAProviderSession : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IGetDataSourceImpl<CAProviderSession>,
    public IOpenRowsetImpl<CAProviderSession>,
    public ISessionPropertiesImpl<CAProviderSession>,
    public IObjectWithSiteSessionImpl<CAProviderSession>,
    public IDBSchemaRowsetImpl<CAProviderSession>,
    public IDBCreateCommandImpl<CAProviderSession, CAProviderCommand>
{
public:
    CAProviderSession()
    {
    }
    HRESULT FinalConstruct()
    {
        return FInit();
    }
    STDMETHOD(OpenRowset)(IUnknown \*pUnk, DBID \*pTID, 
                          DBID \*pInID, REFIID riid,
                          ULONG cSets, DBPROPSET rgSets[], 
                          IUnknown \*\*ppRowset)
    {
        CAProviderRowset\* pRowset;
        return CreateRowset(pUnk, pTID, pInID, riid, 
                            cSets, rgSets, ppRowset, pRowset);
    }
BEGIN_PROPSET_MAP(CAProviderSession)
    BEGIN_PROPERTY_SET(DBPROPSET_SESSION)
        PROPERTY_INFO_ENTRY(SESS_AUTOCOMMITISOLEVELS)
    END_PROPERTY_SET(DBPROPSET_SESSION)
END_PROPSET_MAP()
BEGIN_COM_MAP(CAProviderSession)
    COM_INTERFACE_ENTRY(IGetDataSource)
    COM_INTERFACE_ENTRY(IOpenRowset)
    COM_INTERFACE_ENTRY(ISessionProperties)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(IDBCreateCommand)
    COM_INTERFACE_ENTRY(IDBSchemaRowset)
END_COM_MAP()
BEGIN_SCHEMA_MAP(CAProviderSession)
    SCHEMA_ENTRY(DBSCHEMA_TABLES, CAProviderSessionTRSchemaRowset)
    SCHEMA_ENTRY(DBSCHEMA_COLUMNS, CAProviderSessionColSchemaRowset)
    SCHEMA_ENTRY(DBSCHEMA_PROVIDER_TYPES, CAProviderSessionPTSchemaRowset)
END_SCHEMA_MAP()
};
class CAProviderSessionTRSchemaRowset : 
    public CRowsetImpl< CAProviderSessionTRSchemaRowset, 
                        CTABLESRow, CAProviderSession>
{
public:
    HRESULT Execute(LONG\* pcRowsAffected, ULONG, const VARIANT\*)
    {
        USES_CONVERSION;
        CAProviderWindowsFile wf;
        CTABLESRow trData;
        lstrcpyW(trData.m_szType, OLESTR("TABLE"));
        lstrcpyW(trData.m_szDesc, OLESTR("The Directory Table"));
        HANDLE hFile = INVALID_HANDLE_VALUE;
        TCHAR szDir[MAX_PATH + 1];
        DWORD cbCurDir = GetCurrentDirectory(MAX_PATH, szDir);
        lstrcat(szDir, _T("\\\*.\*"));
        hFile = FindFirstFile(szDir, &wf);
        if (hFile == INVALID_HANDLE_VALUE)
            return E_FAIL; // User doesn't have a c:\ drive
        FindClose(hFile);
        lstrcpynW(trData.m_szTable, T2OLE(szDir), 
                  SIZEOF_MEMBER(CTABLESRow, m_szTable));
        if (!m_rgRowData.Add(trData))
            return E_OUTOFMEMORY;
        \*pcRowsAffected = 1;
        return S_OK;
    }
};
class CAProviderSessionColSchemaRowset : 
    public CRowsetImpl< CAProviderSessionColSchemaRowset, 
                        CCOLUMNSRow, CAProviderSession>
{
public:
    HRESULT Execute(LONG\* pcRowsAffected, ULONG, const VARIANT\*)
    {
        USES_CONVERSION;
        CAProviderWindowsFile wf;
        HANDLE hFile = INVALID_HANDLE_VALUE;
           TCHAR szDir[MAX_PATH + 1];
        DWORD cbCurDir = GetCurrentDirectory(MAX_PATH, szDir);
        lstrcat(szDir, _T("\\\*.\*"));
        hFile = FindFirstFile(szDir, &wf);
        if (hFile == INVALID_HANDLE_VALUE)
            return E_FAIL; // User doesn't have a c:\ drive
        FindClose(hFile);// szDir has got the tablename
        DBID dbid;
        memset(&dbid, 0, sizeof(DBID));
        dbid.uName.pwszName = T2OLE(szDir);
        dbid.eKind = DBKIND_NAME;
        return InitFromRowset <RowsetArrayType> (m_rgRowData, 
                                                 &dbid, 
                                                 NULL, 
                                                 m_spUnkSite, 
                                                 pcRowsAffected);
    }
};
class CAProviderSessionPTSchemaRowset : 
    public CRowsetImpl<CAProviderSessionPTSchemaRowset, 
                       CPROVIDER_TYPERow, CAProviderSession>
{
public:
    HRESULT Execute(LONG\* pcRowsAffected, ULONG, const VARIANT\*)
    {
        return S_OK;
    }
};

### Modifying the Provider Code

As with most Wizard-generated code, the OLE DB Provider code generated by the ATL Object Wizard is just boilerplate code—it doesn't do very much. You need to take several steps to turn this boilerplate code into a real OLE DB Provider. The two critical pieces that need to be added to a provider are the user record and code to manage a data set and to set the data up as rows and columns.

*   **The user record** The ATL Object Wizard provides a default user record named CAProviderWindowsFile. You don't really want to use this user record. You'll probably scrap it and replace it with something useful in your domain. As a simple example, imagine you want to write an OLE DB Provider that enumerates the compound file. Your user record might look like this:
    
    struct CStgInfo {
    BEGIN_PROVIDER_COLUMN_MAP(CStgInfo)
        PROVIDER_COLUMN_ENTRY("StgName", 1, szName)
        PROVIDER_COLUMN_ENTRY("Size", 2, cbSizeLow)
        PROVIDER_COLUMN_ENTRY("Size", 2, cbSizeHigh)
    
    END_PROVIDER_COLUMN_MAP()
    
        OLECHAR szName[256];
        long cbSizeLow;
        long cbSizeHigh;
    };
    
    This structure contains the data fields for the name and size of the substorage. The provider column map macros map the data into columns. You could actually derive the structure from a _STATSTG_ structure (used to enumerate structured storages). You just need to add entries to the provider column map to handle the members.
    
*   **Code to open the data set** The other important addition to the provider is the code necessary to open the data set. This happens in the rowset's _Execute_ function. There are many different kinds of functionality that can go on here. For example, if you want to enumerate the top-level substorages in a compound file, you'd first open the storage and then enumerate the contents as shown in the following code snippet:
    
    class RStgInfoProviderRowset : 
        public CRowsetImpl<RStgInfoProviderRowset, 
                           CStgInfo, 
                           CStgInfoProviderCommand>
    {
    public:
        HRESULT Execute(DBPARAMS \* pParams, LONG\* pcRowsAffected)
        {
            USES_CONVERSION;
            LPTSTR  szFile = 
                   m_strCommandText == _T("")) ? _T("") :
                       OLE2T(m_strCommandText);
    
            IStorage\* pStg = NULL;
    
            HRESULT hr = StgOpenStorage(szFile, NULL, 
                                        STGM_READ|STGM_SHARE_EXCLUSIVE, 
                                        NULL, NULL, &pStg);
    
            if(FAILED(hr))
                return DB_E_ERRORSINCOMMAND;
    
            LONG cStgs = 0;
    
            IEnumSTATSTG\* pEnumSTATSTG;
    
            hr = pStg->EnumElements(0, 0, 0, &pEnumSTATSTG);
    
            if(pEnumSTATSTG) {
    
                STATSTG rgSTATSTG[100];
                ULONG nFetched;
    
                hr = pEnumSTATSTG->Next(100, rgSTATSTG, &nFetched);
    
                for(ULONG i = 0; i < nFetched; i++) {
                    CStgInfo stgInfo;
    
                    stgInfo.cbSizeLow = rgSTATSTG[i].cbSize.LowPart;
                    stgInfo.cbSizeHigh = rgSTATSTG[i].cbSize.HighPart;
    
                    wcsncpy(stgInfo.szName, 
                            rgSTATSTG[i].pwcsName,
                            255);
    
                    CoTaskMemFree(rgSTATSTG[i].pwcsName);
    
                    if (!m_rgRowData.Add(stgInfo))
                        return E_OUTOFMEMORY;
                    cStgs++;
                }
                pEnumSTATSTG->Release();
            }
    
            if(pStg)
                pStg->Release();
    
            if (pcRowsAffected != NULL)
                \*pcRowsAffected = cStgs;
            return S_OK;
        }
    }
    
    When some client code tries to open the OLE DB data provider, the call ends up inside this function. This function simply opens the structured storage file passed in as the command text and uses the standard structured storage enumerator to find the top-level substorages. Then the _Execute_ function stores the name of the substorage and the size of the substorage in an array. The OLE DB provider uses this array to fulfill requests for the column data.
    

Enhancing the Provider
----------------------

Of course, there's a lot you can do to beef up this OLE DB provider. We've barely scratched the surface of what you can do with a provider. When the ATL Object Wizard pumps out the default provider, it's a read-only provider. That is, users cannot change the contents of the data. In addition, the OLE DB templates provide support for locating rowsets and setting bookmarks. In most cases, enhancing the provider is a matter of tacking on implementations of COM interfaces provided by the OLE DB templates.
________________________________________________________________________
8.3.7. - [Conclusion](invcpp5/ch33h.htm)
----------------------------------------------------
 Conclusion 

Conclusion
==========

With so many disparate data sources available today, the only way you can hope to manage access to that data is through some sort of homogeneous mechanism such as OLE DB. The high-level OLE DB architecture is divided into two parts: consumers and providers. Consumers use the data that is made available through providers.

As with most other COM-based architectures, OLE DB involves developers in the task of implementing a good many interfaces—a number of which are boilerplate in nature. The OLE DB Templates available through Visual C++ make creating OLE DB consumers and providers much easier.

You can create a simple consumer by pointing the ATL Object Wizard at a data source when you generate a consumer object. The ATL Object Wizard will examine the data source and create the client-side proxy to the database. From there, you can use the standard navigation functions available through the OLE DB Consumer Templates.

Writing a provider is somewhat more involved (if you want the provider to do anything useful). While the wizards give you a good start, they generate only a simple provider that enumerates the files in a directory. However, the Provider Templates contain a full complement of OLE DB support. With this support, you can create OLE DB providers that implement rowset location strategies, data reading and writing, and bookmarking.
________________________________________________________________________
/9. - [Part VI: Programming for the Internet]()
====================================================
________________________________________________________________________
9.1. - [Chapter 34 -- TCP/IP, Winsock, and WinInet](invcpp5/ch34a.htm)
----------------------------------------------------
 Chapter 34 -- TCP/IP, Winsock, and WinInet  Chapter 34

TCP/IP, Winsock, and WinInet
============================

As a C++ programmer, you're going to be asked to do more than create Web pages. You'll be the one who makes the Internet reach its true potential and who creates distributed applications that haven't even been imagined yet. To be successful, you'll have to understand how the Internet works and how to write programs that can access other computers on the Internet.

In this section, you'll start with a primer on the Transmission Control Protocol/Internet Protocol (TCP/IP) that's used throughout the Internet, and then you'll move up one level to see the workings of HyperText Transport Protocol (HTTP). Then it's time to get something running. You'll assemble your own intranet (a local version of the Internet) and study an HTTP client-server program based on Winsock, the fundamental API for TCP/IP. Finally you'll move on to WinInet, which is a higher level API than Winsock and part of Microsoft's ActiveX technology.
________________________________________________________________________
9.1.1. - [To COM or Not to COM](invcpp5/ch34b.htm)
----------------------------------------------------
 To COM or Not to COM 

To COM or Not to COM
====================

Surely you've read about ActiveX Controls for the Internet. You've probably encountered concepts such as composite monikers and anti-monikers, which are part of the Microsoft Component Object Model (COM). If you were overwhelmed, don't worry—it's possible to program for the Internet without COM, and that's a good place to start. This chapter and the [next chapter](ch35a.htm) are mostly COM-free. In [Chapter 36](ch36a.htm), you'll be writing a COM-based ActiveX document server, but MFC effectively hides the COM details so you can concentrate on Winsock and WinInet programming. It's not that ActiveX controls aren't important, but we can't do them justice in this book. We'll defer to Adam Denning's book on this subject, _ActiveX Controls Inside Out_ (Microsoft Press, 1997). Your study of this book's COM material and Internet material will prepare you well for Adam's book.
________________________________________________________________________
9.1.2. - [Internet Primer](invcpp5/ch34c.htm)
----------------------------------------------------
 Internet Primer 

Internet Primer
===============

You can't write a good Winsock program without understanding the concept of a socket, which is used to send and receive packets of data across the network. To fully understand sockets, you need a thorough knowledge of the underlying Internet protocols. This section contains a concentrated dose of Internet theory. It should be enough to get you going, but you might want to refer to one of the TCP/IP textbooks if you want more theory.

Network Protocols—Layering
--------------------------

All networks use layering for their transmission protocols, and the collection of layers is often called a stack. The application program talks to the top layer, and the bottom layer talks to the network. Figure 34-1 shows you the stack for a local area network (LAN) running TCP/IP. Each layer is logically connected to the corresponding layer at the other end of the communications channel. The server program, as shown at the right in Figure 34-1, continuously listens on one end of the channel, while the client program, as shown on the left, periodically connects with the server to exchange data. Think of the server as an HTTP-based World Wide Web server, and think of the client as a browser program running on your computer.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f34og01x.gif)]

**Figure 34-1.** _The stack for a LAN running TCP/IP._

The Internet Protocol
---------------------

The Internet Protocol (IP) layer is the best place to start in your quest to understand TCP/IP. The IP protocol defines packets called datagrams that are fundamental units of Internet communication. These packets, typically less than 1000 bytes in length, go bouncing all over the world when you open a Web page, download a file, or send e-mail. Figure 34-2 shows a simplified layout of an IP datagram.

Notice that the IP datagram contains 32-bit addresses for both the source and destination computers. These IP addresses uniquely identify computers on the Internet and are used by routers (specialized computers that act like telephone switches) to direct the individual datagrams to their destinations. The routers don't care about what's inside the datagrams—they're only interested in that datagram's destination address and total length. Their job is to resend the datagram as quickly as possible.

The IP layer doesn't tell the sending program whether a datagram has successfully reached its destination. That's a job for the next layer up the stack. The receiving program can look only at the checksum to determine whether the IP datagram header was corrupted.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f34og02x.gif)]

**Figure 34-2.** _A simple IP datagram layout._

The User Datagram Protocol
--------------------------

The TCP/IP protocol should really be called TCP/UDP/IP because it includes the User Datagram Protocol (UDP), which is a peer of TCP. All IP-based transport protocols store their own headers and data inside the IP data block. First let's look at the UDP layout in Figure 34-3.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f34og03x.gif)]

**Figure 34-3.** _A simple UDP layout._

A complete UDP/IP datagram is shown in Figure 34-4.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f34og04x.gif)]

**Figure 34-4.** _The relationship between the IP datagram and the UDP datagram._

UDP is only a small step up from IP, but applications never use IP directly. Like IP, UDP doesn't tell the sender when the datagram has arrived. That's up to the application. The sender could, for example, require that the receiver send a response, and the sender could retransmit the datagram if the response didn't arrive within, say, 20 seconds. UDP is good for simple one-shot messages and is used by the Internet Domain Name System (DNS), which is explained later in this chapter. (UDP is used for transmitting live audio and video, for which some lost or out-of-sequence data is not a big problem.)

Figure 34-3 shows that the UDP header does convey some additional information—namely the source and destination port numbers. The application programs on each end use these 16-bit numbers. For example, a client program might send a datagram addressed to port 1700 on the server. The server program is listening for any datagram that includes 1700 in its destination port number, and when the server finds one, it can respond by sending another datagram back to the client, which is listening for a datagram that includes 1701 in its destination port number.

IP Address Format—Network Byte Order
------------------------------------

You know that IP addresses are 32-bits long. You might think that 232 (more than 4 billion) uniquely addressed computers could exist on the Internet, but that's not true. Part of the address identifies the LAN on which the host computer is located, and part of it identifies the host computer within the network. Most IP addresses are Class C addresses, which are formatted as shown in Figure 34-5.

![](c:/dl/books/windows/msvc5th/invcpp5/images/f34og05.gif)

**Figure 34-5.** _The layout of a Class C IP address._

This means that slightly more than 2 million networks can exist, and each of those networks can have 28 (256) addressable host computers. The Class A and Class B IP addresses, which allow more host computers on a network, are all used up.

> NOTE
> 
> The Internet "powers-that-be" have recognized the shortage of IP addresses, so they have proposed a new standard, the IP Next Generation (IPng) protocol. IPng defines a new IP datagram format that uses 128-bit addresses instead of 32-bit addresses. With IPng, you'll be able, for example, to assign a unique Internet address to each light switch in your house, so you can switch off your bedroom light from your portable computer from anywhere in the world. IPng implementation doesn't yet have a schedule.

By convention, IP addresses are written in dotted-decimal format. The four parts of the address refer to the individual byte values. An example of a Class C IP address is 194.128.198.201. In a computer with an Intel CPU, the address bytes are stored low-order-to-the-left, in so-called little-endian order. In most other computers, including the UNIX machines that first supported the Internet, bytes are stored high-order-to-the-left, in big-endian order. Because the Internet imposes a machine-independent standard for data interchange, all multibyte numbers must be transmitted in big-endian order. This means that programs running on Intel-based machines must convert between network byte order (big-endian) and host byte order (little-endian). This rule applies to 2-byte port numbers as well as to 4-byte IP addresses.

The Transmission Control Protocol
---------------------------------

You've learned about the limitations of UDP. What you really need is a protocol that supports error-free transmission of large blocks of data. Obviously, you want the receiving program to be able to reassemble the bytes in the exact sequence in which they are transmitted, even though the individual datagrams might arrive in the wrong sequence. TCP is that protocol, and it's the principal transport protocol for all Internet applications, including HTTP and File Transfer Protocol (FTP). Figure 34-6 shows the layout of a TCP segment. (It's not called a datagram.) The TCP segment fits inside an IP datagram, as shown in Figure 34-7.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f34og06x.gif)]

**Figure 34-6.** _A simple layout of a TCP segment._

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f34og07x.gif)]

**Figure 34-7.** _The relationship between an IP datagram and a TCP segment._

The TCP protocol establishes a full-duplex, point-to-point connection between two computers, and a program at each end of this connection uses its own port. The combination of an IP address and a port number is called a socket. The connection is first established with a three-way handshake. The initiating program sends a segment with the _SYN_ flag set, the responding program sends a segment with both the _SYN_ and _ACK_ flags set, and then the initiating program sends a segment with the _ACK_ flag set.

After the connection is established, each program can send a stream of bytes to the other program. TCP uses the sequence number fields together with _ACK_ flags to control this flow of bytes. The sending program doesn't wait for each segment to be acknowledged but instead sends a number of segments together and then waits for the first acknowledgment. If the receiving program has data to send back to the sending program, it can piggyback its acknowledgment and outbound data together in the same segments.

The sending program's sequence numbers are not segment indexes but rather indexes into the byte stream. The receiving program sends back the sequence numbers (in the acknowledgment number field) to the sending program, thereby ensuring that all bytes are received and assembled in sequence. The sending program resends unacknowledged segments.

Each program closes its end of the TCP connection by sending a segment with the _FIN_ flag set, which must be acknowledged by the program on the other end. A program can no longer receive bytes on a connection that has been closed by the program on the other end.

Don't worry about the complexity of the TCP protocol. The Winsock and WinInet APIs hide most of the details, so you don't have to worry about _ACK_ flags and sequence numbers. Your program calls a function to transmit a block of data, and Windows takes care of splitting the block into segments and stuffing them inside IP datagrams. Windows also takes care of delivering the bytes on the receiving end, but that gets tricky, as you'll see later in this chapter.

The Domain Name System
----------------------

When you surf the Web, you don't use IP addresses. Instead, you use human-friendly names like _microsoft.com_ or _www.cnn.com_. A significant portion of Internet resources is consumed when host names (such as _microsoft.com_) are translated into IP addresses that TCP/IP can use. A distributed network of name server (domain server) computers performs this translation by processing DNS queries. The entire Internet namespace is organized into domains, starting with an unnamed root domain. Under the root is a series of top-level domains such as _com_, _edu_, _gov_, _and org_.

> NOTE
> 
> Do not confuse Internet domains with Microsoft Windows NT domains. The latter are logical groups of networked computers that share a common security database.

### Servers and Domain Names

Let's look at the server end first. Suppose a company named SlowSoft has two host computers connected to the Internet, one for World Wide Web (WWW) service and the other for FTP service. By convention, these host computers are named _www.slowsoft.com_ and _ftp.slowsoft.com_, respectively, and both are members of the second-level domain slowsoft, which SlowSoft has registered with an organization called InterNIC. (See _[http://www.internic.com/](http://www.internic.com/)_.)

Now SlowSoft must designate two (or more) host computers as its name servers. The name servers for the _com_ domain each have a database entry for the _slowsoft_ domain, and that entry contains the names and IP addresses of SlowSoft's two name servers. Each of the two _slowsoft_ name servers has database entries for both of SlowSoft's host computers. These servers might also have database entries for hosts in other domains, and they might have entries for name servers in third-level domains. Thus, if a name server can't provide a host's IP address directly, it can redirect the query to a lower-level name server. Figure 34-8 illustrates SlowSoft's domain configuration.

> NOTE
> 
> A top-level name server runs on its own host computer. InterNIC manages (at last count) nine computers that serve the root domain and top-level domains. Lower-level name servers could be programs running on host computers anywhere on the Net. SlowSoft's Internet service provider (ISP), ExpensiveNet, can furnish one of SlowSoft's name servers. If the ISP is running Windows NT Server, the name server is usually the DNS program that comes bundled with the operating system. That name server might be designated _ns1.expensivenet.com_.

### Clients and Domain Names

Now for the client side. A user types _http:_//_www.slowsoft.com_ in the browser. (The _http://_ prefix tells the browser to use the HTTP protocol when it eventually finds the host computer.) The browser must then resolve _www.slowsoft.com_ into an IP address, so it uses TCP/IP to send a DNS query to the default gateway IP address for which TCP/IP is configured. This default gateway address identifies a local name server, which might have the needed host IP address in its cache. If not, the local name server relays the DNS query up to one of the root name servers. The root server looks up _slowsoft_ in its database and sends the query back down to one of SlowSoft's designated name servers. In the process, the IP address for _www.slowsoft.com_ will be cached for later use if it was not cached already. If you want to go the other way, name servers are also capable of converting an IP address to a name.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f34og08x.gif)]

**Figure 34-8.** _SlowSoft's domain configuration._

HTTP Basics
-----------

You're going to be doing some Winsock programming soon, but just sending raw byte streams back and forth isn't very interesting. You need to use a higher-level protocol in order to be compatible with existing Internet servers and browsers. HTTP is a good place to start because it's the protocol of the popular World Wide Web and it's relatively simple.

HTTP is built on TCP, and this is the way it works: First a server program listens on port 80. Then some client program (typically a browser) connects to the server (_www.slowsoft.com_, in this case) after receiving the server's IP address from a name server. Using its own port number, the client sets up a two-way TCP connection to the server. As soon as the connection is established, the client sends a request to the server, which might look like this:

GET /customers/newproducts.html HTTP/1.0

The server identifies the request as a GET, the most common type, and it concludes that the client wants a file named newproducts.html that's located in a server directory known as /customers (which might or might not be \customers on the server's hard disk). Immediately following are request headers, which mostly describe the client's capabilities.

Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/x
-jg, \*/\*
Accept-Language: en
UA-pixels: 1024x768
UA-color: color8
UA-OS: Windows NT
UA-CPU: x86
User-Agent: Mozilla/2.0 (compatible; MSIE 3.0; AK; Windows NT)
Host: www.slowsoft.com
Connection: Keep-Alive
If-Modified-Since: Wed, 26 Mar 1997 20:23:04 GMT
_(blank line)_

The If-Modified-Since header tells the server not to bother to transmit newproducts.html unless the file has been modified since March 26, 1997. This implies that the browser already has a dated copy of this file stored in its cache. The blank line at the end of the request is crucial; it provides the only way for the server to tell that it is time to stop receiving and start transmitting, and that's because the TCP connection stays open.

Now the server springs into action. It sends newproducts.html, but first it sends an OK response:

HTTP/1.0 200 OK

immediately followed by some response header lines:

Server: Microsoft-IIS/2.0
Date: Thu, 03 Mar 1997 17:33:12 GMT
Content-Type: text/html
Accept-Ranges: bytes
Last-Modified: Wed, Mar 26 1997 20:23:04 GMT
Content-Length: 407
_(blank line)_

The contents of newproducts.html immediately follow the blank line:

<html>
<head><title>SlowSoft's New Products</title></head>
<body><body background="/images/clouds.jpg">
<h1><center>Welcome to SlowSoft's New Products List
</center></h1><p>
Unfortunately, budget constraints have prevented SlowSoft from
 introducing any new products this year. We suggest you keep
 enjoying the old products.<p>
<a href="default.htm">SlowSoft's Home Page</a><p>
</body>
</html>

You're looking at elementary HyperText Markup Language (HTML) code here, and the resulting Web page won't win any prizes. We won't go into details because dozens of HTML books are already available. From these books, you'll learn that HTML tags are contained in angle brackets and that there's often an "end" tag (with a / character) for every "start" tag. Some tags, such as <a> (hypertext anchor), have attributes. In the example above, the line

<a href="default.htm">SlowSoft's Home Page</a><p>

creates a link to another HTML file. The user clicks on "SlowSoft's Home Page," and the browser requests default.htm from the original server.

Actually, newproducts.html references two server files, default.htm and /images/clouds.jpg. The clouds.jpg file is a JPEG file that contains a background picture for the page. The browser downloads each of these files as a separate transaction, establishing and closing a separate TCP connection each time. The server just dishes out files to any client that asks for them. In this case, the server doesn't know or care whether the same client requested newproducts.html and clouds.jpg. To the server, clients are simply IP addresses and port numbers. In fact, the port number is different for each request from a client. For example, if ten of your company's programmers are surfing the Web via your company's proxy server (more on proxy servers later), the server sees the same IP address for each client.

> NOTE
> 
> Web pages use two graphics formats, GIF and JPEG. GIF files are compressed images that retain all the detail of the original uncompressed image but are usually limited to 256 colors. They support transparent regions and animation. JPEG files are smaller, but they don't carry all the detail of the original file. GIF files are often used for small images such as buttons, and JPEG files are often used for photographic images for which detail is not critical. Visual C++ can read, write, and convert both GIF and JPEG files, but the Win32 API cannot handle these formats unless you supply a special compression/decompression module.

The HTTP standard includes a PUT request type that enables a client program to upload a file to the server. Client programs and server programs seldom implement PUT.

FTP Basics
----------

The File Transfer Protocol handles the uploading and downloading of server files plus directory navigation and browsing. A Windows command-line program called ftp (it doesn't work through a Web proxy server) lets you connect to an FTP server using UNIX-like keyboard commands. Browser programs usually support the FTP protocol (for downloading files only) in a more user-friendly manner. You can protect an FTP server's directories with a user-name/password combination, but both strings are passed over the Internet as clear text. FTP is based on TCP. Two separate connections are established between the client and server, one for control and one for data.

Internet vs. Intranet
---------------------

Up to now, we've been assuming that client and server computers were connected to the worldwide Internet. The fact is you can run exactly the same client and server software on a local intranet. An intranet is often implemented on a company's LAN and is used for distributed applications. Users see the familiar browser interface at their client computers, and server computers supply simple Web-like pages or do complex data processing in response to user input.

An intranet offers a lot of flexibility. If, for example, you know that all your computers are Intel-based, you can use ActiveX controls and ActiveX document servers that provide ActiveX document support. If necessary, your server and client computers can run custom TCP/IP software that allows communication beyond HTTP and FTP. To secure your company's data, you can separate your intranet completely from the Internet or you can connect it through a firewall, which is another name for a proxy server.
________________________________________________________________________
9.1.3. - [Build Your Own $99 Intranet](invcpp5/ch34d.htm)
----------------------------------------------------
 Build Your Own $99 Intranet 

Build Your Own $99 Intranet
===========================

Building a Microsoft Windows-based intranet is easy and cheap. Microsoft Windows 95, Microsoft Windows 98, and Microsoft Windows NT all contain the necessary networking capabilities. If you don't want to spend the $99, you can build a free intranet within a single computer. All the code in this chapter will run on this one-computer configuration.

NT File System vs. File Allocation Table
----------------------------------------

With Windows 95 and Windows 98, you are restricted to one file system, File Allocation Table (FAT—actually VFAT for long filenames). With Windows NT, you choose between NT File System (NTFS) and FAT at setup time. Your intranet will be much more secure if you choose NTFS because NTFS allows you to set user permissions for individual directories and files. Users log on to a Windows server (or to an attached workstation) supplying a user name and password.

Intranet and Internet clients participate in this operating-system security scheme because the server can log them on as though they were local users. Thus you can restrict access to any server directory or file to specific users who must supply passwords. If those user workstations are Windows network clients (as would be the case with a LAN-based intranet), the user name and password are passed through from the user's logon.

Network Hardware
----------------

You obviously need more than one computer to make a network. While your main development computer is probably a Pentium, a Pentium Pro, or a Pentium II, chances are you have at least one old computer hanging around. If it's at least a 486, it makes sense to connect it to your main computer for intranet testing and file backups.

You will need a network board for each computer, but 10-megabit-per-second Ethernet boards now cost less than $50 each. Choose a brand that either comes with its own drivers for Windows 95, Windows 98, and Windows NT, or is already supported by those operating systems. To see a list of supported boards, click on the Network icon in the Control Panel and then click the Add button to add an Adapter.

Most network boards have connectors for both thin coaxial (coax) and 10BaseT twisted pair. With 10BaseT, you must buy a hub, which costs several hundred dollars and needs a power supply. Thin coax requires only coaxial cable (available in precut lengths with connectors) plus terminator plugs. With coax, you daisy-chain your computers together and put terminators on each end of the chain.

Follow the instructions that come with the network board. In most cases you'll have to run an MS-DOS program that writes to the electrically erasable/programmable read-only memory (EEPROM) on the board. Write down the values you select—you'll need them later.

Configuring Windows for Networking
----------------------------------

After clicking on the Network icon in the Control Panel, you select protocols, adapters (network boards), and services. The screens that appear depend on whether you're using Windows 95, Windows 98, or Windows NT. You must select TCP/IP as one of your protocols if you want to run an intranet. You must also install the Windows driver for your network board, ensuring that the IRQ and I/O address values match what you put into the board's EEPROM. You must also assign an IP address to each of your network boards. If you're not connected directly to the Internet, you can choose any unique address you want.

That's actually enough configuring for an intranet, but you'll probably want to use your network for sharing files and printers, too. For Windows NT, install Client And Server Services and bind them to TCP/IP. For Windows 95 and Windows 98, install Client For Microsoft Networks and File And Printer Sharing For Microsoft Networks. If you have an existing network with another protocol installed (Novell IPX/SPX or Microsoft NetBEUI, for example), you can continue to use that protocol on the network along with TCP/IP. In that case, Windows file and print sharing will use the existing protocol and your intranet will use TCP/IP. If you want one computer to share another computer's resources, you must enable sharing from Microsoft Windows Explorer (for disk directories) or from the Printers folder (for printers).

Host Names for an Intranet—The HOSTS File
-----------------------------------------

Both Internet and intranet users expect their browsers to use host names, not IP addresses. There are various methods of resolving names to addresses, including your own DNS server, which is an installable component of Windows NT Server. The easiest way of mapping Internet host names to IP addresses, however, is to use the HOSTS file. On Windows NT, this is a text file in the \Winnt\System32\DRIVERS\ETC directory. On Windows 95 and Windows 98, it's in the \WINDOWS directory, in a prototype HOSTS.SAM file that's already there. Just copy that file to HOSTS, and make the entries with Notepad. Make sure that you copy the edited HOSTS file to all computers in the network.

Testing Your Intranet—The Ping Program
--------------------------------------

You can use the Windows Ping program to test your intranet. From the command line, type _ping_ followed by the IP address (dotted-decimal format) or the host name of another computer on the network. If you get a positive response, you'll know that TCP/IP is configured correctly. If you get no response or an error message, proceed no further. Go back and troubleshoot your network connections and configuration.

An Intranet for One Computer—The TCP/IP Loopback Address
--------------------------------------------------------

The first line in the HOSTS file should be

127.0.0.1       localhost

This is the standard loopback IP address. If you start a server program to listen on this address, client programs running on the same machine can connect to localhost to get a TCP/IP connection to the server program. This works whether or not you have network boards installed.
________________________________________________________________________
9.1.4. - [Winsock](invcpp5/ch34e.htm)
----------------------------------------------------
 Winsock 

Winsock
=======

Winsock is the lowest level Windows API for TCP/IP programming. Part of the code is located in wsock32.dll (the exported functions that your program calls), and part is inside the Windows kernel. You can write both internet server programs and internet client programs using the Winsock API. This API is based on the original Berkely Sockets API for UNIX. A new and much more complex version, Winsock 2, is included for the first time with Windows NT 4.0, but we'll stick with the old version because it's the current standard for both Windows NT, Windows 95, and Windows 98.

Synchronous vs. Asynchronous Winsock Programming
------------------------------------------------

Winsock was introduced first for Win16, which did not support multithreading. Consequently, most developers used Winsock in the asynchronous mode. In that mode, all sorts of hidden windows and _PeekMessage_ calls enabled single-threaded programs to make Winsock send and receive calls without blocking, thus keeping the user interface (UI) alive. Asynchronous Winsock programs were complex, often implementing "state machines" that processed callback functions, trying to figure out what to do next based on what had just happened. Well, we're not in 16-bit land anymore, so we can do modern multithreaded programming. If this scares you, go back and review [Chapter 12](ch12a.htm). Once you get used to multithreaded programming, you'll love it.

In this chapter, we will make the most of our Winsock calls from worker threads so that the program's main thread is able to carry on with the UI. The worker threads contain nice, sequential logic consisting of blocking Winsock calls.

The MFC Winsock Classes
-----------------------

We try to use MFC classes where it makes sense to use them, but the MFC developers informed us that the _CAsyncSocket_ and _CSocket_ classes were not appropriate for 32-bit synchronous programming. The Visual C++ online help says you can use _CSocket_ for synchronous programming, but if you look at the source code you'll see some ugly message-based code left over from Win16.

The Blocking Socket Classes
---------------------------

Since we couldn't use MFC, we had to write our own Winsock classes. _CBlockingSocket_ is a thin wrapping of the Winsock API, designed only for synchronous use in a worker thread. The only fancy features are exception-throwing on errors and time-outs for sending and receiving data. The exceptions help you write cleaner code because you don't need to have error tests after every Winsock call. The time-outs (implemented with the Winsock _select_ function) prevent a communication fault from blocking a thread indefinitely.

_CHttpBlockingSocket_ is derived from _CBlockingSocket_ and provides functions for reading HTTP data. _CSockAddr_ and _CBlockingSocketException_ are helper classes.

### The _CSockAddr_ Helper Class

Many Winsock functions take socket address parameters. As you might remember, a socket address consists of a 32-bit IP address plus a 16-bit port number. The actual Winsock type is a 16-byte _sockaddr_in_ structure, which looks like this:

struct sockaddr_in {
    short   sin_family;
    u_short sin_port;
    struct  in_addr sin_addr;
    char    sin_zero[8];
};

The IP address is stored as type _in_addr_, which looks like this:

struct in_addr {
    union {
        struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;
        struct { u_short s_w1,s_w2; } S_un_w;
        u_long S_addr;
    } S_un;
}

These are ugly structures, so we'll derive a programmer-friendly C++ class from _sockaddr_in_. The file \vcpp32\ex34a\Blocksock.h on the CD-ROM contains the following code for doing this, with inline functions included:

class CSockAddr : public sockaddr_in {
public:
    // constructors
    CSockAddr()
    { 
        sin_family = AF_INET;
        sin_port = 0;
        sin_addr.s_addr = 0; 
    } // Default
    CSockAddr(const SOCKADDR& sa) { memcpy(this, &sa,
        sizeof(SOCKADDR)); }
    CSockAddr(const SOCKADDR_IN& sin) { memcpy(this, &sin,
        sizeof(SOCKADDR_IN)); }
    CSockAddr(const ULONG ulAddr, const USHORT ushPort = 0)
    // parms are host byte ordered
    { 
        sin_family = AF_INET;
        sin_port = htons(ushPort);
        sin_addr.s_addr = htonl(ulAddr); 
    }
    CSockAddr(const char\* pchIP, const USHORT ushPort = 0)  
    // dotted IP addr string
    { 
        sin_family = AF_INET;
        sin_port = htons(ushPort);
        sin_addr.s_addr = inet_addr(pchIP); 
    } // already network byte ordered
    // Return the address in dotted-decimal format
    CString DottedDecimal()
        { return inet_ntoa(sin_addr); } 
    // constructs a new CString object
    // Get port and address (even though they're public)
    USHORT Port() const
        { return ntohs(sin_port); }
    ULONG IPAddr() const
        { return ntohl(sin_addr.s_addr); }
    // operators added for efficiency
    const CSockAddr& operator=(const SOCKADDR& sa)
    { 
        memcpy(this, &sa, sizeof(SOCKADDR));
        return \*this; 
    }
    const CSockAddr& operator=(const SOCKADDR_IN& sin)
    { 
        memcpy(this, &sin, sizeof(SOCKADDR_IN));
        return \*this; 
    }
    operator SOCKADDR()
        { return \*((LPSOCKADDR) this); }
    operator LPSOCKADDR()
        { return (LPSOCKADDR) this; }
    operator LPSOCKADDR_IN()
        { return (LPSOCKADDR_IN) this; }
};

As you can see, this class has some useful constructors and conversion operators, which make the _CSockAddr_ object interchangeable with the type _sockaddr_in_ and the equivalent types _SOCKADDR_IN_, _sockaddr_, and _SOCKADDR_. There's a constructor and a member function for IP addresses in dotted-decimal format. The internal socket address is in network byte order, but the member functions all use host byte order parameters and return values. The Winsock functions _htonl_, _htons_, _ntohs_, and _ntohl_ take care of the conversions between network and host byte order.

### The _CBlockingSocketException_ Class

All the _CBlockingSocket_ functions throw a _CBlockingSocketException_ object when Winsock returns an error. This class is derived from the MFC _CException_ class and thus overrides the _GetErrorMessage_ function. This function gives the Winsock error number and a character string that _CBlockingSocket_ provided when it threw the exception.

### The _CBlockingSocket_ Class

Figure 34-9 shows an excerpt from the header file for the _CBlockingSocket_ class.

**BLOCKSOCK.H**

class CBlockingSocket : public CObject
{
    DECLARE_DYNAMIC(CBlockingSocket)
public:
    SOCKET m_hSocket;
    CBlockingSocket();  { m_hSocket = NULL; }
    void Cleanup();
    void Create(int nType = SOCK_STREAM);
    void Close();
    void Bind(LPCSOCKADDR psa);
    void Listen();
    void Connect(LPCSOCKADDR psa);
    BOOL Accept(CBlockingSocket& s, LPCSOCKADDR psa);
    int Send(const char\* pch, const int nSize, const int nSecs);
    int Write(const char\* pch, const int nSize, const int nSecs);
    int Receive(char\* pch, const int nSize, const int nSecs);
    int SendDatagram(const char\* pch, const int nSize, LPCSOCKADDR psa,
        const int nSecs);
    int ReceiveDatagram(char\* pch, const int nSize, LPCSOCKADDR psa,
        const int nSecs);
    void GetPeerAddr(LPCSOCKADDR psa);
    void GetSockAddr(LPCSOCKADDR psa);
    static CSockAddr GetHostByName(const char\* pchName,
        const USHORT ushPort = 0);
    static const char\* GetHostByAddr(LPCSOCKADDR psa);
    operator SOCKET();
        { return m_hSocket; }
};

**Figure 34-9.** _Excerpt from the header file for the_ CBlockingSocket_class._

Following is a list of the _CBlockingSocket_ member functions, starting with the constructor:

*   **_Constructor_**—The _CBlockingSocket_ constructor makes an uninitialized object. You must call the _Create_ member function to create a Windows socket and connect it to the C++ object.
    
*   **_Create_**—This function calls the Winsock _socket_ function and then sets the _m_hSocket_ data member to the returned 32-bit _SOCKET_ handle.

**Parameter**

**Description**

_nType_

Type of socket; should be _SOCK_STREAM_ (the default value) or _SOCK_DGRAM_

*   **_Close_**—This function closes an open socket by calling the Winsock _closesocket_ function. The _Create_ function must have been called previously. The destructor does not call this function because it would be impossible to catch an exception for a global object. Your server program can call _Close_ anytime for a socket that is listening.
*   **_Bind_**—This function calls the Winsock _bind_ function to bind a previously created socket to a specified socket address. Prior to calling _Listen_, your server program calls _Bind_ with a socket address containing the listening port number and server's IP address. If you supply _INADDR_ANY_ as the IP address, Winsock deciphers your computer's IP address.

**Parameter**

**Description**

_psa_

A _CSockAddr_ object or a pointer to a variable of type _sockaddr_

*   **_Listen_**—This TCP function calls the Winsock _listen_ function. Your server program calls _Listen_ to begin listening on the port specified by the previous _Bind_ call. The function returns immediately.
*   **_Accept_**—This TCP function calls the Winsock _accept_ function. Your server program calls _Accept_ immediately after calling _Listen_. _Accept_ returns when a client connects to the socket, sending back a new socket (in a _CBlockingSocket_ object that you provide) that corresponds to the new connection.

Parameter

Description

_s_

A reference to an existing _CBlockingSocket_ object for which _Create_ has not been called

_psa_

A _CSockAddr_ object or a pointer to a variable of type _sockaddr_ for the connecting socket's address

Return value

_TRUE_ if successful

*   **_Connect_**—This TCP function calls the Winsock _connect_ function. Your client program calls _Connect_ after calling _Create_. _Connect_ returns when the connection has been made.

Parameter

Description

_psa_

A _CSockAddr_ object or a pointer to a variable of type _sockaddr_

*   **_Send_**—This TCP function calls the Winsock _send_ function after calling _select_ to activate the time-out. The number of bytes actually transmitted by each _Send_ call depends on how quickly the program at the other end of the connection can receive the bytes. _Send_ throws an exception if the program at the other end closes the socket before it reads all the bytes.

Parameter

Description

_pch_

A pointer to a buffer that contains the bytes to send

_nSize_

The size (in bytes) of the block to send

_nSecs_

Time-out value in seconds

Return value

The actual number of bytes sent

*   **_Write_**—This TCP function calls _Send_ repeatedly until all the bytes are sent or until the receiver closes the socket.

Parameter

Description

_pch_

A pointer to a buffer that contains the bytes to send

_nSize_

The size (in bytes) of the block to send

_nSecs_

Time-out value in seconds

Return value

The actual number of bytes sent

*   **_Receive_**—This TCP function calls the Winsock _recv_ function after calling _select_ to activate the time-out. This function returns only the bytes that have been received. For more information, see the description of the _CHttpBlockingSocket_ class in the next section.

Parameter

Description

_pch_

A pointer to an existing buffer that will receive the incoming bytes

_nSize_

The maximum number of bytes to receive

_nSecs_

Time-out value in seconds

Return value

The actual number of bytes received

*   **_SendDatagram_**—This UDP function calls the Winsock _sendto_ function. The program on the other end needs to call _ReceiveDatagram_. There is no need to call _Listen_, _Accept_, or _Connect_ for datagrams. You must have previously called _Create_ with the parameter set to _SOCK_DGRAM_.

Parameter

Description

_pch_

A pointer to a buffer that contains the bytes to send

_nSize_

The size (in bytes) of the block to send

_psa_

The datagram's destination address; a _CSockAddr_ object or a pointer to a variable of type _sockaddr_

_nSecs_

Time-out value in seconds

Return value

The actual number of bytes sent

*   **_ReceiveDatagram_**—This UDP function calls the Winsock _recvfrom_ function. The function returns when the program at the other end of the connection calls _SendDatagram_. You must have previously called _Create_ with the parameter set to _SOCK_DGRAM_.

Parameter

Description

_pch_

A pointer to an existing buffer that will receive the incoming bytes

_nSize_

The size (in bytes) of the block to send

_psa_

The datagram's destination address; a _CSockAddr_ object or a pointer to a variable of type _sockaddr_

_nSecs_

Time-out value in seconds

Return value

The actual number of bytes received

*   **_GetPeerAddr_**—This function calls the Winsock _getpeername_ function. It returns the port and IP address of the socket on the other end of the connection. If you are connected to the Internet through a Web proxy server, the IP address is the proxy server's IP address.

Parameter

Description

_psa_

A _CSockAddr_ object or a pointer to a variable of type _sockaddr_

*   **_GetSockAddr_**—This function calls the Winsock _getsockname_ function. It returns the socket address that Winsock assigns to this end
*   of the connection. If the other program is a server on a LAN, the IP address is the address assigned to this computer's network board. If the other program is a server on the Internet, your service provider assigns the IP address when you dial in. In both cases, Winsock assigns the port number, which is different for each connection.

Parameter

Description

_psa_

A _CSockAddr_ object or a pointer to a variable of type _sockaddr_

*   **_GetHostByName_**—This static function calls the Winsock function _gethostbyname_. It queries a name server and then returns the socket address corresponding to the host name. The function times out by itself.

Parameter

Description

_pchName_

A pointer to a character array containing the host name to resolve

_ushPort_

The port number (default value 0) that will become part of the returned socket address

Return value

The socket address containing the IP address from the DNS plus the port number _ushPort_

*   **_GetHostByAddr_**—This static function calls the Winsock _gethostbyaddr_ function. It queries a name server and then returns the host name corresponding to the socket address. The function times out by itself.

Parameter

Description

_psa_

A _CSockAddr_ object or a pointer to a variable of type _sockaddr_

Return value

A pointer to a character array containing the host name; the caller should not delete this memory

*   **_Cleanup_**—This function closes the socket if it is open. It doesn't throw an exception, so you can call it inside an exception _catch_ block.
*   **_operator SOCKET_**—This overloaded operator lets you use a _CBlockingSocket_ object in place of a _SOCKET_ parameter.

### The _CHttpBlockingSocket_ Class

If you call _CBlockingSocket::Receive_, you'll have a difficult time knowing when to stop receiving bytes. Each call returns the bytes that are stacked up at your end of the connection at that instant. If there are no bytes, the call blocks, but if the sender closed the socket, the call returns zero bytes.

In the HTTP section, you learned that the client sends a request terminated by a blank line. The server is supposed to send the response headers and data as soon as it detects the blank line, but the client needs to analyze the response headers before it reads the data. This means that as long as a TCP connection remains open, the receiving program must process the received data as it comes in. A simple but inefficient technique would be to call _Receive_ for 1 byte at a time. A better way is to use a buffer.

The _CHttpBlockingSocket_ class adds buffering to _CBlockingSocket_, and it provides two new member functions. Here is part of the \vcpp32\ex34A\Blocksock.h file:

class CHttpBlockingSocket : public CBlockingSocket
{
public:
    DECLARE_DYNAMIC(CHttpBlockingSocket)
    enum {nSizeRecv = 1000}; // max receive buffer size (> hdr line
                             //  length)
    CHttpBlockingSocket();
    ~CHttpBlockingSocket();
    int ReadHttpHeaderLine(char\* pch, const int nSize, const int nSecs);
    int ReadHttpResponse(char\* pch, const int nSize, const int nSecs);
private:
    char\* m_pReadBuf; // read buffer
    int m_nReadBuf; // number of bytes in the read buffer
};

The constructor and destructor take care of allocating and freeing a 1000-character buffer. The two new member functions are as follows:

*   **_ReadHttpHeaderLine_**—This function returns a single header line, terminated with a <cr><lf> pair. _ReadHttpHeaderLine_ inserts a terminating zero at the end of the line. If the line buffer is full, the terminating zero is stored in the last position.

Parameter

Description

_pch_

A pointer to an existing buffer that will receive the incoming line (zero-terminated)

_nSize_

The size of the _pch_ buffer

_nSecs_

Time-out value in seconds

Return value

The actual number of bytes received, excluding the terminating zero

*   **_ReadHttpResponse_**—This function returns the remainder of the server's response received when the socket is closed or when the buffer is full. Don't assume that the buffer contains a terminating zero.

Parameter

Description

_pch_

A pointer to an existing buffer that will receive the incoming data

_nSize_

The maximum number of bytes to receive

_nSecs_

Time-out value in seconds

Return value

The actual number of bytes received

A Simplified HTTP Server Program
--------------------------------

Now it's time to use the blocking socket classes to write an HTTP server program. All the frills have been eliminated, but the code actually works with a browser. This server doesn't do much except return some hard-coded headers and HTML statements in response to any GET request. (See the EX34A program later in this chapter for a more complete HTTP server.)

### Initializing Winsock

Before making any Winsock calls, the program must initialize the Winsock library. The following statements in the application's _InitInstance_ member function do the job:

WSADATA wsd;
WSAStartup(0x0101, &wsd);

### Starting the Server

The server starts in response to some user action, such as a menu choice. Here's the command handler:

CBlockingSocket g_sListen; // one-and-only global socket for listening
void CSocketView::OnInternetStartServer() 
{
    try {
        CSockAddr saServer(INADDR_ANY, 80);
        g_sListen.Create();
        g_sListen.Bind(saServer);
        g_sListen.Listen();
        AfxBeginThread(ServerThreadProc, GetSafeHwnd());
    }
    catch(CBlockingSocketException\* e) {
        g_sListen.Cleanup();
        // Do something about the exception
        e->Delete();
    }
}

Pretty simple, really. The handler creates a socket, starts listening on it, and then starts a worker thread that waits for some client to connect to port 80. If something goes wrong, an exception is thrown. The global _g_sListen_ object lasts for the life of the program and is capable of accepting multiple simultaneous connections, each managed by a separate thread.

### The Server Thread

Now let's look at the _ServerThreadProc_ function:

UINT ServerThreadProc(LPVOID pParam)
{
    CSockAddr saClient;
    CHttpBlockingSocket sConnect;
    char request[100];
    char headers[] = "HTTP/1.0 200 OK\r\n"
        "Server: Inside Visual C++ SOCK01\r\n"
        "Date: Thu, 05 Sep 1996 17:33:12 GMT\r\n"
        "Content-Type: text/html\r\n"
        "Accept-Ranges: bytes\r\n"
        "Content-Length: 187\r\n"
        "\r\n"; // the important blank line
    char html[] =
        "<html><head><title>Inside Visual C++ Server</title></head>\r\n"
        "<body><body background=\"/samples/images/usa1.jpg\">\r\n"
        "<h1><center>This is a custom home page</center></h1><p>\r\n"
        "</body></html>\r\n\r\n";
    try {
        if(!g_sListen.Accept(sConnect, saClient)) {
            // Handler in view class closed the listening socket
            return 0;
        }
        AfxBeginThread(ServerThreadProc, pParam);
        // read request from client
        sConnect.ReadHttpHeaderLine(request, 100, 10);
        TRACE("SERVER: %s", request); // Print the first header
        if(strnicmp(request, "GET", 3) == 0) {
            do { // Process the remaining request headers
                sConnect.ReadHttpHeaderLine(request, 100, 10);
                TRACE("SERVER: %s", request); // Print the other headers
            } while(strcmp(request, "\r\n"));
            sConnect.Write(headers, strlen(headers), 10); // response hdrs
            sConnect.Write(html, strlen(html), 10); // HTML code
        }
        else {
            TRACE("SERVER: not a GET\n");
            // don't know what to do
        }
        sConnect.Close(); // Destructor doesn't close it
    }
    catch(CBlockingSocketException\* e) {
        // Do something about the exception
        e->Delete();
    }
    return 0;
}

The most important function call is the _Accept_ call. The thread blocks until a client connects to the server's port 80, and then _Accept_ returns with a new socket, _sConnect_. The current thread immediately starts another thread.

In the meantime, the current thread must process the client's request that just came in on _sConnect_. It first reads all the request headers by calling _ReadHttpHeaderLine_ until it detects a blank line. Then it calls _Write_ to send the response headers and the HTML statements. Finally, the current thread calls _Close_ to close the connection socket. End of story for this connection. The next thread is sitting, blocked at the _Accept_ call, waiting for the next connection.

### Cleaning Up

To avoid a memory leak on exit, the program must ensure that all worker threads have been terminated. The simplest way to do this is to close the listening socket. This forces any thread's pending _Accept_ to return _FALSE_, causing the thread to exit.

try {
    g_sListen.Close();
    Sleep(340); // Wait for thread to exit
    WSACleanup(); // Terminate Winsock
}
catch(CUserException\* e) {
    e->Delete();
}

A problem might arise if a thread were in the process of fulfilling a client request. In that case, the main thread should positively ensure that all threads have terminated before exiting.

A Simplified HTTP Client Program
--------------------------------

Now for the client side of the story—a simple working program that does a blind GET request. When a server receives a GET request with a slash, as shown below, it's supposed to deliver its default HTML file:

GET / HTTP/1.0

If you typed _http://www.slowsoft.com_ in a browser, the browser sends the blind GET request.

This client program can use the same _CHttpBlockingSocket_ class you've already seen, and it must initialize Winsock the same way the server did. A command handler simply starts a client thread with a call like this:

AfxBeginThread(ClientSocketThreadProc, GetSafeHwnd());

Here's the client thread code:

CString g_strServerName = "localhost"; // or some other host name
UINT ClientSocketThreadProc(LPVOID pParam)
{
    CHttpBlockingSocket sClient;
    char\* buffer = new char[MAXBUF];
    int nBytesReceived = 0;
    char request[] = "GET / HTTP/1.0\r\n";
    char headers[] = // Request headers
        "User-Agent: Mozilla/1.22 (Windows; U; 32bit)\r\n"
        "Accept: \*/\*\r\n"
        "Accept: image/gif\r\n"
        "Accept: image/x-xbitmap\r\n"
        "Accept: image/jpeg\r\n"
        "\r\n"; // need this
    CSockAddr saServer, saClient;
    try {
        sClient.Create();
        saServer = CBlockingSocket::GetHostByName(g_strServerName, 80);
        sClient.Connect(saServer);
        sClient.Write(request, strlen(request), 10);
        sClient.Write(headers, strlen(headers), 10);
        do { // Read all the server's response headers
            nBytesReceived = sClient.ReadHttpHeaderLine(buffer, 100, 10);
        } while(strcmp(buffer, "\r\n")); // through the first blank line
        nBytesReceived = sClient.ReadHttpResponse(buffer, 100, 10);
        if(nBytesReceived == 0) {
            AfxMessageBox("No response received");
        }
        else {
            buffer[nBytesReceived] = \`\0';
            AfxMessageBox(buffer);
        }
    }
    catch(CBlockingSocketException\* e) {
        // Log the exception
        e->Delete();
    }
    sClient.Close();
    delete [] buffer;
    return 0; // The thread exits
}

This thread first calls _CBlockingSocket::GetHostByName_ to get the server computer's IP address. Then it creates a socket and calls _Connect_ on that socket. Now there's a two-way communication channel to the server. The thread sends its GET request followed by some request headers, reads the server's response headers, and then reads the response file itself, which it assumes is a text file. After the thread displays the text in a message box, it exits.
________________________________________________________________________
9.1.5. - [Building a Web Server with CHttpBlockingSocket](invcpp5/ch34f.htm)
----------------------------------------------------
 Building a Web Server with CHttpBlockingSocket 

Building a Web Server with _CHttpBlockingSocket_
================================================

If you need a Web server, your best bet is to buy one or to use the Microsoft Internet Information Server (IIS) that comes bundled with Windows NT Server. Of course, you'll learn more if you build your own server and you'll also have a useful diagnostic tool. And what if you need features that IIS can't deliver? Suppose you want to add Web server capability to an existing Windows application, or suppose you have a custom ActiveX control that sets up its own non-HTTP TCP connection with the server. Take a good look at the server code in EX34A, which works under Windows NT, Windows 95, and Windows 98. It might work as a foundation for your next custom server application.

EX34A Server Limitations
------------------------

The server part of the EX34A program honors GET requests for files, and it has logic for processing POST requests. (POST requests are described in [Chapter 35](ch35a.htm).) These are the two most common HTTP request types. EX34A will not, however, launch Common Gateway Interface (CGI) scripts or load Internet Server Application Programming Interface (ISAPI) DLLs. (You'll learn more about ISAPI in [Chapter 35](ch35a.htm).) EX34A makes no provision for security, and it doesn't have FTP capabilities. Other than that, it's a great server! If you want the missing features, just write the code for them yourself.

EX34A Server Architecture
-------------------------

You'll soon see that EX34A combines an HTTP server, a Winsock HTTP client, and two WinInet HTTP clients. All three clients can talk to the built-in server or to any other server on the Internet. Any client program, including the Telnet utility and standard browsers such as Microsoft Internet Explorer 4.0, can communicate with the EX34A server. You'll examine the client sections a little later in this chapter.

EX34A is a standard MFC SDI document-view application with a view class derived from _CEditView_. The main menu includes Start Server and Stop Server menu choices as well as a Configuration command that brings up a tabbed dialog for setting the home directory, the default file for blind GETs, and the listening port number (usually 80).

The Start Server command handler starts a global socket listening and then launches a thread, as in the simplified HTTP server described previously. Look at the _ServerThreadProc_ function included in the file \vcpp32\ex34a\ServerThread.cpp of the EX34A project on the companion CD-ROM. Each time a server thread processes a request, it logs the request by sending a message to the _CEditView_ window. It also sends messages for exceptions, such as bind errors.

The primary job of the server is to deliver files. It first opens a file, storing a _CFile_ pointer in _pFile_, and then it reads 5 KB (_SERVERMAXBUF_) blocks and writes them to the socket _sConnect_, as shown in the code below:

char\* buffer = new char[SERVERMAXBUF];
DWORD dwLength = pFile->GetLength();
nBytesSent = 0;
DWORD dwBytesRead = 0;
UINT uBytesToRead;
while(dwBytesRead < dwLength) {
    uBytesToRead = min(SERVERMAXBUF, dwLength - dwBytesRead);
    VERIFY(pFile->Read(buffer, uBytesToRead) == uBytesToRead);
    nBytesSent += sConnect.Write(buffer, uBytesToRead, 10);
    dwBytesRead += uBytesToRead;
}

The server is programmed to respond to a GET request for a phony file named Custom. It generates some HTML code that displays the client's IP address, port number, and a sequential connection number. This is one possibility for server customization.

The server normally listens on a socket bound to address _INADDR_ANY_. This is the server's default IP address determined by the Ethernet board or assigned during your connection to your ISP. If your server computer has several IP addresses, you can force the server to listen to one of them by filling in the Server IP Address in the Advanced Configuration page. You can also change the server's listening port number on the Server page. If you choose port 90, for example, browser users would connect to _http://localhost:90_.

The leftmost status bar indicator pane displays "Listening" when the server is running.

Using the Win32 _TransmitFile_ Function
---------------------------------------

If you have Windows NT 4.0, you can make your server more efficient by using the Win32 _TransmitFile_ function in place of the _CFile::Read_ loop in the code excerpt shown. _TransmitFile_ sends bytes from an open file directly to a socket and is highly optimized. The EX34A _ServerThreadProc_ function contains the following line:

if (::TransmitFile(sConnect, (HANDLE) pFile >m_hFile, dwLength, 0, 
    NULL, NULL, TF_DISCONNECT))

If you have Windows NT, uncomment the line

#define USE_TRANSMITFILE

at the top of ServerThread.cpp to activate the _TransmitFile_ logic.

Building and Testing EX34A
--------------------------

Open the \vcpp32\ex34a project in Visual C++, and then build the project. A directory under EX34A, called Website, contains some HTML files and is set up as the EX34A server's home directory, which appears to clients as the server's root directory.

> NOTE
> 
> If you have another HTTP server running on your computer, stop it now. If you have installed IIS along with Windows NT Server, it is probably running now, so you must run the Internet Service Manager program from the Microsoft Internet Server menu. Select the WWW Service line, and then click the stop button (the one with the square). EX34A reports a bind error (10048) if another server is already listening on port 80.

Run the program from the debugger, and then choose Start Server from the Internet menu. Now go to your Web browser and type _localhost_. You should see the Welcome To The Inside Visual C++ Home Page complete with all graphics. The EX34A window should look like this.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G34OG01x.gif)]

Look at the Visual C++ debug window for a listing of the client's request headers.

If you click the browser's Refresh button, you might notice EX34A error messages like this:

WINSOCK ERROR--SERVER: Send error #10054 -- 10/05/96 04:34:10 GMT

This tells you that the browser read the file's modified date from the server's response header and figured out that it didn't need the data because it already had the file in its cache. The browser then closed the socket, and the server detected an error. If the EX34A server were smarter, it would have checked the client's If-Modified-Since request header before sending the file.

Of course, you can test the server on your $99 intranet. Start the server on one computer, and then run the browser from another, typing in the server's host name as it appears in the HOSTS file.

Using Telnet
------------

The Telnet utility is included with Windows 95, Windows 98, and Windows NT. It's useful for testing server programs such as EX34A. With Telnet, you're sending one character at a time, which means that the server's _CBlockingSocket::Receive_ function is receiving one character at a time. The Telnet window is shown here.

![](c:/dl/books/windows/msvc5th/invcpp5/images/g34og02.gif)

The first time you run Telnet, choose Preferences from the Terminal menu and turn on Local Echo. Each time thereafter, choose Remote System from the Connect menu and then type your server name and port number 80. You can type a GET request (followed by a double carriage return), but you'd better type fast because the EX34A server's _Receive_ calls are set to time-out after 10 seconds.
________________________________________________________________________
9.1.6. - [Building a Web Client with CHttpBlockingSocket](invcpp5/ch34g.htm)
----------------------------------------------------
 Building a Web Client with CHttpBlockingSocket 

Building a Web Client with _CHttpBlockingSocket_
================================================

If you had written your own Internet browser program a few years ago, you could have made a billion dollars by now. But these days, you can download browsers for free, so it doesn't make sense to write one. It does make sense, however, to add Internet access features to your Windows applications. Winsock is not the best tool if you need HTTP or FTP access only, but it's a good learning tool.

The EX34A Winsock Client
------------------------

The EX34A program implements a Winsock client in the file \vcpp32\ex34a\ClientSockThread.cpp on the CD-ROM. The code is similar to the code for the simplified HTTP client. The client thread uses global variables set by the Configuration property sheet, including server filename, server host name, server IP address and port, and client IP address. The client IP address is necessary only if your computer supports multiple IP addresses. When you run the client, it connects to the specified server and issues a GET request for the file that you specified. The Winsock client logs error messages in the EX34A main window.

EX34A Support for Proxy Servers
-------------------------------

If your computer is connected to a LAN at work, chances are it's not exposed directly to the Internet but rather connected through a proxy server, sometimes called a firewall. There are two kinds of proxy servers: Web and Winsock. Web proxy servers, sometimes called CERN proxies, support only the HTTP, FTP, and gopher protocols. (The gopher protocol, which predates HTTP, allows character-mode terminals to access Internet files.) A Winsock client program must be specially adapted to use a Web proxy server. A Winsock proxy server is more flexible and thus can support protocols such as RealAudio. Instead of modifying your client program source code, you link to a special Remote Winsock DLL that can communicate with a Winsock proxy server.

The EX34A client code can communicate through a Web proxy if you check the Use Proxy check box in the Client Configuration page. In that case, you must know and enter the name of your proxy server. From that point on, the client code connects to the proxy server instead of to the real server. All GET and POST requests must then specify the full Uniform Resource Locator (URL) for the file.

If you were connected directly to SlowSoft's server, for example, your GET request might look like this:

GET /customers/newproducts.html HTTP/1.0

But if you were connected through a Web proxy server, the GET would look like this:

GET http://slowsoft.com/customers/newproducts.html HTTP/1.0

Testing the EX34A Winsock Client
--------------------------------

The easiest way to test the Winsock client is by using the built-in Winsock server. Just start the server as before, and then choose Request (Winsock) from the Internet menu. You should see some HTML code in a message box. You can also test the client against IIS, the server running in another EX34A process on the same computer, the EX34A server running on another computer on the Net, and an Internet server. Ignore the "Address" URL on the dialog bar for the time being; it's for one of the WinInet clients. You must enter the server name and filename in the Client page of the Configuration dialog.
________________________________________________________________________
9.1.7. - [WinInet](invcpp5/ch34h.htm)
----------------------------------------------------
 WinInet 

WinInet
=======

WinInet is a higher-level API than Winsock, but it works only for HTTP, FTP, and gopher client programs in both asynchronous and synchronous modes. You can't use it to build servers. The WININET DLL is independent of the WINSOCK32 DLL. Microsoft Internet Explorer 3.0 (IE3) uses WinInet, and so do ActiveX controls.

WinInet's Advantages over Winsock
---------------------------------

WinInet far surpasses Winsock in the support it gives to a professional-level client program. Following are just some of the WinInet benefits:

*   **Caching**—Just like IE3, your WinInet client program caches HTML files and other Internet files. You don't have to do a thing. The second time your client requests a particular file, it's loaded from a local disk instead of from the Internet.
    
*   **Security**—WinInet supports basic authentication, Windows NT challenge/response authentication, and the Secure Sockets Layer (SSL). Authentication is described in [Chapter 35](ch35a.htm).
    
*   **Web proxy access**—You enter proxy server information through the Control Panel (click on the Internet icon), and it's stored in the Registry. WinInet reads the Registry and uses the proxy server when required.
    
*   **Buffered I/O**—WinInet's read function doesn't return until it can deliver the number of bytes you asked for. (It returns immediately, of course, if the server closes the socket.) Also, you can read individual text lines if you need to.
    
*   **Easy API**—Status callback functions are available for UI update and cancellation. One function, _CInternetSession::OpenURL_, finds the server's IP address, opens a connection, and makes the file ready for reading, all in one call. Some functions even copy Internet files directly to and from disk.
    
*   **User friendly**—WinInet parses and formats headers for you. If a server has moved a file to a new location, it sends back the new URL in an HTTP Location header. WinInet seamlessly accesses the new server for you. In addition, WinInet puts a file's modified date in the request header for you.
    

The MFC WinInet Classes
-----------------------

WinInet is a modern API available only for Win32. The MFC wrapping is quite good, which means we didn't have to write our own WinInet class library. Yes, MFC WinInet supports blocking calls in multithreaded programs, and by now you know that makes us happy.

The MFC classes closely mirror the underlying WinInet architecture, and they add exception processing. These classes are summarized in the sections on the following pages.

### _CInternetSession_

You need only one _CInternetSession_ object for each thread that accesses the Internet. After you have your _CInternetSession_ object, you can establish HTTP, FTP, or gopher connections or you can open remote files directly by calling the _OpenURL_ member function. You can use the _CInternetSession_ class directly, or you can derive a class from it in order to support status callback functions.

The _CInternetSession_ constructor calls the WinInet _InternetOpen_ function, which returns an _HINTERNET_ session handle that is stored inside the _CInternetSession_ object. This function initializes your application's use of the Win- Inet library, and the session handle is used internally as a parameter for other WinInet calls.

### _CHttpConnection_

An object of class _CHttpConnection_ represents a "permanent" HTTP connection to a particular host. You know already that HTTP doesn't support permanent connections and that FTP doesn't either. (The connections last only for the duration of a file transfer.) WinInet gives the appearance of a permanent connection because it remembers the host name.

After you have your _CInternetSession_ object, you call the _GetHttpConnection_ member function, which returns a pointer to a _CHttpConnection_ object. (Don't forget to delete this object when you are finished with it.)

The _GetHttpConnection_ member function calls the WinInet _InternetConnect_ function, which returns an _HINTERNET_ connection handle that is stored inside the _CHttpConnection_ object and used for subsequent WinInet calls.

### _CFtpConnection_, _CGopherConnection_

These classes are similar to _CHttpConnection_, but they use the FTP and gopher protocols. The _CFtpConnection_ member functions _GetFile_ and _PutFile_ allow you to transfer files directly to and from your disk.

### _CInternetFile_

With HTTP, FTP, or gopher, your client program reads and writes byte streams. The MFC WinInet classes make these byte streams look like ordinary files. If you look at the class hierarchy, you'll see that _CInternetFile_ is derived from _CStdioFile_, which is derived from _CFile_. Therefore, _CInternetFile_ and its derived classes override familiar _CFile_ functions such as _Read_ and _Write_. For FTP files, you use _CInternetFile_ objects directly, but for HTTP and gopher files, you use objects of the derived classes _CHttpFile_ and _CGopherFile_. You don't construct a _CInternetFile_ object directly, but you call _CFtpConnection::OpenFile_ to get a _CInternetFile_ pointer.

If you have an ordinary _CFile_ object, it has a 32-bit _HANDLE_ data member that represents the underlying disk file. A _CInternetFile_ object uses the same _m_hFile_ data member, but that data member holds a 32-bit Internet file handle of type _HINTERNET_, which is not interchangeable with a _HANDLE_. The _CInternetFile_ overridden member functions use this handle to call WinInet functions such as _InternetReadFile_ and _InternetWriteFile_.

### _CHttpFile_

This Internet file class has member functions that are unique to HTTP files, such as _AddRequestHeaders_, _SendRequest_, and _GetFileURL_. You don't construct a _CHttpFile_ object directly, but you call the _CHttpConnection::OpenRequest_ function, which calls the WinInet function _HttpOpenRequest_ and returns a _CHttpFile_ pointer. You can specify a GET or POST request for this call.

Once you have your _CHttpFile_ pointer, you call the _CHttpFile::SendRequest_ member function, which actually sends the request to the server. Then you call _Read_.

### _CFtpFileFind_, _CGopherFileFind_

These classes let your client program explore FTP and gopher directories.

### _CInternetException_

The MFC WinInet classes throw _CInternetException_ objects that your program can process with try/catch logic.

Internet Session Status Callbacks
---------------------------------

WinInet and MFC provide callback notifications as a WinInet operation progresses, and these status callbacks are available in both synchronous (blocking) and asynchronous modes. In synchronous mode (which we're using exclusively here), your WinInet calls block even though you have status callbacks enabled.

Callbacks are easy in C++. You simply derive a class and override selected virtual functions. The base class for WinInet is _CInternetSession_. Now let's derive a class named _CCallbackInternetSession_:

class CCallbackInternetSession : public CInternetSession
{
public:
    CCallbackInternetSession( LPCTSTR pstrAgent = NULL, DWORD dwContext = 1,
        DWORD dwAccessType = PRE_CONFIG_INTERNET_ACCESS,
        LPCTSTR pstrProxyName = NULL, LPCTSTR pstrProxyBypass = NULL,
        DWORD dwFlags = 0 ) { EnableStatusCallback() }
protected:
    virtual void OnStatusCallback(DWORD dwContext, DWORD dwInternalStatus,
        LPVOID lpvStatusInformation, DWORD dwStatusInformationLength);
};

The only coding that's necessary is a constructor and a single overridden function, _OnStatusCallback_. The constructor calls _CInternetSession::EnableStatusCallback_ to enable the status callback feature. Your WinInet client program makes its various Internet blocking calls, and when the status changes, _OnStatusCallback_ is called. Your overridden function quickly updates the UI and returns, and then the Internet operation continues. For HTTP, most of the callbacks originate in the _CHttpFile::SendRequest_ function.

What kind of events trigger callbacks? A list of the codes passed in the _dwInternalStatus_ parameter is shown here.

**Code Passed**

**Action Taken**

_INTERNET_STATUS_RESOLVING_NAME_

Looking up the IP address of the supplied name. The name is now in _lpvStatusInformation_.

_INTERNET_STATUS_NAME_RESOLVED_

Successfully found the IP address. The IP address is now in _lpvStatusInformation_.

_INTERNET_STATUS_CONNECTING_TO_SERVER_

Connecting to the socket.

_INTERNET_STATUS_CONNECTED_TO_SERVER_

Successfully connected to the socket.

_INTERNET_STATUS_SENDING_REQUEST_

Send the information request to the server.

_INTERNET_STATUS_REQUEST_SENT_

Successfully sent the information request to the server.

_INTERNET_STATUS_RECEIVING_RESPONSE_

Waiting for the server to respond to a request.

_INTERNET_STATUS_RESPONSE_RECEIVED_

Successfully received a response from the server.

_INTERNET_STATUS_CLOSING_CONNECTION_

Closing the connection to the server.

_INTERNET_STATUS_CONNECTION_CLOSED_

Successfully closed the connection to the server.

_INTERNET_STATUS_HANDLE_CREATED_

Program can now close the handle.

_INTERNET_STATUS_HANDLE_CLOSING_

Successfully terminated this handle value.

_INTERNET_STATUS_REQUEST_COMPLETE_

Successfully completed the asynchronous operation.

You can use your status callback function to interrupt a WinInet operation. You could, for example, test for an event set by the main thread when the user cancels the operation.

A Simplified WinInet Client Program
-----------------------------------

And now for the WinInet equivalent of our Winsock client program that implements a blind GET request. Because you're using WinInet in blocking mode, you must put the code in a worker thread. That thread is started from a command handler in the main thread:

AfxBeginThread(ClientWinInetThreadProc, GetSafeHwnd());

Here's the client thread code:

CString g_strServerName = "localhost"; // or some other host name
UINT ClientWinInetThreadProc(LPVOID pParam)
{
    CInternetSession session;
    CHttpConnection\* pConnection = NULL;
    CHttpFile\* pFile1 = NULL;
    char\* buffer = new char[MAXBUF];
    UINT nBytesRead = 0;
    try {
        pConnection = session.GetHttpConnection(g_strServerName, 80);
        pFile1 = pConnection->OpenRequest(1, "/"); // blind GET
        pFile1->SendRequest();
        nBytesRead = pFile1->Read(buffer, MAXBUF - 1);
        buffer[nBytesRead] = \`\0'; // necessary for message box
        char temp[10];
        if(pFile1->Read(temp, 10) != 0) {
            // makes caching work if read complete
            AfxMessageBox("File overran buffer — not cached");
        }
        AfxMessageBox(buffer);
    }
    catch(CInternetException\* e) {
        // Log the exception
        e->Delete();
    }
    if(pFile1) delete pFile1;
    if(pConnection) delete pConnection;
    delete [] buffer;
    return 0;
}

The second _Read_ call needs some explanation. It has two purposes. If the first _Read_ doesn't read the whole file, that means that it was longer than _MAXBUF -1_. The second _Read_ will get some bytes, and that lets you detect the overflow problem. If the first _Read_ reads the whole file, you still need the second _Read_ to force WinInet to cache the file on your hard disk. Remember that WinInet tries to read all the bytes you ask it to—through the end of the file. Even so, you need to read 0 bytes after that.
________________________________________________________________________
9.1.8. - [Building a Web Client with the MFC WinInet Classes](invcpp5/ch34i.htm)
----------------------------------------------------
 Building a Web Client with the MFC WinInet Classes 

Building a Web Client with the MFC WinInet Classes
==================================================

There are two ways to build a Web client with WinInet. The first method, using the _CHttpConnection_ class, is similar to the simplified WinInet client on the preceding page. The second method, using _CInternetSession::OpenURL_, is even easier. We'll start with the _CHttpConnection_ version.

The EX34A WinInet Client #1—Using _CHttpConnection_
---------------------------------------------------

The EX34A program implements a WinInet client in the file \vcpp32\ex34a\ClientInetThread.cpp on the CD-ROM. Besides allowing the use of an IP address as well as a host name, the program uses a status callback function. That function, _CCallbackInternetSession::OnStatusCallback_ in the file \vcpp32\ex34a\utility.cpp, puts a text string in a global variable _g_pchStatus_, using a critical section for synchronization. The function then posts a user-defined message to the application's main window. The message triggers an Update Command UI handler (called by _CWinApp::OnIdle_), which displays the text in the second status bar text pane.

Testing the WinInet Client #1
-----------------------------

To test the WinInet client #1, you can follow the same procedure you used to test the Winsock client. Note the status bar messages as the connection is made. Note that the file appears more quickly the second time you request it.

The EX34A WinInet Client #2—Using _OpenURL_
-------------------------------------------

The EX34A program implements a different WinInet client in the file ClientUrlThread.cpp on the companion CD-ROM. This client uses the "Address" URL (that you type to access the Internet site). Here's the actual code:

CString g_strURL = "http:// ";

UINT ClientUrlThreadProc(LPVOID pParam)
{
    char\* buffer = new char[MAXBUF];
    UINT nBytesRead = 0;

    CInternetSession session; // can't get status callbacks for OpenURL
    CStdioFile\* pFile1 = NULL; // could call ReadString to get 1 line
    try {
        pFile1 = session.OpenURL(g_strURL, 0, INTERNET_FLAG_TRANSFER_BINARY
            |INTERNET_FLAG_KEEP_CONNECTION);
         // If OpenURL fails, we won't get past here
        nBytesRead = pFile1->Read(buffer, MAXBUF - 1);
        buffer[nBytesRead] = \`\0'; // necessary for message box
        char temp[100];
        if(pFile1->Read(temp, 100) != 0) { 
            // makes caching work if read complete
            AfxMessageBox("File overran buffer — not cached");
        }
        ::MessageBox(::GetTopWindow(::GetDesktopWindow()), buffer, 
            "URL CLIENT", MB_OK);
    }
    catch(CInternetException\* e) {
        LogInternetException(pParam, e);
        e->Delete();
    }
    if(pFile1) delete pFile1;
    delete [] buffer;
    return 0;
}

Note that _OpenURL_ returns a pointer to a _CStdioFile_ object. You can use that pointer to call _Read_ as shown, or you can call _ReadString_ to get a single line. The file class does all the buffering. As in the previous WinInet client, it's necessary to call _Read_ a second time to cache the file. The _OpenURL_ _INTERNET_FLAG_KEEP_CONNECTION_ parameter is necessary for Windows NT challenge/response authentication, which is described in [Chapter 35](ch35a.htm). If you added the flag _INTERNET_FLAG_RELOAD_, the program would bypass the cache just as the browser does when you click the Refresh button.

Testing the WinInet Client #2
-----------------------------

You can test the WinInet client #2 against any HTTP server. You run this client by typing in the URL address, not by using the menu. You must include the protocol (http:// or ftp://) in the URL address. Type _http://localhost_. You should see the same HTML code in a message box. No status messages appear here because the status callback doesn't work with _OpenURL_.
________________________________________________________________________
9.1.9. - [Asynchronous Moniker Files](invcpp5/ch34j.htm)
----------------------------------------------------
 Asynchronous Moniker Files 

Asynchronous Moniker Files
==========================

Just when you thought you knew all the ways to download a file from the Internet, you're going to learn about another one. With asynchronous moniker files, you'll be doing all your programming in your application's main thread without blocking the user interface. Sounds like magic, doesn't it? The magic is inside the Windows URLMON DLL, which depends on WinInet and is used by Microsoft Internet Explorer. The MFC _CAsyncMonikerFile_ class makes the programming easy, but you should know a little theory first.

Monikers
--------

A moniker is a "surrogate" COM object that holds the name (URL) of the "real" object, which could be an embedded component but more often is just an Internet file (HTML, JPEG, GIF, and so on). Monikers implement the _IMoniker_ interface, which has two important member functions: _BindToObject_ and _BindToStorage_. The _BindToObject_ function puts an object into the running state, and the _BindToStorage_ function provides an _IStream_ or an _IStorage_ pointer from which the object's data can be read. A moniker has an associated _IBindStatusCallback_ interface with member functions such as _OnStartBinding_ and _OnDataAvailable_, which are called during the process of reading data from a URL.

The callback functions are called in the thread that created the moniker. This means that the URLMON DLL must set up an invisible window in the calling thread and send the calling thread messages from another thread, which uses WinInet functions to read the URL. The window's message handlers call the callback functions.

The MFC _CAsyncMonikerFile_ Class
---------------------------------

Fortunately, MFC can shield you from the COM interfaces described above. The _CAsyncMonikerFile_ class is derived from _CFile_, so it acts like a regular file. Instead of opening a disk file, the class's _Open_ member function gets an _IMoniker_ pointer and encapsulates the _IStream_ interface returned from a call to _BindToStorage_. Furthermore, the class has virtual functions that are tied to the member functions of _IBindStatusCallback_. Using this class is a breeze; you construct an object or a derived class and call the _Open_ member function, which returns immediately. Then you wait for calls to overridden virtual functions such as _OnProgress_ and _OnDataAvailable_, named, not coincidentally, after their _IBindStatusCallback_ equivalents.

Using the _CAsyncMonikerFile_ Class in a Program
------------------------------------------------

Suppose your application downloads data from a dozen URLs but has only one class derived from _CAsyncMonikerFile_. The overridden callback functions must figure out where to put the data. That means you must associate each derived class object with some UI element in your program. The steps listed below illustrate one of many ways to do this. Suppose you want to list the text of an HTML file in an edit control that's part of a form view. This is what you can do:

1.  Use ClassWizard to derive a class from _CAsyncMonikerFile_.
    
2.  Add a character pointer data member _m_buffer_. Invoke _new_ for this pointer in the constructor; invoke _delete_ in the destructor.
    
3.  Add a public data member _m_edit_ of class _CEdit_.
    
4.  Override the _OnDataAvailable_ function thus:
    
    void CMyMonikerFile::OnDataAvailable(DWORD dwSize, DWORD bscfFlag) 
    {
        try {
            UINT nBytesRead = Read(m_buffer, MAXBUF - 1);
            TRACE("nBytesRead = %d\n", nBytesRead);
            m_buffer[nBytesRead] = \`\0'; // necessary for edit control
            // The following two lines add text to the edit control
            m_edit.SendMessage(EM_SETSEL, (WPARAM) 999999, 1000000);
            m_edit.SendMessage(EM_REPLACESEL, (WPARAM) 0,
                (LPARAM) m_buffer);
        }
        catch(CFileException\* pe) {
            TRACE("File exception %d\n, pe->m_cause");
            pe->Delete();
        }
    }
    
5.  Embed an object of your new moniker file class in your view class.
    
6.  In you view's _OnInitialUpdate_ function, attach the _CEdit_ member to the edit control like this:
    
    m_myEmbeddedMonikerFile.m_edit.SubClassDlgItem(ID_MYEDIT, this);
    
7.  In your view class, open the moniker file like this:
    
    m_myEmbeddedMonikerFile.Open("http://host/filename");
    
    For a large file, _OnDataAvailable_ will be called several times, each time adding text to the edit control. If you override _OnProgress_ or _OnStopBinding_ in your derived moniker file class, your program can be alerted when the transfer is finished. You can also check the value of _bscfFlag_ in _OnDataAvailable_ to determine whether the transfer is completed. Note that everything here is in your main thread and—most important—the moniker file object must exist for as long as the transfer is in progress. That's why it's a data member of the view class.
    

Asynchronous Moniker Files vs. WinInet Programming
--------------------------------------------------

In the WinInet examples earlier in this chapter, you started a worker thread that made blocking calls and sent a message to the main thread when it was finished. With asynchronous moniker files, the same thing happens—the transfer takes place in another thread, which sends messages to the main thread. You just don't see the other thread. There is one very important difference, however, between asynchronous moniker files and WinInet programming: with blocking WinInet calls, you need a separate thread for each transfer; with asynchronous moniker files, only one extra thread handles all transfers together. For example, if you're writing a browser that must download 50 bitmaps simultaneously, using asynchronous moniker files saves 49 threads, which makes the program much more efficient.

Of course, you have some extra control with WinInet, and it's easier to get information from the response headers, such as total file length. Your choice of programming tools, then, depends on your application. The more you know about your options, the better your choice will be.
________________________________________________________________________
9.2. - [Chapter 35 -- Programming the Microsoft Internet Information Server](invcpp5/ch35a.htm)
----------------------------------------------------
 Chapter 35 -- Programming the Microsoft Internet Information Server  Chapter 35

Programming the Microsoft Internet Information Server
=====================================================

In [Chapter 34](ch34a.htm), you used a "homemade" Web based on the Winsock APIs. In this chapter, you'll learn how to use and extend Microsoft Internet Information Server (IIS) 4.0, which is bundled with Microsoft Windows NT Server 4.0. IIS is actually three separate servers—one for HTTP (for the World Wide Web), one for FTP, and one for gopher. This chapter tells you how to write HTTP server extensions using the Microsoft IIS application programming interface (ISAPI) that is part of Microsoft ActiveX technology. You'll examine two kinds of extensions: an ISAPI server extension and an ISAPI filter, both of which are DLLs. An ISAPI server extension can perform Internet business transactions such as order entry. An ISAPI filter intercepts data traveling to and from the server and thus can perform specialized logging and other tasks.
________________________________________________________________________
9.2.1. - [IIS Alternatives](invcpp5/ch35b.htm)
----------------------------------------------------
 IIS Alternatives 

IIS Alternatives
================

The exercises in this chapter assume that you have Windows NT Server 4.0 and IIS. If you are running Windows NT Workstation, you can use Peer Web Services, which supports fewer connections and doesn't allow virtual servers. If you are running Microsoft Windows 95 or Windows 98, you can use Personal Web Server, which is packaged with Microsoft FrontPage. Internet Information Server, Peer Web Services, and Personal Web Server can all use ISAPI extension DLLs. See your server's documentation for operating details.
________________________________________________________________________
9.2.2. - [Microsoft IIS](invcpp5/ch35c.htm)
----------------------------------------------------
 Microsoft IIS 

Microsoft IIS
=============

Microsoft IIS is a high-performance Internet/intranet server that takes advantage of Windows NT features such as I/O completion ports, the Win32 function _TransmitFile_, file-handle caching, and CPU scaling for threads.

Installing and Controlling IIS
------------------------------

When you install Windows NT Server 4.0, you are given the option of installing IIS. If you selected IIS at setup, the server will be running whenever Windows NT is running. IIS is a special kind of Win32 program called a service (actually three services—WWW, HTTP, and gopher—in one program called inetinfo.exe), which won't appear in the taskbar. You can control IIS from the Services icon in the Control Panel, but you'll probably want to use the Internet Service Manager program instead.

Running Internet Service Manager
--------------------------------

You can run Internet Service Manager from the Microsoft Internet Server menu that's accessible on the Start menu.

> NOTE
> 
> You can also run an HTML-based version of Internet Service Manager remotely from a browser. That version allows you to change service parameters, but it won't let you turn services on and off.

Figure 35-1 shows the Microsoft Internet Service Manager screen with the World Wide Web (WWW) running and FTP services stopped.

You can select a service by clicking on its icon at the left. The triangle and square buttons on the toolbar of the screen allow you to turn the selected service on or off.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f35og01x.gif)]

**Figure 35-1.** _The Microsoft Internet Service Manager screen._

### IIS Security

After you double-click on the WWW service icon of the Microsoft Internet Service Manager screen, you'll see a property sheet. The Service page lets you configure IIS security. When a client browser requests a file, the server impersonates a local user for the duration of the request and that user name determines which files the client can access. Which local user does the server impersonate? Most often, it's the one you see in the Username field, shown in Figure 35-2.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f35og02x.gif)]

**Figure 35-2.** _The WWW Service Properties screen._

Most Web page visitors don't supply a user name and password, so they are considered anonymous users. Those users have the same rights they would have if they had logged on to your server locally as IUSR_MYMACHINENAME. That means that IUSR_MYMACHINENAME must appear in the list of users that is displayed when you run User Manager or User Manager For Domains (from the Administrative Tools menu), and the passwords must match. The IIS Setup program normally defines this anonymous user for you. You can define your own WWW anonymous user name, but you must be sure that the entry on the Service page matches the entry in the computer's (or Windows NT domain's) user list.

Note also the Password Authentication options. For the time being, stick to the Allow Anonymous option only, which means that all Web users are logged on as IUSR_MYMACHINENAME. Later in this chapter, we'll explain Windows NT Challenge/Response.

### IIS Directories

Remember SlowSoft's Web site from [Chapter 34](ch34a.htm)? If you requested the URL http://slowsoft.com/newproducts.html, the newproducts.html file would be displayed from the slowsoft.com home directory. Each server needs a home directory, even if that directory contains only subdirectories. The home directory does not need to be the server computer's root directory, however. As shown in Figure 35-3, the WWW home directory is really \WebHome, so clients read the disk file \WebHome\newproducts.html.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f35og03x.gif)]

**Figure 35-3.** _The \WebHome WWW home directory screen._

Your server could get by with a home directory only, but the IIS virtual directory feature might be useful. Suppose SlowSoft wanted to allow Web access to the directory \BF on the D drive. The screen above shows a virtual /BugsFixed directory that maps to D:\BF. Clients would access files with a URL similar to this: http://slowsoft.com/BugsFixed/file1.html.

> NOTE
> 
> If your computer was configured for multiple IP addresses (see the Control Panel Network icon), IIS would allow you to define virtual Web servers. Each virtual server would have its own home directory (and virtual directories) attached to a specified IP address, making it appear as though you had several server computers. Unfortunately, the IIS Web server listens on all the computer's IP addresses, so you can't run IIS simultaneously with the EX34A server with both listening on port 80.

As described in [Chapter 34](ch34a.htm), browsers can issue a blind request. As Figure 35-3 shows, Internet Service Manager lets you specify the file that a blind request selects, usually Default.htm. If you select the Directory Browsing Allowed option of the Directories page on the service property screen, browser clients can see a hypertext list of files in the server's directory instead.

### IIS Logging

IIS is capable of making log entries for all connections. You control logging from the Internet Service Manager's Logging property page. You can specify text log files, or you can specify logging to an SQL/ODBC database. Log entries consist of date, time, client IP address, file requested, query string, and so forth.

Testing IIS
-----------

It's easy to test IIS with a browser or with any of the EX35A clients. Just make sure that IIS is running and that the EX35A server is not running. The default IIS home directory is \Winnt\System32\inetsrv\wwwroot, and some HTML files are installed there. If you're running a single machine, you can use the localhost host name. For a network, use a name from the Hosts file. If you can't access the server from a remote machine, run ping to make sure the network is configured correctly. Don't try to build and run ISAPI DLLs until you have successfully tested IIS on your computer.
________________________________________________________________________
9.2.3. - [ISAPI Server Extensions](invcpp5/ch35d.htm)
----------------------------------------------------
 ISAPI Server Extensions 

ISAPI Server Extensions
=======================

An ISAPI server extension is a program (implemented as a DLL loaded by IIS) that runs in response to a GET or POST request from a client program (browser). The browser can pass parameters to the program, which are often values that the browser user types into edit controls, selects from list boxes, and so forth. The ISAPI server extension typically sends back HTML code based on those parameter values. You'll better understand this process when you see an example.

Common Gateway Interface and ISAPI
----------------------------------

Internet server programs were first developed for UNIX computers, so the standards were in place long before Microsoft introduced IIS. The Common Gateway Interface (CGI) standard, actually part of HTTP, evolved as a way for browser programs to interact with scripts or separate executable programs running on the server. Without altering the HTTP/CGI specifications, Microsoft designed IIS to allow any browser to load and run a server DLL. DLLs are part of the IIS process and thus are faster than scripts that might need to load separate executable programs. Because of your experience, you'll probably find it easier to write an ISAPI DLL in C++ than to write a script in PERL, the standard Web scripting language for servers.

CGI shifts the programming burden to the server. Using CGI parameters, the browser sends small amounts of information to the server computer, and the server can do absolutely anything with this information, including access a database, generate images, and control peripheral devices. The server sends a file (HTML or otherwise) back to the browser. The file can be read from the server's disk, or it can be generated by the program. No ActiveX controls or Java applets are necessary, and the browser can be running on any type of computer.

A Simple ISAPI Server Extension GET Request
-------------------------------------------

Suppose an HTML file contains the following tag:

<a href="scripts/maps.dll?State=Idaho">Idaho Weather Map</a><p>

When the user clicks on _Idaho Weather Map_, the browser sends the server a CGI GET request like this:

GET scripts/maps.dll?State=Idaho HTTP/1.0

IIS then loads maps.dll from its scripts (virtual) directory, calls a default function (often named _Default_), and passes it the _State_ parameter _Idaho_. The DLL then goes to work generating a JPG file containing the up-to-the-minute satellite weather map for Idaho and sends it to the client.

If maps.dll had more than one function, the tag could specify the function name like this:

<a href="scripts/maps.dll?GetMap?State=Idah
o&Res=5">Idaho Weather Map</a><p>

In this case, the function _GetMap_ is called with two parameters, _State_ and _Res_.

You'll soon learn how to write an ISAPI server similar to maps.dll, but first you'll need to understand HTML forms, because you don't often see CGI GET requests by themselves.

HTML Forms—GET vs. POST
-----------------------

In the HTML code for the simple CGI GET request above, the state name was hard-coded in the tag. Why not let the user select the state from a drop-down list? For that, you need a form, and here's a simple one that can do the job.

<html>
<head><title>Weathermap HTML Form</title>
</head>
<body>
<h1><center>Welcome to the Satellite Weathermap Service</center></h1>
<form action="scripts/maps.dll?GetMap" method=GET>
    <p>Select your state:
    <select name="State">
        <option> Alabama
        <option> Alaska
        <option> Idaho
        <option> Washington
    </select>
<p><input type="submit"><input type="reset">
</form>
</body></html>

If you looked at this HTML file with a browser, you would see the form shown in Figure 35-4.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f35og04x.gif)]

**Figure 35-4.** _The Weathermap HTML Form window._

The select tag provides the state name from a list of four states, and the all-important "submit" input tag displays the pushbutton that sends the form data to the server in the form of a CGI GET request that looks like this:

GET scripts/maps.dll?GetMap?State=Idaho HTTP/1.0
_(various request headers)
(blank line)_

Unfortunately, some early versions of the Netscape browser omit the function name in form-originated GET requests, giving you two choices: provide only a default function in your ISAPI DLL, and use the POST method inside a form instead of the GET method.

If you want to use the POST option, change one HTML line in the form above to the following:

<form action="scripts/maps.dll?GetMap" method=POST>

Now here's what the browser sends to the server:

POST scripts/maps.dll?GetMap
_(various request headers)
(blank line)_

State=Idaho

Note that the parameter value is in the last line instead of in the request line.

> NOTE
> 
> ISAPI DLLs are usually stored in a separate virtual directory on the server because these DLLs must have execute permission but do not need read permission. Clicking the Edit Properties button shown in Figure 35-3 will allow you to access these permissions from the Internet Service Manager, or you can double-click on a directory to change its properties.

Writing an ISAPI Server Extension DLL
-------------------------------------

Visual C++ gives you a quick start for writing ISAPI server extensions. Just select ISAPI Extension Wizard from the Projects list. After you click the OK button, your first screen looks like Figure 35-5.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f35og05x.gif)]

**Figure 35-5.** _The Step 1 page of the ISAPI Extension Wizard._

Check the Generate A Server Extension Object box, and you've got a do-nothing DLL project with a class derived from the MFC _CHttpServer_ class and a _Default_ member function. Now it's time for a little programming.

You must write your ISAPI functions as members of the derived _CHttpServer_ class, and you must write parse map macros to link them to IIS. There's no "parse map wizard," so you have to do some coding. It's okay to use the _Default_ function, but you need a _GetMap_ function too. First insert these lines into the wizard-generated parse map:

ON_PARSE_COMMAND(GetMap, CWeatherExtension, ITS_PSTR)
ON_PARSE_COMMAND_PARAMS("State")

Then write the _GetMap_ function:

void CWeatherExtension::GetMap(CHttpServerContext\* pCtxt, LPCTSTR pstrState)
{
    StartContent(pCtxt);
    WriteTitle(pCtxt);
    \*pCtxt << "Visualize a weather map for the state of ";
    \*pCtxt << pstrState;
    EndContent(pCtxt);
}

This function doesn't actually generate the weather map (what did you expect?), but it does display the selected state name in a custom HTML file. The _CHttpServer::StartContent_ and _CHttpServer::EndContent_ functions write the HTML boilerplate, and _CHttpServer::WriteTitle_ calls the virtual _CHttpServer::GetTitle_ function, which you need to override:

LPCTSTR CWeatherExtension::GetTitle() const
{
    return "Your custom weather map"; // for browser's title window
}

The MFC _CHttpServerContext_ class has an overloaded << operator, which you use to put text in the HTML file you're building. Behind the scenes, an attached object of the MFC class _CHtmlStream_ represents the output to the server's socket.

The MFC ISAPI Server Extension Classes
--------------------------------------

Now is a good time to review the three MFC classes that are used to create an MFC ISAPI server extension. Remember that these classes are for ISAPI server extensions only. Don't even think of using them in ordinary Winsock or WinInet applications.

### _CHttpServer_

With the help of the ISAPI Extension Wizard, you derive a class from _CHttpServer_ for each ISAPI server extension DLL that you create. You need one member function for each extension function (including the default function), and you need an overridden _GetTitle_ function. The framework calls your extension functions in response to client requests, using the connections established in the parse map. The ISAPI Extension Wizard provides an overridden _GetExtensionVersion_ function, which you seldom edit unless you need initialization code to be executed when the DLL is loaded.

One of the _CHttpServer_ member functions that you're likely to call is _AddHeader_, which adds special response headers, such as Set-Cookie, before the response is sent to the server. (More on cookies later.)

### _CHttpServerContext_

There's one _CHttpServer_ object per DLL, but there is one _CHttpServerContext_ object for each server transaction request. Your extension functions each provide a pointer to one of these objects. You don't derive from _CHttpServerContext_, so you can't easily have variables for individual transactions. Because different IIS threads can manage transactions, you have to be careful to perform synchronization for any data members of your _CHttpServer_ class or global variables.

You've already seen the use of the _StartContent_, _EndContent_, and _WriteTitle_ functions of the _CHttpServer_ class plus the overloaded >> operator. You might also need to call the _CHttpServerContext::GetServerVariable_ function to read information sent by the client in the request headers.

### _CHtmlStream_

Most of the time, you don't use the _CHtmlStream_ class directly. The _CHttpServerContext_ class has a _CHtmlStream_ data member, _m_pStream_, that's hooked up to the >> operator and serves as the output for HTML data. You could access the _CHtmlStream_ object and call its _Write_ member function if you needed to send binary data to the client. Because objects of the _CHtmlStream_ class accumulate bytes in memory before sending them to the client, you need an alternative approach if your DLL relays large files directly from disk.
________________________________________________________________________
9.2.4. - [A Practical ISAPI Server Extension -- ex35a.dll](invcpp5/ch35e.htm)
----------------------------------------------------
 A Practical ISAPI Server Extension -- ex35a.dll 

A Practical ISAPI Server Extension—ex35a.dll
============================================

The weather map server isn't interesting enough to make into a real project. You'll probably find the EX35A example more to your taste. It's a real Internet commerce application—a pizza-ordering program. Imagine a computer-controlled pizza oven and a robot arm that selects frozen pizzas. (Microsoft Internet Explorer 17.0 is supposed to be able to deliver the hot pizzas directly from your clients' monitors, but in the meantime, you'll have to hire some delivery drivers.)

The First Step—Getting the Order
--------------------------------

Junior sales trainees are constantly admonished to "get the order." That's certainly necessary in any form of commerce, including the Internet. When the hungry customer hyperlinks to your site (by clicking on a picture of a pizza, of course), he or she simply downloads an HTML file that looks like this:

<html>
<head><title>Inside Visual C++ HTML Form 1</title>
</head>
<body>
<h1><center>Welcome to CyberPizza</center></h1>
<p> Enter your order.
<form action="scripts/ex35a.dll?ProcessPizzaForm" method=POST>
    <p> Your Name: <input type="text" name="name" value="">
    <p> Your Address: <input type="text" name="address" value="">
    <p> Number of Pies: <input type="text" name="quantity" value=1>
    <p>Pizza Size:
        <menu>
            <li><input type="radio" name="size" value=8>8-inch
            <li><input type="radio" name="size" value=10>10-inch
            <li><input type="radio" name="size" value=12 checked>12-inch
            <li><input type="radio" name="size" value=14>14-inch
        </menu>
    <p> Toppings:
    <p>
        <input type="checkbox" name="top1" value="Pepperoni" checked>
            Pepperoni
        <input type="checkbox" name="top2" value="Onions"> Onions
        <input type="checkbox" name="top3" value="Mushrooms"> Mushrooms
        <input type="checkbox" name="top4" value="Sausage"> Sausage
    <p>
        <em>(you can select multiple toppings)</em>
    <p><input type="submit" value="Submit Order Now"><input type="reset">
</form>
</body></html>

Figure 35-6 shows how the order form appears in the browser.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f35og06x.gif)]

**Figure 35-6.** _The CyberPizza order form._

So far, no ISAPI DLL is involved. When the customer clicks the Submit Order Now button, the action begins. Here's what the server sees:

POST scripts/ex35a.dll?ProcessPizzaForm HTTP/1.0
_(request headers)
(blank line)_
name=Walter+Sullivan&address=Redmond%2C+WA&quantity=2&size=12&top1=Pepperoni
    &top3=Mushrooms

Looks like Walter Sullivan has ordered two 12-inch pepperoni and mushroom pizzas. The browser inserts a + sign in place of a space, the _%2C_ is a comma, and the _&_ is the parameter separator. Now let's look at the parse map entries in ex35a.cpp:

ON_PARSE_COMMAND(ProcessPizzaForm, CEx35aExtension,
    ITS_PSTR ITS_PSTR ITS_I4 ITS_PSTR ITS_PSTR ITS_PSTR ITS_PSTR ITS_PSTR)
ON_PARSE_COMMAND_PARAMS("name address quantity size top1=~ top2=~ top3=~ top4=~")

> **Optional Parameters**
> 
> When you write your parse map statements, you must understand the browser's rules for sending parameter values from a form. In the EX35A pizza form, the browser always sends parameters for text fields, even if the user enters no data. If the user left the Name field blank, for example, the browser would send _name=&_. For check box fields, however, it's a different story. The browser sends the check box parameter value only if the user checks the box. The parameters associated with check boxes are thus defined as optional parameters.
> 
> If your parse macro for parameters looked like this
> 
> ON_PARSE_COMMAND_PARAMS("name address quantity size top1 top2 top3 top4")
> 
> there would be trouble if the customer didn't check all the toppings. The HTTP request would simply fail, and the customer would have to search for another pizza site. The =~ symbols in the ex35a.cpp code designate the last four parameters as optional, with default values ~. If the Toppings option is checked, the form transmits the value; otherwise, it transmits a ~ character, which the DLL can test for. Optional parameters must be listed last.

The DLL's _ProcessPizzaForm_ function reads the parameter values and produces an HTML confirmation form, which it sends to the customer. Here is part of the function's code:

        \*pCtxt << "<form action=\"ex35a.dll?ConfirmOrder\" method=POST>";
        \*pCtxt << "<p><input type=\"hidden\" name=\"name\" value=\"";
        \*pCtxt << pstrName << "\">"; // xref to original order
        \*pCtxt << "<p><input type=\"submit\" value=\"Confirm and charge my credit card\">";
        \*pCtxt << "</form>";
        // Store this order in a disk file or database, referenced by name
    }
    else {
        \*pCtxt << "You forgot to enter name or address. Back up and try again. ";
    }
    EndContent(pCtxt);

The resulting browser screen is shown in Figure 35-7.

![](c:/dl/books/windows/msvc5th/invcpp5/images/f35og07.gif)

**Figure 35-7.** _The pizza confirmation browser screen._

As you can see, we took a shortcut computing the price. To accept, the customer clicks the submit button named Confirm And Charge My Credit Card.

The Second Step—Processing the Confirmation
-------------------------------------------

When the user clicks the Confirm And Charge My Credit Card button, the browser sends a second POST request to the server, specifying that the _CEx35aExtension::ConfirmOrder_ function be called. But now you have to solve a big problem. Each HTTP connection (request/response) is independent of all others. How are you going to link the confirmation request with the original order? Although there are different ways to do this, the most common approach is to send some text back with the confirmation in a hidden input tag. When the confirmation parameter values come back, the server uses the hidden text to match the confirmation to the original order, which it has stored somewhere on its hard disk.

In the EX35A example, the customer's name is used in the hidden field, although it might be safer to use some combination of the name, date, and time. Here's the HTML code that _CEx35aExtension::ProcessPizzaForm_ sends to the customer as part of the confirmation form:

<input type="hidden" name="name" value="Walter Sullivan">

Here's the code for the _CEx35aExtension::ConfirmOrder_ function:

void CEx35aExtension::ConfirmOrder(CHttpServerContext\* pCtxt, 
    LPCTSTR pstrName)
{
    StartContent(pCtxt);
    WriteTitle(pCtxt);
    \*pCtxt << "<p>Our courteous delivery person will arrive within 30 minutes. ";
    \*pCtxt << "<p>Thank you, " << pstrName << ", for using CyberPizza. ";
    // Now retrieve the order from disk by name, and then make the pizza.
    //  Be prepared to delete the order after a while if the customer 
    //  doesn't confirm.
    m_cs.Lock(); // gotta be threadsafe
    long int nTotal = ++m_nTotalPizzaOrders;
    m_cs.Unlock();
    \*pCtxt << "<p>Total pizza orders = " << nTotal;
    EndContent(pCtxt);
}

The customer's name comes back in the _pstrName_ parameter, and that's what you use to retrieve the original order from disk. The function also keeps track of the total number of orders, using a critical section (_m_cs_) to ensure thread synchronization.

Building and Testing ex35a.dll
------------------------------

If you have copied the code from the companion CD-ROM, your project is located in \vcpp32\ex35a. Building the project adds a DLL to the Debug subdirectory. You must copy this DLL to a directory that the server can find and copy PizzaForm.html also. You can use the scripts and wwwroot subdirec- tories already under \Winnt\System32\inetsrv, or you can set up new virtual directories.

> NOTE
> 
> If you make changes to the EX35A DLL in the Visual C++ project, be sure to use Internet Service Manager (Figure 35-1) to turn off the WWW service (because the old DLL stays loaded), copy the new DLL to the scripts directory, and then turn the WWW service on again. The revised DLL will be loaded as soon as the first client requests it.

If everything has been installed correctly, you should be able to load PizzaForm.html from the browser and then order some pizza. Enjoy!

Debugging the EX35A DLL
-----------------------

The fact that IIS is a Windows NT service complicates debugging ISAPI DLLs. Services normally run as part of the operating system, controlled by the service manager database. They have their own window station, and they run on their own invisible desktop. This involves some of the murkier parts of Windows NT, and not much published information is available.

However, you can use these steps to debug your EX35A DLL (or any ISAPI DLL):

1.  Use the Internet Service Manager to stop all IIS services.
    
2.  Choose Settings from the EX35A project Build menu, and in the Project Settings dialog, type in the data as shown.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g35og01x.gif)]
    
3.  Start User Manager or User Manager For Domains (Administrative Tools menu). Choose User Rights from the Policies menu, check Show Advanced User Rights, select the right Act As Part Of The Operating System, and add your user group as shown on the facing page.
    
4.  Repeat step 3 to set the right for Generate Security Audits.
    
5.  Log back on to Windows NT to activate the new permission. (Don't forget this step.)
    
6.  Make sure that the current EX35A DLL file has been copied into the scripts directory.
    
7.  Start debugging. You can set breakpoints, step through code, and see the output of _TRACE_ messages.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/g35og02.gif)
________________________________________________________________________
9.2.5. - [ISAPI Database Access](invcpp5/ch35f.htm)
----------------------------------------------------
 ISAPI Database Access 

ISAPI Database Access
=====================

Your ISAPI server extension could use ODBC to access an SQL database. Before you write pages of ODBC code, however, check out the Internet Database Connector described in the IIS documentation. The Internet Database Connector is a ready-to-run DLL, Httpodbc.dll, that collects SQL query parameters and formats the output. You control the process by writing an IDC file that describes the data source and an HTX file that is a template for the resulting HTML file. No C++ programming is necessary.

The Internet Database Connector is for queries only. If you want to update a database, you must write your own ISAPI server extension with ODBC calls. Make sure your ODBC driver is multithreaded, as is the latest SQL server driver.
________________________________________________________________________
9.2.6. - [Using HTTP Cookies to Link Transactions](invcpp5/ch35g.htm)
----------------------------------------------------
 Using HTTP Cookies to Link Transactions 

Using HTTP Cookies to Link Transactions
=======================================

Now that you've wolfed down the pizza, it's time for some dessert. However, the cookies that we'll be digesting in this section are not made with chocolate chips. Cookies are used to store information on our customers' hard disks. In the EX35A example, the server stores the customer name in a hidden field of the confirmation form. That works fine for linking the confirmation to the order, but it doesn't help you track how many pizzas Walter ordered this year. If you notice that Walter consistently orders pepperoni pizzas, you might want to send him some e-mail when you have a surplus of pepperoni.

How Cookies Work
----------------

With cookies, you assign Walter a customer ID number with his first order and make him keep track of that number on his computer. The server assigns the number by sending a response header such as this one:

Set-Cookie: customer_id=12345; path=/; expires=Monday, 
    02-Sep-99 00:00:00 GMT

The string _customer_id_ is the arbitrary cookie name you have assigned, the / value for _path_ means that the browser sends the cookie value for any request to your site (named CyberPizza.com), and the expiration date is necessary for the browser to store the cookie value.

When the browser sees the _Set-Cookie_ response header, it creates (or replaces) an entry in its cookies.txt file as follows:

customer_id
12345
cyberpizza.com/
0
2096697344
0
2093550622
35
\*

Thereafter, when the browser requests anything from CyberPizza.com, the browser sends a request header like this:

Cookie: customer_id=12345

How an ISAPI Server Extension Processes Cookies
-----------------------------------------------

Your ISAPI server extension function makes a call like this one to store the cookie at the browser:

AddHeader(pCtxt, "Set-Cookie: session_id=12345; path=/;"
     " expires=Monday, " 02-Sep-99 00:00:00 GMT\r\n");

To retrieve the cookie, another function uses code like this:

char strCookies[200];
DWORD dwLength = 200;
pCtxt->GetServerVariable("HTTP_COOKIE", strCookies, &dwLength);

The _strCookies_ variable should now contain the text _customer_id=12345_.

Problems with Cookies
---------------------

There was an uproar some time ago when Internet users first discovered that companies were storing data on the users' PCs. New browser versions now ask permission before storing a cookie from a Web site. Customers could thus refuse to accept your cookie, they could erase their cookies.txt file, or this file could become full. If you decide to use cookies at your Web site, you'll just have to deal with those possibilities.
________________________________________________________________________
9.2.7. - [WWW Authentication](invcpp5/ch35h.htm)
----------------------------------------------------
 WWW Authentication 

WWW Authentication
==================

Up to now, your IIS has been set to allow anonymous logons, which means that anyone in the world can access your server without supplying a user name or password. All users are logged on as IUSR_MYMACHINENAME and can access any files for which that user name has permissions.

> NOTE
> 
> As stated in [Chapter 34](ch34a.htm), you should be using NTFS on your server for maximum security.

Basic Authentication
--------------------

The simplest way to limit server access is to enable basic authentication. Then, if a client makes an anonymous request, the server sends back the response

HTTP/1.0 401 Unauthorized

together with a response header like this:

WWW-Authenticate: Basic realm="xxxx"

The client prompts the user for a user name and password, and then it resends the request with a request header something like this:

Authorization: Basic 2rc234ldfd8kdr

The string that follows Basic is a pseudoencrypted version of the user name and password, which the server decodes and uses to impersonate the client.

The trouble with basic authentication is that intruders can pick up the user name and password and use it to gain access to your server. IIS and most browsers support basic authentication, but it's not very effective.

Windows NT Challenge/Response Authentication
--------------------------------------------

Windows NT challenge/response authentication is often used for intranets running on Microsoft networks, but you can use it on the Internet as well. IIS supports it (see Figure 35-2), but not all browsers do.

If the server has challenge/response activated, a client making an ordinary request gets this response header:

WWW-Authenticate: NTLM
Authorization: NTLM T1RMTVNTUAABAAAAA5IAA ...

The string after _NTLM_ is the well-encoded user name—the password is never sent over the network. The server issues a challenge, with a response header like this:

WWW-Authenticate: NTLM RPTUFJTgAAAAAA ...

The client, which knows the password, does some math on the challenge code and the password and then sends back a response in a request header like this:

Authorization: NTLM AgACAAgAAAAAAAAAA ...

The server, which has looked up the client's password from the user name, runs the same math on the password and challenge code. It then compares the client's response code against its own result. If the client's and the server's results match, the server honors the client's request by impersonating the client's user name and sending the requested data.

When the client resends the request, the challenge/response dialog is performed over a single-socket connection with keep-alive capability as specified in the Connection request header.

WinInet fully supports Windows NT challenge/response authentication. Thus, Internet Explorer 4.0 and the EX34A WinInet clients support it. If the client computer is logged on to a Windows NT domain, the user name and password are passed through. If the client is on the Internet, WinInet prompts for the user name and password. If you're writing WinInet code, you must use the _INTERNET_FLAG_KEEP_CONNECTION_ flag in all _CHttpConnection::OpenRequest_ and _CInternetSession::OpenURL_ calls, as EX34A illustrates.

The Secure Sockets Layer
------------------------

Windows NT challenge/response authentication controls only who logs on to a server. Anyone snooping on the Net can read the contents of the TCP/IP segments. The secure sockets layer (SSL) goes one step further and encodes the actual requests and responses (with a performance hit, of course). Both IIS and WinInet support SSL. (The secure sockets layer is described in the IIS documentation.)
________________________________________________________________________
9.2.8. - [ISAPI Filters](invcpp5/ch35i.htm)
----------------------------------------------------
 ISAPI Filters 

ISAPI Filters
=============

An ISAPI server extension DLL is loaded the first time a client references it in a GET or POST request. An ISAPI filter DLL is loaded (based on a Registry entry) when the WWW service is started. The filter is then in the loop for all HTTP requests, so you can read and/or change any data that enters or leaves the server.

Writing an ISAPI Filter DLL
---------------------------

The ISAPI Extension Wizard makes writing filters as easy as writing server extensions. Choose Generate A Filter Object, and Step 2 looks like this.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g35og03x.gif)]

The list of options under Which Notifications Will Your Filter Process? refers to seven places where your filter can get control during the processing of an HTTP request. You check the boxes, and the wizard generates the code.

The MFC ISAPI Filter Classes
----------------------------

There are two MFC classes for ISAPI filters, _CHttpFilter_ and _CHttpFilterContext_.

### _CHttpFilter_

With the help of the ISAPI Extension Wizard, you derive a class from _CHttpFilter_ for each ISAPI filter you create. There's just one object of this class. The class has virtual functions for each of seven notifications. The list of filters in the order in which IIS calls them is below.

virtual DWORD OnReadRawData(CHttpFilterContext\* pCtxt,
                            PHTTP_FILTER_RAW_DATA pRawData);
virtual DWORD OnPreprocHeaders(CHttpFilterContext\* pCtxt,
                               PHTTP_FILTER_PREPROC_HEADERS pHeaderInfo);
virtual DWORD OnUrlMap(CHttpFilterContext\* pCtxt,

                       PHTTP_FILTER_URL_MAP pMapInfo);
virtual DWORD OnAuthentication(CHttpFilterContext\* pCtxt,
                               PHTTP_FILTER_AUTHENT pAuthent);
virtual DWORD OnSendRawData(CHttpFilterContext\* pCtxt,
                            PHTTP_FILTER_RAW_DATA pRawData);
virtual DWORD OnLog(CHttpFilterContext\* pfc, PHTTP_FILTER_LOG pLog);
virtual DWORD OnEndOfNetSession(CHttpFilterContext\* pCtxt);

If you override a function, you get control. It would be inefficient, however, if IIS made virtual function calls for every notification for each transaction. Another virtual function, _GetFilterVersion_, is called once when the filter is loaded. The ISAPI Extension Wizard always overrides this function for you, and it sets flags in the function's _pVer_ parameter, depending on which notifications you want. Here's a simplified sample with all the flags set:

BOOL CMyFilter::GetFilterVersion(PHTTP_FILTER_VERSION pVer)
{
    CHttpFilter::GetFilterVersion(pVer);
    pVer->dwFlags |= SF_NOTIFY_ORDER_LOW | SF_NOTIFY_NONSECURE_PORT | 
        SF_NOTIFY_LOG | SF_NOTIFY_AUTHENTICATION | 
        SF_NOTIFY_PREPROC_HEADERS | SF_NOTIFY_READ_RAW_DATA | 
        SF_NOTIFY_SEND_RAW_DATA | SF_NOTIFY_URL_MAP | 
        SF_NOTIFY_END_OF_NET_SESSION;
    return TRUE;
}

If you had specified URL mapping requests only, the wizard would have set only the _SF_NOTIFY_URL_MAP_ flag and it would have overridden only _OnUrlMap_. IIS would not call the other virtual functions, even if they were overridden in your derived class.

### _CHttpFilterContext_

An object of this second MFC class exists for each server transaction, and each of the notification functions gives you a pointer to that object. The _CHttpFilterContext_ member functions you might call are _GetServerVariable_, _AddResponseHeaders_, and _WriteClient_.
________________________________________________________________________
9.2.9. - [A Sample ISAPI Filter -- ex35b.dll, ex35c.exe](invcpp5/ch35j.htm)
----------------------------------------------------
 A Sample ISAPI Filter -- ex35b.dll, ex35c.exe 

A Sample ISAPI Filter—ex35b.dll, ex35c.exe
==========================================

It was hard to come up with a cute application for ISAPI filters. The one we thought up, ex35b.dll, is a useful visual logging utility. IIS, of course, logs all transactions to a file (or database), but you must stop the server before you can see the log file entries. With this example, you have a real-time transaction viewer that you can customize.

Choosing the Notification
-------------------------

Start by looking at the list of _CHttpFilter_ virtual member functions on page 1050. Observe the calling sequence and the parameters. For the EX35B logging application, we chose _OnReadRawData_ because it allowed full access to the incoming request and header text (from _pRawData_) and to the source and destination IP addresses (from _pCtxt->GetServerVariable_).

Sending Transaction Data to the Display Program
-----------------------------------------------

The ISAPI filter DLL can't display the transactions directly because it runs (as part of the IIS service process) on an invisible desktop. You need a separate program that displays text in a window, and you need a way to send data from the DLL to the display program. There are various ways to send the data across the process boundary. A conversation with Jeff Richter, the Windows guru who wrote _Advanced Windows_ (Microsoft Press, 1997), led to the data being put in shared memory. Then a user-defined message, WM_SENDTEXT, is posted to the display program. These messages can queue up, so IIS can keep going independently of the display program.

We declared two handle data members in _CEx35bFilter::m_hProcessDest_ and _CEx35bFilter::m_hWndDest_. We added code at the end of the _GetFilterVersion_ function to set these data members to the display program's process ID and main window handle. The code finds the display program's main window by its title, ex35b, and then it gets the display program's process ID.

m_hProcessDest = NULL;
if((m_hWndDest = ::FindWindow(NULL, "ex35b")) != NULL) {
    DWORD dwProcessId;
    GetWindowThreadProcessId(m_hWndDest, &dwProcessId);
    m_hProcessDest = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwProcessId);
    SendTextToWindow("EX35B filter started\r\n");
}

Below is a helper function, _SendTextToWindow_, which sends the WM_SENDTEXT message to the display program.

void CEx35bFilter::SendTextToWindow(char\* pchData)
{
    if(m_hProcessDest != NULL) {
        int nSize = strlen(pchData) + 1;

        HANDLE hMMFReceiver;
        HANDLE hMMF = ::CreateFileMapping((HANDLE) 0xFFFFFFFF, NULL,
            PAGE_READWRITE, 0, nSize, NULL);
        ASSERT(hMMF != NULL);
        LPVOID lpvFile = ::MapViewOfFile(hMMF, FILE_MAP_WRITE, 0, 0, nSize);
        ASSERT(lpvFile != NULL);
        memcpy((char\*) lpvFile, pchData, nSize);
        ::DuplicateHandle(::GetCurrentProcess(), hMMF, m_hProcessDest, 
            &hMMFReceiver, 0, FALSE, DUPLICATE_SAME_ACCESS | 
            DUPLICATE_CLOSE_SOURCE);
        ::PostMessage(m_hWndDest, WM_SENDTEXT, (WPARAM) 0, 
            (LPARAM) hMMFReceiver);
        ::UnmapViewOfFile(lpvFile);
    }
}

The _DuplicateHandle_ function makes a copy of EX35B's map handle, which it sends to the EX35C program in a message parameter. The EX35C process ID, determined in _GetFilterVersion_, is necessary for the _DuplicateHandle_ call. Here is the filter's _OnReadRawData_ function, which calls _SendTextToWindow_:

DWORD CEx35bFilter::OnReadRawData(CHttpFilterContext\* pCtxt,
    PHTTP_FILTER_RAW_DATA pRawData)
{
    TRACE ("CEx35bFilter::OnReadRawData\n");
    // sends time/date, from IP, to IP, request data to a window
    char pchVar[50] = "";
    char pchOut[2000];
    DWORD dwSize = 50;
    BOOL bRet;
    CString strGmt = CTime::GetCurrentTime().FormatGmt("%m/%d/%y %H:%M:%SGMT");
    strcpy(pchOut, strGmt);
    bRet = pCtxt->GetServerVariable("REMOTE_ADDR", pchVar, &dwSize);
    if(bRet && dwSize > 1) {
        strcat(pchOut, ", From ");
        strcat(pchOut, pchVar);
    }
    bRet = pCtxt->GetServerVariable("SERVER_NAME", pchVar, &dwSize);
    if(bRet && dwSize > 1) {
        strcat(pchOut, ", To ");
        strcat(pchOut, pchVar);
    }
     strcat(pchOut, "\r\n");
    int nLength = strlen(pchOut);
    // Raw data is not zero-terminated
    strncat(pchOut, (const char\*) pRawData->pvInData, pRawData->cbInData);
    nLength += pRawData->cbInData;
    pchOut[nLength] = \`\0';
    SendTextToWindow(pchOut);
    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

The Display Program
-------------------

The display program, ex35c.exe, isn't very interesting. It's a standard AppWizard _CRichEditView_ program with a WM_SENDTEXT handler in the main frame class:

LONG CMainFrame::OnSendText(UINT wParam, LONG lParam)
{
    TRACE("CMainFrame::OnSendText\n");
    LPVOID lpvFile = ::MapViewOfFile((HANDLE) lParam, FILE_MAP_READ, 0, 0,
        0);
    GetActiveView()->SendMessage(EM_SETSEL, (WPARAM) 999999, 1000000);
    GetActiveView()->SendMessage(EM_REPLACESEL, (WPARAM) 0, 
        (LPARAM) lpvFile);
    ::UnmapViewOfFile(lpvFile);
    ::CloseHandle((HANDLE) lParam);

    return 0;
}

This function just relays the text to the view.

The EX35C _CMainFrame_ class overrides _OnUpdateFrameTitle_ to eliminate the document name from the main window's title. This ensures that the DLL can find the EX35C window by name.

The view class maps the WM_RBUTTONDOWN message to implement a context menu for erasing the view text. Apparently rich edit view windows don't support the WM_CONTEXTMENU message.

Building and Testing the EX35B ISAPI Filter
-------------------------------------------

Build both the EX35B and EX35C projects, and then start the EX35C program. To specify loading of your new filter DLL, you must manually update the Registry. Run the Regedit application, and then double-click on _Filter DLLs_ in \HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W3SVC\Parameters. Add the full pathname of the DLL separated from other DLL names with a comma.

There's one more thing to do. You must change the IIS mode to allow the service to interact with the EX35C display program. To do this, click on the Services icon in the Control Panel, double-click on World Wide Web Publishing Service, and then check Allow Service To Interact With Desktop. Finally, use Internet Service Manager to stop and restart the WWW service to load the filter DLL. When you use the browser to retrieve pages from the server, you should see output like this.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g35og04x.gif)]

You can use the same steps for debugging an ISAPI filter that you used for an ISAPI server extension.
________________________________________________________________________
9.3. - [Chapter 36 -- ActiveX Document Servers and the Internet](invcpp5/ch36a.htm)
----------------------------------------------------
 Chapter 36 -- ActiveX Document Servers and the Internet  Chapter 36

ActiveX Document Servers and the Internet
=========================================

An ActiveX document is a special file that you can download from a Web server. When the browser sees an ActiveX document file, it automatically loads the corresponding ActiveX document server program from your hard disk, and that program takes over the whole browser window to display the contents of the document. The Microsoft Internet Explorer browser is not the only ActiveX document container program. The Microsoft Office Binder program also runs ActiveX document server programs, storing the several ActiveX documents in a single disk file.

> NOTE
> 
> In the COM world, an ActiveX document server program is called a server because it implements a COM component. The container program (Internet Explorer or Office Binder) creates and controls that COM component. In the Internet world, the same program looks like a client because it can request information from a remote host (Microsoft Internet Information Server).

In this chapter, you'll learn about ActiveX document servers and ActiveX documents and you'll build two ActiveX document servers that work over the Internet in conjunction with Internet Explorer. Pay attention to this technology now because you'll be seeing a lot more of it as Microsoft Windows evolves.
________________________________________________________________________
9.3.1. - [ActiveX Document Theory](invcpp5/ch36b.htm)
----------------------------------------------------
 ActiveX Document Theory 

ActiveX Document Theory
=======================

It's helpful to put ActiveX documents within the context of COM and OLE, which you already understand if you've read the other chapters in this book. You can, however, get started with ActiveX document servers without fully understanding all the COM concepts covered in Part VI.

ActiveX Document Servers vs. OLE Embedded Servers
-------------------------------------------------

As you saw in [Chapter 28](ch28a.htm), an OLE embedded server program runs in a child window of an OLE container application and occupies a rectangular area in a page of the container's document (see Figure 28-1). Unless an embedded server program is classified as a mini-server, it can run stand-alone also. In embedded mode, the server program's data is held in a storage inside the container application's file. The embedded server program takes over the container program's menu and toolbar when the user activates it by double-clicking on its rectangle.

In contrast to an embedded server, an ActiveX document server takes over a whole frame window in its container application, and the document is always active. An ActiveX server application, running inside a container's frame window, runs pretty much the same way it would in stand-alone mode. You can see this for yourself if you have Microsoft Office 97. Office includes an ActiveX container program called Binder (accessible from the Office shortcut bar), and the Office applications (Microsoft Word, Microsoft Excel, and so on) have ActiveX server capability. Figure 36-1 shows a Word document and an Excel chart inside the same binder.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f36og01x.gif)]

**Figure 36-1.** _A Word document and an Excel chart inside a Microsoft Office Binder window._

Like an embedded server, the ActiveX document server saves its data in a storage inside the ActiveX container's file. When the Office user saves the Binder program from the File menu, Binder writes a single OBD file to disk; the file contains one storage for the Word document and another for the Excel spreadsheet. You can see this file structure yourself with the DFVIEW utility, as shown in Figure 36-2.

![](c:/dl/books/windows/msvc5th/invcpp5/images/F36OG02.GIF)

**Figure 36-2.** _A file structure displayed by the DocFile Viewer._

Running an ActiveX Document Server from Internet Explorer
---------------------------------------------------------

Running an ActiveX document server from Internet Explorer is more fun than running one from Microsoft Office Binder (Internet Explorer refers to Internet Explorer 3.0 or greater). Rather than load a storage only from an OBD file, the server program can load its storage from the other side of the world. You just type in a URL, such as _http://www.DaliLama.in/SecretsOfTheUniverse.doc_, and a Microsoft Word document opens inside your Browse window, taking over the browser's menu and toolbar. That's assuming, of course, that you have installed the Microsoft Word program. If not, a Word document viewer is available, but it must be on your hard disk before you download the file.

An ActiveX document server won't let you save your changes back to the Internet host, but it will let you save them on your own hard disk. In other words, File Save is disabled but File Save As is enabled.

If you have Microsoft Office, try running Word or Excel in Internet Explorer now. The EX34A server is quite capable of delivering documents or worksheets to your browser, assuming that they are accessible from its home directory. Note that Internet Explorer recognizes documents and worksheets not by their file extensions but by the CLSID inside the files. You can prove this for yourself by renaming a file prior to accessing it.

ActiveX Document Servers vs. ActiveX Controls
---------------------------------------------

Both ActiveX document servers and ActiveX controls can run with and without the Internet. Both are compiled programs that can run inside a browser. The following table lists some of the differences between the two.

 

**ActiveX Document Server**

**ActiveX Control**

Module type

EXE

Most often a DLL

Can run stand-alone

Yes

No

Code automatically downloaded and registered by a WWW browser

No

Yes

Can be embedded in an HTML file

No

Yes

Occupies the entire browser window

Yes

Sometimes

Can be several pages

Yes

Not usually

Can read/write disk files

Yes

Not usually

OLE Interfaces for ActiveX Document Servers and Containers
----------------------------------------------------------

ActiveX document servers implement the same interfaces as OLE embedded servers, including _IOleObject_, _IOleInPlaceObject_, and _IOleInPlaceActiveObject_. ActiveX document containers implement _IOleClientSite_, _IOleInPlaceFrame_, and _IOleInPlaceSite_. The menu negotiation works the same as it does for Visual Editing.

Some additional interfaces are implemented, however. ActiveX document servers implement _IOleDocument_, _IOleDocumentView_, _IOleCommandTarget_, and _IPrint._ ActiveX document containers implement _IOleDocumentSite_. The architecture allows for multiple views of the same document—sort of like the MFC document-view architecture—but most ActiveX document servers implement only one view per document.

The critical function in an OLE embedded server is _IOleObject::DoVerb_, which is called by the container when the user double-clicks on an embedded object or activates it through the menu. For an ActiveX document server, however, the critical function is _IOleDocumentView::UIActivate_. (Before calling this function, the container calls _IOleDocument::CreateView_, but generally the server just returns an interface pointer to the single document-view object.) _UIActivate_ finds the container site and frame window, sets that window as the server's parent, sets the server's window to cover the container's frame window, and then activates the server's window.

> NOTE
> 
> It's important to realize that the COM interaction takes place between the container program (Internet Explorer or Binder) and the ActiveX document server (your program), which are both running on the client computer. We know of no cases in which remote procedure calls (RPCs) are made over the Internet. That means that the remote host (the server computer) does not use COM interfaces to communicate with clients, but it can deliver data in the form of storages.

MFC Support for ActiveX Document Servers
----------------------------------------

MFC allows you to create your own ActiveX document server programs. In addition, Visual C++ 6.0 now allows you to write ActiveX document containers. To get a server program, create a new MFC AppWizard EXE project and then check the Active Document Server check box, as shown in Figure 36-3. To create a container program, just make sure the Active Document Container check box is marked.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f36og03x.gif)]

**Figure 36-3.** _Step 3 of the MFC AppWizard._

Here's a rundown of the classes involved in MFC's ActiveX Document Server Architecture.

### _COleServerDoc_

As it is for any COM component, your ActiveX document server's document class is derived from _COleServerDoc_, which implements _IPersistStorage_, _IOleObject_, _IDataObject_, _IOleInPlaceObject_, and _IOleInPlaceActiveObject_.

> NOTE
> 
> The COM interfaces and MFC classes discussed here were named before Microsoft introduced ActiveX technology. An ActiveX document server was formerly known as a document object server or a doc object server, so those are the names you'll see in the source code and in some online documentation.

### _CDocObjectServerItem_

This class is derived from the _COleServerItem_ class used in embedded servers. Your ActiveX document server program has a class derived from _CDocObjectServerItem_, but that class isn't used when the program is running in ActiveX document mode.

### _CDocObjectServer_

This class implements the new ActiveX server interfaces. Your application creates an object of class _CDocObjectServer_ and attaches it to the _COleServerDoc_ object. If you look at _COleServerDoc::GetDocObjectServer_ in your derived document class, you'll see the construction code. Thereafter, the document object and attached _CDocObjectServer_ object work together to provide ActiveX document server functionality. This class implements both _IOleDocument_ and _IOleDocumentView_, which means that you can have only one view per document in an MFC ActiveX document server. You generally don't derive classes from _CDocObjectServer_.

### _COleDocIPFrameWnd_

This class is derived from _COleIPFrameWnd_. Your application has a frame window class derived from _COleDocIPFrameWnd_. The framework constructs an object of that class when the application starts in embedded server mode or in ActiveX document server mode. In ActiveX document server mode, the server's window completely covers the container's frame window and has its own menu resource attached, with the identifier _IDR_SRVR_INPLACE_ (for an SDI application).
________________________________________________________________________
9.3.2. - [ActiveX Document Server Example EX36A](invcpp5/ch36c.htm)
----------------------------------------------------
 ActiveX Document Server Example EX36A 

ActiveX Document Server Example EX36A
=====================================

You could construct the EX36A example in two phases. The first phase is a plain ActiveX document server that loads a file from its container. The view base class is _CRichEditView_, which means the program loads, edits, and stores text plus embedded objects. In the second phase, the application is enhanced to download a separate text file from the Internet one line at a time, demonstrating that ActiveX document servers can make arbitrary WinInet calls.

EX36A Phase 1—A Simple Server
-----------------------------

The EX36A example on the book's CD-ROM is complete with the text download feature from Phase 2. You can exercise its Phase 1 capabilities by building it, or you can create a new application with AppWizard. If you do use AppWizard, you should refer to Figure 36-3 to see the AppWizard EXE project dialog and select the appropriate options. All other options are the default options, except those for selecting SDI (Step 1), setting the project's filename extension to _36a_ using the Advanced button in Step 4, and changing the view's base class (_CRichEditView_—on the wizard's last page). You don't have to write any C++ code at all.

Be sure to run the program once in stand-alone mode to register it. While the program is running in stand-alone mode, type some text (and insert some OLE embedded objects) and then save the document as test.36a in your Internet server's home directory (\scripts or \wwwroot directory). Try loading test.36a from Internet Explorer and from Office Binder. Use Binder's Section menu for loading and storing EX36A documents to and from disk files.

You should customize the document icons for your ActiveX document servers because those icons show up on the right side of an Office Binder window.

Debugging an ActiveX Document Server
------------------------------------

If you want to debug your program in ActiveX document server mode, click on the Debug tab in the Build Settings dialog. Set Program Arguments to _/Embedding_, and then start the program. Now start the container program and use it to "start" the server, which has in fact already started in the debugger and is waiting for the container.

EX36A Phase 2—Adding WinInet Calls
----------------------------------

The EX36A example on the CD-ROM includes two dialog bar objects, one for the main frame window and another for the in-place frame window. Both are attached to the same resource template, _IDD_DIALOGBAR_, which contains an edit control that accepts a text file URL plus start and stop buttons that display green and red bitmaps. If you click the green button (handled by the _OnStart_ member function of the _CEx36aView_ class), you'll start a thread that reads the text file one line at a time. The thread code from the file UrlThread.cpp is shown here:

CString g_strURL = "http:// ";
volatile BOOL g_bThreadStarted = FALSE;
CEvent g_eKill;

UINT UrlThreadProc(LPVOID pParam)
{
    g_bThreadStarted = TRUE;
    CString strLine;
    CInternetSession session;
    CStdioFile\* pFile1 = NULL;

    try {
        pFile1 = session.OpenURL(g_strURL, 0, INTERNET_FLAG_TRANSFER_BINARY
            | INTERNET_FLAG_KEEP_CONNECTION); // needed for Windows NT  
                                              //  c/r authentication
        // Keep displaying text from the URL until the Kill event is 
        //  received
        while(::WaitForSingleObject(g_eKill.m_hObject, 0) != WAIT_OBJECT_0) {
            // one line at a time
            if(pFile1->ReadString(strLine) == FALSE) break;
            strLine += \`\n';
            ::SendMessage((HWND) pParam, EM_SETSEL, (WPARAM) 999999, 
                1000000);
            ::SendMessage((HWND) pParam, EM_REPLACESEL, (WPARAM) 0,
                          (LPARAM) (const char\*) strLine);
            Sleep(250); // Deliberately slow down the transfer
        }
    }
    catch(CInternetException\* e) {
        LogInternetException(pParam, e);
        e->Delete();
    }
    if(pFile1 != NULL) delete pFile1; // closes the file—prints a warning
    g_bThreadStarted = FALSE;
    // Post any message to update the toolbar buttons
    ::PostMessage((HWND) pParam, EM_SETSEL, (WPARAM) 999999, 1000000);
    TRACE("Post thread exiting normally\n");
    return 0;
}

This code uses the _CStdioFile_ pointer to _pFile1_ returned from _OpenURL_. The _ReadString_ member function reads one line at a time, and each line is sent to the rich edit view window. When the main thread sets the "kill" event (the red button), the URL thread exits.

Before you test EX36A, make sure that the server (EX34A or IIS) is running and that you have a text file in the server's home directory. Test the EX36A program first in stand-alone mode by entering the text file URL in the dialog bar. Next try running the program in server mode from Internet Explorer. Enter _test.36a_ (the document you created when you ran EX36A in stand-alone mode) in Internet Explorer's Address field to load the server.

> NOTE
> 
> We considered using the _CAsyncMonikerFile_ class (see [Asynchronous Moniker Files](ch34j.htm)) instead of the MFC _WinInet_ classes to read the text file. We stuck with WinInet, however, because the program could use the _CStdioFile_ class _ReadString_ member function to "pull" individual text lines from the server when it wanted them. The _CAsyncMonikerFile_ class would have "pushed" arbitrary blocks of characters into the program (by calling the overridden _OnDataAvailable_ function) as soon as the characters had been received.

> **Displaying Bitmaps on Buttons**
> 
> [Chapter 11](ch11a.htm) describes the _CBitmapButton_ class for associating a group of bitmaps with a pushbutton. Microsoft Windows 95, Microsoft Windows 98, and Microsoft Windows NT 4.0 support an alternative technique that associates a single bitmap with a button. First you apply the Bitmap style (on the button's property sheet) to the button, and then you declare a variable of class _CBitmap_ that will last at least as long as the button is enabled. Then you make sure that the _CButton::SetBitmap_ function is called just after the button is created.
> 
> Here is the code for associating a bitmap with a button, from the EX36A MainFrm.cpp and IpFrame.cpp files:
> 
> m_bitmapGreen.LoadBitmap(IDB_GREEN);
> HBITMAP hBitmap = (HBITMAP) m_bitmapGreen.GetSafeHandle();
> ((CButton\*) m_wndDialogBar.GetDlgItem(IDC_START))
> ->SetBitmap(hBitmap);
> 
> If your button was in a dialog, you could put similar code in the _OnInitDialog_ member function and declare a _CBitmap_ member in the class derived from _CDialog_.
________________________________________________________________________
9.3.3. - [ActiveX Document Server Example EX36B](invcpp5/ch36d.htm)
----------------------------------------------------
 ActiveX Document Server Example EX36B 

ActiveX Document Server Example EX36B
=====================================

Look at the pizza form example from [Chapter 35](ch35a.htm) (EX35A). Note that the server (the ISAPI DLL) processes the order only when the customer clicks the Submit Order Now button. This is okay for ordering pizzas because you're probably happy to accept money from anyone, no matter what kind of browser is used.

For a form-based intranet application, however, you can be more selective. You can dictate what browser your clients have, and you can distribute your own client software on the net. In that environment, you can make data entry more sophisticated, allowing, for example, the client computer to validate each entry as the user types it. That's exactly what's happening in EX36B, which is another ActiveX document server, of course. EX36B is a form-based employee time-sheet entry program that works inside Internet Explorer (as shown in Figure 36-4) or works as a stand-alone application. Looks like a regular HTML form, doesn't it? It's actually an MFC form view, but the average user probably won't know the difference. The Name field is a drop-down combo box, however—which is different from the select field you would see in an HTML form—because the user can type in a value if necessary. The Job Number field has a spin button control that helps the user select the value. These aren't necessarily the ideal controls for time-sheet entry, but the point here is that you can use any Windows controls you want, including tree controls, list controls, trackbars, and ActiveX controls, and you can make them interact any way you want.

![](c:/dl/books/windows/msvc5th/invcpp5/images/f36og04.gif)

**Figure 36-4.** _Employee time-sheet entry form._

> **Field Validation in an MFC Form View**
> 
> Problem: MFC's standard validation scheme validates data only when _CWnd::UpdateData(TRUE)_ is called, usually when the user exits the dialog. Applications often need to validate data the moment the user leaves a field (edit control, list box, and so on). The problem is complex because Windows permits the user to freely jump between fields in any sequence by using the mouse. Ideally, standard MFC DDX- /DDV (data exchange/validation) code should be used for field validation, and the standard _DoDataExchange_ function should be called when the user finishes the transaction.
> 
> Solution: Derive your field validation form view classes from the class _CValidForm_, derived from _CFormView_, with this header:
> 
> // valform.h
> #ifndef _VALIDFORM
> #define _VALIDFORM
> 
> #define WM_VALIDATE WM_USER + 5
> 
> class CValidForm : public CFormView
> {
> DECLARE_DYNAMIC(CValidForm)
> private:
>     BOOL m_bValidationOn;
> public:
>     CValidForm(UINT ID);
>     // override in derived dlg to perform validation
>     virtual void ValidateDlgItem(CDataExchange\* pDX, UINT ID);
>     //{{AFX_VIRTUAL(CValidForm)
>     protected:
>     virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
>     //}}AFX_VIRTUAL
> 
>     //{{AFX_MSG(CValidForm)
>     afx_msg LONG OnValidate(UINT wParam, LONG lParam);
>     //}}AFX_MSG
>     DECLARE_MESSAGE_MAP()
> };
> #endif // _VALIDFORM
> 
> This class has one virtual function, _ValidateDlgItem_, which accepts the control ID as the second parameter. The derived form view class implements this function to call the DDX/DDV functions for the appropriate field. Here is a sample _ValidateDlgItem_ implementation for a form view that has two numeric edit controls:
> 
> void CMyForm::ValidateDlgItem(CDataExchange\* pDX, UINT uID)
> {
>     switch (uID) {
>     case IDC_EDIT1:
>         DDX_Text(pDX, IDC_EDIT1, m_nEdit1);
>         DDV_MinMaxInt(pDX, m_nEdit1, 0, 10);
>         break;
>     case IDC_EDIT2:
>         DDX_Text(pDX, IDC_EDIT2, m_nEdit2);
>         DDV_MinMaxInt(pDX, m_nEdit2, 20, 30);
>         break;
>     default:
>         break;
>     }
> }
> 
> Notice the similarity to the wizard-generated _DoDataExchange_ function:
> 
> void CAboutDlg::DoDataExchange(CDataExchange\* pDX)
> {
>     //{{AFX_DATA_MAP(CMyForm)
>     DDX_Text(pDX, IDC_EDIT1, m_nEdit1);
>     DDV_MinMaxInt(pDX, m_nEdit1, 0, 10);
>     DDX_Text(pDX, IDC_EDIT2, m_nEdit2);
>     DDV_MinMaxInt(pDX, m_nEdit2, 20, 30);
>     //}}AFX_DATA_MAP
> }
> 
> How does it work? The _CValidForm_ class traps the user's attempt to move away from a control. When the user presses the Tab key or clicks on another control, the original control sends a killfocus command message (a control notification message) to the parent window, the exact format depending on the kind of control. An edit control, for example, sends an EN_KILLFOCUS command. When the form window receives this killfocus message, it invokes the DDX/DDV code that is necessary for that field, and if there's an error, the focus is set back to that field.
> 
> There are some complications, however. First, we want to allow the user to freely switch the focus to another application—we're not interested in trapping the killfocus message in that case. Next, we must be careful how we set the focus back to the control that produced the error. We can't just call _SetFocus_ in direct response to the killfocus message; instead we must allow the killfocus process to complete. We can achieve this by posting a user-defined WM_VALIDATE message back to the form window. The WM_VALIDATE handler calls our _ValidateDlgItem_ virtual function after the focus has been moved to the next field. Also, we must ignore the killfocus message that results when we switch back from the control that the user tried to select, and we must allow the IDCANCEL button to abort the transaction without validation.
> 
> Most of the work here is done in the view's virtual _OnCommand_ handler, which is called for all control notification messages. We could, of course, individually map each control's killfocus message in our derived form view class, but that would be too much work. Here is the _OnCommand_ handler:
> 
> BOOL CValidForm::OnCommand(WPARAM wParam, LPARAM lParam) 
> {
>     // specific for WIN32 — wParam/lParam processing different for 
>     //  WIN16
>     TRACE("CValidForm::OnCommand, wParam = %x, lParam = %x\n", 
>         wParam, lParam);
>     TRACE("m_bValidationOn = %d\n", m_bValidationOn);
>     if(m_bValidationOn) {   // might be a killfocus
>         UINT notificationCode = (UINT) HIWORD( wParam );
>         if((notificationCode == EN_KILLFOCUS)  ||
>            (notificationCode == LBN_KILLFOCUS) ||
>            (notificationCode == CBN_KILLFOCUS) ) {
>             CWnd\* pFocus = CWnd::GetFocus(); // static function call
>             // if we're changing focus to another control in the 
>             //  same form
>             if( pFocus && (pFocus->GetParent() == this) ) {
>                 if(pFocus->GetDlgCtrlID() != IDCANCEL) {
>                     // and focus not in Cancel button
>                     // validate AFTER drawing finished
>                     BOOL rtn = PostMessage( WM_VALIDATE, wParam );
>                     TRACE("posted message, rtn = %d\n", rtn);
>                 }
>             }
>         }
>     }
>     return CFormView::OnCommand(wParam, lParam); // pass it on
> }
> 
> Note that _m_bValidationOn_ is a Boolean data member in _CValidForm_.
> 
> Finally, here is the _OnValidate_ message handler, mapped to the user-defined WM_VALIDATE message:
> 
> LONG CValidForm::OnValidate(UINT wParam, LONG lParam)
> {
>     TRACE("Entering CValidForm::OnValidate\n");
>     CDataExchange dx(this, TRUE);
>     m_bValidationOn = FALSE;   // temporarily off
>     UINT controlID = (UINT) LOWORD( wParam );
>     try {
>         ValidateDlgItem(&dx, controlID);
>     }
>     catch(CUserException\* pUE) {
>         pUE->Delete();
>         TRACE("CValidForm caught the exception\n");
>         // fall through — user already alerted via message box
>     }
>     m_bValidationOn = TRUE;
>     return 0;     // goes no further
> }
> 
> Instructions for use:
> 
> 1.  Add valform.h and valform.cpp to your project.
>     
> 2.  Insert the following statement in your view class header file:
>     
>     **#include "valform.h"**
>     
> 3.  Change your view class base class from _CFormView_ to _CValidForm_.
>     
> 4.  Override _ValidateDlgItem_ for your form's controls as shown above.
>     
> 
> That's all.
> 
> For dialogs, follow the same steps, but use valid.h and valid.cpp. Derive your dialog class from _CValidDialog_ instead of from _CDialog_.

Generating POST Requests Under Program Control
----------------------------------------------

The heart of the EX36B program is a worker thread that generates a POST request and sends it to a remote server. The server doesn't care whether the POST request came from an HTML form or from your program. It could process the POST request with an ISAPI DLL, with a PERL script, or with a Common Gateway Interface (CGI) executable program.

Here's what the server receives when the user clicks the EX36B Submit button:

POST scripts/ex35a.dll?ProcessTimesheet HTTP/1.0
_(request headers)
(blank line)_
Period=12&Name=Dunkel&Hours=6.5&Job=5
And here's the thread code from PostThread.cpp:
// PostThread.cpp (uses MFC WinInet calls)

#include <stdafx.h>
#include "PostThread.h"

#define MAXBUF 50000

CString g_strFile = "/scripts/ex35a.dll";
CString g_strServerName = "localhost";
CString g_strParameters;

UINT PostThreadProc(LPVOID pParam)
{
    CInternetSession session;
    CHttpConnection\* pConnection = NULL;
    CHttpFile\* pFile1 = NULL;
    char\* buffer = new char[MAXBUF];
    UINT nBytesRead = 0;
    DWORD dwStatusCode;
    BOOL bOkStatus = FALSE;
    try {
        pConnection = session.GetHttpConnection(g_strServerName, 
            (INTERNET_PORT) 80);
        pFile1 = pConnection->OpenRequest(0, g_strFile + 
            "?ProcessTimesheet", // POST request
            NULL, 1, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION | 
            INTERNET_FLAG_RELOAD); // no cache
        pFile1->SendRequest(NULL, 0,
            (LPVOID) (const char\*) g_strParameters,
            g_strParameters.GetLength());
        pFile1->QueryInfoStatusCode(dwStatusCode);
        if(dwStatusCode == 200) { // OK status
            // doesn't matter what came back from server — we're looking 
            //  for OK status
            bOkStatus = TRUE;
            nBytesRead = pFile1->Read(buffer, MAXBUF - 1);
            buffer[nBytesRead] = \`\0'; // necessary for TRACE
            TRACE(buffer);
            TRACE("\n");
        }
    }
    catch(CInternetException\* pe) {
        char text[100];
        pe->GetErrorMessage(text, 99);
        TRACE("WinInet exception %s\n", text);
        pe->Delete();
    }
    if(pFile1) delete pFile1; // does the close — prints a warning
    if(pConnection) delete pConnection; // Why does it print a warning?
    delete [] buffer;
    ::PostMessage((HWND) pParam, WM_POSTCOMPLETE, (WPARAM) bOkStatus, 0);
    return 0;
}

The main thread assembles the _g_strParameters_ string based on what the user typed, and the worker thread sends the POST request using the _CHttpFile::SendRequest_ call. The t_QueryInfoStatusCode_ to find out if the server sent back an OK response. Before exiting, the thread posts a message to the main thread, using the _bOkStatus_ value in _wParam_ to indicate success or failure.

The EX36B View Class
--------------------

The _CEx36bView_ class is derived from _CValidForm_, as described in "[Field Validation in an MFC Form View](ch36d.htm#1050)". _CEx36bView_ collects user data and starts the post thread when the user clicks the Submit button after all fields have been successfully validated. Field validation is independent of the internet application. You could use _CValidForm_ in any MFC form view application.

Here is the code for the overridden or the overridden _ValidateDlgItem_ member function, which is called whenever the user moves from one control to another:

void CEx36bView::ValidateDlgItem(CDataExchange\* pDX, UINT uID)
{
    ASSERT(this);
    TRACE("CEx36bView::ValidateDlgItem\n");
     switch (uID) {
    case IDC_EMPLOYEE:
        DDX_CBString(pDX, IDC_EMPLOYEE, m_strEmployee);
        // need custom DDV for empty string
        DDV_MaxChars(pDX, m_strEmployee, 10);
        if(m_strEmployee.IsEmpty()) {
            AfxMessageBox("Must supply an employee name");
            pDX->Fail();
        }
        break;
    case IDC_HOURS:
        DDX_Text(pDX, IDC_HOURS, m_dHours);
        DDV_MinMaxDouble(pDX, m_dHours, 0.1, 100.);
        break;
    case IDC_JOB:
        DDX_Text(pDX, IDC_JOB, m_nJob);
        DDV_MinMaxInt(pDX, m_nJob, 1, 20);
        break;
    default:
        break;
    }
    return;
}

The _OnSubmit_ member function is called when the user clicks the Submit button. _CWnd::UpdateData_ returns _TRUE_ only when all the fields have been successfully validated. At that point, the function disables the Submit button, formats _g_strParameters_, and starts the post thread.

void CEx36bView::OnSubmit() 
{
    if(UpdateData(TRUE) == TRUE) {
        GetDlgItem(IDC_SUBMIT)->EnableWindow(FALSE);
        CString strHours, strJob, strPeriod;
        strPeriod.Format("%d", m_nPeriod);
        strHours.Format("%3.2f", m_dHours);
        strJob.Format("%d", m_nJob);
        g_strParameters = "Period=" + strPeriod + "&Employee=" + 
            m_strEmployee + "&Hours=" +strHours + "&Job=" + 
            strJob + "\r\n";
        TRACE("parameter string = %s", g_strParameters);
        AfxBeginThread(PostThreadProc, GetSafeHwnd(), 
            THREAD_PRIORITY_NORMAL);
    }
}

The _OnCancel_ member function is called when the user clicks the Reset button. The _CValidForm_ logic requires that the button's control ID be _IDCANCEL_.

void CEx36bView::OnCancel() 
{
    CEx36bDoc\* pDoc = GetDocument();
    m_dHours = 0;
    m_strEmployee = "" ;
    m_nJob = 0;
    m_nPeriod = pDoc->m_nPeriod;
    UpdateData(FALSE);
}

The _OnPostComplete_ handler is called in response to the user-defined WM_POSTCOMPLETE message sent by the post thread:

LONG CEx36bView::OnPostComplete(UINT wParam, LONG lParam)
{
    TRACE("CEx36bView::OnPostComplete - %d\n", wParam);
    if(wParam == 0) {
        AfxMessageBox("Server did not accept the transaction");
    }
    else 
        OnCancel();
    GetDlgItem(IDC_SUBMIT)->EnableWindow(TRUE);
    return 0;
}

This function displays a message box if the server didn't send an OK response. It then enables the Submit button, allowing the user to post another time-sheet entry.

Building and Testing EX36B
--------------------------

Build the /vcpp36/ex36b project, and then run it once in stand-alone mode to register it and to write a document file called test.36b in your WWW root directory. Make sure the EX35A DLL is available in the scripts directory (with execute permission) because that DLL contains an ISAPI function, _ProcessTimesheet_, which handles the server end of the POST request. Be sure that you have IIS or some other ISAPI-capable server running.

Now run Internet Explorer and load test.36b from your server. The EX36B program should be running in the Browse window, and you should be able to enter time-sheet transactions.

ActiveX Document Servers vs. VB Script
--------------------------------------

It's possible to insert VB Script (or JavaScript) code into an HTML file. We're not experts on VB Script, but we've seen some sample code. You could probably duplicate the EX36B time-sheet application with VB Script, but you would be limited to the standard HTML input elements. It would be interesting to see how a VB Script programmer would solve the problem. (In any case, you're a C++ programmer, not a Visual Basic programmer, so you might as well stick to what you know.)
________________________________________________________________________
9.3.4. - [Going Further with ActiveX Document Servers](invcpp5/ch36e.htm)
----------------------------------------------------
 Going Further with ActiveX Document Servers 

Going Further with ActiveX Document Servers
===========================================

EX36A used a worker thread to read a text file from an Internet server. It used the MFC WinInet classes, and it assumed that a standard HTTP server was available. An ActiveX document server could just as easily make Winsock calls using the _CBlockingSocket_ class from [Chapter 34](ch34a.htm). That would imply that you were going beyond the HTTP and FTP protocols. You could, for example, write a custom internet server program that listened on port 81. (That server could run concurrently with IIS if necessary.) Your ActiveX document server could use a custom TCP/IP protocol to get binary data from an open socket. The server could use this data to update its window in real-time, or it could send the data to another device, such as a sound board.
________________________________________________________________________
9.4. - [Chapter 37 -- Introducing Dynamic HTML](invcpp5/ch37a.htm)
----------------------------------------------------
 Chapter 37 -- Introducing Dynamic HTML  Chapter 37

Introducing Dynamic HTML
========================

Dynamic HyperText Markup Language (DHTML) is a new and exciting technology—introduced as part of Microsoft Internet Explorer 4.0 (IE4)—that provides serious benefits to Webmasters and developers. DHTML could ultimately change the way we think about developing Windows applications. Why the buzz about DHTML?

It began with the IE4 "HTML display engine"—sometimes called Trident in Microsoft literature. As part of the design of Internet Explorer 4, Microsoft made Trident a COM component that exposes many of its internal objects that are used for displaying HTML pages in Internet Explorer 4. This feature allows you to traverse the portions of an HTML page in script or code, as if the HTML page were a data structure. Gone are the days of having to parse HTML or write grotesque Common Gateway Interface (CGI) scripts to get to data in a form. The real power of DHTML, however, is not this ability to access the HTML objects but the ability to actually change and manipulate the HTML page on the fly—thus the name Dynamic HTML.

Once you grasp the concept of DHTML, a million possible applications come to mind. For Webmasters, DHTML means that much of the logic that manipulates a Web page can live in scripts that are downloaded to the client. C++ developers can embed DHTML in their applications and use it as an embedded Web client or as a super-flexible, dynamic "form" that their application changes on the fly. Microsoft Visual J++ developers (who use Windows Foundation Classes [WFC]) can actually program DHTML on the server while an Internet Explorer client responds to the commands—an excellent alternative to CGI and potentially more powerful than Active Server Pages (ASP) server-side scripting.

Unfortunately, DHTML is so powerful and extensive that it requires a separate book to fill you in on all of the copious details. For example, to really leverage DHTML you need to understand all of the possible elements of an HTML page: forms, lists, style sheets, and so on. _Inside Dynamic HTML_ by Scott Isaacs (Microsoft Press, 1997) is a great resource for learning the details of DHTML.

Instead of covering all aspects of DHTML, we will briefly introduce you to the DHTML object model, show you how to work with the model from the scripting angle (as a reference), and then show you how to work with the model from both the Microsoft Foundation Class Library version 4.21 (MFC) and the Active Template Library (ATL). These features are all made possible by the excellent DHTML support introduced in Visual C++ 6.0.
________________________________________________________________________
9.4.1. - [The DHTML Object Model](invcpp5/ch37b.htm)
----------------------------------------------------
 The DHTML Object Model 

The DHTML Object Model
======================

If you've been heads down on a Visual C++ project and haven't yet had time to take a peek at HTML, the first thing you should know is that HTML is an ASCII markup language format. Here is the code for a very basic HTML page:

<html>
<head>
<title>
This is an example very basic HTML page!
</title>
</head>
<body>
<h1>This is some text with H1!
</h1>
<h3>
This is some text with H3!
</h3>
</body>
</html>

This basic HTML "document" is composed of the following elements:

*   **A head (or header)** In this example, the header contains a title: "This is an example very basic HTML page!"
    
*   **The body of the document** The body in this example contains two text elements. The first has the heading 1 (h1) style and reads, "This is some text with H1!" The second text element has the heading 3 (h3) style and reads, "This is some text with H3!"

The end result is an HTML page that—when displayed in Internet Explorer 4—looks like Figure 37-1.

When Internet Explorer 4 loads this sample HTML page, it creates an internal representation that you can traverse, read, and manipulate through the DHTML object model. Figure 37-2 shows the basic hierarchy of the DHTML object model.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f37og01x.gif)]

**Figure 37-1.** _A very basic HTML page, as seen in Internet Explorer 4._

At the root of the object model is the _window_ object. This object can be used from a script to perform some action, such as popping up a dialog box. Here's an example of some JScript that accesses the window object:

<SCRIPT LANGUAGE="JScript">
function about()
{
    window.showModalDialog("about.htm","",
        "dialogWidth:25em;dialogHeight13em")
}
</SCRIPT>

When the _about_ script function is called, it will call the _showModalDialog_ function in the _window_ DHTML object to display a dialog. This example also illustrates how scripts access the object model—through globally accessible objects that map directly to the corresponding object in the DTHML object model.

The window object has several "subobjects" that allow you to further manipulate portions of Internet Explorer 4. The _document_ object is what we will spend most of our time on in this chapter because it gives us programmatic access to the various elements of the currently loaded HTML document. Below, some JScript shows how to create basic dynamic content that changes the document object.

![](c:/dl/books/windows/msvc5th/invcpp5/images/f37og02.gif)

**Figure 37-2.** _Basic hierarchy of the DHTML object model._

<HTML> 
<HEAD>
<TITLE>Welcome!</TITLE>
<SCRIPT LANGUAGE="JScript">
function changeMe() { 
    document.all.MyHeading.outerHTML = 
        "<H1 ID=MyHeading>Dynamic HTML is magic!</H1>";
    document.all.MyHeading.style.color = "green"; 
    document.all.MyText.innerText = "Presto Change-o! "; 
    document.all.MyText.align = "center";
    document.body.insertAdjacentHTML("BeforeEnd", 
        "<P ALIGN=\"center\">Open Sesame!</P>");
} 
</SCRIPT>
<BODY onclick="changeMe()">
<H3 ID=MyHeading> Dynamic HTML demo!</H3>
<P ID=MyText>Click anywhere to see the power of DHTML!</P>
</BODY>
</HTML>

This script changes the _MyHeading_ and _MyText_ objects in the HTML documents on the fly. Not only does it change the text, it also changes attributes of the elements such as color and alignment. If you want to see this script in action, you can find it in the ex37_1.html file on the companion CD.

Before we further deconstruct the DHTML object model, let's examine the DHTML concept of a collection. Collections in DHTML are logically equivalent to C++ data structures such as linked lists. In fact, access to the DHTML object model is performed largely by iterating through collections searching for a particular HTML element and then potentially iterating through another subcollection to get to yet another element. Elements contain several methods, such as _contains_ and _length_, that you use to traverse the elements.

For example, one of the subelements of the _document_ object is a collection named _all_ that contains all of the document's elements. In fact, most of the subobjects of the _document_ object are collections. The following script (ex37_2.html) shows how to iterate through the _all_ collection and list the various items of a document.

<HTML>
<HEAD><TITLE>Iterating through the all collection.</TITLE>
<SCRIPT LANGUAGE="JScript">
function listAllElements() {
    var tag_names = "";
    for (i=0; i<document.all.length; i++)
        tag_names = tag_names + document.all(i).tagName + " ";
    alert("This document contains: " + tag_names);
}
</SCRIPT>
</HEAD>
<BODY onload="listAllElements()">
<H1>DHTML Rocks!</H1>
<P>This document is <B>very</B> short.
</BODY>
</HTML>

Notice how easy it is to retrieve items with script. (The syntax calls for parentheses, similar to accessing an array in C++.) Also notice that each element in an HTML document has properties such as tagName that allow you to programmatically "search" for various elements. For example, if you wanted to write a script that filtered out all bold items, you would scan the _all_ collection for an element with tagName equal to _B_.

Now you have the basics of the DHTML object model down and you understand how to access them through scripts from the Webmaster's perspective. Let's look at how Visual C++ lets us work with DHTML from an application developer's perspective.
________________________________________________________________________
9.4.2. - [Visual C++ and DHTML](invcpp5/ch37c.htm)
----------------------------------------------------
 Visual C++ and DHTML 

Visual C++ and DHTML
====================

Visual C++ 6.0 supports DHTML through both MFC and ATL. Both MFC and ATL give you complete access to the DHTML object model. Unfortunately, access to the object model from languages like C++ is done through OLE Automation (_IDispatch_) and in many cases isn't as cut-and-dried as some of the scripts we looked at earlier.

The DHTML object model is exposed to C++ developers through a set of COM objects with the prefix IHTML (_IHTMLDocument, IHTMLWindow, IHTMLElement, IHTMLBodyElement_, and so on). In C++, once you obtain the document interface, you can use any of the _IHTMLDocument2_ interface methods to obtain or to modify the document's properties.

You can access the _all_ collection by calling the _IHTMLDocument2::get_all_ method. This method returns an _IHTMLElementCollection_ collection interface that contains all the elements in the document. You can then iterate through the collection using the _IHTMLElementCollection::item_ method (similar to the parentheses in the script above). The _IHTMLElementCollection::item_ method supplies you with an _IDispatch_ pointer that you can call _QueryInterface_ on, requesting the _IID_IHTMLElement_ interface. This call to _QueryInterface_ will give you an _IHTMLElement_ interface pointer that you can use to get or set information for the HTML element.

Most elements also provide a specific interface for working with that particular element type. These element-specific interface names take the format of _IHTMLXXXXElement_, where XXXX is the name of the element (_IHTMLBodyElement,_ for example). You must call _QueryInterface_ on the _IHTMLElement_ object to request the element-specific interface you need. This might sound confusing (because it can be!). But don't worry—the MFC and ATL sections in this chapter contain plenty of samples that demonstrate how it all ties together. You'll be writing DHTML code in no time.

MFC and DHTML
-------------

MFC's support for DHTML starts with a new _CView_ derivative, _CHtmlView._ _CHtmlView_ allows you to embed an HTML view inside frame windows or splitter windows, where with some DHTML work it can act as a dynamic form. Example EX37A demonstrates how to use the new _CHtmlView_ class in a vanilla MDI application.

Follow these steps to create the EX37A example:

2.  **Run AppWizard and create \vcpp32\ex37a\ex37a**. Choose New from Visual C++'s File menu. Then click the Projects tab, and select MFC AppWizard (exe). Accept all defaults, except in Step 6 choose CHtmlView as the Base Class, as shown here.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/g37og01x.gif)]
    
3.  **Edit the URL to be loaded.** In the _CEx37aView::OnInitialUpdate_ function, you will see this line:
    
    Navigate2(_T("http://www.microsoft.com/visualc/"),NULL,NULL);
    
    You can edit this line to have the application load a local page or a URL other than the Visual C++ page.
    
4.  **Compile and run.** Figure 37-3 shows the application running with the default Web page.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f37og03x.gif)]
    
    **Figure 37-3.** _The EX37A example._
    
    Now let's create a sample that really shows how to use DHTML with MFC. EX37B creates a _CHtmlView_ object and a _CListView_ object separated by a splitter. The example then uses DHTML to enumerate the HTML elements in the _CHtmlView_ object and displays the results in the _CListView_ object. The end result will be a DHTML explorer that you can use to view the DHTML object model of any HTML file.
    
    Here are the steps to create EX37B:
    
5.  **Run AppWizard and create \vcpp32\ex37b\ex37b.** Choose New from Visual C++'s File menu. Then click the Projects tab, and select MFC AppWizard (exe). Accept all the defaults but three: select Single Document, select Windows Explorer in Step 5, and select _CHtmlView_ as the Base Class in Step 6. The options that you should see after finishing the wizard are shown in the graphic below.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/g37og02x.gif)
    
6.  **Change the _CLeftView_ to be a _CListView_ derivative.** By default, AppWizard makes the _CLeftView_ of the splitter window a _CTreeView_ derivative. Open the LeftView.h file, and do a global search for _CTreeView_ and replace it with _CListView_. Open LeftView.cpp and do the same find and replace (Hint: Use Edit/Replace/Replace All.)
    
7.  **Edit the URL to be loaded.** In the _CEx37bView::OnInitialUpdate_ function, change the URL to res://ie4tour.dll/welcome.htm.
    
8.  **Add a _DoDHTMLExplore_ function to _CMainFrame_.** First add the fol-lowing declaration to the MainFrm.h file:
    
        virtual void DoDHTMLExplore(void);
    
    Now add the implementation for _DoHTMLExplore_ to MainFrm.cpp.
    
    void CMainFrame::DoDHTMLExplore(void)
    {
    
        CLeftView \*pListView = 
            (CLeftView \*)m_wndSplitter.GetPane(0,0);
    
        CEx37bView \* pDHTMLView = 
            (CEx37bView \*)m_wndSplitter.GetPane(0,1);
    
        //Clear the listview 
        pListView->GetListCtrl().DeleteAllItems();
        IDispatch\* pDisp = pDHTMLView->GetHtmlDocument();
        
        if (pDisp != NULL )
        {
            IHTMLDocument2\* pHTMLDocument2;
            HRESULT hr;
    
            hr = pDisp->QueryInterface( IID_IHTMLDocument2,
                        (void\*\*)&pHTMLDocument2 );
            if (hr == S_OK)
            {
                IHTMLElementCollection\* pColl = NULL;
    
                hr = pHTMLDocument2->get_all( &pColl );
                if (hr == S_OK && pColl != NULL)
                {
                    LONG celem;
                    hr = pColl->get_length( &celem );
    
                    if ( hr == S_OK )
                    {
                        for ( int i=0; i< celem; i++ )
                        {
                            VARIANT varIndex;
                            varIndex.vt = VT_UINT;
                            varIndex.lVal = i;
                            VARIANT var2;
                            VariantInit( &var2 );
                            IDispatch\* pDisp; 
    
                            hr = pColl->item( varIndex, var2, &pDisp );
                            if ( hr == S_OK )
                            {
                                IHTMLElement\* pElem;
    
                                hr = pDisp->QueryInterface(
                                    IID_IHTMLElement,
                                    (void \*\*)&pElem);
                                if ( hr == S_OK )
                                {
                                    BSTR bstr;
                                    hr = pElem->get_tagName(&bstr);
                                    CString strTag = bstr;
                                    IHTMLImgElement\* pImgElem;
    
                                    //Is it an image element?
                                    hr = pDisp->QueryInterface(
                                        IID_IHTMLImgElement, 
                                        (void \*\*)&pImgElem );
                                    if ( hr == S_OK )
                                    {
                                        pImgElem->get_href(&bstr);
                                        strTag += " - ";
                                        strTag += bstr;
                                        pImgElem->Release();
                                    }
                                    else
                                    {
                                        IHTMLAnchorElement\* pAnchElem;
    
                                        //Is it an anchor?
                                        hr = pDisp->QueryInterface(
                                            IID_IHTMLAnchorElement, 
                                            (void \*\*)&pAnchElem );
                                        if ( hr == S_OK )
                                        {
                                            pAnchElem->get_href(&bstr);
                                            strTag += " - ";
                                            strTag += bstr;
                                            pAnchElem->Release();
                                        }
                                    }//end of else
    
                                    pListView->GetListCtrl().InsertItem(
                                        pListView->GetListCtrl()
                                        .GetItemCount(), strTag);
                                    pElem->Release();
                                }
                                pDisp->Release();
                            }
                        }
                    }
                    pColl->Release();
                }
                pHTMLDocument2->Release();
            }
            pDisp->Release();
        }
    }
    
    Here are the steps that this function takes to "explore" the HTML document using DHTMLs:
    
    *   First _DoHTMLExplore_ gets pointers to the _CListView_ and _CHtmlView_ views in the splitter window.
        
    *   Then it makes a call to _GetHtmlDocument_ to get an _IDispatch_ pointer to the DHTML _document_ object.
        
    *   Next _DoHTMLExplore_ gets the _IHTMLDocument2_ interface.
        
    *   With the _IHTMLDocument2_ interface, _DoHTMLExplore_ retrieves the _all_ collection and iterates through it. In each iteration, _DoHTMLExplore_ checks the element type.If the element is an image or an anchor, _DoHTMLExplore_ retrieves additional information such as the link for the image. The _all_ collection loop then places the textual description of the HTML element in the _CListView_ object.
        
    
9.  **Make sure that Mainfrm.cpp includes mshtml.h.** Add the following line to the top of Mainfrm.cpp so that the _DoHTMLExplore_ code will compile.
    
    #include <mshtml.h>
    
10.  **Add a call to _DoHTMLExplore_.** For this example, we will change the _CEx37bApp::OnAppAbout_ function to call the _DoDHTMLExplore_ function in the ex37b.cpp file. Replace the existing code with the following boldface code:
    
    void CEx37bApp::OnAppAbout()
    {
        **CMainFrame \* pFrame = (CMainFrame\*)AfxGetMainWnd();
        pFrame->DoDHTMLExplore();**
    
    }
    
11.  **Customize the list view.** In the _CLeftView::PreCreateWindow_ function (LeftView.cpp), add this line:
    
    cs.style |= LVS_LIST;
    
12.  **Compile and run.** Compile and run the sample. Press the "?" toolbar item, or choose Help/About to invoke the explore function.
    
    Figure 37-4 shows the EX37B example in action.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F37OG04x.gif)]
    
    **Figure 37-4.** _The EX37B example in action._
    

Now that you've seen how to use DHTML and MFC, let's look at how ATL implements DHMTL support.

ATL and DHTML
-------------

ATL's support for DHTML comes in the form of an HTML object that can be embedded in any ATL ActiveX control. EX37C creates an ATL control that illustrates DHTML support.

To create the example, follow these steps:

2.  **Run the ATL COM AppWizard and create \vcpp32\ex37c\ex37c.** Choose New from Visual C++'s File menu. Then click the Projects tab, and select ATL COM AppWizard. Choose Executable as the server type.
    
3.  **Insert an HTML control.** In ClassView, right-click on the ex37c classes item and select New ATL Object. Select Controls and HTML Control as shown in the graphic below.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G37OG03x.GIF)
    
4.  **Click Next and fill in the C++ Short Name as shown here.**
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G37OG04x.GIF)
    
    > NOTE
    > 
    > If you look at the _IDHTMLUI_ object, you will see this stock implementation of the _OnClick_ handler:
    > 
    >     STDMETHOD(OnClick)(IDispatch\* pdispBody, VARIANT varColor)
    >     {
    >         CComQIPtr<IHTMLBodyElement> spBody(pdispBody);
    >         if (spBody != NULL)
    >             spBody->put_bgColor(varColor);
    >         return S_OK;
    >     }
    > 
    > The default _OnClick_ handler uses _QueryInterface_ on the _IDispatch_ pointer to get the _IHTMLBodyElement_ object. The handler then calls the _put_bgColor_ method to change the background color.
    
5.  **Compile, load, and run the control to see the ATL DHTML code in action.** After you build the project, select ActiveX Control Test Container from the Tools menu. In the test container, select Insert New Control from the Edit menu and choose CDHTML Class from the list box. Figure 37-5 shows the resulting ActiveX control that uses DHTML to change the background when the user clicks the button.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/f37og05x.gif)
    
    **Figure 37-5.** _EX37C ActiveX control._
    

For More Information…
---------------------

We hope this introduction to DHTML has you thinking of some ways to use this exciting new technology in your Visual C++ applications. The possibilities are endless: completely dynamic applications, applications that update from the Internet, client/server ActiveX controls, and many more.

If you would like to learn more about DHTML, we suggest the following resources:

*   _Inside Dynamic HTML_ by Scott Isaacs (Microsoft Press, 1997)
    
*   _Dynamic HTML in Action_ by William J. Pardi and Eric M. Schurman (Microsoft Press, 1998)
    
*   _The Internet SDK (an excellent resource on DHTML and other Microsoft technologies)_
    
*   _[www.microsoft.com](http://www.microsoft.com)_ (several areas discuss DHTML)
________________________________________________________________________
9.5. - [Chapter 38 -- Visual C++ for Windows CE](invcpp5/ch38a.htm)
----------------------------------------------------
 Chapter 38 -- Visual C++ for Windows CE  Chapter 38

Visual C++ for Windows CE
=========================

In early 1997, Microsoft released a new version of the Windows family of operating systems named Windows CE. Original equipment managers (OEMs) are the target audience for Windows CE. OEMs create small, portable devices—such as hand-held computers—and embedded systems. A myriad of different operating systems, a lack of strong development tools, and a maze of user interfaces have plagued both the portable-device and embedded system markets. In the past, these problems limited the use of these systems and restricted the availability of inexpensive software applications.

> NOTE
> 
> At the time of this writing, Windows CE support for Visual C++ 6.0 was not available. All screen shots and samples programs in this chapter were created using Visual C++ for Windows CE 5.0.

Microsoft hopes that Windows CE can do for the embedded and handheld markets what Windows did for the desktop PC industry. Based on the target audience, you can probably guess that Windows CE has different design goals than Windows 98 and Windows NT. One goal was modularity: if an OEM is using Windows CE in an embedded device for a refrigerator, the keyboard and graphics output modules are not required. The OEM does not pay a penalty for modules not used by the application of Windows CE.

To date, there have been two major releases of Windows CE. The first release was primarily for Handheld PCs (H/PCs) and was limited to noncolor applications. Windows CE 1.0 lacked many advanced Win32 features such as COM and ActiveX, large chunks of GDI, and many Windows controls. Win- dows CE 2.0 was released in late 1997 and added support for a variety of new device types, color, COM and ActiveX technology, and also a Java virtual machine.

Before we look at the details of the Win32 support in Windows CE, let's examine some of the existing device types to get a feel for possible Windows CE applications.

Windows CE devices
------------------

Currently the best known Windows CE devices are the H/PCs such as those available from HP, Sharp, Casio and a variety of vendors. Figure 38-1 shows a typical H/PC machine.

![](c:/dl/books/windows/msvc5th/invcpp5/images/F38og01.jpg)

**Figure 38-1.** _A typical Handheld PC._

H/PCs currently have display resolutions anywhere from 480 by 240 pixels to as large as 640by 240 pixels. They typically have a keyboard, infrared port, serial port, and microphone. The standard software on these devices includes: Pocket Word, Pocket Excel, Internet Explorer, Outlook Express, and other scaled-down Microsoft productivity applications.

A smaller device called a Palm-size PC (P/PC) shown in Figure 38-2 is completely pen-based and does not have a keyboard. Screen sizes are also smaller (240 by 320 pixels) and only gray-scale displays are currently available for P/PCs.

![](c:/dl/books/windows/msvc5th/invcpp5/images/f38og02.jpg)

**Figure 38-2.** _A Palm-size PC._

> NOTE
> 
> Note: At the time of this book's publication, MFC is not supported on the Palm-size PC platform. The SDK for Palm-size PCs and embedded development is also not included with the Visual C++ for Windows CE product. These SDKs must be downloaded from the Microsoft website [http://www.microsoft.com](http://www.microsoft.com).

Perhaps the most exciting Windows CE devices now reaching the market are embedded applications. For example, the CD player from Clarion shown in Figure 38-3 features a GUI, voice recognition, cellular phone support, and a variety of other features that are changing the way we think about electronic devices and appliances. Unlike Windows 95, which only supports Intel processors, and Windows NT, which only supports the Intel and Alpha processors, Windows CE supports a myriad of embeddable 32-bit processors such as the MIPS chip, Hitachi chips, and a variety of other chip sets. This flexibility dramatically increases the potential reach of Windows CE in the embedded market.

![](c:/dl/books/windows/msvc5th/invcpp5/images/f38og03.jpg)

**Figure 38-3.** _An automotive CD player powered by Window CE._

Because all of these devices are based on Windows CE, you can write applications for them using a subset of the familiar Win32 APIs that you have learned throughout this book. Before we investigate Visual C++ programming for Windows CE, let's take a look at the subset of Win32 implemented by Windows CE.

Windows CE vs. Windows 98 and Windows NT
----------------------------------------

Each Windows CE platform (H/PC, Palm-size PC and embedded) supports various subsets of the Win32 API based on which Windows CE modules are loaded. The "core" functionality is fairly static among devices—GDI, windows, and controls and so on, but some user input functions are different. (On a Palm-size PC, for example, it doesn't make sense to have keyboard functions.)

The Win32 support in Windows CE matches the primary design goal of Windows CE: keep everything as small as possible. Whenever a duplicate Win32 call exists, Windows CE provides only the most general API function. For example, instead of implementing both _TextOut_ and _ExtTextOut_, Windows CE supports only the more flexible _ExtTextOut,_ because in this single API you have the functionality of both.

Another interesting aspect of the Win32 Windows CE implementation is that only Unicode functions and strings are supported. You need to be sure to wrap your Windows CE MFC strings with the __T_ macro.

At the GDI layer, Windows CE supports a relatively small subset of the implementations found in Windows 95, Windows 98, and Windows NT. The key groups of GDI Win32 API functions not implemented in Windows CE are mapping modes, arcs, chords, metafiles, and Bézier curves. When you draw lines, you must use _PolyLine_ because _MoveTo and LineTo_ are not supported. Cursor and mouse handling in Windows CE can also be different from what you are accustomed to on larger systems.

Version 2.0 of Windows CE adds many key features that allow for parity with its big brothers, such as color support, TrueType font support, printing, and memory DCs. Many other nuances of the various GDI implementations are well documented in the Windows CE SDK, which is shipped as part of the Visual C++ for Windows CE product.

Windows CE also has some major differences in windowing. Perhaps the largest difference is the fact that only SDI applications are supported. Thus, porting existing MDI applications to Windows CE is relatively difficult. Another interesting windowing fact is that Windows CE windows are not resizable. Since there are a wide variety of screen resolutions, you should programmatically size windows based on the resolution of the display, instead of using static layouts.

Most of the standard Windows 95, Windows 98, and Internet Explorer 4.0 common controls are available on Windows CE, except for the following: the rich edit control, the IP control, _ComboBoxEx_ controls, and the hot key control. Windows CE actually introduces a new common control—the command bar. Command bars implement a hybrid menu bar and toolbar that occupies considerably less space than the standard menu bar and toolbar configuration found in most desktop applications. Figure 38-4 shows an example of a Windows CE command bar.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F38OG04x.gif)]

**Figure 38-4.** _A Windows CE command bar._

ActiveX and COM are supported in Windows CE 2.0, but only for in-process COM objects such as ActiveX controls. Multithreading, memory management, exception handling, and most other areas of Win32 are fully supported —with a few caveats—by Windows CE.

Now that you're familiar with the basics of Windows CE, let's take a look at the Visual C++ development environment for this new operating system.
________________________________________________________________________
9.5.1. - [Visual C++ for Windows CE](invcpp5/ch38b.htm)
----------------------------------------------------
 Visual C++ for Windows CE 

Visual C++ for Windows CE
=========================

Visual C++ for Windows CE is an add-on to Visual C++. When you install C++ for Windows CE, it extends the Visual C++ environment by adding several Windows CE-specific features:

*   An Intel-based Windows CE emulation environment
    
*   New targets for each of the Windows CE supported processors (MIPS/SH and the emulation environment)
    
*   New AppWizards for Windows CE applications
    
*   A Windows CE compatible port of MFC
    
*   A Windows CE compatible port of ATL
    
*   Tools for remote execution and debugging of Windows CE applications on actual devices
    

One interesting aspect of Visual C++ for Windows CE is the fact that it also supports the older 1.0 and 1.01 versions of Windows CE. Figure 38-5 shows the Windows CE operating system and processor configuration bars that have been added to Visual C++.

While the environment lets you remotely run and debug your applications on a connected Windows CE device, it also includes a very powerful Windows CE emulation environment. The Windows CE emulator (WCE) is an Intel-based software-only version of Windows CE that runs on your desktop and gives you the convenience of being able to run and test your applications on your development machine. Of course, to ensure that your applications work correctly, you still need to test on real devices, but the emulator takes much of the pain out of the early compile and debug stages of Windows CE development. Figure 38-6 shows the emulation environment in action.

There are four Windows-CE-specific AppWizards that ship with Visual C++ for WCE:

*   **WCE ATL COM AppWizard**—An ATL-based COM object project
    
*   **WCE MFC ActiveX ControlWizard**—An MFC ActiveX control project
    
*   **WCE MFC AppWizard (dll)**—An MFC DLL project
    
*   **WCE MFC AppWizard (exe)**—An MFC executable project
    

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f38og05x.gif)]

**Figure 38-5.** _Visual C++ for the Windows CE environment._

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f38og06x.gif)]

**Figure 38-6.** _The Windows CE emulator._

The WCE AppWizards are basically the same as their big brother Win32 counterparts, except that they have different features that take advantage of the Windows CE operating system, such as the Windows CE help environment. Figure 38-7 shows the first three steps of the Windows CE MFC executable AppWizard. Notice that there are only two project types: SDI and dialog-based. Notice also the variety of Windows-CE-specific options that you can choose from.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f38og07ax.gif)]

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f38og07bx.gif)]

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/f38og07cx.gif)]

**Figure 38-7.** _The Windows CE MFC AppWizard._

MFC for Windows CE
------------------

Visual C++ for Windows CE ships with a smaller version of MFC named Mini MFC. To get a feel for which MFC classes are and are not supported, see Figure 38-8—the MFC for Windows CE hierarchy chart. The grayed out classes are not supported on Windows CE.

Several classes have been added to Mini MFC, including classes for command bars, object store, and socket classes. Windows CE functions provide the command bars in the Mini MFC _CFrameWnd_ class.

Instead of implementing a file metaphor, Windows CE provides an object store. Several new MFC classes were added to give the Windows CE developer access to the object store:

*   **_CCeDBDatabase_**—Encapsulates a database in the object store
    
*   **_CCeDBEnum_**—Enumerates the databases in the object store
    
*   **_CCeDBProp_**—Encapsulates a database property (Database properties are data items consisting of an application-defined property identifier, a data-type identifier, and the data value.)
    
*   **_CCeDBRecord_**—Provides access to a record in the database

In addition to these data store classes, a new class _CCeSocket_ is provided. _CCeSocket_ implements an asynchronous _CSocket_ derivative.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F38OG08Ax.gif)]

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F38OG08Bx.gif)]

**Figure 38-8.** _MFC for Windows CE hierarchy chart._

Using Mini MFC
--------------

Let's look at a couple of examples to get a feel for the Mini version of MFC. In example EX38A, we will create a basic SDI application that draws some text in the view and displays a dialog when the user presses the left mouse button (or taps the screen on a Windows CE machine). EX38A is similar to the EX06A example, so you can compare the steps in creating a similar application for Windows 98, Windows NT, and Windows CE. For this example, you will create a simulated expense-tracking application for Windows CE—a perfect candidate for portable computing. For demonstration purposes, we will focus on creating a dialog that allows the user to enter expense information. Figure 38-9 shows the application running in the emulation environment.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F38OG09x.gif)]

**Figure 38-9.** _The EX38A expense-tracking application._

Here are the steps to create the EX38A example:

2.  **Run the MFC Executable for Windows CE AppWizard to produce \vcpp32\ex38a\ex38a.** Select the WCE MFC AppWizard project type and accept all the defaults. The options and the default class names are shown here.
    
3.  **Select the WCE x86em Debug configuration.** Choose the Set Active Configuration command from the Set menu and then select Ex38a-Win32 (WCE x86em) Debug from the list. Click OK. This configuration will allow you to work with the desktop emulator instead of working remotely with a connected Windows CE device. (If you have a connected Windows CE device you can select its configuration instead. For example, select Ex38a—Win32 [WCE SH] Debug if you have a connected HP 620LX.)
    
    ![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/G38OG01x.GIF)
    
4.  **Use the dialog editor to create a dialog resource.** Choose Resource from the Insert menu, select Dialog, and then click New. The dialog editor assigns the ID _IDD_DIALOG1_ to the new dialog. Change the dialog caption to _The Dialog that Ate Windows CE!_ You can resize the dialog to be wider but not much taller. (Windows CE displays are much wider than they are tall.)
    
5.  **Remove the OK and CANCEL buttons and add an OK caption button.** Since screen real estate is at a premium in Windows CE, we can save a good deal of space in our dialog by deleting the OK and CANCEL buttons. For Cancel functionality, users can use the close button that is part of the dialog caption. Windows CE also supports an OK caption button that you can create by setting the dialog's property bar. To set the property, open the properties editor for the dialog, click the Extended Styles tab, and then check the Caption Bar OK (WCE Only) option as shown here.
    
    ![](c:/dl/books/windows/msvc5th/invcpp5/images/G38OG02.GIF)
    
    (You might also need to set the dialog's Visible property on the More Styles tab.)
    
6.  **Add the dialog's controls.** Add the following controls shown in Figure 38-9 and accept the default names:
    
    *   A static control and an edit control for a name
        
    *   A static control and an edit control for an amount
        
    *   A static control and a drop-down combo box with for an expense type
        
    *   A City group box with three radio buttons labeled Atlanta, Detroit, and Chicago
        
    *   A Payment Option group box with three check boxes labeled Check, Credit Card, and Cash.
        
    
7.  **Add the _CEx38aDialog_ class.** After adding the controls, double-click on the dialog. ClassWizard detects that you have created a dialog resource and asks whether you want to create a class for the dialog. Click OK and accept the defaults to create the _CEx06aDialog_ class.
    
8.  **Program the controls.** Use ClassWizard to create the following member variables in the dialog class:
    
    *   **_m_pComboBox_—**a member variable used to configure the expense type combo box
        
    *   **_m_pProgressCtrl_—**A member variable for the progress control
    
    > NOTE
    > 
    > If you need a refresher on how to program modal dialogs, please refer to [Chapter 6](ch06a.htm).
    
    Next, add the following code to the _CEx38aDialog::OnInitDialog_ handler to initialize the controls:
    
    **BOOL CWindowsCEDlg::OnInitDialog() 
    {
        CDialog::OnInitDialog();
        m_pComboBox.AddString(_T("Travel"));
        m_pComboBox.AddString(_T("Meal"));
        m_pComboBox.AddString(_T("Cab Fare"));
        m_pComboBox.AddString(_T("Entertainment"));
        m_pComboBox.AddString(_T("Other"));
        m_pProgressCtrl.SetPos(50);
    
        return TRUE;  
    }**
    
    Notice that you must use the __T_ macro whenever you have inline strings.
    
9.  **Connect the dialog to the View.** In ClassWizard, select the _CEx38aView_ class and use ClassWizard to add the _OnLButtonDown_ member function.
    
10.  **Write the code for the _OnLButtonDown_ handler.** Add the boldface code below:
    
    void CEx38aView::OnLButtonDown(UINT nFlags, CPoint point) 
    {
        **CWindowsCEDlg dlg;
        dlg.DoModal();
        CView::OnLButtonDown(nFlags, point);**
    }
    
11.  **Add code to the virtual _OnDraw_ function in file ex38aView.cpp.** The _CDC::TextOut_ function used in previous examples is not supported on Windows CE, so we need to use the _CDC::DrawText_ function as shown here:
    
    void CEx38aView::OnDraw(CDC\* pDC)
    {
        **CRect rect;
        GetClientRect(rect);
    
        pDC->SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));
        pDC->SetBkMode(TRANSPARENT);
    
        pDC->DrawText(_T("Press the left mouse button here."), 
            rect, DT_SINGLELINE);**
    }
    
12.  **Add the ex38aDialog.h header file to ex38aView.cpp.** Insert the include statement
    
    **#include "ex38aDialog.h"**
    
    at the top of the ex38aView.cpp source file, after the statement
    
    #include "ex38aView.h"
    
13.  **Build and run the application.** The EX38A application should appear as shown in Figure 38-10. If everything works satisfactorily, you can change the configuration for a real Windows CE device. Then you can run (or debug) the application remotely on the device to ensure it works in a real-world situation.
    
    [![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F38OG10x.gif)]
    
    **Figure 38-10.** _The EX 38A application running in the Windows CE emulator._
    

As you can tell from the EX38A application, programming for Windows CE is very similar to programming for Windows 98 and Windows.

Many Windows CE developers are interested in porting existing applications to the Windows CE environment. The next section shows you how to tackle this problem.

Porting an Existing MFC Application to Windows CE
-------------------------------------------------

In example EX38B we will port an existing application (EX06B from [Chapter 6](ch06a.htm)) from Windows 98 and Windows NT to Windows CE.

> NOTE
> 
> We chose the EX06B sample because it is an SDI application. If you are porting an MDI application to Windows CE, we recommend that you first convert it into an SDI application (or a series of SDI applications, if you have several views) and then port it to Windows CE.

Here are the steps for converting EX06B:

2.  **Run the MFC AppWizard to produce \vcpp32\ex38b\ex38b.** Select the WCE MFC AppWizard project type and accept all defaults. (You might have thought that we could copy the EX06B workspace and then add a Windows CE configuration. However, it is actually easier to start with a WCE MFC AppWizard project instead because there are many complicated build settings that the wizard automatically sets up for you.)
    
3.  **Using Windows Explorer, copy the EX06B files to the EX38B directory.** Be sure to copy the following files: Ex06bDialog.h, Ex06bDialog.cpp, Ex06bDoc.h, Ex06bDoc.cpp, ex06bView.h, and ex06bView.cpp.
    
4.  **Insert the new files into the project.** Choose the Add To Project/Files command from the Project menu and insert the files from step 2 into the project.
    
5.  **Copy the dialog and Icon resources from EX06B.** Choose Open from the File menu and select \vcpp32\ex06b\ex06b\ex06b.rc. Drag and drop IDD_DIALOG1 from ex06b.rc into the EX38B project. Next, drag and drop the color icon resources (IDI_BLACK, IDI_BLUE, and so on) from the ex06b.rc file into the EX38B project.
    
6.  **Build the application and repair any compiler errors or warnings.** Now that you have moved the key files that you need (the document, view, and dialog classes) from the EX06B application to the Windows CE EX38B application, try to build the project. You should see a number of errors that can be fixed with the following steps:
    
    *   Change all references to the file ex06b.h to ex38b.h
        
    *   Make sure that all inline strings use the __T_ macro. For example, in Ex06bDialog.cpp the line
        
        TRACE("updating trackbar data members\n");
        
        should be changed to use the __T_ macro as follows:
        
        TRACE(**_T("**updating trackbar data members\n"));
        
    *   Convert any other non-Unicode strings to Unicode. (This is the most frequently encountered porting problem.)
        
    *   _Ex06bView::OnDraw_ uses the unsupported _CDC::TextOut_ member function. Change it to use _DrawText_ as follows:
        
            **CRect rect;
            GetClientRect(rect);
        
            pDC->SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));
            pDC->SetBkMode(TRANSPARENT);
        
            pDC->DrawText(_T("Press the left mouse button here."), 
                rect, DT_SINGLELINE);**
        
    
7.  **Replace the wizard-generated view with the real view.** Open the ex38b.cpp file and do a global search and replace:
    
    *   Change CEx38bDoc to CEx06bDoc
        
    *   Change CEx38bView to CEx06bView
        
    
    Also, make sure that ex38b.cpp #includes both the ex06bView.h and ex06bDoc.h header files.
    
8.  **Using the dialog editor, adjust the dialog's layout for Windows CE.** As it stands, the dialog is far too tall for Windows CE. You can rearrange it by following these steps:
    
    *   Remove the OK and CANCEL buttons and use the OK window button (see step 4 in the EX38A example).
        
    *   Move the progress bar controls, sliders, and spinners closer together at the top of the dialog.
        
    *   Move the list control and tree control closer together. To save vertical space, move the current selection static controls to the left of both the tree and list control.
        
    *   Size the dialog to fit on a smaller screen.
        
    
9.  **Clean up the project.** Now you can remove the document and view classes created by the MFC AppWizard by selecting the files in FileView and pressing the Delete key.
    
10.  **Build and test.** In eight easy steps, you have converted a small MFC application from Windows 98 and Windows NT to Windows CE.
    
    Figure 38-11 shows EX38B running in emulation mode for Window CE.
    

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F38OG11x.gif)]

**Figure 38-11.** _The EX38B application running in the Windows CE emulator._

ATL and Windows CE
------------------

In addition to Mini MFC, Visual C++ for Windows CE also provides a Windows CE-friendly version of ATL. ATL is already a lightweight framework, so Microsoft didn't need to reduce the feature set for size constraints. However, there are some areas of COM not covered by Windows CE 2.0 that impact the feature set of ATL for Windows CE.

Windows CE doesn't support the apartment-threading model, so ATL for Windows CE doesn't implement the _CComApartment_, _CComAutoThreadModule_, _CComClassFactoryAutoThread_, or _CComSimpleThreadAllocator_ classes.

Windows CE also doesn't support asynchronous monikers, so ATL for Windows CE doesn't implement the _IBindStatusCallbackImpl_ or _CBindStatusCallback_ classes. A variety of other ATL class member functions that behave differently on Windows CE are documented in the Visual C++ for Windows CE documentation.

In addition to ATL, a Windows CE version of the ATL Wizard is provided. Figure 38-12 shows the wizard that has only one option: to use MFC or not.

[![Click to view at full size.](c:/dl/books/windows/msvc5th/invcpp5/images/F38OG12x.gif)]

**Figure 38-12.** _The WCE ATL COM AppWizard._

When you write ActiveX controls for Windows CE, remember that they are binary objects and therefore processor-dependent. Depending on the devices you plan to support, you might have to provide several versions of the control (MIPS or SH, for example).
________________________________________________________________________
9.5.2. - [For More Information on Windows CE...](invcpp5/ch38c.htm)
----------------------------------------------------
 For More Information on Windows CE... 

For More Information on Windows CE…
===================================

Windows CE is an exciting new environment for Windows developers to explore. The ability to leverage your knowledge of Windows, Win32, and Visual C++ makes Windows CE an extremely appealing and easy-to-work-with environment. _Programming Windows CE_ by Doug Boling (Microsoft Press, 1998) is an excellent resource for learning the details of Windows CE.

Microsoft is developing Windows CE and related technologies at an incredible pace. To stay up to date, we recommend using the Web. Keep an eye on these sites:

*   [http://www.microsoft.com/windowsce](http://www.microsoft.com/windowsce). This site provides news and information about the Windows CE operating system, devices and development tools. You can sign up for a useful newsletter here.
    
*   [http://www.microsoft.com/msdn](http://www.microsoft.com/msdn). The Microsoft Developer Network (MSDN) has tons of Windows CE articles. They are all online and searchable.
________________________________________________________________________
/10. - [Appendixes]()
====================================================
________________________________________________________________________
10.1. - [Appendix A -- Message Map Functions in the Microsoft Foundation Class Library](invcpp5/chaaa.htm)
----------------------------------------------------
 Appendix A -- Message Map Functions in the Microsoft Foundation Class Library 

Appendix A
==========

Message Map Functions in the Microsoft Foundation Class Library
===============================================================

**HANDLERS FOR WM_COMMAND MESSAGES**

**Map Entry**

**Function Prototype**

ON_COMMAND(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_COMMAND_EX(<id>, <memberFxn>)

afx_msg BOOL memberFxn(UINT);

ON_COMMAND_EX_RANGE(<id>, <idLast>, <memberFxn>)

afx_msg BOOL memberFxn(UINT);

ON_COMMAND_RANGE(<id>, <idLast>, <memberFxn>)

afx_msg void memberFxn(UINT);

ON_UPDATE_COMMAND_UI(<id>, <memberFxn>)

afx_msg void memberFxn(CCmdUI\*);

ON_UPDATE_COMMAND_UI_RANGE (<id>, <idLast>, <memberFxn>)

afx_msg void memberFxn(CCmdUI\*);

ON_UPDATE_COMMAND_UI_REFLECT (<memberFxn>)

afx_msg void memberFxn(CCmdUI\*);

**HANDLERS FOR CHILD WINDOW NOTIFICATION MESSAGES**

**Map Entry**

**Function Prototype**

**_Generic Control Notification Codes_**

 

ON_CONTROL(<wNotifyCode>, <id>, <memberFxn>)

afx_msg void memberFxn();

ON_CONTROL_RANGE(<wNotifyCode>, <id> <idLast>, <memberFxn>)

afx_msg void memberFxn(UINT);

ON_CONTROL_REFLECT(<wNotifyCode>, <memberFxn>)

afx_msg void memberFxn();

ON_CONTROL_REFLECT_EX(<wNotifyCode>, <memberFxn>)

afx_msg BOOL memberFxn();

ON_NOTIFY(<wNotifyCode>, <id>, <memberFxn>)

afx_msg void memberFxn(NMHDR\*, LRESULT\*);

ON_NOTIFY_EX(<wNotifyCode>, <id>, <memberFxn>)

afx_msg BOOL memberFxn(UINT, NMHDR\*, LRESULT\*);

ON_NOTIFY_EX_RANGE(<wNotifyCode>, <id>, <idLast>, <memberFxn>)

afx_msg BOOL memberFxn(UINT, NMHDR\*, LRESULT\*);

ON_NOTIFY_RANGE(<wNotifyCode>, <id>, <idLast>, <memberFxn>)

afx_msg void memberFxn(UINT, NMHDR\*, LRESULT\*);

ON_NOTIFY_REFLECT(<wNotifyCode>, <memberFxn>)

afx_msg void memberFxn(NMHDR\*, LRESULT\*);

ON_NOTIFY_REFLECT_EX(<wNotifyCode>, <memberFxn>)

afx_msg BOOL memberFxn(NMHDR\*, LRESULT\*);

**_User Button Notification Codes_**

 

ON_BN_CLICKED(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_BN_DOUBLECLICKED(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_BN_KILLFOCUS(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_BN_SETFOCUS(<id>, <memberFxn>)

afx_msg void memberFxn();

**_Combo Box Notification Codes_**

 

ON_CBN_CLOSEUP(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_CBN_DBLCLK(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_CBN_DROPDOWN(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_CBN_EDITCHANGE(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_CBN_EDITUPDATE(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_CBN_ERRSPACE(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_CBN_KILLFOCUS(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_CBN_SELCHANGE(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_CBN_SELENDCANCEL(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_CBN_SELENDOK(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_CBN_SETFOCUS(<id>, <memberFxn>)

afx_msg void memberFxn();

**_Check List Box Notification Codes_**

 

ON_CLBN_CHKCHANGE(<id>, <memberFxn>)

afx_msg void memberFxn();

**_Edit Control Notification Codes_**

 

ON_EN_CHANGE(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_EN_ERRSPACE(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_EN_HSCROLL(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_EN_KILLFOCUS(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_EN_MAXTEXT(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_EN_SETFOCUS(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_EN_UPDATE(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_EN_VSCROLL(<id>, <memberFxn>)

afx_msg void memberFxn();

**_List Box Notification Codes_**

 

ON_LBN_DBLCLK(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_LBN_ERRSPACE(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_LBN_KILLFOCUS(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_LBN_SELCANCEL(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_LBN_SELCHANGE(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_LBN_SETFOCUS(<id>, <memberFxn>)

afx_msg void memberFxn();

**_Static Control Notification Codes_**

 

ON_STN_CLICKED(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_STN_DBLCLK(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_STN_DISABLE(<id>, <memberFxn>)

afx_msg void memberFxn();

ON_STN_ENABLE(<id>, <memberFxn>)

afx_msg void memberFxn();

**HANDLERS FOR WINDOW NOTIFICATION MESSAGES**

**Map Entry**

**Function Prototype**

ON_WM_ACTIVATE()

afx_msg void OnActivate(UINT, CWnd\*, BOOL);

ON_WM_ACTIVATEAPP()

afx_msg void OnActivateApp(BOOL, HTASK);

ON_WM_ASKCBFORMATNAME()

afx_msg void OnAskCbFormatName(UINT, LPTSTR);

ON_WM_CANCELMODE()

afx_msg void OnCancelMode();

ON_WM_CAPTURECHANGED()

afx_msg void OnCaptureChanged(CWnd\*);

ON_WM_CHANGECBCHAIN()

afx_msg void OnChangeCbChain(HWND, HWND);

ON_WM_CHAR()

afx_msg void OnChar(UINT, UINT, UINT);

ON_WM_CHARTOITEM()

afx_msg int OnCharToItem(UINT, CListBox\*, UINT);

ON_WM_CHARTOITEM_REFLECT()

afx_msg int CharToItem(UINT, UINT);

ON_WM_CHILDACTIVATE()

afx_msg void OnChildActivate();

ON_WM_CLOSE()

afx_msg void OnClose();

ON_WM_COMPACTING()

afx_msg void OnCompacting(UINT);

ON_WM_COMPAREITEM()

afx_msg int OnCompareItem(int, LPCOMPAREITEMSTRUCT);

ON_WM_COMPAREITEM_REFLECT()

afx_msg int CompareItem (LPCOMPAREITEMSTRUCT);

ON_WM_CONTEXTMENU()

afx_msg void OnContextMenu(CWnd\*, CPoint);

ON_WM_COPYDATA()

afx_msg BOOL OnCopyData(CWnd\*, COPYDATASTRUCT\*);

ON_WM_CREATE()

afx_msg int OnCreate(LPCREATESTRUCT);

ON_WM_CTLCOLOR()

afx_msg HBRUSH OnCtlColor(CDC\*, CWnd\*, UINT);

ON_WM_CTLCOLOR_REFLECT()

afx_msg HBRUSH CtlColor(CDC\*, UINT);

ON_WM_DEADCHAR()

afx_msg void OnDeadChar(UINT, UINT, UINT);

ON_WM_DELETEITEM()

afx_msg void OnDeleteItem(int, LPDELETEITEMSTRUCT);

ON_WM_DELETEITEM_REFLECT()

afx_msg void DeleteItem (LPDELETEITEMSTRUCT)

ON_WM_DESTROY()

afx_msg void OnDestroy();

ON_WM_DESTROYCLIPBOARD()

afx_msg void OnDestroyClipboard();

ON_WM_DEVICECHANGE()

afx_msg BOOL OnDeviceChange(UINT, DWORD);

ON_WM_DEVMODECHANGE()

afx_msg void OnDevModeChange(LPTSTR);

ON_WM_DRAWCLIPBOARD()

afx_msg void OnDrawClipboard();

ON_WM_DRAWITEM()

afx_msg void OnDrawItem(int, LPDRAWITEMSTRUCT);

ON_WM_DRAWITEM_REFLECT()

afx_msg void DrawItem (LPDRAWITEMSTRUCT);

ON_WM_DROPFILES()

afx_msg void OnDropFiles(HDROP);

ON_WM_ENABLE()

afx_msg void OnEnable(BOOL);

ON_WM_ENDSESSION()

afx_msg void OnEndSession(BOOL);

ON_WM_ENTERIDLE()

afx_msg void OnEnterIdle(UINT, CWnd\*);

ON_WM_ENTERMENULOOP()

afx_msg void OnEnterMenuLoop(BOOL);

ON_WM_ERASEBKGND()

afx_msg BOOL OnEraseBkgnd(CDC\*);

ON_WM_EXITMENULOOP()

afx_msg void OnExitMenuLoop(BOOL);

ON_WM_FONTCHANGE()

afx_msg void OnFontChange();

ON_WM_GETDLGCODE()

afx_msg UINT OnGetDlgCode();

ON_WM_GETMINMAXINFO()

afx_msg void OnGetMinMaxInfo (MINMAXINFO\*);

ON_WM_HELPINFO()

afx_msg BOOL OnHelpInfo(HELPINFO\*);

ON_WM_HSCROLL()

afx_msg void OnHScroll(UINT, UINT, CScrollBar\*);

ON_WM_HSCROLL_REFLECT()

afx_msg void HScroll(UINT, UINT);

ON_WM_HSCROLLCLIPBOARD()

afx_msg void OnHScrollClipboard(CWnd\*, UINT, UINT);

ON_WM_ICONERASEBKGND()

afx_msg void OnIconEraseBkgnd(CDC\*);

ON_WM_INITMENU()

afx_msg void OnInitMenu(CMenu\*);

ON_WM_INITMENUPOPUP()

afx_msg void OnInitMenuPopup(CMenu\*, UINT, BOOL);

ON_WM_KEYDOWN()

afx_msg void OnKeyDown(UINT, UINT, UINT);

ON_WM_KEYUP()

afx_msg void OnKeyUp(UINT, UINT, UINT);

ON_WM_KILLFOCUS()

afx_msg void OnKillFocus(CWnd\*);

ON_WM_LBUTTONDBLCLK()

afx_msg void OnLButtonDblClk(UINT, CPoint);

ON_WM_LBUTTONDOWN()

afx_msg void OnLButtonDown(UINT, CPoint);

ON_WM_LBUTTONUP()

afx_msg void OnLButtonUp(UINT, CPoint);

ON_WM_MBUTTONDBLCLK()

afx_msg void OnMButtonDblClk(UINT, CPoint);

ON_WM_MBUTTONDOWN()

afx_msg void OnMButtonDown(UINT, CPoint);

ON_WM_MBUTTONUP()

afx_msg void OnMButtonUp(UINT, CPoint);

ON_WM_MDIACTIVATE()

afx_msg void OnMDIActivate(BOOL, CWnd\*, CWnd\*);

ON_WM_MEASUREITEM()

afx_msg void OnMeasureItem(int, LPMEASUREITEMSTRUCT);

ON_WM_MEASUREITEM_REFLECT()

afx_msg void MeasureItem (LPMEASUREITEMSTRUCT);

ON_WM_MENUCHAR()

afx_msg LRESULT OnMenuChar(UINT, UINT, CMenu\*);

ON_WM_MENUSELECT()

afx_msg void OnMenuSelect(UINT, UINT, HMENU);

ON_WM_MOUSEACTIVATE()

afx_msg int OnMouseActivate(CWnd\*, UINT, UINT);

ON_WM_MOUSEMOVE()

afx_msg void OnMouseMove(UINT, CPoint);

ON_WM_MOUSEWHEEL()

afx_msg BOOL OnMouseWheel(UINT, short, CPoint);

ON_WM_MOVE()

afx_msg void OnMove(int, int);

ON_WM_MOVING()

afx_msg void OnMoving(UINT, LPRECT);

ON_WM_NCACTIVATE()

afx_msg BOOL OnNcActivate(BOOL);

ON_WM_NCCALCSIZE()

afx_msg void OnNcCalcSize(BOOL, NCCALCSIZE_PARAMS\*);

ON_WM_NCCREATE()

afx_msg BOOL OnNcCreate (LPCREATESTRUCT);

ON_WM_NCDESTROY()

afx_msg void OnNcDestroy();

ON_WM_NCHITTEST()

afx_msg UINT OnNcHitTest(CPoint);

ON_WM_NCLBUTTONDBLCLK()

afx_msg void OnNcLButtonDblClk(UINT, CPoint);

ON_WM_NCLBUTTONDOWN()

afx_msg void OnNcLButtonDown(UINT, CPoint);

ON_WM_NCLBUTTONUP()

afx_msg void OnNcLButtonUp(UINT, CPoint);

ON_WM_NCMBUTTONDBLCLK()

afx_msg void OnNcMButtonDblClk(UINT, CPoint);

ON_WM_NCMBUTTONDOWN()

afx_msg void OnNcMButtonDown(UINT, CPoint);

ON_WM_NCMBUTTONUP()

afx_msg void OnNcMButtonUp(UINT, CPoint);

ON_WM_NCMOUSEMOVE()

afx_msg void OnNcMouseMove(UINT, CPoint);

ON_WM_NCPAINT()

afx_msg void OnNcPaint();

ON_WM_NCRBUTTONDBLCLK()

afx_msg void OnNcRButtonDblClk(UINT, CPoint);

ON_WM_NCRBUTTONDOWN()

afx_msg void OnNcRButtonDown(UINT, CPoint);

ON_WM_NCRBUTTONUP()

afx_msg void OnNcRButtonUp(UINT, CPoint);

ON_WM_PAINT()

afx_msg void OnPaint();

ON_WM_PAINTCLIPBOARD()

afx_msg void OnPaintClipboard(CWnd\*, HGLOBAL);

ON_WM_PALETTECHANGED()

afx_msg void OnPaletteChanged(CWnd\*);

ON_WM_PALETTEISCHANGING()

afx_msg void OnPaletteIsChanging(CWnd\*);

ON_WM_PARENTNOTIFY()

afx_msg void OnParentNotify(UINT, LPARAM);

ON_WM_PARENTNOTIFY_REFLECT()

afx_msg void ParentNotify(UINT, LPARAM);

ON_WM_QUERYDRAGICON()

afx_msg HCURSOR OnQueryDragIcon();

ON_WM_QUERYENDSESSION()

afx_msg BOOL OnQueryEndSession();

ON_WM_QUERYNEWPALETTE()

afx_msg BOOL OnQueryNewPalette();

ON_WM_QUERYOPEN()

afx_msg BOOL OnQueryOpen();

ON_WM_RBUTTONDBLCLK()

afx_msg void OnRButtonDblClk(UINT, CPoint);

ON_WM_RBUTTONDOWN()

afx_msg void OnRButtonDown(UINT, CPoint);

ON_WM_RBUTTONUP()

afx_msg void OnRButtonUp(UINT, CPoint);

ON_WM_RENDERALLFORMATS()

afx_msg void OnRenderAllFormats();

ON_WM_RENDERFORMAT()

afx_msg void OnRenderFormat(UINT);

ON_WM_SETCURSOR()

afx_msg BOOL OnSetCursor(CWnd\*, UINT, UINT);

ON_WM_SETFOCUS()

afx_msg void OnSetFocus(CWnd\*);

ON_WM_SETTINGCHANGE()

afx_msg void OnSettingChange(UINT, LPCTSTR);

ON_WM_SHOWWINDOW()

afx_msg void OnShowWindow(BOOL, UINT);

ON_WM_SIZE()

afx_msg void OnSize(UINT, int, int);

ON_WM_SIZECLIPBOARD()

afx_msg void OnSizeClipboard(CWnd\*, HGLOBAL);

ON_WM_SIZING()

afx_msg void OnSizing(UINT, LPRECT);

ON_WM_SPOOLERSTATUS()

afx_msg void OnSpoolerStatus(UINT, UINT);

ON_WM_STYLECHANGED()

afx_msg void OnStyleChanged(int, LPSTYLESTRUCT);

ON_WM_STYLECHANGING()

afx_msg void OnStyleChanging(int, LPSTYLESTRUCT);

ON_WM_SYSCHAR()

afx_msg void OnSysChar(UINT, UINT, UINT);

ON_WM_SYSCOLORCHANGE()

afx_msg void OnSysColorChange();

ON_WM_SYSCOMMAND()

afx_msg void OnSysCommand(UINT, LPARAM);

ON_WM_SYSDEADCHAR()

afx_msg void OnSysDeadChar(UINT, UINT, UINT);

ON_WM_SYSKEYDOWN()

afx_msg void OnSysKeyDown(UINT, UINT, UINT);

ON_WM_SYSKEYUP()

afx_msg void OnSysKeyUp(UINT, UINT, UINT);

ON_WM_TCARD()

afx_msg void OnTCard(UINT, DWORD);

ON_WM_TIMECHANGE()

afx_msg void OnTimeChange();

ON_WM_TIMER()

afx_msg void OnTimer(UINT);

ON_WM_VKEYTOITEM()

afx_msg int OnVKeyToItem(UINT, CListBox\*, UINT);

ON_WM_VKEYTOITEM_REFLECT()

afx_msg int VKeyToItem(UINT, UINT);

ON_WM_VSCROLL()

afx_msg void OnVScroll(UINT, UINT, CScrollBar\*);

ON_WM_VSCROLL_REFLECT()

afx_msg void VScroll(UINT, UINT);

ON_WM_VSCROLLCLIPBOARD()

afx_msg void OnVScrollClipboard(CWnd\*, UINT, UINT);

ON_WM_WINDOWPOSCHANGED()

afx_msg void OnWindowPosChanged (WINDOWPOS\*);

ON_WM_WINDOWPOSCHANGING()

afx_msg void OnWindowPosChanging (WINDOWPOS\*);

ON_WM_WININICHANGE()

afx_msg void OnWinIniChange(LPCTSTR);

**USER-DEFINED MESSAGE CODES**

**Map Entry**

**Function Prototype**

ON_MESSAGE(<message>, <memberFxn>)

afx_msg LRESULT memberFxn(WPARAM, LPARAM);

ON_REGISTERED_MESSAGE (<nMessageVariable>,<memberFxn>)

afx_msg LRESULT memberFxn(WPARAM, LPARAM);

ON_REGISTERED_THREADMESSAGE(<nMessageVariable>, <memberFxn>)

afx_msg void memberFxn(WPARAM, LPARAM);

ON_THREAD_MESSAGE (<message>, <memberFxn>)

afx_msg void memberFxn(WPARAM, LPARAM);
________________________________________________________________________
10.2. - [Appendix B -- MFC Library Runtime Class Identification and Dynamic Object Creation](invcpp5/chaba.htm)
----------------------------------------------------
 Appendix B -- MFC Library Runtime Class Identification and Dynamic Object Creation 

Appendix B
==========

MFC Library Runtime Class Identification and Dynamic Object Creation
====================================================================

Long before runtime type information (RTTI) was added to the C++ language specification, the MFC library designers realized that they needed runtime access to an object's class name and to the position of the class in the hierarchy. Also, the document-view architecture (and, later, COM class factories) demanded that objects be constructed from a class specified at runtime. So the MFC team created an integrated macro-based class identification and dynamic creation system that depends on the universal _CObject_ base class. And in spite of the fact that the Visual C++ version 6.0 compiler supports the ANSI RTTI syntax, the MFC library continues to use the original system, which actually has more features.

This appendix explains how the MFC library implements the class identification and dynamic creation features. You'll see how the _DECLARE_DYNAMIC_, _DECLARE_DYNCREATE_, and associated macros work, and you'll learn about the _RUNTIME_CLASS_ macro and the _CRuntimeClass_ structure.
________________________________________________________________________
10.2.1. - [Getting an Object's Class Name at Runtime](invcpp5/chabb.htm)
----------------------------------------------------
 Getting an Object's Class Name at Runtime 

Getting an Object's Class Name at Runtime
=========================================

If you wanted only an object's class name, you'd have an easy time, assuming that all your classes were derived from a common base class, _CObject_. Here's how you'd get the class name:

class CObject
{
public:
    virtual char\* GetClassName() const { return NULL; }
};

class CMyClass : public CObject
{
public:
    static char s_lpszClassName[];
    virtual char\* GetClassName() const { return s_lpszClassName; }
};
char CMyClass::s_szClassName[] = "CMyClass";

Each derived class would override the virtual _GetClassName_ function, which would return a static string. You would get an object's actual class name even if you used a _CObject_ pointer to call _GetClassName_. If you needed the class name feature in many classes, you could save yourself some work by writing macros. A _DECLARE_CLASSNAME_ macro might insert the static data member and the _GetClassName_ function in the class declaration, and an _IMPLEMENT_CLASSNAME_ macro might define the class name string in the implementation file.
________________________________________________________________________
10.2.2. - [The MFC CRuntimeClass Structure and the RUNTIME_CLASS Macro](invcpp5/chabc.htm)
----------------------------------------------------
 The MFC CRuntimeClass Structure and the RUNTIME_CLASS Macro 

The MFC _CRuntimeClass_ Structure and the _RUNTIME_CLASS_ Macro
================================================================

In a real MFC program, an instance of the _CRuntimeClass_ structure replaces the static _s_lpszClassName_ data member shown above. This structure has data members for the class name and the object size; it also contains a pointer to a special static function, _CreateObject_, that's supposed to be implemented in the target class. Here's a simplified version of _CRuntimeClass_:

struct CRuntimeClass
{
    char m_lpszClassName[21];
    int m_nObjectSize; // used for memory validation
    CObject\* (\*m_pfnCreateObject)();
    CObject\* CreateObject();
};

> NOTE
> 
> The real MFC _CRuntimeClass_ structure has additional data members and functions that navigate through the class's hierarchy. This navigation feature is not supported by the official C++ RTTI implementation.

This structure supports not only class name retrieval but also dynamic creation. Each class you derive from _CObject_ has a static _CRuntimeClass_ data member, provided that you use the MFC _DECLARE_DYNAMIC_, _DECLARE_DYNCREATE_, or _DECLARE_SERIAL_ macro in the declaration and the corresponding _IMPLEMENT_ macro in the implementation file. The name of the static data member is, by convention, _class<class_name>_. If your class were named _CMyClass_, the _CRuntimeClass_ data member would be named _classCMyClass_.

If you want a pointer to a class's static _CRuntimeClass_ object, you use the MFC _RUNTIME_CLASS_ macro, defined as follows:

#define RUNTIME_CLASS(class_name) (&class_name::class##class_name)

Here's how you use the macro to get the name string from a class name:

ASSERT(RUNTIME_CLASS(CMyClass)->m_lpszClassName == "CMyClass");

If you want the class name string from an object, you call the virtual _CObject::GetRuntimeClass_ function. The function simply returns a pointer to the class's static _CRuntimeClass_ object, just as earlier the _GetClassName_ function returned the name string. Here's the function you'd write for _CMyClass_:

virtual CRuntimeClass\* GetRuntimeClass() 
    const { return &classCMyClass; }

And here's how you'd call it:

ASSERT(pMyObject->GetRuntimeClass()->m_lpszClassName == "CMyClass");
________________________________________________________________________
10.2.3. - [Dynamic Creation](invcpp5/chabd.htm)
----------------------------------------------------
 Dynamic Creation 

Dynamic Creation
================

You've already learned that the _DECLARE_ and _IMPLEMENT_ macros add a static _CRuntimeClass_ object to a class. If you use the _DECLARE_DYNCREATE_ or _DECLARE_SERIAL_ macro (and the corresponding _IMPLEMENT_ macro), you get an additional static member function _CreateObject_ (distinct from _CRuntimeClass::CreateObject_) in your class. Here's an example:

CObject\* CMyClass::CreateObject()
{
    return new CMyClass;
}

Obviously, _CMyClass_ needs a default constructor. This constructor is declared protected in wizard-generated classes that support dynamic creation.

Now look at the code for the _CRuntimeClass::CreateObject_ function:

CObject\* CRuntimeClass::CreateObject()
{
    return (\*m_pfnCreateObject)();
}

This function makes an indirect call to the _CreateObject_ function in the target class. Here's how you would dynamically construct an object of class _CMyClass_:

CRuntimeClass\* pRTC = RUNTIME_CLASS(CMyObject);
CMyClass\* pMyObject = (CMyClass\*)pRTC->CreateObject();

Now you know how document templates work. A document template object has three _CRuntimeClass\*_ data members initialized at construction to point to the static _CRuntimeClass_ data members for the document, frame, and view classes. When _CWinApp::OnFileNew_ is called, the framework calls the _CreateObject_ functions for the three stored pointers.
________________________________________________________________________
10.2.4. - [A Sample Program](invcpp5/chabe.htm)
----------------------------------------------------
 A Sample Program 

A Sample Program
================

Here is the code for a command-line program that dynamically constructs objects of two classes. Note that this isn't real MFC code—the _CObject_ class is a simplified version of the MFC library _CObject_ class. You can find this code in the dyncreat.cpp file in the \vcpp32\appendb folder.

#include <stdio.h>

#define RUNTIME_CLASS(class_name) (&class_name::class##class_name)

class CObject;

struct CRuntimeClass
{
    char m_lpszClassName[21];
    int m_nObjectSize;
    CObject\* (\*m_pfnCreateObject)();
    CObject\* CreateObject();
};

// not a true abstract class because there are no pure 
//  virtual functions, but user can't create CObject objects 
//  because of the protected constructor
class CObject
{
public:
    // not pure because derived classes don't necessarily
    // implement it
    virtual CRuntimeClass\* GetRuntimeClass() const { return NULL; }
        
    // We never construct objects of class CObject, but in MFC we
    //  use this to get class hierarchy information
    static CRuntimeClass classCObject;        // DYNAMIC
     virtual ~CObject() {};  // gotta have it
protected:
    CObject() { printf("CObject constructor\n"); }
};

CRuntimeClass CObject::classCObject = { "CObject", 
    sizeof(CObject), NULL };

CObject\* CRuntimeClass::CreateObject()
{
    return (\*m_pfnCreateObject)(); // indirect function call
}

class CAlpha : public CObject
{
public:
    virtual CRuntimeClass\* GetRuntimeClass() 
        const { return &classCAlpha; }
    static CRuntimeClass classCAlpha;        // DYNAMIC
    static CObject\* CreateObject();          // DYNCREATE
protected:
    CAlpha() { printf("CAlpha constructor\n"); }
};

CRuntimeClass CAlpha::classCAlpha = { "CAlpha", 
    sizeof(CAlpha), CAlpha::CreateObject };

CObject\* CAlpha::CreateObject() // static function
{
    return new CAlpha;    
}

class CBeta : public CObject
{
public:
    virtual CRuntimeClass\* GetRuntimeClass() 
        const { return &classCBeta; }
    static CRuntimeClass classCBeta;         // DYNAMIC
    static CObject\* CreateObject();          // DYNCREATE
protected:
    CBeta() { printf("CBeta constructor\n"); }
};

CRuntimeClass CBeta::classCBeta = { "CBeta", 
    sizeof(CBeta), CBeta::CreateObject };

CObject\* CBeta::CreateObject() // static function
{
    return new CBeta;    
}

int main()
{
    printf("Entering dyncreate main\n");

    CRuntimeClass\* pRTCAlpha = RUNTIME_CLASS(CAlpha);
    CObject\* pObj1 = pRTCAlpha->CreateObject();
    printf("class of pObj1 = %s\n", 
        pObj1->GetRuntimeClass()->m_lpszClassName);

    CRuntimeClass\* pRTCBeta = RUNTIME_CLASS(CBeta);
    CObject\* pObj2 = pRTCBeta->CreateObject();
    printf("class of pObj2 = %s\n", 
        pObj2->GetRuntimeClass()->m_lpszClassName);

    delete pObj1;
    delete pObj2;
    return 0;
}
