
# 🚩 Book Ref

Java 技术书籍大全 PDF (https://github.com/dahuoyzs/javapdf)

	Head First Java(第2版)中文版.pdf
	链接：https://pan.baidu.com/s/1s6OL72c4HWlgDRgWssDoJQ 提取码：e6j1

	Effective Java中文版(第2版).pdf
	链接：https://pan.baidu.com/s/1n7Po4pJM7H__spiVkjJixA 提取码：5jyl

	Effective.Java中文版(第3版).pdf
	链接：https://pan.baidu.com/s/1moNzNVhlTZMRlTUEcNMlxg 提取码：rfc7

	Hadoop权威指南(第2版).pdf
	链接：https://pan.baidu.com/s/1isOm16xKlqOa1BraBhzqdA 提取码：kpu6

	Hadoop权威指南大数据的存储与分析(第4版-升级-修订版).pdf
	链接：https://pan.baidu.com/s/16uJPdsnvHdm6FFmT7xz5vw 提取码：08vg

	Java加密与解密的艺术 梁栋.pdf
	链接：https://pan.baidu.com/s/1WILNurQGoZDPgERo3GrpeQ 提取码：dolc

	Java并发编程实战_带目录.pdf
	链接：https://pan.baidu.com/s/1lnBsCvVJ_p1mTLtMetgvyg 提取码：ha8s

	Java并发编程的艺术.pdf
	链接：https://pan.baidu.com/s/1PK0q5e6Dg-DPgJXrwYyEWw 提取码：rro7

	Java程序性能优化-让你的Java程序更快,更稳定[葛一鸣].pdf
	链接：https://pan.baidu.com/s/1xyxHK9UDshp7Eou1vjob7w 提取码：lk8v

	Java虚拟机规范(Java SE 8版)(带书签完整版).pdf
	链接：https://pan.baidu.com/s/1bF3ypUPbTVAc1TyorNpUjg 提取码：kb2a

	LogBack中文文档.pdf
	链接：https://pan.baidu.com/s/1dB4LysHST-QiKXQyIWUxEA 提取码：sjjq

	MapReduce设计模式（美）.pdf
	链接：https://pan.baidu.com/s/1VnaeO_qCwM9sfEkLcqSkLw 提取码：98gg

	Netty 入门与实战：仿写微信 IM 即时通讯系统.docx
	链接：https://pan.baidu.com/s/1jdrl_ikS8yXwW3jkUyFYkg 提取码：vxwi

	On Java 8(Java编程思想第五版)-英文.pdf
	链接：https://pan.baidu.com/s/182kzwlRF4hfJ6cke_V-iGg 提取码：007z

	Spring Cloud微服务实战.pdf
	链接：https://pan.baidu.com/s/1sjsz_M5bA7rDUFkOTTSQ1g 提取码：z9gd

	Spring技术内幕-深入解析Spring架构与设计原理(第2版)带书签.pdf
	链接：https://pan.baidu.com/s/1UClmWWN4CpQUiu87EkPN9w 提取码：t14m

	Spring源码深度解析.pdf
	链接：https://pan.baidu.com/s/1TXEeIQJlkvMvZ9Z6FR71Aw 提取码：mhex

	《Spring Boot+Vue全栈开发实战》_王松_2018-12-01.pdf
	链接：https://pan.baidu.com/s/1FGUFBuWGnVAqEMMC7_oI5Q 提取码：5823

	《深入理解Spring Cloud与微服务构建》.pdf
	链接：https://pan.baidu.com/s/1evN4tCPDkQCgpKSbfyc67g 提取码：iuds

	写给大忙人看的JavaSE8.pdf
	链接：https://pan.baidu.com/s/19fCS_oYNPpTn9HE-LO5ifA 提取码：5oyt

	深入理解Java虚拟机JVM高级特性与最佳实践第2版(周志朋).pdf
	链接：https://pan.baidu.com/s/1d_5IrA9ZWFBT0GO6tqd3IQ 提取码：uhlr

	深入理解Java虚拟机JVM高级特性与最佳实践第3版(周志朋).pdf
	链接：https://pan.baidu.com/s/1osx-E5P4qB1B465YL_N6_w 提取码：e101

	深入理解java虚拟机第2版(BillVenners著曹晓刚译).pdf
	链接：https://pan.baidu.com/s/1RASOQfqLuJn7sUd0T3Z9mA 提取码：nwca

	HotSpot实战.pdf
	链接：https://pan.baidu.com/s/1-2BpDo95LhvG-O4a_Sup4A 提取码：6fhf

	Java Performance.pdf
	链接：https://pan.baidu.com/s/16zEU6fnsZMnaG5lqyPD8ww 提取码：aw65

	Core Java, Volume II--Advanced-Cay S. Horstmann.pdf
	链接：https://pan.baidu.com/s/1mtomhSVE9FSQfgyc8ulP7A 提取码：4pfb

	数据库
	MySQL必知必会(文字版).pdf
	链接：https://pan.baidu.com/s/15hcVf3b4qHtoiLKmWg6GdA 提取码：eptx

	MySQL性能调优与架构设计.pdf
	链接：https://pan.baidu.com/s/1Y_SGIBwiav11eeTGPiLb7Q 提取码：nbd5

	MySQL技术内幕InnoDB存储引擎(第1版).pdf
	链接：https://pan.baidu.com/s/10sRLE9KDUogBzlTFb-06jg 提取码：nqyw

	MySQL技术内幕InnoDB存储引擎(第2版).pdf
	链接：https://pan.baidu.com/s/1EYIIYvwwfufifH1QWdaPqw 提取码：l0ij

	SQL学习指南(第2版).pdf
	链接：https://pan.baidu.com/s/1iYKE0Vst8o6JIaoHTtdAzg 提取码：fn1f

	深入浅出MySQL++数据库开发、优化与管理维护+第2版+唐汉明.pdf
	链接：https://pan.baidu.com/s/1Kky9OSKlD8PLx6qG-kCyHA 提取码：4mj4

	深入浅出MySQL.pdf
	链接：https://pan.baidu.com/s/1K8mAUW3GADYcHb30uh7x8w 提取码：ivsf

	漫画数据库.pdf
	链接：https://pan.baidu.com/s/1edW10NPRXoPLwQL4t20sMw 提取码：czms

	高性能的MySQL(第3版).pdf
	链接：https://pan.baidu.com/s/1MDT3GzoHdZR7iTCZAFY1gQ 提取码：w8oy

	算法
	Java数据结构和算法（第二版）.pdf
	链接：https://pan.baidu.com/s/1RZZ3uoQlr5rQow119lsG2g 提取码：9bgu

	《设计模式》中文版.pdf
	链接：https://pan.baidu.com/s/1reY7Fnugs_ZSfBcsD4xHhA 提取码：nqyk

	算法导论(第2版).pdf
	链接：https://pan.baidu.com/s/1zCQg1JHLezHMAJnKkSVsVw 提取码：624v

	算法心得：高效算法的奥秘(第2版).pdf
	链接：https://pan.baidu.com/s/1f_udzJiXV49d_JVW11qaGA 提取码：5fci

	网络
	HTTP权威指南（中文版）.pdf
	链接：https://pan.baidu.com/s/1zRAxZ4flGR1kSPk3LpVaxQ 提取码：i1w1

	TCP-IP详解_卷一、二、三.pdf
	链接：https://pan.baidu.com/s/16yJAnKk99pfUkFJb54NjOA 提取码：8ooj

	图解HTTP.pdf
	链接：https://pan.baidu.com/s/1znL-3U7sGXDGWyVioWOmIg 提取码：9fv0

	网络是怎样连接的.pdf
	链接：https://pan.baidu.com/s/19-coudapbvsjXn1hGbxdOg 提取码：84am

	重构与规范
	重构 - 改善既有代码的设计 - 1.pdf
	链接：https://pan.baidu.com/s/17XkDXQF1Png5A8MiT_rrIw 提取码：zevj

	重构-改善既有代码的设计-2-中文.pdf
	链接：https://pan.baidu.com/s/1EMVOK7HwhvD81Q5rjGMFdg 提取码：hohc

	阿里巴巴Android开发手册.pdf
	链接：https://pan.baidu.com/s/10xWRdnEyqe_T6b8BP80vDQ 提取码：7ogc

	阿里巴巴Java开发手册v1.3.0.pdf
	链接：https://pan.baidu.com/s/1MvE7fc12oy2lK6WKBC9LFw 提取码：3vn2

	阿里巴巴Java开发手册v1.3.1.pdf
	链接：https://pan.baidu.com/s/14nuMZlZYMxGlhxwwaVp9vw 提取码：547e

	中间件
	Redis入门指南（第2版）.pdf
	链接：https://pan.baidu.com/s/1LoAJ0ZlKElL2TFuch38Rsw 提取码：pmep

	Redis实战.pdf
	链接：https://pan.baidu.com/s/1_N4y2Jnf1bBfBFNPgcbcyQ 提取码：g3rm

	redis设计与实现第二版.pdf
	链接：https://pan.baidu.com/s/1OuILN3VYmhLdqdaM1AdPTw 提取码：vvwy

	RocketMQ技术内幕.pdf
	链接：https://pan.baidu.com/s/1qTQWHTepEIi0LcSlGsqq-A 提取码：1ivj

	前端
	ES6 编码规范-Tower.pdf
	链接：https://pan.baidu.com/s/1HoPDSFuj-NHwVeCXxC8HCg 提取码：1ayf

	es6手册.md
	链接：https://pan.baidu.com/s/1ZT21nAq8EsaCV25C6nBxxA 提取码：0d4k

	ES6标准入门（第二版）.pdf
	链接：https://pan.baidu.com/s/1HoPDSFuj-NHwVeCXxC8HCg 提取码：1ayf

	JavaScript设计模式与开发实践.pdf
	链接：https://pan.baidu.com/s/1cdVK75H2PQ1BYuAEH14IFQ 提取码：3w18

	JavaScript语言精粹.pdf
	链接：https://pan.baidu.com/s/1s2B5Fx24-oD2NBXs02fGWQ 提取码：a3i5

	React 中文版-v1.1.pdf
	链接：https://pan.baidu.com/s/13aKbirXB1vAG4wU_UoIX2Q 提取码：eabd

	Redux 官方文档中文翻译.pdf
	链接：https://pan.baidu.com/s/1aXLct_zaCnznDCLEPTeIJw 提取码：uea5

	webpack 思维导图.pdf
	链接：https://pan.baidu.com/s/1iSGksVNE2f5GykASw0qzog 提取码：xxcp

	深入浅出ES6.pdf
	链接：https://pan.baidu.com/s/1yh2ak_23lwxcdxOmBKd1Tw 提取码：meno

	安全
	ssh权威指南.pdf
	链接：https://pan.baidu.com/s/1ZBD0adS33pb8MrgCoumi3g 提取码：d6re

	《加密与解密（第4版）》.pdf
	链接：https://pan.baidu.com/s/1UFy9f14cPBZi4Cvk4wkw1A 提取码：0jrw

	《白帽子讲Web安全》(阿里道哥).pdf
	链接：https://pan.baidu.com/s/1w-VHgsYDKbk79QsEIgldAw 提取码：bpeh

	服务器
	docker_practice.pdf
	链接：https://pan.baidu.com/s/1m3dOf9RMXDW5qhw5tBYQww 提取码：z32d

	Docker从入门到实践.pdf
	链接：https://pan.baidu.com/s/12BDqXpbCg2Hpi5i6ABDsoQ 提取码：eyu0

	Docker技术入门与实战+第2版.pdf
	链接：https://pan.baidu.com/s/1CiByHKAJ-0esh-gRb4YQjA 提取码：0j4y

	Introducing Istio Service Mesh for Microservices.pdf
	链接：https://pan.baidu.com/s/1QYzV2tG5p7r6VX2joB9EeA 提取码：74f5

	Jenkins权威指南.2016.pdf
	链接：https://pan.baidu.com/s/17DYVh0JffbKJKRbqVwNqDg 提取码：e832

	Kubernetes in Action.pdf
	链接：https://pan.baidu.com/s/1RaPVVjm1RRpZHFty07iX_A 提取码：1zd0

	kubernetes.pdf
	链接：https://pan.baidu.com/s/1_07VBMa_MoBg4RVDfyj5tA 提取码：0d3f

	LINUX内核完全剖析：基于0.12内核.pdf
	链接：https://pan.baidu.com/s/12pGrrYgKxxjUfrrNKO-ZEw 提取码：sdph

	Maven实战.pdf
	链接：https://pan.baidu.com/s/1h2SxJ8as0rzBhPYZ8Bgkjw 提取码：u25e

	Nginx教程从入门到精通.pdf
	链接：https://pan.baidu.com/s/1CsOf2AQn5s_6RQ10P4T2rQ 提取码：9qzj

	Nginx高性能Web服务器实战教程.pdf
	链接：https://pan.baidu.com/s/1wpQ6qeacrZciBdm2r0sX_w 提取码：m0it

	深入理解计算机系统(原书第三版3).pdf
	链接：https://pan.baidu.com/s/175pmfJQYpn_UmUHKevjMFw 提取码：7y26

	git
	github-roam.pdf
	链接：https://pan.baidu.com/s/1abCW8L00_e5d--nuqWeauw 提取码：hfcr

	git使用指南.pdf
	链接：https://pan.baidu.com/s/1LEp1NJnbwHdVqQpkbgnsCg 提取码：lx4i

	Git版本控制管理第2版(美)罗力格.pdf
	链接：https://pan.baidu.com/s/1wyh5G5OowpJ6jOHKGCseFQ 提取码：6mpq

	从 0 开始学习 GitHub 系列.pdf
	链接：https://pan.baidu.com/s/1q0kWzCGxlzxMMmqhZ6LkPg 提取码：xma6

	AI
	Mathematical Methods for Physics and Engineering.pdf
	链接：https://pan.baidu.com/s/1m1H6rg4ntmGdLZjNMaQq4Q 提取码：zpx9

	The Elements of Statistical Learning.pdf
	链接：https://pan.baidu.com/s/1A1uxEuTq79pfqPa65u_8-g 提取码：6lwh

	凸优化理论.pdf
	链接：https://pan.baidu.com/s/1zvDewKkUri7u4HEunP076A 提取码：vjxm

	同济线性代数教材.pdf
	链接：https://pan.baidu.com/s/1rQy9Tm83-jrcbQBTGf3VeQ 提取码：y2zo

	同济高等数学第六版上下册.pdf
	链接：https://pan.baidu.com/s/12NGyvxQToPKT7EilVshnag 提取码：byqt

	数学之美.pdf
	链接：https://pan.baidu.com/s/16n2g5986MqKitds1733OXw 提取码：dwrb

	数据挖掘与分析（英文）.pdf
	链接：https://pan.baidu.com/s/1z1obinsyF0PKyNnMBJrjaA 提取码：xwsd

	斯坦福大学机器学习复习材料.pdf
	链接：https://pan.baidu.com/s/1Ghz9oH2Es6WYLCTygELlSw 提取码：6lna

	斯坦福大学机器学习课程个人笔记完整版.pdf
	链接：https://pan.baidu.com/s/1ph7v4MJXXH2RAUMdY7pjOw 提取码：42id

	机器学习.pdf
	链接：https://pan.baidu.com/s/1KC8-p9Ed6e-Y-EVrVe6I6g 提取码：j194

	梯度下降.pdf
	链接：https://pan.baidu.com/s/1sW3fngjTwayr_8GqsQ1Mng 提取码：4qm4

	概率论与数理统计同济大学.pdf
	链接：https://pan.baidu.com/s/19Fdq7E9MpmnWpBkixvr53A 提取码：zt0m

	深度学习.pdf
	链接：https://pan.baidu.com/s/1rsraLEqCVFzoqT-UhOrOeA 提取码：12l7

	深度学习Deep Learning.pdf
	链接：https://pan.baidu.com/s/1aU2fclfilmZe6VpYh4BhBQ 提取码：crtg

	神经网络和深度学习.pdf
	链接：https://pan.baidu.com/s/1qZlkqZJQ8HRfBPwH4ovsEA 提取码：l9gs

	经典算法大全.pdf
	链接：https://pan.baidu.com/s/1ONi8y_CxOsIz4rbqbJROdg 提取码：2z75

	统计学习方法李航.pdf
	链接：https://pan.baidu.com/s/1CxGWelEiq9Vq5piBlW5x8g 提取码：m718

	美国人工智能的发展概述.pdf
	链接：https://pan.baidu.com/s/1iN1rXoF7G-19HFf368bxBw 提取码：eeaz

	量化研究手册：数据分析.pdf
	链接：https://pan.baidu.com/s/1LhxNtaq4P1OkRcq3K9pM6g 提取码：q9et

	面向机器智能的TensorFlow实践.pdf
	链接：https://pan.baidu.com/s/1mT3T1R1BfFSyLXtuYpcEfQ 提取码：cbo8



# 🚩 Java Virtual Machine
- [Oracle's OpenJDK](http://openjdk.java.net/)
- [Java Language and Virtual Machine Specifications](https://docs.oracle.com/javase/specs/)
- [Java Platform, Standard Edition 8 Reference Implementations](http://jdk.java.net/java-se-ri/8-MR3)
- [JVM参数配置&&命令工具](https://cloud.tencent.com/developer/article/1512211)
- [JVM系列三:JVM参数设置、分析](https://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html)
- [《深入理解Java虚拟机》读书笔记](https://www.jianshu.com/p/355ae3bcec41)
- [《深入理解Java虚拟机》读书笔记 Class 类文件加载](https://www.jianshu.com/p/4ed041086846)
- [深入理解 Java 虚拟机（全章节完整）](https://blog.csdn.net/TJtulong/article/details/89598598)
- [深入理解JVM（③）JVM运行时数据区域](https://cnblogs.com/jimoer/p/12549269.html)
- [深入理解JVM（③）Java的模块化](https://www.cnblogs.com/jimoer/p/13216782.html)
- [一文看懂分布式事务](https://www.cnblogs.com/jimoer/p/12113286.html)
- [Core Java I Fundamentals & II Advanced Topics](https://horstmann.com/corejava/index.html)

Java 虚拟机规范有多种实现，其中 HotSpot VM 是 Oracle JDK 和 Open JDK 中所带的虚拟机，也是目前使用范围最广的 Java 虚拟机。OpenJDK 作为开源的软件技术，已经普及使用。

Google Android Dalvik VM 不能称作正统的 Java 虚拟机，它没有遵循 Java 虚拟机规范，不能直接执行 Java 的 Class 文件，使用的是寄存器架构而不是 JVM 中常见的栈结构。但是它与 Java 又有千丝万缕的联系，它执行的 dex （Dalvik Executable）文件可以由 Class 文件转化而来，使用 Java 语法编写应用程序，可以直接使用大部分的 Java API 等。

在 Java 发展之初，设计者就曾考虑过并实现了让其他语言运行在 Java 虚拟机之上的可能，发布规范文档也是拆分成 Java 语言规范和 Java 虚拟机规范两部分。时至今日，商业和开源机构已经在 Java 语言之外发展出一大批在 Java 虚拟机上运行的语言，如 Groovy、JRuby、Scala 等。

JVM 对 Java 是无感的，不管什么语言，只要按 JVM 规范实现 class，JVM 就可以解析并运行它。实现语言无关性的基础仍然是虚拟机和字节码存储格式，Java 虚拟机不和任何语言绑定，它只与 Class 文件的二进制文件格式相关联，理论上讲，任一门功能性语言都可以表示为一个能被 Java 虚拟机所接受的有效的 Class 文件。

可以将 JVM 理解为一台实现了高级汇编语言的机器，而且这种高级汇编语言具有 OOP 类对象封装的概念，真的非常高级。

The Java® Virtual Machine Specification 8 文档有 7 个章节，分别讲解了 JVM 各个层面的内容：

- [Chapter1. Introduction](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-1.html)
- [Chapter2. The Structure of the Java Virtual Machine](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html)
- [Chapter3. Compiling for the Java Virtual Machine](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html)
- [Chapter4. The class File Format](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html)
- [Chapter5. Loading, Linking, and Initializing](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html)
- [Chapter6. The Java Virtual Machine Instruction Set](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html)
- [Chapter7. Opcode Mnemonics by Opcode](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-7.html)

前面 5 章，除了开始作了一个介绍，其它基本在讲 JVM 基本原理和结构，JVM 编译原理，还有 JVM 引导，Java 字节码文件的结构和类的加载流程，这些都是非常实用的技术，最后面两章主要是字节码指令的参考文档。

探秘 JVM 最好的方法就是下载开源的 JDK 编译运行，使用 GDB 调试原代码是最直接的学习办法。可以在 OpenJDK 官网下载配套的 The official Reference Implementations for Java SE 8 源代码。


**JMM** - Java Memory Model，Java 内存模型用昌来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各平台达到一致的内存访问抽象模式。JMM 定义了线程和主内存之间的抽象关系，线程之间的共享变量存储在**主内存** main memory 中，每个线程都有一个私有的**本地内存** local memory，本地内存中存储了该线程以读/写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。

Java 虚拟机在执行程序的过程中会把它所管理的内存划分为若干个不同的数据区域，主要分成**线程隔离数据区**和**线程共享数据区**两部分，这些区域有各自的用途，以及创建和销毁的时机，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的穷的和结束而建立和销毁。

![Java 虚拟机运行时数据区域](https://img2020.cnblogs.com/blog/772743/202003/772743-20200322230955320-675886480.png)

JVM 运行时线程共享数据区域：

- 程序计数器 Program Counter Register

	程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。由于 Java 虚拟机的多线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

	如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的额虚拟机字节码指令地址；

	如果正在执行的是本地方法 Native Method，这个技术器值则应为空 Undefined。

- JVM 虚拟机栈 Java Virtual Machine Stack

	与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的线程内存模型：每个方法被执行的时候，Java 虚拟机都会同步创建一个栈帧 Stack Frame 用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈道出栈的过程。

	局部变量表存放了编译期可知的各种 Java 虚拟机基本数据类型，如 boolean、byte、char、short、int、float、long、double、reference 和 returnAddress 类型。其中对象引用并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置。返回地址 returnAddress 指向了一条字节码指令的地址。

	这些数据类型在局部变量表中存储空间以局部变量槽 Slot 来表示，其中 64bit 的 long 和 double 类型的数据会占用两个变量槽，其余的数据类型只占用一个。而虚拟机真正使用多大的内存空间来实现一个变量槽，是完全由具体的虚拟机实现自行决定的，譬如按照 1 个变量槽占用 32 个比特、64个比特，或者更多。

	在《Java虚拟机规范》中对这个内存区域规定了两类一次状况：

	- 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；
	- 如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存，就会抛出outofMemoryError异常。

- 本地方法栈 Native Method Stacks

	与虚拟机栈所发挥的作用是非常相似的，区别在于虚拟机栈是虚拟机执行 Java 方法也就是字节码服务，而本地方法栈则是为虚拟机栈使用到的本地方法服务，HotSpot 虚拟机直接把本地方法栈与虚拟机栈合二为一了。并且与虚拟机栈一样，本地方法栈也会在栈深度移除或者栈扩展失败时分别抛出 StackOverflowError 和 OutOfMemoryError 异常。

线程共享数据区部分：

- Java Heap

	Java 堆是虚拟机所管理的内存中最大的一块，并且是被所有线程共享的一个块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java 世界里几乎所有的对象实例都在这里分配内存。

	如果从分配内存的角度看，所有线程共享的 Java 堆中可以划分出多个线程私有的分配缓冲区 Thread Local Allocation Buffer 以提升对象分配时的效率。根据 Java 虚拟机规范，Java 对可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。有些情况，例如处理大对象，典型的数组对象，多数虚拟机实现考虑到实现简单，存储高效等因素，很可能会要求连续的内存空间。

	Java 堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的 Java 虚拟机都是按照可扩展来实现的，通过参数执行参数 -Xmn 和 -Xns 设定。如果在 Java 堆中没有内存完成实例分配，并且堆也无法再扩展时，Java 虚拟机将会抛出 OutOfMemoryError 异常。

- Method Area

	方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

	说到方法区，不得不提一些**永久代** Permanent Generation 这个概念，尤其是在 JDK 8 以前，许多 Java 程序员都习惯在 HotSpot 虚拟机上开发，部署程序，都更愿意把方法区称为 Permanent Generation，或者将两者混为一谈。但两者是不等价的，因为 HotSpot 虚拟机设计团队选择把收集器的分代设计扩展至方法区，所以使用永久代来实现方法区。这样使得垃圾收集器能够像管理 Java 堆一样管理这部分内存，永久代是 JDK 8 之前的 HotSpot 虚拟机特有的机制，其他虚拟机并不存在这个概念，例如 JRockit、J9。

	在后续的发展中，HotSpot 团队意识到永久代的设计并不是一个好主意，所以为了 HotSpot 虚拟机未来更好的发展，在 JDK 6 HotSpot 团队就有放弃永久代，逐步改为采用本地内存 Native Memory 来实现方法区的计划，到了 JDK 7 HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地内存中实现的元空间 Meta space 来代替，把 JDK 中永久代还剩余的内容全部移到元空间中，主要是类型信息。

此外，**运行时常量池** Run-Time Constant Pool 是方法区的一部，Class 文件中除了又类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表 Constant Pool Table，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后放到方法区的运行时常量中。

运行时常量池相对于 Class 文件常量池的一个重要特征是具备动态性，Java 语言并不要求常量一定只有编译期才能产生，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是 String 类的 intern() 方法。

运行时常量池无法申请到内存时也是会抛出 OutOfMemoryError 异常。

另外，**直接内存** Direct Memory 这一概念并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范的一部分。但是这部分内存也被频繁地使用，也可能导致 OutOfMenmoryError 异常出现，所以也是要熟悉的。

在配置虚拟机内存的时候，除了要考虑本机的物理内存外，还需要将直接内存考虑到。经常遇到有些开发者在设置内存时忽略了直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMenoryError 异常。


在 JDK 1.4 中新加入了 NIO（New Input/Output）类，引入了一种基于通道 Channel 与缓冲区 Buffer 的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。

JDK 9 引入模块化系统 Java Platform Module System 是一次重要升级，除了像之前 JAR 包那样充当代码的容器之外，还包括：

- 依赖其他模块的列表。
- 导出的包列表，即其他模块可以使用的列表。
- 开放的包列表，即其他模块可反射访问模块的列表。
- 使用的服务列表。
- 提供服务的实现列表。
- 模块化系统

可配置的封装隔离机制解决了原来类路径上跨文件的 public 类的可访问性的问题。使用模块化，意味着 public 并非所有地方代码都可以访问，未导出和未开放的类是不能够被外部使用。

需要先声明导出包的路径，然后在使用时导入模块：

	module example {
	    exports com.demos.test;
	}

	module exampleTwo {
	    requires example;
	}


## ⚡ GC 垃圾回收
- [Java Garbage Collection handbook](https://plumbr.io/java-garbage-collection-handbook)
- [深入理解JVM（③）经典的垃圾收集器](https://www.cnblogs.com/jimoer/p/13126614.html)
- [深入理解JVM（③）判断对象是否还健在？](https://www.cnblogs.com/jimoer/p/13055672.html)
- [深入理解JVM（③）各种垃圾收集算法](https://www.cnblogs.com/jimoer/p/13096642.html)

Java 内建自动垃圾回收机制，这是比 C++ 高级的功能，不用自行清理也不会以引用内存泄露，但是需要知道 GC 工作原理由于垃圾对象的判定、垃圾对象的收集两个步骤。

Java 对象主要存放在 Java Heap，垃圾收集器 Garbage Collection 在回收堆内存前，第一件事情就是要确定这些对象之中哪些还存活着，哪些已经死去不被引用了。

- 判定垃圾对象
	- 引用计数算法 Programm Counter
	- 可达性分析法 Reachability Analysis
- 垃圾回收算法
	- 标记清除算法 
	- 复制算法
	- 标记整理算法
	- 分代收集算法

在对象中添加一个引用计数器，每有一个地方引用它时，计数器值就加一；当引用失效是，计数器值就减一；任何时刻计数器为零的对象就是不可以能再被使用的对象。

引用计数算法的原理简单，判定效率也很高。市面上也确实有一些技术使用的此类算法来判定对象是否存活，像使用 ActionScript 3 的 FlashPlayer、Python 语言等。但是在主流的 Java 虚拟机里面都没有选用引用计算法来管理内存，主要是使用此算法时，必须要配合大量的额外处理才能保证正确的工作，例如要解决对象之间的相互循环引用的问题。

引用计数算法在对象中添加一个引用计数器，当有地方引用这个对象的时候，引用计数器的值就加 1，当引用失效的时候，计数器的值就减 1。但 Java 虚拟机中没有使用这种算法，这是由于如果堆内的对象之间相互引用，就始终不会发生计数器 -1，那么就不会回收。

测试：两个对象相互引用

	import java.lang.*;

	public class GcCounterTest 
	{
	    private Object instance;
	    
	    // 占据 20M 内存
	    public GcCounterTest() {
	        byte[] m = new byte[20 * 1024 *1024];
	    }

	    public void finalize(){
	        System.out.println("Destructor...");
	    }
	    
	    public static void main(String[] args) {
	        GcCounterTest c1 = new GcCounterTest();
	        GcCounterTest c2 = new GcCounterTest();
	        
	        c1.instance = c2;
	        c2.instance = c1;
	        // 断掉引用
	        c1 = null;
	        c2 = null;
	        
	        // 假设在这行发生 GC，对象内存是否能被回收？
	        System.gc();
	    }
	}

在后面发生 GC 的时候，如果按照引用计数算法，这两个对象虽然都被设置成了 null，但是两个对象相互引用，所以按程序计算器的方式它们都不会被回收，但是真正的实际运行结果是，这两个对象都被回收了，这也说明 HotSpot 虚拟机并不是用引用计数法来进行的内存管理。

Java 没有提供像 C++ 那样的析构函数，因为不用程序员支管理内存，但是提供了一个在对象清理时执行的 **void finalize()** 方法，因此你如果确实需要析构的话就可以实现这样一个方法。


当前主流的商用程序语言 Java、 C# 等都是通过**可达性分析** Reachability Analysis 算法来判断对象是否存活的。这个算法的基本思路就是通过一一系列称为 GC Roots 的对象的起始节点集，从这些节点开始根据引用关系向下搜索，搜索走过的的路径称为**引用链** Reference Chain，如果某个对象到 GC Roots 间没有任何引用链相连，或者从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的。

程序中，固定作为 GC Roots 对象的包括以下几种：

- 在虚拟机栈中引用的对象，譬如各个现场被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
- 在方法区中类静态属性引用的对象，譬如 Java 类的引用类型静态变量。
- 在方法区中常量引用的对象，譬如字符串常量池 String Table 里的引用。
- 在本地方法栈中 JNI 即通常所说的 Native 方法引用的对象。
- Java 虚拟机内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象 NullPointException、OutOfMemoryError 等，还有系统类加载器。
- 所有被同步锁 synchronized 关键字持有的对象。
- 反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。

除了这些固定的 GC Roots 集合以外，根据垃圾收集器以及当前回收的区域不同，还会有其他对象临时性加入，如果只针对 Java 堆中某一块儿区域发起垃圾收集时，例如只针对年轻代的垃圾收集，必须考虑到当前区域内的对象是否有被其他区域的对象所引用，这个时候就需要把这些关联区域的对象一并加入 GC Roots 集合中，来保证可达性分析的正确性。

引用关系的处理是垃圾回收机制中很重要的一环，JDK 1.2 版之后对引用的概念进行了扩充，将引用分为四种类型：

- 强引用 Strongly Reference

	强引用是最传统的引用的定义，指引用复制，即类似以下这种：

		Object obj = new Object()

	无论在任何情况下，只要强引用关系还存在，垃圾收集器就不会回收掉被引用的对象。

- 软引用 Soft Reference 描述一些还有用，但非必须的对象。在系统发生内存溢出前，会先对软引用对象进行第二次回收，如果回收后还没有足够的内存，才会抛出内存溢出的异常。
- 弱引用 Weak Reference 描述那些非必须的对象，但是它的强度比软引用更弱一些，弱引用的对象，只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
- 虚引用 Phantom Reference 也称为幽灵引用或幻影引用，它是最弱的一种引用关系。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。


清除垃圾回收内存时，有多种处理方法。

**标记清除算法**先标记出要回收的对象，再去清除，但会有效率问题和空间问题。标记的空间被清除后，会造成我的内存中出现越来越多的不连续空间，当要分配一个大对象的时候，在进行寻址的要花费很多时间，可能会再一次触发垃圾回收。

复制算法将按对象建立使用的时间长度进行区分，针对不同的年代进行不同算法的垃圾回收，针对新生代选择复制算法，对老年代选择标记整理算法。

JVM 内存分配原则：

- 优先分配到 Eden
- 大对象直接分配到老年代
- 长期存活的对象分配到老年代
- 空间分配担保
- 动态对象的年龄判断

对象内存分区：

	- 堆：
		- 新生代 new generation
			- Eden 伊甸园
			- Survivor From 存活区
			- Survivor To 存活区
		- 老年代 Tenured Generation
		- Metaspace

**复制算法**是将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，浪费较大。

现在的商业虚拟机都采用这种收集算法来回收新生代，IBM 公司的专门研究表明，新生代中的对象 98% 是“朝生夕死”的，所以并不需要按照 1:1 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性的复制到另外一块 Survivor。最后清理掉 Eden 和刚才用过的 Survivor 空间。HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1，也就是每次新生代中可用内存为整个新生代容量的 90%（80%+10%），只有 10% 的内存会被“浪费”。

使用两个 Survivor 区主要是为了解决内存碎片化和效率问题，如果只有一个 Survivor 区，每触发一次 Minor GC 都会有数据从 Eden 放到 Survivor，一直这样循环下去。注意的是，Survivor 区也会进行垃圾回收，这样就会出现内存碎片化问题，后果就是导致堆中可能没有足够大的连续空间存放一个大对象，影响程序性能。如果有两块 Survivor 就能将剩余对象集中到其中一块 Survivor 上，有效地避免碎片问题。

对于老年代，回收的垃圾较少时，如果采用复制算法，则效率较低。**标记整理算法**的标记操作和“标记-清除”算法一致，后续操作不只是直接清理对象，而是在清理无用对象完成后让所有存活的对象都向一端移动，并更新引用其对象的指针。


垃圾收集器：

- Serial 收集器，单线程垃圾收集器、最基本、发展最悠久。
- ParNew 可多线程收集垃圾，收集新生代，使用收集算法。
- Parallel 多线程收集垃圾，收集新生代，使用收集算法。Parallel 收集器更关注系统的吞吐量，可以通过参数来打开自适应调节策略。
- CMS - Concurrent Mark Sweep 标记-清除算法收集器，用于老年代，常与 ParNew 协同工作。
- G1 - Garbage First 垃圾收集器是当今垃圾回收技术最前沿的成果之一，并行与并发能力，早在 JDK 7 就已加入 JVM 的收集器大家庭中，成为 HotSpot 重点发展的垃圾回收技术。

单线程垃圾收集器、最基本、发展最悠久。它的单线程的意义并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。偶尔用在桌面应用中。

Java 中 Stop-The-World 机制简称 STW，是在执行垃圾收集算法时，Java 应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）全局暂停现象。全局停顿，所有 Java 代码停止，native 代码可以执行，但不能与 JVM 交互，这些现象多半是由于 gc 引起。

查看 JVM 的 GC 信息，可以在运行程序时加入以下参数：

	>java -verbose:gc -XX:+PrintGCDetails -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 GcCounterTest
	[GC (Allocation Failure) [DefNew: 836K->588K(9216K), 0.0016158 secs][Tenured: 0K->587K(10240K), 0.0018080 secs] 836K->587K(19456K), [Metaspace: 1727K->1727K(4480K)], 0.0043166 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
	[GC (Allocation Failure) [DefNew: 0K->0K(9216K), 0.0005927 secs][Tenured: 21067K->587K(30724K), 0.0016413 secs] 21067K->587K(39940K), [Metaspace: 1727K->1727K(4480K)], 0.0032806 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
	[Full GC (System.gc()) [Tenured: 21067K->587K(30724K), 0.0016370 secs] 21230K->587K(39940K), [Metaspace: 1727K->1727K(4480K)], 0.0024321 secs] [Times: user=0.02 sys=0.00, real=0.00 secs]
	Destructor...

	Heap
	 def new generation   total 9216K, used 328K [0x05000000, 0x05a00000, 0x05a00000)
	  eden space 8192K,   4% used [0x05000000, 0x05052048, 0x05800000)
	  from space 1024K,   0% used [0x05800000, 0x05800000, 0x05900000)
	  to   space 1024K,   0% usedDestructor... [0x05900000, 0x05900000, 0x05a00000)
	 tenured generation
	 total 28676K, used 587K [0x05a00000, 0x07601000, 0x15000000)
	   the space 28676K,   2% used [0x05a00000, 0x05a92ce8, 0x05a92e00, 0x07601000)
	 Metaspace       used 1732K, capacity 2242K, committed 2368K, reserved 4480K


上面打印的 JVM GC 日志中，有两次 GC (Allocation Failure)，这是正常情况：

- Full GC 表明进行了一次垃圾回收，前面没有 Full 修饰，表明这是一次 Minor GC。
- Allocation Failure： 表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。
- ParNew 表明本次 GC 发生在年轻代并且使用的是 ParNew 垃圾收集器。

日志中，836K->588K(9216K) 这样的表达是指 GC 前该内存区域使用容量 -> GC 后该内存区域使用容量，括号内的是该内存区域总容量，后面跟着 GC 耗时，单位是分别是 KB 和秒。看 Full GC (System.gc()) 这里表示前面测试代码中使用 API 触发的一次 GC，老年代区 Tenured 的内存由 21067K->587K 即将占据 20M 内存的 byte[] 字节数组释放了。

常见 GC 方式：

- Minor GC/Young GC：新生代 GC，指发生在新生代的垃圾收集动作，Minor GC 非常频繁，一般回收速度也比较快。
- Old GC/Major GC：收集整个 Old gen 的 GC，只有 CMS 模式这么称呼，Major GC 的速度一般比 Minor GC 多 10 倍以上。
- Full GC：收集整个堆，包括 Young gen、Old gen、Perm gen（如果存在的话）等所有部分的模式。
- Mixed GC：收集整个 young gen 以及部分 old gen 的 GC，只有 G1 模式这么称呼。

对于复制算法来说，当年轻代 Eden 区域满的时候会触发一次 Minor GC，将 Eden 和 Survivor From 区的对象复制到另外一块 Survivor To。如果某个对象存活的时间超过 Minor GC 次数超过 -XX:+MaxTenuringThreshold 指定值，会直接进入老年代。

Full GC 用于清理整个堆空间，它的触发条件主要有以下几种：

- 显式调用 System.gc 方法。
- 方法区空间不足，JDK 8 及之后不会有这种情况。
- 老年代空间不足，引起 Full GC，又细分以下几种：

	- 大对象直接进入老年代引起，由 -XX:PretenureSizeThreshold 参数定义
	- Minor GC 时，经历  Minor GC 次数超过 -XX:MaxTenuringThreashold 指定次数仍健在的对象进入老年代。
	- Minor GC 时，动态对象年龄判定机制会将对象提前转移老年代，年龄从小到大进行次数累加，当加入某个年龄段后，累加和超过 survivor * TargetSurvivorRatio 的时候，从这个年龄段往上的年龄的对象进入老年代。
	- Minor GC 时，Eden 和 From Space 区向 To Space 区复制时，大于 To Space 区可用内存，会直接把对象转移到老年代


JVM 的空间分配担保机制可能会触发 Full GC，在进行 Minor GC 之前，JVM 空间担保分配机制可能会触发发一次 Full GC。

空间担保分配是指在发生 Minor GC 之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。 如果大于，则此次 Minor GC 是安全的。如果小于，则虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。

如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一次 Minor GC，但这次 Minor GC 依然是有风险的，失败后会重新发起一次 Full GC，否则改为直接进行一次 Full GC。

JDK 8 HotSpot 虚拟机为什么要取消永久代？并且新增了一个叫元空间 Metaspace 的区域，对应在 JVM 规范中的方法区，主要存放一些 class 和元数据的信息。区别在于，元空间使用的并不是 JVM 中的内存，而是使用本地内存。而这么做的原因大致有以下几点：

- 字符串存在永久代中，容易出现性能问题和内存溢出。
- 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
- 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
- Oracle 可能会将 HotSpot 与 JRockit 合二为一。


GC 性能方面的考虑主要有 2 个方面的指标：吞吐量 throughput，和暂停 pause 时间。即工作时间不算 gc 的时间占总的时间比，和 gc 发生时 app 对外显示的无法响应时间。

The Young Generation 新生代对于 app 流畅性运行影响的因素，young generation 越大，minor collection 越少；但是在固定 heap size 情况下，更大的 young generation 就意味着小的 tenured generation，就意味着更多的 major collection，major collection 会引发 minor collection。

GC 时的 Stop the World(STW) 是大家最大的敌人。但可能很多人还不清楚，除了 GC，JVM 下还会发生停顿现象。



常用 JVM 启动参数：

|     参数名称    |                        说明                        |
|-----------------|----------------------------------------------------|
| -Xms            | 初始堆大小，物理内存的1/64(<1GB)                   |
| -Xmx            | 最大堆大小，物理内存的1/4(<1GB)                    |
| -Xmn            | 年轻代大小，此处的大小是（eden+ 2 survivor space)  |
| -XX:PermSize    | 设置持久代初始值，物理内存的1/64                   |
| -XX:MaxPermSize | 设置持久代最大值 物理内存的1/4                     |
| -Xss            | 每个线程的堆栈大小，JDK1.5以后为1M                 |
| -XX:NewRatio    | 年轻代(包括 Eden 和两个 Survivor 区)与年老代的比值 |

- **-XX：ParallelGCThreads** 参数限制 ParNew 的线程数，默认使用的线程数和 CPU 数相同。该收集器是 Serial 收集器的多线程版本，采用复制算法回收内存，期间会停止其他工作线程，即 Stop The World。
- **-verbose:gc -XX:+PrintGCDetails** 表示输出虚拟机中 GC 的详细情况。默认使用 Parallel 收集器（服务器），Serial 收集器（客户端），服务器和客户端可以通过 java -version 查看。
- **-XX:+UseSerialGC** 设置收集器。
- **-Xms20M -Xmx20M -Xmn10M** 分别设置初始堆大小和最大堆内存大小都是 20M，新生代大小为 10M，如果设置的内容不够用就会触发 OutOfMemoryError 异常。
- **-XX:SurvivorRatio=8** 设置 eden 与 survuvor 的比值大小 8:1，JVM 优先把对象放入 Eden 区，当 Eden 区放不下了后（2 * 3 = 6M），通过分配担保机制放入老年代 6M（Minor GC），再把最后一个 4M 放入新生代。
- **-XX:PretenureSizeThreshold=6M** 设置大文件大小，大对象直接分配到老年代，研究认为大对象不是朝生夕死的，如果放在新生代，则需要不断移动，性能较差。
- **-XX:MaxTenuringThreshold** 最大年龄，默认为 15，即经过这么多次 GC 还没有被清理掉的新生代码对象会晋升为长期存活对象，分配到老年代。
- **-XX:+HandlePromotionFailure=true** 开启空间分配担保失败允许，取前面每一次回收晋升到老年代对象容量的平均值大小作为经验值，与老年代的剩余空间进行比较，决定是否 Full GC 来让老年代腾出更多空间。


性能优化四个命令：

- **jps**：Java process status 查看 Java 进程状态
- **jstat**：显示本地或者远程虚拟机垃圾回收，例如：jstat -gcutil $pid 1000 5
- **jmap**：查看JVM堆中对象详细占用情况，例如：jmap -histo [pid]
- **jstack**：用于生成虚拟机当前线程快照，jstack -l [pid]

JDK 自带可视化监控工具 JConsole，是一种基于 JMX 的可视化监视、管理工具可进行内存管理、线程管理、查看死锁等。直接执行 jconsole 命令即可，源代码在 tools.jar 包中。




## ⚡ NIO - Non-blocking I/O
- [Java NIO 浅析](https://zhuanlan.zhihu.com/p/23488863)
- [Java1.4 从 BIO 模型发展到 NIO 模型](https://www.cnblogs.com/kendoziyu/p/java-develop-from-bio-to-nio.html)
- [Java NIO 对象分类](https://www.cnblogs.com/jimoer/p/11575610.html)

Java 1.4 引入 java.nio 包，使用这些 API 可以实现一个 BIO 模型，也可以实现 NIO 模型。

**NIO** - Non-blocking I/O 也称为 New I/O，是 Java 一种同步非阻塞 I/O 模型，也是 I/O 多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O 处理问题的有效方式。

先来认识几个概念：

- Blocking 阻塞是指当有任务在执行时，会发出一个请求操作，如果该请求操作需要的条件不满足的话，那么就会一直等待，直到条件满足后，才继续执行后面的其他工作。
- Non-Blocking 非阻塞是指当有任务在执行时，会发出一个请求操作，如果该请求操作需要的条件不满足的话，会立即返回一个标志信息告知条件不满足，而不会一直在等待下去。
- Synchronous I/O 同步 IO 是指一个线程在执行 IO 操作时，该线程在操作完成前，是会被阻塞的。
- Asynchronous I/O 异步 IO 是指一个线程在执行 IO 操作时，该线程并不会被阻塞。 

从计算机硬件体系结构理解，CPU 的中断系统提供了这个一个能力，程序在等待 I/O 数据进入阻塞状态，当数据到来时触发一个 I/O 中断告诉 CPU 可以继续执行处于阻塞状态的程序。阻塞期间，CPU 不执行线程的任何其它代码，这也就是为何阻塞状太是节省 CPU 资源的。

根据不同的应用场合，同步性和阻塞性可以组合到一起：

- **同步阻塞**，是最常用的一种用法，使用也是最简单的，但是 I/O 性能一般很差，CPU 大部分处于空闲状态，即不消耗 CPU 时间，但会损失程序性能。
- **同步非阻塞**，提升 I/O 性能的常用手段，就是将 I/O 的阻塞改为非阻塞方式，尤其在网络 I/O 是长连接同时传输数据也不很多的情况下，提升性能非常有效，但消耗 CPU 时间，需要一个平衡。
- **异步阻塞**，这种方式在分布式数据库中经常用到，例如，在一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，还有任意份记录会写到其他机器上，这些备份记录通常都采用异步阻塞的方式写 I/O。异步阻塞对网络I/O能够提升效率，尤其像上面这种同时写多份相同数据的情况。
- **异步非阻塞**，这种组合方式用起来比较复杂，只有在一些非常复杂的分布式情况下用，集群之间的消息同步机制一般用这种 I/O 组合方式。它适合同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大却非常频繁的情况。这种网络 I/O 用此方式性能达到最高。

《Unix 网络编程》指明五种 I/O 模型，而 Java NIO 使用的是**多路 I/O 复用模型**，其它四种介绍如下：

- **阻塞 I/O 模型**，最常见的一种，一个 read 操作分两个阶段，先等待数据准备就绪，再将数据拷贝到调用的线程中。阻塞是发生在第一个阶段的，数据准备好之前会一直阻塞用户线程，当数据就绪后再将数据拷贝到线程中，并返回结果给用户线程。
- **非阻塞 I/O 模型**，当应用程序发起一个 read操作时，并不会阻塞，而是立刻会收到一个结果，指示数据是准备好了没有。判断返回结果是一个错误状态，就知道数据还没有准备好，可以再次执行 read 操作直到系统将数据拷贝到了线程的内存中，读取出来。
- **信号驱动 I/O 模型**，让内核在数据报准备就绪时发送 SIGIO 信号通知用户线程。首先开启套接字的信号驱动式 I/O 功能，并通过 sigaction 系统调用安装一个信号处理函数。该系统调用将立即返回，进程继续工作，也就是说没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个 SIGIO 信号。我们随后就可以在信号处理函数中调用 recvfrom 读取数据报，并通知用户进程数据已经准备好，可以读取了。
- **异步 I/O 模型**，当用户线程发起 read 操作时，告知内核启动读取数据操作，并让内核在整个操作完成后通知程序，包括将数据从内核复制到程序自己的缓冲区。这样在内核执行读取数据操作时，用户线程可以继续执行，当接收到内核在整个操作都完成的信号时，就可以直接去使用数据了。


随着网络设计模式的兴起，Reactor 和 Proactor 事件处理模式应运而生，来介绍一下这两种高性能 I/O 设计模式：

- Reactor 响应式模式

	- 应用程序在 Reactor 中注册 Ready for Read 读就绪事件和相关联的事件处理器
	- Reactor 阻塞等待内核事件通知
	- Reactor 收到通知，然后分发可读写事件到用户事件处理函数
	- 用户读取数据，并处理数据
	- 事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。

- Proactor 主动模式

	- 应用程序初始化一个异步读取操作，然后注册相应的事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于 Reactor 的关键。
	- 事件分离器等待读取操作完成事件
	- 在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作，并将读取的内容放入用户传递过来的缓存区中。这也是区别于 Reactor 的一点，所以 Proactor 应用程序需要传递缓存区。
	- 事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。

Reactor 模式要求主线程只作为 I/O 处理单元，只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程。除此之外，主线程不做任何其他实质性的工作。 读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。而 Proactor 模式将所有 I/O 操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。

异步 I/O 模型就是使用的 Proactor 模式，Java NIO 多路 I/O 复用模型中使用 Reactor 模式。


所以多路复用 I/O 模型和非阻塞 I/O 有类似之处，但是多路复用 I/O 模型的效率是比非阻塞 I/O 模型要高的，因为在非阻塞 I/O 中，不断的询问 scoket 状态的是通过用户线程去进行的，而多路复用 I/O 模型，轮询每个 scoket 状态是内核进行处理的，结合硬件底层实现效率远比用户线程实现要高得多的，因此多路复用 I/O 模型比较适合高并发应用中使用。

不过此模型也是存在问题的，由于多路复用 I/O 模型是通过轮询的方式来检测是否有事件到达，并对到达的事件逐一响应，一旦事件响应体很大或是响应事件数量过多，就会消耗大量的时间去处理事件，从而影响整个过程的及时性。为了应对这种情况 Linux 系统提供了 epoll 接口，但是除了 Linux 其他操作系统对 epoll 接口的支持又有很多差异，所以虽然 epoll 解决了事件检测的时效性问题，但是在跨平台能力上却并不能得到很好的支持。
 

Java NIO 使用的多路 I/O 复用模型，有三个基础概念：

- Channel 通道

	Channel 可以理解为互通的管道，和 Java IO 各种 Stream，如 InputStream、OutputStream 类似，只不过 Channel 是双向的，而 Stream 是单向的。通道的作用是将数据移入或移出道各种 I/O 源，即可读又可写。

	Channel 类层次结构相当复杂，有多个接口和许多可选操作，常用的也就几个：

	- FileChannel 可以对文件进行读和写；
	- DatagramChannel 可以以 UDP 的协议来进行数据读写；
	- SocketChannel 以 TCP 的协议来对网络两端进行读写；
	- ServerSocketChanel 能够监听客户端 TCP 连接，并为每个连接创建一个新的 SocketChannel 来进行数据读写。

	通过 selector.select() 去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此多路复用 I/O 模型也会阻塞用户线程，只不过线程是被 select() 函数阻塞的而不是被 scoket 阻塞的。

- Buffer 缓冲区

	Buffer 是一个高效的数据容器，在 NIO 中所有的数据操作都必须经过缓冲区，这点是和 BIO 不同的，BIO是直接将数据写到 Stream 对象中的。因为 Stream 对象的设计是按顺序一个字节一个字节的传送数据。虽然出于性能考虑，也可以传递字节数组，但是基本概念都是一个字节一个字节的传递数据。通道与之不同之处在于，通道会传送缓冲区的数据块，而且通道的基本概念就是按照一个数据块一个数据块的去读和写。所以也可以将缓冲区理解为一个字节数组，专门用来存储以及准备好出入通道的字节。

	无论是客户端发送和接收数据，还是服务端接收和相应数据，都是从缓冲区中进行数据操作的。

- Selector 选择器

	Selector 是 Java NIO 中最重要的一部分，它用单线程来轮询处理注册的 Channel，一旦哪个 Channel 的数据准备就绪了，就可以进行处理了。


Buffer 缓冲区的常用属性介绍

在 Java 中除了 boolean 外，所有的基本数据类型都有特定的 Buffer 子类，ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer。网络程序几乎只会使用 ByteBuffer，但程序偶尔也会使用其他类型来取代 ByteBuffer。

除了数据列表外，每个缓冲区都记录了信息的 4 个关键部分。无论是何种类型，都有相同的方法来获取和设置这些值：

- 位置 position

	缓冲区中将读取或写入的下一个位置，0 开始计，最大值等于缓冲区的大小。

		public final int position();
		public final Buffer position(int newPosition);

- 容量 capacity

	缓冲区可以保存的最大数目，容量值在创建缓冲区时设置，此后不能改变。

		public final int capacity();

- 限度 limit

	缓冲区中可访问数据的末尾位置，只要不改变限度，就无法读/写超过这个位置的数据，即使缓冲区有更大的容量也没有用。

		public final int limit();
		public final Buffer limit(int newLimit);

- 标记 mark

	缓冲区中客户端指定的索引，通过 mark() 可以将标记设置为当前位置。调用 reset() 可以将当前位置设置为所标识的位置。

		public final Buffer mark() ;
		public final Buffer reset();

	如果将位置设置为低于现有标记，则丢弃这个标记。

与读取 InputStream 不同，读取缓冲区实际上不会以任何方式改变缓冲区中的数据。只可能向前或向后设置位置，从而可以从缓冲区中某个特定位置开始读取。类似的程序可以调整限度，从而控制将要读取的数据的末尾。


Selector 使用介绍

首先要先向 Selector 中注册 Channel，然后调用它的 select() 方法，这个方法会一直阻塞到某个注册的 Channel 中的事件准备就绪。一旦 select() 方法返回，线程就可以处理这些事件了，比如新的连接进入，数据接收等。

Selector 类并没有注册新通道的方法，register() 方法在 SelectableChannel 类中声明，它实现了 Channel 接口，它支持将 Channel 注册到 Selector 中。

	public abstract SelectionKey register(Selector sel, int ops, Object att) throws ClosedChannelException;
	public final SelectionKey register(Selector sel, int ops) throws ClosedChannelException;

第一个参数代表通道要向哪个选择器注册，第二个参数是 SelectionKey 类中的一个命名常量，标识所注册的操作：

	SelectionKey.OP_READ;
	SelectionKey.OP_WRITE;
	SelectionKey.OP_CONNECT;
	SelectionKey.OP_ACCEPT;

当一个通道需要在同一个选择器中关注多个操作，只需要用户位操作符组合这些常量即可。

	channel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);

第三个参数是可选的，代表键的附件。这个参数通常用户存储链接状态，例如要实现一个 Web 服务器，可能要附加一个 FileInputStream 或 FileChannel，这个流或通道连接到服务器提供给客户端的本地文件。

例子，复制文件的读写操作大致过程：

	public static void copyFileByNIO(String src,String dst) throws IOException {

	    //声明源文件和目标文件
	    RandomAccessFile aFile = new RandomAccessFile(src, "rw");
	    RandomAccessFile bFile = new RandomAccessFile(dst, "rw");

	    //获得传输通道channel
	    FileChannel inChannel = aFile.getChannel();
	    FileChannel outChannel = bFile.getChannel();
	    //获得容器buffer
	    ByteBuffer buffer= ByteBuffer.allocate(1024);
	    while(true){
	        //判断是否读完文件
	        int eof =inChannel.read(buffer);
	        if(eof==-1){
	            break;
	        }
	        //重设一下buffer的position=0，limit=position
	        buffer.flip();
	        //开始写
	        outChannel.write(buffer);
	        //写完要重置buffer，重设position=0,limit=capacity
	        buffer.clear();
	    }
	    inChannel.close();
	    outChannel.close();
	    aFile.close();
	    bFile.close();
	} 


## ⚡ NIO & Netty
- [Netty in Action](https://www.w3cschool.cn/essential_netty_in_action/)
- [基于 Netty 实现 RpcKids 框架](https://zhuanlan.zhihu.com/p/35720383)
- [基于 Netty 实现 MvcKids 框架](https://zhuanlan.zhihu.com/p/36064672)

旧式 BIO - Blocking I/O 模型在客户端与服务端建立连接之后，服务端就会立即分配一个线程，但是服务端又需要阻塞线程来等待读取客户端发送数据。这样就需要不断创建新的线程应对不断增加的服务端请求，而创建线程是需要消耗服务器性能的。那么可不可以等客户端数据到达后再分配线程进行处理呢？Selector 以及基于事件处理的 NIO 模型应运而生。

BIO 方式一个连接一个线程去处理非常消耗 CPU 资源，特别是对于 HTTP 这种短连接协议，就算加入了线程池也不能完美解决 BIO 的缺陷，所以可以用 NIO 进行服务器的优化，NIO 基于 I/O 多路复用实现单线程处理大量连接，但是编写起来比较复杂，可以选择 Netty 实现。

JBOSS 提供的 Netty 是一个 Java 开源框架。Netty 提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。也就是说，Netty 是一个基于 NIO 的客户、服务器端编程框架，使用 Netty 可以确保你快速和简单的开发出一个网络应用，例如，实现了某种协议的客户，服务端应用。Netty 相当简化和流线化了网络应用的编程开发过程，例如，TCP/UDP 的 socket 服务开发。

Netty 有哪些新增特性？

- 能够更简单地处理大容量数据流；
- 能够更简单地处理协议编码和单元测试；
- I/O 超时和 idle 状态检测；
- 应用程序的关闭更简单，更安全；
- 更可靠的 OutOfMemoryError 预防。

Netty 是优秀的 Java 网络应用程序框架，它提供了对 Java NIO API 的封装，屏蔽了繁杂的编程细节，让开发者可以更加专注于业务逻辑的实现。很多中间件都是基于 Netty 来实现的，你可以用来实现一个 Web 容器，也能写一个游戏服务器。学习 Netty 能够让你更加熟悉网络编程的核心。

在网络发展初期，需要花很多时间来学习 socket 的复杂，寻址等等，在 C socket 库上进行编码，并需要在不同的操作系统上做不同的处理。Java 早期版本(1995-2002)介绍了足够的面向对象的糖衣来隐藏一些复杂性，但实现复杂的客户端-服务器协议仍然需要大量的样板代码，和进行大量的监视才能确保他们是对的。这些早期的 Java API（java.net）只能通过原生的 socket 库来支持所谓的“blocking（阻塞）”的功能。

- ServerSocket 创建并监听端口的连接请求
- accept() 调用阻塞，直到一个连接被建立了。返回一个新的 Socket 用来处理 客户端和服务端的交互
- 流被创建用于处理 socket 的输入和输出数据。BufferedReader 读取从字符输入流里面的本文。PrintWriter 打印格式化展示的对象读到本文输出流
- 处理循环开始 readLine() 阻塞，读取字符串直到最后是换行或者输入终止。
- 如果客户端发送的是“Done”处理循环退出
- 执行方法处理请求，返回服务器的响应
- 响应发回客户端
- 处理循环继续


"New"还是"Nonblocking"?

在 2002 年 Java 1.4 引入了非阻塞 API 在 java.nio 包。NIO 最初是为 New Input/Output 的缩写，然而，Java 的 API 已经存在足够长的时间，它不再是新的。现在普遍使用的缩写来表示 Nonblocking I/O。另一方面，一般阻塞 I/O 为 OIO 或 Old Input/Output。

NIO 很重要的一个组成部分是 Selector，它最终决定已注册的 socket 哪一组可以准备执行 I/O 操作。Selector 通知目标线程进行处理，并且可以同时处理多个并发连接。一个 Selector 由一个线程通常处理，但具体实施可以使用多个线程。因此，每次读或写操作执行能立即检查完成。总体而言，该模型提供了比 阻塞 I/O 模型 更好的资源使用，因为可以用较少的线程处理更多连接，这意味着更少的开销在内存和上下文切换上。当没有 I/O 处理时，线程可以被重定向到其他任务上。

如果你要直接使用这些 Java API 构建的 NIO 建立你的应用程序，只是这样做正确和安全是无法保证的。实现可靠和可扩展的 event-processing（事件处理器）来处理和调度数据并保证尽可能有效地，这是一个繁琐和容易出错的任务，最好留给专家 - Netty。

Netty 基本构成：

- Channel 是 NIO 基本的结构。它代表了一个用于连接到实体如硬件设备、文件、网络套接字或程序组件，能够执行一个或多个不同的 I/O 操作的开放连接。
- callback 回调是一个简单的方法，可以在某个合适的时间调用以通知客户。这种技术被广泛使用在各种编程的情况下，最常见的方法之一通知给其他人操作已完成。
- Future 提供了另外一种通知应用操作已经完成的方式。这个对象作为一个异步操作结果的占位符,它将在将来的某个时候完成并提供结果。
- Event 和 Handler，Netty 使用不同的事件来通知我们更改的状态或操作的状态。这使我们能够根据发生的事件触发适当的行为。

Netty 的异步编程模型是建立在 future 和 callback 的概念上的，将所有这些元素整合，协同为自己的程序设计提供了强大的力量。

比如，拦截操作和转换入站或出站数据只需要您提供回调或利用 future 操作返回的，这使得链操作简单、高效，促进编写可重用的、通用的代码。一个 Netty 的设计的主要目标是促进“关注点分离”:你的业务逻辑从网络基础设施应用程序中分离。

Netty 通过触发事件从应用程序中抽象出 Selector，从而避免手写调度代码。EventLoop 分配给每个 Channel 来处理所有的事件，包括：

- 注册感兴趣的事件
- 调度事件到 ChannelHandler
- 安排进一步行动

该 EventLoop 本身是由只有一个线程驱动，它给一个 Channel 处理所有的 I/O 事件，并且在 EventLoop 的生命周期内不会改变。这个简单而强大的线程模型消除你可能对你的 ChannelHandler 同步的任何关注，这样你就可以专注于提供正确的回调逻辑来执行。该 API 是简单和紧凑。






## ⚡ class File Format
- [Chapter 4. The class File Format](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html)

虚拟机规范并没有限定指明二进制字节流要从一个 Class 文件获取，或者说没有限定从哪里获取、怎样获取。这种开放使得 Java 在很多领域得到充分运用，例如：

- 从ZIP包中读取，这很常见，成为JAR，EAR，WAR格式的基础
- 从网络中获取，最典型的应用就是Applet
- 运行时计算生成，最典型的是动态代理技术，java.lang.reflect.Proxy，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成后缀为 $Proxy 的代理类
- 有其他文件生成，过时的 JSP 就会生成对应的 Class 类


JVM 加载的 Class 文件结构包括以下内容：

- 魔数：确定这个文件能否被 Java 虚拟机接受，值为 0xCAFFBABE（咖啡宝贝？）
- 版本号：Class 文件的版本号
- 常量池：Class 文件的资源仓库
- 访问标志：用于识别一些类或者接口层次的访问信息，是类还是接口？是否为 public？
- 索引集合：包括类索引、父类索引、接口索引
- 字段表集合：描述接口或类中声明的变量，但不包括方法内部的局部变量
- 方法表集合：代码在方法表中的属性集合“Code”属性
- 属性表集合：字段表、方法表都可以携带自己的属性表，以用于描述某些场景专用信息

ClassFile Structure：

	ClassFile {
	    u4             magic;
	    u2             minor_version;
	    u2             major_version;
	    u2             constant_pool_count;
	    cp_info        constant_pool[constant_pool_count-1];
	    u2             access_flags;
	    u2             this_class;
	    u2             super_class;
	    u2             interfaces_count;
	    u2             interfaces[interfaces_count];
	    u2             fields_count;
	    field_info     fields[fields_count];
	    u2             methods_count;
	    method_info    methods[methods_count];
	    u2             attributes_count;
	    attribute_info attributes[attributes_count];
	}


Table 4.1-A. access_flags and property modifiers

|   Flag Name    | Value  |                                   Interpretation                                  |
|----------------|--------|-----------------------------------------------------------------------------------|
| ACC_PUBLIC     | 0x0001 | Declared public; may be accessed from outside its package.                        |
| ACC_FINAL      | 0x0010 | Declared final; no subclasses allowed.                                            |
| ACC_SUPER      | 0x0020 | Treat superclass methods specially when invoked by the invokespecial instruction. |
| ACC_INTERFACE  | 0x0200 | Is an interface, not a class.                                                     |
| ACC_ABSTRACT   | 0x0400 | Declared abstract; must not be instantiated.                                      |
| ACC_SYNTHETIC  | 0x1000 | Declared synthetic; not present in the source code.                               |
| ACC_ANNOTATION | 0x2000 | Declared as an annotation type.                                                   |
| ACC_ENUM       | 0x4000 | Declared as an enum type.                                                         |


Table 4.3-A. Interpretation of field descriptors

| FieldType term |    Type   |                                   Interpretation                                  |
|----------------|-----------|-----------------------------------------------------------------------------------|
| B              | byte      | signed byte                                                                       |
| C              | char      | Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16 |
| D              | double    | double-precision floating-point value                                             |
| F              | float     | single-precision floating-point value                                             |
| I              | int       | integer                                                                           |
| J              | long      | long integer                                                                      |
| L ClassName ;  | reference | an instance of class ClassName                                                    |
| S              | short     | signed short                                                                      |
| Z              | boolean   | true or false                                                                     |
| [              | reference | one array dimension                                                               |


在 HotSpot 虚拟机中，Java 对象内存布局可以分为 3 块区域：

- 对象头 Header

	- 第一部分，哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等；
	- 第二部分，类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例；

- 实例数据 Instance Data

	- 实例数据部分是对象真正存储的有效信息，即在代码中定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的。

- 对齐填充 Padding

	- 对齐填充：HotSpot 虚拟机要求对象的起始地址必须是 8 字节的整数倍，换句话说，就是对象的大小必须是 8 字节的整数倍。



## ⚡ Java CLI
- https://www.oracle.com/java/technologies/javase-downloads.html
- [The Java Tutorials Bundle](https://www.oracle.com/java/technologies/javase/java-tutorial-downloads.html)
- [The Java™ Tutorials](https://docs.oracle.com/javase/tutorial/index.html)
- [JDI - Java Debug Interface](https://www.ibm.com/developerworks/cn/java/j-lo-jdi)
- [JavaTM Platform Debugger Architecture (JPDA)](https://docs.oracle.com/javase/6/docs/technotes/guides/jpda/index.html)
- [Spring Boot引起的“堆外内存泄漏”排查及经验总结](https://tech.meituan.com/2019/01/03/spring-boot-native-memory-leak.html)

对给定的一个 Java 源代码文件，可以在命令行进行编译生成 .class 类文件，然后再执行：

	javac demo.java
	java demo

Java 应用项目可以打包成一个 jar，当然你必须指定一个拥有 main 函数的主类作为 jar 包的程序入口。

具体的方法是修改 jar 包内目录 META-INF/MANIFEST.MF 文件。

比如 main 函数在 test.someClassName 类上定义，我们就只要在 MANIFEST.MF 里面添加如下一句话：

	Main-Class: test.someClassName

然后我们可以在控制台输入以下命令执行：

	java -jar test.jar

项目需要引用其他第三方的 jar 包，在 eclipse 会将放在项目的 lib 子目录下 jar 包一并打包，但是用 java -jar 执行时需要依赖外部包，就需要告知 Java 引用 jar 包所在。

运行时将其加入 -classpath 参数中指定目录，简写为 -cp：

	java -classpath some.jar -jar test.jar

因为使用 classpath 指定的 jar 由 AppClassloader 来加载，Java 命令加了 -jar 参数，AppClassloader 就只关注 test.jar 范围内的 class 了，classpath 参数失效。

程序依赖 DLL 文件可以，可以在 java.library.path 指定路径，path_to_dll 为动态链接库文件所在目录，或直接在代码中硬编码：

	java -Djava.library.path=<path_to_dll> <main_class>
	System.setProperty("java.library.path", "/path/to/library");


方法一、使用 Bootstrap Classloader 来加载这些类

	-Xbootclasspath: 完全取代系统 Java classpath，最好不用。
	-Xbootclasspath/a: 在系统 class 加载后加载，推荐使用。
	-Xbootclasspath/p: 在系统 class 加载前加载，注意使用，和系统类冲突就不好了。

多个 jar 包使用 ; 或 : 分隔，根据 Windows/Unix 系统选用：

	java -Xbootclasspath/a:some.jar;some2.jar; -jar test.jar
	java -Dloader.path=/path/to/lib -jar test.jar


方法二、使用 Extension Classloader 来加载

你可以把需要加载的 jar 都扔到 %JRE_HOME%/lib/ext 下面，这个目录下的 jar 包会在 Bootstrap Classloader 工作完后，由 Extension Classloader 来加载。非常方便，非常省心。:)

命令行使用 -cp 参考只能指定一个固定 jar 包，不能用通配符，多个包要一个个写。通常情况 jar 都在同一目录，可以使用 -Djava.ext.dirs 参数指定包目录，配置多个目录使用冒号分隔（Windows下使用分号）。

	java -Djava.ext.dirs="libs\;%JAVA_HOME%\jre\lib\ext"

方法三、还是用 AppClassloader 来加载，不过不需要 classpath 参数

我们在 MANIFEST.MF 中添加如下代码，多个 jar 包用空格分隔：

	Class-Path: lib/some.jar
	Class-Path: lib/some.jar lib/some2.jar

lib 是和 test.jar 同目录的一个子目录，test.jar 要引用的 some.jar 包就在这里面。

另：如果 META-INF/INDEX.LIST 文件存在，可能会使 Class-Path 配置失效。INDEX.LIST 是 Jar 打包工具打包时生成的索引文件，删除对运行不产生影响。

方法四、自定义 Classloader 来加载

这种方法是终极解决方案，基本上那些知名 Java 应用都会在代码中使用 Classloader，如 Tomcat、JBoss 等等。


如果源代码是包的形式组织，多个源文件就要分别依次进行编译，-d 指定输出目录：

	>javac -d . src\com\coding\HelloBean.java
	>javac -d . src\com\coding\SpringDemo.java
	>javac -d . src\com\coding\HelloListener.java

或者，使用 sourcelist.txt 编译多个 Java 文件的目的，将要编译的文件列表：

	src\com\coding\HelloBean.java
	src\com\coding\SpringDemo.java
	src\com\coding\HelloListener.java

命令行运行：

	javac -d bin -sourcepath src -classpath bin @sourcelist.txt

编译时，依赖库以或类目录使用 -cp 指定，多个包用冒号或者分号隔开： 

    javac -d bin -encoding utf-8 -cp .:lib/fastjson-1.2.37.jar -g -sourcepath src @src/sources.txt
 
    jar -cvfm demo.jar MANIFEST.MF *  

注意 MANIFEST.MF 文件定义主类，参考内容如下：

	Manifest-Version: 1.0  
	Main-Class: com.travel.app.AppMainEntry
	Class-Path: bin/fastjson-1.2.37.jar bin/json-20170516.jar bin/org.restlet.ext.json-2.3.10.jar bin/org.restlet-2.3.10.jar




## ⚡ Reflection 反射机制
- Class (Java SE 9 & JDK 9 ) - https://docs.oracle.com/javase/9/docs/api/java/lang/Class.html
- Field (Java Platform SE 7 ) - https://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Field.html
- ByteArrayOutputStream (Java SE 9 & JDK 9 ) - https://docs.oracle.com/javase/9/docs/api/java/io/ByteArrayOutputStream.html
- URL (Java SE 9 & JDK 9 ) - https://docs.oracle.com/javase/9/docs/api/java/net/URL.html
- Class热替换与卸载 - http://www.importnew.com/22462.html
- 深入探讨 Java 类加载器 - https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html
- 反射机制（Reflection） – http://blog.qiji.tech/archives/4374
- 深入理解Java类型信息(Class对象)与反射机制 - https://blog.csdn.net/javazejian/article/details/70768369
- 深入理解Java类加载器(一)：Java类加载原理解析 - https://blog.csdn.net/justloveyou_/article/details/72217806
- 类加载器与 Class.getResourceAsStream 问题解决 https://blog.csdn.net/w1196726224/article/details/54428493
- http://tomcat.apache.org/tomcat-7.0-doc/class-loader-howto.html

认识 Class 对象之前，先来了解一个概念，RTTI - Run-Time Type Identification **运行时类型识别**，对于这个词一直是 C++ 中的概念，至于 Java RTTI 的说法则是源于《Thinking in Java》一书，其作用是在运行时识别一个对象的类型和类的信息，分两种：

- 传统的 RTTI，它假定我们在编译期已知道了所有类型，在没有反射机制创建和使用类对象时，一般都是编译期已确定其类型，如 new 对象时该类必须已定义好。
- 反射机制方式 RTTI，它允许我们在运行时发现和使用类型的信息。

在 Java 中用来表示运行时类型信息的对应类就是 Class 类也对应源代码编译后生成的类文件，Class 类也是一个实实在在的类，存在于 java.lang 包中。

Class 类也是类的一种，但是特别地 Class 类用来描述使用 class 关键字定义的类，这些描述信息用于在运行时获取类定义内容，Class 类的对象作用是运行时提供或获得某个对象的类型信息。编写好的类在编译后都会产生一个 Class 对象，表示的是创建的类的类型信息，而且这个 Class 对象保存在同名字节码文件中。比如创建一个 Shapes 类，编译后就会创建其包含 Shapes 类相关类型信息的 Class 对象，并保存在 Shapes.class 字节码文件中。每

个通过关键字 class 标识的类，在内存中有且只有一个与之对应的 Class 对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个 Class 对象。Class 类只存私有构造函数，因此对应 Class 对象只能有 JVM 创建和加载。

在运行期间，如果我们要产生某个类的对象，虚拟机 JVM 会检查该类型的 Class 对象是否已被加载。如果没有被加载，JVM 会根据类的名称找到 .class 文件并加载它。一旦某个类型的 Class 对象已被加载到内存，就可以用它来产生该类型的所有对象。

装载类的过程非常简单：查找类所在位置，并将找到的 Java 类的字节码装入内存，在内存中生成对应的 Class 对象。JVM 并不止有一个类装载器，事实上，如果你愿意的话，你可以让 JVM 拥有无数个类装载器。

类装载器自身也是一个类，它也需要被装载到内存中来，那么这些类装载器由谁来装载呢，总得有个根吧？确实存在这样的根，Bootstrap ClassLoader 就是。

类装载器把一个类装入 Java 虚拟机中要经过装载、链接和初始化三个步骤，其中链接又可以细分成校验、准备和解析三步，除了解析外，其它步骤是严格按照顺序完成的：

- 装载：查找和导入类或接口的二进制数据；
- 链接：执行下面的校验、准备和解析步骤，其中解析步骤是可以选择的；
- 校验：检查导入类或接口的二进制数据的正确性；
- 准备：给类的静态变量分配并初始化存储空间；
- 解析：将符号引用转成直接引用；
- 初始化：激活类的静态变量的初始化Java代码和静态Java代码块。

**Class.forName(String name)** 方法调用的是 Class.forName(String name, boolean initialize, ClassLoader loader)，装载的类会被初始化。

**ClassLoader.loadClass(String name)** 方法调用的是 ClassLoader.loadClass((String name, boolean resolve)，resolve=false 表示被装载后不进行链接。


通过反射方法实例化对象及修改私有成员为公有成员

	import java.lang.reflect.*;

	class Gum {
		private int weight = 0;
		static { System.out.println("Loading Gum"); }
		public Gum(){ }
		public Gum(int i){ weight = i; }
		public String greeting(){ return "Hi!"; }
	}

	public class coding {
		public static void print(Object obj) {
			System.out.println(obj);
		}
		@SuppressWarnings("unchecked")
		public static void main(String[] args) {
			try {
				Class clz = Class.forName("Gum");
				// Class clazz = Gum.class;
				// Constructor[] cts = clz.getConstructors();
				// for ( Constructor c:cts ) {
				// 	print("Contructor: "+c.getName​());
				// }
				// Constructor constructor = clz.getConstructor();
				// Object object = clz.newInstance(); 
				Constructor constructor = clz.getConstructor(int.class);
				Object object = constructor.newInstance(0);

				Method method = clz.getMethod("greeting");
				String msg = (String)method.invoke(object);
				print(msg);

				Field field = clz.getDeclaredField("weight");
				field.setAccessible(true);
				print("get private member:"+field.get(object));

				Class<?> class1 = Class.forName("Gum");
				String name = class1.getClassLoader().getClass().getName();
				print("class loader is " + name);

			} catch(Exception e) {
				e.printStackTrace();
			}
		}
	}

使用类反射方法 Class.forName() 载入类，返回值是对应类的 Class 对象，也可以通过对象实例的 **getClass()** 方法获取，这是基础对象类 Object 定义的方法，字面常量的方式获取 Class 对象如 Object.class。如果没有定义相应的类构造函数，getConstructor() 会引发 NoSuchMethod 异常。


Field.setAccessible(true) 并不是将方法的访问权限改成了public，而是取消java的权限控制检查。即使是public成员，其accessible 属性默认也是false，即需要进行权限检查。

与 Java 反射相关的类如下：

	Class 类        代表类的实体，在运行的Java应用程序中表示类和接口
	Field 类        代表类的成员变量（成员变量也称为类的属性）
	Method类        代表类的方法
	Constructor类   代表类的构造方法


注意，getClassLoader() 方法，如果类是通过 Bootstrap class loader 加载的则会返回 null，即使用类似以下的命令运行：

	java -Xbootclasspath/p:demos LoadClassDemo

如果对象是原类型 primitive type 或是 void 也会返回 null。




## ⚡ ClassLoader 类的加载流程
- [Chapter 5. Loading, Linking, and Initializing](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html)
- [loadClass()的研究](https://www.cnblogs.com/guweiwei/p/6534418.html)
- [深入理解JVM（③）虚拟机的类加载器（双亲委派模型）](https://www.cnblogs.com/jimoer/p/13200244.html)
- [深入理解JVM（③）HotSpot 虚拟机对象探秘](https://www.cnblogs.com/jimoer/p/13034193.html)
- [写一个 Java 热加载](https://zhuanlan.zhihu.com/p/90404828)
- [能不能自定义一个类叫 java.lang.System？](https://zhuanlan.zhihu.com/p/77366251)

JVM 动态加载类主要有三个步骤：

- Loading
- Linking
- Initializing

JVM 启动后，首先就是处理最底层的加载器，Bootstrap Class Loader，这个 C++ 实现的加载器是所有 Java 类加载的根基。

JVM 技术规范的 Chapter 5. Loading, Linking, and Initializing 目录可以很好地解析类文件的加载流程：

	5.1. The Run-Time Constant Pool
	5.2. Java Virtual Machine Startup
	5.3. Creation and Loading
	5.3.1. Loading Using the Bootstrap Class Loader
	5.3.2. Loading Using a User-defined Class Loader
	5.3.3. Creating Array Classes
	5.3.4. Loading Constraints
	5.3.5. Deriving a Class from a class File Representation
	5.4. Linking
	5.4.1. Verification
	5.4.2. Preparation
	5.4.3. Resolution
	5.4.3.1. Class and Interface Resolution
	5.4.3.2. Field Resolution
	5.4.3.3. Method Resolution
	5.4.3.4. Interface Method Resolution
	5.4.3.5. Method Type and Method Handle Resolution
	5.4.3.6. Call Site Specifier Resolution
	5.4.4. Access Control
	5.4.5. Overriding
	5.5. Initialization
	5.6. Binding Native Method Implementations
	5.7. Java Virtual Machine Exit


参考《深入理解 Java 虚拟机》，类加载器有几个重要的特性：

- 每个类加载器都有自己的预定义的搜索范围，用来加载 class 文件； 
- 每个类和加载它的 ClassLoader 共同确定了这个类的唯一性，同一个类由不同加载器加载，那么 JVM 认为是不同的类；
- 双亲委派模型。

在 JDK 9 之前的 Java 应用都是由这三类加载器互相配合来完成加载的，如果有自定义的类加载器，会先执行自定义的类加载器。各种的类加载器之间的层次关系被称为类加载器的双亲委派模型 Parents Delegation Model。

**双亲委派模型**是指所有的类加载器都是有层级结构的，类加载器本身也有一个父级加载器 Parent ClassLoader，除了启动类加载器 Bootstrap ClassLoader。当一个类加载器接收到一个类加载请求时，首先将这个请求委派给它的父加载器去加载，所以每个类加载请求最终都会传递到顶层的启动类加载器，如果父加载器无法加载时，子类加载器才会去尝试自己去加载。

双亲指的就是 Extension CLassLoader 和 Bootstrap ClassLoader 两个底层加载器。

而绝大多数 Java 应用都会用到如下 3 中系统提供的类加载器：

- 启动类加载器 Bootstrap/Primordial/NULL ClassLoader：顶层的类加载器，没有父类加载器。负责加载 /lib 目录下的，或则被 -Xbootclasspath 参数所指定路径中的，并被 JVM 识别的（仅按文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录也不会被加载）类库加载到虚拟机内存中。所有被 Bootstrap classloader 加载的类，它的 Class.getClassLoader 方法返回的都是 null，所以也称作 NULL ClassLoader。

- 扩展类加载器 Extension CLassLoader：由 sun.misc.Launcher$ExtClassLoader 实现，负责加载 <JAVA_HOME>/lib/ext 目录下，或被 `java.ext.dirs` 系统变量所指定的目录下的所有类库；

- 应用程序类加载器 Application/System ClassLoader：由 sun.misc.Launcher$AppClassLoader 实现。它是 ClassLoader.getSystemClassLoader() 方法的默认返回值，所以也称为系统类加载器。它负责加载 classpath 下所指定的类库，如果应用程序没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

通过双亲委派模型就实现了类加载器的三个特性：

- 委派 delegation：子类加载器委派给父类加载器加载；
- 可见性 visibility：子类加载器可访问父类加载器加载的类，父类不能访问子类加载器加载的类；
- 唯一性 uniqueness：可保证每个类只被加载一次，比如 Object 类是被 Bootstrap ClassLoader 加载的，因为有了双亲委派模型，所有的 Object 类加载请求都委派到了 Bootstrap ClassLoader，所以保证了只被加载一次。

从 JVM 虚拟机实现的角度来看，只存在两种不同的类加载器实现：

- 启动类加载器 Bootstrap ClassLoader 是虚拟机自身的一部分；
- 所有其他的类加载器，独立于虚拟机外部，都继承自抽象类 java.lang.ClassLoader。


双亲委派模型的源码其实非常简洁，先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的 loadeClass() 方法，若父加载器为空则默认使用启动类加载器作为父加载器。父加载器加载失败抛出 ClassNotFoundException 异常后，才会调用自己的 findClass 方法尝试进行加载。

类加载与 sun.misc.Launcher 相关，来看 OpenJDK 提供的抽象类 **ClassLoader** 源码如下：

	protected Class<?> loadClass(String name, boolean resolve)
	    throws ClassNotFoundException
	{
	    synchronized (getClassLoadingLock(name)) {
	        // 首先，检查请求的类是否已经被加载过了
	        Class<?> c = findLoadedClass(name);
	        if (c == null) {
	            long t0 = System.nanoTime();
	            try {
	                if (parent != null) {
	                    c = parent.loadClass(name, false);
	                } else {
	                    c = findBootstrapClassOrNull(name);
	                }
	            } catch (ClassNotFoundException e) {
	                // 如果父类加载器抛出 ClassNotFoundException
	                // 说明父类加载器无法完成加载请求
	            }

	            if (c == null) {
	                // 在父类加载器仍然无法加载时
	                // 再调用本身的 findClass 方法来进行类加载
	                long t1 = System.nanoTime();
	                c = findClass(name);

	                // this is the defining class loader; record the stats
	                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
	                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
	                sun.misc.PerfCounter.getFindClasses().increment();
	            }
	        }
	        if (resolve) {
	            resolveClass(c);
	        }
	        return c;
	    }
	}

双亲委派模型并不是一个具体强制性约束的模型，虽然在 Java 大部分的类加载器都遵循这个模型，但也有例外的情况，直到 JDK9 模块化为止，主要出现过 3 次较大规模规则破坏的情况。

第一次被破坏，其实发生在双亲委派模型出现之前，由于双亲委派模型在 JDK 1.2 之后才被引入，但是类加载器的概念和抽象类 java.lang.ClassLoader 则在 Java 的第一个版本中就已经存在了。为了向前兼容，只能在 JDK 1.2 之后的 java.lang.ClassLoader 中添加一个新的 protected findClass() 方法，并引导用户编写类的加载逻辑时尽可能去重写这个方法，而不是在 loadClass() 中编写代码。

第二次破坏是因为自身的一些局限性导致的，双亲委派模型很好的解决了各个类加载器协作时基础类型的一致性问题，即越基础的类由越上层的加载器进行加载。

但是如果基础的类需要调用下面的用户代码时该怎么办呢？Java 设计团队用了一个不太优雅的方案，引入了一个名叫线程上下文的类加载器 Thread Context ClassLodar。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoader() 方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。

像 JNDI、JDBC、JCE、JAXB、JBI 等都是用的这种类型加载器实现的功能。最常见的 Tomcat 中就用到了线程上下文的类加载器。

第三次破坏，是为了实现热部署、模块化。在更新了一部分代码后，不需要停机重启，只需要将类加载器和类都替换掉就可以了，典型的就是 OSGi 的模块化热部署。

OSGi 实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块 Bundle 都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 幻境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当受到类加载请求时，OSGi 将按照下面的顺序进行类搜索：

- 将 java.＊ 开头的类委派给父类加载器加载。
- 否则，将委派列表名单内的类委派给父类加载器加载。
- 否则，将 Import 列表中的类委派给 Export 这个类的 Bundle 的类加载器加载。
- 否则，查找当前 Bundle ClassPath，使用自己的类加载器加载。
- 否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载。
- 否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载。
- 否则，类加载器失败。


能不能自定义一个类叫 java.lang.System？能不能自定义一个类叫 java.lang.String？这一类问题就是考察对 Java 加载字节码流程的理解。由于 JVM 安全机制，试图加载命名空间以 java.lang 开头的类，会引发 SecurityException 异常。

	java.lang.SecurityException: Prohibited package name: java.lang
	        at java.lang.ClassLoader.preDefineClass(ClassLoader.java:662)
	        at java.lang.ClassLoader.defineClass(ClassLoader.java:761)
	        at java.lang.ClassLoader.defineClass(ClassLoader.java:642)

java.lang.System 这些类是 Bootstrap 加载器加载的，就算自己重写，也总是使用 Java 系统提供的 System，自己写的 System 类根本没有机会得到加载。虽然可以打破双亲委派机制，但是自定义的类加载器最终也会在父类的 final defineClass() 方法执行时被拦截下来，得到相同异常，自定义的 classLoader 不可能加载到以 java 开头的类的。

    /* Determine protection domain, and check that:
        - not define java.* class,
        - signer of this class matches signers for the rest of the classes in
          package.
    */
    private ProtectionDomain preDefineClass(String name, ProtectionDomain pd)
    {
        if (!checkName(name))
            throw new NoClassDefFoundError("IllegalName: " + name);

        if ((name != null) && name.startsWith("java.")) {
            throw new SecurityException
                ("Prohibited package name: " +
                 name.substring(0, name.lastIndexOf('.')));
        }
        if (pd == null) {
            pd = defaultDomain;
        }

        if (name != null) checkCerts(name, pd.getCodeSource());

        return pd;
    }

ClassLoader 有两个方法供重写实现自定义加载器，一般优先实现 findClass()，因为系统提供的加载器实现了 loadClass() 逻辑，在其加载失败时就会调用 findClass()，并且系统并实现的这个方法只是简单地抛出 ClassNotFoundException，目的就是让使用者自行实现：

	 * <p> The network class loader subclass must define the methods {@link
	 * #findClass <tt>findClass</tt>} and <tt>loadClassData</tt> to load a class
	 * from the network.  Once it has downloaded the bytes that make up the class,
	 * it should use the method {@link #defineClass <tt>defineClass</tt>} to
	 * create a class instance.  A sample implementation is:
	 *
	 * <blockquote><pre>
	 *     class NetworkClassLoader extends ClassLoader {
	 *         String host;
	 *         int port;
	 *
	 *         public Class findClass(String name) {
	 *             byte[] b = loadClassData(name);
	 *             return defineClass(name, b, 0, b.length);
	 *         }
	 *
	 *         private byte[] loadClassData(String name) {
	 *             // load the class data from the connection
	 *             &nbsp;.&nbsp;.&nbsp;.
	 *         }
	 *     }
	 * </pre></blockquote>


回到前面 defineClass() 方法，参考其实现，它的核心是调用了一个私有的 native 方法，外部类是不可访问的，想到反射的用途了吗，就算是 private 方法，用一个 setAccessible(true) 就可以访问，但是可以可惜有人试过，但是结果还是失败的，因为 native 方法还是抛出同样的异常。

    protected final Class<?> defineClass(String name, byte[] b, int off, int len,
                                         ProtectionDomain protectionDomain)
        throws ClassFormatError
    {
        protectionDomain = preDefineClass(name, protectionDomain);
        String source = defineClassSourceLocation(protectionDomain);
        Class<?> c = defineClass1(name, b, off, len, protectionDomain, source);
        postDefineClass(c, protectionDomain);
        return c;
    }

    private native Class<?> defineClass1(String name, byte[] b, int off, int len,
                                         ProtectionDomain pd, String source);

所以，目前来看，所有基于 Java 的技术是不能可去定制 java.lang.System 这样的类的，首先 API 的安全检查这一关就过不了。

但是，JDK 9 后引入了模块化，这个功能带来了转机，有人试验通过了，参考操作流程总结：

- Java 11 不能直接编译自定义的 java.lang 这个包，因为已经存在 java.base 这个模块里；
- 可以使用 Java 8 编译，再由 Java 11 反射方法来加载，注意，fineClass1 方法在 Java 11 中变成了静态方法；
- Java 11 platfromClassLoader 可以成功的把自定义的 java.lang.System 加载到内存当中并实例化对象；

虽然，历经曲折才将自定义的 java.lang.System 加载进来，但是不能像内部提供的 System 类一样使用，只能通过反射的方式执行。这也许没有多大意义，只不过求解的过程对 Java 虚拟机的加载器和类加载流程的深入理解才是最有价值的。


另一例测试代码：

	class SingleTon {
	    private static SingleTon singleTon = new SingleTon();
	    public static int count1;
	    public static int count2 = 0;
		{
		    System.out.println("Dynamic code block");
		}
		static {
		    System.out.println("static code block");
		}
	    private SingleTon() {
		    System.out.println("constructor");
	        count1++;
	        count2++;
	    }

	    public static SingleTon getInstance() {
	        return singleTon;
	    }
	}

	public class Test {
	    public static void main(String[] args) {
	        SingleTon singleTon = SingleTon.getInstance();
	        System.out.println("count1=" + singleTon.count1);
	        System.out.println("count2=" + singleTon.count2);
	    }
	}


分析:静态成员初始化动作在构造函数执行后，动态代码块 --> 静态代码块 --> 构造器 按顺序执行。

- SingleTon singleTon = SingleTon.getInstance();调用了类的SingleTon调用了类的静态方法，触发类的初始化 
- 类加载的时候在准备过程中为类的静态变量分配内存并初始化默认值 singleton=null count1=0,count2=0 
- 类初始化化，为类的静态变量赋值和执行静态代码快。singleton赋值为new SingleTon()调用类的构造方法 
- 调用类的构造方法后count=1;count2=1 
- 继续为count1与count2赋值,此时count1没有赋值操作,所有count1为1,但是count2执行赋值操作就变为0

类的初始化发生在以下几种情况，称为对一个类进行 “主动引用” ，除此之外称为“被动引用”，均不会触发类的初始化。

	创建类的实例
	访问类的静态变量，不含常量【被final修辞的静态变量】，编译器当常量为值而不是域(field)。
	访问类的静态方法
	反射加载，如( Class.forName("my.xyz.Test") )
	当初始化一个类时，发现其父类还未初始化，则先出发父类的初始化
	虚拟机启动时，定义了main()方法的那个类先初始化

类从被加载到虚拟机内存中开始，直到卸载出内存为止，它的整个生命周期包括了七个步骤，其中，验证、准备和解析这三个部分统称为连接（linking）。

	1) 加载 Loading
	2) 验证 Verification、
	3) 准备 Preparation、
	4) 解析 Resolution
	5) 初始化 Initialization
	6) 使用 Using
	7) 卸载 Unloading

加载阶段是类加载过程的第一个阶段，在此阶段，虚拟机需要完成以下三件事情：

	1、 通过一个类的全限定名来获取定义此类的二进制字节流。
	2、 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
	3、 在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。

加载阶段即可以使用系统提供的类加载器在完成，也可以由用户自定义的类加载器来完成。加载阶段与连接阶段的部分内容(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始。

验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

Java语言本身是相对安全的语言，使用Java编码是无法做到如访问数组边界以外的数据、将一个对象转型为它并未实现的类型等，如果这样做了，编译器将拒绝编译。但是，Class文件并不一定是由Java源码编译而来，可以使用任何途径，包括用十六进制编辑器(如UltraEdit)直接编写。如果直接编写了有害的“代码”(字节流)，而虚拟机在加载该Class时不进行检查的话，就有可能危害到虚拟机或程序的安全。

不同的虚拟机，对类验证的实现可能有所不同，但大致都会完成下面四个阶段的验证 ：文件格式验证、元数据验证、字节码验证和符号引用验证。

准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。

	public static int value=123;

上一句代码在准备阶段value初始值为0，在执行构造函数后，开始初始化阶段才会变为123。

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 符号引用 Symbolic Reference 以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。 直接引用 Direct Reference 可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，如果有了直接引用，那么引用的目标必定已经在内存中存在。

类初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。



## ⚡ ClassLoader 类加载器

JVM预定义几种类加载器，当JVM启动的时候，Java缺省开始使用如下三种类型的类加载器：

启动（Bootstrap）类加载器：引导类加载器是用 本地代码实现的类加载器，它负责将 <JAVA_HOME>/lib下面的核心类库 或 -Xbootclasspath选项指定的jar包等 虚拟机识别的类库 加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以 不允许直接通过引用进行操作。

扩展（Extension）类加载器：扩展类加载器是由Sun的ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的，它负责将 <JAVA_HOME >/lib/ext或者由系统变量-Djava.ext.dir指定位置中的类库 加载到内存中。开发者可以直接使用标准扩展类加载器。

系统（System）类加载器：系统类加载器是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的，它负责将 用户类路径(java -classpath 或 -Djava.class.path 变量所指的目录，即当前类所在路径及其引用的第三方类库的路径，如第四节中的问题6所述)下的类库 加载到内存中。开发者可以直接使用系统类加载器，是最常用的加载器，同时也是java中默认的加载器。通过Java反射机制 Class.getClassLoader() 可以得到类加载器信息。

除了以上列举的三种类加载器，还有一种比较特殊的类型就是线程上下文类加载器（context class loader），从 JDK 1.2 开始引入的。Java.lang.Thread 类中的方法 getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。如果没有通过 setContextClassLoader(ClassLoader cl)方法进行设置的话，线程将继承其父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。使用线程上下文类加载器，可以在执行线程中抛弃双亲委派加载链模式，使用线程上下文里的类加载器加载类。典型的例子有：通过线程上下文来加载第三方库jndi实现，而不依赖于双亲委派。大部分Java application服务器(jboss, tomcat..)也是采用contextClassLoader来处理web服务。还有一些采用hot swap特性的框架，也使用了线程上下文类加载器，比如 seasar (full stack framework in japenese)。

JVM在加载类时默认采用的是双亲委派机制。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归 (本质上就是loadClass函数的递归调用)。因此，所有的加载请求最终都应该传送到顶层的启动类加载器中。如果父类加载器可以完成这个类加载请求，就成功返回；只有当父类加载器无法完成此加载请求时，子加载器才会尝试自己去加载。事实上，大多数情况下，越基础的类由越上层的加载器进行加载，因为这些基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API（当然，也存在基础类回调用户用户代码的情形）。 系统类加载器的父类加载器是标准扩展类加载器，标准扩展类加载器的父类加载器是启动类加载器。

虚拟机出于安全等因素考虑，不会加载<JAVA_HOME>/lib目录下存在的陌生类，换句话说，虚拟机只加载<JAVA_HOME>/lib目录下它可以识别的类。因此，开发者通过将要加载的非JDK自身的类放置到此目录下期待启动类加载器加载是不可能的。

在绝大多数情况下，系统默认提供的类加载器实现已经可以满足需求。但是在某些情况下，您还是需要为应用开发出自己的类加载器。比如您的应用通过网络来传输Java类的字节代码，为了保证安全性，这些字节代码经过了加密处理。这个时候您就需要自己的类加载器来从某个网络地址上读取加密后的字节代码，接着进行解密和验证，最后定义出要在Java虚拟机中运行的类来。下面将通过两个具体的实例来说明类加载器的开发。通过用户自定义的类装载器，你的程序可以加载在编译时并不知道或者尚未存在的类或者接口，并动态连接它们并进行有选择的解析。

除了和本地实现密切相关的启动类加载器之外，包括标准扩展类加载器和系统类加载器在内的所有其他类加载器我们都可以当做自定义类加载器来对待，唯一区别是是否被虚拟机默认使用。前面的内容中已经对java.lang.ClassLoader抽象类中的几个重要的方法做了介绍，这里就简要叙述一下一般 用户自定义类加载器的工作流程（可以结合后面问题解答一起看）：

	1、首先检查请求的类型是否已经被这个类装载器装载到命名空间中了，如果已经装载，直接返回；否则转入步骤2；

	2、委派类加载请求给父类加载器（更准确的说应该是双亲类加载器，真实虚拟机中各种类加载器最终会呈现树状结构），如果父类加载器能够完成，则返回父类加载器加载的Class实例；否则转入步骤3；

	3、调用本类加载器的 findClass() 方法，试图获取对应的字节码。如果获取的到，则调用 defineClass() 导入类型到方法区；如果获取不到对应的字节码或者其他原因失败，向上抛出异常。

在Java中，一个类用其完全匹配类名(fully qualified class name)作为标识，这里指的完全匹配类名包括包名和类名。但在JVM中，一个类用其全名和一个ClassLoader的实例 作为唯一标识，不同类加载器加载的类将被置于不同的命名空间。

在java.net包下有一个 URLClassLoader 类提供了运程加载类的功能，它让我们可以通过以下几种方式进行加载：

	* 文件: (从文件系统目录加载)
	* jar包: (从Jar包进行加载)
	* Http: (从远程的Http服务进行加载)

一个class被一个ClassLoader实例加载过的话，就不能再被这个ClassLoader实例再次加载，即加载类时调用了defileClass()方法，重新加载字节码、解析、验证后就不能重复执行。系统默认的AppClassLoader加载器内部会缓存加载过的class，重新加载的话，就直接取缓存。所以需要热加载只能重新创建一个ClassLoader，然后再去加载已经被加载过的class文件。实现热加载需要重载 ClassLoader 的 loadClass() 方法，跳过内部的双亲委托机制。即使不采用双亲委托机制，比如java.lang包中的相关类还是不能自定义一个同名的类来代替，主要因为JVM解析、验证class的 时候，会进行相关判断。强制重复加载引发 java.lang.LinkageError 异常：

	Exception in thread "main" java.lang.LinkageError: loader (instance of  NetworkClassLoader): attempted  duplicate class definition

JVM中class和Meta信息存放在PermGen space区域。如果加载的class文件很多，那么可能导致PermGen space区域空间溢出。引起：java.lang.OutOfMemoryErrorPermGen space. 对于有些Class我们可能只需要使用一次，就不再需要了，JVM中的Class只有满足以下三个条件，才能被GC回收，也就是该Class被卸载（unload）：

	该类所有的实例都已经被GC。
	加载该类的ClassLoader实例已经被GC。
	该类的java.lang.Class对象没有在任何地方被引用。
	System.gc()执行后的Class的卸载是不可控的。


## ⚡ NetWorkClassLoader 自定义远程类加载器

自定义类加载器，只需要三个步骤：

- 新建一个 MyClassLoader 继承 ClassLoader；
- 重写 loadclass 方法，读入字节码；
- 使用 defineClass 返回类定义。

因为 JDK 已经在 loadClass 方法中帮我们实现了搜索类的算法，当在 loadClass 方法中搜索不到类时，才会调用 findClass 方法来搜索类。所以我们只需重写该方法即可，如没有特殊的要求，一般不建议重写 loadClass 搜索类的算法。

反射机制的应用必须要求该类是 public 访问权限的类，这样才能由加载器加载。要实现 HotSwap 热加载，只需要创建新实例去加载目标类就可以，热加载逻辑可以根据文件更新时间来做判断。

	import java.lang.reflect.*;
	import java.io.ByteArrayOutputStream;
	import java.io.InputStream;
	import java.io.InputStreamReader;
	import java.io.BufferedReader;
	import java.net.URL;
	import java.net.HttpURLConnection;

	/**
	 * NetworkClassLoader ncl = new NetworkClassLoader("http://xxx.com");  
	 * String basicClassName = "Gum";  
	 * Class<?> clazz = ncl.loadClass(basicClassName);
	 * Gum oo = (Gum)clazz.newInstance();
	 */
	class NetworkClassLoader extends ClassLoader {

		private String rootUrl;

		public NetworkClassLoader(String rootUrl) {
			this.rootUrl = rootUrl;
		}

		@Override
		protected Class<?> findClass(String name) throws ClassNotFoundException {
			byte[] classData = getClassData(name);
			if (classData == null) {
				throw new ClassNotFoundException();
			} else {
				return defineClass(name, classData, 0, classData.length);
			}
		}

		private byte[] getClassData(String className) {
			String path = rootUrl + "/" + className.replace('.', '/') + ".class";
			try {
				URL url = new URL(path);
			// HttpURLConnection con = (HttpURLConnection)url.openConnection();
			// System.out.println(con.getResponseCode​() +" "+ con.getContentType());
			// BufferedReader buffer = new BufferedReader(new InputStreamReader(ins));
			// StringBuffer bs = new StringBuffer();
			// String line  = null;
			// while((line=buffer.readLine())!=null){
			// 	bs.append(line);
			// }
			// System.out.println("getClassData:"+bs.length()+":"+bs.substring(0));
			// return bs.toString().getBytes();
				InputStream ins = url.openStream();
				ByteArrayOutputStream baos = new ByteArrayOutputStream();
				int bufferSize = 4096;
				byte[] buffer = new byte[bufferSize];
				int len = 0;
				while ((len = ins.read(buffer)) != -1) {
					baos.write(buffer, 0, len);
				}
				System.out.println("getClassData:"+len+":");
				return baos.toByteArray();
			} catch (Exception e) {
				System.out.println("getClassData exception:");
				e.printStackTrace();
			}
			System.out.println("getClassData null:");
			return null;
		}

		@Override
		public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
			Class c = findLoadedClass(name);
			if( name.startsWith("java.") ){
				ClassLoader system = ClassLoader.getSystemClassLoader();
				c = system.loadClass(name);
			}
			if( null==c ) c = findClass(name);
			if( null!=c && resolve ) resolveClass(c);
			return c;
		}

	}




# 🚩 Java 网课大纲

模块一：JVM 进阶 - Java开发者大厂面试必知必会

	教学目标
	1. 从 0 掌握 JVM 关键技术，了解核心知识；
	2. 全面了解各类 GC 算法的原理和特性，洞悉相关原理；
	3. 全面学习常见的 JVM 分析调优工具，上手十八般武艺；
	4. 一线大厂 JVM 面试题全面剖析，助力拿到心仪 Offer。

	学习和工作中的痛点
	1. 没有经过体系化 JVM 学习，不懂原理，做不到知其然知其所以然；
	2. 不熟悉 JVM 工具和方法，遇到问题不知道从何下手、如何分析和解决问题；
	3. 缺乏实际场景的练习，每次看看书上的知识就忘，理解不深，无法做到融会贯通；
	4. 在面试过程中十回有九回都遇到问 JVM 理论和分析调优的问题，每次都很难让面试官满意。

	通过学习掌握的核心能力
	1. 夯实基础：掌握 JVM 的基础知识和常用工具，了解一般原理，知道从什么地方着手分析问题；
	2. 深入学习：掌握各类 GC 算法的一般原理，知道如何根据实际需要选择使用合适的 GC 策略；
	3. 分析问题：掌握 GC 日志、线程、内存等维度的分析技巧，知道排查问题和优化系统的套路；
	4. 积累经验：了解常见的分析调优经验，熟悉常见的面试问题和技巧，彻底学会 JVM 知识。

	详细内容
	1. JVM 基础知识、Java 字节码技术、JVM 类加载器、JVM 内存模型、JVM 启动参数详解；
	2. JDK 内置命令行工具、JDK 内置图形界面工具、JDWP 简介、JMX 与相关工具；
	3. 常见的 JVM GC 算法（Parallel GC/CMS GC/G1 GC）基本原理和特点；
	4. 新一代 GC 算法（Java11 ZGC/Java12 Shenandoah) 和 Oracle GraalVM；
	5. GC 日志解读与分析、JVM 的线程堆栈等数据分析、内存 dump 和内存分析工具；
	6. fastThread 相关工具以及面临复杂问题时的几个高级工具的使用；
	7. JVM 问题排查分析的常用手段、性能调优的最佳实践经验等；
	8. JVM 相关的常见面试问题必知必会、全面分析。

模块二：NIO 技术 - 构建高吞吐服务器的终极武器

	教学目标
	1. 理解 NIO 的相关概念和原理，了解核心知识；
	2. 全面掌握 Netty 相关的功能特性，掌握 Netty 的技术原理；
	3. 全面学会使用 Netty 技术编程，能够写出高效服务器端代码；
	4. 掌握常用的性能压测技术和相关工具，能够压测 HTTP 接口性能。

	学习和工作中的痛点
	1. 不理解 NIO 相关概念和技术点，搞不清原理，沟通和面试时无法准确表达；
	2. 缺乏实际场景的练习，对 Netty 的使用和原理不熟悉，难以应用到工作中；
	3. 不会使用 Netty 做高性能服务端编程，对性能相关指标和数据没有概念。

	通过学习掌握的核心能力
	1. 夯实基础：掌握 NIO 相关的知识和技术，能知道各种技术有什么优缺点，适用于什么场景；
	2. 深入学习：熟练掌握 Netty/NIO 编程，能够设计实现一个高性能 HTTP 服务器/ API 网关；
	3. 积累经验：了解常见的性能相关概念和压测入门，对性能指标有清晰概念，能够简单地量化分析。

	详细内容
	1. 同步/异步、阻塞/非阻塞、BIO、NIO、AIO、Reactor/Proactor；
	2. ByteBuff/Acceptor/Channel/Handler、NioEventLoopGroup/EventLoop、bossGroup/workerGroup；
	3. Netty 的启动和执行过程、线程模型、事件驱动、服务端和客户端的使用方式；
	4. 常见的 API Gateway/HTTP Server、SEDA 原理、业务 API 网关的功能和结构；
	5. Throughout/TPS/QPS、Latency/P99/P95/P90、ApacheBench/Wrk/JMeter/LoadRunner。

模块三：并发编程 - 多核处理器时代高性能的秘诀

	教学目标
	1. 学会多线程、高并发相关概念和技术，了解并发编程的核心知识；
	2. 全面了解并发的相关技术的原理和用途，洞悉技术原理和相互关系；
	3. 熟练掌握 Java 的多线程、并发包中各个类的使用，上手十八般武艺。

	学习和工作中的痛点
	1. 没有经过系统性学习并发编程，搞不清楚技术原理，写不出一个良好的多线程/异步代码；
	2. 不熟悉 Java 的各个多线程工具和方法，遇到多线程问题常常束手无措，不会分析解决问题；
	3. 缺乏实际场景的练习，平时没怎么用到多线程和并发，导致死记硬背的概念总是记不住。

	通过学习掌握的核心能力
	1. 夯实基础：系统掌握 Java 多线程和并发编程的技术原理和知识点，写出优秀的并发代码；
	2. 深入学习：熟练应用各种并发工具，了解在什么情况下使用哪些具体的技术和方法；
	3. 分析问题：掌握常见的多线程和并发问题分析技巧，知道排查一般问题的具体步骤；
	4. 积累经验：构建完整全面的并发编程知识体系，熟悉常见的面试问题和技巧，彻底掌握 Java 并发编程知识。

	详细内容
	1. Java 多线程基础：线程、锁、synchronized、volatile/final、sleep/await/notify/fork/join；
	2. Java 并发包基础：线程池 Executor、AQS/CAS、Atomic 原子操作、Lock/ReadWriteLock/Condition、Callable/Future；
	3. Java 并发容器与工具：BlockingQueue/CopyOnWriteList/ConcurrentHashMap、CountDownLatch/CyclicBarrier/Semaphore 等；
	4. 其他：万金油 ThreadLocal，化繁为简 Java8 parallelStream 等。

模块四：开发框架 - 深入理解 Spring 等主流框架思想

	教学目标
	1. 重新认识主流开源技术框架，深入理解背后的原理和关系；
	2. 掌握整合各种框架的最佳实践，学会在工作中做技术框架选型；
	3. 了解主流框架的发展趋势，一线大厂的使用模式和关注点。

	学习和工作中的痛点
	1. 对主流开源技术框架，始终在会用、会做简单整合，不懂背后原理；
	2. 只会用自己熟悉的框架，不会做技术选型，也不了解一些最佳实践经验；
	3. 框架发展太快，学习跟不上了，也不太了解一线大厂使用主流框架的方式。

	通过学习掌握的核心能力
	1. 夯实基础：从更高的维度和更深入的原理，重新学习主流框架，了解框架的内在联系；
	2. 深入学习：掌握常见框架的一些最佳实践经验，能够根据具体的项目情况进行技术框架选型；
	3. 积累经验：了解常见主流框架的发展趋势，掌握最佳学习姿势，能够轻松驾驭技术发展。

	详细内容
	1. Spring 技术体系（Spring Core/Web/MVC/Data/Messaging、Spring Boot 等）；
	2. ORM 技术体系（JPA、Hibernate、MyBatis 等）。


模块五：系统性能优化 - 学会性能分析与 MySQL 优化

	教学目标
	1. 深入了解业务系统性能的度量分析方法，找到性能瓶颈和关键路径；
	2. 了解 MySQL 的性能关键点，学会如何进行 MySQL 和 SQL 语句的性能分析；
	3. 掌握如何编写高效的 SQL 语句，能对复杂的业务 SQL 进行性能优化。

	学习和工作中的痛点
	1. 性能调优能力是架构师/技术专家的核心能力之一，但是对这一块没经验；
	2. 遇到性能问题不知道从何下手、如何分析性能瓶颈在哪儿，也就不知道如何解决问题；
	3. 缺乏实际场景的练习，每次看别人讲的理论，都没办法转化到实际工作中去；
	4. 在面试过程中经常被问到分析调优的问题，总是觉得自己没有太多干货可讲。

	通过学习掌握的核心能力
	1. 深入学习：通过系统化的学习性能相关知识和实践经验，掌握复杂业务系统性能分析方法；
	2. 分析问题：掌握 SQL/索引/事务 的分析技巧，知道排查问题和优化 MySQL/SQL 的办法；
	3. 积累经验：掌握编写高性能 SQL 的技能，避免常见的各种低性能坑，提升数据库编程水平。

	详细内容
	1. 系统可观测性（日志、调用链跟踪、指标度量），80/20 优化原则，CPU、内存、磁盘/网络 IO 等分析；
	2. MySQL 的锁、事务、索引、并发级别、死锁、执行计划、慢 SQL 统计、缓存失效、参数优化；
	3. 库表设计优化，引擎选择，表结构优化设计，列类型选择，索引设计，外键等；
	4. SQL 查询优化，索引选择，连接优化，聚合查询优化，Union 优化，子查询优化，条件优化等；
	5. 场景分析，主键生成与优化，高效分页，快速导入导出数据，解决死锁问题等。


模块六：超越分库分表 - 掌握海量业务数据的应对之道

	教学目标
	1. 从 0 掌握海量业务数据处理的关键技术，了解核心知识，参与实践案例；
	2. 全面学习 MySQL 主从复制架构，读写分离和数据库垂直/水平拆分；
	3. 学习应对系统不同类型数据的处理办法，对数据进行冷热分离，提升系统数据处理能力；
	4. 全面掌握各类场景下的读写分离，数据库拆分的框架和中间件，在实际工作中熟练使用。

	学习和工作中的痛点
	1. 只会增删改查，不了解对海量业务数据的处理办法；
	2. 每次被人问到 MySQL 的高可用和高性能架构，都不能清晰地讲明白；
	3. 缺乏实际场景的练习，不了解不同类型的数据对应的处理办法；
	4. 对于常见的读写分离、分库分表等技术，停留在理论阶段，没有动手实践过。

	通过学习掌握的核心能力
	1. 夯实基础：全面了解 MySQL 主从复制架构，读写分离和数据库垂直/水平拆分的应用场景和技术原理；
	2. 深入学习：进一步学会 MySQL 的高可用和高性能架构；
	3. 分析问题：掌握应对系统不同类型数据的处理办法，对数据进行冷热分离，提升系统数据处理能力；
	4. 积累经验：全面掌握各类场景下的读写分离，分库分表的框架和中间件，在实际工作中熟练使用。

	详细内容
	1. MySQL 主从复制，Binlog，Row/Statement 模式，主从切换，读写分离，数据库扩容；
	2. 数据库垂直拆分与水平拆分，分库分表，分布式主键，分表算法，SQL 限制，数据迁移，实时同步；
	3. Spring 动态切换数据库，TDDL/Sharding-JDBC 框架，MyCat/Sharding-Proxy 中间件；
	4. 数据库拆分的最佳实践，分布式事务最佳实践，多租户的最佳实践。


模块七：分布式服务 - 复杂业务系统架构演进必由之路

	教学目标
	1. 全面掌握 RPC 原理和常见的 RPC 技术；
	2. 深刻理解服务治理相关的技术和应用场景；
	3. 深入学习 Dubbo 和 Spring Cloud 的功能和技术原理；
	4. 深入了解微服务架构的特点和最佳实践。

	学习和工作中的痛点
	1. 会用简单的 RPC 和 REST，但是对其原理和细节不够了解；
	2. 一直没有实际接触过服务治理相关的技术，只知道几个名词，不清楚具体的功能和用法；
	3. 对 Dubbo 和 Spring Cloud 一知半解，简单作为 RPC 调用都会，再复杂的就不太清楚了；
	4. 微服务相关的知识都有些了解，但是不是很懂到底什么时候该做微服务，怎么做微服务。

	通过学习掌握的核心能力
	1. 夯实基础：系统的了解和学习 RPC 知识，知道每种 RPC 有什么特点，什么时候用什么 RPC 技术；
	2. 深入学习：全面的学习一遍服务治理的技术，能够认识到什么情况下使用哪种具体的特性；
	3. 分析问题：深刻理解 Dubbo 和 Spring Cloud 技术体系原理，遇到问题能够迅速定位和解决；
	4. 积累经验：深入了解微服务架构的特点和最佳实践经验，学会何时做微服务，如何做微服务。

	详细内容
	1. 基础知识：RPC、通信与数据协议、WebService、Hessian、REST、gRPC、Protocol Buffers 等；
	2. 服务化：服务治理、配置管理、注册发现、服务分组、版本管理、集群管理、负载均衡、限流与降级熔断等；
	3. 框架：Apache Dubbo 的功能与原理分析，Spring Cloud 体系，具体的案例实践；
	4. 微服务：微服务架构的 6 个最佳实践，从微服务到服务网格、云原生的介绍。


模块八：分布式缓存 - 复杂业务系统访问提速第一法宝

	教学目标
	1. 深入理解缓存的应用场景和缓存策略；
	2. 全面掌握几种常见缓存问题的处理方式；
	3. 彻底掌握 Redis 缓存中间件，了解 Hazelcast 内存网格；
	4. 学会使用缓存技术实现排行数据展示，分布式 ID 生成等典型应用场景。

	学习和工作中的痛点
	1. 对缓存的认知停留在 JVM 内的静态 Map 和往 Redis 存 KV 数据，不了解什么时候该用缓存；
	2. 不熟悉常见的缓存问题处理方案，遇到问题难以解决，例如缓存失效和雪崩问题如何解决；
	3. 只了解简单的 Redis 操作，高级功能（例如集群或 Lua）没用过，其他缓存技术也没接触过；
	4. 没有在实际的应用场景里用 Redis 之类的缓存技术，不知道具体有哪些典型的应用场景。

	通过学习掌握的核心能力
	1. 夯实基础：掌握缓存的应用场景和常见的策略，特别是与数据库的同步；
	2. 深入学习：掌握常见的缓存问题的处理策略，将缓存技术应用到实际工作；
	3. 分析问题：全面掌握 Redis 缓存技术，能够分析和解决缓存问题；
	4. 积累经验：深入实践和掌握几个典型的应用场景，了解 Hazelcast 内存网格技术。

	详细内容
	1. 缓存的应用场景，缓存加载策略与失效策略，缓存与数据库同步等；
	2. 缓存预热、缓存失效、缓存击穿、缓存雪崩、多级缓存、缓存与 Spring+ORM 框架集成；
	3. 缓存中间件，Redis（几种常用数据结构、分布式锁、Lua 支持、集群），Hazelcast（Java 数据结构、内存网格、事务支持、集群）；
	4. 缓存的应用场景，排行数据展示，分布式 ID 生成，Session 共享，热点账户操作等。


模块九：分布式消息 - 复杂业务系统关系解耦不二法门

	教学目标
	1. 从 0 掌握消息队列（MQ）的关键技术，了解核心知识；
	2. 全面了解各类 MQ 技术的原理和特性，洞悉相关原理；
	3. 全面吃透 Kafka 的基本功能，集群搭建，高可用等，上手十八般武艺；
	4. 深入理解 MQ 的特点和应用场景，通过交易场景实战演练，并动手做一个简单的 MQ。

	学习和工作中的痛点
	1. 很少使用 MQ，就算用过也只是简单的收发消息，对 MQ 的原理和细节不了解；
	2. 不熟悉常见的几个主流 MQ，其中的多数技术都没有接触过，或者只听过名词；
	3. 缺乏实际场景的练习，每次看看书上的知识就忘，理解不深，无法做到融会贯通；
	4. 不太了解什么时候该用 MQ，MQ 能帮我们解决哪些方面的问题，带来什么样的好处。

	通过学习掌握的核心能力
	1. 夯实基础：掌握 MQ 的基础知识和常用工具，了解一般原理，知道用 MQ 的一些基本概念；
	2. 深入学习：掌握各类 MQ 技术的一般原理和功能，知道如何根据实际需要选择使用合适的 MQ；
	3. 分析问题：掌握 Kafka 等主流 MQ 技术，能对一般的 MQ 问题进行分析和解决；
	4. 积累经验：了解 MQ 如何应用到一个具体的业务场景和 MQ 内部细节，彻底学会 JVM 知识。

	详细内容
	1. 消息队列的基本知识，Broker 与 Client，消息模式（点对点、发布订阅），消息协议（STOMP、JMS、AMQP、OpenMessaging 等），消息 QoS（最多一次、最少一次、有且仅有一次），消息重试，延迟投递，事务性，消息幂等与去重；
	2. 消息中间件：ActiveMQ 的简单入门，Kafka 的基本功能与使用，高可用（集群、分区、副本）、性能，RabbitMQ 和 RocketMQ，Pulsar 的简单介绍；
	3. 消息的 4 个主要功能，搭建一个 Kafka 集群，实现常用的消息发送、消息消费功能；
	4. 典型使用场景，使用 MQ 实现交易订单的处理，动手实现一个简化版的消息队列。


模块十：分布式系统架构 - 如何设计高并发高可用的 Java 系统

	教学目标
	1. 了解大规模分布式的复杂业务系统架构技术发展脉络；
	2. 全面掌握业务系统发展不同阶段应该如何做技术选型；
	3. 以一个电商系统为例，深入学习如何分析系统架构；
	4. 掌握高并发高可用的分布式 Java 系统的设计方法。

	学习和工作中的痛点
	1. 没有机会去从头设计一个高并发的大规模分布式系统，缺乏对此类问题深入的学习和思考；
	2. 对业务系统架构发展不了解，技术思路一直停留在一个静态观念，一般只会选择自己熟悉的技术；
	3. 缺乏实际场景的练习，每次看看书上的知识就忘，面对复杂业务系统架构设计，总觉得无从下手；
	4. 平时从网上或书上看到各种零散的知识和经验，无法转化成自己的知识和能力，总是掌握不了。

	通过学习掌握的核心能力
	1. 夯实基础：了解大规模分布式的复杂业务系统架构技术发展脉络，从技术发展里借鉴经验；
	2. 深入学习：掌握业务系统发展不同阶段应该如何做技术选型，为系统选择合适的架构方案；
	3. 分析问题：深入理解如何基于系统的功能性和非功能性需求，进行详细的系统架构分析；
	4. 积累经验：掌握高并发高可用的分布式 Java 系统的设计方法，能够独立设计复杂业务系统。

	详细内容
	1. 业务分析、功能性需求、非功能性需求、高可用、高性能、稳定性、易用性、扩展性、可维护性、安全性等；
	2. “4+1” Views、TOGAF、架构方案、业务架构、数据架构、设计文档、技术选型、部署文档、运维文档等；
	3. 分布式服务化、分布式消息中间件、分布式缓存、分布式文件系统、监控告警系统、权限与认证中心等。


模块十一：业务系统重构 - 重构遗留系统是架构师的必修技能

	教学目标
	1. 通过一个具体复杂电商业务系统的重构，掌握遗留系统重构的方法和经验；
	2. 了解一线大厂系统演进的具体案例，掌握如何解决老系统的各种疑难杂症；
	3. 学会如何解决困难的问题，协调资源，推动团队，完成看似不可能的目标。

	学习和工作中的痛点
	1. 实际工作中，我们并不是总能有机会从头去做一个大系统，维护和改造老系统，反而是更常见的任务；
	2. 遗留的老系统质量很差，经常出故障，没文档，代码复杂且没人清楚细节，不知如何下手改造；
	3. 改造过程中，遇到很多具体的复杂技术难题，心里没底，各项估计也不准确；
	4. 涉及到的各方人员都不是很理解，也不怎么配合，阻力很大，工作难以推动。

	通过学习掌握的核心能力
	1. 深入学习：通过一个具体复杂电商业务系统的重构，学习遗留系统重构的方法和经验；
	2. 分析问题：了解如何评估遗留老系统，做出充分、详细、客观的分析报告；
	3. 积累经验：掌握业务系统重构改造中的一些通用性技术问题，以及推动工作的办法。

	详细内容
	1. 分析系统现状，给出明确的各项指标，了解各方对指标的期望和差距；
	2. 给出多个可选的改造或重做方案，明确各方案的优缺点，提供决策依据；
	3. 方案上的适当妥协，各方达成一致，快速推动重构工作启动和展开；
	4. 细化具体的方案细节，形成路径，争取足够的资源，恰当的时间窗口；
	5. 小步快跑，迅速取得阶段性成果，不影响业务整体的规划和发展；
	6. 保持业务连续性，多做监控、兼容和特性开关，给改造加上保险丝和缓冲区；
	7. 及时评估改进进展，更新方案和路线、资源和时间，推动改造顺利进行；
	8. 复盘总结相关经验，提出更多建议和改进办法，实现经验分享，方法复用。


模块十二：架构师修炼之道 - 如何升级打怪终成一线技术专家

	教学目标
	1. 了解架构师应该具备的硬技能和软实力；
	2. 全面了解架构师典型的成长路径；
	3. 掌握一些实用的学习方法，借鉴一些成长经验；
	4. 学习如何准备相关的面试和求职。

	学习和工作中的痛点
	1. 总搞不清楚怎么样才能算是一名合格的架构师，总觉得是架构师很玄乎；
	2. 技术能力提升和软实力都遇到瓶颈，没人指导，找不到成长的突破口；
	3. 不知道什么好的学习方法和经验，总是走弯路，浪费了很多时间精力；
	4. 总是觉得自己面试准备得不好，发挥得不好，不能够给面试官足够好的评价。

	通过学习掌握的核心能力
	1. 夯实基础：学习架构师应该具备的硬技能和软实力，摸清自己哪些方面可以进一步提升；
	2. 深入学习：找到自己成长到下一个层次的突破口，制定相关的规划路径，实现成长；
	3. 借鉴方法：掌握一些实用的好方法和经验，能够让我们少走弯路，事半功倍；
	4. 积累经验：如何提前准备面试，怎样打磨简历突出亮点，如何在面试过程中脱颖而出。

	详细内容
	1. 分享我个人的成长第一手经验，升级打怪，成为架构师、技术专家、技术总监；
	2. 六个硬能力：技术能力、设计能力、抽象能力、管理能力、结构化思考能力、系统化分析能力；
	3. 七个软实力：大局观能力、沟通协作能力、持续学习能力、关注力、探索力、决策力、自我驱动力。




# 🚩 常量池 变量堆

变量比较：

- a b 是常量成员的变量，字符串 xyz 是字面常量，编译时会引用到同一块内存地址，直接用 == 比较地址相等。
- a c 虽然内容相同但是地址不同，== 比较地址是否相等。
- equals 方法比较首先会曾判断地址是否相同，再判断类型是否相同，最后判断内容是否相同，其一成立则为真。

String 类型比较不同对象内容是否相同，用 equals，因为 == 用于比较引用类型和比较基本数据类型时具有不同的功能。

数据类型换 Integer 也成立，这里对象类型基类即 Object 的基本特性，基本数据类型除外，如 char, int, long

	// package com.jeango.it.const_variables;

	public class coding {

		static public void main(String args[]){
			String a = "xyz";
			String b = "xyz";
			String c = new String("xyz");

			coding.log("       a==b? "+(a==b));
			coding.log("       a==c? "+(a==c));
			coding.log("a.equals(b)? "+a.equals(b));
		}
		static public void log(String t){
			System.out.print(t+"\n");
		}
		
	}

# 🚩 参数传递 传值和引用

重申一遍：Java 中只有传值。与C++不同的，Java里面没有指针的概念，Java的设计者巧妙的对指针的操作进行了管理，这就是开发Java语言的目的。事实上，在懂C++的Java程序员眼中，Java到处都是精美绝伦的指针。

	public class coding {

		static public void main(String args[]){
			String a = "xyz";
			String b = coding.prefix(a);
			coding.log("a = "+a);  // a = xyz
			coding.log("b = "+b);  // b = **xyz
			String[] c = {"abc","xyz"};
			String[] d = coding.prefixs(c);
			for (String s:c ) log("Item in c " + s); // Item in c abc ...
			for (String s:d ) log("Item in d " + s); // Item in d abc ...
		}
		static public String prefix(String t){
			t = "**"+t;
			return t;
		}
		static public String[] prefixs(String[] ss){
			for( String s:ss) s = "**"+s;
			return ss;
		}
		static public void log(String t){
			System.out.print(t+"\n");
		}
		
	}


# 🚩 Thread 多线程

	new Thread(Runnable target).start()
	
start() 方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。

run() 方法只是类的一个普通方法而已，直接调用依然只有主线程这一个线程，还是要等待run方法体执行完毕后才可继续执行下面的代码。

	public class coding {

		static public void main(String args[]){
			Thread t = new Thread(){
				public void run(){
					work();
				}
				public void start(){
					work();
				}
			};
			for (int i=0; i<10000; i++) {
				// t.run();
				t.start();
				log("done");
			}
		}
		static public void work(){
			log("I'm working...");
		}
		static public void log(String t){
			System.out.print(t+" ");
		}

	}



# 🚩 factorial and int and BigDecimal

	public class coding {

		static public void main(String args[]){
			int[] ia = {1,2,3,4,5,6,7,8,9,10,20,30,31,32,33,34,35,100}; // BigDecimal needed!
			for (int i:ia ) {
				log( i + "!=" + factorial(i));
			}
		}
		static public int factorial(int i){
			if( i<=1 ) return 1;
			return i * factorial(i-1);
		}
		static public void log(String t){
			System.out.print(t+"\n");
		}

	}

# 🚩 RegExp 正则表达式

java.util.regex.Matcher 和 java.util.regex.Pattern：

	Pattern p = Pattern.compile("cat");
	Matcher m = p.matcher("one cat two cats in the yard");
	StringBuffer sb = new StringBuffer();
	while (m.find()) {
	   m.appendReplacement(sb, "dog");
	}
	m.appendTail(sb);
	System.out.println(sb.toString());

Pattern 字符的匹配：

	x 字符 x 
	\\ 反斜线字符 
	\0n 八进制值的字符0n (0 <= n <= 7) 
	\0nn 八进制值的字符 0nn (0 <= n <= 7) 
	\0mnn 八进制值的字符0mnn 0mnn (0 <= m <= 3, 0 <= n <= 7) 
	\xhh 十六进制值的字符0xhh 
	\uhhhh 十六进制值的字符0xhhhh 
	\t 制表符('\u0009') 
	\n 换行符 ('\u000A') 
	\r 回车符 ('\u000D') 
	\f 换页符 ('\u000C') 
	\a 响铃符 ('\u0007') 
	\e 转义符 ('\u001B') 
	\cx T对应于x的控制字符 x 
	  
	字符类 
	[abc] a, b, or c (简单类) 
	[^abc] 除了a、b或c之外的任意 字符（求反） 
	[a-zA-Z] a到z或A到Z ，包含（范围) 
	[a-z-[bc]] a到z，除了b和c ： [ad-z]（减去） 
	[a-z-[m-p]] a到z，除了m到 p： [a-lq-z] 
	[a-z-[^def]] d, e, 或 f 
	备注：
	方括号的正则表达式“t[aeio]n”只匹配“tan”、“Ten”、“tin”和“ton”，只能匹配单个字符。
	圆括号，因为方括号只允许匹配单个字符；故匹配多个字符时使用圆括号“()”。比如使用“t(a|e|i|o|oo)n”正则表达式，就必须用圆括号。

	预定义的字符类 
	. 任意字符（也许能与行终止符匹配，也许不能） 备注：句点符号代表任意一个字符。比如：表达式就是“t.n”，它匹配“tan”、“ten”、“tin”和“ton”，还匹配“t#n”、“tpn”甚至“t n”。
	\d 数字: [0-9] 
	\D 非数字: [^0-9] 
	\s 空格符: [ \t\n\x0B\f\r] 
	\S 非空格符: [^\s] 
	\w 单词字符: [a-zA-Z_0-9] 
	\W 非单词字符: [^\w]

	表达次数的符号
	符号 次数
	* 0次或者多次
	+ 1次或者多次
	? 0次或者1次
	{n} 恰好n次
	{n,m} 从n次到m次

# 🚩 构造过程

构造过程父类优先于子类，父类构造器执行完后才进入子类的构造，coding.key 的初始在父类构造完成后进行，在父类中使用coding.key就是未初始化的值。

	public class coding extends base {

		String key = "xyz";
		static public void main(String args[]){
			coding c = new coding();
		}
		public void go(){
			log("key = "+key);
		}
		static public void log(String t){
			System.out.print(t+"\n");
		}

	}

	class base {
		private String key = "abc";
		public base(){ // never add void to constructors 
			go();
		}

		public void go(){
			coding.log(key);
		}
	}


# 🚩 动态代码块 静态代码块 构造器执行顺序


	public class coding {

		public static coding a = new coding();
		public static coding z = new coding();
		{
			log("Dynamic Code Block ");
		}
		static {
			log("Static Code Block ");
		}
		public coding(){ log("Constructor"); }
		static public void main(String args[]){
			// new coding();
		}
		static public void log(String t){
			System.out.println(t);
		}

	}

执行输出，静态成员按定义前后顺序进行初始化，首先是 a 初始化一个coding，这里输出第一行内容，然后是 z 初始化输出第二行内容。

	Dynamic Code Block 
	Constructor
	Dynamic Code Block 
	Constructor
	Static Code Block 


# 🚩 Integer.MAX_VALUE

	static public void main(String args[]){
		int i = Integer.MAX_VALUE;
		long l = Integer.MAX_VALUE;
		l++;
		log(l+""); // 2147483648
		l = i+1;
		log(l+""); // -2147483648
	}
	static public void log(String t){
		System.out.println(t);
	}



# 🚩 RSA 非对称加密解密工具类
https://docs.oracle.com/javase/7/docs/api/java/security/KeyPairGenerator.html


# 🚩 MD5 SHA256 信息摘要算法工具类
https://docs.oracle.com/javase/7/docs/api/java/security/MessageDigest.html

	import java.security.MessageDigest;
	
	public class coding {

		static public void main(String args[]) throws Exception {
			coding.log(bytesToHex(MD5("abc")));
		}
		// return 128bit/16Bytes fingerpoint data or fall
		public static byte[] MD5(String msg) throws Exception {
		    try {
		        MessageDigest md = MessageDigest.getInstance("MD5");
				// MessageDigest md = MessageDigest.getInstance("SHA-1");
				// MessageDigest md = MessageDigest.getInstance("SHA-256");
			    byte[] byteArray = msg.getBytes("UTF-8");
			    byte[] fingerprint = md.digest(byteArray);
			    return fingerprint;
		    } catch (Exception e) {
		        log(e.toString());
		        e.printStackTrace();
		        return new byte[0];
		    }
		}

		public static String bytesToHex(byte[] bytes){
		    StringBuffer hexValue = new StringBuffer();
		    for (int i = 0; i < bytes.length; i++) {
		        int val = ((int) bytes[i]) & 0xff;
		        if (val < 16) {
		            hexValue.append("0");
		        }
		        hexValue.append(Integer.toHexString(val));
		    }
		    return hexValue.toString();
		}

		static public void log(String t){
			System.out.print(t+"\n");
		}
		
	}


# 🚩 Base64 

Base64 是比较常用的一种能将二进位数据以可视字符串表达出的编码方式，使用了64个可见字符来编码，每个字节只利用了 6bits 信息，即 2^6=64 种状态对应 64 个可见字符。二进制转到字符称为编码，由字符转换到二进制称为解码。转换时，3 个二进位字节分拆成四组6bits的数据，按取值索引找到码表对应的字符即可，当数据最后一组不足 3 字节，就使用 padding 填充，确保转换后的 Base64 编码数量是4字节的整数倍。Base64不只一种编码方案，基础的方案中使用了除号，编码后的内容不能用于文件名。在URL中，+/=三个符号要对应转换成 %2B %2F %3D，这会占用有长度要求URL。所以，后来推出有兼容URL与文件名的编码方案 Base64url，这个方案中使用了 - 和 _ 替换了基础方案中使用的 + 号和 / 号，对于 = 这个符号的处理，有些实现会省略，有些则以圆点替换。

除Base64外，还有Base16即Hex十六进编码也是使用较多的一种，这种编码刚好用两个字节编码一个二位字节数据。

Base64编码 - https://en.wikipedia.org/wiki/Base64
base64url in RFC 4648 - https://tools.ietf.org/html/rfc4648
Base32 - RFC 4648 alphabet - https://en.wikipedia.org/wiki/Base32
MIME编码 - https://en.wikipedia.org/wiki/MIME
Base16 Hexadecimal - https://en.wikipedia.org/wiki/Hexadecimal
(code point +:43 /:47 0:48 =:61 A:65 a:97)

Java 的Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：

	static Base64.Decoder getDecoder() 解码使用基本型 base64 编码方案。
	static Base64.Encoder getEncoder() 编码使用基本型 base64 编码方案。
	static Base64.Decoder getMimeDecoder() 解码使用 MIME 型 base64 编码方案。	
	static Base64.Encoder getMimeEncoder() 编码使用 MIME 型 base64 编码方案。
	static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator) 可以指定每行的长度及行的分隔符。
	static Base64.Decoder getUrlDecoder() 解码使用 URL 和文件名安全型 base64 编码方案。
	static Base64.Encoder getUrlEncoder() 编码使用 URL 和文件名安全型 base64 编码方案。

基本：输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/。
URL：输出映射到一组字符A-Za-z0-9+_
MIME: 输出隐射到MIME友好格式。输出每行不超过76字符，并且使用 \r\n 作为分割。编码输出最后没有行分割。


## ⚡ Base64的Java语言实现
http://www.herongyang.com/Encoding/Base64-Sun-Java-Implementation.html
http://www.runoob.com/java/java8-base64.html
Base64编码与Java版本实现 - https://www.jianshu.com/p/79ecc613ed21

第三方实现Base64的API有 Apache Commons Codec library 的org.apache.commons.codec.binary.Base64，还有 Google Guava 库里的 com.google.common.io.BaseEncoding.base64() 这个静态方法。最后一个，号称Base64编码速度最快的 MigBase64 而且是10年前的实现。

这里贴的是坚果的实现，好久不写Java，找个练习题做做以免荒废了：

	import java.util.Base64;
	import java.nio.charset.Charset;

	public class coding {

		static public void main(String args[]) throws Exception {
			String a = new String("Base64的Java语言实现");
			// for( int i=0; i<a.length(); i++){
			// 	int c = a.charAt(i);
			// 	log( "Char Code "+c+ " 0x"+Integer.toHexString(c) + " 0b"+Integer.toBinaryString(c) ); 
			// }
			// byte[] as = a.getBytes();
			// for( int i=0; i<as.length; i++){
			// 	int c = as[i] & 0xFF;
			// 	log( "Byte Code "+c+ " 0x"+Integer.toHexString(c) + " 0b"+Integer.toBinaryString(c) ); 
			// }
			String cp = Charset.defaultCharset().name();
			log("Default CodePage "+cp);

			String b = Base64.getEncoder().encodeToString(a.getBytes());
			String c = new String( Base64.getDecoder().decode(b) );
			String d = Basee64encode(a.getBytes());
			String e = new String(Basee64decode(d));

			log("encode => "+a+" => "+b+" == "+d+"? "+(b.equals(d)?"PASS":"FAIL"));
			log("decode => "+c+" == "+e+"? "+(c.equals(e)?"PASS":"FAIL"));
		}

		static public String Basee64encode(byte[] bin){
			int i = bin.length%3;
			int g = bin.length - i;
			StringBuffer s = new StringBuffer();
			String fix = new String();
			if( i==1 ){
				int b = (0x3f & (bin[g]<<4));
				fix += map64(0x3F & bin[g]>>2)+""+map64(b)+"==";
			}else if( i==2 ){
				int b = (0x03 & bin[g])<<4 | (0xf0 & bin[g+1])>>4;
				int c = (0x0f & bin[g+1])<<2; // !!! 最后四bits移到最高位
				fix += map64(0x3f & bin[g]>>2) +""+ map64(b) +""+ map64(c)+'=';
			}
			for (i=0; i<g; i+=3 ) { 
				int a = (0xff & bin[i]  )>>2; // bigger first
				int b = (0x03 & bin[i]  )<<4 | (0xF0 & bin[i+1])>>4;
				int c = (0x0f & bin[i+1])<<2 | (0xC0 & bin[i+2])>>6;
				int d = (0x3f & bin[i+2]);
				s.append(map64(a));
				s.append(map64(b));
				s.append(map64(c));
				s.append(map64(d));
				// log( ((short)(bin[i]) & 0xFF)+" "+(bin[i+1] & 0xFF)+" "+ (bin[+2] & 0xff)+" => "+(a)+" "+(b)+" "+(c)+" "+(d));
			}
			return s.toString()+fix;
		}

		static public byte[] Basee64decode(String msg){
			byte[] bytes = msg.getBytes();
			byte[] res = new byte[bytes.length*3/4];
			for(int i=0; i<bytes.length; i+=4){
				byte a = unmap64(bytes[i]);
				byte b = unmap64(bytes[i+1]);
				byte c = unmap64(bytes[i+2]);
				byte d = unmap64(bytes[i+3]);
				res[i*3/4+0] = (byte)(a<<2 | b>>4);
				res[i*3/4+1] = (byte)(b<<4 | c>>2);
				res[i*3/4+2] = (byte)(c<<6 | d);
				// log("+ "+(short)(res[i*3/4+0] & 0xFF) +" "+ (short)(0xFF&res[i*3/4+1]) +" "+ (short)(0xFF&res[i*3/4+2]) );
			}
			int l = bytes.length;
			int pad = bytes[l-2]=='='? 2:bytes[l-1]=='='? 1:0;
			if( pad>0 ){
				byte[] ret = new byte[res.length-pad];
				System.arraycopy(res, 0, ret, 0, res.length-pad);
				return ret;
			}
			return res;
		}
		static public char map64(int i){
			// +:43 /:47 0:48 =:61 A:65 a:97
			if( i>63 ) return '=';
			byte code = (byte)(i==62?'+':i==63?'/':i<26?'A'+i:i<52?'a'+i-26:'0'+i-52);
			return (char)code;
		}
		static public byte unmap64(byte i){
			// +:43 /:47 0:48 =:61 A:65 a:97
			if( i=='=' ) return 0;
			byte index = (byte)(i=='+'?62:i=='/'?63:i<'A'?i-'0'+52:i<'a'?i-'A':i-'a'+26);
			return (byte)index;
		}

		static public void log(String t){
			System.out.print(t+"\n");
		}
		
	}

## ⚡ 字符串转字节处理

String.getBytes()方法可以将字串的字节数组导出，但特别要注意的是，本方法将返回该操作系统默认的编码格式的字节数组。在不同平台上，系统默认的代码页可能不一致，英文系统一般使用 iso-8859-1，中文系统有 GBK，不考虑到这一点软件就会有问题。例如如下示例代码，通过指定 UTF-16/UTF-8 来获取到字串的字节数据。注意 UTF-16 输出多了两个字节 0xFE 0xFF，这是BOM信息，字节顺序标记 Byte Order Mark，它有两个字节，值大的在后表示 BigEnding 大尾编码方式，通过 UTF-16BE/UTF-16LE 指定大端小端来去除这两额外的BOM字节。关于大尾小尾，前者表高有效位先编码，后者表示低有效位先编码，即对一个两字节的汉字来说，大尾表示高位的那个字节先编码输出。

	String a = new String("的J");

	byte[] as = a.getBytes("UTF-16");
	for( int i=0; i<as.length; i++){
		int c = as[i] & 0xFF;
		log( "Byte Code "+c+ " 0x"+Integer.toHexString(c) + " 0b"+Integer.toBinaryString(c) ); 
	}

	// UTF-16 的 字使用4个字节编码，英文字母2个字节
	Byte Code 254 0xfe 0b11111110
	Byte Code 255 0xff 0b11111111
	Byte Code 118 0x76 0b1110110
	Byte Code 132 0x84 0b10000100
	Byte Code 0 0x0 0b0
	Byte Code 74 0x4a 0b1001010

	// UTF-8 的 字使用3个字节编码，英文字母1个字节
	Byte Code 231 0xe7 0b11100111
	Byte Code 154 0x9a 0b10011010
	Byte Code 132 0x84 0b10000100
	Byte Code 74 0x4a 0b1001010

不同编码的字节顺序标记的表示编辑

	编码          表示 (十六进制)  表示 (十进制)
	UTF-8         EF BB BF       239 187 191
	UTF-16 大端序  FE FF          254 255
	UTF-16 小端序  FF FE          255 254
	UTF-32 大端序  00 00 FE FF    0 0 254 255
	UTF-32 小端序  FF FE 00 00    255 254 0 0


## ⚡ 复习Java运算符优先级

	优先级     描述          运算符
	1         括号          ()  []
	2         正负号         +  -
	3         自增自减非     ++    --  !
	4         乘除取余       *   /   %
	5         加减          +   -
	6         移位运算       <   >>   >>>
	7         大小关系       >   >=   <  <=
	8         相等关系       =   !=
	9         按位与         &
	10        按位异或       ^
	11        按位或         |
	12        逻辑与         &&
	13        逻辑或         ||
	14        条件运算       ?:
	15        赋值运算        =  +=  -=  *=  /=  %=
	16        位赋值运算      =  |=  <<=  >>=  >>>=


## ⚡ 复习Java基础数据类型

	Primitive type  Size      Minimum    Maximum   　　　　Wrapper type
	boolean         —         —          —       　　　　　Boolean
	char            16 bits   Unicode 0  Unicode 2^16-1   Character
	byte             8 bits  -128       +127              Byte
	short           16 bits  -2^15      +2^15-1           Short
	int             32 bits  -2^31      +2^31-1           Integer
	long            64 bits  -2^63      +2^63-1           Long
	float           32 bits   IEEE754    IEEE754          Float
	double          64 bits   IEEE754    IEEE754          Double
	void            —         —          —                Void

范围大的向范围小的数据类型转换时，需要考虑符号位的影响。如无符号整数就不能直接转为byte，值>127的正数都不行，视为负数。Java所有数值都是带符号的，没有无符号数值。反过来，处理byte数据时，如何无符号化处理？按补码的规律，byte数据如果为负数，可以+256来实现，正数不用处理，也可以和 0xFF 进行位与运算，这个位运算操作可以去掉转换后的数值的符号位。例如，下例中byte的-1转换到int时，通过与运算将int的符号位清零，这样实现byte数据的无符号化。

	byte myByte =(byte)0xff;
	int myInt = myByte & 0xFF;
	sytem.out.println( ""+(by & 0xff));
	sytem.out.println( ""+(by + 256) );

取得某正数的负数补码表达规则是，按位取反加1。1的负数是-1，补码就是对正1的十进位 00000001 取反得到 11111110，加1就得到 11111111，用16进位表示就是 0xFF。

	1的二进位表示 00000001           128的二进位表示 10000000
	1的二进位取反 11111110           128的二进位取反 01111111
	二进位取反加一 11111111          二进位取反后加一 10000000
	即得到1的对应负数补码 0xFF        128的对应负数-128的补码为 0x80，注意和128一样

计算机在读取数据进行运算时，会根据最高位即符号位来应用加减法则进行计算。现在根据补码值 0x81 反解出这个原值，字面上如果无称号处理0x81就是129，按减1求反得出负数对应的正值，即127，所以0x81这个补码对应的负数就是-127。

	byte by = (byte)129;
	System.out.println(""+(by));
	System.out.println(""+(by&0xff));
	System.out.println(""+(by+256));

## ⚡ Binary

	public static String byteToBinary(byte src) {  
	    StringBuilder result = new StringBuilder();  
	    for (int i = 0; i < 8; i++) {  
	        result.append(src%2 == 0 ? '0' : '1');  
	        src = (byte)(src >>> 1);  
	    }  
	    return result.reverse().toString();  
	}

## ⚡ Base16码表

	Index  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
	Encode 0 1 2 3 4 5 6 7 8 9  A  B  C  D  E  F

## ⚡ Base64码表

	Index  Char  Index  Char  Index  Char  Index Char
	0      A     16     Q     32     g     48     w
	1      B     17     R     33     h     49     x
	2      C     18     S     34     i     50     y
	3      D     19     T     35     j     51     z
	4      E     20     U     36     k     52     0
	5      F     21     V     37     l     53     1
	6      G     22     W     38     m     54     2
	7      H     23     X     39     n     55     3
	8      I     24     Y     40     o     56     4
	9      J     25     Z     41     p     57     5
	10     K     26     a     42     q     58     6
	11     L     27     b     43     r     59     7
	12     M     28     c     44     s     60     8
	13     N     29     d     45     t     61     9
	14     O     30     e     46     u     62     +
	15     P     31     f     47     v     63     /
	padding = 

## ⚡ URL and Filename safe Base 64 Alphabet

     Value Encoding  Value Encoding  Value Encoding  Value Encoding
         0 A            17 R            34 i            51 z
         1 B            18 S            35 j            52 0
         2 C            19 T            36 k            53 1
         3 D            20 U            37 l            54 2
         4 E            21 V            38 m            55 3
         5 F            22 W            39 n            56 4
         6 G            23 X            40 o            57 5
         7 H            24 Y            41 p            58 6
         8 I            25 Z            42 q            59 7
         9 J            26 a            43 r            60 8
        10 K            27 b            44 s            61 9
        11 L            28 c            45 t            62 - (minus)
        12 M            29 d            46 u            63 _ (underline)
        13 N            30 e            47 v        
        14 O            31 f            48 w
        15 P            32 g            49 x
        16 Q            33 h            50 y         (pad) .

Multipurpose Internet Mail Extensions (MIME)是Base64的另一种编码方案，广泛应用于文件的编码，MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据，如IE保存网页单文件MHT方式就是使用的MIME，Multipart message 编码信息参考：

	MIME-Version: 1.0
	Content-Type: multipart/mixed; boundary=frontier

	This is a message with multiple parts in MIME format.
	--frontier
	Content-Type: text/plain

	This is the body of the message.
	--frontier
	Content-Type: application/octet-stream
	Content-Transfer-Encoding: base64

	PGh0bWw+CiAgPGhlYWQ+CiAgPC9oZWFkPgogIDxib2R5PgogICAgPHA+VGhpcyBpcyB0aGUg
	Ym9keSBvZiB0aGUgbWVzc2FnZS48L3A+CiAgPC9ib2R5Pgo8L2h0bWw+Cg==
	--frontier--


## ⚡ Base32码表 - RFC 4648 alphabet

	Value   Symbol   Value   Symbol   Value   Symbol   Value   Symbol
	0       A        8       I       16       Q       24       Y
	1       B        9       J       17       R       25       Z
	2       C       10       K       18       S       26       2
	3       D       11       L       19       T       27       3
	4       E       12       M       20       U       28       4
	5       F       13       N       21       V       29       5
	6       G       14       O       22       W       30       6
	7       H       15       P       23       X       31       7
	padding =

# 🚩 JSON 数据转换

 
https://www.runoob.com/w3cnote/java-json-instro.html

Java中并没有内置JSON的解析，因此使用JSON需要借助第三方类库。下面是几个常用的 JSON 解析类库：

Gson: 谷歌开发的 JSON 库，功能十分全面。https://github.com/google/gson
FastJson: 阿里巴巴开发的 JSON 库，性能十分优秀。https://github.com/alibaba/fastjson/
Jackson: 社区十分活跃且更新速度很快。https://github.com/FasterXML/jackson



# 🚩 Java Lock 并发同步锁定
- https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter
- https://tech.meituan.com/2018/11/15/java-lock.html
- Doug Lea’s Home Page http://gee.cs.oswego.edu/
- 任务取消(Cancellation) http://ifeve.com/cancellation/
- 彻底理解 Synchronized https://www.jianshu.com/p/d53bf830fa09
- synchronized 详解 https://juejin.im/post/6844903482114195463
- 关于 synchronized 和 ReentrantLock 之多线程同步详解 - https://www.jianshu.com/p/96c89e6e7e90
- Java Fork/Join 框架 http://ifeve.com/java-fork-join-framework/
- 深入理解Java并发之synchronized实现原理 - https://blog.csdn.net/javazejian/article/details/72828483
- Java Concurrent Animated 看动画学并发 http://ifeve.com/java-concurrent-animated/
- JUC Abstract Queued Synchronizer 详细分析 https://www.jianshu.com/p/0da2939391cf
- [几种自旋锁的java实现](https://www.jianshu.com/p/824b2e4f1eed)

多线程代码中加锁，根本上就是将多线和执行变成单线执行，保证数据的正确性，所以加锁就会损失掉多线程带来的性能提升。

使用锁要优化加锁操作根据应用场景，尽量减少锁的时间，不需要同步执行的代码，能不放在同步快里面执行就不要放在同步快内，可以让锁尽快释放；细化锁的粒度，将物理上的一个锁，拆成逻辑上的多个锁，增加并行度，从而降低锁竞争。

基本概念：

- Pessimistic or Optimistic Locking 悲观锁与乐观锁
- Starvation and Fairness 饥饿与公平锁
- Pessimistic or Optimistic Locking 悲观锁与乐观锁
- Biased Locking 偏向锁
- ReentrantLock 重入锁
- ReadWriteLock 读写锁

有资源的锁定，那么在处理线程等待过程中就可能有出现死锁现象，四个必要条件：

- 互斥条件：一个资源每次只能被一个进程使用
- 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求
- 不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。
- 循环等待条件: 若干进程间形成首尾相接循环等待资源的关系。


并发编程三要素：

- **原子性**：指的是一个操作不能再继续拆分，要么一次操作完成，要么就是不执行。为了保证原子性，Java 提供了两个高级的字节码指令 monitorenter 和 monitorexit，这个就是关键字 synchronized 的内部实现。

- **可见性**：指的是一个变量在被一个线程更改后，其他的线程能立即看到最新的值，关键字 volatile 就是做这种事的。

- **有序性**：指的是程序的执行按照代码的先后顺序执行。

对于可见性和有序性，Java 提供了关键字 volatile 禁止指令重排，保证了有序性，同时 volatile 可以保证变量的读写及时从缓存中刷新到主存，也就保证了可见性。以外，synchronized 是可见性和有序性另外一种实现，同步方法和同步代码块保证一个变量在同一时间只能有一个线程访问，这就是一种先后顺序，而对于可见性保证，只能有一个线程操作变量，那么其他线程只能在前一个线程操作完成后才可以看到变量最新的值。

CAS - Compare And Swap 比较并交换技术，著名的并行计算专家 Doug lea 大神在同步组件中大量使用 CAS 技术鬼斧神工地实现了 Java 多线程的并发操作。整个 AQS 同步组件、Atomic 原子类操作等等都是以 CAS 实现的，甚至 ConcurrentHashMap 在 1.8 的版本中也调整为了 CAS + Synchronized，可以说 CAS 是整个 JUC 的基石。JUC 即是 Java 5.0 提供的 java.util.concurrent 并发包，在此包中增加了在并发编程中很常用的工具类,
用于定义类似于线程的自定义子系统，包括线程池，异步 IO 和轻量级任务框架。还提供了设计用于多线程上下文中的 Collection 实现等。

CAS 算法：

- 是硬件对于并发的支持，针对多处理器操作而设计的处理器中的一种特殊指令，管理对共享数据的并发访问;
- CAS 是一种无锁的非阻塞算法的实现;
- CAS 包含了三个操作数，需要读写的内存值 V、进行比较的预估值 A、拟写入的更新值 B；
- 当且仅当 V == A 时，赋值 V = B，否则将不做任何操作;

CAS虽然很高效，但是它也存在三大问题：

- ABA 问题。CAS 需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是 A，后来变成了 B，又变成 A，那么 CAS 进行检查时会发现值没有发生变化。ABA 问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从 “A－B－A” 变成了 “1A－2B－3A”。JDK 5 开始提供 AtomicStampedReference 类来解决 ABA 问题，具体操作封装在 compareAndSet() 中。首先会检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。

- 循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。

- 只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS 能够保证原子操作，但是对多个共享变量操作时，CAS 是无法保证操作的原子性的。
Java 1.5 开始提供 AtomicReference 类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行 CAS 操作。



要理解掌握不同的锁，就需要对多线程中使用到的资源读写场景进行分析：

- 资源要不要锁定操作？
	- 要锁定 -> 悲观锁
	- 不锁定 -> 乐观锁
- 资源要不要锁定读写操作？
	- 读取要锁定 -> 读锁
	- 写入要锁定 -> 写锁
- 资源锁定失败，要不要阻塞线程？
	- 进入阻塞等待 -> 同步锁
	- 不阻塞 -> 自旋锁、适应性自旋锁 
- 多线程竞争资源锁定要不要排队？
	- 排队 -> 公平锁
	- 插队 -> 非公平锁
- 线程能否重复获取同一个锁定对象？ 
	- 可以 -> 可重入锁
	- 不能 -> 非重入锁
- 线程能否共享同一个锁定对象？ 
	- 可以 -> 共享锁
	- 不能 -> 排他锁 Mutex
- 多线程竞争同步资源的程序细节有什么差别？
	- 不锁定资源，多线程只有一个成功修改资源
	- 同一个线程执行同步资源时自动获取资源 -> 偏向锁
	- 多个线程竞争同步资源时，没有获取到资源的线程自旋等待 -> 轻量级锁
	- 多个线程竞争同步资源时，没有获取到资源的线程阻塞等待唤醒 -> 轻量级锁

乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。

**悲观锁**认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。

**乐观锁**则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。

悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。

简单理解下悲观锁：当一个事务锁定了一些数据之后，只有当当前锁提交了事务，释放了锁，其他事务才能获得锁并执行操作。 悲观锁一般是用于并发不是很高，并且不允许脏读等情况，但是对数据库资源消耗较大。

	set autocommit = 0;
	bigen --开启事务
	select id, total, front, end from price where id=1 for update 
	insert into price values(?,?,?,?,?)
	commit --提交事务

这里使用 select for update 的方式利用数据库开启了悲观锁，锁定了 id=1 的这条数据，注意:这里除非是使用了索引会启用行级锁，不然是会使用表锁，将整张表都锁住。。之后使用commit提交事务并释放锁，这样下一个线程过来拿到的就是正确的数据。

相对比的是更好的并发加锁方式，乐观锁首先假设数据冲突很少，只有在数据提交修改的时候才进行校验，如果冲突了则不会进行更新。乐观锁在实际应用相对较多，它可以提供更好的并发访问，并且数据库开销较少，但是有可能存在脏读的情况。


偏向锁/轻量级锁/重量级锁这三种锁是指锁的状态，并且是针对 Synchronized。

在 Java 5 通过引入锁升级的机制来实现高效 Synchronized。

**偏向锁**是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况。

如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM 会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。

**轻量级锁**是指偏向锁被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。

**重量级锁**是指轻量级锁中，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。


**自旋锁**原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等，即进入自旋状态。等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。

但是线程自旋是需要消耗 CUP 时间的，说白了就是让 CUP 在做无用功，如果一直获取不到锁，那线程也不能一直占用 CUP，所以需要设定一个自旋等待的最大时间。

如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，这时竞争线程会停止自旋进入阻塞状态。

自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！

**自适应自旋锁**意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。

在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock


**公平锁**是指多个线程按照申请锁的顺序来获取锁。

**非公平锁**是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。

**可重入锁**又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。一个好处是可一定程度避免死锁，比如两个相互调用的方法 A 和 B，如果不是可重入锁的话，在加锁的时候调用对方可能造成死锁。


对于 ReentrantLock 而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁，它的优点在于吞吐量比公平锁大，ReentrantLock 例化时传入 true 可以那建立公平锁。

	ReentrantLock()	
	ReentrantLock​(boolean fair)

对于 Synchronized 而言，也是一种非公平锁，也是一个可重入锁。但并不像 ReentrantLock 通过 AQS - Abstract Queued Synchronizer 来实现线程调度，所以并没有任何办法使其变成公平锁。


**排它锁**也叫独享锁，是指该锁一次只能被一个线程所持有。**共享锁**是指该锁可被多个线程所持有，互斥锁/读写锁就是具体的实现。

对于 ReentrantLock 而言，是独享锁、互斥锁，但是对于 Lock 的另一个实现类 ReadWriteLock，读取锁定是共享的，其写入锁定是独享锁，共享读取锁可保证并发读取高效。

独享锁与共享锁也是通过 AQS 来实现的，通过实现不同的方法来实现独享或者共享。

对于 Synchronized 而言，当然是独享锁。

 Java 中的具体实现就是 ReentrantLock。

**读写锁**在 Java 中的具体实现就是 ReadWriteLock，管理着一组锁，一个是只读的锁，一个是写锁。读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的。 所有读写锁的实现必须确保写操作对读操作的内存影响。换句话说，一个获得了读锁的线程必须能看到前一个释放的写锁所更新的内容。 读写锁比互斥锁允许对于共享数据更大程度的并发。每次只能有一个写线程，但是同时可以有多个线程并发地读数据。ReadWriteLock 适用于读多写少的并发情况。 Java 并发库中 ReentrantReadWriteLock 实现了 ReadWriteLock 接口并添加了可重入的特性。


**分段锁**其实是一种锁的设计，并不是具体的一种锁，对于 ConcurrentHashMap 而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。

分段锁的含义以及设计思想，ConcurrentHashMap 中的分段锁称为 Segment，它继承自 ReentrantLock。类似于 JDK 8 HashMap 的实现，即内部拥有一个 Entry 数组，数组中的每个元素又是一个链表，同时又是一个 ReentrantLock。

当需要 put 元素的时候，并不是对整个 hashmap 进行加锁，而是先通过 hashcode 来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程 put 的时候，只要不是放在一个分段中，就实现了真正的并行的插入。

但是，在统计 size 的时候，可就是获取 hashmap 全局信息的时候，就需要获取所有的分段锁才能统计。

分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。

Java 各种锁对象：

|         类对象         |            锁类型            |      适用场景      |
|------------------------|------------------------------|--------------------|
| ReentrantLock          | 互斥锁                       | 数据一致性         |
| ReentrantReadWriteLock | 可重入读写锁                 |                    |
| ReadWriteLock          | 共享读取锁、独享写入锁       | 高性能读取         |
| StampedLock            | 戳锁，排它写，悲观读，乐观读 | 需要高性能读取场合 |




## ⚡ Semaphores 信号量 

信号量 Semaphores 机制是一种卓有成效的进程同步工具，由荷兰学者 Dijkstra 提出。

信号量的值仅能由 PV 操作来改变。

- P 操作（wait）申请一个单位资源，然后进程进入。
- V 操作（signal）释放一个单位资源，然后进程出来。

Semaphore 信号量维护一定数量的特权，当特权有余量，线程通过 acquire 方法可以获取到代码执行特权，用完后使用 release 方法归还这。

Semaphore 可以用于流量控制，特别是对并发数有限制的场景。如数据库同时只允许有 20 个线程访问，就可以使用信号量来实现。

当特权使用完后，线程再执行 acquire 就会进入同步阻塞，等待其它线程归还特权后，再继续获取特权执行同步代码。

    Semaphore​(int permits) 
    Semaphore​(int permits, boolean fair)

构造函数可以指定是是使用公平锁，默认是 nonfair fairness。

常用方法：

- void	acquire()	获取代码执行特权
- void	acquire​(int permits) 获取指定数量代码执行特权
- int	drainPermits()		将现有的特权清空
- boolean	tryAcquire()	尝试获取一个代码执行特权，如果在调用期无结果就退出
- boolean	tryAcquire​(int permits)	同上，但指定了需要的特权数量
- void	release()	释放特权，装饰特权归还 Semaphore 对象管理
- void	release​(int permits) 同上，指定了特权数量


## ⚡ Synchronized 重量级同步锁

在 JDK1.5 之前都是使用 synchronized 关键字保证同步的，它可以把任意一个非 NULL 对象当作锁定对象。

作用于方法时，锁住的是对象的实例(this)； 当作用于静态方法时，锁住的是 Class 实例，又因为 Class 的相关数据存储在永久带 PermGen（JDK 1.8 则是 metaspace）。永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程；

synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。

Synchronized 通过监视队列实现目标锁定，有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。

- **Contention List**：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；
- **Entry List**：Contention List中那些有资格成为候选资源的线程被移动到Entry List中；
- **Wait Set**：哪些调用wait方法被阻塞的线程被放置在这里；
- **OnDeck**：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为OnDeck；
- **Owner**：当前已经获取到所资源的线程被称为Owner；
- **!Owner**：当前释放锁的线程。

JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行 CAS - Compare and Swap 访问，为了降低对尾部元素的竞争，JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。Owner 线程会在 unlock 时将 ContentionList 中的部分线程迁移到 EntryList 中，并指定 EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在 JVM 中，也把这种选择行为称之为竞争切换。

OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList。如果 Owner 线程阻塞在 wait 方法，则转移到 WaitSet 队列中，直到某个时刻通过 notify 或者 notifyAll 唤醒，会重新进去 EntryList 中。

处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的，Linux 内核下采用 pthread_mutex_lock 内核函数实现。

对比 synchronized、ReentrantLock 两者的区别：

|          |            synchronized            |          ReentrantLock          |
|----------|------------------------------------|---------------------------------|
| 调度机制 | 使用对象的 wait、notify、notifyAll | 与 Condition 结合进行线程的调度 |
| 设置方式 | 显式的使用在同步方法或者同步代码块 | 显式的声明指定起始和结束位置    |
| 释放方式 | 托管给 JVM 自动执行                | 手动释放锁                      |

JDK 1.6 之前 ReentrantLock 性能优于 synchronized，不过之后的 synchronized 做了大量的性能调优，而且 synchronized 相对程序员来说，简洁熟悉，如果不是 synchronized 无法实现的功能，如轮询锁、超时锁和中断锁等，推荐首先使用 synchronized，而针对锁的高级功能，再使用 ReentrantLock。
 

Synchronized 同步锁用法：

1. 修饰一个代码块，被修饰的代码块称为同步语句块，同步作用于这个代码块的对象；
2. 修饰一个方法，称为同步方法，其作用的范围是整个方法，同步作用于调用这个方法的对象；
3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有实例；
4. 修改一个类，其作用的范围是 synchronized 后面括号括起来的部分，作用于这个类的所有实例。

使用示范；

    public void method()
    {
       synchronized(this) {
          // todo
       }
    }

    public synchronized void method()
    {
       // todo
    }

    public synchronized static void method() {
       // todo
    }

    class ClassName {
       public void method() {
          synchronized(ClassName.class) {
             // todo
          }
       }
    }

synchronized 修饰一个方法为同步方法，但不能在构造器上使用。同步加锁的是对象，而不是代码。

- 修饰实例方法，相当于 synchronized(this);
- 修饰静态方法，相当于 synchronized(this.class);
- 修饰代码块的形式是 synchronized(Object)。

如果锁的是类对象 class，尽管 new 多个实例对象，但他们仍然是属于同一个类依然会被锁住，线程之间保证同步关系，给 class 加同步锁和给静态方法加锁一样。


Java Virtual Machine Specification 文档中提到 monitorenter 和 monitorexit 用于锁定状态的切换。每个对象有一个监视器 monitor，它被占用时对象就处于锁定状态。线程执行 monitorenter 指令尝试获取 monitor 的所有权，过程如下：

- 如果 monitor 的进入数为 0，则该线程进入 monitor，然后将进入数设置为 1，该线程拥有锁定对象的使用权。
- 如果线程已经占有该 monitor，只是重新进入，则进入 monitor 的进入数加 1。
- 如果其他线程已经占用 monitor，则该线程进入阻塞状态，直到 monitor 的进入数为 0，再重新尝试获取 monitor 的所有权。

代码块同步在编译后，通过将 monitorenter 指令插入到同步代码块的开始处，将 monitorexit 指令插入到方法结束处和异常处，通过反编译字节码可以观察到。任何一个对象都有一个 monitor 与之关联，线程执行 monitorenter 指令时，会尝试获取对象对应的 monitor 的所有权，即尝试获得对象的锁。

方法同步方式，synchronized 方法在 method_info 结构有 ACC_synchronized 标记，线程执行时会识别该标记，获取对应的锁，实现方法同步。

两者虽然实现细节不同，但本质上都是对一个对象的监视器 monitor 的获取。


Synchronized 为非公平锁，在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是，自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。

synchronized 它无法保证等待的线程获取锁的顺序，而 Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作，它能以更优雅的方式处理线程同步问题。这样就实现了和 sychronized 一样的同步效果，需要注意的是，用 sychronized 修饰的方法或者语句块在代码执行完之后锁自动释放，而用 Lock 需要我们手动释放锁，所以为了保证锁最终被释放(发生异常情况)，要把互斥区放在 try 内，在 finally 内释放锁。

	import java.util.concurrent.locks.Lock;
	import java.util.concurrent.locks.ReentrantLock;

	public class coding {

		private static Lock lock = new ReentrantLock();
		//private static Lock lock = new ReentrantLock(true);
		
		public static void main(String[] args) {
			new Thread() {
				public void run() {
					log("T0 "+Thread.currentThread().getName());
				};
			}.start();
			new Thread() {
				public void run() {
					log("T1 "+Thread.currentThread().getName());
				};
			}.start();
		}

		static public void log(String t) {
			for ( int i=0; i<5; i++) {
				lock.lock();
				try {
					System.out.println(t);
					Thread.sleep(600);
				}catch(Exception e){
					e.printStackTrace();
				} finally {
					lock.unlock();
				}
			}
		}

	}

可以将上面代码中 log 改造为 synchronized 同步锁，只需要在方法成员声明中添加这个关键字，并去掉Lock相关的两行代码即可，这样这个方法就会具有非公平的同步锁功能，代码执行完之后锁自动释放。

	static synchronized public void log(String t) {
		for ( int i=0; i<10; i++) {
			// lock.lock();
			try {
				System.out.println(t);
				Thread.sleep(800);
			}catch(Exception e){
				e.printStackTrace();
			} finally {
				// lock.unlock();
			}

		}
	}

synchronized 等待唤醒机制提供了 wait 和 notify 等方法用于多线程协调运行：

- this.wait() 使线程进入等待状态，必须在已获得的锁对象上调用 wait() 方法；
- this.notify() 或 this.notifyAll() 唤醒其他等待线程；

已唤醒的线程还需要重新获得锁后才能继续执行。

使用 sleep() 和 wait() 方法使用线程进入睡眠的区别：

- sleep() 睡眠时，保持对象锁，仍然占有该锁； 
- wait() 睡眠时，释放对象锁。 


Lock 接口的出现替代了同步代码块或者同步函数，将其隐式锁操作变成显式锁操作，同时更为灵活，可以在一个锁上加上多个监视器。

Lock 接口中的方法:

- lock(): 获取锁
- unlock(): 释放锁, 这个动作是必须要完成的, 所以通常需要定义在 finally 代码块中
- tryLock​(long time, TimeUnit unit) 尝试等待指定时间，超时就进入中断退出
- lockInterruptibly() 尝试获取锁并在线程中断后退出
- newCondition() 返回条件监视器

Condition 接口的出现替代了 synchronized 中的 wait()、notify()、notifyAll() 等方法，将这些
监视器方法单独进行了封装，变成 Condition 监视器对象，可以与任意锁进行组合。

Condition 对象常用方法：

- await(): 让线程处于冻结状态
- signal(): 唤醒一个等待线程
- signalAll(): 唤醒所有等待线程

线程的 interrupt() 方法可以终止线程的执行。

参考 Java Concurrent Animated 项目，用一系列的动画来演示 Java 并发库组件和代码，效果更好。


## ⚡ volatile 敏感同步
- Java 并发编程 volatile https://www.cnblogs.com/iou123lg/p/9280639.html
- Managing volatility https://www.ibm.com/developerworks/java/library/j-jtp06197/
- Chapter 17. Threads and Locks https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html
- https://manybutfinite.com/post/what-does-an-idle-cpu-do/
- https://www.cnblogs.com/zhangj95/p/5647051.html#what-does-an-idle-cpu-do
- https://javatutorial.net/java-volatile-example

volatile 是 Java 提供的一个比 synchronized 更轻量级的实现，synchronized 实现了数据在同一时刻只能有一个线程对数据访问，而 volatile 实现的就是同时可以多个线程在访问数据，但是只要数据发生了变化，便确保其他线程及时感知这种变化。

计算机的硬件组成可以抽象为由总线、IO 设备、主存、CPU 等组成。其中数据存放在主存中，CPU 负责指令的执行，CPU的指令执行非常快，大部分简单指令的执行只需要一个时钟周期，而一次主内存数据的读取则需要几十到几百个时钟周期，那么 CPU 从主存中读写数据就会有很大的延迟，这就产生了 L1/L2/L3 级高速缓存的概念。

也就是说，当程序在运行过程中，会将运算需要的数据从主存复制一份到 CPU 内部高速缓存当中。那么 CPU 进行计算时就可以直接从它的高速缓存读写入数据，当运算结束之后，再将高速缓存中的数据回写到主存当中，通过这种方式来降低 CPU 从主存中获取数据的延迟。

在多内核 CPU 架构中，硬件内存架构中存在的一个问题，缓存一致性问题。比如说核 A 改变了缓存变量 i 的值之后，核 B 是不知道的，存放的还是旧值，最终对这样的一个脏数据进行操作。

为此，CPU 厂商定制了相关的规则来解决这样一个硬件问题，主要有总线加锁和缓存加锁方式。

变量会从主内存复制到高速缓存，计算完成后，会再回写到主内存，而高速缓存和主内存的交互是会经过总线的。既然变量在同一时刻被多个 CPU 同时操作，会带来脏数据，那么只要在总线上阻塞其他 CPU，确保同一时刻只能有一个 CPU 对变量进行操作，后续的 CPU 读写操作就不会有脏数据。总线锁的缺点也很明显，有点类似将多核操作变成单核操作，所以效率低。

缓存锁，即缓存一致性协议，主要有 MSI、MESI、MOSI 等，这些协议的主要核心思想：当 CPU 写数据时，如果发现操作的变量是共享变量，即在其他 CPU 中也存在该变量的副本，会发出信号通知其他 CPU 将该变量的缓存行置为无效状态，因此当其他 CPU 需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。


JVM 规范中试图定义一种 Java 内存模型 JMM - Java Memory Model 来屏蔽各个硬件平台和操作系统的内存访问差异，以实现在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言 C/C++ 等直接使用物理硬件和操作系统的内存模型，可以理解为类似于直接使用了硬件标准，都或多或少的在不同的平台有着不一样的执行结果。　

JMM 的主要目标是定义程序中各个变量的访问规则，即变量在内存中的存储和从内存中取出变量这样的底层细节。其规定了所有变量都存储在主内存，每个线程还有自己的工作内存，线程读写变量时需先复制到工作内存，执行完计算操作后再回写到主内存，每个线程还不能访问其他线程的工作内存。

工作内存可以看成是 CPU 高速缓存、寄存器的抽象，主内存可以看成就是物理硬件中主内存的抽象。

为了获得较好的执行性能，JMM 并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在 JMM 中还会存在指令重排序的问题。

Java 语言又是怎么来解决这两个问题的呢？就是通过 volatile 这个关键字来解决缓存一致性和指令重排问题，volatile 作用就是确保可见性和禁止指令重排。


## ⚡ Starvation and Fairness 饥饿与公平
- [Java 并发之饥饿和公平锁 Starvation and Fairness](https://cloud.tencent.com/developer/article/1193092)

如果一个线程的cpu执行时间都被其他线程抢占了，导致得不到 CPU 执行，这种情况就叫做饥饿，这个线程就会出现饥饿致死的现象，因为永远无法得到 CPU 的执行。解决饥饿现象的方法就是实现公平，保证所有线程都公平的获得执行的机会。

饥饿发生的原因：
 
- 高优先级的线程占用了大部分的 CPU 时间，低优先级线程发生饥饿；
- 线程被永久堵塞在一个等待进入同步块的状态；
- 线程在等待一个处于永久等待完成的对象；

虽然无法实现完全 100% 公平，但是我们仍然可以尽可能的提高线程的公平性。

首先，我们研究一个简单的 synchronize 同步块：

	public class Synchronizer{

	  public synchronized void doSynchronized(){
	    //do a lot of work which takes a long time
	  }

	}

如果超过一个线程调用这个方法，那么只有一个线程可以进入这个方法执行，其他线程都必须等待，直到该线程退出。而且我们无法知道下一个进入 synchronize 的语句块的线程会是那一个

使用 lock 而不是 synchronize 增加等待线程的公平性：

	public class Synchronizer
	{
	  Lock lock = new Lock();

	  public void doSynchronized() throws InterruptedException{
	    this.lock.lock();
	      //critical section, do a lot of work which takes a long time
	    this.lock.unlock();
	  }

	}

Lock 简单的实现：

	public class Lock {
	  private boolean isLocked      = false;
	  private Thread  lockingThread = null;

	  public synchronized void lock() throws InterruptedException{
	    while(isLocked){
	      wait();
	    }
	    isLocked      = true;
	    lockingThread = Thread.currentThread();
	  }

	  public synchronized void unlock(){
	    if(this.lockingThread != Thread.currentThread()){
	      throw new IllegalMonitorStateException(
	        "Calling thread has not locked this lock");
	    }
	    isLocked      = false;
	    lockingThread = null;
	    notify();
	  }
	}


10 Fork/Join 框架
public class TestForkJoinPool{
    public static void main(String[] args){
        ForkJoinPool pool = new ForkJoinPool();

        ForkJoinTask<Long> task = new ForkJoinSumCalculate(0L, 100000000L);

        Long sum = pool.invoke(task);

        System.out.println(sum);
    }

}

class ForkJoinSumCalculate extends RecursiveTask<Long>{

    private static final long serialVersionUID = 24340990L;

    private long start;
    private long end;

    private static final long THURSHOLD = 10000L;  // 拆分临界值

    // 有参构造器
    public ForkJoinSumCalculate(long start, long end){
        this.start = start;
        this.end = end;
    }

    public Long compute(){
        long length = end - start;

        if(length <= THURSHOLD){
            long  sum = 0L;

            for(long i = start; i<=end; i++){
                sum += i;
            }
            return sum;
        }else{
            long middle = (start + end ) / 2;
            ForkJoinSumCalculate left = new ForkJoinSumCalculate(start, middle);
            left.fork(); // 进行拆分,同时压入线程队列

            ForkJoinSumCalculate right = new ForkJoinSumCalculate(middle + 1, end);
            right.fork(); // 进行拆分,同时压入线程队列

            return left.join() + right.join();
        }
    }
}


## ⚡ Atomic 原子包

java.util.concurrent.atomic 是一个小型工具包，支持对单个变量进行无锁线程安全编程。

类的实例 AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference 各自提供访问和更新相应的类型的单个变量。 每个类还为该类型提供适当的实用方法。

例如，AtomicLong 和 AtomicInteger 提供原子增量方法，如一个生成序列号的程序：

	class Sequencer { 
	private final AtomicLong sequenceNumber = new AtomicLong(0); 
		public long next() { 
		    return sequenceNumber.getAndIncrement();
		}
	} 

|                类                 |                                     描述                                     |
|-----------------------------------|------------------------------------------------------------------------------|
| AtomicBoolean                     | 可以原子方式更新的值 boolean 。                                              |
| AtomicInteger                     | 可以原子方式更新的 int值。                                                   |
| AtomicIntegerArray                | 一个 int数组，其中元素可以原子方式更新。                                     |
| AtomicIntegerFieldUpdater<T>      | 基于反射的实用程序，可对指定类的指定 volatile int字段进行原子更新。          |
| AtomicLong                        | 可以原子方式更新的 long值。                                                  |
| AtomicLongArray                   | 一个 long数组，其中元素可以原子方式更新。                                    |
| AtomicLongFieldUpdater<T>         | 基于反射的实用程序，可以对指定类的指定 volatile long字段进行原子更新。       |
| AtomicMarkableReference<V>        | AtomicMarkableReference维护一个对象引用以及一个标记位，可以原子方式更新。    |
| AtomicReference<V>                | 可以原子方式更新的对象引用。                                                 |
| AtomicReferenceArray<E>           | 一组对象引用，其中元素可以原子方式更新。                                     |
| AtomicReferenceFieldUpdater<T,​V> | 基于反射的实用程序，可以对指定类的指定 volatile引用字段进行原子更新。        |
| AtomicStampedReference<V>         | AtomicStampedReference维护一个对象引用以及一个整数“标记”，可以原子方式更新。 |
| DoubleAccumulator                 | 一个或多个变量共同维护使用提供的函数更新的运行 double值。                    |
| DoubleAdder                       | 一个或多个变量共同维持最初的零和 double总和。                                |
| LongAccumulator                   | 一个或多个变量共同维护使用提供的函数更新的运行 long值。                      |
| LongAdder                         | 一个或多个变量共同维持最初为零的总和为 long 。                               |

内部 compareAndSet 方法使用 Unsafe 调用 native 原生方法 CAS（CompareAndSet）递增数值。

    public final boolean compareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }

CAS 利用 CPU 调用底层指令实现，单一处理器，进行简单的读写操作时，能保证自身读取的原子性，多处理器或复杂的内存操作时，CAS 采用总线加锁或缓存加锁方式保证原子性。

在多核心 CPU 中使用总线加锁，如 i=0 初始化，多处理器多线程环境下进行 i++ 操作下，处理器核心 A 和 B 同时读取 i 值到各自缓存，分别进行递增，回写值 i=1 相同。处理器提供 LOCK# 信号，进行总线加锁后，处理器 A 读取 i 值并递增，处理器 B 被阻塞不能读取 i 值。

总线加锁，在 LOCK# 信号下，其他线程无法操作内存，性能较差，缓存加锁能较好处理该问题。

缓存加锁，处理器核心 A 和 B 同时读取 i 值到缓存，处理器 A 提前完成递增，数据立即回写到主内存，并让处理器 B 缓存该数据失效，处理器 B 需重新读取 i 值。


	import java.util.concurrent.atomic.*;

	public class AtomicDemo extends Thread 
	{
	    private static final AtomicInteger TEST_INT = new AtomicInteger();

	    @Override
	    public void run() {
	        if (TEST_INT.intValue()<100) TEST_INT.incrementAndGet();
	    }

	    public static void main(String[] args) {
	        for (int i = 0; i < 1000; i++) {
	            AtomicDemo demo = new AtomicDemo();
	            demo.start();
	            // demo.join();
	        }
	     
	        System.out.println("最终结果："+TEST_INT);
	    }
	}

